Hello, thank you for being here. Today we will talk about VHS Form Validation with VValidate V4. So let's get to it. First a little bit about me. I am up to Ramanabad, a Front Engine Engineer at Octobuts. I created and maintained VValidate for VHS since 2016. I wrote about JavaScript TypeScript VHS on my blog. So check it out if you are interested in that type of content. Also you can give me a follow at Logarit.com Twitter. So forms are hard but what makes them so. There are various pain points when it comes to forms manifesting in as friction in a lot of areas and I have identified the most painful areas to be these ones or at least the most common ones that we run into. And this is also seen in other libraries. So most libraries try to address the issues for the developer. So this start with Vavitracking. So Vavitracking is really complicated because it depends on how you accept this and declare your forms. If you are using native HTML elements and you don't really have JavaScript going on here, then Vavitracking is done automatically for you because that's native HTML behavior when it submits the form to some packing server using full page reloads. But if you have JavaScript forms, then it becomes a lot more involved because you need to have two way bindings between your inputs and your data models in memory and keep them synced. This can be tricky and there is a lot of caveats here for example the field types like check boxes, radio buttons and file inputs. So each really file type really has its own quirks that you need to take into account when tracking your form values. The other pinpoint is validation error messages. So with validation can be really simple or it can be really complicated again based on your needs. For example, you can have synchronous validation or you can have a pipeline of asynchronous validations building on top of each other. So managing this can be really difficult. Also the way and the style of you expressing your validation intent, is it global validations that you call upon using some kind of friendly string formats like Laraville or other frameworks or is it explicit functions, explicit JavaScript functions that you import and pass around explicitly to make everything clear. So it really depends on your use case. Also error messages, it can be really hard to normalize the generation of error messages because error messages are complicated and it begins with how you phrase them. So if you include the field name in the error message like this field or this email field is required or this name field is required, you have an issue here because you have to include the field name in the generated message. But if you avoid that and use simpler messages like this field is required, this field must be a valid email, then you escape this but there is localization and not all of languages agree that you can be neutral about fields. So it is really complicated. There is also the UI and UX aspect and forms are tedious. Users hate filling out forms and you as a form filler, really you hate this and as it's available you probably hate them as well. So the issue is forms here is if they are repetitive and you might be asking a lot for information here. So if the experience is really poor or really frustrating, the user won't bother and you will be testing their patients. So depending on how much fun the interaction with the firm is, the user may choose to fill out the form or lose patients and maybe decide it's not worth it to go through this. So yeah and this defeats the whole purpose of having a form, right? You only have it to collect some values and yeah, there is also organization. So let's say you are building a really complex admin dashboard application and this admin dashboard application has a lot of crud and a lot of crud forms and crud pages and these forms usually exist in two modes, create and edit. So in that case how are you going to organize all of these validation rules, all of these fields, all of these forms and messages. That's a lot of stuff to organize. So the validation library should give you at least some kind of units of organization that allow you to do something like that. There is also the bugging and the verbiage experience. Most validation libraries don't really have any debugging tools and this can be really frustrating and can send you in a wild boost chase when you have this form that isn't submitting and you can't really figure out why it's not submitting. So having the bugging tools is really beneficial here. So Vvalid tries to address some of these issues but let's talk more about it first. Vvalid is currently the most popular uses form validation library at around 1.4 million downloads per month and 8.6 K stars on GitHub. So with that out of the way let's talk about the goals. The goal of Vvalid is to solve these main points and using the word solve can be a lot of claim here. So at least it will reduce the friction that you encounter with these pain points. But it does a really good job at reducing that friction and we'll see a lot of examples on each of these points. Also it tries to offer a progressive VBI to match the VGS ideology. So VGS has this ideology or mantra of it being the progressive JavaScript framework and it really does a good job of doing so. So what does it mean? It means VGS caters to those who are using it as an enhancement layer for their application. So for those who just want to sprinkle some JavaScript into their application to make some widgets interactive and some aspects of their page interactive without having to do everything in JavaScript. This really offers a really good job for that use case because you can import it from the CDN and integrate it right into your application. With really minimum effort and really minimum setup you don't really have to set up web pack or a really complicated store and stuff to get it working. On the other hand you have those who want to build a fully working single page application that uses VGS for routing, state management and rendering, so everything. For these developers VGS scales well to match their needs. So VBI validate tries to follow that guideline to be really easy to integrate with minimum effort almost like a certain replace manner. But also catering for those who want to do more and want to do a lot of and get a lot of benefit out of the tool that they are using. There is also the composition first design approach. The composition of the VBI is similar to the ReactOXIBI which allows you as a developer to integrate third-party logic into your own components. Also first part logic of course. It allows you to integrate some kind of logic into your own components in a really reusable manner. So Vivided doubles down on that and you will see in a few minutes how it does so. So first let's talk about the building blocks. So this is the most basic form you have. You have a form element and an input element. So let's say you want to convert this form to a Vivided form. All you have to do is remove the form element and use the form component. Notice the difference is the upper case form component. The first letter is upper case. And the input element was removed and we added the field component instead. And that's it. So it's almost assertion replace API. But of course there are a lot more to it than that. But this is the basic way to get Vivided into your project and having the same exact render output as the previous native forum. So let's talk about the first pain point value tracking. This typical forum usually have this three sections inside it. Has state binding, state declaration and value retrieval. So the state binding section contains the markup for your elements and it is two way bind it to your state declaration or one way bind it depending on your needs. There is also the value retrieval section where you retrieve the values that you have declared so you can send them to the server. The problem with this is there is some friction here and it can be too much friction if you have really large forums. And say you want to add a field if you added this field you may forget to bind it to your state or you may forget to retrieve it before sending it to the API and that means the forum may be missing some data or maybe maybe not working as you have expected. And this is a friction I'm talking about here. So Vivided tries to reduce it or completely eliminate it by reducing it to a single section. So you only have to declare your fields and give it a name. That name can act as a field path in the model tree. So for example here we replaced all the inputs with the field component and Vivided will automatically create the models for them and bind the elements, the input elements to that to these models. Another thing is another benefits is you can use JavaScript object syntax or erase syntax to express nested fields. So we have the links fields here. We have links of these zero and links of one and when Vivided sees it it understands that you want to create a field element that is tracked in the first element of an array called links and you want to create another field that is tracked in the second element of the array called links of links. So it creates that tree for you. It traverses the names into a form tree, it generates it for you and retrieves it for you automatically when you try to submit that form and really that reduces a lot of effort here. So if you need to add a field use that throw it in the form and you are done. So let's talk about the most important aspect and it's in the name of the library validation. So we developers come from different backgrounds. Me myself I was a backend engineer, a lot of backend engineer, then a Node.js backend engineer, then switched over to a front end. So with this I have a lot of experience of how each ecosystem expresses their validation and that really gives me ideas on how and the best way for each use case. For example you always need to have a baseline so having a JavaScript functions as a baseline is really makes sense and it's a must have. So having JavaScript functions as act as your validator opens the door for using third birthday libraries like validator.js and custom functions. So it's really important to have it. Also integrations with other frameworks or in inspiration from other frameworks. For example there is the backend that inspires string expression that's inspired with larval validation syntax. Larval validation syntax is very easy, very compact and easily maintainable and because of their global nature so they need to be defined globally that makes them really, really useful in applications when you have a lot of forms. So admin dashboards for example and in these forms you really need to call upon validation library validation rules without having to worry about declaring them each time you need to use them. So this really makes sense here. There is also the schema validators that you can use to build really complex and really dynamic validation schemas using the app and so many others. You can use them to make for example a field is required when another field in the forum is bigger than five. So you really can really make these arbitrary conditions and you can pretty much build whatever dynamic schemas that you want to validate your forms. So let's see what each one looks like. With JavaScript function this is really straightforward. You create a function that function receives the value. Then you can either return a Boolean like true and the field turns through that means that the field is valid. Otherwise you can return a string and that says this is the error message for that field. This field is invalid and this is the error message. This is straightforward and all you have to do is pass it to the rules property of the field component. Field validation was a lot of rules is similar but it uses strings. So you grab the combined library called at Vvalid slash rules and you basically grab the rules that you will need and you define them in your application. Note that you only have to do this once so you don't really need to do this in each component. You can do it at the interborn to your application and not worry about it again. And once you define them you can call upon them using string. So in the rules property you can pass a string that's expressed as required pipe email. So this is a required email field. You can use the up schemas to validate your fields. So in this example right here we grab the string schema from yep and use it to build up a required email schema and we pass that schema to the field. Same property rules and Vvalidate has first class support for it and we'll understand that you want to do schema validation using this schema. Another thing that's really exciting here is you can use these schemas specifically object schemas to specify a validation schema for the entire form. So you no longer have to specify a validation rule for each field and this really makes it much more easier to reason about the validation rules of that form. So you don't have to go back and forth between the script and the simple little lot and this reduces this friction as well. So there is some friction here but you can completely eliminate it by using validation schemas. Then you define on your schema object. For example here we have an object schema that contains an email, that is a required email, a name field that is a required string and another string called password that is required and can must be minimum six characters long and this will allow Vvalidate to use the schema for your fields. It will validate each field according to the schema and it will automatically assign the error messages properly according to the schema. So this makes it really easy to maintain such forms and makes it really pleasant to use them. So let's talk about the progressive integration aspect. Right here we have this basic form, really basic form that uses the full page reload to submit the data which is the native way to submit your forms. So this form submits their post method. These four fields through the action endpoint slash register and typically you have this in your backend application or in your backend render application. And the allowable can be Rails or it can be plain old PHP or plain old whatever. So this form typically behaves like this, you submit the form and it performs a full page reload, the server validates and the directs you back to the form if there are any errors or errors otherwise it will move on to the next page, log you in or whatever. But let's say you want to add some sprinkles some JavaScript here to spice it up a little bit. For example, you want to prevent submission if the form is invalid and submit using exactly the same flow if everything is valid. So you can do that using search and replace. It can be as easily as this. So you remove the form elements and use the form components, you remove the input elements and use the field components. And we also add the error message component that we use to display errors. Each error message component can have a name which is the same name of the field that it will display the error message for. So it needs to match the field names. Also we need to provide the validation schema and in any of the ways that we saw before or you can provide for each field its own rules, it doesn't really matter. But validation schemas I really recommend using them whenever you can. But right here we do. So what we validated to do here is it will automatically identify that you don't have a validation submission function. So you don't really want to hijack the form submit event. And what it will do is when the user submits a form to validate the forum and to render any error messages and then it will branch off. If the form is valid, it will perform a full page reload and submit the form normally just as if you had no JavaScript at all. But so similar to the same behavior we had before, nothing extra here. But if the form turns out to be invalid, then it will prevent the submission and display the error messages. So it did really what you want and it kind of understood your intention here. If you have a submit handler here, it will then act as it will only execute that handler as your when that form is valid and it will prevent submission in either case. Because it then assumes yes, you really want to hijack the submission here. So we will do that. So let's talk about UI in X and we will cover through a couple of examples really quickly. Right here we have form interaction flags. You can do a lot more than this example, but this is just a taste of what we validate it really has to offer. So let's say you want to disable the submit button until the form is valid. You can do this by accessing the valid meta flag or you can display the submission progress by checking the submitting flag. And this flag is true whenever the form is being validated and submitted and will turn false once it's done. So you can really use it to spell some spinners or change some text or disable your inputs if you really want to. So it's really nice to use. You can do a lot more. There are a lot of meta flags like touch, dirty and validated and many others. So yeah, you can really build whatever experience and craft whatever experience you really want. Check that documentation for more information about what else is available here. Another example here is handling invalid submissions. This is a fairly new addition to the library. So a lot of users really wanted to do something extra when the user submits the form and turns out invalid, which is really useful if you have this long form and you really want to scroll the user to the input that they cannot see. So the user may be trying some of the form but they don't understand exactly what's going on. So it can be really useful to just scroll them. Yeah, here is the field that has an issues. Please fix it. So we can really do that using this simple example. We grab the first arrow key and that can happen to be the field name and then you can build your form for that to be correct. And then query that input, grab it and scroll it into view and you're done. So three liners really improved experience of real-erong forms or multi-stip forms if you have them. So yeah, you can do a lot more with V-validate in terms of your own UX but this is just a couple of examples. So form generators. Form generators are really complicated but using V-validate you can really get away with that very basic form generator. V-validate itself doesn't offer any form generator for you out of the box but you have all the tools to build your own. But if you don't really know what is a form generator, it is basically a component or a function or something that accepts a JSON object or a JavaScript object and generates your fields and forms based on that object. They can be dynamic and it makes it really easy to retrieve your forms from the AI for example. And they are really useful and really reduce, they can really boost your productivity when we're working with a lot of forms. So right here in this tutorial, it's only it climbs long if you live out the schema fields definition. And yeah, this is the most basic form generator. Of course, you can expand upon it more to include more complicated inputs like selects, custom components and more and there is actually a tutorial in the documentation covering that. You can also use specialised libraries that have first part support with V-validate again because of the composition API that we will come to just a minute. V-validate can be integrated with other libraries and one such library is form-view-late and form-view-late really takes it to the next level with forms generation. It allows you to, it's completely diagnostic so it doesn't really care what you want to render. You can render custom components or you can render an it of HTML elements. With the form-view-late, you can then render your inputs, integrate them with V-validate without really a lot of work. So you only have to declare your fields and if you really need this kind of functionality so form-validation and validation into your application, this can be really, really useful. And it will take care of the heart and heavy lifting for you. So you only have to care about the actual application logic because most of the things are done for you. So you can then do the composition API. So the composition API again allows you to integrate the V-validate features into your own components and you can think of V-validate as the central API that has two outlets, the composition API outlet and the components API outlet. You have seen the components API so far and the component API is actually the same. They both offer the same features. And actually the components API is built using the composition API. This means that you can mix and match between them. They are not mutually exclusive. You can use the components API along with the composition API. So if you want to build custom field components with V-validation, value tracking on all of the features I showcase, you can use a function called use field. For form components, you can use a function called use form. This is an example for such an basic input component called input text. And this component, all it does, it just imports useful from V-validate, calls it and passes a field name to it, which will be a probe most likely. And it grabs two things, the value and the error message. The value is the internal model that V-valid creates for you. So you can actually bind it to your actual input and it will automatically be validated. Whenever that value changes, V-validate will populate the error message with any information or the proper error message. For custom forms, it is similar. You grab the use form function. You can pass the validation scheme into it and other configuration properties. You can grab a handle submit function for them and there are a lot of stuff you can grab for them. But for this example, we are only grabbing the handle submit, which creates submission handlers for you. These submission handlers, you can bind to your listeners, so you can listen for a form submit event and trigger the submit function for it. You can use it on button clicks. You can really use it in any kind of events and you can even call it manually in your JavaScript and they all behave the same. They will validate the form and execute or call back if everything is valid. Otherwise, they will just validate the form and won't do anything extra. So yeah. Let's check an example from before and after. So before we used the components, maybe I, which was a little bit verbose because we had to use the field component and the error message component that we have a bunch of fields. So this became very bit really quickly. But if we use a composition API to build our own input text component, we can then really accept this our forms in terms of one line. So one liner name, one liner email and one liner password and that's it. We are done. We get value tracking error messages for those elements and we get the rendering as well. But this is really the main benefit of using the composition API. You should use it to build your own components and not to validate JavaScript values. If you really want to just validate JavaScript values, then you are better off using other libraries. This is the main goal of the composition API in Vvalid. Help you build your own custom components and custom forms. In this example, notice that we use the form component with our custom input text component. Again, this is because it's all built on the composition API meaning you can mix them and they will work seamlessly together. You can do the opposite as well. So let's check this last thing which is the view. It's diff tools plugin. Right here we have this really nice forum. And we have the view of diff tools. You have the view diff tools offers in the spectres that allow you to view the components three in different ways. So the default one is called components. But once you use any kind of Vvalid stuff, either the composition API or the components, you will see a new inspector called Vvalidate. If you click on it, you will notice that it renders a completely different view. It shows you the nodes in terms of node components but in terms of fields and forms. So right here this is a form node, this is a name node and I'm calling them nodes because each component can contain multiple fields or multiple forms. So it's not really accurate to call each one component. So they are just nodes. So each node can have a summary of their state like you can see down here. And yeah, form of course have more states. So of course they have more stuff to show. But yeah, you get access to initial values, current values, errors and any other meta information. At a glance you get these tags called form field that tells you which node is which. So this is a form node, this is field node and so on. They are in red. So notice once I start filling out these elements, they turn to green. This is really neat because Vvalidate now tells you what each component validity is just at a glance without you having to really dig deep and see why this field is not valid. So yeah, just simple color change can tell you a lot. So here, right now we can tell that this form isn't valid because it's red and it is invalid because this field is the only one that's invalid. So makes complete sense. And if we try to submit it, this does this little shaking, which is a small animation that we have here. But we show an error message here. If we click on the confirm password node, notice that we have the error here and the valid flag is turned false. But if we go to the form, we in the errors object, we have passwords do not match for the confirm password field. So if let's try filling it out and there's our empty hover form is valid. It is green, same thing for the confirm password field. If we try to submit it, everything submits and it works nicely. You can have do a lot of other actions to debug your state. For example, you can clear the form. So you can clear individual inputs. So let's click on the password field. You can clear it by clicking on this icon. And yeah, it is cleared. And you can force validate it. You can click on the form node and clear it and also form validate and force validate it. So this is really nice and allows you at a glance to figure out what's wrong. So if you have this form that isn't submitting, you can check the errors and figure out why it's not submitting. Maybe it has some field that you forgot to show or maybe you forgot our rules. So yeah, that's all. That's all for this talk. So there's of course a lot more that we didn't cover because there is a lot of APIs and components that makes it really useful for you. For example, array fields, multiple step forms, localization and UI libraries integrations, which is libraries like Quasar, Vutify, Toolwind, the Headless UI and more. Check out the documentation. There is a lot of information, each of them and leave your feedback. So thank you for attending this talk and see you around.