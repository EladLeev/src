Hello, this is an intro to FastAPI. So FastAPI, hyper-performance is to learn fast to code, ready for production. First, I am Sebastian Ramirez, I'm a developer at Explosion in Berlin, Germany. I'm actually from Colombia in South America, that's why I sent. You can find me on Github, LinkedIn, Twitter, I work for Explosion. Explosion are the creators of space in natural language processing toolkits, for doing things like machine learning or text. Also, the creators of Prodigy, the dataset annotation tool using active learning. So you can annotate datasets for machine learning with the model being live, retrained live with the annotations you create. And think the people learning framework based on standard Python type annotations. I created FastAPI and hyper, we are going to talk about FastAPI. So a little bit about FastAPI, it has currently 15,000 in Observes, have been going about 1000 stars per month so people have been liking it. It's currently being used by Microsoft, Uber, Netflix and a bunch of other organizations and application systems. The performance is in the top rank for Python. And FastAPI is based on standards like Open API, JSON schema or two or two is what is used by Facebook Google, GitHub, Twitter, whenever you do login with application X, all that is using all of the, and FastAPI lets you build this all to things very easily or integrate with it. And because it's based on all these open standards is very easy to have things like automatic API documentation. This automatic API documentation user interface that you can see in the right, this comes by default with FastAPI for free when you create an application using FastAPI. So when you create an application using FastAPI, it's based on standards for free. You don't have to do anything to get a standard based application just because you wrote it with FastAPI. Now FastAPI is based on Python type hints or type annotations. This is the standard way you do their types in modern Python. For example, here we're saying that name is a string or that price is a float. This is a standard Python. This is not a custom syntax. This is just standard Python. And because this is like the standard way to do their type annotations, we get out to completion everywhere in the editor and type checks and type errors. We're going to see more examples of this later. The point is this is standard type annotations are what provides out to completion in your editor. So when you write code with FastAPI, you get out to completion everywhere in your code. FastAPI is easy and short. So this code that you see here is a complete valid FastAPI application. We import from FastAPI, the class FastAPI, we create an object of this class FastAPI. And then we use this decorator here. A decorator is something that uses this ad symbol. And what it does is it's using in some way the function that is below. That's what a decorator does with this ad symbol. What we are doing is we're saying in our app application, in our FastAPI application, we want to handle the path slash whenever we get a request that has a URL with just the slash path and is using a HTTP get operation, we're a HTTP get method. We want this function to handle that. And when we are doing is just returning a dictionary that has a message, hello world. You can see that we don't have to return like some type of request or some type of class of anything like that. We just return a simple dictionary. FastAPI will take care of converting this to JSON. So the more FastAPI code you write, the less API code you actually write. Because FastAPI gets out of the way and then you can just like focus on your business logic for your application. Now let's see a basic FastAPI application. We have this is more like the same we just saw before we had async def for this function. Now we have this normal def function. If you don't know how async and away works or you don't feel comfortable with them, you can just use normal functions and FastAPI will do the right thing for you. So this is just the normal thing we were seeing before. Now let's add another path here. This is slash items slash and we are going to take this item ID as a path parameter. We put it in curly braces as if it was a Python form f string like a formatted string. We just don't add the f here but it's more with the same syntax and we declare this item ID as a path parameter here and we also declare it here to receive it in our function. And we are saying that this item ID is an integer. We are also declaring this queue which is a string that by default is none because this queue is not in the path here. FastAPI will take it from the query parameters. So if our application leaves at this the main sondermy.com then the when we send our quest with slash items slash five is we'll be handled by this function. This is slash items is the same slash items and this five here will be the item ID that we declare here that we're going to receive here as a path parameter. And then we can declare the query parameter after the question mark here. So this queue equals some query whenever our code executed this queue will have the value some query if we send it to you like this. And if we check the your slash docs FastAPI automatically generates this documentation interface for us and we can see we have the slash items item ID we have this item ID here which is the same here that is our required path parameter and it has to be an integer. We also have the queue query parameter which is a string and has to be on the query and this documentation interface generated automatically by FastAPI for us because it's based on all these standards that we were talking about. So whenever you write an application with FastAPI you just write some basic code and Google guide FastAPI makes a docs user interface for you for your API. Now let's check a basic FastAPI app with a body. We are declaring here that we have a food plus and we are using this base model thing this is imported from pedantic so FastAPI is actually based and used in uses internally this library called pedantic that helps us do a little of the like all the data handling in FastAPI and pedantic uses the standard type annotations for Python. So we are declaring that we want a name to be a string and we want ingredients to be this thing list. This list is imported from typing which is standard Python this typing comes from Python and this list is the standard way to the person thing as a list in the type annotations so we're saying that this ingredients is a list that should contain strings and by default it's just an empty list. Then in the code that we have here below we are saying that this goes to slash food slash and now this is not a get request but a post HTTP operation and this we are going to handle post requests and we declare this parameter food of to be an instance of this type food class of the declared before. This is also standard Python type annotations but we have lowercase food this is a parameter and this title case food is the same class we declared here and by doing this we are telling Python that this food is an instance of this class. This is just like standard Python and FastAPI will use it to document our web API as followable. So we can see that if we go to the documentation user interface we can see the example value that we expect to receive in the value of the request and we are going to receive a name that should be a string and we are going to receive ingredients that should be a list with strings and this is on automatically click automatically by FastAPI for us because we are using this standard this go back this is standard type annotations and this class created using by Dante. Now let's go forward. We can actually execute queries and like execute requests to our API. If we go back to the documentation as we were seeing it before we click here and try it out and we will see that this compared to an interactive system that we want like execute and send data to our live application. We are sending some food that has a name of taco ingredients is Figueles Carnet, Taco Shell, Sarasura. So this is all valid data we are sending that and then we receive the message repairing taco. This is the same code that we were returning. We are just receiving the right response from our application. If we go back to the code we can see that we are sending this message that is a preparing food name and because we are actually receiving an instance we are not receiving an dictionary we are receiving an instance of this class food. We can use food the name to get the name that we received there and this is in polyvases because this is an F string which is the modern way in Python to write formatted strings. So let's go forward. We are receiving the message that we were expecting to receive when we interact with the user interface for the documentation of our API. So this is our request body full of tacos might look like. Now let's say that we want to declare a fasty-be-eplication that takes a body and a query parameter. So we declare the by-identic model as we were returning before and now we declare it here. This is all the same code but we are also declaring this delivery which is a boolean by default false because this delivery is not part of the path so it's not a path parameter and because this is a simple value a boolean. A simple value like a string, a float, a boolean is not a complex class like this food that we created here then fasty-be-eplication will be rid of from the query parameters. Also fasty-be-eplication we are declaring this as being a boolean. Fasty-be-eplication will take care of giving us a boolean. Not a string with the word false or something like that we will receive a boolean and if we see it in the interactive documentation user interface we can see that fasty-be-eplication will read that the delivery query parameter that we created and we'll put it here we'll say that this is a boolean and it should go in the query parameter because when it cleared as a boolean then the user interface is going to be able to show us the valid values which are just two or false and this is how we will call it if we're using it if we're sending a request so we'll declare after the question mark we say delivery equals string. Now notice that this URL is just a long string and this true would actually descend as if it was a string containing the text true but because we declared in our code let's go back we declared in our code as being a boolean and fasty-be-eplication using paedantic will take care of converting this boolean that came as a string to an actual boolean so we are going to receive a boolean in our code this is going to be false like this one or true if we send it like to be true. So by using a standard Python type annotation like this or this fasty-py is one side doing documentation for application automatically and on the other side data serialization or data conversion we are receiving the boolean instead of a string the same true or something like that and you don't have to put everything in the way you can use query parameters if you need to and there's also a similar ways to declare headers cookies and so on so. Now let's say that we want to receive a very complex data shape we want to receive adjacent array of objects in our body so adjacent array is the equivalent of a Python list adjacent object is the equivalent of a Python dictionary so we are declaring here the same way we are using this list before we are also going to use it here and this list comes from the standard Python typing module and we're saying that we are going to receive orders which is a list of food and food is this pedantic class we created here that has name and has brilliance and now the code that we are doing here is very simple it's just like some sample small application that is collecting all the ingredients and putting them together so we create a list of ingredients and for each one of the food in orders orders is this thing we declared here we are iterating for each one of the ingredients in the food dot ingredients so the ingredients for this is specific food and we are holding that ingredient in lowercase to all the ingredients that we have and we just return those ingredients so we are just collecting all the ingredients for the food or the orders that we received now if we go to the documentation user interface we can see that it can it detects that that this should be a list of that of these data shape and we can say this is a list because we have to square braces here this is like the sample value that we will be sending so if we want to send JSON and we want to send it inside of JSON some JSON objects in some of JSON objects or lists or lists or whatever like you wouldn't do anything that we want we can declare very deeply complex deeply nested data structures and past API we'll be able to handle it all based on standard Python type annotations but what up to now we have seen that it's doing the whole thing is doing documentation and serialization of data conversion for us but what happens if we say value data so let's see this one we have this is this is this is our square bracket so this is a list we declare that we are going to receive a list that's valid the first item is this JSON object and these are all JSON objects so that's up to now that's valid the first item has a name which is a string that's valid because of what we've declared and we have ingredients which is a list of strings in this case we've got the tackle share and so this is valid then we have the next one which has a name which is pizza and this is a string so this is valid we don't have ingredients here but if you remember the ingredients was a by default an empty list because it had a default value then it is not required so this is actually a valid food item now we have the next one this is called this has a name Trojan food this sounds weird but after now this is valid because it has a name and this is a string now we check the ingredients and the first item is salt the salt is a string inside of the list so this is valid after now but the next one is actually a JSON object that has a name and it says that it's a sneaky object we declare that we are going to receive strings not objects so this is weird here and the next one has this food name which is an old breath but if we check what we did there that we are receiving is name not food name and name was required and because we are not sending a name here then we are not sending our required value and if we try to execute this then we're going to receive another automatically and the error is going to tell us that we have invalid data so FastAPI is going to validate all the data based on those type annotations automatically for us and not just will give us an error saying I hate the data is invalid it will tell us exactly where the data is invalid so here we have the details we have this is a list of errors and we have two errors the first one says that in the body in order the index two so let's go back this is the index one sorry this is the index here this is the index one and this is the index two so somewhere here we have an error let's go forward inside of that index two inside of ingredients in index one a string type was expected so let's go back so we were in this object inside of the ingredients this is index zero in index one which is this one a string type was expected and we sent an object so we have a very clear specification of where the problem is let's check the next error this says that it's in index three at name the field was required and we didn't send it let's go back this is the index three and we have a food name but we don't have a name and the required a required key that we were expecting was named so fast API is giving us this validation error automatically and it's doing all that for us let's go back to our code it's way back here that means that by using this standard Python type annotations fast API is doing documentation serialization or data conversion and validation this is saving us like I don't know 50 lines of code in here something like that so whenever this code is executed this code that we see all here it's because the data is already valid fast API already made sure that we have valid data we can just focus on the business logic of your application not on handling specific errors of the data shapes that you receive now let's go forward to where we were so we received this nice validation error when we sent it valid data so if we send invalid data fast API a replication fast API we made that face and say no that's not allowed now because we are doing all these based on type annotations on standard Python type uh mutations of type hints we get out of completion everywhere now check this this is and this orders is a list of instances of this class food so we can iterate for each one of the food in orders and when we can iterate for each ingredient in food dot ingredients so you can see we are two for loops inside so we are two for loops deep and still we get out of completion for this ingredient so the editor will know that this ingredient is a string and we will be able to have completion for this all this because it's based on standard Python types this will be very difficult to achieve with a order tools or even other languages without using the standard Python definitions or the standard type definitions for each specific language so we are getting all this for free and we are also getting type checks so the code the editor is going to know that this ingredient is a string and if we try to send a string with some integer it's going to give us a nice error saying take high this is not a valid operation here and we're going to see this error error the while we are developing our application before having to wait to run the application to see the error but we're going to get it right away in our editor all because it's all based on standard Python types well yeah this is all based on some kind of type Python types so we get all these things for free now let's say that we want to add some extra metadata so we have this delivery query parameter here there is a boolean we want to add a description we have to say this is back for delivery so we from fast API we import this query thing and then we use it here and before we had the default value of the delivery was false but now we are using instead of pulling false we are using this query thing here and because we are using this space to use this query here we no longer have what the default value here so this query will take as the first parameter what that default value was before so we are going to take this false here this false means that this delivery will have a default value of false and we'll also have this additional metadata this description part for the delivery and then if we check the documentation user interface we can see that we have the part for the delivery description here for this delivery query parameter that should be a boolean and that by default is false so we now let's go back we now take the false instead of having just false here instead having just a simple false here we have this query thing with the description and the default value for this query parameter is going to be the first parameter of query forward to the documentation nice we get that so you now don't have to write documentation outside of your code you don't have to keep updating some wiki somewhere with what is the API expecting to do and the front-end theme that is using your API is not going to come complaining that the API is no longer working because you updated it and forgot to update the wiki because everything will live right there in the code right where it belongs describing where it should be describing now let's say that we want to have a required query parameter so we have the delivery which is not required because because it has a default value of false and we now add another one that is quantity because it doesn't have any default value here it's going to be required and it's going to expect an interior so this is going to be this has to be an integer and it's a required query parameter if we check the documentation we can see that we have quantity here it's a required query parameter that has to be an integer if we try to execute this request here without sending a quantity we're going to receive this error and if we send it through code or from the command line we will also get like one of those validation errors that we were seeing before so this is the phase that the API will make when we omit required data now let's say that we send valid data so we're going to slash food slash and we're saying after the question mark we say the quantity is going to be equal to two we're going to have this hat to be an integer and we are sending two if we execute this request then we're going to see the response that we were expecting so it will work nicely as we want something to have in mind one does not simply make all query parameters required because it's not very common for query parameters to be required and clients and the developers won't probably expect the query parameters to be required so if you have a query parameter there is that is required and like just try to leave the amount of them but if you need to make them required you can do it as well now let's say that we want to add some extra validation for this quantity query parameter we can use the same query thing that we were using we are going to use it here as well and we say that this quantity which is an integer has to be greater than 0 and it has to be less than or equal to 10 so this has to be a value between 0 and 10 and now notice that we now are using this equals something so we this function parameter has like quote unquote a default value of this whatever this where everything is here but we wanted this quantity to be a required query parameter so the same way that the one before we were using the same way that the first parameter is the actual default value in the case of delivery this was false in the case of quantity we also pass as the first parameter we pass the default value and in this case we are using three dots this three dots is a valid Python syntax this is a valid Python symbol called ellipses and this symbol is what we are using here to talk FastAPI hey and I want to use this extra things these nice features from this query thing but I want this quantity to not have a default value and still be required so this is how we do it this is actually also used by Pydantic and it's actually underneath it's used using Pydantic but this is the way that we are saying that this quantity must be required and now if we go to the documentation we can see that the quantity is required it's an integer and if we send in valid data we're going to receive one of these nice messages saying hey ensure this value is greater than 0 because we appear that it had to be greater than 0 so when we say it invalid data FastAPI we'll complain to the client and we'll let the data and the code pass one day the data pass and we'll let the code even be executed because it will just show the invalid data like the invalid data errors but if we send valid data then it will be all happy and work nicely as we expected so it's protecting us from invalid data from having to all that handling in our internal code now about performance FastAPI is a intub rank for Python frameworks in performance the blue ones here in this this is a third pariphench mark created by TekkenPower and the blue ones here are Python the green ones are go or go lang go is a compiled language so this is not a very comparison at all despite on this interpreted goes compared it's compiled and it should be way faster than interpreted language but FastAPI and some others here are able to be even faster than some go frameworks for APIs so this is quite nice which one of these is exactly the fastest is not necessarily that relevant you can see that they are on the same ballpark and in fact FastAPI here appears on top of UVGON but UVGON is actually the bare bones server that is running fast API so UVGON should be faster than any of these guys and FastAPI is actually built on top of starlet the key point is that you get some of the best performance available for Python frameworks and you can see that we have here in this benchmark this handling 15000 something requests per second so it's handling over 9000 requests good some other features FastAPI has a dependency injection system which is very simple to use it allows you to do very fancy stuff like authentication authorization or even database session management a bunch of things that you can do using this the dependency injection system and the dependency injection system is also integrated with all these standards things so you also get documentation automatically with it it's very simple to use and like very intuitive and powerful at the same time there are also several security utilities integrating an integrated with all of two which is also integrated with the documentation interface you will have support for web sockets for files background tasks eC GraphQL integration templates like a bunch of other things what you will expect from a most of the frameworks now when is not a good idea to use fast API let's say that you have a stable jangle of application or some other framework and it's a stable if it's a stable if you don't need to add new features it's working perfectly and it's not even an API then like you don't need to or and don't that your compulsion to refactor to rewrite it using fast API but something that that can be done if you want to use fast API is for example adding a layer fast API on top of your existing application to handle like the new features or new requests for some additional paths that you declare or something like that that will be like a nice way to integrate it or to slowly migrate to fast API if you want to just to avoid like trying to rewrite everything from scratch and delay delay in your project development nevertheless there are teams that have just like migrated entirely to fast API and having very happy with it but yeah just make sure that it actually in the next sense before just go in all of the fast API now some other tools typer typer is like the fast API of command line interfaces so this is to create command line applications that are running terminal it's also based on Python type annotations the way you write code it is almost the same as with fast API so you get completion type 6 and everything and the nice thing is that your users your clients are going to get shell completion in their terminal for bash fish seashell power shell yeah think is the functional deep learning framework with Python type annotations that is compatible with your favorite libraries like a tensor flow or PyTorch this is built by explosion the company worker and if you like this Python type annotations and you are into deep learning you might want to check think as well thank you very much that's what I have for you if you want to check the documentation is here fast API here's the yeah the documentation for fast API if you have any questions you can ask them on the issues in the GitHub repository or you can also like contact me in these links thank you very much