1
00:00:23,080 --> 00:00:26,476
Hello everyone, and thank you for coming to this talk. My name is

2
00:00:26,498 --> 00:00:30,436
Adam Fulmanik and we are going to talk a little bit about

3
00:00:30,618 --> 00:00:33,776
databases, guardrails, deployment,

4
00:00:33,888 --> 00:00:37,140
CI CD, and which things can go wrong.

5
00:00:37,290 --> 00:00:41,172
So in the next minutes we are going to see how

6
00:00:41,226 --> 00:00:44,040
our industry changed over last years,

7
00:00:44,190 --> 00:00:47,464
how we didn't manage to build good processes and

8
00:00:47,502 --> 00:00:51,124
tools around the databases yet, and most importantly,

9
00:00:51,172 --> 00:00:54,792
how to fix all of that so we can use that from

10
00:00:54,846 --> 00:00:58,312
our applications and prevent the bad code from reaching

11
00:00:58,376 --> 00:01:02,108
production. This is the idea. So let us begin.

12
00:01:02,274 --> 00:01:06,224
The very important thing I'd like to start with is the

13
00:01:06,262 --> 00:01:10,252
world has changed significantly in the last two decades.

14
00:01:10,396 --> 00:01:14,208
Previously, what we were doing is whenever we had a team

15
00:01:14,374 --> 00:01:18,064
working on something, generally there was one product

16
00:01:18,182 --> 00:01:21,712
with one database with couple of hosts running behind

17
00:01:21,766 --> 00:01:25,076
the load balances. That was the idea. If you

18
00:01:25,098 --> 00:01:28,384
wanted to deploy something new, then it was deployed

19
00:01:28,432 --> 00:01:31,604
completely independently along the way. So each

20
00:01:31,642 --> 00:01:34,840
one product, something like this on the slide, was basically

21
00:01:34,910 --> 00:01:39,064
running with one database, couple of hosts, load balancer, and obviously

22
00:01:39,182 --> 00:01:42,824
the user calling all of that. Right? And if we were

23
00:01:42,862 --> 00:01:46,840
to deploy new product, then it was completely independent.

24
00:01:46,920 --> 00:01:50,316
It wasn't necessarily talking to our product, it was

25
00:01:50,338 --> 00:01:53,676
using separate database and whatnot. So this

26
00:01:53,698 --> 00:01:57,392
is how the world looked like before. When there were issues

27
00:01:57,526 --> 00:02:01,408
with the setup, then they were quite easy to manage.

28
00:02:01,494 --> 00:02:04,992
I'm not going telling solving those because this

29
00:02:05,046 --> 00:02:08,736
depends on the issue, obviously, but managing how to solve

30
00:02:08,768 --> 00:02:12,484
this issue was rather straightforward. We knew where

31
00:02:12,522 --> 00:02:16,288
the locks are. We knew how to find files,

32
00:02:16,384 --> 00:02:19,888
requests, whatever else. And when the database was slow,

33
00:02:19,984 --> 00:02:24,308
we generally knew where to tackle it. So one DBA

34
00:02:24,404 --> 00:02:28,024
could actually deal with all of that. And it was enough for us

35
00:02:28,062 --> 00:02:31,732
to have a DBA around that was capable of solving

36
00:02:31,796 --> 00:02:35,788
our performance issues, problems with databases, or whatever

37
00:02:35,874 --> 00:02:39,900
else. However, this has changed significantly.

38
00:02:40,240 --> 00:02:44,232
The world we are in now is way more complex.

39
00:02:44,376 --> 00:02:47,964
We have microservices, we have multiple components.

40
00:02:48,012 --> 00:02:51,104
We have multiple databases for each application.

41
00:02:51,302 --> 00:02:54,864
We have SQL databases, NoSQL databases. We have

42
00:02:54,902 --> 00:02:59,060
various other serverless solutions. We have as freebackets, we have

43
00:02:59,130 --> 00:03:03,508
all of that, most importantly talking with everything else.

44
00:03:03,594 --> 00:03:07,524
So the connections, interconnections between applications are

45
00:03:07,562 --> 00:03:11,516
now much more complex and much more complicated.

46
00:03:11,648 --> 00:03:15,732
This is where we are now. And if the problem appears,

47
00:03:15,876 --> 00:03:19,256
then we don't even know how to track it. Because in

48
00:03:19,278 --> 00:03:23,060
the world of microservices, logs are scattered

49
00:03:23,140 --> 00:03:26,552
across multiple components in our ecosystem.

50
00:03:26,696 --> 00:03:30,664
It's not that we just go to the web server and we capture

51
00:03:30,712 --> 00:03:34,696
the logs. No. Now web servers are first, they are scaled

52
00:03:34,728 --> 00:03:38,764
out second, we have multiple independent microservices

53
00:03:38,892 --> 00:03:42,320
so web servers talk to each other. And third,

54
00:03:42,470 --> 00:03:46,924
we have so many databases that when the problem appears,

55
00:03:47,052 --> 00:03:50,988
we do not necessarily know whether it started where

56
00:03:51,014 --> 00:03:55,252
we see it, or whether it's just an outcome of something else.

57
00:03:55,386 --> 00:03:59,092
And this something else can be of various nature. This something

58
00:03:59,146 --> 00:04:02,096
else can be because the data distribution changed,

59
00:04:02,208 --> 00:04:05,556
or maybe because we have like spike in the traffic,

60
00:04:05,668 --> 00:04:09,224
or maybe because it's different time of the year, and people are

61
00:04:09,262 --> 00:04:13,108
generally using our platform way more because it's like Christmas

62
00:04:13,204 --> 00:04:17,244
or Halloween or whatever else. So understanding all

63
00:04:17,282 --> 00:04:20,664
those things is now much, much harder.

64
00:04:20,792 --> 00:04:24,780
Most importantly, one DBA just won't do.

65
00:04:24,930 --> 00:04:30,140
I mean, we have many databases now, and those independent

66
00:04:30,220 --> 00:04:34,172
databases, they generally need to be tuned and adjusted.

67
00:04:34,236 --> 00:04:38,192
And it doesn't scale well because adjusting and tuning one

68
00:04:38,246 --> 00:04:42,384
database takes time, and adjusting many databases

69
00:04:42,512 --> 00:04:46,324
takes much more time to do that. So how

70
00:04:46,362 --> 00:04:50,212
can we deal with that? Well, our current industry is

71
00:04:50,266 --> 00:04:53,924
telling us that yes, we can use monitoring, we can use monitoring

72
00:04:53,972 --> 00:04:57,672
tools, and this way we can figure out what is going

73
00:04:57,726 --> 00:05:02,200
on. But there are a couple of problems to that. First problem is

74
00:05:02,350 --> 00:05:05,516
everything is complex. This is like a

75
00:05:05,538 --> 00:05:09,564
slide I took from the Internet describing an architecture of

76
00:05:09,682 --> 00:05:14,060
some monitoring solution. And we can see how many things

77
00:05:14,130 --> 00:05:18,076
there are in here that are capturing just the monitoring

78
00:05:18,108 --> 00:05:21,360
data and just everything around to

79
00:05:21,430 --> 00:05:24,976
show us the design of the system and the

80
00:05:24,998 --> 00:05:28,944
monitoring and observability. But even if we take the monitoring

81
00:05:28,992 --> 00:05:31,856
solutions, they are less than ideal.

82
00:05:31,968 --> 00:05:35,076
The problem with monitoring solutions is, well,

83
00:05:35,178 --> 00:05:39,248
they are kind of complex and sophisticated.

84
00:05:39,344 --> 00:05:42,452
Nowadays we have so many charts. We have charts

85
00:05:42,516 --> 00:05:45,992
showing like raw signals, trends over time,

86
00:05:46,126 --> 00:05:49,236
various data from various sources.

87
00:05:49,348 --> 00:05:53,444
We have all of that shown on a single chart that

88
00:05:53,502 --> 00:05:56,812
is not very much readable. And most

89
00:05:56,866 --> 00:06:00,652
importantly, if there is a problem with the data,

90
00:06:00,786 --> 00:06:04,264
with the traffic, with our applications behind the scenes,

91
00:06:04,392 --> 00:06:08,588
then based on this chart, we just don't know what to do because

92
00:06:08,754 --> 00:06:12,268
this fingy, those charts, those diagrams,

93
00:06:12,364 --> 00:06:16,096
they just show us, hey, there is a fire in here,

94
00:06:16,278 --> 00:06:19,700
but it doesn't tell us how to put

95
00:06:19,770 --> 00:06:23,236
down this fire, how to tame the

96
00:06:23,258 --> 00:06:26,324
complexity and how it started.

97
00:06:26,442 --> 00:06:30,164
We see the fire is there, but we have no idea what

98
00:06:30,202 --> 00:06:33,688
is the reason behind the fire and how to cope with it.

99
00:06:33,854 --> 00:06:37,272
So this is where we are now. And the

100
00:06:37,326 --> 00:06:41,336
thingy we need to address is we need to see

101
00:06:41,438 --> 00:06:45,068
what breaks in modern world and how we can fix that.

102
00:06:45,154 --> 00:06:48,684
And the solution to fixing that is building a

103
00:06:48,722 --> 00:06:52,556
completely new approach we call database guardrails. Just like

104
00:06:52,578 --> 00:06:56,540
we had to learn that sysops and developers,

105
00:06:56,980 --> 00:07:00,640
they cant work independently, they need to sit next

106
00:07:00,710 --> 00:07:03,776
to each other and work hand to hand.

107
00:07:03,878 --> 00:07:07,084
And later on we started doing DevOps

108
00:07:07,132 --> 00:07:11,060
engineering. So there are people that know both sides of

109
00:07:11,210 --> 00:07:15,328
this scenario the same way. We need to build new solutions

110
00:07:15,424 --> 00:07:18,980
that will let us tame the complexity of databases and

111
00:07:19,050 --> 00:07:22,672
protect them from breaking and also monitor

112
00:07:22,736 --> 00:07:26,308
them when something goes wrong and finally will automatically

113
00:07:26,404 --> 00:07:29,928
root cause all the issues. And this is a must have.

114
00:07:30,014 --> 00:07:33,416
No matter whether we are like big Fortune 500 company

115
00:07:33,598 --> 00:07:37,420
or small startup, just treading the water and building

116
00:07:37,490 --> 00:07:41,500
their first product doesn't matter. We need to be able to manage

117
00:07:41,570 --> 00:07:45,052
our databases effectively, because when the time comes

118
00:07:45,106 --> 00:07:48,828
and the problems begin to happen, then it's way too late

119
00:07:48,924 --> 00:07:52,944
to figure out what solutions to put in place. So before going

120
00:07:52,982 --> 00:07:56,576
to that, let's see what breaks in the current world.

121
00:07:56,678 --> 00:08:00,020
And this way we'll be able to see how to fix

122
00:08:00,090 --> 00:08:04,464
those issues. So generally, as with every database,

123
00:08:04,592 --> 00:08:08,612
we have like three different groups of problems, three different

124
00:08:08,666 --> 00:08:12,432
areas where problems can appear. First group is code

125
00:08:12,506 --> 00:08:16,216
changes. So we change our code, we change the code of

126
00:08:16,238 --> 00:08:19,704
our JavaScript application. So then it reads the

127
00:08:19,742 --> 00:08:23,208
data from the database in a different manner. So we

128
00:08:23,214 --> 00:08:26,344
have different query using different tables, different views,

129
00:08:26,392 --> 00:08:29,596
basically extracting different data, right. Obviously we change the

130
00:08:29,618 --> 00:08:32,108
query, things may begin to break.

131
00:08:32,274 --> 00:08:35,676
Okay, second area is schema changes.

132
00:08:35,778 --> 00:08:38,956
So we change the schema of our database,

133
00:08:39,068 --> 00:08:42,512
we change the schema of the columns, types, whatever else.

134
00:08:42,646 --> 00:08:45,984
And this may break the way how queries are

135
00:08:46,022 --> 00:08:49,924
executed, which indexes are used, or maybe our Orm may

136
00:08:49,962 --> 00:08:53,604
go wrong and decrease the quality of the data.

137
00:08:53,722 --> 00:08:58,272
So this is around how we store the data in the database.

138
00:08:58,416 --> 00:09:02,376
But there is also third important area, which I call here

139
00:09:02,478 --> 00:09:06,152
query changes. And what I mean here is not that we

140
00:09:06,206 --> 00:09:10,440
change the query that we execute, no, we run exactly

141
00:09:10,510 --> 00:09:14,156
the same query as before. But this time what

142
00:09:14,178 --> 00:09:17,564
we do is the query that we

143
00:09:17,602 --> 00:09:20,824
execute, it executes differently.

144
00:09:20,952 --> 00:09:24,924
It executes differently because something has

145
00:09:25,042 --> 00:09:28,876
changed. This something can be database configuration,

146
00:09:28,988 --> 00:09:31,920
ORM configuration, maybe index got wrong,

147
00:09:31,990 --> 00:09:35,280
maybe statistics become outdated or other stuff.

148
00:09:35,350 --> 00:09:39,084
Or maybe there are many more transactions in the database, so the database

149
00:09:39,132 --> 00:09:42,176
engine need to cope with those transactions differently.

150
00:09:42,288 --> 00:09:46,004
There are many things that can change outside of

151
00:09:46,042 --> 00:09:49,956
the query, and this query may start running

152
00:09:50,058 --> 00:09:53,652
completely differently, which leads to lower performance.

153
00:09:53,796 --> 00:09:57,896
And this is something that is actually very important in

154
00:09:57,918 --> 00:10:01,464
our databases. And we are going to see throughout this talk

155
00:10:01,582 --> 00:10:05,704
how to deal with that and how our current solutions,

156
00:10:05,832 --> 00:10:09,480
current CI CD pipelines and current tests don't

157
00:10:09,560 --> 00:10:13,176
capture those scenarios. So let's jump right straight

158
00:10:13,208 --> 00:10:16,296
to it. The very first thing is we have slow

159
00:10:16,328 --> 00:10:20,048
queries. So this is the scenario, as you cant see here on

160
00:10:20,054 --> 00:10:23,584
the screen we have the query that is generated from

161
00:10:23,622 --> 00:10:27,616
our JavaScript application. We are getting user for some specific

162
00:10:27,718 --> 00:10:31,840
user id and this is just an aggregate route. So this user

163
00:10:31,920 --> 00:10:35,824
had so much more data related to it. For instance like details,

164
00:10:35,872 --> 00:10:39,092
pages, questions, location, whatever else.

165
00:10:39,226 --> 00:10:42,664
We get this data and we finally return the

166
00:10:42,702 --> 00:10:47,316
user in our application code and this query generates

167
00:10:47,428 --> 00:10:51,204
the following SQL statements sent to our database.

168
00:10:51,332 --> 00:10:55,224
This SQL statement has something like what, eight different tables

169
00:10:55,272 --> 00:10:58,284
being used? And this in general,

170
00:10:58,402 --> 00:11:02,044
because it uses so many tables, then it

171
00:11:02,082 --> 00:11:06,252
exponentially increases the number of rows it

172
00:11:06,306 --> 00:11:10,128
extracts from the database and how long it takes to process

173
00:11:10,214 --> 00:11:14,352
all of them. This is something I observed in one of my production code.

174
00:11:14,486 --> 00:11:19,156
And generally this simple query was extracting 300,000

175
00:11:19,258 --> 00:11:22,720
rows from the database and ultimately

176
00:11:22,800 --> 00:11:26,080
the code was running for nearly 25 seconds.

177
00:11:26,240 --> 00:11:29,364
That wasn't fast, just to

178
00:11:29,402 --> 00:11:32,680
say that was terribly slow. Now the problem

179
00:11:32,750 --> 00:11:36,836
with this approach is that when we run this thingy

180
00:11:36,948 --> 00:11:40,552
and we'd like to test it locally, then we have

181
00:11:40,686 --> 00:11:43,960
generally no way how to test it with our local

182
00:11:44,030 --> 00:11:47,644
developers environment. Why is that? That is because in

183
00:11:47,682 --> 00:11:51,468
our local database what happens is we have, I don't know,

184
00:11:51,554 --> 00:11:55,464
hundred rows. So when we have hundred rows then this query

185
00:11:55,512 --> 00:11:59,072
on the right side of the screen won't generate many,

186
00:11:59,126 --> 00:12:02,752
many more rows and effectively it

187
00:12:02,806 --> 00:12:07,088
wouldn't cause us any issues. We won't see the performance problems.

188
00:12:07,254 --> 00:12:11,588
However, once we go to production we'll immediately see

189
00:12:11,674 --> 00:12:15,204
that something is wrong. But it's only when

190
00:12:15,242 --> 00:12:18,468
we go to production that's one of

191
00:12:18,474 --> 00:12:21,280
the issues we may have with databases. Another issue,

192
00:12:21,370 --> 00:12:24,920
and actually how we fixed this issue in this case

193
00:12:24,990 --> 00:12:28,840
was to change this one query, this one

194
00:12:28,910 --> 00:12:31,940
big application code, extracting all the tables.

195
00:12:32,020 --> 00:12:35,464
The production was to change it to getting the aggregate

196
00:12:35,512 --> 00:12:38,792
root and sending many independent queries.

197
00:12:38,936 --> 00:12:42,476
This resulted in sending many SQL statements to the

198
00:12:42,498 --> 00:12:45,852
database, which is correct, but may seem like

199
00:12:45,906 --> 00:12:49,824
okay, it's going to be terrible for the performance, but actually those

200
00:12:49,862 --> 00:12:53,376
queries are much smaller, get much smaller amount of

201
00:12:53,398 --> 00:12:57,024
data, so they execute much faster. And ultimately we

202
00:12:57,062 --> 00:13:00,756
just concatenate and join all the data in the application

203
00:13:00,858 --> 00:13:04,800
code. And this production, this change made the query

204
00:13:04,880 --> 00:13:08,084
run in something like a split second,

205
00:13:08,202 --> 00:13:12,400
generally way faster, even though we were running many more queries.

206
00:13:12,560 --> 00:13:16,232
Another problem we may see is let's say that we refactor the code

207
00:13:16,286 --> 00:13:19,348
to make it more readable and we break the performance.

208
00:13:19,444 --> 00:13:22,872
So let's say that I have a boarding passes table with

209
00:13:22,926 --> 00:13:26,364
something like 8 million rows. Now what I'd like to do is

210
00:13:26,402 --> 00:13:30,316
this is a handcrafted query. So not something probably you do often

211
00:13:30,418 --> 00:13:34,552
in your production code. But let's say that I would like to use CTE

212
00:13:34,616 --> 00:13:38,464
common table expression to extract boarding passes and

213
00:13:38,502 --> 00:13:41,904
calculate double checksum of the ticket number.

214
00:13:42,022 --> 00:13:46,492
So CTE, if you don't know what that is, it's kind of named temporary

215
00:13:46,556 --> 00:13:49,876
table that leaves only during the duration, for the

216
00:13:49,898 --> 00:13:53,364
duration of the query. So what we do is we

217
00:13:53,402 --> 00:13:57,172
get everything from boarding passes. We take the

218
00:13:57,226 --> 00:14:01,044
ticket number and we calculate the checksum of the ticket number

219
00:14:01,082 --> 00:14:04,324
and we do it twice just to show some cpu

220
00:14:04,372 --> 00:14:07,924
intensive operation. And we store that as an additional column

221
00:14:07,972 --> 00:14:12,152
called double hash. So this is our temporary table with

222
00:14:12,206 --> 00:14:15,704
this double hash. And then what we do is we join

223
00:14:15,752 --> 00:14:19,404
this table three times to match like one

224
00:14:19,442 --> 00:14:23,256
to one rows based on the ticket number, flight id and bonding

225
00:14:23,288 --> 00:14:26,656
number, and we look for some specific

226
00:14:26,838 --> 00:14:29,920
checksum of the ticket number. However,

227
00:14:30,070 --> 00:14:33,676
we don't need to use the CTE common table expression

228
00:14:33,708 --> 00:14:38,060
for that. We can just take the boarding passes table initially,

229
00:14:38,220 --> 00:14:42,452
join it three times and then calculate the

230
00:14:42,506 --> 00:14:46,516
checksum of the ticket number. Here inside the were

231
00:14:46,618 --> 00:14:50,352
condition, those two queries are equivalent

232
00:14:50,496 --> 00:14:54,408
and they return exactly the same result. The problem is the

233
00:14:54,414 --> 00:14:57,896
query at the bottom runs in 8 seconds while the query at the

234
00:14:57,918 --> 00:15:02,232
top runs in 13, so nearly twice as

235
00:15:02,366 --> 00:15:06,350
long. So now imagine that you come to your application

236
00:15:06,880 --> 00:15:10,412
and you like to rewrite this query to make it more

237
00:15:10,466 --> 00:15:13,804
readable. You have all your unit tests, you have all

238
00:15:13,842 --> 00:15:17,472
your integration tests and they are still green after

239
00:15:17,526 --> 00:15:20,640
you rewrite the code. Why is that? That's because

240
00:15:20,710 --> 00:15:24,352
those tests, they only compare the result

241
00:15:24,486 --> 00:15:28,124
of the query, not the query performance. They verify

242
00:15:28,252 --> 00:15:31,696
whether you extracted exactly the same rows

243
00:15:31,888 --> 00:15:35,508
and whether you extracted the same data.

244
00:15:35,674 --> 00:15:39,140
So they will be green if you implement the code,

245
00:15:39,290 --> 00:15:42,452
but they won't notice the issue. The same way would

246
00:15:42,506 --> 00:15:45,736
actually happen with the example we had previously. If you

247
00:15:45,758 --> 00:15:49,624
have unit tests here and here, then those unit tests will be

248
00:15:49,662 --> 00:15:53,304
exactly the same. They will be green because you extract the same data.

249
00:15:53,422 --> 00:15:56,444
It's just you extract them differently. So here with

250
00:15:56,482 --> 00:15:59,804
this example, you change the statement the

251
00:15:59,842 --> 00:16:04,120
query to make it more readable and you decrease the performance.

252
00:16:04,280 --> 00:16:07,816
Yet another issue is changes in schema.

253
00:16:07,928 --> 00:16:11,824
We may actually add columns, drop columns, change the column type or

254
00:16:11,862 --> 00:16:15,872
whatever else. And all those operations they make break our

255
00:16:15,926 --> 00:16:19,116
performance and how things work in the production database.

256
00:16:19,228 --> 00:16:22,016
And we won't notice that with our unit tests.

257
00:16:22,128 --> 00:16:26,304
Adding a column may be like detrimental for the performance

258
00:16:26,352 --> 00:16:29,924
when we use select star statements. Because if you add

259
00:16:29,962 --> 00:16:33,272
a column, then select star will pick it up and will start

260
00:16:33,326 --> 00:16:37,000
extracting more and more data. This may actually

261
00:16:37,070 --> 00:16:40,868
decrease the performance. And you won't notice that from your unit

262
00:16:40,884 --> 00:16:44,396
test because hey, the old data that was needed for the

263
00:16:44,418 --> 00:16:48,284
unit test does not change. And also when adding a

264
00:16:48,322 --> 00:16:51,416
column you may cause table reorganization.

265
00:16:51,528 --> 00:16:55,176
Table rewrite because sometimes the database

266
00:16:55,208 --> 00:16:58,944
engine cant add a column into the

267
00:16:58,982 --> 00:17:02,512
table just like that. It needs to take the data,

268
00:17:02,646 --> 00:17:06,140
copy it on the side, recreate the table,

269
00:17:06,220 --> 00:17:09,764
and then copy the data back to the

270
00:17:09,802 --> 00:17:13,268
original table. This may take minutes or even

271
00:17:13,354 --> 00:17:16,864
hours. And in some cases I heard about migrations

272
00:17:16,992 --> 00:17:20,772
taking more than a month. Now if

273
00:17:20,826 --> 00:17:24,424
the migration is so long and you didn't prepare for

274
00:17:24,462 --> 00:17:27,976
that, then you risk taking your database down because the

275
00:17:27,998 --> 00:17:31,944
database may simply not be available for your users just

276
00:17:31,982 --> 00:17:35,224
because it's working hard to reorganize the schema.

277
00:17:35,352 --> 00:17:38,764
So those migrations is something that

278
00:17:38,802 --> 00:17:42,984
may kill your performance and take your business down for some prolonged

279
00:17:43,032 --> 00:17:46,640
time. Now the question is, how do you verify that before

280
00:17:46,790 --> 00:17:50,272
going to production? You don't, because your

281
00:17:50,326 --> 00:17:53,968
unit tests, your integration tests, they generally work against

282
00:17:54,054 --> 00:17:57,520
the latest schema. They don't work against

283
00:17:57,590 --> 00:18:01,152
like the schema that is currently being migrated.

284
00:18:01,296 --> 00:18:04,896
Not to mention that you won't even notice the performance issues with schema

285
00:18:04,928 --> 00:18:08,912
migration because in your local environment that schema

286
00:18:08,976 --> 00:18:12,912
will run nearly instantaneously right in no time.

287
00:18:13,066 --> 00:18:16,520
There are other issues with schemas, for instance, dropping a column that's obviously

288
00:18:16,590 --> 00:18:20,312
never safe, especially harder when we are dealing with

289
00:18:20,366 --> 00:18:24,136
like heterogeneous applications, when we have a database

290
00:18:24,248 --> 00:18:27,804
that is used by multiple applications. In such

291
00:18:27,842 --> 00:18:31,608
a scenario, what happens is that you change the schema,

292
00:18:31,704 --> 00:18:35,160
you test your application, one application in isolation,

293
00:18:35,240 --> 00:18:38,992
and all your unit tests are green, obviously, and everything goes well.

294
00:18:39,126 --> 00:18:42,656
But your second application doesn't know that the

295
00:18:42,678 --> 00:18:45,808
column was removed. So again,

296
00:18:45,974 --> 00:18:49,360
unit tests for the second application will still be green

297
00:18:49,510 --> 00:18:53,232
because hey, it's not aware that the column was dropped.

298
00:18:53,296 --> 00:18:57,030
And then you deploy to production and you break the other application.

299
00:18:57,560 --> 00:19:01,456
Changing column types is yet another issue you may face

300
00:19:01,578 --> 00:19:04,904
when you change the column type. Then first you may

301
00:19:04,942 --> 00:19:08,344
break the data quality just because you change

302
00:19:08,382 --> 00:19:12,184
the representation of numbers, dates, geolocation information.

303
00:19:12,382 --> 00:19:16,044
Or you may break your application altogether just because your

304
00:19:16,082 --> 00:19:19,896
Orm cannot read and use the data anymore.

305
00:19:20,008 --> 00:19:23,916
And you can also change the performance. For instance, previously you

306
00:19:23,938 --> 00:19:26,968
were storing geolocation data as like pair of

307
00:19:27,074 --> 00:19:30,304
numbers, and now you need to serialize it as a

308
00:19:30,342 --> 00:19:33,996
string. And again, your unit test won't capture

309
00:19:34,028 --> 00:19:37,308
this change just because first you have small database

310
00:19:37,404 --> 00:19:41,364
and second, everything will work correctly from the

311
00:19:41,402 --> 00:19:45,396
user perspective. It's only the performance will break once you go to

312
00:19:45,418 --> 00:19:49,332
production. Other thing with schema migrations is

313
00:19:49,386 --> 00:19:53,652
missing indexes. So what happens is, okay, you send

314
00:19:53,706 --> 00:19:56,808
a query and this query is slow because

315
00:19:56,894 --> 00:20:00,104
what? Because you lack an index. So what do you do?

316
00:20:00,142 --> 00:20:03,768
You need to add an index to increase the query performance, right? So you

317
00:20:03,774 --> 00:20:07,304
need to pick a proper index type. There are various index types.

318
00:20:07,352 --> 00:20:11,032
You need to analyze how it's going to store the data and whatnot.

319
00:20:11,096 --> 00:20:15,052
But generally you can do that. But the important part to understand here

320
00:20:15,106 --> 00:20:18,352
is that index is only helping in the

321
00:20:18,406 --> 00:20:22,096
read scenario. It's not helping in the data

322
00:20:22,198 --> 00:20:25,776
update scenario. Actually it's even worse in the

323
00:20:25,798 --> 00:20:29,616
data update. That is because you need to update the data

324
00:20:29,718 --> 00:20:33,152
in the table, but also all the indexes configured

325
00:20:33,216 --> 00:20:36,896
on the table. So while you can configure index

326
00:20:36,928 --> 00:20:40,624
and you can even confirm yes, it increased the performance for reading.

327
00:20:40,752 --> 00:20:44,104
You also need to check everything else around the performance of

328
00:20:44,142 --> 00:20:47,556
data modification. And as before, your unit

329
00:20:47,588 --> 00:20:51,224
tests are going to be green. But there is yet another problem with

330
00:20:51,262 --> 00:20:54,936
that. Let's say that you have a junior inexperienced developer on

331
00:20:54,958 --> 00:20:58,684
your team and they have slow query and you suggest them what

332
00:20:58,722 --> 00:21:02,124
to do. Add an index. What do they do now is they

333
00:21:02,162 --> 00:21:05,548
add indexes everywhere. So you have so

334
00:21:05,634 --> 00:21:09,330
many indexes because you index basically everything.

335
00:21:09,700 --> 00:21:13,852
And this is yet another problem. You have an index that increases

336
00:21:13,916 --> 00:21:17,456
the performance for reading but kills the performance for writing and

337
00:21:17,478 --> 00:21:21,264
updating. And what's more, when you have many indexes,

338
00:21:21,392 --> 00:21:25,030
you don't actually know whether those indexes are still used,

339
00:21:25,400 --> 00:21:29,152
because it may be that today you configure such an index

340
00:21:29,216 --> 00:21:33,268
and it is being used properly, but you can configure it

341
00:21:33,434 --> 00:21:37,256
and forget about it. And six months from now the index is

342
00:21:37,278 --> 00:21:40,948
not used anymore. Are your unit tests, integration tests

343
00:21:40,964 --> 00:21:44,296
going to tell you that the index is not being used? They won't tell

344
00:21:44,318 --> 00:21:47,592
you that. Why? Because nothing changes. The query

345
00:21:47,656 --> 00:21:51,228
gets the same data with or without an index. It doesn't matter.

346
00:21:51,394 --> 00:21:55,148
Are you going to face the performance issue? Obviously you are,

347
00:21:55,234 --> 00:21:58,816
because those indexes will be like staying around, but they

348
00:21:58,838 --> 00:22:02,352
are not being used at all. Not to mention

349
00:22:02,406 --> 00:22:06,080
that there are bugs. Bugs, obviously some of them will

350
00:22:06,150 --> 00:22:09,756
capture with our unit tests. Some of them we won't

351
00:22:09,868 --> 00:22:13,604
just because they are tied to the engine we are using.

352
00:22:13,722 --> 00:22:16,960
An important part here is to understand that engines

353
00:22:17,040 --> 00:22:20,292
differ. It may be that in production you have different

354
00:22:20,426 --> 00:22:24,024
type of the database just because you have different license or

355
00:22:24,062 --> 00:22:27,428
you are using some cloud component that you can't run locally,

356
00:22:27,524 --> 00:22:31,668
whereas in local environment you just use something like in memory database

357
00:22:31,764 --> 00:22:34,820
or free tier edition of your cloud component.

358
00:22:34,900 --> 00:22:38,696
Right? Now, those two products, the one you use in the developers

359
00:22:38,728 --> 00:22:41,692
and the one you use in production, they may differ.

360
00:22:41,826 --> 00:22:45,448
And because they differ, you may hit different bugs.

361
00:22:45,544 --> 00:22:48,944
One of the bugs that we faced, like years back, I mean,

362
00:22:48,982 --> 00:22:52,992
the industry first years back was the Halloween problem.

363
00:22:53,126 --> 00:22:56,828
And the Halloween problem is actually pretty interesting. And now databases

364
00:22:56,924 --> 00:23:00,416
protect themselves from facing this Halloween problem.

365
00:23:00,518 --> 00:23:03,364
But let's see what was going on. Let's say that we would like to give

366
00:23:03,402 --> 00:23:07,120
a pay rise to the employees. So we get the table employees,

367
00:23:07,200 --> 00:23:11,024
and we increase salary by 10% for everyone that earns

368
00:23:11,072 --> 00:23:14,824
less than 10,000, right? Obviously numbers do not match here.

369
00:23:14,862 --> 00:23:18,404
That doesn't matter, and so on. So what we do is we scan

370
00:23:18,452 --> 00:23:22,404
rows one by one. And once we find a row, okay, this row

371
00:23:22,452 --> 00:23:25,916
is below 10,000, so we increase the

372
00:23:26,018 --> 00:23:29,884
salary by 10%. Now, the problem with the table was

373
00:23:29,922 --> 00:23:33,400
that rows were ordered by the salary.

374
00:23:33,560 --> 00:23:38,384
So what happens now is if you get the row, that salary is below 10,000,

375
00:23:38,582 --> 00:23:41,824
you put it, you increase the salary. So the

376
00:23:41,862 --> 00:23:45,936
row goes here, and then you continue scanning and

377
00:23:45,958 --> 00:23:49,360
you find the same row again and you process it again.

378
00:23:49,510 --> 00:23:53,204
So what happened? And the problem takes name from when it

379
00:23:53,242 --> 00:23:56,944
happened and happened on the last day of October. So it was Halloween.

380
00:23:57,072 --> 00:24:00,660
So what happened is everyone in the company

381
00:24:00,810 --> 00:24:04,884
started earning at least 10,000 because we protested the same row

382
00:24:04,932 --> 00:24:08,756
many times. Obviously that was a bug in the database.

383
00:24:08,868 --> 00:24:12,136
But if you are testing your code against a different

384
00:24:12,238 --> 00:24:15,432
database type, then you won't find this bug

385
00:24:15,496 --> 00:24:18,968
at all until you hit the production.

386
00:24:19,144 --> 00:24:22,140
There are some other issues with the orms.

387
00:24:22,560 --> 00:24:26,608
So orm libraries, they help us reading the data,

388
00:24:26,694 --> 00:24:30,752
writing the data, mapping the SQL entities into

389
00:24:30,806 --> 00:24:34,044
our objects and other stuff, and they are pretty useful.

390
00:24:34,172 --> 00:24:38,048
However, they pose their own issues on

391
00:24:38,214 --> 00:24:42,384
the way they work. So let's say that we have table court aircraft,

392
00:24:42,512 --> 00:24:46,624
and aircraft has one single aircraft may have many seats.

393
00:24:46,752 --> 00:24:50,128
What we would like to do is we would like to get all the aircraft,

394
00:24:50,224 --> 00:24:53,864
then iterate through every single aircraft and just

395
00:24:53,902 --> 00:24:57,768
get the number of seats. What may happen

396
00:24:57,854 --> 00:25:01,604
behind the scenes is that we may face an unplug

397
00:25:01,652 --> 00:25:05,592
one queries problem just because how ORM

398
00:25:05,656 --> 00:25:09,276
gets the data. ORM can get the data in

399
00:25:09,298 --> 00:25:12,232
the eager mode or lazy mode.

400
00:25:12,376 --> 00:25:15,624
In eager mode, ORm gets the aggregate

401
00:25:15,672 --> 00:25:19,132
route with all the data behind. In lazy

402
00:25:19,196 --> 00:25:22,576
mode, the ORM just gets the basic data.

403
00:25:22,678 --> 00:25:26,528
And when we try accessing something else, it gets this

404
00:25:26,614 --> 00:25:29,856
something else and fill in the gaps as we go.

405
00:25:29,958 --> 00:25:33,444
So if our ORM is configured in the lazy mode that

406
00:25:33,482 --> 00:25:36,656
we may start with one query to get all the aircraft.

407
00:25:36,768 --> 00:25:40,432
And then just as we iterate over those entities,

408
00:25:40,576 --> 00:25:44,168
we will be getting another query for every single

409
00:25:44,254 --> 00:25:48,212
entity along the way. Ultimately we get n plus one queries,

410
00:25:48,276 --> 00:25:52,264
one query for aircraft and n additional queries for

411
00:25:52,302 --> 00:25:56,292
every single aircraft to get the seats. We can optimize

412
00:25:56,356 --> 00:26:00,264
that to reconfigure the ORM to get the data in the eager

413
00:26:00,312 --> 00:26:03,676
mode. And in the eager mode what would happen is we would

414
00:26:03,698 --> 00:26:07,664
get all the aircraft and join them with the seats in

415
00:26:07,702 --> 00:26:10,892
one query. So this seems like a solution.

416
00:26:10,956 --> 00:26:14,544
There are two problems to that though. First problem is

417
00:26:14,662 --> 00:26:18,160
we won't notice this problem from our

418
00:26:18,230 --> 00:26:22,644
unit tests, integration tests or whatever else, just because

419
00:26:22,842 --> 00:26:26,692
the data is correct. Data doesn't change behind

420
00:26:26,746 --> 00:26:30,132
the scenes, it's just the way how we extract the data changes.

421
00:26:30,266 --> 00:26:34,224
And second problem is, let's say that we would like to change our ORm

422
00:26:34,272 --> 00:26:37,704
from lazy code to eager mode always. And then we end

423
00:26:37,742 --> 00:26:41,176
up with the same problem that we already saw, that you join the

424
00:26:41,198 --> 00:26:45,036
big aggregate route and you end up extracting like hundreds of

425
00:26:45,058 --> 00:26:48,940
thousands of rows just because you wanted to get

426
00:26:49,010 --> 00:26:52,348
all of that. So it's not a silver bullet either

427
00:26:52,434 --> 00:26:56,152
lazy or eager mode. You just don't just flip

428
00:26:56,296 --> 00:27:00,428
the switch and you're good to go. No, you need to understand what's

429
00:27:00,444 --> 00:27:04,560
your scenario and you need to decide on a case by case basis.

430
00:27:05,060 --> 00:27:08,840
Other problems that orms introduce

431
00:27:08,940 --> 00:27:12,592
are around polymorphism and generally impedance

432
00:27:12,656 --> 00:27:16,112
mismatch. In general, impedance mismatch is a term

433
00:27:16,176 --> 00:27:20,580
meaning that we want to map two incompatible

434
00:27:21,020 --> 00:27:24,648
paradigms on top of each other. So we have object

435
00:27:24,734 --> 00:27:28,184
oriented paradigm or functional paradigm in our application

436
00:27:28,302 --> 00:27:31,892
code, and we want to map it on the SQL

437
00:27:31,956 --> 00:27:34,804
paradigm like relationship paradigm.

438
00:27:34,932 --> 00:27:38,140
And the opposite obviously goes the same way. We take the

439
00:27:38,210 --> 00:27:41,452
SQL paradigm and map it on OOP object

440
00:27:41,506 --> 00:27:44,620
oriented programming. So this doesn't go well.

441
00:27:44,690 --> 00:27:48,060
If we want to do it like naively, then yes,

442
00:27:48,130 --> 00:27:51,596
we can do this naive way. And there are for instance patterns

443
00:27:51,628 --> 00:27:55,024
how to do polymorphism in SQL. Let's say that you have a

444
00:27:55,062 --> 00:27:58,704
class that inherits from some other class and you can see how

445
00:27:58,742 --> 00:28:02,788
to put this class onto the database. In SQL database there

446
00:28:02,794 --> 00:28:05,732
are patterns like table PI hierarchy, table per type,

447
00:28:05,786 --> 00:28:08,996
et cetera, et cetera. However, they will decrease the

448
00:28:09,018 --> 00:28:13,000
performance. So it's not that you can take the way

449
00:28:13,150 --> 00:28:16,904
you implement your applications like object oriented way and

450
00:28:16,942 --> 00:28:20,552
put it in SQL database. This doesn't work and it goes both

451
00:28:20,606 --> 00:28:24,264
ways. So what happens with the data types

452
00:28:24,312 --> 00:28:28,552
in SQL databases. For instance, we have a thing regarding

453
00:28:28,616 --> 00:28:31,672
varcar, regarding the strings.

454
00:28:31,736 --> 00:28:35,740
Basically we store in the database, the thing that is called collation.

455
00:28:36,100 --> 00:28:40,012
Collation is basically a configuration in the database

456
00:28:40,076 --> 00:28:44,524
that dictates how we compare characters

457
00:28:44,652 --> 00:28:48,304
in the database. So we decide whether we like

458
00:28:48,342 --> 00:28:52,208
a lowercase character is equal to uppercase character,

459
00:28:52,304 --> 00:28:55,684
or whether we should put, I don't know, null first, or maybe how

460
00:28:55,722 --> 00:28:58,784
we compare international characters and whatnot.

461
00:28:58,912 --> 00:29:02,376
And this is something we can configure per database. But can we

462
00:29:02,398 --> 00:29:06,036
configure something like that in our object oriented

463
00:29:06,068 --> 00:29:09,924
programming language? Can we configure how we compare

464
00:29:09,972 --> 00:29:13,268
strings in JavaScript?

465
00:29:13,444 --> 00:29:17,224
We can't, and this goes to other types as well. We can

466
00:29:17,262 --> 00:29:20,824
specify the precision of numbers with decimal in SQL

467
00:29:20,872 --> 00:29:24,392
database, but in JavaScript we do not have that precision

468
00:29:24,456 --> 00:29:28,688
at all. We can, for instance, use spatial data that can be

469
00:29:28,774 --> 00:29:32,736
stored as a pair of numbers, but our orm may not

470
00:29:32,758 --> 00:29:36,044
be capable of doing this way. So it may actually serialize

471
00:29:36,092 --> 00:29:39,672
and deserialize that to string or to JSON.

472
00:29:39,836 --> 00:29:44,000
So this may hit the performance or even make it unusable

473
00:29:44,160 --> 00:29:47,668
just because we want to map one incompatible paradigm on

474
00:29:47,674 --> 00:29:50,704
top of each other. But this goes even further.

475
00:29:50,832 --> 00:29:54,368
Again, what happens if we have heterogeneous applications?

476
00:29:54,464 --> 00:29:57,784
How can we deal with that? It may be that we change the type

477
00:29:57,822 --> 00:30:00,904
of a column and we break some other application just

478
00:30:00,942 --> 00:30:05,304
because it cannot deal with this new column. Or DRM cant handle

479
00:30:05,352 --> 00:30:08,808
that. Other problems that orms introduce

480
00:30:08,904 --> 00:30:12,504
are around, like lack of visibility. Do you know what your isolation

481
00:30:12,552 --> 00:30:16,044
level is? Do you know where your transactions code begins or

482
00:30:16,082 --> 00:30:19,224
where it rolls back? Do you know who commits the transaction?

483
00:30:19,272 --> 00:30:23,084
Who rolls it back? What about caching? What about connection pulling?

484
00:30:23,132 --> 00:30:27,436
What about query hint? What about migration configuration? Is your RM

485
00:30:27,548 --> 00:30:30,816
going to deal with the migration or with

486
00:30:30,838 --> 00:30:34,704
the schema when it realizes that there is a schema drift?

487
00:30:34,832 --> 00:30:37,924
Or is it going to throw an exception on you, or is it going to

488
00:30:37,962 --> 00:30:41,072
go and change the schema on your behalf?

489
00:30:41,216 --> 00:30:44,584
Other things that may go well, and we could

490
00:30:44,622 --> 00:30:47,684
have more things around like migrations,

491
00:30:47,812 --> 00:30:51,492
rollbacks, et cetera, et cetera, heterogeneous applications,

492
00:30:51,556 --> 00:30:54,396
how we manage them, how we fix them, and so on and on.

493
00:30:54,498 --> 00:30:57,660
Generally there are so many issues around and

494
00:30:57,730 --> 00:31:01,996
managing all of that is hard. And the most important part

495
00:31:02,098 --> 00:31:06,272
is we won't notice those when

496
00:31:06,326 --> 00:31:10,284
we implement application in our developer environment.

497
00:31:10,412 --> 00:31:13,664
We just won't notice that. That is

498
00:31:13,702 --> 00:31:17,264
because unit tests and integration tests are going to be

499
00:31:17,302 --> 00:31:21,380
green, but we will hit errors when we go to production.

500
00:31:22,360 --> 00:31:26,464
So orms and databases in general they're

501
00:31:26,512 --> 00:31:30,560
hard because changes are scattered in various places.

502
00:31:30,720 --> 00:31:34,904
There are so many moving pieces, dump so many things

503
00:31:35,022 --> 00:31:38,216
that are not clear to us, whether we load the

504
00:31:38,238 --> 00:31:41,864
data eagerly or lazily, which indexes we

505
00:31:41,902 --> 00:31:45,004
use, whether we run n plus one queries or

506
00:31:45,042 --> 00:31:48,312
just one query, whether the problem is in the database,

507
00:31:48,376 --> 00:31:52,184
in the code, are there triggered stored procedures, functions,

508
00:31:52,232 --> 00:31:56,400
views? Many, many more issues than we can't deal

509
00:31:56,470 --> 00:32:00,476
with easily. And now talking about tests,

510
00:32:00,588 --> 00:32:03,504
do they help? Do they work in our case?

511
00:32:03,622 --> 00:32:07,004
So unit tests obviously won't capture

512
00:32:07,052 --> 00:32:11,156
those issues because they just first run against the

513
00:32:11,178 --> 00:32:15,504
latest schema and they only check the correctness

514
00:32:15,632 --> 00:32:19,396
of the data. So they only check whether we

515
00:32:19,418 --> 00:32:23,240
read and returned correct data, not how

516
00:32:23,310 --> 00:32:27,460
we extracted this data. Same goes for integration

517
00:32:27,540 --> 00:32:31,252
tests. They will use like a physical component

518
00:32:31,396 --> 00:32:35,080
instead of just like unit mocked databases

519
00:32:35,160 --> 00:32:38,844
or in memory databases or whatever else. But still,

520
00:32:38,962 --> 00:32:42,888
they are probably triggered against like small databases

521
00:32:42,984 --> 00:32:46,604
to make them run much faster so they won't observe the

522
00:32:46,642 --> 00:32:50,224
issues end to end tests. On the other hand,

523
00:32:50,342 --> 00:32:53,664
if we don't run them in production, they face exactly the same

524
00:32:53,702 --> 00:32:57,424
problem, so they won't capture the issues. So it seems like the

525
00:32:57,462 --> 00:33:01,524
typical test pyramid is not going to do for us.

526
00:33:01,722 --> 00:33:05,184
But you might say, okay, we have load tests.

527
00:33:05,312 --> 00:33:08,980
Load tests should capture those issues, right? Shouldn't they?

528
00:33:09,130 --> 00:33:12,584
And they can capture some of those issues, but they

529
00:33:12,622 --> 00:33:16,104
have problems on their own. First problem is

530
00:33:16,222 --> 00:33:19,800
they are super expensive. They may take hours

531
00:33:19,950 --> 00:33:23,544
to complete. You need to create new hardware for

532
00:33:23,582 --> 00:33:27,356
them. You need to host a dedicated environments for those.

533
00:33:27,458 --> 00:33:31,004
You need to anonymize your data, you need to gather the data,

534
00:33:31,122 --> 00:33:34,664
you need to access production. For that, you need to anonymize.

535
00:33:34,712 --> 00:33:38,748
So you are GDPR compliant, California protection

536
00:33:38,844 --> 00:33:42,524
compliant, and other stuff. This gets even harder

537
00:33:42,572 --> 00:33:45,872
with machine learning scenarios or with, I don't know,

538
00:33:45,926 --> 00:33:50,096
specific mobile devices, scenarios and whatnot. And whatnot.

539
00:33:50,208 --> 00:33:53,844
So there are many issues with those. But the biggest issue we have

540
00:33:53,882 --> 00:33:57,444
with load tests is it happens way

541
00:33:57,562 --> 00:34:01,336
too late. They happen at the very end of

542
00:34:01,358 --> 00:34:05,720
our pipeline. We run load tests after we wrote the code,

543
00:34:05,870 --> 00:34:09,112
probably committed it to the branch, even code

544
00:34:09,166 --> 00:34:12,420
reviewed with teammates, merged to the main branch,

545
00:34:12,500 --> 00:34:16,444
and deployed to non production environments. So this

546
00:34:16,482 --> 00:34:19,884
is when we run load tests. And if there is an

547
00:34:19,922 --> 00:34:22,908
issue observed during the load test,

548
00:34:22,994 --> 00:34:27,104
then we need to start from scratch. This is something that

549
00:34:27,142 --> 00:34:30,876
is way too late for our cases.

550
00:34:30,988 --> 00:34:34,784
So yes, load tests will help us a bit, but they

551
00:34:34,822 --> 00:34:39,424
won't prevent the bed code from reaching preprod

552
00:34:39,472 --> 00:34:42,612
environment, meaning that they won't save us time.

553
00:34:42,746 --> 00:34:46,432
We need something better, we need some other solution

554
00:34:46,576 --> 00:34:50,308
that is going to prevent the bad code as early

555
00:34:50,394 --> 00:34:54,216
as possible. And even when we deploy to production and

556
00:34:54,238 --> 00:34:58,056
we face issues, we need something that will show us what the

557
00:34:58,078 --> 00:35:01,784
problem is and how to automatically fix that.

558
00:35:01,982 --> 00:35:06,440
And the solution to that is database guard rows.

559
00:35:06,600 --> 00:35:10,396
Database guard rows is the concept of

560
00:35:10,578 --> 00:35:14,184
maintaining managing databases in an efficient

561
00:35:14,232 --> 00:35:17,996
manner so that we can prevent bedcode from reaching production.

562
00:35:18,108 --> 00:35:22,028
We can monitor databases and monitor them semantically,

563
00:35:22,124 --> 00:35:26,524
understanding that we monitor databases that are used by developers

564
00:35:26,572 --> 00:35:30,976
and it applications and finally automatically troubleshoot

565
00:35:31,008 --> 00:35:34,116
the issues. So in order

566
00:35:34,298 --> 00:35:37,444
to build those database guardrails and to

567
00:35:37,482 --> 00:35:41,464
improve what we have today, we need to understand what

568
00:35:41,502 --> 00:35:45,780
we are dealing with. So just because we are talking databases,

569
00:35:45,940 --> 00:35:49,592
we can't use generic solutions that would work

570
00:35:49,646 --> 00:35:53,044
for them. We need to have specifically crafted

571
00:35:53,092 --> 00:35:56,924
solutions for the business we use, for the domain we work with,

572
00:35:56,962 --> 00:36:00,524
for the architecture of our system. We need to

573
00:36:00,562 --> 00:36:04,284
capture the context to understand what is going on.

574
00:36:04,402 --> 00:36:08,000
And to do that we need to understand all

575
00:36:08,070 --> 00:36:12,176
sides of our application, developers side and production side.

576
00:36:12,278 --> 00:36:16,464
So let's see how we can capture this context in order to

577
00:36:16,502 --> 00:36:20,000
build solutions that will prevent bad code from reaching production

578
00:36:20,080 --> 00:36:23,792
and help us diagnose it once we make a mistake.

579
00:36:23,936 --> 00:36:27,520
So the very first thing is the multiple parts,

580
00:36:27,600 --> 00:36:31,624
multiple pieces to creating the

581
00:36:31,662 --> 00:36:35,224
full observability and monitoring of the solution. So we start

582
00:36:35,262 --> 00:36:38,728
with telemetry. Telemetry is the ability to

583
00:36:38,814 --> 00:36:42,436
capture the raw signals. Signals could be logs, metrics,

584
00:36:42,468 --> 00:36:46,284
traces, whatever else. So those signals, we need to have a

585
00:36:46,322 --> 00:36:50,168
way of capturing them and the telemetry lets

586
00:36:50,184 --> 00:36:53,976
us do that. And now there are open source

587
00:36:54,088 --> 00:36:57,980
standardized solutions for capturing the telemetry. For instance,

588
00:36:58,060 --> 00:37:01,296
open telemetry is a library or a set

589
00:37:01,318 --> 00:37:04,768
of libraries that we can use for that. Once we cant

590
00:37:04,854 --> 00:37:08,716
capture signals, we need to process them in

591
00:37:08,758 --> 00:37:12,484
some centralized way and we need to obviously be able

592
00:37:12,522 --> 00:37:15,924
to manage those. Then we can start building the

593
00:37:15,962 --> 00:37:20,020
visibility. Visibility is the state when we see

594
00:37:20,090 --> 00:37:23,944
what's inside the system in every single place. Meaning that

595
00:37:23,982 --> 00:37:27,540
no matter whether the web server database,

596
00:37:27,620 --> 00:37:31,332
whether it's Q Enterprise service, bus, load balancer,

597
00:37:31,396 --> 00:37:35,672
serverless application, whatever else, we have basically telemetry

598
00:37:35,736 --> 00:37:39,496
wired in everywhere, in all the places.

599
00:37:39,608 --> 00:37:43,416
Once we have that and we capture signals from everywhere,

600
00:37:43,528 --> 00:37:47,184
we can say that we have visibility. Visibility shows

601
00:37:47,222 --> 00:37:49,904
us what's it inside the system.

602
00:37:50,102 --> 00:37:54,240
Then we can start building the APM application

603
00:37:54,390 --> 00:37:58,080
performance management. That gives us this

604
00:37:58,150 --> 00:38:02,228
ability to say whether our system is healthy or not.

605
00:38:02,394 --> 00:38:06,432
And we do it in a way that we aggregate

606
00:38:06,496 --> 00:38:11,020
the data from all the places we build meaningful

607
00:38:11,200 --> 00:38:14,996
aggregates, meaningful charts, meaningful dashboards

608
00:38:15,028 --> 00:38:18,808
showing us what's going on? So that we can just pick at those

609
00:38:18,894 --> 00:38:22,232
and immediately say okay, it's all green,

610
00:38:22,366 --> 00:38:26,056
our system is up and running and APM

611
00:38:26,168 --> 00:38:30,344
is going to give us exactly that. We can just look at the dashboards

612
00:38:30,392 --> 00:38:34,284
and it's green. However, when things break,

613
00:38:34,482 --> 00:38:38,144
APM is not going to tell us what's the

614
00:38:38,182 --> 00:38:42,288
reason. It's going to tell us that hey, this component is

615
00:38:42,374 --> 00:38:45,596
slow. There are problems in this component,

616
00:38:45,788 --> 00:38:49,116
but APM won't tell us that this component

617
00:38:49,148 --> 00:38:52,816
is slow just because we changed the migration. We deployed

618
00:38:52,848 --> 00:38:56,452
it last Wednesday. Now there is a different data distribution coming

619
00:38:56,506 --> 00:38:59,712
from our users and we stopped using the index.

620
00:38:59,856 --> 00:39:03,652
APM won't give us this full story. APM will only

621
00:39:03,706 --> 00:39:07,416
tell us databases slow and cpu spikes. And now what

622
00:39:07,438 --> 00:39:10,952
can you do with that? Well, if you don't know what's the reason?

623
00:39:11,086 --> 00:39:14,808
You may just try and upscale your database and this might help

624
00:39:14,894 --> 00:39:18,236
actually, but it's not the problem. The true problem is that

625
00:39:18,258 --> 00:39:22,184
you stopped using an index that was in the database.

626
00:39:22,312 --> 00:39:25,644
So now you need to modify your code to

627
00:39:25,682 --> 00:39:29,836
fix that. APM is not going to tell you that, but observability

628
00:39:29,948 --> 00:39:33,632
is. Observability gives you

629
00:39:33,686 --> 00:39:37,724
this, lets you connect all the dots from the developer

630
00:39:37,772 --> 00:39:41,312
environment to production environment. Connects the dots

631
00:39:41,376 --> 00:39:45,412
from like CI, CD, from your application code, from your

632
00:39:45,466 --> 00:39:48,740
web servers, queues, databases, whatever else,

633
00:39:48,890 --> 00:39:53,132
and with proper tooling around with database guardrails

634
00:39:53,216 --> 00:39:57,048
cant tell you the full story how it worked.

635
00:39:57,214 --> 00:40:00,600
This is what you can do. Now the question is okay,

636
00:40:00,750 --> 00:40:04,296
but what can we do? How do we do that? We have telemetry,

637
00:40:04,328 --> 00:40:07,740
we have signals, why can't we have observability right away?

638
00:40:07,890 --> 00:40:11,496
And the problem with that is monitoring.

639
00:40:11,608 --> 00:40:15,352
The way we do is it captures the signals

640
00:40:15,496 --> 00:40:19,472
that are generally agnostic to what we do. They can

641
00:40:19,526 --> 00:40:23,136
show you errors, they can show you charts, but you need

642
00:40:23,158 --> 00:40:26,384
to know how to configure thresholds and what to do with them.

643
00:40:26,502 --> 00:40:30,004
Observability, on the other hand, needs to connect the

644
00:40:30,042 --> 00:40:33,684
dots from multiple places and understand

645
00:40:33,802 --> 00:40:37,364
the characteristic of your application. And specifically it

646
00:40:37,402 --> 00:40:41,430
needs to understand what is running in your application.

647
00:40:41,960 --> 00:40:45,192
And in order to do that we need to use open

648
00:40:45,246 --> 00:40:49,176
telemetry to capture the stuff from the databases. How can

649
00:40:49,198 --> 00:40:53,080
we do that? Well, observability is basically a tool.

650
00:40:53,150 --> 00:40:56,796
Open telemetry is a tool for capturing logs, traces and

651
00:40:56,818 --> 00:41:00,904
metrics. And the way we do that is we can use the set of sdks

652
00:41:00,952 --> 00:41:05,224
from open telemetry that lets us capture the signals. Those sdks

653
00:41:05,352 --> 00:41:08,520
are built for your programming languages of your choice

654
00:41:08,600 --> 00:41:12,256
and they are also nowadays integrated with many of the pieces you

655
00:41:12,278 --> 00:41:15,212
already have with your databases, orms,

656
00:41:15,356 --> 00:41:18,864
SQL drivers, web frameworks, whatever else. Whatever else.

657
00:41:18,982 --> 00:41:22,588
The way open telemetry works is it captures the so

658
00:41:22,614 --> 00:41:25,776
called signals, sorry, traces and spans.

659
00:41:25,888 --> 00:41:30,020
So imagine that we have a workflow of like the user comes

660
00:41:30,170 --> 00:41:33,896
and wants to, I don't know, buy a ticket, so they click the

661
00:41:33,998 --> 00:41:37,464
buy purchase button. Now what happens is

662
00:41:37,502 --> 00:41:40,792
the request comes to the load balancer. It is then being

663
00:41:40,846 --> 00:41:44,696
set to, I don't know, your web server to the database queuing

664
00:41:44,808 --> 00:41:49,016
mailer system and whatever else open telemetry.

665
00:41:49,048 --> 00:41:52,940
What it does is it lets us compose a trace,

666
00:41:53,600 --> 00:41:57,488
a trace of everything that is actually happening

667
00:41:57,574 --> 00:42:00,976
behind the scenes as part of this workflow. And the trace is

668
00:42:00,998 --> 00:42:04,770
composed of like spans that represent what happened

669
00:42:06,260 --> 00:42:09,908
in a particular piece of our system. And such a

670
00:42:09,914 --> 00:42:13,504
span is basically a big jSon with like metadata,

671
00:42:13,552 --> 00:42:17,204
human friendly explanation. What were the events when the

672
00:42:17,242 --> 00:42:20,404
situation started, when it finished, what was the

673
00:42:20,442 --> 00:42:23,976
id of the operation, what was the attributes of the

674
00:42:23,998 --> 00:42:27,784
operation and other stuff. So this is what opentelemetry can

675
00:42:27,822 --> 00:42:31,192
do for us. We cant capture those signals and

676
00:42:31,246 --> 00:42:34,696
capture that stuff to build traces and spans.

677
00:42:34,808 --> 00:42:38,172
Now the question is, what do we actually capture to

678
00:42:38,226 --> 00:42:42,396
build proper database guardrails? And the question the answer

679
00:42:42,498 --> 00:42:45,704
is we need to understand databases

680
00:42:45,832 --> 00:42:50,060
as simple as that. And to do that we need to understand how databases

681
00:42:50,140 --> 00:42:53,424
work behind the scenes. So whenever you send a

682
00:42:53,462 --> 00:42:57,228
query to the database, it goes through various

683
00:42:57,404 --> 00:43:00,836
stages, it is being parsed, it is being rewritten by

684
00:43:00,858 --> 00:43:04,752
your database engine. But most importantly, a planner

685
00:43:04,816 --> 00:43:09,156
comes in. Planner is a component of database engine

686
00:43:09,338 --> 00:43:13,008
that checks your query and tries to

687
00:43:13,034 --> 00:43:16,264
figure out okay, how do I want to execute this

688
00:43:16,302 --> 00:43:19,700
query to get the highest possible performance?

689
00:43:19,860 --> 00:43:22,904
And let's see how it works. Imagine that we have

690
00:43:22,942 --> 00:43:25,868
a query like this one, select star from whatever,

691
00:43:26,034 --> 00:43:30,232
and we can use the explain keyword

692
00:43:30,376 --> 00:43:33,736
to get the execution plan of this query.

693
00:43:33,848 --> 00:43:37,456
And the execution plan is like, could be JSON, could be some

694
00:43:37,558 --> 00:43:40,352
other form explaining what's going on.

695
00:43:40,486 --> 00:43:43,756
So if we now dissect this execution plan provided

696
00:43:43,788 --> 00:43:47,644
by the database, we can see that it consists of multiple

697
00:43:47,692 --> 00:43:51,396
nodes. Basically every row here is a node in

698
00:43:51,418 --> 00:43:55,744
this plan, and node explains a particular operation

699
00:43:55,872 --> 00:43:59,892
that is being executed by the database. Every node has

700
00:44:00,026 --> 00:44:04,036
different types, so we can for instance, sequentially scan the table.

701
00:44:04,148 --> 00:44:07,524
We can use an index, we can join two tables with nested

702
00:44:07,572 --> 00:44:10,904
loops, strategy or whatever else. And more

703
00:44:10,942 --> 00:44:15,752
importantly, every operation, every node has cost associated

704
00:44:15,816 --> 00:44:19,656
with it. And this cost basically indicates

705
00:44:19,768 --> 00:44:23,404
how hard it is to execute a

706
00:44:23,442 --> 00:44:26,584
particular operation. It's not that it's some

707
00:44:26,642 --> 00:44:29,916
meaningful value like it will take 6 seconds or load

708
00:44:29,948 --> 00:44:33,404
600 megabytes, nothing like this. It's just an arbitrary

709
00:44:33,452 --> 00:44:36,624
value telling us how expensive it

710
00:44:36,662 --> 00:44:40,032
is. Now the idea is the database

711
00:44:40,096 --> 00:44:43,524
engine can create

712
00:44:43,722 --> 00:44:47,072
many plans for a particular query,

713
00:44:47,216 --> 00:44:51,480
meaning that you can have multiple execution plans with

714
00:44:51,550 --> 00:44:55,608
different costs. And then the database engine picks the plan,

715
00:44:55,694 --> 00:44:58,712
which is the cheapest one with the lowest cost.

716
00:44:58,846 --> 00:45:02,680
So that's how databases work. Now this

717
00:45:02,750 --> 00:45:06,588
plan includes everything. It includes which tables are going

718
00:45:06,594 --> 00:45:10,296
to be read, how we are going to read them, which indexes

719
00:45:10,328 --> 00:45:14,120
we're going to use, how much data we're going to extract

720
00:45:14,200 --> 00:45:18,080
and whatnot. So this is what we can do. And now

721
00:45:18,230 --> 00:45:22,188
the idea is we use open telemetry

722
00:45:22,284 --> 00:45:25,852
and other observability solutions to extract

723
00:45:25,916 --> 00:45:29,828
the things from the database when we run stuff

724
00:45:29,914 --> 00:45:33,444
in our local environment. And this way

725
00:45:33,482 --> 00:45:36,756
we can explain what is going on,

726
00:45:36,938 --> 00:45:40,452
because now just by looking at the query in our

727
00:45:40,506 --> 00:45:44,152
local environment, we can tell whether this

728
00:45:44,206 --> 00:45:48,020
query is going to work well, because we can take the execution

729
00:45:48,100 --> 00:45:51,556
plan and compare it with production database.

730
00:45:51,748 --> 00:45:55,428
And we can see that it doesn't matter that we have like one row in

731
00:45:55,454 --> 00:45:58,540
our local database just because we take this plan

732
00:45:58,610 --> 00:46:02,104
and compare how it would execute in the production

733
00:46:02,152 --> 00:46:05,564
database and how long it would took, how heavy it would

734
00:46:05,602 --> 00:46:09,264
be. So this way we can prevent the bed code from

735
00:46:09,302 --> 00:46:12,464
reaching production. Because we can analyze the

736
00:46:12,502 --> 00:46:15,612
changes in the developer environments easily.

737
00:46:15,756 --> 00:46:19,004
We can analyze the changes, we can see the migrations,

738
00:46:19,052 --> 00:46:22,480
we can see whether indexes are used, and most importantly,

739
00:46:22,560 --> 00:46:26,500
we can find things that unit tests won't find for us because

740
00:46:26,570 --> 00:46:30,004
we can see, okay, you are running n plus one queries instead of

741
00:46:30,042 --> 00:46:34,516
one query. You are converting the data from like numbers to strings.

742
00:46:34,708 --> 00:46:38,500
You are not using indexes and whatnot and whatnot.

743
00:46:38,660 --> 00:46:42,068
So this way we can prevent the bed code from reaching production.

744
00:46:42,164 --> 00:46:45,756
But the story doesn't end here. What we can do also

745
00:46:45,858 --> 00:46:49,612
is we can monitor the production database the same

746
00:46:49,666 --> 00:46:53,784
way. And when something breaks, when the database is slow,

747
00:46:53,832 --> 00:46:57,656
when cpu spikes, we can see it's not because like

748
00:46:57,698 --> 00:47:01,184
you have, I don't know, slow cpu, but it's because you

749
00:47:01,222 --> 00:47:04,290
stopped using an index just because

750
00:47:04,740 --> 00:47:07,836
you deployed recently and it changed the query,

751
00:47:07,948 --> 00:47:11,744
or maybe just because database engine decided to run the query differently,

752
00:47:11,792 --> 00:47:15,744
because you have different data distribution nowadays. And ultimately

753
00:47:15,872 --> 00:47:19,604
we can automatically troubleshoot the stuff just

754
00:47:19,642 --> 00:47:23,384
because we know how it went from your local

755
00:47:23,582 --> 00:47:26,756
development box until production.

756
00:47:26,948 --> 00:47:30,712
We can tell you the full story, the full big picture of

757
00:47:30,766 --> 00:47:34,232
what is going on and how to deal with that. So those

758
00:47:34,286 --> 00:47:37,884
are database guardrails. Prevent bad code from

759
00:47:37,922 --> 00:47:41,084
reaching production and push all your checks to the left as

760
00:47:41,122 --> 00:47:45,748
early as possible. Monitor your solution constantly

761
00:47:45,944 --> 00:47:49,916
to understand what is going on with understanding

762
00:47:49,948 --> 00:47:53,344
of the databases and finally troubleshoot all of

763
00:47:53,382 --> 00:47:57,260
that automatically to give you the big picture.

764
00:47:57,420 --> 00:48:01,460
And now how cant we do that? Well, the interesting thing

765
00:48:01,530 --> 00:48:06,128
is that it only takes like one Javascript dependency

766
00:48:06,304 --> 00:48:09,892
to be installed in your application, to have

767
00:48:09,946 --> 00:48:13,544
all of that to be proactive and to push all the

768
00:48:13,582 --> 00:48:16,964
stuff to the left and to save you from headache

769
00:48:17,012 --> 00:48:20,456
of debugging issues in production because you can

770
00:48:20,478 --> 00:48:24,132
just capture them as early as possible. And Matis does exactly

771
00:48:24,206 --> 00:48:28,060
that. Matis lets you see the stuff and

772
00:48:28,130 --> 00:48:31,404
protects you from breaking your production. So the way

773
00:48:31,442 --> 00:48:35,464
we do it is we integrate with source code, we analyze

774
00:48:35,512 --> 00:48:38,656
the stuff and let me show you really quickly what we do.

775
00:48:38,758 --> 00:48:42,544
So once you create a

776
00:48:42,582 --> 00:48:46,384
project in Matis, you have three pillars just

777
00:48:46,422 --> 00:48:50,064
like we spoke before. So the very first pillar

778
00:48:50,112 --> 00:48:53,744
is we integrate with your application and can show you easily

779
00:48:53,792 --> 00:48:57,670
that hey, your application exposes this particular

780
00:48:58,040 --> 00:49:01,444
rest endpoint. And in this rest endpoint what

781
00:49:01,482 --> 00:49:05,272
happens is when someone coded, they got this

782
00:49:05,326 --> 00:49:09,336
HTTP code. However, there were some issues with this rans point.

783
00:49:09,438 --> 00:49:12,856
What happens is you can dig deeper and you can see and you

784
00:49:12,878 --> 00:49:16,204
can understand that hey, this is the query that has

785
00:49:16,242 --> 00:49:20,092
been executed. This is the actual SQL statement that was run

786
00:49:20,146 --> 00:49:24,428
against the database. This is the execution plan

787
00:49:24,514 --> 00:49:27,936
with all the details, how things were executed on the

788
00:49:27,958 --> 00:49:31,564
database. In the database. Those are statistics of tables,

789
00:49:31,612 --> 00:49:35,264
what was read and whatnot. And most importantly we can

790
00:49:35,382 --> 00:49:38,800
analyze that and automatically tell you hey,

791
00:49:38,950 --> 00:49:43,152
you are scanning a table and you read something like 16

792
00:49:43,216 --> 00:49:46,676
million rows, that's not going to fly well. This is

793
00:49:46,698 --> 00:49:50,832
the impact on your database and this is how you can fix that. For instance

794
00:49:50,896 --> 00:49:54,436
by creating such an index to improve the performance.

795
00:49:54,548 --> 00:49:58,792
So this is the important stuff. We can see what happens behind

796
00:49:58,846 --> 00:50:02,484
the scenes and we can give you, using expert

797
00:50:02,532 --> 00:50:06,392
knowledge, using machine learning solutions, using whatever else we can

798
00:50:06,446 --> 00:50:10,604
find the anomalies and show you this is not going to fly well once

799
00:50:10,642 --> 00:50:13,820
you go to production and we can do that from your local

800
00:50:13,890 --> 00:50:17,356
development environment. So we take your local box and

801
00:50:17,378 --> 00:50:21,008
we compare that with production and we can show you this is not going

802
00:50:21,014 --> 00:50:24,096
to fly well. So this is about the queries that

803
00:50:24,118 --> 00:50:27,632
you run in your database. But we can also do other stuff.

804
00:50:27,686 --> 00:50:31,584
We can for instance analyze your CI CD. So for instance

805
00:50:31,632 --> 00:50:35,412
we can show you hey, you submitted this pull request and this is what

806
00:50:35,466 --> 00:50:39,076
happened inside this particular pull request. This is

807
00:50:39,098 --> 00:50:42,608
the performance, but we can also find pull requests for like schema

808
00:50:42,624 --> 00:50:46,024
migration and we can show you that hey, you are trying to

809
00:50:46,062 --> 00:50:49,784
create this thingy and this is not going to fly well because you

810
00:50:49,822 --> 00:50:53,944
lack indexes when creating this migration or whatever else. So we

811
00:50:53,982 --> 00:50:57,068
analyze this migration even though in your local

812
00:50:57,154 --> 00:51:00,796
environment this migration can run in a split second just because you

813
00:51:00,818 --> 00:51:04,476
have hundreds of rows. But we can analyze and tell you once you go

814
00:51:04,498 --> 00:51:07,916
to production that's not going to fly well. But this

815
00:51:07,938 --> 00:51:11,536
is just for the prevention. We also cover the stuff

816
00:51:11,638 --> 00:51:15,456
for monitoring. So what we can do is we can show you hey

817
00:51:15,558 --> 00:51:18,880
this is your production database and we cant show you like

818
00:51:18,950 --> 00:51:22,416
metrics for your database host showing

819
00:51:22,448 --> 00:51:25,552
you the things that you are interested in from the database

820
00:51:25,616 --> 00:51:29,076
perspective. We can analyze your configuration and tell you what

821
00:51:29,098 --> 00:51:32,912
is going wrong, but we can also analyze apart from the host,

822
00:51:32,976 --> 00:51:36,456
we can analyze particular databases. So we can

823
00:51:36,478 --> 00:51:40,040
for instance tell you that hey, those are the transaction you're running,

824
00:51:40,110 --> 00:51:43,176
this is the number of rows, temporary files, whatever else.

825
00:51:43,278 --> 00:51:47,144
We can analyze your indexes, extensions, we can analyze the

826
00:51:47,182 --> 00:51:50,636
live queries as you go through the database and we can show

827
00:51:50,658 --> 00:51:54,360
you hey this is the query that is being executed in your database

828
00:51:54,440 --> 00:51:58,288
and this is how it goes over time. And we can find

829
00:51:58,374 --> 00:52:01,836
insights, show you what is wrong. We can provide anomaly

830
00:52:01,868 --> 00:52:05,552
detection for all of that. So this is how we cant

831
00:52:05,606 --> 00:52:09,604
deal with the databases. And most importantly we

832
00:52:09,642 --> 00:52:14,180
can do all of that with understanding databases,

833
00:52:14,600 --> 00:52:18,660
with knowing what you do and building this full picture.

834
00:52:19,000 --> 00:52:22,676
So coming back to the slides, we integrate with the source

835
00:52:22,708 --> 00:52:26,420
code, with your CI CD pipelines, with your databases,

836
00:52:26,500 --> 00:52:30,436
no matter whether it's local pre production, production database

837
00:52:30,548 --> 00:52:34,808
we can do on demand analysis and we can provide database observability

838
00:52:34,904 --> 00:52:38,364
that you need to build database guardrails. So we

839
00:52:38,402 --> 00:52:41,532
integrate with the source code of whatever language you have,

840
00:52:41,586 --> 00:52:44,456
JavaScript, Python, any other languages,

841
00:52:44,568 --> 00:52:47,724
frameworks, libraries, drivers. We can integrate with

842
00:52:47,762 --> 00:52:51,436
CI CD, with GitHub actions or whatever else to analyze

843
00:52:51,468 --> 00:52:55,276
what you do. We can provide you with observability

844
00:52:55,388 --> 00:52:58,512
dashboards showing you what's going on and

845
00:52:58,566 --> 00:53:02,512
how things change along the way. So in summary,

846
00:53:02,656 --> 00:53:06,932
there are many things that can break with the databases today,

847
00:53:07,066 --> 00:53:10,960
many things that we won't capture with unit tests, with integration

848
00:53:11,040 --> 00:53:14,584
tests, and we need to be proactive. We can't wait for

849
00:53:14,622 --> 00:53:18,744
load tests to happen. We need to have those checks as

850
00:53:18,782 --> 00:53:22,168
early in the pipeline as possible, we need to push them to

851
00:53:22,174 --> 00:53:26,804
the left as much as possible, and we need to build understanding

852
00:53:26,852 --> 00:53:30,616
to have successful database godros, no matter whether we are a startup

853
00:53:30,648 --> 00:53:34,172
or Fortune 500 company, we need to understand all those

854
00:53:34,226 --> 00:53:38,264
big pieces because just monitoring and just APM won't

855
00:53:38,312 --> 00:53:42,220
do for us. And Mattis does exactly that. It covers

856
00:53:42,300 --> 00:53:45,964
all the things, all the problems and all the areas

857
00:53:46,012 --> 00:53:49,884
of your application. And Matis is the database godros

858
00:53:49,932 --> 00:53:52,948
ultimate solution that you can just take and start using

859
00:53:53,034 --> 00:53:56,740
in your applications. And being all of that said,

860
00:53:56,810 --> 00:54:00,116
I'd like to thank you for attending this talk. I hope you

861
00:54:00,138 --> 00:54:03,744
find it useful. I hope you enjoyed it. Join our Discord

862
00:54:03,792 --> 00:54:07,604
channel, see our Matty's platform, check it out,

863
00:54:07,722 --> 00:54:11,524
drop me a line on email, Twitter, whatever works for you

864
00:54:11,642 --> 00:54:15,130
and enjoy the rest of the conference. Thank you.

