1
00:00:00,410 --> 00:00:06,174
Jamaica real

2
00:00:06,212 --> 00:00:09,934
time feedback into the behavior of your distributed systems and

3
00:00:09,972 --> 00:00:14,094
observing changes exceptions errors in real time

4
00:00:14,212 --> 00:00:17,914
allows you to not only experiment with confidence, but respond

5
00:00:18,042 --> 00:00:20,480
instantly to get things working again.

6
00:00:24,610 --> 00:00:50,478
Code welcome

7
00:00:50,564 --> 00:00:54,158
to Conf 42 Javascript. Today I'm going

8
00:00:54,164 --> 00:00:57,422
to talk about build your own svelte, but before that,

9
00:00:57,556 --> 00:01:01,578
let me share by mama myself I'm Lee

10
00:01:01,594 --> 00:01:05,070
Hao again. I'm a frontend developer at Shopee.

11
00:01:06,870 --> 00:01:10,466
I'm based in Singapore, but I'm born and raised in

12
00:01:10,488 --> 00:01:14,450
Malaysia in a beautiful town called Bukit Murtajam.

13
00:01:15,350 --> 00:01:19,534
So outside of work I do a bit of open source. I'm a svelte

14
00:01:19,582 --> 00:01:23,206
maintainer, and if you'd like to follow me on social this

15
00:01:23,228 --> 00:01:26,994
is my Twitter handle, but most importantly this is my YouTube

16
00:01:27,042 --> 00:01:30,466
channel. I have a YouTube channel where I like to do contents

17
00:01:30,498 --> 00:01:34,314
about frontend that I wish it was there when I first started out.

18
00:01:34,512 --> 00:01:38,102
Well, when I first started out building web applications,

19
00:01:38,166 --> 00:01:41,870
probably eight, nine years ago, I started with jQuery.

20
00:01:42,450 --> 00:01:46,654
JQuery provides me utilities to select some elements and

21
00:01:46,692 --> 00:01:50,174
do something with them. For example, when user interacts with the

22
00:01:50,212 --> 00:01:53,826
page and the data changes, I use jquery to find the

23
00:01:53,848 --> 00:01:56,914
elements and modify them directly. But this

24
00:01:56,952 --> 00:02:00,322
gets messy quickly when applications get

25
00:02:00,376 --> 00:02:04,450
more and more complex. Fast forward a few more years

26
00:02:04,520 --> 00:02:07,842
I started to use React, which allows me to describe

27
00:02:07,906 --> 00:02:11,682
my view as a function of data. This declarative

28
00:02:11,746 --> 00:02:15,682
approach frees my mind to think about how to modify the elements,

29
00:02:15,826 --> 00:02:18,360
but let the react library to figure that out.

30
00:02:18,750 --> 00:02:22,742
The way how this works is that react takes a different snapshot

31
00:02:22,806 --> 00:02:26,554
of the virtual Dom, comparing it and figuring out the

32
00:02:26,592 --> 00:02:29,450
actions needed to update the actual dom.

33
00:02:29,790 --> 00:02:33,454
This comes with a cost, and because react has no idea what

34
00:02:33,492 --> 00:02:36,794
type of virtual dom there will be, whether it's this element,

35
00:02:36,842 --> 00:02:40,026
or that element, or this event handler, that event handler.

36
00:02:40,138 --> 00:02:44,290
So it has to have code to prepare for all eventuality.

37
00:02:44,870 --> 00:02:48,094
For a very simple application, the react library

38
00:02:48,142 --> 00:02:51,746
code may be overweight relative to the code you write,

39
00:02:51,928 --> 00:02:55,542
but this of course is a trade off. Your code is no longer

40
00:02:55,596 --> 00:02:58,934
as efficient as you would have it like if you write it in

41
00:02:58,972 --> 00:03:02,310
jQuery, but you gain the ability to describe

42
00:03:02,970 --> 00:03:05,750
as a more complex UI.

43
00:03:06,650 --> 00:03:10,122
But what if you

44
00:03:10,176 --> 00:03:13,866
can't write your component in a way

45
00:03:14,048 --> 00:03:16,998
decoratively, like how you would in react,

46
00:03:17,174 --> 00:03:20,578
but use a tool to turn it into optimized

47
00:03:20,614 --> 00:03:23,774
JavaScript code? That how you would write in

48
00:03:23,812 --> 00:03:27,502
jQuery. Well, that's when I started to learn

49
00:03:27,556 --> 00:03:28,910
about Svelte.

50
00:03:31,410 --> 00:03:34,894
Here's the svelte syntax. It's closely resemblance

51
00:03:34,942 --> 00:03:38,638
of the HTML syntax and you can define variables

52
00:03:38,654 --> 00:03:43,102
in a script text and use it in the HTML using the clear brackets.

53
00:03:43,246 --> 00:03:47,494
You can define CSS in a style tag to

54
00:03:47,532 --> 00:03:50,630
make changes of the variable. You can modify them directly

55
00:03:51,050 --> 00:03:54,630
like this. Here we add a click event

56
00:03:54,700 --> 00:03:57,510
listener called the decrement,

57
00:03:58,090 --> 00:04:01,866
which when we click on the button we'll call the decrement function, which will

58
00:04:01,888 --> 00:04:05,066
then modify the counter variable. And then you'll see that

59
00:04:05,088 --> 00:04:08,154
the counter value that we use in the curly brackets over

60
00:04:08,192 --> 00:04:12,160
here in a div will update immediately. Is that simple?

61
00:04:12,610 --> 00:04:16,014
But how does that work? A lot of time I hear this

62
00:04:16,052 --> 00:04:19,182
explanation where people say svelte is

63
00:04:19,236 --> 00:04:22,542
a compiler based framework. Takes a code.

64
00:04:22,596 --> 00:04:26,226
You write, analyze and compile it into JavaScript. So you can

65
00:04:26,248 --> 00:04:29,806
do a lot of magical things that you can do in JavaScript.

66
00:04:29,998 --> 00:04:32,946
But still, how does it work?

67
00:04:33,128 --> 00:04:36,802
I'm a big fan of the idea getting your hands dirty,

68
00:04:36,946 --> 00:04:40,582
learning by building. And I probably learn a lot

69
00:04:40,636 --> 00:04:44,422
from content like this. Say for example writing a library using

70
00:04:44,476 --> 00:04:47,350
jquery. Build your own react.

71
00:04:48,170 --> 00:04:51,366
But what about build your own svelte?

72
00:04:51,558 --> 00:04:55,418
I haven't find any content about that yet. So today we're going to

73
00:04:55,504 --> 00:04:58,540
going to do that and figure anything out together.

74
00:04:59,310 --> 00:05:02,750
I do realize that this may be the first time for some of you to

75
00:05:02,820 --> 00:05:06,954
hear about svelte. It's okay. I have a series of YouTube tutorials

76
00:05:07,002 --> 00:05:10,510
teaching about Svelte. You can visit them my YouTube channel,

77
00:05:10,660 --> 00:05:14,462
watch them later. But today, instead of talking about how to use

78
00:05:14,516 --> 00:05:17,902
svelte, I'm going to talk about how to create spelt,

79
00:05:18,046 --> 00:05:22,370
how to create a compiler based framework like spelt or quick

80
00:05:22,520 --> 00:05:26,294
or Astro, meta frameworks like Astro, and we're going to hear

81
00:05:26,332 --> 00:05:27,720
about them.

82
00:05:29,130 --> 00:05:32,550
And today I'm going to talk about how you can create

83
00:05:32,620 --> 00:05:36,450
a compiler. The word compiler

84
00:05:36,530 --> 00:05:40,380
sounds very scary to me when I first started to get

85
00:05:41,950 --> 00:05:45,100
figuring this out. Well,

86
00:05:46,670 --> 00:05:50,380
don't worry, we are here together to learn this

87
00:05:50,930 --> 00:05:54,718
min general this is a breakdown of what a compiler do.

88
00:05:54,884 --> 00:05:58,622
It takes your code, parse it, analyze it,

89
00:05:58,676 --> 00:06:03,158
and finally generate an output. Let's take a look closer

90
00:06:03,194 --> 00:06:06,546
look at each of this step. First,

91
00:06:06,648 --> 00:06:10,594
when we say the compiler process your code, it takes your code

92
00:06:10,712 --> 00:06:13,922
and generates a representation of your code that

93
00:06:13,976 --> 00:06:17,990
probably looks like a tree structure. And we call this

94
00:06:18,140 --> 00:06:21,938
an abstract syntax tree or ast

95
00:06:22,034 --> 00:06:25,638
for shots. It is called abstract because it contains the

96
00:06:25,644 --> 00:06:29,814
abstract structure of a code as compiler to concrete

97
00:06:29,862 --> 00:06:33,334
syntax tree, which contains all the concrete

98
00:06:33,382 --> 00:06:37,434
detail such as where is the semicolon, where is the parenthesis and

99
00:06:37,472 --> 00:06:41,402
things like that. So for abstract syntax tree just contains

100
00:06:41,466 --> 00:06:44,990
the semantic meaning of insight as a tree.

101
00:06:46,690 --> 00:06:49,914
And then the compiler analyzes this tree,

102
00:06:50,042 --> 00:06:54,314
the code through this tree. What this means is that irrecursively

103
00:06:54,362 --> 00:06:58,434
going through every code of your ast, trying to gather information such

104
00:06:58,472 --> 00:07:01,530
as maybe what are the variables being declared, what are the

105
00:07:01,540 --> 00:07:04,782
variables being used, and what variables will be changed

106
00:07:04,846 --> 00:07:08,246
and so forth. And armed with that information,

107
00:07:08,348 --> 00:07:12,070
the compiler is then able to generate a more optimized code.

108
00:07:12,220 --> 00:07:15,670
So today, with time permits, we're going to implement a very,

109
00:07:15,740 --> 00:07:18,970
very simplified version of spelt.

110
00:07:20,110 --> 00:07:23,610
This will be our compiles that we are going to compile.

111
00:07:23,950 --> 00:07:27,338
Any feature that you see on here will be used.

112
00:07:27,424 --> 00:07:30,714
Any feature that you don't see in this component will

113
00:07:30,752 --> 00:07:34,254
not be implemented. This is the example

114
00:07:34,372 --> 00:07:37,726
of the counter component that we just saw where you

115
00:07:37,748 --> 00:07:41,642
have two buttons, one click to decrement, one click to increment,

116
00:07:41,786 --> 00:07:44,370
and you have a div that contains the counter.

117
00:07:44,790 --> 00:07:48,162
Right? So here, let's take a look at my

118
00:07:48,216 --> 00:07:52,100
project setup. So here I have

119
00:07:53,110 --> 00:07:55,300
prepared with you with the code.

120
00:07:56,970 --> 00:08:00,520
Let me zoom that in a bit more. So here

121
00:08:01,690 --> 00:08:05,762
I have a app, dots felt, which is the counter component

122
00:08:05,826 --> 00:08:08,954
that you just saw. Sorry, I think. Let me clean

123
00:08:08,992 --> 00:08:12,682
this up a bit different. I think so.

124
00:08:12,736 --> 00:08:15,900
Okay, this is exactly the counter component that you just saw.

125
00:08:16,750 --> 00:08:20,362
And later on I will compile this

126
00:08:20,416 --> 00:08:23,774
app svelte into the app js file in this

127
00:08:23,812 --> 00:08:27,226
folder. Okay? And then you see the index HTML.

128
00:08:27,338 --> 00:08:31,006
This is where we are going to import this app js that we will be

129
00:08:31,028 --> 00:08:34,366
generating later on. And we're going to use this to

130
00:08:34,388 --> 00:08:38,358
create amount our component index

131
00:08:38,394 --> 00:08:42,334
JS is where our compiler code will be. So here I've

132
00:08:42,382 --> 00:08:45,122
already written the instructions, right.

133
00:08:45,176 --> 00:08:48,514
So we will read the file into

134
00:08:48,552 --> 00:08:52,274
this content, we're going to parse it into ast. We're going to analyze the AST

135
00:08:52,322 --> 00:08:56,358
to get the analysis. I'm going to use the AST and the analysis to

136
00:08:56,444 --> 00:09:00,454
generate a Javascript code. I'm going to write that file into app js

137
00:09:00,582 --> 00:09:03,706
in the end. So these three functions is what we're going to

138
00:09:03,728 --> 00:09:04,410
implement.

139
00:09:07,070 --> 00:09:10,970
So the first thing we're going to look at is this.

140
00:09:11,120 --> 00:09:15,274
Well we keep mentioning that the svelte compiler will compile this into an optimized

141
00:09:15,322 --> 00:09:18,814
Javascript. But how would that Javascript look like?

142
00:09:19,012 --> 00:09:23,178
Since we are creating a simplified version of svelte, let's design our simplified

143
00:09:23,274 --> 00:09:25,650
version of the svelte output.

144
00:09:27,110 --> 00:09:30,980
First, the simplest code for creating a button like this

145
00:09:31,510 --> 00:09:35,390
is to have these instructions

146
00:09:35,470 --> 00:09:38,950
where we create element going to add event listeners click

147
00:09:39,020 --> 00:09:42,342
and then the decrement function, we're going to append this

148
00:09:42,396 --> 00:09:46,054
button to the parent and to destroy. We are

149
00:09:46,092 --> 00:09:50,154
going to call the remove event listeners to clean up as well as remove child

150
00:09:50,192 --> 00:09:53,900
to remove this element from the parent. So here

151
00:09:55,150 --> 00:09:59,302
we need some function to call the crit and destroy instructions

152
00:09:59,366 --> 00:10:02,926
separately. So let's direct them in an object method like this

153
00:10:02,948 --> 00:10:06,234
one. And also we want to be able to create multiple

154
00:10:06,282 --> 00:10:10,094
counter compiles. So let's have it as a function that

155
00:10:10,132 --> 00:10:13,530
returns the lifecycle object so that we can keep calling

156
00:10:13,620 --> 00:10:17,230
app to create multiple instances of this component.

157
00:10:17,310 --> 00:10:21,054
And then we can call the create to mount

158
00:10:21,102 --> 00:10:24,370
and pass in the target where we are going to mount our component.

159
00:10:25,030 --> 00:10:28,834
Wait, oops, I think I forgot that the button needs

160
00:10:28,872 --> 00:10:32,374
to have some text. Right. So here I'm going to add a few more

161
00:10:32,412 --> 00:10:35,986
lines of code. Here we're going to create a text node. I'm going to append

162
00:10:36,018 --> 00:10:39,722
the text node into the button and we can keep doing this

163
00:10:39,856 --> 00:10:43,126
and this and this and we keep adding code

164
00:10:43,158 --> 00:10:44,490
to build up the component.

165
00:10:46,350 --> 00:10:50,394
Wait, but wait a minute. I think the counter expression is

166
00:10:50,432 --> 00:10:54,014
dynamic. So we need one more way to basically up call to

167
00:10:54,052 --> 00:10:57,278
updates the value updates the content of

168
00:10:57,284 --> 00:11:00,782
the text node. So we're going to create a lifecycle called

169
00:11:00,836 --> 00:11:04,490
updates where we're going to pass in a parameter called change which is

170
00:11:04,580 --> 00:11:08,066
taking min as an array that can contain what are the

171
00:11:08,088 --> 00:11:12,180
variables that will change and then we will change it by setting the data

172
00:11:12,550 --> 00:11:16,226
to the updated value. So here is how we're going

173
00:11:16,248 --> 00:11:20,086
to call this function. And the increment function will probably will

174
00:11:20,108 --> 00:11:23,922
insert a line called lifecycle update. The counter

175
00:11:24,066 --> 00:11:27,222
right here. We're going to probably will do some analysis to figure that

176
00:11:27,276 --> 00:11:31,562
out. Figure out if

177
00:11:31,616 --> 00:11:35,194
we're going to change the counter and if counter will change, we're going to figure

178
00:11:35,232 --> 00:11:39,574
out that where it will be changing and we insert

179
00:11:39,622 --> 00:11:42,720
the lifecycle updates method over there.

180
00:11:43,250 --> 00:11:46,846
That's why the analysis step is very important because it let

181
00:11:46,868 --> 00:11:49,840
us know to know which variables will change.

182
00:11:50,770 --> 00:11:54,100
Okay, but you may ask me one question.

183
00:11:54,550 --> 00:11:58,482
The way I visualize just now, right. We step

184
00:11:58,536 --> 00:12:02,130
through and visualize. This seems very straightforward

185
00:12:04,230 --> 00:12:07,734
from your naked eye. But how do you

186
00:12:07,772 --> 00:12:11,046
actually write the code to do that? Right, because in

187
00:12:11,068 --> 00:12:14,326
essence the code that you see the eye of

188
00:12:14,348 --> 00:12:17,454
a computer is just a bunch of characters.

189
00:12:17,522 --> 00:12:21,082
It's a string. So how do you take

190
00:12:21,136 --> 00:12:25,034
this string and then figure out what other elements are

191
00:12:25,072 --> 00:12:29,034
there? Well, that's why we need to parse the

192
00:12:29,072 --> 00:12:32,366
code into ast. That will be much clearer if you

193
00:12:32,388 --> 00:12:35,434
compare the steps using ast.

194
00:12:35,562 --> 00:12:38,782
So let me walk through the steps that we saw just now,

195
00:12:38,836 --> 00:12:41,838
but with the ast as we go down,

196
00:12:41,924 --> 00:12:45,682
we realize that actually traversing each element is like traversing through

197
00:12:45,736 --> 00:12:48,130
the each node in the ast.

198
00:12:48,790 --> 00:12:52,450
So that's why it's much simpler if you can able to write

199
00:12:52,520 --> 00:12:56,034
a parser to parse the code, right? So now

200
00:12:56,072 --> 00:12:59,890
that begs the question, how do you pass a string into ast?

201
00:13:01,050 --> 00:13:04,358
Well, Min, all things in programming there's always a technique to do it,

202
00:13:04,444 --> 00:13:08,326
and today I'm going to show you how. So first of all, before we

203
00:13:08,348 --> 00:13:11,500
do that, we need to describe how our code should look like.

204
00:13:13,470 --> 00:13:16,854
The way to describe it. We're going to use this thing called a syntax

205
00:13:16,902 --> 00:13:21,190
notation. This is like the design document, like the PRD,

206
00:13:21,350 --> 00:13:24,560
but describing how your syntax should look like.

207
00:13:24,930 --> 00:13:28,314
We need this before we can even start writing our parser.

208
00:13:28,442 --> 00:13:31,854
There are various syntax notation. It could be a real

209
00:13:31,892 --> 00:13:35,726
root diagrams. You can have the Becker's north form.

210
00:13:35,908 --> 00:13:39,202
Well, in this example of the Becker's north form I'm going to show you,

211
00:13:39,336 --> 00:13:42,980
it describes how a JSON object syntax should look like.

212
00:13:43,830 --> 00:13:47,426
So I guess as a JavaScript developer, you are very familiar

213
00:13:47,458 --> 00:13:51,126
with how a JSON object should look like, right? A JSON object could

214
00:13:51,148 --> 00:13:54,550
be either a open and curly brackets like this,

215
00:13:54,700 --> 00:13:58,374
or open brackets, a property list and a

216
00:13:58,412 --> 00:14:01,946
closed brackets, right? So the first one is for an

217
00:14:01,968 --> 00:14:06,010
empty object, this one is for object with some key values.

218
00:14:06,430 --> 00:14:09,834
But what's the syntax of property list? Well, we can define it.

219
00:14:09,872 --> 00:14:14,000
Again, the syntax of a property list can be a property

220
00:14:14,690 --> 00:14:17,966
or a property list with a comma and

221
00:14:17,988 --> 00:14:21,710
then a property. So you can see the recursiveness in terms of

222
00:14:21,860 --> 00:14:25,714
how you can define the syntax. So now what is the property?

223
00:14:25,832 --> 00:14:29,230
Well, the property can be a string

224
00:14:29,390 --> 00:14:32,994
and then a colon, the colon string, and then a

225
00:14:33,032 --> 00:14:35,794
value, right? And then you can keep doing this,

226
00:14:35,912 --> 00:14:38,894
define how you look like as a syntax of a string,

227
00:14:38,942 --> 00:14:42,054
and what's the syntax of the value? But that's not what we're going to do

228
00:14:42,092 --> 00:14:46,070
here today we're going to talk about syntax of svelte.

229
00:14:46,410 --> 00:14:50,174
So here's how I'm going to define the syntax of svelte.

230
00:14:50,322 --> 00:14:53,638
Say, syntax of svelte is a fragments,

231
00:14:53,814 --> 00:14:57,622
which is made up of a fragment

232
00:14:57,686 --> 00:15:01,854
or multiple fragments without any space with

233
00:15:01,892 --> 00:15:05,854
the fragment. So fragment itself can

234
00:15:05,892 --> 00:15:09,294
be a script, an element, or expressions or

235
00:15:09,332 --> 00:15:12,858
text. So now we're going to define the syntax of a script.

236
00:15:12,954 --> 00:15:16,346
Well, for the script is the brackets,

237
00:15:16,538 --> 00:15:20,130
angle brackets, S-C-R-I-P-T angle brackets,

238
00:15:20,950 --> 00:15:24,974
and then with some Javascript and then angle brackets

239
00:15:25,022 --> 00:15:28,754
again, S-C-R-I-P-T angle brackets. So this is a syntax

240
00:15:28,802 --> 00:15:31,942
for the script. How about elements? Well,

241
00:15:31,996 --> 00:15:35,266
elements is a angle brackets, the name of the tag,

242
00:15:35,298 --> 00:15:38,178
tag names, attribute lists and angle brackets,

243
00:15:38,274 --> 00:15:41,594
fragments, angle brackets, fragments, tag name

244
00:15:41,632 --> 00:15:44,794
and angle brackets. We can keep doing this for each

245
00:15:44,832 --> 00:15:48,522
of them, right? So for example, attributes is an attribute name with

246
00:15:48,576 --> 00:15:52,266
equal curly brackets and then Javascript and then curly brackets.

247
00:15:52,458 --> 00:15:57,040
Keep doing all this. Okay, so now

248
00:15:57,970 --> 00:16:01,550
after we have this, now it's time to implement our

249
00:16:01,620 --> 00:16:05,042
parser. Let me close this. Okay,

250
00:16:05,096 --> 00:16:09,086
so now let's write some basic structure for our parser.

251
00:16:09,278 --> 00:16:13,266
Going to type real fast over here. Wow. So the

252
00:16:13,288 --> 00:16:16,738
thing is, I'm going to here create a few helper functions I'm going

253
00:16:16,744 --> 00:16:19,846
to create a few helper functions for each type of the node that we are

254
00:16:19,868 --> 00:16:23,202
going to pass. So just now we see that we have fragments,

255
00:16:23,266 --> 00:16:27,160
fragment, Javascript element attribute. Yeah, so we're going to just create

256
00:16:27,610 --> 00:16:30,418
one function for each of the type, right?

257
00:16:30,444 --> 00:16:33,734
So here this structure, you see that we're going to create an ast,

258
00:16:33,862 --> 00:16:36,906
an object that represents the tree itself

259
00:16:37,008 --> 00:16:40,598
and call the past fragments to give us the ast. And here

260
00:16:40,624 --> 00:16:43,440
I'm going to define a variable called I. But what is I?

261
00:16:44,210 --> 00:16:48,590
So if you see I, I is actually a pointer.

262
00:16:49,010 --> 00:16:52,080
It will be a pointer that points to

263
00:16:53,170 --> 00:16:56,434
the character we have in the string. And the core idea

264
00:16:56,472 --> 00:17:00,654
of a parser is to match the characters where I is currently pointing

265
00:17:00,702 --> 00:17:04,158
at. Like here we are pointing min the angle brackets,

266
00:17:04,334 --> 00:17:08,242
and based on the syntax rule we can decide

267
00:17:08,306 --> 00:17:11,862
whether to advance or to read

268
00:17:11,916 --> 00:17:14,920
the value out from where I is pointing at.

269
00:17:15,610 --> 00:17:18,986
So we have our rules and we're going to figure out how to advance and

270
00:17:19,008 --> 00:17:23,100
match the characters based on where I is pointing at.

271
00:17:24,110 --> 00:17:27,546
So I have this page that shows you the syntax and let's get

272
00:17:27,568 --> 00:17:31,582
back to the code. So the first syntax that we see is

273
00:17:31,716 --> 00:17:35,630
fragments, which can be one fragment or multiple fragments.

274
00:17:36,130 --> 00:17:39,530
So before we actually go that, right, I think let's

275
00:17:39,690 --> 00:17:43,422
write some helper function for us to

276
00:17:43,476 --> 00:17:46,658
advance, match, advanced and read value. We're going

277
00:17:46,664 --> 00:17:50,450
to have one helper function for each. So to match

278
00:17:50,520 --> 00:17:53,522
the value I'm going to create the match function,

279
00:17:53,656 --> 00:17:57,622
which basically gives me a boolean value to tell me whether the

280
00:17:57,676 --> 00:18:01,078
I that's pointing at matches the value that we're going

281
00:18:01,084 --> 00:18:04,614
to call it. Right? So we're going to slice that string out and

282
00:18:04,652 --> 00:18:08,066
compare whether we match where I pointing

283
00:18:08,098 --> 00:18:11,420
at is matching the value. The string that we're going to pass min

284
00:18:11,870 --> 00:18:15,002
and the next one is trying to advance I, right?

285
00:18:15,056 --> 00:18:17,900
So I'm going to call this function called it.

286
00:18:18,270 --> 00:18:21,040
And the way how it works is that,

287
00:18:23,330 --> 00:18:27,294
for example, if I try to pass an

288
00:18:27,332 --> 00:18:28,960
attribute over here, for example,

289
00:18:30,690 --> 00:18:33,906
after I reach the attribute name, I know that the

290
00:18:33,928 --> 00:18:37,922
next thing I need to have

291
00:18:38,056 --> 00:18:41,742
is the equal and curly brackets.

292
00:18:41,886 --> 00:18:45,746
I try to match this, I will match this and

293
00:18:45,848 --> 00:18:49,334
if it matches then I will advance my eye, right?

294
00:18:49,452 --> 00:18:53,346
And if it does not match, then it's a syntax error,

295
00:18:53,378 --> 00:18:56,806
right? So basically we don't really care what symbol is this, we just

296
00:18:56,828 --> 00:18:59,894
want to match and then advance I and if it does not

297
00:18:59,932 --> 00:19:03,402
match, we're going to throw a syntax error and this is what exactly I'm doing,

298
00:19:03,456 --> 00:19:06,726
right, I've matched an advance. If not, I'm going to throw

299
00:19:06,758 --> 00:19:10,218
a syntax error, then lastly is trying to read the

300
00:19:10,224 --> 00:19:13,454
value out, right? So this case will be the case where we're going to use

301
00:19:13,492 --> 00:19:17,166
for reading value out, say the attribute name, reading the

302
00:19:17,188 --> 00:19:20,734
tag name or the attribute value, right? So here

303
00:19:20,772 --> 00:19:24,254
I'm going to create this function called read while matching. Basically it takes

304
00:19:24,292 --> 00:19:28,078
min a regular expressions, and as long as the regular expressions

305
00:19:28,174 --> 00:19:31,902
matches the content where I is pointing at, then we'll keep advancing

306
00:19:31,966 --> 00:19:36,018
I and then we're going to return whatever we have read

307
00:19:36,184 --> 00:19:40,054
so far while advancing I so the first thing is the

308
00:19:40,092 --> 00:19:43,494
fragments, right? So fragments is going to be

309
00:19:43,532 --> 00:19:47,234
an array and we are going to keep calling the parse fragments

310
00:19:47,282 --> 00:19:50,534
to read out the fragments and going to push it into the array.

311
00:19:50,662 --> 00:19:52,970
And this is the parse fragments.

312
00:19:53,630 --> 00:19:57,082
So for fragment itself we have seen here that

313
00:19:57,136 --> 00:20:00,666
it will be either a script element, expressions or text.

314
00:20:00,848 --> 00:20:04,206
So I'm going to rely on these functions to

315
00:20:04,228 --> 00:20:07,840
help me. Right, so you get a script element, expression or text.

316
00:20:08,530 --> 00:20:12,334
Well now let's go to the more difficult one,

317
00:20:12,372 --> 00:20:16,434
right, script, how do you pass a Javascript? Let's take a look. So for

318
00:20:16,472 --> 00:20:20,034
script we're going to match this string, right, SdRI PT with

319
00:20:20,072 --> 00:20:23,506
angle brackets, and I'm going to keep reading anything until we

320
00:20:23,528 --> 00:20:27,518
hit the angle bracket sri pt so

321
00:20:27,544 --> 00:20:31,734
this is how we're going to parse the Javascript. So here

322
00:20:31,772 --> 00:20:35,286
I'm going to match script and then I'm going to edit this so

323
00:20:35,308 --> 00:20:38,582
that we can advance, and then later on it will just keep

324
00:20:38,636 --> 00:20:42,498
reading contents until we find the angle brackets.

325
00:20:42,594 --> 00:20:45,786
SRi pt so this is the code that we're going to

326
00:20:45,808 --> 00:20:49,818
take it out. And of course today I'm not going to spend my time to

327
00:20:49,824 --> 00:20:53,246
figure out how we can write a JavaScript parcel. We can actually use a

328
00:20:53,268 --> 00:20:56,718
library to do that for me. So I'm going

329
00:20:56,724 --> 00:20:59,722
to use import set library,

330
00:20:59,786 --> 00:21:03,490
which is called econt. Okay, I'm going to parse it

331
00:21:03,640 --> 00:21:07,010
and then I'm going to advance my eye and also eat away

332
00:21:07,080 --> 00:21:10,660
the closing JavaScript tags. And that's it.

333
00:21:11,990 --> 00:21:15,298
So for parse element, let's see.

334
00:21:15,464 --> 00:21:19,234
So for parse element we're going to have angle brackets, the tag

335
00:21:19,282 --> 00:21:22,662
name attribute list, angle brackets and then pass

336
00:21:22,716 --> 00:21:26,502
fragments, again, angle bracket slash and then eat away

337
00:21:26,556 --> 00:21:29,962
this tag name, right? So it's like matching read

338
00:21:30,016 --> 00:21:33,014
while matching parse attribute,

339
00:21:33,062 --> 00:21:36,230
list it, this pass fragments

340
00:21:36,390 --> 00:21:39,994
at the angle bracket, slash it, the tag name

341
00:21:40,032 --> 00:21:43,566
as well as angle brackets. Let's try to do that.

342
00:21:43,668 --> 00:21:47,246
Right. First we're going to match edit and

343
00:21:47,268 --> 00:21:51,198
I'm going to read while matching and I'm going to pass and then yeah,

344
00:21:51,284 --> 00:21:55,006
so basically how we see

345
00:21:55,028 --> 00:21:58,626
the syntax rule, how we translate it and how we just type it out.

346
00:21:58,728 --> 00:22:02,574
So for children we're going to call past fragments, but the past fragments

347
00:22:02,622 --> 00:22:06,046
that we have over here will keep reading

348
00:22:06,078 --> 00:22:08,894
until we hit the end of the contents.

349
00:22:08,942 --> 00:22:12,214
But the past fragment here I'm going to use is until we hit

350
00:22:12,252 --> 00:22:15,798
the closing tag, right? So maybe we want to have a different condition. So we're

351
00:22:15,804 --> 00:22:19,366
going to create a parameter called condition, replace it,

352
00:22:19,548 --> 00:22:23,210
and so here we're going to keep matching until we'll match the end tag,

353
00:22:24,590 --> 00:22:28,698
right? So here on top we're going to just keep reading until

354
00:22:28,784 --> 00:22:32,026
we hit the end of the content. So we have

355
00:22:32,128 --> 00:22:36,014
passed elements, let's go to pass attribute list. This is

356
00:22:36,052 --> 00:22:40,318
kind of similar to pass fragments. So going to

357
00:22:40,484 --> 00:22:44,174
have an attribute array and then skip white space, right? So in

358
00:22:44,212 --> 00:22:46,900
each attribute we're going to have one white space.

359
00:22:48,150 --> 00:22:51,806
So the white space can be more one character white space, multiple character

360
00:22:51,838 --> 00:22:55,742
white space. So how we can do that is actually we're going to reuse

361
00:22:55,806 --> 00:22:59,202
some of the utilities that we already have, like the read while matching,

362
00:22:59,346 --> 00:23:03,266
basically skipping white space will be like reading white spaces

363
00:23:03,298 --> 00:23:06,678
character, but then we just ignore whatever we read out so far.

364
00:23:06,844 --> 00:23:10,700
Okay, so now, next thing. So now we're going to

365
00:23:11,150 --> 00:23:14,502
keep reading attribute until we hit the angle brackets,

366
00:23:14,566 --> 00:23:18,326
which tells us that we are at the end of this opening

367
00:23:18,358 --> 00:23:21,966
tag. So while we are not

368
00:23:21,988 --> 00:23:25,706
matching, we're going to call pass attributes and then we're going to keep looping

369
00:23:25,738 --> 00:23:29,710
that. So for pass attributes here,

370
00:23:29,780 --> 00:23:33,342
if you see, we will be keep reading whatever

371
00:23:33,396 --> 00:23:36,754
it is until it hits the equal sign and then we're going to eat these

372
00:23:36,792 --> 00:23:40,206
two characters until it hits

373
00:23:40,238 --> 00:23:44,514
the color brackets and then we're going to eat the color brackets so

374
00:23:44,552 --> 00:23:48,520
here I'm going to read while matching, type out real quick,

375
00:23:51,130 --> 00:23:55,430
right, it's it. And so for pass expressions,

376
00:23:56,410 --> 00:24:00,022
if you see here, we're going to eat curly brackets,

377
00:24:00,086 --> 00:24:04,214
some JavaScript and curly brackets. So we're going to match curly

378
00:24:04,262 --> 00:24:08,214
brackets, eat that, parse JavaScript and it another closing curly

379
00:24:08,262 --> 00:24:11,486
brackets for text. Basically it

380
00:24:11,508 --> 00:24:15,514
will be anything that is not script elements or expressions.

381
00:24:15,642 --> 00:24:20,030
So basically we can keep reading any value until we hit

382
00:24:20,180 --> 00:24:23,710
the angle brackets or the curly brackets.

383
00:24:25,090 --> 00:24:27,570
So we're going to use the read while matching,

384
00:24:28,470 --> 00:24:31,998
and then we're going to trim away some of the empty spaces.

385
00:24:32,094 --> 00:24:35,714
So if you take a look over here, the code from here to

386
00:24:35,752 --> 00:24:39,134
here, there are some new lines, characters, but we're just going to make

387
00:24:39,192 --> 00:24:42,966
things easy. We're just going to skip and don't see them. So as long

388
00:24:42,988 --> 00:24:46,854
as the text is maybe after we trim is just content full

389
00:24:46,892 --> 00:24:50,410
of anti strings, then white spaces, then we're just going to ignore it

390
00:24:50,480 --> 00:24:55,114
and only have the code for text that

391
00:24:55,152 --> 00:24:58,234
has actual values. So finally we're going to

392
00:24:58,272 --> 00:25:01,454
call Parse Javascript here, we're going to use acon to help us to do

393
00:25:01,492 --> 00:25:04,798
that. Okay? And I think that's it.

394
00:25:04,884 --> 00:25:09,438
Right, so let's see our result. So here

395
00:25:09,604 --> 00:25:11,360
I'm going to call my,

396
00:25:12,870 --> 00:25:17,058
hold on, let me see here we can pass,

397
00:25:17,144 --> 00:25:20,574
and then since we ever have the analysis and generate, let's comment

398
00:25:20,622 --> 00:25:24,500
them out. So I'm going to write the code,

399
00:25:26,170 --> 00:25:29,202
the ast that we have into a JSON

400
00:25:29,266 --> 00:25:32,280
file est. Okay,

401
00:25:33,050 --> 00:25:34,440
I'm going to run this.

402
00:25:37,470 --> 00:25:41,018
And here we see basically our est

403
00:25:41,104 --> 00:25:44,282
that we do. Yay. Okay,

404
00:25:44,336 --> 00:25:47,846
so here we have our, let's collapse

405
00:25:47,878 --> 00:25:51,342
this. Here we have our HTML, which is the ast of the

406
00:25:51,476 --> 00:25:54,800
template, right? So here if you look side by side,

407
00:25:57,970 --> 00:26:02,170
you will see that we have the elements,

408
00:26:02,250 --> 00:26:05,390
which is the button over here, and then you have attributes,

409
00:26:05,750 --> 00:26:09,774
which contains name on click and the value which is JavaScript

410
00:26:09,822 --> 00:26:13,570
est. And then next we have the children, which is the text

411
00:26:13,640 --> 00:26:17,094
code. It's called decrement. So next one we have this

412
00:26:17,132 --> 00:26:21,622
element called div children. And yeah,

413
00:26:21,756 --> 00:26:24,440
basically we have everything now. Okay,

414
00:26:28,090 --> 00:26:31,962
so I think that's it for parsing. Yay. It's not that hard,

415
00:26:32,016 --> 00:26:35,786
right? You can do that. So I think let's continue

416
00:26:35,968 --> 00:26:39,930
when writing the next part, which is to do analysis.

417
00:26:42,190 --> 00:26:46,240
So to analyze our code, this is our JavaScript code.

418
00:26:47,090 --> 00:26:50,350
If you just look at it, you probably can tell that there will be three

419
00:26:50,420 --> 00:26:53,874
variables, right? These are the variables that be top level and be able

420
00:26:53,992 --> 00:26:57,042
to be used in your template. And you also

421
00:26:57,096 --> 00:27:00,626
can tell from the eye because I believe you are

422
00:27:00,728 --> 00:27:03,842
experienced developer can probably tell that

423
00:27:03,976 --> 00:27:07,310
here we are modifying counter,

424
00:27:07,470 --> 00:27:10,566
right, because the variable names is the same,

425
00:27:10,748 --> 00:27:14,470
but it's not that straightforward. It's not just about variable names because

426
00:27:14,540 --> 00:27:18,118
if you look at the code right here you

427
00:27:18,124 --> 00:27:21,446
can probably say that, yeah, you're right, because although the counter

428
00:27:21,478 --> 00:27:25,306
variable has the same variable name, but this is modifying the counter being

429
00:27:25,328 --> 00:27:28,922
declared locally and not modifying the counter variable up

430
00:27:28,976 --> 00:27:32,702
there, right? And this is because of this concept called

431
00:27:32,756 --> 00:27:36,266
a shopee, right. Each of this scope you can declare a variable,

432
00:27:36,378 --> 00:27:39,806
define a variable, and then if you are

433
00:27:39,908 --> 00:27:43,114
assessing the variable, you'll be looking from the inner scope

434
00:27:43,162 --> 00:27:46,580
before we look up to the outer scope, right? So here

435
00:27:47,670 --> 00:27:51,314
there is three shopee, but you may ask me how

436
00:27:51,352 --> 00:27:54,594
do I know, how do I tell from Li Hau Tan tell

437
00:27:54,632 --> 00:27:58,214
there's multiple scope, but how do you able

438
00:27:58,252 --> 00:28:01,240
to tell that with your code?

439
00:28:02,090 --> 00:28:05,542
Well, it will be much easier if you have the ast, right?

440
00:28:05,596 --> 00:28:09,670
So this is the ast for the Javascript and you try to color code

441
00:28:09,740 --> 00:28:13,542
the scope, you'll see that a scope

442
00:28:13,686 --> 00:28:16,220
is like a subtree of your est.

443
00:28:17,230 --> 00:28:20,874
So the root of that subtree is a node

444
00:28:20,922 --> 00:28:24,638
that creates a new scope. And today

445
00:28:24,724 --> 00:28:29,454
we're not going to figure

446
00:28:29,492 --> 00:28:32,946
out how to write the code to analyze the shopee. I'm going to use a

447
00:28:32,968 --> 00:28:35,860
library called periscopic to do that for us.

448
00:28:36,470 --> 00:28:39,890
Okay, so I'm going to import this library.

449
00:28:40,470 --> 00:28:43,780
No, I think let me walk through one more.

450
00:28:46,470 --> 00:28:49,778
So we're going to have this periscopic. What it does is that you can analyze

451
00:28:49,794 --> 00:28:53,362
the JavaScript est and it returns you the map, the globals

452
00:28:53,426 --> 00:28:58,374
and the scope. Okay, so the

453
00:28:58,412 --> 00:29:01,846
scope is the root shopee and then the map

454
00:29:01,958 --> 00:29:05,386
is actually a mapping of the code that creates scope and the

455
00:29:05,408 --> 00:29:08,970
scope itself. So in this case if you have three

456
00:29:09,120 --> 00:29:12,310
code, then the map will have three entries,

457
00:29:12,390 --> 00:29:15,994
right? The keys will be this code, this node and this node,

458
00:29:16,122 --> 00:29:19,726
and then the value will be the scope that the

459
00:29:19,748 --> 00:29:23,086
root scope, the two child scope that it creates,

460
00:29:23,118 --> 00:29:26,914
the scope one and scope two. Okay, so with

461
00:29:26,952 --> 00:29:30,142
that I think we probably should start writing

462
00:29:30,206 --> 00:29:33,314
some code in our analysis. So here,

463
00:29:33,352 --> 00:29:36,398
let's figure out some structure.

464
00:29:36,574 --> 00:29:39,682
First is what we're going to analyze. So we're going to have the object

465
00:29:39,736 --> 00:29:43,558
called results. I'm going to store things like what we're going to analyze over here.

466
00:29:43,724 --> 00:29:47,078
So we have three things, right? The variables, what are variables and what are the

467
00:29:47,084 --> 00:29:50,410
variables will change and what are the variables will be used in a template.

468
00:29:52,030 --> 00:29:55,654
So the first thing is that analysis.

469
00:29:55,782 --> 00:29:59,626
Are we going to call it periscopic to analyze the scope for

470
00:29:59,648 --> 00:30:02,540
me? So here,

471
00:30:02,910 --> 00:30:06,254
based on what is defined in the root scope, we can

472
00:30:06,292 --> 00:30:09,006
declare in root scope we can tell that these are the variables that you can

473
00:30:09,028 --> 00:30:12,286
use, right? And then we're going to keep the root scope and

474
00:30:12,308 --> 00:30:15,890
the map in the results so that we can use them later on as well.

475
00:30:16,040 --> 00:30:19,714
So we need to figure out what is the current scope. I'm going to use

476
00:30:19,752 --> 00:30:23,646
a library to then traverse

477
00:30:23,678 --> 00:30:27,518
through the tree. This library called Esri Walker,

478
00:30:27,614 --> 00:30:31,094
it has two callbacks. One is the enter we will call

479
00:30:31,132 --> 00:30:34,726
whenever we enter a node and then we will call whenever we are leaving the

480
00:30:34,748 --> 00:30:38,486
node. So how this Esri Walker works is

481
00:30:38,508 --> 00:30:42,058
that it uses the daffer search. So it will

482
00:30:42,144 --> 00:30:44,890
traverse the tree in a daffer search manner.

483
00:30:45,710 --> 00:30:49,990
And you see that we're going to figure out what is the scope,

484
00:30:50,070 --> 00:30:53,418
right? And because of this deferred search

485
00:30:53,504 --> 00:30:57,946
manner, we can't actually able to tell what is the current scope

486
00:30:58,138 --> 00:31:01,470
because whenever it looks, does the

487
00:31:01,540 --> 00:31:05,710
deferred search traversal whenever it enters its node

488
00:31:05,790 --> 00:31:07,970
that is creating a new shopee.

489
00:31:08,790 --> 00:31:12,622
We can find this by looking at the map that returns from the periscopic.

490
00:31:12,686 --> 00:31:16,194
Whenever we found a map we say okay, now this

491
00:31:16,232 --> 00:31:19,446
is a node that creates scope. Then we'll set the current scope as the

492
00:31:19,468 --> 00:31:23,126
scope that this code creates. And then we step through,

493
00:31:23,228 --> 00:31:27,058
therefore search and keep traversing through the inner child nodes.

494
00:31:27,154 --> 00:31:30,886
And then as we come back up and we encounter

495
00:31:30,918 --> 00:31:34,726
this node again, realize that, okay, now we're exiting this scope,

496
00:31:34,758 --> 00:31:39,334
we're going back to the parent scope, right? So when we exit, we'll reset

497
00:31:39,462 --> 00:31:43,840
back this current scope to the parent scope, right? So here

498
00:31:45,010 --> 00:31:48,574
whenever we encounter a node that has

499
00:31:48,612 --> 00:31:52,254
in the map, then we can set the current shopee as the

500
00:31:52,292 --> 00:31:56,526
scope that we're being created by the nodes. And if we encounter

501
00:31:56,558 --> 00:32:00,686
a node when we're leaving, then we update the current scope as the parent scope.

502
00:32:00,878 --> 00:32:04,594
So now with the scope, now we can know, now we can

503
00:32:04,632 --> 00:32:07,878
find the variables, whether the variables is being declared in

504
00:32:07,884 --> 00:32:11,234
the scope. We can use the current scope to figure out where this variable

505
00:32:11,282 --> 00:32:14,742
is being declared. So here we're going to

506
00:32:14,796 --> 00:32:18,314
check, I think first is

507
00:32:18,352 --> 00:32:21,818
we need to figure out what are the

508
00:32:21,984 --> 00:32:26,042
code that will make changes, right? So here we use

509
00:32:26,096 --> 00:32:28,730
a tool called the est Explorer.

510
00:32:29,390 --> 00:32:32,814
I just pasted the code in here so you can

511
00:32:32,852 --> 00:32:36,174
see over here, if I hover over here,

512
00:32:36,212 --> 00:32:39,434
that you will see that this is an update

513
00:32:39,482 --> 00:32:43,122
expressions and then the variable itself is

514
00:32:43,176 --> 00:32:46,626
in the argument name. This is the

515
00:32:46,648 --> 00:32:48,900
variable name. Okay,

516
00:32:50,070 --> 00:32:54,398
so we need to check if the node type is update expressions

517
00:32:54,574 --> 00:32:58,402
and we ask the current scope, which scope that we declare

518
00:32:58,466 --> 00:33:01,638
this argument name, this variable name.

519
00:33:01,804 --> 00:33:04,706
And if this is being declared in the root scope,

520
00:33:04,818 --> 00:33:07,474
then we know we encounter something that's changed.

521
00:33:07,602 --> 00:33:10,940
Then we're going to say result will change. We'll add this thing in.

522
00:33:11,470 --> 00:33:14,822
Okay, and I think that's it for analyzing

523
00:33:14,966 --> 00:33:18,166
what variables will change. The next thing I want to analyze

524
00:33:18,198 --> 00:33:22,174
also is what are the variables that will be used in a template. So here

525
00:33:22,212 --> 00:33:26,154
what we can do is we're going to traverse through the ast

526
00:33:26,202 --> 00:33:28,750
that we just created, the fragments.

527
00:33:30,530 --> 00:33:33,934
And then over here we are going to look at two things, right?

528
00:33:33,972 --> 00:33:37,458
So first is that if it's being used as the attribute value,

529
00:33:37,544 --> 00:33:40,914
then this is the variable that we just assume this

530
00:33:40,952 --> 00:33:44,658
is being used in a template. And over here also if this

531
00:33:44,744 --> 00:33:48,086
variable is in an expression, we are going to say it's being

532
00:33:48,108 --> 00:33:51,750
used in a template. So encounter,

533
00:33:52,170 --> 00:33:56,086
depending on which type of the frank type we encounter, if it's an

534
00:33:56,108 --> 00:33:59,702
element we just keep traversing its children and its

535
00:33:59,756 --> 00:34:03,386
attribute. And if

536
00:34:03,408 --> 00:34:07,066
it's an attribute, then we're going to say attribute value is

537
00:34:07,088 --> 00:34:10,686
being used in a template. And if it's expression, I'm going

538
00:34:10,708 --> 00:34:14,350
to say the expression value itself

539
00:34:14,420 --> 00:34:16,030
will be used in the templates.

540
00:34:19,730 --> 00:34:23,026
And I think that is it

541
00:34:23,128 --> 00:34:26,020
for analyzing. Let's try and run our code.

542
00:34:27,670 --> 00:34:31,486
This time around I'm going to comment way analysis

543
00:34:31,518 --> 00:34:34,850
and generate MJ's console out analysis.

544
00:34:39,210 --> 00:34:43,282
So let me run the code and you'll see this is the analysis

545
00:34:43,346 --> 00:34:47,334
results on the variables change and be used

546
00:34:47,372 --> 00:34:52,714
in templates. And if I come over here and

547
00:34:52,752 --> 00:34:56,060
try and change something, for example, if I remove this too,

548
00:34:56,830 --> 00:35:00,460
just completely remove it, then you'll see that,

549
00:35:01,730 --> 00:35:02,720
hold on.

550
00:35:06,530 --> 00:35:10,954
Then you'll see that variable

551
00:35:11,002 --> 00:35:13,810
that we use in the template is only decrement,

552
00:35:16,150 --> 00:35:19,426
right? And if I try to come

553
00:35:19,448 --> 00:35:23,122
over here and say, for example, remove this

554
00:35:23,256 --> 00:35:27,086
variable, then you'll see that the variables we

555
00:35:27,128 --> 00:35:30,018
have left is counter and decrement.

556
00:35:30,194 --> 00:35:33,398
And over here if I try to say let

557
00:35:33,484 --> 00:35:36,786
counter equals to zero, then we know that this counter is actually referring

558
00:35:36,818 --> 00:35:40,570
to discounter rather than outer one. And run analysis again.

559
00:35:40,720 --> 00:35:44,266
You see that world change is now an empty set.

560
00:35:44,368 --> 00:35:48,106
We didn't change any variables. Okay, so let

561
00:35:48,128 --> 00:35:51,454
me reset this back and then I

562
00:35:51,492 --> 00:35:54,480
think it's time to go back to our code.

563
00:35:56,690 --> 00:36:01,280
So now we're able to analyze and

564
00:36:01,810 --> 00:36:05,106
parse and then analyze our code. I think the

565
00:36:05,128 --> 00:36:09,502
next thing is we're going to figure out how we can generate

566
00:36:09,566 --> 00:36:10,420
the code.

567
00:36:12,950 --> 00:36:16,034
So the idea of generating each code will be

568
00:36:16,152 --> 00:36:19,606
as simple as going through each node and then figure out

569
00:36:19,628 --> 00:36:22,982
what are the instructions that we need to insert for

570
00:36:23,036 --> 00:36:26,630
creating and destroying the elements. So we're going to go through each

571
00:36:26,700 --> 00:36:29,660
of the element and figure out what are the instructions needed.

572
00:36:30,430 --> 00:36:33,674
So let's go back to our code. So here I'm going to

573
00:36:33,712 --> 00:36:37,770
write something, right? So for generate, going to create a few arrays

574
00:36:38,110 --> 00:36:42,590
which this will containing the instructions for create, update and destroy,

575
00:36:42,930 --> 00:36:45,760
and then also the list of variables that we use.

576
00:36:46,130 --> 00:36:49,360
So here the code will look something like this.

577
00:36:52,210 --> 00:36:55,698
So here, min, create, update, destroy. We're going

578
00:36:55,704 --> 00:36:59,700
to join the instructions over min, each of them

579
00:37:00,310 --> 00:37:03,986
and then also for

580
00:37:04,008 --> 00:37:07,126
these variables that we have, so need to declare them. So here is

581
00:37:07,148 --> 00:37:10,402
how I'm going to declare using the let the variable

582
00:37:10,466 --> 00:37:14,022
name. Okay, so here if I try to run

583
00:37:14,076 --> 00:37:17,586
this now, you'll see

584
00:37:17,628 --> 00:37:20,902
that I have a very basic structure.

585
00:37:20,966 --> 00:37:24,506
Now we have nothing. So now let's continue to write

586
00:37:24,528 --> 00:37:28,198
our code. So here I'm

587
00:37:28,214 --> 00:37:31,406
going to create a function called traverse. I'm going to traverse each type of the

588
00:37:31,428 --> 00:37:34,830
node. So for element, what we have

589
00:37:34,900 --> 00:37:38,430
here is we have instructions to create element

590
00:37:40,050 --> 00:37:43,982
and then we also call traverse for the attributes and the

591
00:37:44,036 --> 00:37:44,640
children.

592
00:37:47,330 --> 00:37:50,882
And then we need to append a child to the parent as well as

593
00:37:50,936 --> 00:37:54,366
to remove child in the parent in the destroy methods,

594
00:37:54,398 --> 00:37:58,354
right? So these are the things, the next element

595
00:37:58,402 --> 00:38:02,102
we're going to do is the text. So for

596
00:38:02,156 --> 00:38:05,334
text, if you look here, next thing for

597
00:38:05,372 --> 00:38:08,998
text we want to need is to document a create text node for the text

598
00:38:09,084 --> 00:38:11,880
content and then we append to the parent.

599
00:38:12,570 --> 00:38:16,570
Okay, so here we're going to create the text node,

600
00:38:17,230 --> 00:38:20,958
we're going to push this variable name and then we're going

601
00:38:20,964 --> 00:38:25,070
to say we're going to create

602
00:38:25,140 --> 00:38:28,554
text code and then we're going to use to append the parent with the append

603
00:38:28,602 --> 00:38:32,778
child. Next thing we have is attributes.

604
00:38:32,954 --> 00:38:36,802
So for attributes we are going to just handle the

605
00:38:36,856 --> 00:38:40,382
on click event listeners. So for that we're going to have two instructions,

606
00:38:40,446 --> 00:38:43,906
one in a create array when instructions to

607
00:38:43,928 --> 00:38:47,374
add event listeners the events name and the variable.

608
00:38:47,502 --> 00:38:51,174
And then for destroy instructions we're going to call remove event listeners the

609
00:38:51,212 --> 00:38:55,266
name of the event and then the variable. So this decrement comes directly

610
00:38:55,298 --> 00:38:59,002
from the attribute value and then the value

611
00:38:59,056 --> 00:39:02,726
of the listener compiles directly from the attribute

612
00:39:02,918 --> 00:39:06,090
name where we just remove the first three characters.

613
00:39:06,670 --> 00:39:11,674
Okay, so here I'm going to do that if

614
00:39:11,712 --> 00:39:15,022
it starts with the on event listeners. So we're going to get event

615
00:39:15,076 --> 00:39:18,826
name right, remove the first three characters, event handler.

616
00:39:18,938 --> 00:39:23,154
We just assume that the variable itself is an event handler and

617
00:39:23,192 --> 00:39:27,886
then we're going to basically add instruction to create and into destroy

618
00:39:28,078 --> 00:39:32,690
and that's it. So lastly we have expressions.

619
00:39:33,030 --> 00:39:36,434
So expressions like

620
00:39:36,472 --> 00:39:39,702
this, we're going to just treat it as if it is just a text

621
00:39:39,756 --> 00:39:43,078
note. And then one thing we're going to do is we're going to analyze and

622
00:39:43,164 --> 00:39:47,558
we're going to use analysis to figure out whether this

623
00:39:47,644 --> 00:39:50,840
variable like the counter will change. If it will.

624
00:39:51,210 --> 00:39:54,938
Then we're going to include these conditions here to basically

625
00:39:55,024 --> 00:39:58,460
call to update the text value with the latest value.

626
00:40:01,490 --> 00:40:04,720
So here I am going to create this

627
00:40:05,890 --> 00:40:07,200
text code first,

628
00:40:12,390 --> 00:40:16,102
right. And then I'm going to use the analysis basically to check if

629
00:40:16,156 --> 00:40:19,960
we have the world change. Then we are going to

630
00:40:20,490 --> 00:40:23,160
new instructions in the updates call.

631
00:40:25,290 --> 00:40:27,640
Okay, I think that's it,

632
00:40:28,110 --> 00:40:31,914
right. So I think we will have one more thing which

633
00:40:31,952 --> 00:40:34,570
is to call traverse the fragment,

634
00:40:35,390 --> 00:40:38,780
right. So let's save this and let's try and run our code.

635
00:40:41,010 --> 00:40:44,320
So here is our code right now,

636
00:40:44,850 --> 00:40:48,462
okay. Basically we have all the structures, it looks

637
00:40:48,516 --> 00:40:52,174
quite good, really you should proud of yourself to

638
00:40:52,212 --> 00:40:55,714
be progressing so far. So I

639
00:40:55,752 --> 00:40:59,602
think one thing we're still missing is that this variable like decrements, these are not

640
00:40:59,656 --> 00:41:03,794
defined yet, right. Basically the code inside this Javascript over

641
00:41:03,832 --> 00:41:07,634
here, we still haven't figured a way to insert

642
00:41:07,682 --> 00:41:11,878
them, right. So we need to figure a way to basically add

643
00:41:11,964 --> 00:41:15,640
this lifecycle update over here

644
00:41:16,090 --> 00:41:19,674
in all the update expressions. So to do

645
00:41:19,712 --> 00:41:23,466
that we

646
00:41:23,488 --> 00:41:26,794
are going to paste in the code that we have earlier on,

647
00:41:26,912 --> 00:41:29,340
basically is where we use the,

648
00:41:30,190 --> 00:41:33,182
where we try to figure any variables that will change.

649
00:41:33,316 --> 00:41:37,294
Right over here I'm going to make some changes. Basically we

650
00:41:37,332 --> 00:41:41,166
are going to also check whether

651
00:41:41,268 --> 00:41:44,314
the variable, not just we know that it will change,

652
00:41:44,372 --> 00:41:48,034
we'll also check whether it will actually be used in a template. If not,

653
00:41:48,072 --> 00:41:51,790
we're not going to add the lifecycle

654
00:41:51,870 --> 00:41:55,358
updates function, right? So if we have this used in

655
00:41:55,384 --> 00:41:59,394
templates then we are going to insert this instruction

656
00:41:59,442 --> 00:42:02,600
for lifecycle updates. Okay?

657
00:42:04,010 --> 00:42:07,798
Yeah, this one, just assume that it works. I'm not

658
00:42:07,804 --> 00:42:11,506
going to explain too much into this one. So by now let's

659
00:42:11,538 --> 00:42:15,226
see, I think we need to, after we change the ast, we need to

660
00:42:15,248 --> 00:42:18,714
come over here and insert this code. So we're going to use

661
00:42:18,752 --> 00:42:22,310
a library called escode gen, basically what turns Javascript

662
00:42:22,390 --> 00:42:26,046
into a string. And I'm going to turn that ast into the

663
00:42:26,068 --> 00:42:29,246
string since the whole thing we generate is a string. Right. So we're

664
00:42:29,268 --> 00:42:33,070
going to turn that into a string and then

665
00:42:33,140 --> 00:42:36,270
insert a line over here and I think that's

666
00:42:36,350 --> 00:42:40,260
kind of it. Right. Let's try and run our code and see what we get.

667
00:42:44,240 --> 00:42:48,200
Let's fresh this. So here we basically have this

668
00:42:48,290 --> 00:42:51,776
instructions, looks promising and we have

669
00:42:51,798 --> 00:42:55,456
the lifecycle updates. And in the lifecycle update you have

670
00:42:55,478 --> 00:42:59,404
this. And let's try and run this in a browser,

671
00:42:59,452 --> 00:43:02,900
shall we? So here I'm going to start the server,

672
00:43:03,240 --> 00:43:06,976
I'm going to run this server and this is the compiles

673
00:43:07,008 --> 00:43:10,720
that you see, right. And this is the magical

674
00:43:10,800 --> 00:43:14,424
moment. I'm going to click on the decrements and

675
00:43:14,462 --> 00:43:18,600
it works. Yay. And increments, yes, it works

676
00:43:18,670 --> 00:43:22,632
as well. Whoa. Okay, so we

677
00:43:22,686 --> 00:43:26,508
kind of managed to write all this within a

678
00:43:26,514 --> 00:43:29,564
short period of time. And so you see that this is

679
00:43:29,602 --> 00:43:32,732
how a compiler is being written, right?

680
00:43:32,866 --> 00:43:36,830
And to show you, to demonstrate to you that

681
00:43:37,600 --> 00:43:40,892
this compiler writes is an optimized,

682
00:43:41,036 --> 00:43:44,416
generates an optimized javascript code and actually uses what

683
00:43:44,438 --> 00:43:48,156
we analyze, let's try to make some changes in our component

684
00:43:48,188 --> 00:43:51,744
and see what is being generated. The first thing is that what

685
00:43:51,782 --> 00:43:54,864
if I do not change anything in the counter,

686
00:43:54,912 --> 00:43:58,164
right. For example, we have a variable called counter right here and we

687
00:43:58,202 --> 00:44:01,472
try and modify the local variable. So basically this counter

688
00:44:01,536 --> 00:44:05,488
is not going to change what will happen trying to

689
00:44:05,514 --> 00:44:11,624
build this. You will see that first

690
00:44:11,662 --> 00:44:14,612
of all, I do not insert the lifecycle update,

691
00:44:14,756 --> 00:44:18,776
and secondly, in the lifecycle update method here is empty.

692
00:44:18,888 --> 00:44:22,620
So we don't need to generate extra code. If we don't really

693
00:44:22,690 --> 00:44:25,596
need it, right? We are not going to change the counter, then we don't have

694
00:44:25,618 --> 00:44:29,408
to need the update function, right? Of course you can do it

695
00:44:29,494 --> 00:44:32,944
much better by removing this function totally because

696
00:44:32,982 --> 00:44:36,850
you don't even need it. Yeah, we should do that.

697
00:44:37,220 --> 00:44:40,704
So maybe you can try doing that yourself. Right?

698
00:44:40,742 --> 00:44:43,984
So what if, say for example, we're not changing

699
00:44:44,032 --> 00:44:47,492
it this way, but we are not going to have this

700
00:44:47,546 --> 00:44:50,704
counter variable, right? We can still click on counter,

701
00:44:50,832 --> 00:44:54,632
counter increment and decrement, but we're not going to show that on

702
00:44:54,686 --> 00:44:58,600
the template. We're going to use the counterparble in the template.

703
00:44:58,940 --> 00:45:00,330
Guess what happens?

704
00:45:04,000 --> 00:45:07,356
This is what happens. So first of all,

705
00:45:07,458 --> 00:45:11,196
again, we don't have that Div and the updates, we don't have

706
00:45:11,218 --> 00:45:14,568
the instructions to do those things. And secondly,

707
00:45:14,744 --> 00:45:18,236
this knows that we can still update the

708
00:45:18,258 --> 00:45:21,712
counter variable and we can still console log to see the updated value.

709
00:45:21,846 --> 00:45:25,584
But we no longer needed to call the lifecycle updates because we

710
00:45:25,622 --> 00:45:28,824
are not using that value in the template.

711
00:45:28,972 --> 00:45:32,724
So there's no need to call the updates at all

712
00:45:32,762 --> 00:45:36,804
because there's no dynamic expressions over

713
00:45:36,842 --> 00:45:40,052
here. So you can see that

714
00:45:40,186 --> 00:45:44,152
we are actually create an optimized Javascript based on

715
00:45:44,286 --> 00:45:48,056
what we analyze. And basically that's what svelte do.

716
00:45:48,158 --> 00:45:51,720
Okay, so some summary.

717
00:45:52,220 --> 00:45:55,676
We figure out how to write a compiler within

718
00:45:55,778 --> 00:45:59,148
a span of, I think, I don't know how long

719
00:45:59,154 --> 00:46:02,012
we have spent, maybe 40, 50 minutes. Right?

720
00:46:02,066 --> 00:46:06,140
So if you can type really fast, that's how

721
00:46:06,210 --> 00:46:09,180
long you need to take to write a compiler.

722
00:46:09,340 --> 00:46:12,576
Right, so what is a compiler? This is the

723
00:46:12,598 --> 00:46:16,336
compilation step. We parse our code into an ast and

724
00:46:16,358 --> 00:46:20,208
then we do some analyzing to get an analysis, and then

725
00:46:20,214 --> 00:46:23,940
we use the analysis and ast to generate the JavaScript codes.

726
00:46:24,280 --> 00:46:27,844
Right. So here of course we don't have time or we don't really

727
00:46:27,882 --> 00:46:31,044
have a space for do questions, but feel free to find

728
00:46:31,082 --> 00:46:34,730
me on Twitter or on YouTube. So this is my YouTube channel

729
00:46:37,420 --> 00:46:40,504
and all the codes that you saw just now is available on

730
00:46:40,542 --> 00:46:43,704
GitHub called Minisvelt. Here you can find

731
00:46:43,742 --> 00:46:47,740
this. And actually I have also actually

732
00:46:47,810 --> 00:46:52,044
recorded some of this talk, some part of this content and

733
00:46:52,162 --> 00:46:55,564
subsequent following up content in my YouTube channel. You can go

734
00:46:55,602 --> 00:46:59,584
and watch that. It will be

735
00:46:59,622 --> 00:47:03,344
part of this build your own svelte series hold

736
00:47:03,382 --> 00:47:06,880
on, series where you will

737
00:47:06,950 --> 00:47:13,696
see that you'll

738
00:47:13,728 --> 00:47:17,670
find a series. Hold on,

739
00:47:20,280 --> 00:47:22,950
let me get the playlist for you.

740
00:47:23,720 --> 00:47:27,040
Right, so this is the build your own svelte

741
00:47:27,120 --> 00:47:30,896
playlist. Right now we have three and I intend

742
00:47:30,928 --> 00:47:34,156
to add a few more follow ups on how you can make it it

743
00:47:34,178 --> 00:47:37,804
more complete, how you can add reactive declarations that you have min

744
00:47:37,842 --> 00:47:41,484
spelt, how you can do it on the server side rendering and things like

745
00:47:41,522 --> 00:47:45,004
that. So do subscribe to my YouTube channel and I

746
00:47:45,042 --> 00:47:49,000
shall see you and hope you enjoy the rest of the conference.

747
00:47:49,160 --> 00:47:49,496
Bye.

