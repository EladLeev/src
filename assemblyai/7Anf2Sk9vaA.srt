1
00:00:23,050 --> 00:00:26,510
Hi everyone. Today I'm here to tell you all how to use

2
00:00:26,580 --> 00:00:29,814
less javascript in. It's going to be fun.

3
00:00:30,012 --> 00:00:33,634
So let's get the big question out of the way first. Do I hate

4
00:00:33,682 --> 00:00:37,334
JavaScript? Well, I build Polypane, which is

5
00:00:37,372 --> 00:00:41,194
a browser for developers that's built using web

6
00:00:41,232 --> 00:00:44,794
technologies. So I actually write a ton of

7
00:00:44,832 --> 00:00:48,314
javascript all day, every day. Now this

8
00:00:48,352 --> 00:00:52,342
talk won't be about polypane, so if a browser

9
00:00:52,406 --> 00:00:56,714
specifically built for web developers sounds interesting to you, head over to Polypane

10
00:00:56,842 --> 00:01:00,222
app. Now, with all the JavaScript I write,

11
00:01:00,356 --> 00:01:04,222
you could say that I love JavaScript, but I

12
00:01:04,276 --> 00:01:08,334
also love CSS, and I even love HTML

13
00:01:08,382 --> 00:01:12,210
because it gives me the content editable attribute.

14
00:01:14,310 --> 00:01:17,762
So the reason I love all of these technologies is

15
00:01:17,816 --> 00:01:20,680
something called the rule of least power.

16
00:01:21,210 --> 00:01:24,742
It's one of the core principles of web development, and it

17
00:01:24,796 --> 00:01:28,610
means that you should choose the least powerful language suitable

18
00:01:28,690 --> 00:01:33,510
for a given purpose. Now, on the web, this means preferring HTML

19
00:01:33,670 --> 00:01:37,782
over CSS over JavaScript. Your javascript

20
00:01:37,846 --> 00:01:41,446
can break, it can have an error, it can fail to load,

21
00:01:41,638 --> 00:01:45,994
it takes actual resources to download and run,

22
00:01:46,192 --> 00:01:49,834
and it can exclude keyword users and people using assistive

23
00:01:49,882 --> 00:01:53,262
technologies. CSS and HTML, on the other hand,

24
00:01:53,316 --> 00:01:56,686
are declarative, and that means that you use them

25
00:01:56,708 --> 00:02:00,226
to tell the browser what to do and not how to do it.

26
00:02:00,408 --> 00:02:03,794
Your browser will instead do the heavy lifting for you,

27
00:02:03,912 --> 00:02:07,220
and your end user will have a better experience.

28
00:02:07,910 --> 00:02:11,414
Now of course, the CSS can also filter load, but if your

29
00:02:11,452 --> 00:02:15,110
HTML is solid and semantic, then people can still

30
00:02:15,180 --> 00:02:18,790
access all your content. It really is the foundation.

31
00:02:19,210 --> 00:02:22,554
And in recent times, both browser makers and

32
00:02:22,592 --> 00:02:26,342
specification writers have ported a lot of functionality

33
00:02:26,406 --> 00:02:30,010
to HTML and CSS that a few years ago needed

34
00:02:30,080 --> 00:02:33,574
JavaScript. So that's what we'll be discussing

35
00:02:33,622 --> 00:02:37,502
today. Now, the reason this is important is because

36
00:02:37,556 --> 00:02:41,054
once you learn something on the web, you never have

37
00:02:41,092 --> 00:02:44,686
to learn it again. Once you figured out how

38
00:02:44,708 --> 00:02:48,290
to implement, for example, a slider in JavaScript

39
00:02:48,710 --> 00:02:52,354
that then becomes part of your toolbox. And because it's the

40
00:02:52,392 --> 00:02:55,966
web, that thing will keep working forever,

41
00:02:56,078 --> 00:02:59,620
and there's never a reason for you to learn it again,

42
00:03:00,150 --> 00:03:04,082
even if there are now better ways available in modern browsers.

43
00:03:04,226 --> 00:03:07,558
So the techniques I'll be sharing today are cool,

44
00:03:07,644 --> 00:03:11,234
and that's why I'm showing them. But what I want you to take away

45
00:03:11,372 --> 00:03:15,290
is that just because you know that something needs Javascript,

46
00:03:15,630 --> 00:03:19,366
that doesn't necessarily mean that it's still true in modern

47
00:03:19,398 --> 00:03:23,130
browsers. You can make better websites if you check

48
00:03:23,200 --> 00:03:26,558
every now and then. If that thing you're implementing really

49
00:03:26,644 --> 00:03:29,694
still does need JavaScript. So let's get

50
00:03:29,732 --> 00:03:33,274
started. It's going to be a bit of a grab bag of features,

51
00:03:33,322 --> 00:03:37,374
new and old. Some of these you might know, some of these might be

52
00:03:37,412 --> 00:03:41,138
new to you. There's going to be a couple of live demos, so if

53
00:03:41,144 --> 00:03:44,914
you see me fumble about, just roll with it. Let's get

54
00:03:44,952 --> 00:03:48,062
started. Now we'll start with custom toggles,

55
00:03:48,126 --> 00:03:51,634
and when implementing them we often reach for a JavaScript

56
00:03:51,682 --> 00:03:55,560
solution because that then handles the click events and the states

57
00:03:56,010 --> 00:04:00,054
for us. But we can do the same with an ordinary checkbox and

58
00:04:00,092 --> 00:04:03,626
the checked pseudoclass. That way we can have a

59
00:04:03,648 --> 00:04:07,094
fully interactive toggle using CSS and native

60
00:04:07,142 --> 00:04:10,634
browser APIs, and that means that the accessibility is

61
00:04:10,672 --> 00:04:14,202
preserved. This is the HTML that we're going to use,

62
00:04:14,256 --> 00:04:17,834
and as you can see, it's pretty simple. There's a label

63
00:04:17,882 --> 00:04:21,614
and inside of it there's a checkbox. Now the neat thing

64
00:04:21,652 --> 00:04:25,326
here is that having the input inside the label already gives us

65
00:04:25,348 --> 00:04:29,394
stuff for free because the browser has associated this

66
00:04:29,432 --> 00:04:33,134
input and this label, and now I can click anywhere in the label

67
00:04:33,182 --> 00:04:36,574
to toggle the checkbox. This is something the browser

68
00:04:36,622 --> 00:04:40,594
gives us for free. But of course we can't ship just this

69
00:04:40,632 --> 00:04:44,406
checkbox because it doesn't look like a toggle. So we'll make it look like a

70
00:04:44,428 --> 00:04:47,602
toggle and we can use all of this CSS

71
00:04:47,666 --> 00:04:51,242
for that. Now none of this CSS is super

72
00:04:51,296 --> 00:04:54,682
important except for this first line here,

73
00:04:54,816 --> 00:04:58,826
appearance none. Now what appearance none does

74
00:04:58,928 --> 00:05:03,014
is it tells the browser to stop treating the input

75
00:05:03,062 --> 00:05:07,086
elements like replaced content. Replaced content in

76
00:05:07,108 --> 00:05:10,910
browsers, which are form controls and images

77
00:05:11,410 --> 00:05:16,074
are things that the browser will replace

78
00:05:16,202 --> 00:05:19,998
from your HTML. So as it builds the web page and renders

79
00:05:20,014 --> 00:05:23,746
the web page using your HTML and your CSS, when a

80
00:05:23,768 --> 00:05:27,854
browser encounters replaced content, what it actually does is it reserves

81
00:05:27,902 --> 00:05:31,490
that space in your HTML and then

82
00:05:31,560 --> 00:05:35,014
adds a native form controller, adds an image on top

83
00:05:35,052 --> 00:05:38,358
of it. So that's not really part of your web page.

84
00:05:38,444 --> 00:05:42,426
And that's also the reason why form controls are historically difficult

85
00:05:42,528 --> 00:05:45,802
to style. They're not really part of your

86
00:05:45,856 --> 00:05:49,978
HTML page. Another effect of that is that

87
00:05:50,064 --> 00:05:53,702
before and after pseudo elements don't work for replaced content.

88
00:05:53,856 --> 00:05:57,502
Because before and after pseudo elements are part of your

89
00:05:57,556 --> 00:06:01,242
element and that entire element gets replaced

90
00:06:01,386 --> 00:06:05,246
so they disappear again with appearance none. We can

91
00:06:05,268 --> 00:06:08,926
tell the browser to not replace our form controls.

92
00:06:08,958 --> 00:06:10,690
We can tell the browser essentially,

93
00:06:11,830 --> 00:06:15,246
let me be responsible for the styling of this element.

94
00:06:15,358 --> 00:06:18,706
Don't use a native form control. I'm going to do

95
00:06:18,728 --> 00:06:21,926
the work to make this look the way that it should look.

96
00:06:22,108 --> 00:06:25,494
So that's what the rest of this HTML does. And by using

97
00:06:25,532 --> 00:06:29,426
appearance none. We also get back that before pseudo

98
00:06:29,458 --> 00:06:32,602
element. So we're using the regular input as

99
00:06:32,656 --> 00:06:36,118
the background here, the gray part of the toggle,

100
00:06:36,294 --> 00:06:40,390
and then we're using the before element to add the nib

101
00:06:40,470 --> 00:06:44,474
inside of the toggle. Now we've added

102
00:06:44,522 --> 00:06:48,442
the CSS, but everything is still functional,

103
00:06:48,506 --> 00:06:52,026
so I can click to toggle the checkbox.

104
00:06:52,218 --> 00:06:55,790
Now you'll have to trust me here, but it's really toggled.

105
00:06:56,130 --> 00:06:59,346
Of course we need to make sure that the user also knows that

106
00:06:59,368 --> 00:07:03,074
it's toggled and that's where the checked pseudoclass comes

107
00:07:03,112 --> 00:07:06,926
in. To make that change visible, we use the checked pseudo

108
00:07:06,958 --> 00:07:10,950
class. This will match whenever the input would normally show

109
00:07:11,020 --> 00:07:15,062
the checkbox. So as I click,

110
00:07:15,196 --> 00:07:18,806
the checked pseudo class resolves to true and we can

111
00:07:18,828 --> 00:07:23,722
give our input green background and

112
00:07:23,856 --> 00:07:27,206
move the nip to the right to indicate that the toggle

113
00:07:27,238 --> 00:07:30,426
is currently on. Now there's one last thing

114
00:07:30,448 --> 00:07:33,290
we need to do, and that is accessibility.

115
00:07:33,870 --> 00:07:37,546
So we want to add an outline to the toggle when it's selected

116
00:07:37,578 --> 00:07:41,594
by the keyboard. If you use your mouse, it's very clear which element

117
00:07:41,642 --> 00:07:45,786
you're interacting with because your mouse is right on top of it. But that's

118
00:07:45,818 --> 00:07:49,022
not the case with a keyboard, and we need to provide a

119
00:07:49,076 --> 00:07:51,886
different indicator for keyboard users.

120
00:07:52,078 --> 00:07:55,186
Now you might have used outline none in

121
00:07:55,208 --> 00:07:58,682
the past for your input elements to get rid of that ugly

122
00:07:58,766 --> 00:08:00,440
dotted line,

123
00:08:02,490 --> 00:08:05,720
but that line, even if it was ugly, is important.

124
00:08:06,410 --> 00:08:09,650
Modern browsers ship something called focus visible.

125
00:08:09,810 --> 00:08:13,654
Focus visible only works when you interact

126
00:08:13,702 --> 00:08:17,466
with an element using the keyboard instead of the mouse. So we

127
00:08:17,488 --> 00:08:20,890
can use that to add our outline back in. Now,

128
00:08:20,960 --> 00:08:24,090
as I toggle the checkbox using my mouse,

129
00:08:24,170 --> 00:08:28,298
nothing happens. But as soon as I switch to the spacebar to toggle,

130
00:08:28,474 --> 00:08:31,902
you can see that the outline appears because

131
00:08:31,956 --> 00:08:35,290
it now matches focus visible. Historically,

132
00:08:35,370 --> 00:08:38,626
outline wasn't very stylable, but that too has changed in

133
00:08:38,648 --> 00:08:41,938
modern browsers. For one, as you can see, it follows the

134
00:08:41,944 --> 00:08:45,090
border radius of the element, but we can also

135
00:08:45,160 --> 00:08:48,834
offset it to move it a little away from

136
00:08:48,872 --> 00:08:52,582
the element. Or if you use a negative offset into

137
00:08:52,636 --> 00:08:56,230
the element, and that way we get quite a bit of stylability.

138
00:08:56,970 --> 00:09:01,010
One other thing I want you to do is instead of using outline

139
00:09:01,090 --> 00:09:04,810
none, I want you to use outline color transparent.

140
00:09:05,390 --> 00:09:09,366
The effect will be the same because the outline won't be visible

141
00:09:09,478 --> 00:09:13,574
for outline none because you've hidden it completely and outline

142
00:09:13,622 --> 00:09:16,270
color because it's there, but it's transparent.

143
00:09:16,610 --> 00:09:19,902
This changes, however, when a user uses forced color

144
00:09:19,956 --> 00:09:23,934
mode. What forced color mode does on Windows is it

145
00:09:23,972 --> 00:09:28,146
replaces all the colors on the screen, including the ones in your website,

146
00:09:28,328 --> 00:09:32,386
with a palette that the user chose. That means that

147
00:09:32,408 --> 00:09:35,586
your outline color transparent will be replaced with a

148
00:09:35,608 --> 00:09:39,074
color that the user can see if they use forced color mode,

149
00:09:39,122 --> 00:09:43,558
and that way we can give them additional hints without

150
00:09:43,724 --> 00:09:47,480
having to show that color or that outline to everyone.

151
00:09:48,090 --> 00:09:52,726
Now, I don't have time to go into forced color mode today,

152
00:09:52,828 --> 00:09:56,742
but if you want to learn more, go to polypane app forced

153
00:09:56,886 --> 00:10:00,726
colors, where I wrote about it extensively.

154
00:10:00,918 --> 00:10:04,618
Now, while we're working with forms, have you heard of

155
00:10:04,704 --> 00:10:08,282
data list? So, data list is the browser's

156
00:10:08,346 --> 00:10:11,946
built in way to show a list of match suggestions as a user

157
00:10:11,978 --> 00:10:15,950
types into an input. In other words, it's an autosuggest.

158
00:10:16,370 --> 00:10:20,590
It works like this. You add a data list element to your HTML

159
00:10:20,750 --> 00:10:23,540
with options and you then give it an id.

160
00:10:23,910 --> 00:10:27,602
You will link that id using the list attribute on any

161
00:10:27,656 --> 00:10:31,766
input element. Now, as I write into the

162
00:10:31,788 --> 00:10:35,558
input element, you can see that the data list options

163
00:10:35,644 --> 00:10:39,494
get filtered down to the suggestions matching what

164
00:10:39,532 --> 00:10:43,286
I've already written. And you can also see there's a drop

165
00:10:43,318 --> 00:10:45,980
down that shows you all the options to select.

166
00:10:46,510 --> 00:10:50,426
Now, because it's an auto suggest, you can still type in

167
00:10:50,448 --> 00:10:54,122
any other value, and that will work too. So that's

168
00:10:54,186 --> 00:10:57,966
quite a bit of functionality for a single HTML element that

169
00:10:57,988 --> 00:11:01,914
you would instead ship a very large JavaScript

170
00:11:01,962 --> 00:11:04,320
framework or JavaScript library for.

171
00:11:04,770 --> 00:11:08,610
Similarly, instead of shipping a JavaScript color picker

172
00:11:09,190 --> 00:11:12,642
with like a full canvas renderer and a little

173
00:11:12,696 --> 00:11:15,906
picker et cetera, you can let the browser handle it.

174
00:11:16,088 --> 00:11:19,458
And because the browser has more rights than you as a

175
00:11:19,464 --> 00:11:23,430
web page, they can even offer

176
00:11:23,500 --> 00:11:27,474
more functionality. So now as I open the color picker,

177
00:11:27,522 --> 00:11:31,080
which unfortunately doesn't get picked up, it seems.

178
00:11:31,550 --> 00:11:34,886
No, it unfortunately doesn't get picked up by OBS, which I'm

179
00:11:34,918 --> 00:11:38,650
using to record

180
00:11:38,720 --> 00:11:42,220
this, but it shows a native browser control

181
00:11:42,670 --> 00:11:46,190
with a canvas UI, with an rgb picker, et cetera, but also

182
00:11:46,260 --> 00:11:50,330
with a color dropper icon. And if I click that color dropper icon,

183
00:11:50,490 --> 00:11:54,446
what happens is that I can pick any color on

184
00:11:54,468 --> 00:11:57,954
the screen, including outside of the browser, and have that

185
00:11:57,992 --> 00:12:02,020
be the color a user selected. So that actually gives you

186
00:12:02,550 --> 00:12:06,180
color picking functionality from your entire

187
00:12:06,870 --> 00:12:10,674
screen, and that's just not something your browser

188
00:12:10,802 --> 00:12:14,678
will ever let you as a web page do. Now another

189
00:12:14,764 --> 00:12:18,854
thing that's nice about this input type color is that

190
00:12:18,972 --> 00:12:22,826
it's unstyled, but instead of being white

191
00:12:22,928 --> 00:12:25,974
it's sort of gray. And that's because we've

192
00:12:26,022 --> 00:12:29,242
told the browser that this input actually uses a

193
00:12:29,296 --> 00:12:32,854
dark color scheme. With the CSS color scheme

194
00:12:32,902 --> 00:12:36,874
dark, and that then lets the browser switch

195
00:12:36,922 --> 00:12:40,394
out the form controls from the default

196
00:12:40,442 --> 00:12:43,562
white ones to the dark mode set that it ships

197
00:12:43,626 --> 00:12:47,138
or that the operating system ships. So you can have

198
00:12:47,224 --> 00:12:50,574
native form elements but still adhere

199
00:12:50,622 --> 00:12:53,998
to whatever color scheme your user prefers.

200
00:12:54,174 --> 00:12:57,394
Now if you have a website that uses both dark and

201
00:12:57,432 --> 00:13:01,186
light mode, you can also cater for that using color scheme

202
00:13:01,218 --> 00:13:05,142
dark space light, and then the browser will automatically switch between

203
00:13:05,196 --> 00:13:08,946
them depending on which prefers

204
00:13:08,978 --> 00:13:12,822
color scheme or light or dark mode is active

205
00:13:12,886 --> 00:13:16,282
on the operating system. So that's pretty nice

206
00:13:16,336 --> 00:13:19,994
for just a single line of CSS. Now on

207
00:13:20,032 --> 00:13:23,690
to something a little bigger in page transitions,

208
00:13:24,030 --> 00:13:27,518
when moving from one section of the page to another,

209
00:13:27,684 --> 00:13:31,054
browsers jump by default. And this can be jarring and

210
00:13:31,092 --> 00:13:35,374
disorienting because you no longer know where on the page you are.

211
00:13:35,572 --> 00:13:39,326
It will be much nicer to scroll the user to the new location so

212
00:13:39,348 --> 00:13:42,180
they have a sense of where they are now on the page.

213
00:13:42,630 --> 00:13:45,780
Now in the past we might have used jquery for that,

214
00:13:46,470 --> 00:13:49,566
and in just a few lines of code, plus hundreds

215
00:13:49,598 --> 00:13:52,966
and hundreds of lines of jquery, we could get all the

216
00:13:52,988 --> 00:13:56,422
links that link to another part of the page. And then

217
00:13:56,476 --> 00:13:59,606
when you click it we find where they go to

218
00:13:59,628 --> 00:14:03,674
the page and then we animate HTML to it. So that

219
00:14:03,712 --> 00:14:07,258
was pretty awesome. But you no longer

220
00:14:07,344 --> 00:14:10,874
need these jquery skills because we can achieve the same thing

221
00:14:10,912 --> 00:14:15,190
with just a single line of CSS scroll behavior.

222
00:14:15,270 --> 00:14:19,114
Smooth. Now this tells the browser to always scroll smoothly

223
00:14:19,162 --> 00:14:22,894
when navigating to a fragment identifier, which is an id with

224
00:14:22,932 --> 00:14:26,942
a hash in front of it as part of the URL. Now every

225
00:14:26,996 --> 00:14:30,594
internal link is magically upgraded. Browsers will figure

226
00:14:30,632 --> 00:14:34,414
out how long the animation should take and how fast they should scroll

227
00:14:34,542 --> 00:14:38,066
based on how far they have to scroll and how much cpu power they have

228
00:14:38,088 --> 00:14:42,082
available, et cetera. And that means that the animation is always snappy

229
00:14:42,146 --> 00:14:45,654
and there's never a different part of your page that has to

230
00:14:45,692 --> 00:14:49,302
wait on the main thread to finish this

231
00:14:49,356 --> 00:14:53,226
animation before doing anything else. So as I click

232
00:14:53,248 --> 00:14:56,970
the link, it gently scrolls down to wherever

233
00:14:57,870 --> 00:15:01,494
I link to. Now don't worry,

234
00:15:01,622 --> 00:15:04,842
this is also available in JavaScript in any of

235
00:15:04,896 --> 00:15:09,470
the scroll APIs. So scroll to scroll by, et cetera.

236
00:15:11,250 --> 00:15:14,446
By adding behavior smooth to the object

237
00:15:14,548 --> 00:15:17,758
that you pass the function. So that still saves

238
00:15:17,774 --> 00:15:21,874
you shipping a bunch of Javascript where

239
00:15:21,912 --> 00:15:24,900
you would normally do the scroll animation yourself.

240
00:15:25,430 --> 00:15:29,890
Now there's one important consideration though, and that is accessibility.

241
00:15:30,550 --> 00:15:34,646
Because while for most people, jumping from one part of the page to another part

242
00:15:34,668 --> 00:15:38,374
of the page is the jarring thing for people that have

243
00:15:38,412 --> 00:15:41,874
vestibular disorders, it's the scrolling that actually poses

244
00:15:41,922 --> 00:15:45,850
a problem, as it can make them nauseous and unwell.

245
00:15:46,270 --> 00:15:50,214
Now browsers have a way of catering to these users with the preferred reduced

246
00:15:50,262 --> 00:15:54,014
motion media query, and the way to implement that is

247
00:15:54,052 --> 00:15:57,882
to only set smooth scrolling when the user doesn't

248
00:15:57,946 --> 00:16:02,074
mind motion. So instead of disabling

249
00:16:02,122 --> 00:16:06,110
scroll behavior when the user has prefers reduced motion reduced,

250
00:16:07,110 --> 00:16:11,134
we want to use that as the default case, and then only when the user

251
00:16:11,182 --> 00:16:15,074
indicates that they don't mind more motion with

252
00:16:15,112 --> 00:16:18,770
prefers reduced motion, no preference do we add

253
00:16:18,840 --> 00:16:22,386
the scroll behavior. So now we have smooth scrolling

254
00:16:22,418 --> 00:16:25,506
for the people that want that. No smooth

255
00:16:25,538 --> 00:16:29,010
scrolling for those that don't. And we're not shipping any javascript,

256
00:16:29,170 --> 00:16:32,374
so that's a great start. But we can add more.

257
00:16:32,572 --> 00:16:35,578
So what if we want to scroll to an element, but we want

258
00:16:35,584 --> 00:16:39,206
to keep a little headroom, for example, to make sure that our fixed header doesn't

259
00:16:39,238 --> 00:16:42,906
overlap the title we just scroll to. Well, CSS has

260
00:16:42,928 --> 00:16:46,810
a solution for that called scroll margin. Scroll margin

261
00:16:46,890 --> 00:16:50,202
and scroll padding, which also exists,

262
00:16:50,346 --> 00:16:54,334
work just like regular margin and padding, except they're only applied when

263
00:16:54,372 --> 00:16:57,982
scrolling to can element. So now as I scroll

264
00:16:58,046 --> 00:17:02,530
to the target, it leaves room above

265
00:17:03,030 --> 00:17:06,930
the element to make sure that it doesn't sit behind the header.

266
00:17:07,350 --> 00:17:11,150
Now if I scroll back to top where I haven't set a scroll margin,

267
00:17:11,310 --> 00:17:14,678
you can see that it ends up behind the header and I still have to

268
00:17:14,684 --> 00:17:18,614
scroll down to read the first line again. Now that sure

269
00:17:18,732 --> 00:17:22,838
beats manually subtracting the offset in Javascript before each animation.

270
00:17:22,934 --> 00:17:26,186
Right. Now, as a finishing touch, what if we

271
00:17:26,208 --> 00:17:30,330
want to highlight our target in some way to give it some extra prominence?

272
00:17:31,310 --> 00:17:34,810
For that we could use JavaScript to add a class

273
00:17:34,880 --> 00:17:38,586
to the target as soon as we click a link. But there's

274
00:17:38,618 --> 00:17:42,186
a CSS solution too, the target pseudoclass.

275
00:17:42,378 --> 00:17:45,834
Now when an element matches the fragment which is the

276
00:17:45,892 --> 00:17:49,090
little bit in the URL after the hash,

277
00:17:49,670 --> 00:17:53,300
which happens as a result of clicking can internal link

278
00:17:53,750 --> 00:17:57,262
the target pseudo, CSS will be active and then the transition

279
00:17:57,326 --> 00:18:01,190
will play. So now as I click to target,

280
00:18:01,690 --> 00:18:05,286
we can see that the animation played while the

281
00:18:05,308 --> 00:18:08,774
target was scrolling into view. So now we've built a way

282
00:18:08,812 --> 00:18:12,214
to smoothly scroll to a specific section and highlight

283
00:18:12,262 --> 00:18:15,622
it while keeping some space for the rest of the UI,

284
00:18:15,766 --> 00:18:18,970
and we're doing it all without JavaScript.

285
00:18:19,470 --> 00:18:23,094
What about another staple of JavaScript, scroll related

286
00:18:23,142 --> 00:18:26,670
features? I'm talking about image carousels or

287
00:18:26,740 --> 00:18:30,650
sliders. For that we have the scroll

288
00:18:30,730 --> 00:18:32,030
snap APIs.

289
00:18:34,210 --> 00:18:37,806
With scroll snap we can create sliders that snap to

290
00:18:37,828 --> 00:18:41,278
their parent elements in different ways while accepting scroll input

291
00:18:41,294 --> 00:18:45,026
like normal. So for the parent we have to tell it what the

292
00:18:45,048 --> 00:18:48,510
scroll snap type is. And this takes two values,

293
00:18:48,670 --> 00:18:52,326
an axis, which is x for horizontal or y for

294
00:18:52,348 --> 00:18:56,374
vertical, and a snap type, which is mandatory for always

295
00:18:56,412 --> 00:19:00,134
snapping or proximity. And that means it only

296
00:19:00,172 --> 00:19:03,674
snaps when the edge is close enough. Now what

297
00:19:03,712 --> 00:19:07,302
the edge is is something you define

298
00:19:07,366 --> 00:19:10,490
on the children, on the child elements.

299
00:19:10,830 --> 00:19:13,974
Here you have scroll snap align, and that takes a value

300
00:19:14,032 --> 00:19:17,374
of start, end or center, and it tells you what

301
00:19:17,412 --> 00:19:20,794
to snap to. Now, for left to right languages,

302
00:19:20,922 --> 00:19:24,830
start is left, but this is different in other scripts.

303
00:19:25,330 --> 00:19:28,206
And as you can see, I now scroll.

304
00:19:28,398 --> 00:19:31,954
And as I scroll it follows my

305
00:19:31,992 --> 00:19:35,698
scrolling one to one and it's a

306
00:19:35,784 --> 00:19:39,446
regular native scroll. But as soon as I release the

307
00:19:39,468 --> 00:19:42,978
mouse you can see that it snaps to the edge.

308
00:19:43,154 --> 00:19:46,614
Now by changing the scroll snap align to center, we get

309
00:19:46,652 --> 00:19:49,990
center aligning. So now as I scroll

310
00:19:50,570 --> 00:19:53,530
it will automatically center the element.

311
00:19:53,950 --> 00:19:58,982
Now I want you to notice that all of these cards

312
00:19:59,046 --> 00:20:03,050
have different sizes, and I want you to take a moment to

313
00:20:03,120 --> 00:20:06,590
think how much Javascript you would need to

314
00:20:06,660 --> 00:20:10,026
center this scroll area for randomly

315
00:20:10,058 --> 00:20:13,934
sized cards. And then look back at the screen and see

316
00:20:13,972 --> 00:20:17,206
that we get all of that with a single line of CSS.

317
00:20:17,338 --> 00:20:20,786
Scroll snap align, center. Now there's a

318
00:20:20,808 --> 00:20:24,174
whole range of cool tricks you can do with this, like animations,

319
00:20:24,302 --> 00:20:27,678
overscroll effects, and other things that I don't

320
00:20:27,694 --> 00:20:30,962
have time for. But this presentation by Adam Argal

321
00:20:31,106 --> 00:20:34,018
goes into the nitty gritty of scroll snapping.

322
00:20:34,114 --> 00:20:37,990
So check that out if you want to learn more onto two

323
00:20:38,060 --> 00:20:41,186
UI elements that we often solve with JavaScript,

324
00:20:41,378 --> 00:20:45,462
that we can also just use HTML for an accordion

325
00:20:45,606 --> 00:20:48,906
and a modal. So having an accordion on

326
00:20:48,928 --> 00:20:52,758
your page can help you keep the content organized by showing

327
00:20:52,774 --> 00:20:56,558
the titles of sections and only expanding the full section when a

328
00:20:56,564 --> 00:21:00,362
user clicks on them. Now there's a pair of native HTML elements

329
00:21:00,426 --> 00:21:04,270
that does exactly this, which is the details and summary elements.

330
00:21:04,610 --> 00:21:08,510
All contents except the summary will be hidden by default

331
00:21:08,590 --> 00:21:12,242
until I click the summary and then the rest is

332
00:21:12,296 --> 00:21:15,858
made visible as well. Now of course it's very

333
00:21:15,944 --> 00:21:19,442
common to have the first bit

334
00:21:19,496 --> 00:21:22,200
of the accordion, the first details open,

335
00:21:22,730 --> 00:21:27,014
so that people know that there's more content to see and

336
00:21:27,212 --> 00:21:30,822
that's very easy to do in HTML as well, because you can just add the

337
00:21:30,876 --> 00:21:34,826
open attribute to your details. Now if

338
00:21:34,848 --> 00:21:38,502
you've been writing react or anything else that uses JSX,

339
00:21:38,566 --> 00:21:41,338
you might look at this and think okay, that's great,

340
00:21:41,504 --> 00:21:45,514
but now it's just open forever. Luckily in HTML

341
00:21:45,562 --> 00:21:48,874
that's not the case, because open is just the initial

342
00:21:48,922 --> 00:21:52,410
state and it will update

343
00:21:52,490 --> 00:21:56,274
automatically as we open and close the

344
00:21:56,312 --> 00:21:59,714
dialog or the details element. In terms of

345
00:21:59,752 --> 00:22:03,806
styling, that triangle is a marker pseudo element

346
00:22:03,918 --> 00:22:07,602
and you can use CSS to style it, though it

347
00:22:07,656 --> 00:22:11,682
only supports a subset of CSS like colors and sizes. You can't

348
00:22:11,826 --> 00:22:15,554
move the marker to another place on the page that doesn't

349
00:22:15,602 --> 00:22:19,046
work, but you can, for example, switch out

350
00:22:19,148 --> 00:22:22,650
the triangle with an emoji of your choice,

351
00:22:23,070 --> 00:22:27,270
and then we can use that open attribute because it updates

352
00:22:27,350 --> 00:22:31,962
on the fly and switch out the

353
00:22:32,016 --> 00:22:36,094
design or pick a different emoji like I've done here

354
00:22:36,292 --> 00:22:40,014
so you can style it essentially just the way you want it,

355
00:22:40,052 --> 00:22:43,166
or just the way your designer designed it.

356
00:22:43,348 --> 00:22:47,038
Now a gotcha here is that even though the summary is clickable

357
00:22:47,134 --> 00:22:51,214
like a link or a button, it doesn't get a different cursor

358
00:22:51,262 --> 00:22:54,818
like a link, or it also doesn't look, well,

359
00:22:54,904 --> 00:22:58,742
buttony. So without getting into only

360
00:22:58,796 --> 00:23:02,294
links should have pointer cursors. I think you can

361
00:23:02,332 --> 00:23:06,022
improve the discoverability of your accordions by

362
00:23:06,076 --> 00:23:10,342
adding a hover effect and a pointer cursor to your

363
00:23:10,396 --> 00:23:14,042
summary, so that people know that it's actually something I can

364
00:23:14,096 --> 00:23:18,140
click and clicking it makes something happen on the page.

365
00:23:18,510 --> 00:23:21,926
Now for this next one dialog I am going to cheat

366
00:23:21,958 --> 00:23:25,146
a little, because for now it does need a

367
00:23:25,168 --> 00:23:28,606
tiny bit of JavaScript. The dialog element in

368
00:23:28,628 --> 00:23:32,430
HTML is like a better alert or a confirm or a prompt.

369
00:23:32,770 --> 00:23:36,526
It implements a modal dialog for you, and it takes care of all the things

370
00:23:36,548 --> 00:23:39,922
that matter. It helps keep focus inside

371
00:23:39,976 --> 00:23:43,140
of the dialog so you can't tap out of it.

372
00:23:43,510 --> 00:23:47,314
It shows a backdrop to make sure that the dialogue is what

373
00:23:47,352 --> 00:23:50,914
the user focuses on. It helps

374
00:23:50,962 --> 00:23:54,834
prevent setting that issue so you no longer have to worry about chat widgets

375
00:23:54,882 --> 00:23:58,802
popping up over your dialogues. And it also handles

376
00:23:58,866 --> 00:24:02,854
closing the element for you. And the best thing is that unlike

377
00:24:02,902 --> 00:24:07,062
alert, prompt and confirm, it doesn't block your main javascript thread

378
00:24:07,126 --> 00:24:10,586
because it's a regular HTML element. It's not a

379
00:24:10,608 --> 00:24:14,166
bit of browser UI. So to create a dialog you

380
00:24:14,208 --> 00:24:17,994
use a dialog element, but in the dialog

381
00:24:18,042 --> 00:24:21,470
you add a form with the method dialog.

382
00:24:21,810 --> 00:24:25,294
Now a dialog will be completely hidden from view. And to show

383
00:24:25,332 --> 00:24:28,958
it you can call the show modal function it exposes.

384
00:24:29,134 --> 00:24:33,202
For example, after clicking a button now

385
00:24:33,256 --> 00:24:36,434
as I click the button it calls show modal and

386
00:24:36,472 --> 00:24:39,250
it opens up this dialog.

387
00:24:39,750 --> 00:24:43,122
Now this dialog doesn't come with any

388
00:24:43,176 --> 00:24:46,582
UI that we don't ship ourselves, so there is no close

389
00:24:46,636 --> 00:24:50,390
button for example, and I can click anywhere I want and nothing

390
00:24:50,460 --> 00:24:54,854
happens. The browser expects us to implement this UI

391
00:24:54,902 --> 00:24:58,550
ourselves and that's where that form comes in with the method

392
00:24:58,630 --> 00:25:01,994
dialog. So any submit button in

393
00:25:02,032 --> 00:25:05,338
that form, or any form submission

394
00:25:05,434 --> 00:25:09,114
which you can trigger by a submit button will tell the browser

395
00:25:09,162 --> 00:25:12,746
that it can now close the dialog.

396
00:25:12,938 --> 00:25:16,506
So that's what that form does. And it's

397
00:25:16,538 --> 00:25:20,562
important to note that this dialog sits on top of everything and

398
00:25:20,616 --> 00:25:23,922
with on top of everything, I really mean on top of

399
00:25:23,976 --> 00:25:27,362
everything because this dialog is no longer part

400
00:25:27,416 --> 00:25:31,334
of your HTML page, but it sits on something called the

401
00:25:31,372 --> 00:25:36,070
top layer. And the top layer is a new concept in browsers

402
00:25:36,890 --> 00:25:40,374
that sits on top of your HTML page and you

403
00:25:40,412 --> 00:25:44,410
can promote elements to the top layer.

404
00:25:44,910 --> 00:25:48,522
That means that even the highest set index will still be below

405
00:25:48,576 --> 00:25:52,726
this top layer and you never have set index writing.

406
00:25:52,918 --> 00:25:56,554
So that's how easy it is to implement a custom confirm

407
00:25:56,602 --> 00:25:59,934
dialog. But what if you want to show

408
00:26:00,052 --> 00:26:03,726
multiple options? For example, you have a save UI where

409
00:26:03,748 --> 00:26:07,614
it's safe and cancel. Well you can add multiple

410
00:26:07,662 --> 00:26:11,746
buttons to that dialog with different values and

411
00:26:11,768 --> 00:26:15,026
then listen to the close event. Then when

412
00:26:15,048 --> 00:26:18,338
the close event is called you can get the

413
00:26:18,424 --> 00:26:21,800
chosen value with dialog return value.

414
00:26:22,330 --> 00:26:26,546
So now as I show the modal there are two buttons and depending

415
00:26:26,578 --> 00:26:30,134
on which button I click the return value will

416
00:26:30,172 --> 00:26:34,034
be wrong or correct. Now lastly, you can style

417
00:26:34,082 --> 00:26:38,262
the dialog however you want with rounded corners, drop shadows,

418
00:26:38,326 --> 00:26:41,206
whatever. It's just a regular HTML element.

419
00:26:41,398 --> 00:26:44,746
But you can also show a backdrop that overlays the rest

420
00:26:44,768 --> 00:26:47,806
of the page so it sits between your dialogue and the rest of the

421
00:26:47,828 --> 00:26:51,502
page, for example to dim it to make the dialogue stand

422
00:26:51,556 --> 00:26:55,630
out more. And you can do that with the backdrop pseudo element.

423
00:26:56,130 --> 00:26:59,662
Now the backdrop automatically takes the full size of the viewport

424
00:26:59,726 --> 00:27:02,050
without you needing to do any calculations.

425
00:27:04,470 --> 00:27:08,340
So all you really need to do is add a background image or

426
00:27:08,790 --> 00:27:12,786
other background property. Like for example here I've added

427
00:27:12,818 --> 00:27:16,294
a backdrop filter to blur the page, but you can really do

428
00:27:16,332 --> 00:27:19,734
anything you want here. Now you've probably already heard

429
00:27:19,772 --> 00:27:23,222
of container queries, but if not, imagine if

430
00:27:23,276 --> 00:27:26,506
media queries didn't look at the browser width but at the

431
00:27:26,528 --> 00:27:29,914
width of a parent element. Container queries are

432
00:27:29,952 --> 00:27:33,926
going to replace a ton of custom settings on all of your components.

433
00:27:34,118 --> 00:27:37,774
So container queries provide a built in way of

434
00:27:37,812 --> 00:27:41,386
changing the layout of a component depending on which parent element

435
00:27:41,418 --> 00:27:44,622
they're in and how much space there is available in

436
00:27:44,676 --> 00:27:48,510
that element. So if you use a component based framework,

437
00:27:48,590 --> 00:27:52,850
it will save you passing a prop to change your component depending on the location.

438
00:27:53,190 --> 00:27:56,766
For example, here we have one container,

439
00:27:56,958 --> 00:28:00,440
and depending on if it has a lot of room

440
00:28:01,130 --> 00:28:04,838
in the horizontal direction, in the inline size

441
00:28:05,004 --> 00:28:08,306
or not a lot of room, we flip the flex

442
00:28:08,338 --> 00:28:11,418
direction from having two columns to just a

443
00:28:11,424 --> 00:28:14,794
single column. Now one thing I want to call out here is

444
00:28:14,832 --> 00:28:17,654
that it's the size of the image,

445
00:28:17,782 --> 00:28:21,530
which I've written down as 50 CQW.

446
00:28:22,990 --> 00:28:27,286
You're probably already familiar with viewport units like VH,

447
00:28:27,478 --> 00:28:30,762
VW V min and Vmax that give you a percentage

448
00:28:30,826 --> 00:28:34,654
of the entire screen. Now for container queries, we now

449
00:28:34,692 --> 00:28:37,150
have CQW for width,

450
00:28:37,310 --> 00:28:40,834
CQH for container query height, et cetera that

451
00:28:40,872 --> 00:28:44,126
give you percentages of the container dimensions.

452
00:28:44,318 --> 00:28:47,954
Now, container queries are relatively new, but once it gets more

453
00:28:47,992 --> 00:28:51,186
widespread adoption among developers, it's going to unlock a

454
00:28:51,208 --> 00:28:55,174
whole new way of doing responsive design because you no longer

455
00:28:55,212 --> 00:28:58,582
need to keep track of where on the page you use a component because

456
00:28:58,636 --> 00:29:02,134
the component itself is now responsible for its responsive

457
00:29:02,182 --> 00:29:05,274
design. So as the component moves around the

458
00:29:05,312 --> 00:29:09,014
page as well as on different screen sizes, it can adapt

459
00:29:09,062 --> 00:29:12,426
automatically. All the things I mentioned up to

460
00:29:12,448 --> 00:29:16,494
now are available in browsers today, but I also

461
00:29:16,532 --> 00:29:20,490
wanted to give you a quick overview of some upcoming features.

462
00:29:20,650 --> 00:29:25,146
Each of those could be a full presentation on their own, so I'm

463
00:29:25,258 --> 00:29:27,810
not going to do any of them justice,

464
00:29:28,390 --> 00:29:31,858
but I just want to show you the cool things that are coming,

465
00:29:31,944 --> 00:29:35,806
like quote unquote soon, starting with masonry

466
00:29:35,838 --> 00:29:39,858
layout. So instead of using masonry js or packery

467
00:29:39,954 --> 00:29:43,750
JS, this native masonry implementation will apply

468
00:29:43,820 --> 00:29:47,430
a masonry layout to grids like the Pinterest layout.

469
00:29:47,930 --> 00:29:51,622
It's available in Firefox behind the feature flag, and it's in

470
00:29:51,676 --> 00:29:55,130
Safari's tech preview. And if you want to learn more,

471
00:29:55,200 --> 00:29:58,538
check out this meshing magazine link that is shown on

472
00:29:58,544 --> 00:30:01,850
the screen now and is also in the slides now.

473
00:30:01,920 --> 00:30:06,000
Another very cool upcoming element is select list

474
00:30:06,370 --> 00:30:10,830
because if you've ever implemented your own custom select using javascript,

475
00:30:11,330 --> 00:30:15,054
you basically did a

476
00:30:15,092 --> 00:30:19,010
poor job because it's incredibly hard to do

477
00:30:19,160 --> 00:30:23,070
a good select and take care of all the keyword interactions,

478
00:30:23,150 --> 00:30:26,850
of all the accessibility, of all the different ways

479
00:30:26,920 --> 00:30:30,098
that the browser subtly implements, selects,

480
00:30:30,274 --> 00:30:33,830
but a regular select element is super limited,

481
00:30:34,490 --> 00:30:38,070
so you kind of have to regular select

482
00:30:38,140 --> 00:30:41,580
can't even contain icons or whatever.

483
00:30:42,270 --> 00:30:45,702
So enter select list. This new element

484
00:30:45,766 --> 00:30:49,014
has all the logic and the semantics of a regular

485
00:30:49,062 --> 00:30:52,458
select, but every part is completely

486
00:30:52,544 --> 00:30:56,142
stylable. Now when I say it

487
00:30:56,196 --> 00:31:00,640
implements all the logic and semantics of a regular select,

488
00:31:01,090 --> 00:31:04,618
that means that I can just add a select list element

489
00:31:04,714 --> 00:31:08,466
to the page and have it behave like a

490
00:31:08,488 --> 00:31:11,950
regular select, but I can also go wild

491
00:31:12,030 --> 00:31:15,886
and style it. The select list itself contains

492
00:31:15,918 --> 00:31:19,510
a number of parts that you can style separately using the new

493
00:31:19,580 --> 00:31:23,126
parts pseudo function. So apart from button and

494
00:31:23,148 --> 00:31:26,840
list box you can also style each value, the selected value,

495
00:31:27,290 --> 00:31:31,074
the drop down marker and more. It's all HTML,

496
00:31:31,122 --> 00:31:35,002
so you can style the list box however you want. So for example,

497
00:31:35,136 --> 00:31:39,274
do you want to create a grid layout that just works?

498
00:31:39,472 --> 00:31:43,020
Do you want rounded corners that also just works?

499
00:31:43,550 --> 00:31:47,194
Do you want to create a full fledged emoji picker?

500
00:31:47,322 --> 00:31:50,080
Yeah, go ahead. A date picker also works.

501
00:31:50,530 --> 00:31:54,094
However, it's still very early days for this element and

502
00:31:54,132 --> 00:31:57,522
it's still under development. In fact, it hasn't been

503
00:31:57,576 --> 00:32:00,994
called select list for that long because less

504
00:32:01,032 --> 00:32:04,994
than a month ago it was select menu and they

505
00:32:05,032 --> 00:32:08,402
changed the name. Recently. They're still working on the right

506
00:32:08,456 --> 00:32:11,686
implementation for this element. However, if you want

507
00:32:11,708 --> 00:32:14,726
to play with it, you can try it out in polypane and if you set

508
00:32:14,748 --> 00:32:18,230
the right feature flag in other recent chromium browsers.

509
00:32:19,450 --> 00:32:23,814
The hash selector can also replace a ton of JavaScript

510
00:32:23,942 --> 00:32:27,510
because it allows us for the first time to style elements

511
00:32:27,590 --> 00:32:30,170
based on their relation to other elements.

512
00:32:30,510 --> 00:32:34,462
Now regular CSS selectors will only allow you to style based on

513
00:32:34,516 --> 00:32:37,646
their parent on where they are in

514
00:32:37,748 --> 00:32:41,162
the tree. But with the hash selector you can style

515
00:32:41,226 --> 00:32:44,910
based on child elements or siblings, or entirely different

516
00:32:44,980 --> 00:32:47,982
parts of the dom. In other words,

517
00:32:48,036 --> 00:32:51,300
they allow you to style parent elements based on their children,

518
00:32:51,670 --> 00:32:55,730
which is why they've been called the parent selector. At this moment

519
00:32:55,800 --> 00:32:59,302
it's available in Chrome and Webkit, so it's not quite ready

520
00:32:59,356 --> 00:33:02,950
for regular usage. But it's in Firefox's nightly,

521
00:33:03,610 --> 00:33:06,902
and that means that it's very close to being

522
00:33:06,956 --> 00:33:10,962
available in all browsers. So while there are hundreds

523
00:33:11,026 --> 00:33:14,762
of really really cool examples, I'm going to give you just one.

524
00:33:14,816 --> 00:33:18,346
There is a form where a user can select out of a list of options,

525
00:33:18,528 --> 00:33:22,214
and when they choose other, a new input

526
00:33:22,262 --> 00:33:25,280
field appears where people can fill in their own value.

527
00:33:25,810 --> 00:33:29,690
Now, instead of adding a JavaScript listener to the radio element

528
00:33:29,770 --> 00:33:33,962
and then hiding and showing we can do the same with this CSS

529
00:33:34,026 --> 00:33:37,060
selector. So now as I click other,

530
00:33:37,750 --> 00:33:41,442
what happens is that normally other

531
00:33:41,496 --> 00:33:45,554
text has display none, but then we add this

532
00:33:45,672 --> 00:33:48,634
has part to the selector.

533
00:33:48,782 --> 00:33:52,678
So when other is checked has

534
00:33:52,764 --> 00:33:56,966
starts to match and

535
00:33:56,988 --> 00:34:00,406
then the rest of the CSS selector also matches and we

536
00:34:00,428 --> 00:34:04,486
can style other text and show it. So that's

537
00:34:04,518 --> 00:34:08,086
zero listeners. It's easy to follow CSS and there's

538
00:34:08,118 --> 00:34:11,686
no javascript needed. Now that really scratches

539
00:34:11,718 --> 00:34:15,678
the surface in terms of what has can do. If you want to learn more

540
00:34:15,764 --> 00:34:19,102
and read up on other examples I wrote an article about

541
00:34:19,156 --> 00:34:22,874
hasis and where that you can read over on the polypane

542
00:34:22,922 --> 00:34:26,960
blog at Polypane app where is has

543
00:34:27,330 --> 00:34:30,926
now? As a last example, scroll driven

544
00:34:30,958 --> 00:34:34,610
animations are now available in chromium and

545
00:34:34,760 --> 00:34:38,686
what they do is they let you link animations

546
00:34:38,798 --> 00:34:41,826
in CSS to scroll positions.

547
00:34:42,018 --> 00:34:45,714
Previously, if you wanted to do any sort of animation on scroll

548
00:34:45,762 --> 00:34:48,898
or like a parallax effect, you'd have to use JavaScript,

549
00:34:49,074 --> 00:34:52,886
for example the excellent Greenstock library. But with this

550
00:34:52,908 --> 00:34:57,210
spec scroll driven animations you can do all of that in CSS.

551
00:34:57,710 --> 00:35:01,402
So this example uses no

552
00:35:01,456 --> 00:35:04,730
javascript at all. If you want to learn more

553
00:35:04,880 --> 00:35:08,446
you can go to brem us because that is a

554
00:35:08,468 --> 00:35:12,750
blog with a ton of cool scroll driven examples.

555
00:35:13,490 --> 00:35:17,520
But that's about all the time I have for this particular demo

556
00:35:17,830 --> 00:35:21,394
because I'm at the end of my presentation. So those

557
00:35:21,432 --> 00:35:25,234
are the things you can do in modern browsers that no

558
00:35:25,272 --> 00:35:28,546
longer need JavaScript and some that you'll be able to

559
00:35:28,568 --> 00:35:31,842
use soon. I think we have a great future

560
00:35:31,896 --> 00:35:35,702
ahead of us once these features land in browsers, and instead

561
00:35:35,756 --> 00:35:38,886
of managing things with JavaScript, we can let the browser deal with it

562
00:35:38,908 --> 00:35:42,230
based on the rules we declare with CSS and HTML.

563
00:35:42,650 --> 00:35:46,406
So I hope all of you now like or even love CSS and

564
00:35:46,428 --> 00:35:50,342
HTML a little bit more. All the live demos are of

565
00:35:50,396 --> 00:35:53,886
upcoming features are courtesy CEO of

566
00:35:53,908 --> 00:35:57,646
Polypane Shipping with experimental features turned on. You can

567
00:35:57,668 --> 00:36:01,674
find me on Twitter as at kiliovalkov and you can find Polypane

568
00:36:01,722 --> 00:36:04,380
at Polypane app. Thanks for listening and watching.

