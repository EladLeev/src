1
00:00:23,190 --> 00:00:26,550
Hello everyone, welcome to my talk sealing the gaps

2
00:00:26,630 --> 00:00:30,162
a deep dive into JavaScript neural leak detection. So,

3
00:00:30,216 --> 00:00:33,950
as you might guess, this talk will be about JavaScript memory consumption

4
00:00:34,030 --> 00:00:37,940
and how to identify JavaScript memory leaks happening in your application.

5
00:00:39,190 --> 00:00:42,718
Have you ever seen this specific error message which says r

6
00:00:42,744 --> 00:00:46,502
Snap, something went wrong. So the number one reason behind

7
00:00:46,556 --> 00:00:50,038
it is most probably too high memory consumption of a

8
00:00:50,044 --> 00:00:53,446
given chrome tab. So the browser decides to kill the

9
00:00:53,468 --> 00:00:56,858
tab and give you this error message. And the reason behind

10
00:00:56,944 --> 00:01:00,518
too much memory consumption can also be memory leaks.

11
00:01:00,694 --> 00:01:03,974
So before we go into any detail, let me quickly introduce

12
00:01:04,022 --> 00:01:07,626
myself. Hi, I'm Julian Jandel. I'm performance

13
00:01:07,658 --> 00:01:11,434
engineer at the company pushbasedio. So let's

14
00:01:11,482 --> 00:01:15,754
first talk about memory consumption. What consumes

15
00:01:15,802 --> 00:01:19,614
memory in our application? There are three main

16
00:01:19,652 --> 00:01:23,762
contributors that contribute to the amount of memory of our application

17
00:01:23,896 --> 00:01:27,458
or of the git browser tab running our application. On the

18
00:01:27,464 --> 00:01:31,054
first hand, we have JavaScript code we write, then we have the DOM

19
00:01:31,102 --> 00:01:34,578
we produce with our templates, and we have the composition layer

20
00:01:34,594 --> 00:01:38,086
we produce with our style sheets. So let's first talk

21
00:01:38,108 --> 00:01:42,278
about JavaScript. Whenever you store an object, in this case

22
00:01:42,444 --> 00:01:46,310
just a simple object with one property which says

23
00:01:46,380 --> 00:01:49,802
title Spiderman, we store it in memory. We just said say

24
00:01:49,856 --> 00:01:53,606
left movie equals this object, and this object is now stored in memory.

25
00:01:53,718 --> 00:01:57,294
As soon as we nullify this object back again, then we

26
00:01:57,332 --> 00:02:01,134
release this object from memory. Back then

27
00:02:01,172 --> 00:02:04,942
we have the case of immutability. So whenever you create

28
00:02:04,996 --> 00:02:08,542
a copy, for example, of the object we have created before,

29
00:02:08,676 --> 00:02:12,254
then we create a shallow copy which says okay, we have to copy

30
00:02:12,302 --> 00:02:15,662
all the primitive values. In this case we will consume

31
00:02:15,726 --> 00:02:19,378
twice memory as before, because movie copy is now its very own

32
00:02:19,464 --> 00:02:22,850
copied object and not a reference to the other one anymore,

33
00:02:23,270 --> 00:02:26,646
then we have DOM nodes. So for each dom node we create, they are

34
00:02:26,668 --> 00:02:30,360
stored as strings, and if they contain attributes and other

35
00:02:30,730 --> 00:02:33,946
strings, for example text or other values, then this is

36
00:02:33,968 --> 00:02:37,478
also stored in the memory of your browser tab.

37
00:02:37,574 --> 00:02:40,874
And finally we have the composition layers. So whenever you

38
00:02:40,912 --> 00:02:44,326
have any specific rule that promotes

39
00:02:44,358 --> 00:02:48,090
a new layer, for example, if you say will change transform

40
00:02:48,170 --> 00:02:51,930
or you use directly the transform property CSS

41
00:02:52,010 --> 00:02:55,434
attribute, then you will promote a new layer which consumes

42
00:02:55,482 --> 00:02:58,842
memory, but in this case specifically on your GPU.

43
00:02:58,906 --> 00:03:02,174
So if your device has a dedicated graphics

44
00:03:02,222 --> 00:03:06,158
card, then the memory will be stored on your GPU. This is specifically

45
00:03:06,254 --> 00:03:09,566
important for lower end devices like mobile

46
00:03:09,598 --> 00:03:13,078
phones, because they most probably have not enough

47
00:03:13,244 --> 00:03:15,640
dedicated GPU memory available.

48
00:03:17,610 --> 00:03:20,870
So let's inspect the DOM and the JavaScript memory.

49
00:03:21,530 --> 00:03:25,014
We go twofold here. So in the first one

50
00:03:25,052 --> 00:03:28,346
we want to have a bird's eye view, and then we want

51
00:03:28,368 --> 00:03:32,554
to do an in depth analysis. So let's start with the bird's eye view.

52
00:03:32,752 --> 00:03:36,750
We have multiple tools that help us here so we can, for example,

53
00:03:36,820 --> 00:03:40,622
use the performance monitor of the Chrome devtools, which gives us

54
00:03:40,676 --> 00:03:44,334
an overview over a time span about

55
00:03:44,372 --> 00:03:48,026
the memory consumption of our JavaScript heap,

56
00:03:48,138 --> 00:03:52,370
and about the amount of Dom nodes and the amount of JavaScript event

57
00:03:52,440 --> 00:03:55,998
listeners. This is very important because all of them contribute

58
00:03:56,094 --> 00:03:59,380
as well to the memory of our Chrome tab in total.

59
00:03:59,750 --> 00:04:02,070
Then we have the task manager,

60
00:04:02,890 --> 00:04:06,626
which also gives you an indicator about the memory footprint.

61
00:04:06,738 --> 00:04:10,594
This doesn't have to be completely in line with what the performance monitor

62
00:04:10,642 --> 00:04:14,314
tells you, because the memory footprint contains more

63
00:04:14,352 --> 00:04:18,154
information than just those metrics. We can see

64
00:04:18,352 --> 00:04:22,122
the JavaScript memories, so the JS heap size

65
00:04:22,176 --> 00:04:24,890
here in the last column where it says JavaScript memory.

66
00:04:25,630 --> 00:04:29,194
And finally, this is a very new feature. Just drop

67
00:04:29,242 --> 00:04:33,134
with the new chrome where the chrome browser can

68
00:04:33,172 --> 00:04:36,298
tell you by hovering over your tab how much memory

69
00:04:36,394 --> 00:04:39,642
it uses. So you do not have to open the task manager anymore,

70
00:04:39,706 --> 00:04:42,562
you can simply hover over your tab bar.

71
00:04:42,616 --> 00:04:46,466
And this is a pretty cool new feature. So all of

72
00:04:46,488 --> 00:04:49,902
those metrics give you just an indication about how much memory

73
00:04:49,966 --> 00:04:53,506
your application right now uses, or over a very

74
00:04:53,688 --> 00:04:56,834
tiny time span. But let's go into an in depth analysis.

75
00:04:56,882 --> 00:05:00,386
Let's find out what happens inside there and how the data is stored

76
00:05:00,418 --> 00:05:04,178
in there. So before we go into the in depth analysis, let's talk

77
00:05:04,204 --> 00:05:08,060
about the terminology, because we have to introduce some words here.

78
00:05:08,750 --> 00:05:12,262
The first and most important one, I guess is the memory heap.

79
00:05:12,406 --> 00:05:16,006
So the memory heap is an interconnected

80
00:05:16,038 --> 00:05:20,054
graph, which means your objects are not only simple

81
00:05:20,112 --> 00:05:23,486
objects, but they only have references to each other. So if

82
00:05:23,508 --> 00:05:26,846
you store a reference from one object to another, then this

83
00:05:26,868 --> 00:05:30,306
will be also part of the memory heap. And if you

84
00:05:30,328 --> 00:05:33,506
want to remove objects from the memory heap, it has

85
00:05:33,528 --> 00:05:36,946
to traverse the whole graph in order to find anything.

86
00:05:37,048 --> 00:05:41,380
So it not only stores objects but also their

87
00:05:41,770 --> 00:05:44,994
references to other objects, as well as primitive values

88
00:05:45,042 --> 00:05:48,566
belonging to different objects. Then we have object

89
00:05:48,668 --> 00:05:52,678
sizes, and this is threefold. We have the shallow size

90
00:05:52,764 --> 00:05:56,874
which describes only the size of this very specific

91
00:05:56,992 --> 00:06:00,746
one object we are taking a look at. Then we

92
00:06:00,768 --> 00:06:04,410
have the retained size, which gives us information about

93
00:06:04,560 --> 00:06:07,790
everything this node will

94
00:06:07,860 --> 00:06:11,326
release when we remove this specific object from the

95
00:06:11,348 --> 00:06:16,718
memory. So also taking account into everything

96
00:06:16,804 --> 00:06:19,790
that relates to this object and not only the object itself.

97
00:06:19,860 --> 00:06:23,234
So this is the metric which is most important when

98
00:06:23,272 --> 00:06:27,086
you want to prioritize after which nodes

99
00:06:27,118 --> 00:06:30,338
are most important to release from the memory because the retained size

100
00:06:30,424 --> 00:06:34,370
gives you the information. If I remove this one from the memory,

101
00:06:34,450 --> 00:06:38,034
then retained size will be the amount of memory

102
00:06:38,082 --> 00:06:41,750
I save from that. And finally we have the distance.

103
00:06:42,090 --> 00:06:46,150
Distance is telling you the distance the

104
00:06:46,220 --> 00:06:50,086
garbage collection collector needs to travel. So the path the garbage

105
00:06:50,118 --> 00:06:53,514
collector need to travel over the graph in order to

106
00:06:53,552 --> 00:06:57,902
find a given node and to finally release it within

107
00:06:57,956 --> 00:07:00,110
the next garbage collecting cycle.

108
00:07:00,610 --> 00:07:04,910
So after all this terminology,

109
00:07:05,250 --> 00:07:08,478
let's find out which tools we have in order to

110
00:07:08,564 --> 00:07:11,678
inspect the memory of our JavaScript applications.

111
00:07:11,854 --> 00:07:15,026
So first of all we have the memory tab of the

112
00:07:15,048 --> 00:07:18,654
chrome browser. You can find it by opening the devtools and then simply

113
00:07:18,702 --> 00:07:22,434
selecting the memory tab before you want to

114
00:07:22,472 --> 00:07:26,162
start any analysis or create a heat snapshot.

115
00:07:26,226 --> 00:07:30,262
You always want to trigger the garbage collector which is indicated by this

116
00:07:30,316 --> 00:07:33,734
tiny garbage icon here on top. And then you can take

117
00:07:33,772 --> 00:07:38,278
a snapshot here down with the blue button which says take snapshot.

118
00:07:38,374 --> 00:07:42,186
This will create now a heap snapshot for you and you

119
00:07:42,208 --> 00:07:46,446
will be ported over to an overview which

120
00:07:46,548 --> 00:07:49,694
will basically give you an information about

121
00:07:49,812 --> 00:07:54,046
all the nodes that are stored in

122
00:07:54,068 --> 00:07:57,738
your app. So all the arrays, all the strings, everything that belongs

123
00:07:57,754 --> 00:08:01,222
to window, all anonymous functions that are somewhere stored.

124
00:08:01,306 --> 00:08:04,418
So basically everything that is accessible in your memory and

125
00:08:04,504 --> 00:08:08,606
used by your application is now visible in this snapshot

126
00:08:08,638 --> 00:08:11,746
and you can search it and filter it. So let's take a look at how

127
00:08:11,768 --> 00:08:15,462
you do that. So there is a little search bar on top

128
00:08:15,516 --> 00:08:19,286
where it says class filter and in the demo we will

129
00:08:19,308 --> 00:08:22,930
go over next I have a class for example named

130
00:08:23,010 --> 00:08:27,030
findme. So if you search for it, it will filter

131
00:08:27,110 --> 00:08:30,710
all the summary, all the overview

132
00:08:30,790 --> 00:08:34,774
entries and will give you only the entry

133
00:08:34,822 --> 00:08:37,658
which says find me and you can inspect it then.

134
00:08:37,744 --> 00:08:41,166
So you will see with the tiny f symbol here. This is the id of

135
00:08:41,188 --> 00:08:44,222
the node stored in your memory and it will give you

136
00:08:44,276 --> 00:08:47,646
also an indication where this object specific

137
00:08:47,748 --> 00:08:51,186
object is actually created. As you can

138
00:08:51,208 --> 00:08:54,706
also see here, you will be informed about the distance and

139
00:08:54,728 --> 00:08:58,654
the shallow size and the retained size. So those three terms we discussed

140
00:08:58,702 --> 00:09:02,470
before when inspecting nodes in the heap snapshot,

141
00:09:03,450 --> 00:09:06,310
if you select one of those nodes,

142
00:09:07,370 --> 00:09:11,014
you will be given a retainers list. And the

143
00:09:11,052 --> 00:09:14,282
retainers list is one specific super cool

144
00:09:14,336 --> 00:09:17,930
feature to inspect memory leaks which we will use later

145
00:09:18,000 --> 00:09:21,866
on because this will tell you objects that still

146
00:09:21,968 --> 00:09:25,910
rely on this specific node. So if you want to

147
00:09:26,000 --> 00:09:29,614
trace down the memory heap then

148
00:09:29,652 --> 00:09:31,520
you search in the retainers list.

149
00:09:33,010 --> 00:09:36,926
Which other node is still keeping the one I'm searching for

150
00:09:37,028 --> 00:09:40,430
in memory. So let's go on a quick

151
00:09:40,500 --> 00:09:43,874
demo where we quickly go over

152
00:09:43,912 --> 00:09:48,274
the memory tab capabilities. So here

153
00:09:48,312 --> 00:09:51,654
you can see a very simple code example just

154
00:09:51,692 --> 00:09:55,074
with this findme class which I was telling

155
00:09:55,122 --> 00:09:58,934
about before. So this findme class

156
00:09:59,052 --> 00:10:02,230
has just a content property which has

157
00:10:02,300 --> 00:10:05,734
just a very large array to have artificially large memory

158
00:10:05,782 --> 00:10:10,134
consumption. So we can see some number in our memory heap snapshot.

159
00:10:10,262 --> 00:10:13,722
And finally we create a const out of it which says new

160
00:10:13,776 --> 00:10:17,754
findme and then we console log

161
00:10:17,792 --> 00:10:21,310
it to the console. So let's take a look at how this one looks

162
00:10:21,380 --> 00:10:25,406
in our browser. So we have just the title here.

163
00:10:25,508 --> 00:10:29,466
We will open now the memory tab. So I've opened

164
00:10:29,498 --> 00:10:33,586
the chrome dev tools, we don't need the performance monitor for now,

165
00:10:33,688 --> 00:10:37,358
but let's take a look at the memory

166
00:10:37,454 --> 00:10:41,394
tab here. So the first thing we want to do is collecting garbage. Then we

167
00:10:41,432 --> 00:10:45,190
want to take a heap snapshot, and as we can see, five megabytes,

168
00:10:45,610 --> 00:10:48,662
pretty large for just the title. So let's search

169
00:10:48,716 --> 00:10:52,326
for findme. And as you can see here

170
00:10:52,428 --> 00:10:57,130
now we have found our object which says findme

171
00:10:57,790 --> 00:11:00,874
with this specific node id.

172
00:11:01,072 --> 00:11:04,854
And when we click it, it will open up the retainers

173
00:11:04,902 --> 00:11:08,510
list down here in the bottom and it will point us to

174
00:11:08,580 --> 00:11:12,046
a line of code where this is

175
00:11:12,148 --> 00:11:15,918
still in use. But in this case this is a stacked example and we

176
00:11:15,924 --> 00:11:19,534
have just a global const. So this will not go anywhere

177
00:11:19,582 --> 00:11:23,170
from this point. We will go over memory leak

178
00:11:23,830 --> 00:11:27,330
detection afterwards. But this is just a cool feature

179
00:11:27,910 --> 00:11:31,462
for inspecting which other lines of code

180
00:11:31,516 --> 00:11:34,680
are still affecting this findme property.

181
00:11:35,530 --> 00:11:39,154
Okay, so let's

182
00:11:39,202 --> 00:11:41,670
go back to our presentation.

183
00:11:45,070 --> 00:11:48,442
We have now discussed how to inspect or

184
00:11:48,496 --> 00:11:52,742
how to get an overview over our properties

185
00:11:52,886 --> 00:11:55,994
stored in the JavaScript memory heap via the

186
00:11:56,032 --> 00:11:59,562
memory tab in the chrome devtools. What we didn't inspect

187
00:11:59,626 --> 00:12:03,454
were our composition layers, but I introduced it before, so let's talk about

188
00:12:03,492 --> 00:12:06,910
that as well. So I have an example here from

189
00:12:06,980 --> 00:12:11,634
observable HQ from the observable HQ landing page.

190
00:12:11,832 --> 00:12:16,482
As you can see here, there's a UI element which just

191
00:12:16,536 --> 00:12:20,194
shifts elements on a pane left and right,

192
00:12:20,312 --> 00:12:24,062
and if you inspect it via the layer tool and shift

193
00:12:24,126 --> 00:12:27,366
the application a little bit, then you can see all of

194
00:12:27,388 --> 00:12:30,902
those images and all of those tiles are actually on their very own

195
00:12:30,956 --> 00:12:34,998
layers. And what does that mean for our memory consumption?

196
00:12:35,174 --> 00:12:39,642
So you have seen this slide before, but I want to emphasize this

197
00:12:39,696 --> 00:12:43,162
once again. So there are certain rules that

198
00:12:43,216 --> 00:12:46,938
promote a new layer in your application.

199
00:12:47,104 --> 00:12:50,926
So whenever you use one of those, it will promote a

200
00:12:50,948 --> 00:12:54,282
new CSS layer and this will consume memory

201
00:12:54,346 --> 00:12:57,838
on the GPU of your device and how much we can also

202
00:12:57,924 --> 00:13:01,874
inspect. So other reasons besides the two

203
00:13:01,912 --> 00:13:06,354
we have seen before that promote a layer are for example 3d

204
00:13:06,392 --> 00:13:10,194
or perspective changes. A video element always promotes a new

205
00:13:10,232 --> 00:13:13,270
layer, canvas elements always promotes new layers,

206
00:13:14,090 --> 00:13:19,126
animated opacities or transforms. And if

207
00:13:19,148 --> 00:13:22,466
you have a sibling with the lower Z index plus a new stacking

208
00:13:22,498 --> 00:13:26,118
index. So how to inspect those layers?

209
00:13:26,294 --> 00:13:30,310
How does this work? There is a tool in the chrome devtools

210
00:13:30,470 --> 00:13:34,106
which says layers. You can reach it because it's not enabled by

211
00:13:34,128 --> 00:13:37,526
default by clicking this three button menu on top and then

212
00:13:37,568 --> 00:13:41,326
select more tools and there you find layers. So you

213
00:13:41,348 --> 00:13:46,190
can just open the layer tool and it will open this nice

214
00:13:46,260 --> 00:13:49,810
overview for you where you can zoom and tilt and pinch

215
00:13:50,870 --> 00:13:54,274
into the viewport and see basically a 3d

216
00:13:54,312 --> 00:13:58,382
view of the application where all the layers are separately displayed.

217
00:13:58,446 --> 00:14:01,954
It also gives you detailed information about the layers. And as you can

218
00:14:01,992 --> 00:14:05,270
see here down below, here's a memory estimate and

219
00:14:05,340 --> 00:14:09,362
a composition reason. So if you want to find out why this element

220
00:14:09,426 --> 00:14:12,562
in your browser was promoted to a new layer,

221
00:14:12,626 --> 00:14:16,806
then you can just use this tool to inspect it. Select your layer via

222
00:14:16,838 --> 00:14:20,602
the layer tool and it will give you the reason why it was composited into

223
00:14:20,656 --> 00:14:24,374
a new layer. And also you see this particular layer

224
00:14:24,422 --> 00:14:28,426
consumes seven megabytes of GPU memory. So let's

225
00:14:28,458 --> 00:14:32,414
take a look at this one as well. Let's open

226
00:14:32,452 --> 00:14:36,810
again the chrome browser. So here we have the observable HQ

227
00:14:36,890 --> 00:14:40,114
landing page and I am already scrolled down to

228
00:14:40,152 --> 00:14:43,282
the point where we actually want to be. So let me open

229
00:14:43,336 --> 00:14:46,530
up again the dev tools.

230
00:14:46,870 --> 00:14:50,334
So I have basically the default setup,

231
00:14:50,382 --> 00:14:53,654
so it is not available by default here. So I will go here

232
00:14:53,772 --> 00:14:57,234
and go to more tools and select the layers

233
00:14:57,282 --> 00:15:01,318
tool. And now I have the layers tab available here where

234
00:15:01,404 --> 00:15:04,774
all the layers are basically collapsed here, but we can

235
00:15:04,812 --> 00:15:08,490
expand it and then we can see all of the layers here in this list.

236
00:15:08,560 --> 00:15:11,994
And also we can zoom in here this 3d

237
00:15:12,032 --> 00:15:15,846
view and by selecting different movement tools we can

238
00:15:15,968 --> 00:15:19,854
turn around our application and bring the application

239
00:15:19,972 --> 00:15:23,662
into position where we actually can see the layering is

240
00:15:23,716 --> 00:15:27,102
happening. So here you can see it nice and

241
00:15:27,156 --> 00:15:30,610
beautiful. So the text actually has a completely different

242
00:15:30,680 --> 00:15:34,146
layer than the images here up top, and we

243
00:15:34,168 --> 00:15:37,746
can see all of them created here. And if we select for

244
00:15:37,768 --> 00:15:41,314
example this specific layer here, we can see

245
00:15:41,432 --> 00:15:45,070
a memory estimate of 10.5 megabytes

246
00:15:45,150 --> 00:15:48,806
and we can also see a composition reason,

247
00:15:48,988 --> 00:15:53,154
compositing reason. So this one specifically has an active

248
00:15:53,202 --> 00:15:56,646
accelerated transform animation or transition.

249
00:15:56,838 --> 00:16:01,606
So we can go over to the elements panel and confirm

250
00:16:01,638 --> 00:16:05,386
this once again. But I guess this tool will be right anyway.

251
00:16:05,488 --> 00:16:09,086
So this is a nice tool to inspect how much memory your layers are

252
00:16:09,108 --> 00:16:12,206
consuming and how much layers your application actually have.

253
00:16:12,308 --> 00:16:16,000
And as I said before, this might not be very important for

254
00:16:17,650 --> 00:16:21,086
your desktop users, but for mobile users this can be important,

255
00:16:21,188 --> 00:16:24,782
especially if you have very large layers that consume

256
00:16:24,926 --> 00:16:28,670
lots of memories. So if we for example, just select the outer document,

257
00:16:28,750 --> 00:16:33,430
which is pretty large, we see this one consumes 35 megabytes.

258
00:16:35,050 --> 00:16:38,680
So treat your layers with caution and everything will be good.

259
00:16:39,130 --> 00:16:43,800
Very cool. So let's go back to finally

260
00:16:45,310 --> 00:16:48,838
hit the target of identifying memory leaks.

261
00:16:48,934 --> 00:16:52,682
And I've brought again the Osnap logo for you because

262
00:16:52,736 --> 00:16:55,260
this is a very funny guy, I think.

263
00:16:56,270 --> 00:16:59,994
Okay, so let's first talk about what are memory leaks?

264
00:17:00,042 --> 00:17:03,262
In order to fix something, we need to know about what they are,

265
00:17:03,316 --> 00:17:07,502
right? So memory leaks essentially are,

266
00:17:07,636 --> 00:17:11,394
or is memory that is allocated by your application.

267
00:17:11,512 --> 00:17:13,780
So something that is stored and used,

268
00:17:14,630 --> 00:17:17,618
stored but not used anymore by your application.

269
00:17:17,704 --> 00:17:21,486
So you have a global variable stored somewhere, but you don't

270
00:17:21,518 --> 00:17:25,666
use it anymore. And this is basically a memory leaks.

271
00:17:25,858 --> 00:17:29,974
And if you do it too often, then this one will be the

272
00:17:30,012 --> 00:17:33,494
number one reason for crashing browser sessions, and then you will

273
00:17:33,612 --> 00:17:37,542
get the odd snap error. So the worst

274
00:17:37,606 --> 00:17:41,530
case is when you repeatedly allocate memory without

275
00:17:41,600 --> 00:17:45,274
cleaning up. So for example, if you have a component that you

276
00:17:45,312 --> 00:17:49,390
create which creates a memory leak, and you create it

277
00:17:49,460 --> 00:17:53,438
multiple times and destroy it multiple times, in this case

278
00:17:53,524 --> 00:17:57,134
you will see patterns like this in the performance monitor. And this is where

279
00:17:57,172 --> 00:18:01,278
the performance monitor then also shines

280
00:18:01,454 --> 00:18:04,994
when inspecting memory leaks. So this is just

281
00:18:05,032 --> 00:18:08,370
a nice overview over time, where the starting point

282
00:18:08,440 --> 00:18:11,250
starts with 10,000 dom nodes,

283
00:18:11,750 --> 00:18:15,814
and in the end, after some interactions, you see all

284
00:18:15,852 --> 00:18:19,426
of the metrics are just rising and rising and rising. We get Dom

285
00:18:19,458 --> 00:18:22,822
nodes added and added and added and added and added. We get event

286
00:18:22,876 --> 00:18:26,934
listeners added, sometimes removed, but in the end added and

287
00:18:26,972 --> 00:18:30,586
added and more added, same as the Javascript heap size.

288
00:18:30,688 --> 00:18:34,614
And we end up seeing heap size increasing by 50 megabytes,

289
00:18:34,662 --> 00:18:38,282
DOm nodes by 70,000, and event listeners

290
00:18:38,346 --> 00:18:41,802
by 400. So this is definitely indicating

291
00:18:41,866 --> 00:18:45,066
a memory leak. And if you see such a pattern

292
00:18:45,098 --> 00:18:48,814
in your application, you should be worried about it because this

293
00:18:48,852 --> 00:18:52,690
can end up in a OS map. So what

294
00:18:52,760 --> 00:18:56,290
causes memory leaks? Finally? First of all,

295
00:18:56,360 --> 00:19:00,066
console logging. So this was very unexpected when

296
00:19:00,088 --> 00:19:03,762
I heard it the first time, but it's true and it makes sense

297
00:19:03,816 --> 00:19:07,158
if you think about it. So in order to display the

298
00:19:07,244 --> 00:19:11,106
value in your console or an object in your console.

299
00:19:11,138 --> 00:19:14,822
It has to keep reference to it, right? It doesn't create a copy just

300
00:19:14,876 --> 00:19:18,618
on its own. It references the object to finally

301
00:19:18,704 --> 00:19:21,930
display it and you can verify it by console log

302
00:19:22,000 --> 00:19:26,538
something. Even with the closed console, if you open your console afterwards,

303
00:19:26,634 --> 00:19:31,694
it will still be there and print it out. So still with

304
00:19:31,732 --> 00:19:34,750
a closed console, you will have a memory leak. Here.

305
00:19:34,820 --> 00:19:38,586
If you print out objects, then we

306
00:19:38,628 --> 00:19:42,354
have global variables. So whenever you store something

307
00:19:42,392 --> 00:19:46,370
on window or just create a random const in any component outside

308
00:19:46,440 --> 00:19:50,162
of the component's class scope, then you

309
00:19:50,216 --> 00:19:56,834
create something that is not really cleanable

310
00:19:56,882 --> 00:20:00,326
anymore. So you create something in a global scope and this will

311
00:20:00,348 --> 00:20:03,766
be stored and will be forever there and never clean up. Of course you can

312
00:20:03,788 --> 00:20:07,974
reuse it and you won't do it multiple times if you import the component

313
00:20:08,022 --> 00:20:11,194
file again. But just so you know, global variables will

314
00:20:11,232 --> 00:20:13,740
store memory which cannot be cleaned up.

315
00:20:15,310 --> 00:20:19,358
Then leftover subscriptions and this is most probably the number one reason

316
00:20:19,444 --> 00:20:22,986
for most memory leaks, like leftover callbacks

317
00:20:23,018 --> 00:20:27,210
and subscriptions to for example event listeners or intervals

318
00:20:27,290 --> 00:20:31,006
or just other RXJS subscriptions.

319
00:20:31,118 --> 00:20:34,434
So whenever you have something that you do

320
00:20:34,472 --> 00:20:38,386
not kill which runs forever like an interval or a timer from

321
00:20:38,408 --> 00:20:42,486
rxjs, and you reference some other value inside of

322
00:20:42,508 --> 00:20:46,006
it, it cannot be released anymore because

323
00:20:46,108 --> 00:20:49,446
this forever ongoing callback always keeps a

324
00:20:49,468 --> 00:20:53,302
reference to this object. And this means

325
00:20:53,356 --> 00:20:56,890
that in our case we create here a new foo object

326
00:20:57,040 --> 00:21:01,194
which will always be in memory, but also everything that

327
00:21:01,232 --> 00:21:04,634
relates to it. So if Foo has private values like this

328
00:21:04,672 --> 00:21:09,326
huge data amount, then of course huge data will also be

329
00:21:09,508 --> 00:21:12,030
part of the memory footprint.

330
00:21:12,450 --> 00:21:16,042
Same goes for HTML elements. And HTML elements

331
00:21:16,106 --> 00:21:20,030
have some specifics here. So they are not only contributing

332
00:21:20,190 --> 00:21:23,938
like Javascript values here, because if you

333
00:21:24,024 --> 00:21:27,922
end up having an

334
00:21:27,976 --> 00:21:31,282
HTML element which you cannot clean up anymore, it will get

335
00:21:31,336 --> 00:21:34,886
a detached element. So in this case you just have a

336
00:21:34,908 --> 00:21:38,386
reference in a function that is never cleaned up in a global

337
00:21:38,418 --> 00:21:41,798
scope to a button that you wanted actually to remove, then the

338
00:21:41,804 --> 00:21:45,198
button cannot be really removed. Of course it's not part of the DoM

339
00:21:45,234 --> 00:21:48,890
anymore that the user sees, but it will be a detached element.

340
00:21:49,390 --> 00:21:52,938
So now we know what memory leaks are. Now let's finally

341
00:21:53,024 --> 00:21:56,794
talk about how to detect memory leaks. So we will

342
00:21:56,832 --> 00:22:00,334
do follow the same approach as we did before.

343
00:22:00,532 --> 00:22:04,126
We will go first into a bird's eye view and then into an in

344
00:22:04,148 --> 00:22:07,040
depth analysis. Let's start with the bird's eye view,

345
00:22:08,530 --> 00:22:11,694
so this time we can use again the performance monitor

346
00:22:11,742 --> 00:22:14,866
to observe memory consumption over time. Of our application.

347
00:22:14,968 --> 00:22:18,866
As I've seen before, as I've shown you before,

348
00:22:19,048 --> 00:22:23,018
we want to indicate or see those patterns. So those patterns

349
00:22:23,054 --> 00:22:25,970
can indicate okay, this situation looks safe,

350
00:22:26,050 --> 00:22:30,262
or this situation definitely looks like something we need to dig into.

351
00:22:30,396 --> 00:22:33,994
So if we see the pattern on the left side where all of our

352
00:22:34,032 --> 00:22:36,698
metrics, or even if it's only one,

353
00:22:36,784 --> 00:22:41,814
is only increasing over time and is never ever decreasing,

354
00:22:41,942 --> 00:22:45,546
then 100% I can tell you something is wrong,

355
00:22:45,648 --> 00:22:49,866
whereas on the other side you see there is a slight increase,

356
00:22:49,978 --> 00:22:53,966
but there is also decrease every time. And afterwards, at the

357
00:22:53,988 --> 00:22:57,594
last point in time, this is where the garbage collector could release

358
00:22:57,642 --> 00:23:01,466
basically everything and we are on par on plane like the one

359
00:23:01,508 --> 00:23:04,754
before. This is the perfect scenario you want to see. So then

360
00:23:04,792 --> 00:23:08,914
everything is fine. If you have something on the left you should definitely take

361
00:23:08,952 --> 00:23:13,094
a look at. So exactly. We should

362
00:23:13,132 --> 00:23:16,930
never forget to trigger the garbage collector before we analyze our heap

363
00:23:17,010 --> 00:23:20,566
because otherwise the garbage collector is uncontrollable. We have

364
00:23:20,588 --> 00:23:24,454
no control about when the garbage collector of our browser

365
00:23:24,582 --> 00:23:27,974
decides to collect something, it totally

366
00:23:28,022 --> 00:23:31,450
depends on your system load and your system set up whatsoever.

367
00:23:32,030 --> 00:23:35,482
So before you do any investigation or something,

368
00:23:35,616 --> 00:23:39,834
then please go ahead and trigger the garbage collector annually because otherwise

369
00:23:39,882 --> 00:23:43,358
there's something you might didn't want to see.

370
00:23:43,524 --> 00:23:46,218
So let's go into the in depth analysis.

371
00:23:46,314 --> 00:23:50,034
Analysis so do you remember

372
00:23:50,152 --> 00:23:54,482
the detached elements I talked about before where

373
00:23:54,536 --> 00:23:58,578
this is very important because most of the time as we develop

374
00:23:58,664 --> 00:24:02,354
on front ends, we are tightly

375
00:24:02,402 --> 00:24:05,810
coupling our JavaScript code anyway, the DOM elements,

376
00:24:05,890 --> 00:24:10,002
as we are working with components that afterwards

377
00:24:10,066 --> 00:24:13,754
get dom nodes. And this is really

378
00:24:13,792 --> 00:24:17,318
cool because the edge browser, the Microsoft

379
00:24:17,414 --> 00:24:20,154
Edge browser with version 93,

380
00:24:20,352 --> 00:24:24,198
added a new tool to their devtools,

381
00:24:24,214 --> 00:24:27,962
which is called the detached elements tool, which is dramatically

382
00:24:28,026 --> 00:24:31,690
helping in finding memory leaks based off component

383
00:24:31,770 --> 00:24:35,040
oriented frameworks. So how does this work?

384
00:24:36,370 --> 00:24:39,486
So this looks basically the

385
00:24:39,508 --> 00:24:42,674
same as the chrome dev tools, but instead

386
00:24:42,712 --> 00:24:45,826
of the three dot menu you have a plus icon here and there. You can

387
00:24:45,928 --> 00:24:49,362
select the detached elements tool here. If you open

388
00:24:49,416 --> 00:24:53,010
it, you want to follow the following approach.

389
00:24:53,170 --> 00:24:56,470
So the buttons are in my opinion the wrong

390
00:24:56,540 --> 00:24:59,862
order because the first thing you always want to do

391
00:24:59,916 --> 00:25:03,494
is triggering the garbage collector. So hitting the

392
00:25:03,532 --> 00:25:06,666
trash button here, the trash bin button here as the

393
00:25:06,688 --> 00:25:10,054
first button, then we want to read the detached elements.

394
00:25:10,102 --> 00:25:13,894
So this is telling the browser to read all detached elements

395
00:25:13,942 --> 00:25:17,466
that are still kept in Dom, and afterwards we want to analyze

396
00:25:17,498 --> 00:25:21,246
the heap. So first we know about all the detached elements and

397
00:25:21,268 --> 00:25:25,338
then we want to deeply analyze

398
00:25:25,434 --> 00:25:27,920
where those detached elements belong to.

399
00:25:28,370 --> 00:25:32,526
So this will lead us to this list of detached

400
00:25:32,558 --> 00:25:36,354
elements after we followed this approach, where each of those

401
00:25:36,472 --> 00:25:39,826
elements should have an id. Elements that do not have an

402
00:25:39,848 --> 00:25:43,646
id anymore you can safely ignore because they are not part of this heap

403
00:25:43,678 --> 00:25:47,426
anymore. On the top right you see a total amount of detached

404
00:25:47,458 --> 00:25:51,142
elements found in our current example, and then we can go ahead

405
00:25:51,196 --> 00:25:55,414
and select one of those. And this will now be interconnected

406
00:25:55,462 --> 00:25:59,494
with the memory tab we have seen before and open up the retainers

407
00:25:59,542 --> 00:26:03,114
list. So if you remember, the retainers list will give you

408
00:26:03,152 --> 00:26:06,842
information about where this code is

409
00:26:06,896 --> 00:26:10,494
actually still in use. And in this example, you see our

410
00:26:10,532 --> 00:26:14,446
detached node is a list item. We select its id,

411
00:26:14,548 --> 00:26:17,850
it will tell us open up the memory tab

412
00:26:18,010 --> 00:26:21,342
down here at the bottom. Then it will show us

413
00:26:21,396 --> 00:26:25,202
it is a detached HTML diff element and it will point

414
00:26:25,256 --> 00:26:29,314
us directly to the source of leakage. So we

415
00:26:29,352 --> 00:26:32,934
can just click basically this line of code here.

416
00:26:32,972 --> 00:26:36,486
And we see here context in. So this will definitely

417
00:26:36,588 --> 00:26:39,410
mean detached v eight event listener.

418
00:26:39,490 --> 00:26:44,018
So this means probably an anonymous function in an event listener,

419
00:26:44,114 --> 00:26:48,074
maybe a click event or something. And by clicking this

420
00:26:48,112 --> 00:26:51,546
line of code we will go directly to the

421
00:26:51,568 --> 00:26:54,666
source where this click listener is coming from, and we can

422
00:26:54,688 --> 00:26:58,558
fix it right away. So let's go to our final

423
00:26:58,644 --> 00:27:02,526
demo for this. I need to switch now to

424
00:27:02,548 --> 00:27:06,222
the edge browser. So this is now the edge browser and this is another

425
00:27:06,276 --> 00:27:10,894
stackbus example I am showing here. So this one is slightly

426
00:27:10,942 --> 00:27:14,370
more complex than the one before. So let's first open up

427
00:27:14,440 --> 00:27:18,174
our dev tools here. And let's

428
00:27:18,222 --> 00:27:22,174
start with the performance monitor because we want at first confirm

429
00:27:22,222 --> 00:27:25,154
of course, is there a memory leak or is there none?

430
00:27:25,282 --> 00:27:28,518
And of course, as I've always said

431
00:27:28,604 --> 00:27:31,762
before, we should clear our garbage.

432
00:27:31,826 --> 00:27:35,526
As you have seen, we have a slight ditch here now. So this

433
00:27:35,548 --> 00:27:37,786
was a good thing to have a clean state.

434
00:27:37,968 --> 00:27:41,686
And now we want to go ahead and toggle

435
00:27:41,718 --> 00:27:45,514
this button and we can see, okay, now we have 120

436
00:27:45,632 --> 00:27:48,302
megabytes, let's go ahead and click one more,

437
00:27:48,436 --> 00:27:52,094
200, 270, and more

438
00:27:52,132 --> 00:27:55,674
and more and more. So we'll see this stair like pattern,

439
00:27:55,802 --> 00:27:59,378
and this already indicates a memory leak. But to be sure,

440
00:27:59,464 --> 00:28:03,246
we definitely need to collect our garbage

441
00:28:03,278 --> 00:28:06,802
here. So let's collect garbage. And yeah,

442
00:28:06,856 --> 00:28:10,786
when garbage collection collection is not doing the

443
00:28:10,808 --> 00:28:14,598
thing here, then we can be sure that we run into a

444
00:28:14,604 --> 00:28:18,246
memory leak here. So let's figure out what is the problem. And it

445
00:28:18,268 --> 00:28:22,280
looks like that we also leak Dom nodes. So we can safely say

446
00:28:23,290 --> 00:28:26,986
it's kind of related here, the amount of Javascript heap size and

447
00:28:27,008 --> 00:28:31,130
the amount of Dom nodes. So let's do a detached elements analysis.

448
00:28:33,230 --> 00:28:36,934
I want to collect the garbage again. And then we click

449
00:28:36,992 --> 00:28:40,686
here to get our detached elements. So now we

450
00:28:40,708 --> 00:28:44,542
have this list here and it says on

451
00:28:44,596 --> 00:28:48,366
the first side, object not found in memory. That is because we

452
00:28:48,388 --> 00:28:51,774
didn't analyze the heap yet. So when we analyze the memory

453
00:28:51,822 --> 00:28:55,806
heap, it will transform or analyze it and transform

454
00:28:55,998 --> 00:28:59,694
those into actual ids. And if here is now some leftover

455
00:28:59,822 --> 00:29:03,154
which has no id, and this one can be ignored. But all of them have

456
00:29:03,192 --> 00:29:06,374
ids, so it looks like all of them would be still

457
00:29:06,412 --> 00:29:09,926
kept in memories. And those are actual divs. Of course they are not part of

458
00:29:09,948 --> 00:29:13,366
the domno. So if we inspect it, it's completely empty. But they

459
00:29:13,388 --> 00:29:16,902
are still here as detached Dom nodes and stored in our memory

460
00:29:16,966 --> 00:29:20,602
of the browser. So the size column here is

461
00:29:20,656 --> 00:29:24,086
actually not indicating the amount of memory here is stored,

462
00:29:24,118 --> 00:29:27,566
but the depth of the node. So if we open it up,

463
00:29:27,748 --> 00:29:31,182
we see some track nodes and size

464
00:29:31,236 --> 00:29:34,846
is indicating that. So if we

465
00:29:34,868 --> 00:29:38,506
now select this id here, then it will

466
00:29:38,548 --> 00:29:41,906
open up the memory tab at the bottom,

467
00:29:42,088 --> 00:29:46,610
immediately select it, and immediately open

468
00:29:46,680 --> 00:29:50,546
up the retainers list and point us directly to

469
00:29:50,568 --> 00:29:54,358
the source of leaks. So we see here context in

470
00:29:54,524 --> 00:29:58,018
and we see v eight event listener. V eight event listener

471
00:29:58,114 --> 00:30:02,434
indicates an event listener of an event of a HTML

472
00:30:02,482 --> 00:30:06,586
node. And here we can just click this specific

473
00:30:06,688 --> 00:30:10,090
line of code and it will directly point us

474
00:30:10,160 --> 00:30:13,994
to our list item implementation here. List item. And we see

475
00:30:14,112 --> 00:30:17,534
bold Toggle has an event listener to the

476
00:30:17,572 --> 00:30:20,958
event change with an anonymous function.

477
00:30:21,124 --> 00:30:24,746
And because this one is probably never destroyed,

478
00:30:24,858 --> 00:30:28,126
when we actually toggle our list back to

479
00:30:28,148 --> 00:30:31,966
an invisible or destroyed state, that's why it's still kept

480
00:30:31,998 --> 00:30:35,220
in memory and that's why we could find it now.

481
00:30:35,830 --> 00:30:38,878
So let's go ahead and fix the lines

482
00:30:38,894 --> 00:30:42,534
of code that our memory leaks are gone.

483
00:30:42,572 --> 00:30:46,920
And afterwards let's check that the leaks are actually gone.

484
00:30:47,930 --> 00:30:51,046
Okay, so what I want to do now is I want

485
00:30:51,068 --> 00:30:54,842
to transform our anonymous function into something

486
00:30:54,896 --> 00:30:58,010
we can afterwards destroy with

487
00:30:58,080 --> 00:31:01,786
the remove event listener. Let's first go quickly over the

488
00:31:01,808 --> 00:31:05,338
code. So we have this class list item which gets

489
00:31:05,424 --> 00:31:09,070
created whenever we toggle this button

490
00:31:09,140 --> 00:31:13,102
here. So whenever we click toggle list, we create

491
00:31:13,156 --> 00:31:16,894
a bunch of list items. So every dom node you see

492
00:31:16,932 --> 00:31:21,058
here is actually a list item class.

493
00:31:21,224 --> 00:31:24,862
And this one will create its node

494
00:31:24,926 --> 00:31:28,370
template by an item template I have created, clone it.

495
00:31:28,440 --> 00:31:32,246
And this is the template we are creating here. Basically a very simple

496
00:31:32,348 --> 00:31:34,600
component as a class.

497
00:31:35,850 --> 00:31:39,862
Okay, so this specific event

498
00:31:39,916 --> 00:31:43,874
listener is now the problematic thing. So what we actually want to do is

499
00:31:43,932 --> 00:31:47,210
we want to have for example a destroy method

500
00:31:48,750 --> 00:31:52,646
like in angular the Ng destroy method. But we are in plain

501
00:31:52,678 --> 00:31:56,758
Javascript field here, so we have no framework taking care of this for

502
00:31:56,784 --> 00:32:00,362
us. We will have to do it manually. But on destroy

503
00:32:00,426 --> 00:32:03,722
we want to use the bold toggle and use remove

504
00:32:03,786 --> 00:32:07,594
event listener and remove our event listener

505
00:32:07,642 --> 00:32:11,540
to change in order to fix it. The last thing we need to do here

506
00:32:12,630 --> 00:32:16,962
in the list item is to store this function as

507
00:32:17,016 --> 00:32:20,514
something we can afterwards reuse. So we want

508
00:32:20,552 --> 00:32:25,910
to store it here as a bold

509
00:32:26,810 --> 00:32:30,920
change listener exactly like this.

510
00:32:31,850 --> 00:32:35,418
And now we can apply it here

511
00:32:35,504 --> 00:32:39,114
in our add event listener method, and we can

512
00:32:39,152 --> 00:32:43,078
also use it here in the remove event listener

513
00:32:43,174 --> 00:32:47,146
as a reference. And now we should be sure when the destroy method

514
00:32:47,178 --> 00:32:51,198
is called that our event listener is

515
00:32:51,364 --> 00:32:54,894
removed and the leaks is gone. So let's make

516
00:32:54,932 --> 00:32:58,494
sure that we also call the destroy method. So here

517
00:32:58,532 --> 00:33:02,734
we have the destroy list function which is called whenever

518
00:33:02,782 --> 00:33:06,386
we click the toggle button again. So what we want to do is we

519
00:33:06,408 --> 00:33:10,610
have the item here already and we want to call the destroy method.

520
00:33:12,410 --> 00:33:16,280
So let's save this real quick,

521
00:33:16,970 --> 00:33:21,558
open it up in a new browser tab and

522
00:33:21,644 --> 00:33:25,034
quickly confirm that the change changes here. So this

523
00:33:25,072 --> 00:33:28,294
one looks good. And now we want to confirm

524
00:33:28,342 --> 00:33:32,300
also via the performance monitor. So we open it up,

525
00:33:33,950 --> 00:33:37,914
we see still memory consumption, but there you go, you could see

526
00:33:38,032 --> 00:33:41,422
the memory got released after a couple of clicks because

527
00:33:41,476 --> 00:33:45,566
the browser decided to. So now you see not a stair like

528
00:33:45,748 --> 00:33:48,998
pattern which goes on forever and forever and forever,

529
00:33:49,194 --> 00:33:52,770
but instead it will keep only

530
00:33:52,840 --> 00:33:56,622
something in memory, probably even for optimization purposes.

531
00:33:56,766 --> 00:33:59,838
But when I now click the garbage collection here manually,

532
00:33:59,934 --> 00:34:03,026
then we see the heap size is back there where it should be on the

533
00:34:03,048 --> 00:34:06,210
very low level of seven megabytes.

534
00:34:06,790 --> 00:34:10,994
Okay, I guess my time

535
00:34:11,112 --> 00:34:14,506
ends here. I thank you very much for your

536
00:34:14,528 --> 00:34:18,006
time. I hope you enjoyed listening to me and you learned

537
00:34:18,038 --> 00:34:21,434
something from this talk. If you have any questions about this

538
00:34:21,472 --> 00:34:25,142
talk, please ping me. My email is here and also my Twitter handle,

539
00:34:25,206 --> 00:34:27,850
so please reach out to me. Thank you.

