1
00:00:27,650 --> 00:00:31,266
Hello, my name is Tom and this is my talk getting back to sleep

2
00:00:31,298 --> 00:00:34,646
as soon as possible for the on call developer or how to win at on

3
00:00:34,668 --> 00:00:38,774
call. This is me, Tom Granot. I'm a developer advocate working for Lightrun and

4
00:00:38,812 --> 00:00:42,486
previously I was a site reliability engineer working for a company called Actix that

5
00:00:42,508 --> 00:00:45,682
does distributed systems in Munich, Germany.

6
00:00:45,746 --> 00:00:48,854
If you want to reach out to me, you can do so over Twitter or

7
00:00:48,892 --> 00:00:51,886
using my email, which is Tom granot, liverin.com.

8
00:00:52,068 --> 00:00:55,946
Let's go. I'd like to introduce you to Jamie. Jamie is a Java developer

9
00:00:55,978 --> 00:01:00,320
with about five years of experience working for the enterprise application company

10
00:01:00,850 --> 00:01:04,062
that produces Oasis. Very simple,

11
00:01:04,116 --> 00:01:07,038
run of the mill enterprise application. And specifically,

12
00:01:07,054 --> 00:01:10,818
Jamie works on the transaction system inside the application that is in

13
00:01:10,824 --> 00:01:14,610
charge of allowing users to purchase various things inside the application. Now,

14
00:01:14,680 --> 00:01:18,650
Oasis, being a system that is viewed by many corporations worldwide, is active

15
00:01:18,670 --> 00:01:22,306
24/7 there's always one developer on call. Tonight it's

16
00:01:22,338 --> 00:01:26,214
Jamie, and also there's a DevOps engineer and one or two support engineers that

17
00:01:26,252 --> 00:01:29,330
are there for more minor escalations. In addition,

18
00:01:29,410 --> 00:01:33,098
Olasis wide, there is a NOC team that is in charge of monitoring all

19
00:01:33,104 --> 00:01:36,922
the different systems. And I think before we actually set

20
00:01:36,976 --> 00:01:40,150
the scene and dive into exactly what happened in the current incident,

21
00:01:40,230 --> 00:01:43,930
it's worth noticing or explaining how the stack

22
00:01:44,010 --> 00:01:47,390
for the transaction system looks like. So it's a microservices based

23
00:01:47,540 --> 00:01:51,022
application. There are different services, a credit service, a fraud service,

24
00:01:51,076 --> 00:01:54,218
an external billing API, a gateway, and so forth, that are in charge

25
00:01:54,234 --> 00:01:57,714
of the proper operation of the application. And each service, or more

26
00:01:57,752 --> 00:02:01,186
correctly, each system inside the Oasis application has its

27
00:02:01,208 --> 00:02:04,430
own monitoring stack propped up by the DevOps engineers

28
00:02:04,510 --> 00:02:07,922
in order to separate the concern. Whether or not this was the right

29
00:02:07,976 --> 00:02:11,766
decision is something for the past. Jamie wasn't there when it was decided. It's just

30
00:02:11,788 --> 00:02:15,026
the current situation. But the monitoring stack is something Jamie knows

31
00:02:15,058 --> 00:02:18,546
and appreciates. The LK stack elasticsearch log Stack in Kibana

32
00:02:18,578 --> 00:02:22,266
and is a very comfortable way of understanding what's going on inside your application.

33
00:02:22,368 --> 00:02:25,674
Now, the problem with oncall is that, and Jamie has

34
00:02:25,712 --> 00:02:29,846
been doing it for a long while, so it's

35
00:02:29,878 --> 00:02:33,494
ingrained inside the brain that on call always brings

36
00:02:33,542 --> 00:02:37,134
new challenges. So it's either something completely new that you've never seen

37
00:02:37,172 --> 00:02:40,894
before, it might be something that you've seen before, or another team member has seen

38
00:02:40,932 --> 00:02:44,610
before, but nobody documented. It might be something that is completely

39
00:02:44,680 --> 00:02:48,562
outside of your scope, some external system failing, but there's always something.

40
00:02:48,696 --> 00:02:52,594
And to properly understand that, why so

41
00:02:52,632 --> 00:02:55,774
many things happen in production and in these on call sessions.

42
00:02:55,822 --> 00:02:59,554
It's important to understand the players, the people actually doing the work during these sessions.

43
00:02:59,602 --> 00:03:03,014
So the developers engineers are usually confined to the infrastructure. They know

44
00:03:03,052 --> 00:03:06,226
how the infrastructure works. They can mitigate any blocks

45
00:03:06,258 --> 00:03:10,094
or timeouts or problems in the infrastructure level. And the support engineers

46
00:03:10,162 --> 00:03:13,734
are more playbook followers. They see a set of circumstances

47
00:03:13,782 --> 00:03:17,526
happening, and they know how to operate twist knobs, turn switches,

48
00:03:17,558 --> 00:03:21,914
and off and on and off. And not to solve various problems, but just

49
00:03:22,032 --> 00:03:25,354
being immersed in the environment, just understanding it

50
00:03:25,392 --> 00:03:29,006
completely, just being part of it, is very hard due to the noise in

51
00:03:29,028 --> 00:03:31,902
the system. There are so many things going on at any given point in time.

52
00:03:31,956 --> 00:03:35,474
There are logs coming in and support tickets and phone numbers, and customers

53
00:03:35,592 --> 00:03:38,862
polling you messaging, sorry, on slack,

54
00:03:38,926 --> 00:03:42,530
other teammates messaging on slack. It's basically lots of noise all around.

55
00:03:42,600 --> 00:03:46,082
And whenever there's a problem that's remotely complex that none of the above people

56
00:03:46,136 --> 00:03:48,918
can solve, developers are called, in this case,

57
00:03:49,004 --> 00:03:52,470
Jamie. And in our specific case tonight, a wild problem

58
00:03:52,540 --> 00:03:55,814
has appeared. Some transaction is failing. The support engineers are looking

59
00:03:55,852 --> 00:03:59,142
and they're trying to operate a situation, trying to kind of progress with it,

60
00:03:59,196 --> 00:04:03,018
and they're not making headway. They get stuck. The playbooks are not working.

61
00:04:03,104 --> 00:04:06,566
It's really hard to understand what's going on. And so they turn to the DevOps

62
00:04:06,598 --> 00:04:10,646
team to see whether it's maybe an infrastructure problem, something not in the application logic,

63
00:04:10,678 --> 00:04:14,414
but something actually inside the infrastructure itself. And the DevOps team

64
00:04:14,452 --> 00:04:18,302
look at the monitoring systems, and nothing is apparent. So, as I mentioned before,

65
00:04:18,356 --> 00:04:22,078
when something like this happened, some remotely complex application logic problem,

66
00:04:22,164 --> 00:04:25,730
you call the developers, in this case JB. It's really important

67
00:04:25,800 --> 00:04:29,666
to understand what it is that a system tells you

68
00:04:29,688 --> 00:04:33,266
about itself during production. The absolute best situation

69
00:04:33,448 --> 00:04:36,734
with a running system is a situation of observability. It's a password.

70
00:04:36,782 --> 00:04:40,102
It's been thrown around many different times lately. The bottom line is that

71
00:04:40,156 --> 00:04:43,814
it can be defined as the ability to understand how your systems work

72
00:04:43,852 --> 00:04:47,366
on the inside without chipping new code and without chipping new code. Bit is

73
00:04:47,388 --> 00:04:50,806
the core part here. It's how we differentiate a system that is

74
00:04:50,828 --> 00:04:54,774
just monitored and a system that is fully observable, instead of relying

75
00:04:54,822 --> 00:04:58,378
on adding adfixes and adding more and more instrumentations and logs to

76
00:04:58,384 --> 00:05:02,298
the running application in order to understand what's going on. Instead, the system,

77
00:05:02,384 --> 00:05:05,758
in the way it was originally instrumented, tells you all the story

78
00:05:05,844 --> 00:05:09,054
and tells you what is wrong with it by allowing you to explore in real

79
00:05:09,092 --> 00:05:13,162
time what is going on. And I think it's also important to differentiate

80
00:05:13,226 --> 00:05:16,866
what a monitoring and observability stack gives you. The current tooling and

81
00:05:16,888 --> 00:05:20,114
things that we have inside our oncall situation give you and what

82
00:05:20,152 --> 00:05:23,714
they don't. To be completely honest, many monitoring stacks today

83
00:05:23,752 --> 00:05:26,178
are really good. They tell you a lot of the information.

84
00:05:26,264 --> 00:05:29,378
It's easy to understand many of the problems that it used to

85
00:05:29,384 --> 00:05:33,078
be really hard to understand. And the first primitive, if you will, in this situation

86
00:05:33,164 --> 00:05:36,646
is the log line. So, logs that are being emitted out of the application in

87
00:05:36,668 --> 00:05:40,022
real time are the things that tell you what is happening at any given

88
00:05:40,076 --> 00:05:43,466
time in the application. It's a timestamped event log of what is

89
00:05:43,488 --> 00:05:47,002
going on inside the application. But this is only on the application level. The application

90
00:05:47,056 --> 00:05:50,166
is not running in a void. It's running on a piece of machine, or multiple

91
00:05:50,198 --> 00:05:54,254
machines that have their own health situation. The amount of cpu they

92
00:05:54,292 --> 00:05:57,754
use, the amount of memory they consume and so forth. And if the machine beneath

93
00:05:57,802 --> 00:06:01,774
the application is not feeling okay, it's overloaded, then the application will

94
00:06:01,812 --> 00:06:05,438
show. But if we go even one step further, these are two

95
00:06:05,524 --> 00:06:08,930
kind of pieces of information that are bit further apart from one another.

96
00:06:09,000 --> 00:06:12,386
So the log tell you this timestamped event log of the application. And the

97
00:06:12,408 --> 00:06:15,586
itmetrics tells you how the machines beneath field. But in

98
00:06:15,608 --> 00:06:19,286
order to understand how the actual service, which is a piece of software that is

99
00:06:19,308 --> 00:06:22,838
intended to bring value to the customer, how it looks like from the customer

100
00:06:22,924 --> 00:06:26,514
perspective, there's also another set of metrics, service metrics,

101
00:06:26,562 --> 00:06:30,002
business level metrics, SLA metrics, depends on the organization.

102
00:06:30,066 --> 00:06:33,174
They're called differently in different places. And these metrics relate

103
00:06:33,222 --> 00:06:36,646
more to the purported value the system gives to the users.

104
00:06:36,678 --> 00:06:40,390
And this could be things as how good of information the system is emitting,

105
00:06:40,470 --> 00:06:43,834
how much time it takes it to emit this information, how many outages

106
00:06:43,882 --> 00:06:47,742
there are and so forth. This is the value as it is perceived by

107
00:06:47,796 --> 00:06:51,902
the customer from the software. But this is not granular enough

108
00:06:51,956 --> 00:06:55,054
information. Sometimes you want to understand what's going

109
00:06:55,092 --> 00:06:58,478
on after you call a specific endpoint. And distributed tracers.

110
00:06:58,494 --> 00:07:01,746
These are the tracers I'm talking about here. Stuff like zipkin Yeager. There are

111
00:07:01,768 --> 00:07:05,362
many of those tools. They allow you to inspect an endpoint and say,

112
00:07:05,416 --> 00:07:09,094
all right, this endpoint takes x time to respond and it

113
00:07:09,132 --> 00:07:12,614
calls three downstream API endpoints, each of them taking another

114
00:07:12,732 --> 00:07:16,406
third x of time to respond. And this allows you to more

115
00:07:16,508 --> 00:07:19,626
kind of surgically go inside and better understand how

116
00:07:19,648 --> 00:07:23,786
can API endpoint performs like in real life. But even that is

117
00:07:23,888 --> 00:07:27,770
not always enough. And sometimes when the application itself

118
00:07:27,920 --> 00:07:32,086
is constructed above, a virtual machine like Java is over the JVM

119
00:07:32,118 --> 00:07:35,982
you have a set of tools called profilers. And it's not only limited to

120
00:07:36,116 --> 00:07:39,758
tools running over virtual machines. There are many different

121
00:07:39,844 --> 00:07:43,578
type of tools that are called profilers that work at different levels of the stack.

122
00:07:43,674 --> 00:07:47,422
What I'm referring to is stuff like J profiler, things that profile

123
00:07:47,566 --> 00:07:51,074
the JVM and tell you how another layer of obstruction in the middle

124
00:07:51,112 --> 00:07:54,738
is failing. So not the machines running beneath, not the application

125
00:07:54,824 --> 00:07:57,906
running above, but the JVM in the middle. And speaking of

126
00:07:57,928 --> 00:08:01,490
tools that we don't often see in production profiles have incurred a lot of overhead.

127
00:08:01,570 --> 00:08:04,786
Debuggers are also another set of tooling that allow you to explore random

128
00:08:04,818 --> 00:08:08,406
code path. Basically step in, step out of different flows and

129
00:08:08,428 --> 00:08:12,374
understand how a user behaves like in real life. And these debuggers

130
00:08:12,422 --> 00:08:15,926
are again, there are remote debuggers that can be used in production,

131
00:08:15,958 --> 00:08:19,722
but usually it's a tool used inside development to walk through

132
00:08:19,776 --> 00:08:23,434
different code paths. There's another subset of tooling called exception or error

133
00:08:23,482 --> 00:08:27,306
monitoring and handling tooling. And these tools enable you to enrich

134
00:08:27,338 --> 00:08:30,606
the information you receive once something bad happens. So an

135
00:08:30,628 --> 00:08:34,474
error has happened or can exception was thrown. And these tools

136
00:08:34,522 --> 00:08:38,418
enable you to get a better grasp when things go bad.

137
00:08:38,504 --> 00:08:41,986
So when things go out of all, not all exceptions are bad. But I think

138
00:08:42,008 --> 00:08:45,186
the more interesting part is talking about what our tools don't tell you. And the

139
00:08:45,208 --> 00:08:48,966
first and foremost thing that comes to mind is incorrect application state. This can come

140
00:08:48,988 --> 00:08:52,646
in so many forms, it can come as a request coming from the product that

141
00:08:52,668 --> 00:08:56,294
was incorrectly implemented, an incorrect request coming from product that

142
00:08:56,332 --> 00:09:00,386
was correctly implemented. Whatever set of circumstances

143
00:09:00,418 --> 00:09:03,778
that caused the application state to be incorrect, perhaps edge case that

144
00:09:03,804 --> 00:09:06,858
wasn't tested for. And again, there are many different ways this could happen.

145
00:09:06,944 --> 00:09:10,746
This ends up being a detriment on the user's experience.

146
00:09:10,848 --> 00:09:14,606
The user using the application doesn't really care what we did wrong.

147
00:09:14,708 --> 00:09:17,870
The only thing the user cares about is the application is not working

148
00:09:17,940 --> 00:09:21,354
and our tools will not pinpoint and say this is wrong. Logic.

149
00:09:21,402 --> 00:09:25,326
Logic is logic. It's difficult to account for unless you tell the system exactly what

150
00:09:25,348 --> 00:09:28,526
it is supposed to do. And this is something that even modern monitoring

151
00:09:28,558 --> 00:09:31,650
stacks don't really account for. Another thing that's hard to understand,

152
00:09:31,720 --> 00:09:35,154
but is more mechanical if you will, is quantitative data on the code

153
00:09:35,192 --> 00:09:38,994
level. So assume you're getting an OoM for some reason and there's a data structure

154
00:09:39,042 --> 00:09:42,486
exploding in memory and that data structure exploding in memory is the thing

155
00:09:42,508 --> 00:09:46,374
that's causing the OOM. This is not something you would usually be able

156
00:09:46,412 --> 00:09:49,922
to determine unless you've instrumented the metrics beforehand.

157
00:09:49,986 --> 00:09:53,786
So understanding the size, visualizing a graph of how the

158
00:09:53,808 --> 00:09:57,146
data structure behaves over time, unless you actively ask for

159
00:09:57,168 --> 00:10:00,890
it, it is not information that will always be readily or even at all

160
00:10:00,960 --> 00:10:04,762
available to you. Another thing that is more related to developer mistakes,

161
00:10:04,826 --> 00:10:08,734
or perhaps not mistakes, but just things you don't always

162
00:10:08,852 --> 00:10:12,606
catch during developers. I'll swallow the exception, a situation in which

163
00:10:12,628 --> 00:10:16,302
an exception was thrown and caught and nothing was actually emitted doing that.

164
00:10:16,356 --> 00:10:19,666
So some side effect that was supposed to happen did not

165
00:10:19,688 --> 00:10:23,074
happen because of the exception. Maybe some piece of information that was supposed

166
00:10:23,112 --> 00:10:26,194
to be emitted. Not even a side effect, but some piece of information was not

167
00:10:26,232 --> 00:10:29,666
emitted. And this, when looking at the application again, trying to

168
00:10:29,688 --> 00:10:32,950
observe it and understand what's going on inside of it, it will be very hard

169
00:10:33,020 --> 00:10:36,966
because there's a piece of the logic you're not seeing. It's literally swallowed by

170
00:10:36,988 --> 00:10:40,522
the application. This is not only about developer level things.

171
00:10:40,576 --> 00:10:44,150
There are some things where you use some external

172
00:10:44,230 --> 00:10:47,610
API, not all at your control, some external API completely

173
00:10:47,760 --> 00:10:51,578
abstracted away from you that behaves in weird ways. Maybe the format

174
00:10:51,674 --> 00:10:55,034
is not the format you expected, it does not conform to specification.

175
00:10:55,162 --> 00:10:59,150
It times out in ways you did not expect. The state

176
00:10:59,300 --> 00:11:02,798
after you made a request, changes on

177
00:11:02,804 --> 00:11:06,038
the next request, and so forth. So many moving pieces in production

178
00:11:06,074 --> 00:11:09,646
that you can always kind of ask questions, can always ask to dump

179
00:11:09,678 --> 00:11:13,326
the information, but that usually requires asking the question. Adding a logs

180
00:11:13,358 --> 00:11:16,622
to dump that piece of information into the logs.

181
00:11:16,686 --> 00:11:20,006
Sometimes this is actually not allowed, especially when PCI compliance or

182
00:11:20,028 --> 00:11:23,782
HIPAA is involved. And then you would need to not log

183
00:11:23,836 --> 00:11:27,382
the entire object because there will be private information there, but instead

184
00:11:27,436 --> 00:11:31,610
find a way around it. And there's also this more

185
00:11:31,760 --> 00:11:34,970
nuanced problem when the application state is

186
00:11:35,040 --> 00:11:38,682
correct, but the user took the incorrect flow in order to get

187
00:11:38,736 --> 00:11:42,138
where the user is currently at, and it's difficult to understand how to get the

188
00:11:42,144 --> 00:11:45,338
user out of that situation. This happens, for example, when requests

189
00:11:45,354 --> 00:11:49,406
are coming with will request parameters and the user is receiving not

190
00:11:49,508 --> 00:11:53,006
the experience of the application they expected to receive. This can

191
00:11:53,028 --> 00:11:56,718
be as simple as perhaps a menu not opening correctly,

192
00:11:56,814 --> 00:12:00,254
and can be as bad as what recently

193
00:12:00,302 --> 00:12:04,210
happened with GitHub when a user actually logged into the wrong

194
00:12:04,280 --> 00:12:07,646
session. So this is the best example of unexpected user flow.

195
00:12:07,758 --> 00:12:11,782
The other piece of the puzzle, I guess, which is things that are

196
00:12:11,836 --> 00:12:15,494
hard to reproduce and only happen in specific conditions, not for

197
00:12:15,532 --> 00:12:18,722
specific users, but just under a specific set of conditions, are races.

198
00:12:18,786 --> 00:12:22,662
So those are shared resources, and the order in which two parties

199
00:12:22,726 --> 00:12:26,394
reach to it matters. It shouldn't, because it should be everybody gets

200
00:12:26,432 --> 00:12:29,622
the same treatment, or everybody gets the correct flow of operations.

201
00:12:29,686 --> 00:12:33,254
But sometimes races do occur, and when they happen, they're hard to reproduce.

202
00:12:33,302 --> 00:12:36,590
You have to wait for the exact set of circumstances for them to happen.

203
00:12:36,660 --> 00:12:40,190
And even then, most monitoring tools will not tell you why the race happened,

204
00:12:40,260 --> 00:12:44,314
or even which set of circumstances, the full set of circumstances

205
00:12:44,362 --> 00:12:47,874
that is needed to reproduce the race. And therefore, many races end up

206
00:12:47,912 --> 00:12:51,922
being left in bugs for time and time over, until basically,

207
00:12:51,976 --> 00:12:55,634
we'll see that bug the next time it appears. And one important thing

208
00:12:55,672 --> 00:12:58,846
to mention about these types of problems is what happens

209
00:12:58,888 --> 00:13:02,582
when you move away from developing locally and you're moving to deploying your applications into

210
00:13:02,636 --> 00:13:07,026
production, when there are a lot of replicas of your application, and perhaps

211
00:13:07,058 --> 00:13:10,418
if you're a monolith, there are specific parts of the application

212
00:13:10,524 --> 00:13:14,406
that get more load than other parts, and they affect the former parts

213
00:13:14,438 --> 00:13:18,666
in the application. There are all this consideration when we're working with either

214
00:13:18,768 --> 00:13:22,666
a large load on specific pieces of the application. Perhaps things you

215
00:13:22,688 --> 00:13:26,670
didn't actually work on that belong to somebody else, but you steal resources from them.

216
00:13:26,740 --> 00:13:30,634
Or when you take the same application and run it across multiple

217
00:13:30,682 --> 00:13:34,654
instances in order to better understand, or perhaps

218
00:13:34,702 --> 00:13:38,370
not better understand or provide a better service by

219
00:13:38,440 --> 00:13:42,002
allowing for multiple instances of the same piece of code,

220
00:13:42,136 --> 00:13:45,730
weird things can happen in the in betweens. And I just

221
00:13:45,800 --> 00:13:49,438
want to show you a demo to better explain exactly what I'm talking

222
00:13:49,464 --> 00:13:53,014
about, show you what these type of problems looks like in the wild. But before

223
00:13:53,052 --> 00:13:56,166
that, it's important to understand the context that drove us

224
00:13:56,188 --> 00:13:59,446
here. Basically what we know. And the support engineers received the

225
00:13:59,468 --> 00:14:02,826
ticket, which means they know the specific customer that's acting up, and they

226
00:14:02,848 --> 00:14:06,138
even know the specific id for that user. It's 2911.

227
00:14:06,224 --> 00:14:09,318
And the DevOps team also knows

228
00:14:09,414 --> 00:14:12,798
that the monitoring system is not showing any problems.

229
00:14:12,884 --> 00:14:16,366
The metrics look okay, and I just want to remind you

230
00:14:16,388 --> 00:14:19,882
that there are about six services inside the current OS

231
00:14:19,946 --> 00:14:23,402
transaction system, and there's a monitoring stack based on Elk.

232
00:14:23,466 --> 00:14:26,706
Let's assume that Jamie is being called into the situation, and all he

233
00:14:26,728 --> 00:14:30,334
knows is that the metrics look okay, and there's a specific user id that's acting

234
00:14:30,382 --> 00:14:33,614
up. This is the Kibana dashboard, or the Kibana entry

235
00:14:33,662 --> 00:14:37,054
screen. And that Kibana board is used heavily

236
00:14:37,102 --> 00:14:40,214
by the DevOps team, and perhaps even the support engineers, in order

237
00:14:40,252 --> 00:14:43,798
to understand what's going on. But from Jamie's perspective, if the

238
00:14:43,804 --> 00:14:47,046
metrics are okay, and the support engineers said that

239
00:14:47,068 --> 00:14:51,142
the usual things don't work, then the first thing, or the second thing, perhaps that

240
00:14:51,196 --> 00:14:54,714
Jamie will do, will go into the log trail. So you go into the log

241
00:14:54,752 --> 00:14:58,106
trail and you look for the log lines for the specific user to

242
00:14:58,128 --> 00:15:01,322
see in your own eyes what is happening with it. And I'm going to pass

243
00:15:01,376 --> 00:15:05,166
that number here. And we can see that the log are actually very clear.

244
00:15:05,268 --> 00:15:09,598
It looks like there's a step by step, service by service

245
00:15:09,684 --> 00:15:13,586
oncall into each following the length of the transaction. So I

246
00:15:13,608 --> 00:15:17,790
can see that the inventory resource inside the inventory

247
00:15:17,950 --> 00:15:21,780
service started to validate the transaction. Looks like

248
00:15:22,950 --> 00:15:26,802
the same service, sorry, also tries to process the purchase.

249
00:15:26,946 --> 00:15:30,262
Then there's a sequence of calls to transaction service,

250
00:15:30,316 --> 00:15:33,878
then credit service, then fraud service, then external billing service,

251
00:15:34,044 --> 00:15:38,342
culminating in the kind of back propagation of everything else back

252
00:15:38,396 --> 00:15:41,606
down the line. So because you're

253
00:15:41,638 --> 00:15:45,494
looking at the logs and they're not telling you the full story, it doesn't

254
00:15:45,542 --> 00:15:49,014
look like something in the transaction is wrong. It looks like the transaction

255
00:15:49,142 --> 00:15:51,550
finished processing correctly.

256
00:15:52,210 --> 00:15:56,110
We're basically stuck. There is no extra

257
00:15:56,180 --> 00:15:59,566
path to go here. There is no more information

258
00:15:59,668 --> 00:16:03,326
the application tells me about itself out of the box that hasn't been

259
00:16:03,348 --> 00:16:06,818
checked by me or by other members of my team that explain

260
00:16:06,904 --> 00:16:10,046
exactly what's going on. And it really depends.

261
00:16:10,078 --> 00:16:13,554
The playbooks differ here from oncall team. From oncall team. There are some people that

262
00:16:13,592 --> 00:16:17,030
have specific tooling that are used to solve these type of problems,

263
00:16:17,100 --> 00:16:21,062
basically get more information. Some people throw the same environment over

264
00:16:21,116 --> 00:16:25,106
staging. Some people have a ready made database with shadow

265
00:16:25,138 --> 00:16:28,806
traffic or shadow data that enables them to test things in a kind

266
00:16:28,828 --> 00:16:32,842
of more safe environment. Some people just connect the remote debugger and walk

267
00:16:32,896 --> 00:16:37,254
through the flow piece by piece using that specific user,

268
00:16:37,302 --> 00:16:41,102
because that specific context of the user because it's allowed. It really

269
00:16:41,156 --> 00:16:45,246
depends on the exact situation that you have. And I

270
00:16:45,268 --> 00:16:48,590
just want to mention and kind of focus

271
00:16:48,660 --> 00:16:51,694
on this feeling of helplessness, if you will. Right.

272
00:16:51,812 --> 00:16:55,098
It's not clear what's going on, and it's really annoying.

273
00:16:55,194 --> 00:16:58,306
It's not something you accounted for. Something is happening,

274
00:16:58,408 --> 00:17:02,606
and the application is not telling you what it is. But Jamie

275
00:17:02,638 --> 00:17:05,730
is a cool headed, very down to earth person,

276
00:17:05,880 --> 00:17:09,286
and the code itself is the next place to

277
00:17:09,308 --> 00:17:12,326
go. So the next thing is indeed to go into the code, and I'm going

278
00:17:12,348 --> 00:17:17,218
to open my intellij that is simulating Jamie's

279
00:17:17,234 --> 00:17:20,566
intellij. And I'm going to start walking through the code in order to

280
00:17:20,588 --> 00:17:23,722
understand what exactly is going on. And the first thing

281
00:17:23,776 --> 00:17:26,902
is looking for the inventory resource, which is the thing that starts

282
00:17:26,966 --> 00:17:30,618
all the things. I'm going to look for inventory resource, and you

283
00:17:30,624 --> 00:17:33,854
can see there's a controller here and as expected, it's making

284
00:17:33,892 --> 00:17:37,386
a call to another microservice. This case using the fame

285
00:17:37,418 --> 00:17:40,926
client and looking in, it looks like it is indeed calling to

286
00:17:40,948 --> 00:17:44,930
the transaction service. Now I'm going to look for the same resource inside

287
00:17:45,000 --> 00:17:48,750
a transaction service. So I'm going to go for transaction

288
00:17:48,830 --> 00:17:52,286
resource. And again, unsupprised immediate

289
00:17:52,318 --> 00:17:56,130
transaction resource is calling another client, which is calling the credit service.

290
00:17:56,280 --> 00:17:59,666
Now at this point, Jamie is experienced and knowing

291
00:17:59,698 --> 00:18:02,280
that these services kind of go after the other,

292
00:18:03,050 --> 00:18:06,262
Jamie decides to go all the way to the end, to the final

293
00:18:06,316 --> 00:18:10,558
service that is actually doing the work, which in this case looks like the external

294
00:18:10,594 --> 00:18:14,650
billing service. And there's an external billing resource here. And let's see whether

295
00:18:14,720 --> 00:18:18,186
the problem is at the actual end. So basically the end

296
00:18:18,208 --> 00:18:22,906
of the road, as they say. And when

297
00:18:22,928 --> 00:18:27,134
Jim is looking at the controller, so it does

298
00:18:27,172 --> 00:18:30,506
appear as if the transaction is finished correctly. It doesn't

299
00:18:30,538 --> 00:18:34,510
look like there's some sort of problems here. So Jamie has a choice.

300
00:18:35,330 --> 00:18:38,786
It's possible to go back to the last service we

301
00:18:38,808 --> 00:18:41,698
looked at, which is the credit service, so we can go back from the end.

302
00:18:41,784 --> 00:18:45,518
Again. It's a matter of decision in really long chains.

303
00:18:45,614 --> 00:18:49,206
It might make sense to go a bit in the beginning and then a bit

304
00:18:49,228 --> 00:18:52,198
at the end and backwards, which is what Jamie decides to do.

305
00:18:52,284 --> 00:18:56,146
The service before external billing service is fraud resource,

306
00:18:56,258 --> 00:18:59,814
let's look for fraud resource and immediately

307
00:18:59,862 --> 00:19:02,906
the problem becomes apparent. There is a check for

308
00:19:02,928 --> 00:19:06,054
fraud method here that throws an exception.

309
00:19:06,182 --> 00:19:10,154
And to those familiar with eclipse, this is intellij. This is what happened when

310
00:19:10,192 --> 00:19:13,958
you author generate a catch block in eclipse there is

311
00:19:13,984 --> 00:19:17,194
a try and a catch and you're expected to fill the catch and the developer

312
00:19:17,242 --> 00:19:20,494
did not fill the catch. What would probably happen here,

313
00:19:20,532 --> 00:19:24,446
I assume is the developers might, after checking for

314
00:19:24,468 --> 00:19:28,146
fraud and throwing the exception, propagate some error downstream. A lot

315
00:19:28,168 --> 00:19:31,314
of ways to handle it, but the bottom line is an exception was thrown and

316
00:19:31,352 --> 00:19:34,802
caught and we were none the wiser. And I think this is

317
00:19:34,856 --> 00:19:38,918
basically a good time to stop the demo and go back

318
00:19:39,004 --> 00:19:42,406
into the problem at hand, which is how to

319
00:19:42,428 --> 00:19:46,006
make a system observable. We talked about the fact that observability can be defined as

320
00:19:46,028 --> 00:19:49,890
the ability to understand how the systems work without shipping new code and

321
00:19:49,900 --> 00:19:53,082
in this specific situation, you see the frustration. It would be really

322
00:19:53,136 --> 00:19:56,794
hard to understand what's going on without shipping new code

323
00:19:56,912 --> 00:20:01,114
to investigate. This was a very short, very simple application

324
00:20:01,232 --> 00:20:04,814
and it took me, or rather Jamie in this situation.

325
00:20:05,012 --> 00:20:08,606
It took him precious minutes of a customer complaining about the

326
00:20:08,628 --> 00:20:11,966
application to investigate. And this again is a small application,

327
00:20:12,068 --> 00:20:15,810
a small use case. This happens way more often

328
00:20:15,960 --> 00:20:19,586
in larger system with many different developers working on the system and

329
00:20:19,608 --> 00:20:23,726
the system being very complex. So perhaps there is possibility

330
00:20:23,838 --> 00:20:27,074
to talk again about how we might be

331
00:20:27,112 --> 00:20:30,646
able to account for all these things. Our tools don't tell you. How can

332
00:20:30,668 --> 00:20:33,814
we make sure that during an on call situation we would be

333
00:20:33,852 --> 00:20:37,094
able to ask more questions and get more

334
00:20:37,132 --> 00:20:40,326
answer without resorting to diving through the code in

335
00:20:40,348 --> 00:20:44,486
order to understand exactly what is going on, but by getting real production

336
00:20:44,518 --> 00:20:48,106
information and understanding what we can do with it. And I think

337
00:20:48,128 --> 00:20:51,926
the best way to define this new practice is continuous observability,

338
00:20:52,038 --> 00:20:55,662
which is this streamlined process we can have for asking new questions

339
00:20:55,716 --> 00:20:58,814
and getting immediate answers. And there are

340
00:20:59,012 --> 00:21:02,734
a few tools in many different areas that can help you depending on

341
00:21:02,772 --> 00:21:05,486
how deep in the stack you want to go, from which perspective you want to

342
00:21:05,508 --> 00:21:09,054
observe. I work for Lightrun. We build a continuous observability toolbox.

343
00:21:09,102 --> 00:21:12,786
You're more than welcome to look inside of it, but the

344
00:21:12,808 --> 00:21:16,370
core of the issue here is that you should have some way of

345
00:21:16,440 --> 00:21:20,222
exploring these situations in real time. And up until then,

346
00:21:20,296 --> 00:21:23,286
I do have a few suggestions for you on how you can win in these

347
00:21:23,308 --> 00:21:27,282
situations and make the experience not suck as much as it did for Jamie.

348
00:21:27,346 --> 00:21:30,918
Basically looking at the information or looking at the application

349
00:21:31,004 --> 00:21:34,586
and being very frustrated that they have to dive into the code back

350
00:21:34,608 --> 00:21:37,834
again to understand what's going on. And the first thing is you got to choose

351
00:21:37,872 --> 00:21:41,562
to love it. It's rough and on call is not fun for anyone, but being

352
00:21:41,616 --> 00:21:45,146
angry and self absorbed and being totally annoyed with

353
00:21:45,168 --> 00:21:48,286
all situation is not going to help. Step out of your shoes for a second.

354
00:21:48,388 --> 00:21:51,982
Remember that everybody's oncall, including the Dells engineer in front of you and the support

355
00:21:52,036 --> 00:21:55,214
engineer on the other end, and be a part of the team work together.

356
00:21:55,332 --> 00:21:59,326
But having said that, as a developer, you have the obligation to be as prepared

357
00:21:59,358 --> 00:22:02,302
as possible. You know how the application is supposed to behave,

358
00:22:02,366 --> 00:22:06,062
so you should be able to answer their questions much faster

359
00:22:06,126 --> 00:22:09,894
instead of trying to kind of rummage through your things to get

360
00:22:09,932 --> 00:22:13,554
any answer. The DevOps team lives inside the monitoring systems

361
00:22:13,602 --> 00:22:17,206
they know, and the NOC team they know the tooling very well, in and

362
00:22:17,228 --> 00:22:21,190
out and they can answer your questions. So you should be prepared the same.

363
00:22:21,260 --> 00:22:24,954
And I think what really helps with preparing is documenting. So you see

364
00:22:24,992 --> 00:22:28,326
something in an oncall session and you think it's a singular location

365
00:22:28,358 --> 00:22:31,270
and you will never see it again. You are incorrect.

366
00:22:31,350 --> 00:22:34,342
Sit down. Document it for your future self,

367
00:22:34,416 --> 00:22:37,918
right, for three, four, six months down the road when it's going to

368
00:22:37,924 --> 00:22:41,630
come again and you're going to regret you haven't written it down. Write everything

369
00:22:41,700 --> 00:22:45,534
up, make sure it's prepared and come with it in searchable or an indexable

370
00:22:45,582 --> 00:22:49,378
form for your next session. And speaking of

371
00:22:49,464 --> 00:22:53,586
another set of tooling, I mentioned them before. A lot of teams have these more,

372
00:22:53,688 --> 00:22:57,582
let's call them case specific tooling that are used for debugging.

373
00:22:57,646 --> 00:23:01,318
Specific thing, emergency debugging tools that are used for debugging specific

374
00:23:01,404 --> 00:23:04,966
problems that tend to happen in their own systems. It can take

375
00:23:04,988 --> 00:23:08,738
the form of tooling built internally, it can take the form of shell scripts,

376
00:23:08,754 --> 00:23:12,018
it can take many different forms. And it's on you to make sure that you

377
00:23:12,044 --> 00:23:15,718
have them available. Having them enables you to solve the problems much quicker.

378
00:23:15,814 --> 00:23:19,514
And you wouldn't know that you need these tools, or you would be able to

379
00:23:19,552 --> 00:23:23,194
have these tools and help you if you wouldn't write proper postmortems. And that's not

380
00:23:23,232 --> 00:23:27,360
just documenting the steps that you took, that's documenting why the situation

381
00:23:27,730 --> 00:23:31,374
has occurred, what step you took to solve it, and what steps are

382
00:23:31,412 --> 00:23:34,766
needed in order to make it never happen again. There's a full process here,

383
00:23:34,788 --> 00:23:38,610
and a good postmortem is composed of information from all the different

384
00:23:38,680 --> 00:23:41,998
teams. What is missing in the player books for the support engineers, what is missing

385
00:23:42,014 --> 00:23:45,490
in the dashboards of the developers team? What tools? What would the developer have

386
00:23:45,560 --> 00:23:49,430
that would make it easier for them to solve the problem? And having

387
00:23:49,500 --> 00:23:52,962
said that, there's also this kind of humility

388
00:23:53,026 --> 00:23:56,678
that developers should take here, because if you're running a

389
00:23:56,684 --> 00:24:00,646
large enough system, there are people dedicated to just keeping it healthy. So if there's

390
00:24:00,678 --> 00:24:04,602
something that relates to the underlying infrastructure, ask questions.

391
00:24:04,736 --> 00:24:07,930
Go ahead, be part of a team and know that you

392
00:24:08,000 --> 00:24:11,946
don't have to know anything. It's perfectly fine to not know all the things and

393
00:24:12,048 --> 00:24:16,174
first ask questions and also be

394
00:24:16,212 --> 00:24:19,566
blunt about things that are just not under your control. If it's obvious to

395
00:24:19,588 --> 00:24:23,066
the application is behaving, but it's missing some resource, talk to the DevOps

396
00:24:23,098 --> 00:24:26,142
team. Explain to them that this resource is missing. This is why,

397
00:24:26,196 --> 00:24:29,566
please help me. I think this is pretty much it for this talk.

398
00:24:29,668 --> 00:24:33,326
I'm really happy you guys joined me. Feel free again to reach out

399
00:24:33,348 --> 00:24:37,078
to me over Twitter over GitHub. You can open an issue in one of

400
00:24:37,084 --> 00:24:40,806
my repos, but that's not a desirable method of

401
00:24:40,828 --> 00:24:44,386
communication. It's much better if you use Twitter or my email tongue

402
00:24:44,418 --> 00:24:48,102
at Lightrun. Please make sure to check out Lightrun. If you find

403
00:24:48,156 --> 00:24:52,086
this talk interesting. I think you would be pleasantly intrigued by

404
00:24:52,108 --> 00:24:54,660
everything we have to offer and see you again soon.

