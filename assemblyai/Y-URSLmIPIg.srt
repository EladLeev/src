1
00:00:25,490 --> 00:00:29,206
Hi everybody, my name is Jesus Espino. I'm software engineer at

2
00:00:29,228 --> 00:00:33,410
Maramos and I'm going to talk about struggle embedding, instrumentation and code generation.

3
00:00:33,570 --> 00:00:37,078
Well, what is Maramos? Maramos is a communication platform.

4
00:00:37,244 --> 00:00:39,846
We write in the backend in go,

5
00:00:40,028 --> 00:00:44,054
we write in the front end in typescript and react. And we are focused on

6
00:00:44,092 --> 00:00:47,586
security and performance. We are an open source

7
00:00:47,618 --> 00:00:51,054
project and with an open code model we

8
00:00:51,092 --> 00:00:54,800
have a self hosted version and we provide

9
00:00:55,410 --> 00:00:59,280
features to deploy on the cloud like

10
00:01:00,130 --> 00:01:03,550
Kubernetes operators and things like that. And of course we

11
00:01:03,620 --> 00:01:07,294
have our own SaaS service. Well what are the main pieces

12
00:01:07,342 --> 00:01:11,358
and why I'm talking to you about Maramos?

13
00:01:11,454 --> 00:01:14,914
I'm going to talk about maramos because I'm going to explain something that we did

14
00:01:14,952 --> 00:01:18,614
here in Maramos. This is the Maramos architecture. We have the

15
00:01:18,652 --> 00:01:21,926
client that is a react typescript application that

16
00:01:21,948 --> 00:01:25,346
calls to the API and the websockets API. The API

17
00:01:25,378 --> 00:01:29,714
and the Websockets API call the app layer. That is where our business logic

18
00:01:29,762 --> 00:01:33,354
live. Our app layer is going to leverage a set

19
00:01:33,392 --> 00:01:36,938
of services to provide the final functionality. And one of

20
00:01:36,944 --> 00:01:40,614
these services, for example, is the file service that allows us to store files

21
00:01:40,662 --> 00:01:44,750
in s three or in the local file system, or the email service

22
00:01:44,820 --> 00:01:48,254
that allow us to send email notification and all that

23
00:01:48,292 --> 00:01:52,320
stuff. The important piece here is the store. The store service

24
00:01:53,010 --> 00:01:56,894
is can abstraction that allows us to provide

25
00:01:57,012 --> 00:02:00,238
all the storage mechanism related to database access,

26
00:02:00,324 --> 00:02:03,950
database storage, database queries, all that stuff

27
00:02:04,020 --> 00:02:07,874
is inside the store. And the app layer doesn't know anything about SQL,

28
00:02:07,922 --> 00:02:11,570
doesn't know anything about how the data is actually stored.

29
00:02:11,650 --> 00:02:15,126
The app layer only knows that the store is going to take

30
00:02:15,148 --> 00:02:18,650
care of the entities and store them and is going to return

31
00:02:18,720 --> 00:02:22,106
me then whenever I have to use them.

32
00:02:22,208 --> 00:02:26,042
Well, what does our store look like? Our store

33
00:02:26,176 --> 00:02:29,674
is interface. It's a huge interface that have

34
00:02:29,712 --> 00:02:33,502
a lot of superstores. Each superstore have a single

35
00:02:33,556 --> 00:02:37,342
responsibility over a certain part of the data. For example,

36
00:02:37,396 --> 00:02:40,686
the Tigna store is going to take care about the

37
00:02:40,708 --> 00:02:44,074
team model and how it's storing the database,

38
00:02:44,122 --> 00:02:47,854
how we query the teams, all that stuff. Then we have the user

39
00:02:47,902 --> 00:02:51,794
store that does the same for the users, the bot store for the bots and

40
00:02:51,832 --> 00:02:55,266
so on. This is how it looks like in the code. We have

41
00:02:55,288 --> 00:02:58,594
the store interface that have a set of methods that return,

42
00:02:58,712 --> 00:03:02,930
well, each superstore struct the superstore interface.

43
00:03:03,090 --> 00:03:06,834
In this case, the team Superstore interface is going to have a set of methods

44
00:03:06,882 --> 00:03:08,360
related to the team model.

45
00:03:09,790 --> 00:03:13,190
If we want to implement this interface, we have to implement

46
00:03:13,270 --> 00:03:16,730
each of these methods. So our SQL store,

47
00:03:16,880 --> 00:03:20,526
the implementation of the store that we have is going to implement each

48
00:03:20,548 --> 00:03:24,202
of this method accessing to the database using SQL.

49
00:03:24,266 --> 00:03:28,206
But we will able to build a completely different store using

50
00:03:28,308 --> 00:03:31,658
MongoDB or using any other database.

51
00:03:31,754 --> 00:03:34,914
What's the problem that we are trying to solve? We want to

52
00:03:34,952 --> 00:03:38,606
add caches to our system, to our store, but we don't

53
00:03:38,638 --> 00:03:42,418
want to share responsibilities in the same code.

54
00:03:42,504 --> 00:03:46,050
We want to have a very code generation of concerns

55
00:03:46,130 --> 00:03:50,390
and we decide that we want to build something that is

56
00:03:50,460 --> 00:03:54,790
completely separated. We don't want to see checking cache invalidation

57
00:03:55,930 --> 00:03:59,906
cache insertions in our SQL related

58
00:04:00,018 --> 00:04:03,274
code. So we want to have our SQL code that

59
00:04:03,312 --> 00:04:06,534
is going to generate the queries, it's going to query the database

60
00:04:06,582 --> 00:04:10,494
and then we want to have in another place the

61
00:04:10,532 --> 00:04:14,302
cache logic where you insert things

62
00:04:14,356 --> 00:04:18,106
in the cache, you retrieve things from the cache, you invalidate

63
00:04:18,138 --> 00:04:21,066
the cache, all that logic should be separated.

64
00:04:21,258 --> 00:04:25,054
Well, our initial approach is to use a well known

65
00:04:25,102 --> 00:04:28,770
pattern, that is the middleware pattern. We create

66
00:04:28,920 --> 00:04:32,242
a new set of interfaces and strikes to

67
00:04:32,296 --> 00:04:35,510
provide this pattern and well, the result

68
00:04:35,580 --> 00:04:39,302
wasn't easy to understand. This is how

69
00:04:39,356 --> 00:04:42,822
it looks like. We had the SQL store that

70
00:04:42,876 --> 00:04:46,406
implements the store interface that we already saw.

71
00:04:46,588 --> 00:04:50,722
The SQL store also have to implement this new layered

72
00:04:50,786 --> 00:04:54,234
store supplier. This layered store supplier is

73
00:04:54,272 --> 00:04:57,354
going to have this set chain next that is

74
00:04:57,392 --> 00:05:01,238
going to set the next element in the chain of this chain

75
00:05:01,254 --> 00:05:04,958
of middlewares and the next is going to provide the next

76
00:05:05,124 --> 00:05:09,406
middleware that is responsible for

77
00:05:09,428 --> 00:05:13,338
the rest of the logic. The cache layer is going to implement

78
00:05:13,434 --> 00:05:16,882
this layer, the store supplier only. And then we have this

79
00:05:16,936 --> 00:05:20,738
layer, the store that is another extract that is going to provide,

80
00:05:20,904 --> 00:05:24,974
well, it's going to have the database store database,

81
00:05:25,102 --> 00:05:28,878
the SQL layer, the SQL store, and it's going

82
00:05:28,904 --> 00:05:32,514
to have also the cache layer and any other layer

83
00:05:32,562 --> 00:05:36,086
that you want to add is going to go here and then we are going

84
00:05:36,108 --> 00:05:39,834
to have this set of superstore that are overriding or

85
00:05:39,872 --> 00:05:43,962
not that are going to be delegated to the layer of the store or

86
00:05:44,016 --> 00:05:48,214
are going to be delegated directly to the SQL store. This approach

87
00:05:48,342 --> 00:05:52,166
work well, but it's not easy to understand and it's

88
00:05:52,198 --> 00:05:55,726
not easy to think about or reason about. Well, this is

89
00:05:55,748 --> 00:05:59,598
the code, this is how it looks like in the code. I don't want to

90
00:05:59,604 --> 00:06:02,974
explain much that it's more or less the same that we

91
00:06:03,012 --> 00:06:06,434
saw in the previous slide. What went well

92
00:06:06,472 --> 00:06:10,018
and what didn't work, what went well is the

93
00:06:10,024 --> 00:06:13,458
middleware pattern. It's something that is well known, something that is

94
00:06:13,544 --> 00:06:17,346
kind of easy to think about it, because conceptually you already know

95
00:06:17,368 --> 00:06:21,318
the concept of middleware, you know how it's expected to

96
00:06:21,404 --> 00:06:25,298
work. So from the concept perspective,

97
00:06:25,394 --> 00:06:29,242
was really easy to understand. Also, we had the opportunity to provide extra

98
00:06:29,296 --> 00:06:32,618
information without affecting the layers beneath. So for example,

99
00:06:32,704 --> 00:06:36,534
we were able to add this hint to the cache layer,

100
00:06:36,662 --> 00:06:39,900
allowing to add certain extra information,

101
00:06:40,270 --> 00:06:43,914
certain context from the app layer,

102
00:06:44,042 --> 00:06:47,374
to decide if we want to cache something or not,

103
00:06:47,492 --> 00:06:51,182
or if we want to invalidate the cache or not. This is because

104
00:06:51,316 --> 00:06:55,134
from the app layer we have way more context and we

105
00:06:55,172 --> 00:06:58,914
have the big picture of what we want to do with the data from the

106
00:06:58,952 --> 00:07:02,482
store. We only know that we are adding a new team,

107
00:07:02,536 --> 00:07:05,810
we are removing a team, we are adding people to certain

108
00:07:05,880 --> 00:07:08,994
teams or something like that. But we don't have the big picture.

109
00:07:09,122 --> 00:07:12,422
We don't know why we are adding that and we don't know if

110
00:07:12,476 --> 00:07:16,246
we, right before that we added other thing and

111
00:07:16,348 --> 00:07:19,626
we don't need to cache anything or we don't need to

112
00:07:19,648 --> 00:07:23,834
invalidate the cache or whatever. So that was an interesting thing

113
00:07:23,872 --> 00:07:27,610
to have, but we weren't using it so well,

114
00:07:27,680 --> 00:07:30,886
was a great feature that we were taking advantage

115
00:07:30,918 --> 00:07:34,558
of that what didn't work well was a bit hard to understand

116
00:07:34,644 --> 00:07:38,446
and follow all the code there, and at the same time was a

117
00:07:38,468 --> 00:07:42,094
bit hard to add new caches because you have to

118
00:07:42,132 --> 00:07:45,646
modify different places. We have to modify the cache layer,

119
00:07:45,678 --> 00:07:49,422
we have to modify the SQL layer, and we have to modify other parts.

120
00:07:49,486 --> 00:07:53,490
Like the layer store was complicated to add things

121
00:07:53,560 --> 00:07:56,886
there and there was a lot

122
00:07:56,908 --> 00:08:00,438
of code in a lot of different places and was really

123
00:08:00,524 --> 00:08:04,006
error prone and wasn't the best approach in

124
00:08:04,028 --> 00:08:07,606
terms of maintenance. Well, our current approach, what we

125
00:08:07,628 --> 00:08:10,934
use for our current approach, stroke embedding, instead of creating

126
00:08:10,982 --> 00:08:14,554
all this middleware logic where you have all these

127
00:08:14,592 --> 00:08:18,694
layers and all that stuff, we take advantage of the stroke

128
00:08:18,742 --> 00:08:22,190
embedding feature of go to create

129
00:08:22,260 --> 00:08:26,218
these layers, just store. The concept

130
00:08:26,234 --> 00:08:30,286
of a store is going to be embedded in another

131
00:08:30,388 --> 00:08:33,886
store. So we can create a layer

132
00:08:33,918 --> 00:08:37,314
that embeds the store and automatically is going

133
00:08:37,352 --> 00:08:40,594
to be a store because it's embedding a store.

134
00:08:40,712 --> 00:08:44,654
So this feature is a great feature of the language.

135
00:08:44,782 --> 00:08:48,258
And you can build this kind of layers

136
00:08:48,354 --> 00:08:52,114
really easy. Well, we rely on the existing interface.

137
00:08:52,162 --> 00:08:55,714
We relay on this store interface. We remove the layer,

138
00:08:55,762 --> 00:08:59,622
the store, the layered suppliers, all that stuff is

139
00:08:59,676 --> 00:09:03,554
gone. And we relay only on the existing store interface.

140
00:09:03,682 --> 00:09:08,326
We created this cache store, local cache, store that embeds

141
00:09:08,438 --> 00:09:12,318
the other store, the SQL store in it, and we override the

142
00:09:12,324 --> 00:09:16,206
methods that we need and everything else is transparent. Well this

143
00:09:16,228 --> 00:09:19,834
is how it looks like way simpler, right? The SQL

144
00:09:19,882 --> 00:09:23,534
store is going to implement the store. We are going to write all

145
00:09:23,572 --> 00:09:26,858
the methods, we are going to write all the SQL code. We are going to

146
00:09:26,884 --> 00:09:30,130
write a lot of stuff for the SQL store that is going to be needed

147
00:09:30,200 --> 00:09:33,746
anyway. But for the cache layer, we are going to embed the

148
00:09:33,768 --> 00:09:36,902
store. So automatically the cache layer without any

149
00:09:36,956 --> 00:09:40,422
method in it is going to implement the store. We only

150
00:09:40,476 --> 00:09:45,106
need to override the places where the cache need to take some action.

151
00:09:45,218 --> 00:09:48,742
For example, whenever I add a new post

152
00:09:48,876 --> 00:09:52,714
I going to cache certain information. Or whenever I add

153
00:09:52,752 --> 00:09:55,610
a new user I'm going to cache certain information.

154
00:09:55,760 --> 00:09:58,954
Whenever I get some user I'm going to cache that information.

155
00:09:59,152 --> 00:10:02,850
Whenever I modify the user I have to validate

156
00:10:02,870 --> 00:10:06,414
that cache. So we only need to find that places where

157
00:10:06,452 --> 00:10:10,686
we need to modify and update our cache and

158
00:10:10,788 --> 00:10:14,206
override them. And that is what we do.

159
00:10:14,308 --> 00:10:17,990
We create this local cache store that embeds a storetore.

160
00:10:18,090 --> 00:10:22,226
Any store can be embedded, but let's think about it as the

161
00:10:22,248 --> 00:10:25,486
SQL store. So we have the local cache store and we embed

162
00:10:25,518 --> 00:10:29,074
the SQL store in it. Then we have a set of Superstore.

163
00:10:29,122 --> 00:10:33,506
That is the specific cache implementation of this superstore.

164
00:10:33,618 --> 00:10:36,914
In this case it's the team Superstore. We override

165
00:10:36,962 --> 00:10:41,066
the method that gets the team store in this case is going to return

166
00:10:41,168 --> 00:10:45,078
this own implementation of the team Superstore

167
00:10:45,254 --> 00:10:48,886
and how we implement this superstore.

168
00:10:48,998 --> 00:10:52,554
The Superstore is going to embed again this

169
00:10:52,672 --> 00:10:56,014
team store, any team store, but we're going to think about

170
00:10:56,052 --> 00:10:59,646
it as the SQL team store. Then we add

171
00:10:59,668 --> 00:11:02,974
the root store. That is a private attribute that we are going to

172
00:11:03,012 --> 00:11:06,222
use to share some data and share some methods.

173
00:11:06,286 --> 00:11:10,078
And it's going to be just the local cache store instance.

174
00:11:10,174 --> 00:11:13,758
Finally, we need to add methods to this superstore.

175
00:11:13,854 --> 00:11:16,866
This method for example is get method. And the

176
00:11:16,888 --> 00:11:20,386
get method is going to check the cache. It's going to return the cache.

177
00:11:20,418 --> 00:11:23,926
If there's a heat and if there's not a hit, it's going to go

178
00:11:24,028 --> 00:11:27,650
and use the embedded

179
00:11:27,730 --> 00:11:31,058
track. It's going to take the embedding thing store

180
00:11:31,164 --> 00:11:35,194
and use whatever is there. It's going to use the underneath store.

181
00:11:35,312 --> 00:11:38,774
So the SQL store and it's going to get the data from the SQL

182
00:11:38,822 --> 00:11:42,378
store, check if there's any error, and if there's no error,

183
00:11:42,474 --> 00:11:45,710
I'm going to cache this information and return

184
00:11:45,780 --> 00:11:49,214
the result well. What went well and what didn't work,

185
00:11:49,332 --> 00:11:53,006
one of the things that went really well was the simplicity of the

186
00:11:53,028 --> 00:11:56,398
solution. This is very simple, this is very straightforward,

187
00:11:56,494 --> 00:11:59,986
this is very clear pattern. It's really easy to

188
00:12:00,008 --> 00:12:03,250
understand, really easy to think about it, and really easy

189
00:12:03,320 --> 00:12:06,614
to think about other options that we can

190
00:12:06,732 --> 00:12:09,910
build with. This also was very simple.

191
00:12:09,980 --> 00:12:13,986
To add new caches was super straightforward, was overriding

192
00:12:14,018 --> 00:12:17,382
methods and just delegating everything else

193
00:12:17,436 --> 00:12:21,414
in the underneath the store. You don't need to think about adding

194
00:12:21,542 --> 00:12:25,178
in three different places code. You only have to add code

195
00:12:25,264 --> 00:12:29,242
in the cache layer and it's all that you need to do.

196
00:12:29,376 --> 00:12:32,974
It's a really general approach, so it can

197
00:12:33,012 --> 00:12:36,606
be really easy to reuse for other things as we're going to

198
00:12:36,628 --> 00:12:41,290
see soon what didn't work well. There's some subtleties

199
00:12:41,450 --> 00:12:45,050
around stroke embedding. String embedding

200
00:12:45,210 --> 00:12:48,830
is a struct embedding. It is not inheritance.

201
00:12:48,910 --> 00:12:52,178
So you are embedding a struct in another

202
00:12:52,264 --> 00:12:55,702
struct. So think about it as something

203
00:12:55,756 --> 00:12:58,882
that you are doing manually.

204
00:12:59,026 --> 00:13:02,662
You have a struct and you embed something inside that

205
00:13:02,716 --> 00:13:06,854
struct. Go provides some kind of syntax sugar to

206
00:13:06,892 --> 00:13:09,666
make this track embedding more comfortable,

207
00:13:09,778 --> 00:13:13,062
and allows you to call methods

208
00:13:13,126 --> 00:13:16,998
from the embedded struct in the parent struct.

209
00:13:17,094 --> 00:13:20,858
The parent struct can override that. Methods can

210
00:13:21,024 --> 00:13:24,526
define that methods, and if the methods are defined, it's going to

211
00:13:24,548 --> 00:13:27,834
be call from the parent. But if it's not defined,

212
00:13:27,882 --> 00:13:31,466
it's going to be call from the embedded struct.

213
00:13:31,578 --> 00:13:35,614
But there is the problem. Whenever you call a struct

214
00:13:35,662 --> 00:13:39,198
that embeds other struct, if the methods is not defined,

215
00:13:39,294 --> 00:13:43,262
it's going to call the underneath method the embedded

216
00:13:43,326 --> 00:13:47,442
struct method. And once you call the embedded strand method,

217
00:13:47,586 --> 00:13:51,254
that is not going to know anything about the parent.

218
00:13:51,372 --> 00:13:54,914
The context of that method is going to be the embedded

219
00:13:54,962 --> 00:13:59,010
object. So there's no information about the parent at all.

220
00:13:59,100 --> 00:14:02,566
So if in that method you call another method

221
00:14:02,598 --> 00:14:06,266
of extract, doesn't matter if you override that method on

222
00:14:06,288 --> 00:14:09,466
the parent, because you are in the context of

223
00:14:09,488 --> 00:14:12,726
the embedded extract. So you are going to call the methods

224
00:14:12,838 --> 00:14:16,302
of the embedding extract always. So that

225
00:14:16,356 --> 00:14:20,094
means that that can lead to some

226
00:14:20,292 --> 00:14:24,274
subtle errors that are really hard to track and

227
00:14:24,312 --> 00:14:28,526
really hard to find. But if you really know what struggle

228
00:14:28,558 --> 00:14:31,266
embedding is, it's really easy to avoid them.

229
00:14:31,368 --> 00:14:35,206
So one of the problem is these subtle errors that

230
00:14:35,228 --> 00:14:38,710
can happen. You have to be sure that your team

231
00:14:38,780 --> 00:14:42,294
knows what struggle embedding means and for

232
00:14:42,332 --> 00:14:46,482
sure know that struct embedding is not inheritance.

233
00:14:46,626 --> 00:14:50,394
Okay. Another problem is the interface has to be

234
00:14:50,432 --> 00:14:54,278
homogeneous. So that means that some flexibility

235
00:14:54,374 --> 00:14:58,394
get removed and doesn't allow you to add

236
00:14:58,432 --> 00:15:02,294
these kind of hints or things like that, or specific parameters

237
00:15:02,342 --> 00:15:05,566
for certain layers. And all that stuff is the price that you have

238
00:15:05,588 --> 00:15:09,214
to pay to have this homogeneous interface that you can wrap in

239
00:15:09,252 --> 00:15:13,002
layers. But this is the first solution.

240
00:15:13,066 --> 00:15:16,594
We built this for the cache. Went really well actually.

241
00:15:16,792 --> 00:15:20,978
But we start thinking, oh well, we have this new

242
00:15:21,144 --> 00:15:24,910
layers architecture that we can leverage for other things.

243
00:15:25,080 --> 00:15:28,454
For example, we can leverage that for instrumentation, to add

244
00:15:28,492 --> 00:15:31,910
instrumentation to our store without modifying anything

245
00:15:31,980 --> 00:15:35,842
in the store. Just having some instrumentation

246
00:15:35,986 --> 00:15:40,566
in a well defined layer and separating

247
00:15:40,758 --> 00:15:44,586
all that logic from the rest of the store. It's a great

248
00:15:44,768 --> 00:15:48,074
separation of concerns. You can have login if

249
00:15:48,112 --> 00:15:51,726
you want to log all the actions that

250
00:15:51,748 --> 00:15:55,358
you are doing. If you want to log specific actions in specific

251
00:15:55,444 --> 00:15:58,654
places. Auditing, for example, if you want

252
00:15:58,772 --> 00:16:02,526
to audit when something get accessed or

253
00:16:02,548 --> 00:16:05,490
get removed or get modified or something like that.

254
00:16:05,640 --> 00:16:09,582
Well, something that is really interesting is a storage and query delegation.

255
00:16:09,726 --> 00:16:13,406
For example, if you have your SQL

256
00:16:13,518 --> 00:16:16,758
store that, store things in SQL, SQL is great,

257
00:16:16,844 --> 00:16:20,566
but it's not the best option for every single problem out

258
00:16:20,588 --> 00:16:24,134
there. Sometimes you want to store unstructured data,

259
00:16:24,252 --> 00:16:27,686
sometimes you want to store data that is not so important

260
00:16:27,788 --> 00:16:31,386
to lose over time or is not necessarily to

261
00:16:31,408 --> 00:16:34,922
be 100% sure that you are storing the data

262
00:16:34,976 --> 00:16:39,222
and the data is 100% consistent. For example, some temporary

263
00:16:39,286 --> 00:16:42,366
data related to the status of the user, or if the

264
00:16:42,388 --> 00:16:45,822
user is typing something or was

265
00:16:45,876 --> 00:16:49,006
the last channel that the user viewed or things like that.

266
00:16:49,108 --> 00:16:53,454
That information is important for our users, but it's not critical.

267
00:16:53,582 --> 00:16:57,182
So you can leverage some in memory database,

268
00:16:57,246 --> 00:17:00,994
you can leverage some search specific enzyme like

269
00:17:01,032 --> 00:17:05,106
elasticsearch or bleep. Or you

270
00:17:05,128 --> 00:17:08,706
can start in a struct data in coach tv or Mongo

271
00:17:08,738 --> 00:17:12,354
for example, that can provide you certain performance

272
00:17:12,402 --> 00:17:15,878
improvements or certain extra features for certain

273
00:17:16,044 --> 00:17:20,250
pattern usage. Well, also we can add their

274
00:17:20,320 --> 00:17:23,562
extra validation if we want to be sure that

275
00:17:23,616 --> 00:17:27,370
certain things get consistent in the database. We can add extra

276
00:17:27,440 --> 00:17:30,786
validation in a layer. We can add extra error

277
00:17:30,838 --> 00:17:34,922
handling. For example, if you have a non relabeled network

278
00:17:34,986 --> 00:17:38,506
connection with your database, there can be some timeouts

279
00:17:38,538 --> 00:17:42,142
or there can be some network connection problems and maybe

280
00:17:42,196 --> 00:17:45,790
you want to handle that at the store level and struct

281
00:17:45,870 --> 00:17:49,362
the app layer from all the logic needed

282
00:17:49,416 --> 00:17:53,262
to retry a timeout on the database or retry

283
00:17:53,326 --> 00:17:57,094
certain situations under certain errors or

284
00:17:57,132 --> 00:18:00,566
you want to track certain kind of errors and store that

285
00:18:00,668 --> 00:18:04,166
information in a sentry or something like

286
00:18:04,188 --> 00:18:07,218
that. We start with instrumentation.

287
00:18:07,394 --> 00:18:10,858
We added this timer layer. The timer layer is

288
00:18:10,944 --> 00:18:15,082
just a layer that wraps every single method in the store and

289
00:18:15,136 --> 00:18:18,602
adds a timer and calculates how much time

290
00:18:18,656 --> 00:18:21,962
it takes to execute the query in the store.

291
00:18:22,096 --> 00:18:25,562
Yeah, it wraps everything with

292
00:18:25,616 --> 00:18:29,422
can almost identical method. So this

293
00:18:29,476 --> 00:18:33,362
is a lot of code and it's a very

294
00:18:33,416 --> 00:18:37,666
annoying kind of code that you have to write. And then the

295
00:18:37,688 --> 00:18:41,140
maintenance of that is really boring and

296
00:18:41,750 --> 00:18:45,182
error prone and complicated. So wow.

297
00:18:45,256 --> 00:18:48,966
Generators to the rescue. We are going to write one

298
00:18:49,068 --> 00:18:51,862
after another, same time,

299
00:18:51,996 --> 00:18:55,526
the same thing, a lot of times without a reason.

300
00:18:55,628 --> 00:19:00,026
Well, go provide us generators and we

301
00:19:00,048 --> 00:19:03,334
are going to use them for building this timer layer.

302
00:19:03,462 --> 00:19:07,286
Timer layer. This is an example of a method wrapped

303
00:19:07,318 --> 00:19:10,694
in the timer layer. In this case is the safe method

304
00:19:10,742 --> 00:19:14,038
of the Audi store. We start the timer,

305
00:19:14,134 --> 00:19:17,966
we execute the underneath the store call,

306
00:19:18,148 --> 00:19:21,566
and we calculate the last time, the time that has

307
00:19:21,588 --> 00:19:25,406
been spent in that method. And then if the metrics are enabled,

308
00:19:25,438 --> 00:19:28,798
I'm going to check if the query will succeed.

309
00:19:28,894 --> 00:19:32,674
And if succeed, I going to store, well, whatever it

310
00:19:32,712 --> 00:19:36,338
succeed or not, I'm going to store that information. In Prometheus.

311
00:19:36,434 --> 00:19:41,362
This is really great because it helps a lot to investigate

312
00:19:41,506 --> 00:19:45,222
bottlenecks. For example, we have all the information on

313
00:19:45,276 --> 00:19:48,442
how much it takes to execute every

314
00:19:48,496 --> 00:19:51,670
method in our store. This is can histogram.

315
00:19:51,750 --> 00:19:55,194
So we have the information of the average time.

316
00:19:55,312 --> 00:19:59,258
We have information about things like how many times these

317
00:19:59,344 --> 00:20:03,342
methods have been called. So we know how much

318
00:20:03,396 --> 00:20:07,582
time it takes in a cumulative way.

319
00:20:07,636 --> 00:20:11,390
So we can decide, okay, this method is called

320
00:20:11,540 --> 00:20:14,926
just a few times, but it's taking a lot

321
00:20:14,948 --> 00:20:18,446
of time each time. That is something that we have to handle.

322
00:20:18,558 --> 00:20:22,034
But at the same time you can think, oh, this method is really fast,

323
00:20:22,152 --> 00:20:25,414
but it's getting called like millions of

324
00:20:25,452 --> 00:20:29,974
times. So if you are able to improve the performance there,

325
00:20:30,092 --> 00:20:33,618
you are getting a very important performance improvement.

326
00:20:33,714 --> 00:20:36,918
So sometimes the time that is taken for

327
00:20:37,004 --> 00:20:40,214
certain methods is not that important and it's more

328
00:20:40,252 --> 00:20:43,706
important the time that is taken in total, not for

329
00:20:43,728 --> 00:20:47,306
each call. So this kind of information is there in

330
00:20:47,328 --> 00:20:50,966
a grafana and we can explore that. We can set alerts

331
00:20:51,078 --> 00:20:53,580
on that. So we can decide, for example,

332
00:20:54,030 --> 00:20:58,720
if a methods gets an increment of 10%

333
00:20:59,090 --> 00:21:03,774
of time to get executed in

334
00:21:03,812 --> 00:21:07,994
certain time, we can execute

335
00:21:08,042 --> 00:21:11,710
an alarm and send an email and say, okay, this method

336
00:21:12,130 --> 00:21:15,478
gets degradated in that date will be is

337
00:21:15,484 --> 00:21:18,662
because you upgraded to a new version and maybe

338
00:21:18,796 --> 00:21:22,546
that degradation is acceptable or is explained

339
00:21:22,578 --> 00:21:26,290
by some changes in the code that are necessary,

340
00:21:26,450 --> 00:21:30,066
but you don't degradate that without noticing.

341
00:21:30,098 --> 00:21:34,186
That other thing that we did is adding open tracing. Open tracing is

342
00:21:34,208 --> 00:21:37,546
great and give you a lot of information about what is

343
00:21:37,568 --> 00:21:40,954
going on in your system. But adding open tracing means that

344
00:21:40,992 --> 00:21:44,446
you have to add a lot of small details here and there in

345
00:21:44,468 --> 00:21:48,462
your code. And was something that we didn't want to do because

346
00:21:48,516 --> 00:21:52,026
we don't want to contaminate all our methods

347
00:21:52,058 --> 00:21:55,454
with this set of information in open tracing.

348
00:21:55,502 --> 00:21:59,122
So what we did, we create a layer that is

349
00:21:59,256 --> 00:22:02,434
almost the same of the timer layer. But for

350
00:22:02,472 --> 00:22:06,242
open tracing we created this layer and we

351
00:22:06,296 --> 00:22:09,954
also replicated that for other places. We use open tracing

352
00:22:10,002 --> 00:22:13,366
in the API using the middleware of the API that was

353
00:22:13,468 --> 00:22:16,854
already covered. And then we had to add

354
00:22:16,892 --> 00:22:20,086
open tracing to the app layer. The app layer is

355
00:22:20,188 --> 00:22:24,534
a big structure that has a lot of methods and that methods,

356
00:22:24,582 --> 00:22:27,754
well that is the way that we organize that

357
00:22:27,792 --> 00:22:32,378
methods. So what we did is just build automatically generate

358
00:22:32,474 --> 00:22:35,690
interface that match that structure

359
00:22:35,770 --> 00:22:39,546
with that interface. We created the layer

360
00:22:39,578 --> 00:22:43,086
for the app using again code generation. So now what

361
00:22:43,108 --> 00:22:46,386
we have is whenever we change something in the

362
00:22:46,408 --> 00:22:50,386
app layer or whenever we change something in the store, we only have

363
00:22:50,408 --> 00:22:53,746
to execute code generation and it's going to generate all

364
00:22:53,768 --> 00:22:57,334
the open tracing code for us. And we don't have any open

365
00:22:57,372 --> 00:23:01,094
tracing related code in the app layer and we don't have any open

366
00:23:01,132 --> 00:23:04,502
tracing related code in the rest of the store. We only

367
00:23:04,556 --> 00:23:08,290
have that information in the specific set

368
00:23:08,380 --> 00:23:12,346
of auto generated code that we have there. Well this is

369
00:23:12,368 --> 00:23:15,642
how it looks like in the code, the open

370
00:23:15,696 --> 00:23:19,350
tracing layer method, we just set the open tracing

371
00:23:19,430 --> 00:23:23,178
information. We execute the underneath

372
00:23:23,274 --> 00:23:27,200
method in the store and we add more information

373
00:23:27,890 --> 00:23:30,718
to the open tracing and that's it. Okay,

374
00:23:30,804 --> 00:23:34,530
the retries, the retry layer in the database.

375
00:23:34,870 --> 00:23:39,102
We want to use serial stable isolation level in the database.

376
00:23:39,246 --> 00:23:42,594
And that has a problem when you use read

377
00:23:42,632 --> 00:23:49,906
committed, basically you try to execute the queries and

378
00:23:49,928 --> 00:23:53,398
time is going to work pretty well. And when the load is

379
00:23:53,484 --> 00:23:57,414
pretty low, it's almost impossible. It's really hard

380
00:23:57,452 --> 00:24:00,954
to refuse that a transaction failing there.

381
00:24:01,072 --> 00:24:04,122
But when you are using serial disable isolation level,

382
00:24:04,256 --> 00:24:07,706
the problem is the isolation is so high that

383
00:24:07,808 --> 00:24:11,742
whenever you try to run two transactions and

384
00:24:11,796 --> 00:24:15,438
one of them modifies certain data and the other one

385
00:24:15,604 --> 00:24:19,694
is querying, some part of that modified data is going

386
00:24:19,732 --> 00:24:23,266
to fail. But it's not going to fail in

387
00:24:23,288 --> 00:24:26,658
a way that this query is broken or something like that.

388
00:24:26,744 --> 00:24:30,130
It's just saying okay. I'm not able to

389
00:24:30,200 --> 00:24:33,790
execute this transaction because something was modified

390
00:24:33,870 --> 00:24:37,074
before. So you need to execute the transaction

391
00:24:37,122 --> 00:24:40,838
again. And that is what a repeatable error means

392
00:24:40,924 --> 00:24:44,946
in the database. So whenever a database return, a repeatable error

393
00:24:45,058 --> 00:24:48,730
means retry. It probably

394
00:24:48,800 --> 00:24:52,950
is going to work, you only need to retry it. But because the transaction

395
00:24:53,110 --> 00:24:56,550
is something that I can re execute

396
00:24:56,710 --> 00:25:00,154
automatically from the database, because you are able

397
00:25:00,192 --> 00:25:04,158
to do things between the transactions and you are able to do

398
00:25:04,244 --> 00:25:08,074
calculations between the transaction, it's not easy for the database

399
00:25:08,122 --> 00:25:11,930
to infer that the transaction is repeatable

400
00:25:12,010 --> 00:25:15,534
by itself. So you need to repeat the transaction

401
00:25:15,582 --> 00:25:19,646
from the outside. Well, because we need to repeat

402
00:25:19,678 --> 00:25:23,714
the transactions when we receive a repeatable error. That was pretty

403
00:25:23,832 --> 00:25:27,986
easy to do with a layer. We just generate automatically

404
00:25:28,018 --> 00:25:32,034
a layer that catch any error that is a repeatable error

405
00:25:32,082 --> 00:25:35,238
and try again. Well, this also

406
00:25:35,324 --> 00:25:38,994
helps us with this. Whenever a deadlock

407
00:25:39,042 --> 00:25:42,434
happened in the database, one of the transaction is going to succeed

408
00:25:42,482 --> 00:25:46,038
and the other is going to get killed

409
00:25:46,134 --> 00:25:49,642
with a repeatable error. So that is something

410
00:25:49,696 --> 00:25:52,970
that happened really in a really rare way,

411
00:25:53,040 --> 00:25:57,290
but is something that can happen in very loaded environments.

412
00:25:57,450 --> 00:26:00,654
And what was happening before is just,

413
00:26:00,692 --> 00:26:04,870
well, it returns can error to the app layer and it returns

414
00:26:04,890 --> 00:26:09,474
an error to the API and probably the API is going to retry again.

415
00:26:09,672 --> 00:26:13,300
Now we are going to retry vaguely in the SQL store.

416
00:26:13,670 --> 00:26:17,590
This is how we did that. We have a get,

417
00:26:17,740 --> 00:26:21,286
for example, in this case we have the get method. We just

418
00:26:21,468 --> 00:26:24,738
enter in a loop, try to execute the query.

419
00:26:24,834 --> 00:26:28,166
If that works, great. If it doesn't work,

420
00:26:28,348 --> 00:26:31,786
if this is not a repeatable error, I'm going to return the

421
00:26:31,808 --> 00:26:35,690
error. But if it is a repeatable error, I'm going to try

422
00:26:35,760 --> 00:26:39,642
again. I'm going to repeat and repeat and repeat until it

423
00:26:39,696 --> 00:26:43,066
succeed or it fails three times.

424
00:26:43,168 --> 00:26:46,842
After three times we give up and return an error.

425
00:26:46,986 --> 00:26:50,366
Then what is really interesting here is

426
00:26:50,468 --> 00:26:53,934
we have the timer layer, we have the open tracing layer,

427
00:26:53,982 --> 00:26:58,034
we have the retry layer, and all that layers are

428
00:26:58,072 --> 00:27:01,426
auto generated. Everything that we change in

429
00:27:01,448 --> 00:27:05,250
the store is going to be automatically up to date with just

430
00:27:05,320 --> 00:27:08,520
a make generate. That is awesome.

431
00:27:09,290 --> 00:27:13,174
So if you have this kind of code, it's really great to

432
00:27:13,212 --> 00:27:17,342
have generators. And how we do that, we use ASt

433
00:27:17,506 --> 00:27:21,446
to analyze this struct, this interface,

434
00:27:21,558 --> 00:27:24,182
this store interface and all the soup interfaces.

435
00:27:24,326 --> 00:27:27,834
And we build a data struct where we

436
00:27:27,872 --> 00:27:31,426
have all the superstore

437
00:27:31,478 --> 00:27:34,858
that are defined, all the method of the superstores,

438
00:27:34,954 --> 00:27:38,158
all the parameters of the methods, all the return values of the

439
00:27:38,164 --> 00:27:42,342
methods, all that information is in a new struct

440
00:27:42,506 --> 00:27:46,350
that we pass that information to a template

441
00:27:46,430 --> 00:27:50,242
and that template generates the code. We have

442
00:27:50,296 --> 00:27:54,194
different templates, we have the same ast code that

443
00:27:54,232 --> 00:27:57,622
analyze the store and then we use that same

444
00:27:57,676 --> 00:28:01,266
structure that we just generated to populate

445
00:28:01,378 --> 00:28:04,546
three different templates, one for the timer layer,

446
00:28:04,578 --> 00:28:08,050
one for the open tracing layer and one for the retry layer.

447
00:28:08,130 --> 00:28:11,770
And that templates are going to be generated and it's going to generate a certain

448
00:28:11,840 --> 00:28:15,034
amount of code. And on top of that we are going to use go

449
00:28:15,072 --> 00:28:18,602
format package to reformat that. Why we use

450
00:28:18,656 --> 00:28:22,718
go format package because we don't want to be super

451
00:28:22,884 --> 00:28:26,606
correct when we generate the code. Generating the

452
00:28:26,628 --> 00:28:30,938
code is already a complicated task and generating

453
00:28:31,114 --> 00:28:34,958
code that the Go format likes

454
00:28:35,054 --> 00:28:38,354
is even harder. So we just delegate that in go

455
00:28:38,392 --> 00:28:41,746
format. We generate the code and reformat it with Go

456
00:28:41,768 --> 00:28:45,474
format package. So the developers are

457
00:28:45,512 --> 00:28:48,886
happy and the go compiler is happy. So this is an

458
00:28:48,908 --> 00:28:52,214
example of the timer layer template. As you can see

459
00:28:52,252 --> 00:28:56,162
there we have the superstores. We range over the superstores,

460
00:28:56,226 --> 00:28:59,994
we range over the methods of the superstores and

461
00:29:00,112 --> 00:29:04,074
we generate the functions there. We generate the

462
00:29:04,112 --> 00:29:07,546
star equal time module now and all

463
00:29:07,568 --> 00:29:11,022
that stuff. We are generating all the code there.

464
00:29:11,156 --> 00:29:14,974
It's not easy to understand, but once you write this has

465
00:29:15,012 --> 00:29:18,878
been working really well for a long time without

466
00:29:19,044 --> 00:29:22,490
almost any maintenance. Okay. But not everything

467
00:29:22,580 --> 00:29:27,042
can be generated or can be automatically generated. So we

468
00:29:27,096 --> 00:29:31,262
have to build something else. And I already talked about this storage

469
00:29:31,326 --> 00:29:34,974
query delegation pattern and in this case we

470
00:29:35,032 --> 00:29:38,534
use this pattern to build the

471
00:29:38,572 --> 00:29:42,182
search layer. For the searches in maramos we use full

472
00:29:42,236 --> 00:29:45,766
text search in the database. But we also support

473
00:29:45,868 --> 00:29:49,822
other searching mechanism like elasticsearch or bleep.

474
00:29:49,906 --> 00:29:53,482
If you want to use elasticsearch or bleep, what we do is

475
00:29:53,536 --> 00:29:57,034
just add a search layer on top of

476
00:29:57,072 --> 00:30:01,758
our SQL database layer and every search in

477
00:30:01,764 --> 00:30:05,754
the store is going to be delegated to elasticsearch or bleed.

478
00:30:05,882 --> 00:30:09,834
Every search in the store or every action

479
00:30:09,882 --> 00:30:13,314
to the store that needs to update the indexes is going

480
00:30:13,352 --> 00:30:16,734
to execute an update of the index

481
00:30:16,782 --> 00:30:18,930
in elasticsearch or bleed.

482
00:30:19,270 --> 00:30:23,246
And anytime that you try to search something it's

483
00:30:23,278 --> 00:30:27,126
going to hit the elasticsearch or bleed but

484
00:30:27,148 --> 00:30:30,214
it's not going to hit the database. So you are

485
00:30:30,252 --> 00:30:34,006
going to have probably better performance from a specific

486
00:30:34,108 --> 00:30:38,070
for search back end to search stuff.

487
00:30:38,140 --> 00:30:41,578
And actually we have more features and a better

488
00:30:41,664 --> 00:30:45,258
search using this in giants than the database one.

489
00:30:45,344 --> 00:30:48,614
And you are going to free some database

490
00:30:48,662 --> 00:30:51,898
titles for other stuff. So that is another

491
00:30:51,984 --> 00:30:55,614
interesting thing. Well, we want to make this transparent from

492
00:30:55,652 --> 00:30:59,374
any store user like the app layer. If the app layer is trying

493
00:30:59,412 --> 00:31:03,150
to use the store, they don't need to know if they are using

494
00:31:03,220 --> 00:31:06,946
elasticsearch or bleep or something like that. They only need to know that

495
00:31:06,968 --> 00:31:10,830
they are searching for users. And if the elasticsearch

496
00:31:10,910 --> 00:31:14,446
is enabled, it's going to get handled by elasticsearch.

497
00:31:14,558 --> 00:31:18,454
But the app layer doesn't know to need anything. Well this

498
00:31:18,492 --> 00:31:21,894
time we created the layer writing the code

499
00:31:22,012 --> 00:31:25,830
and here is an example. For example, in this case we are talking about the

500
00:31:25,900 --> 00:31:27,080
post store.

501
00:31:28,830 --> 00:31:32,170
We are overriding the method save of the post store

502
00:31:32,320 --> 00:31:36,502
and we are just saving the post using the SQL

503
00:31:36,566 --> 00:31:40,006
store underneath. And if there is an error

504
00:31:40,118 --> 00:31:43,578
I do nothing. But if there's no error,

505
00:31:43,674 --> 00:31:47,486
I'm going to index that post, I'm going to update the index of

506
00:31:47,508 --> 00:31:50,542
that post in the elasticsearch or bleed. If I

507
00:31:50,596 --> 00:31:53,706
search for a set of posts,

508
00:31:53,818 --> 00:31:57,398
I'm going to check in giants, I'm going to check what engines

509
00:31:57,434 --> 00:32:01,326
are enabled and I'm going to try to search in that in giants.

510
00:32:01,438 --> 00:32:05,362
If one of the injuries fail, I'm going to try in the next

511
00:32:05,416 --> 00:32:08,920
one until I find any injury that works.

512
00:32:09,690 --> 00:32:12,818
If none of our elastics are or bleeding

513
00:32:12,834 --> 00:32:16,486
giant specializes in giants works,

514
00:32:16,668 --> 00:32:20,642
we are going to fall back to the database search. We can disable

515
00:32:20,706 --> 00:32:24,202
this fallback and if we disable that fallback, it's going to return

516
00:32:24,256 --> 00:32:27,658
an empty list. But if we don't disable that fallback, we are going

517
00:32:27,664 --> 00:32:31,914
to just call the underneath SQL store to return the results.

518
00:32:32,042 --> 00:32:36,106
This works well. If you have for example downtime

519
00:32:36,138 --> 00:32:41,038
in elasticsearch, you can just use the

520
00:32:41,124 --> 00:32:44,366
database search as a fallback. And this is the

521
00:32:44,388 --> 00:32:47,522
final onion. This is how it looks like in our

522
00:32:47,576 --> 00:32:51,486
system. We have the app that is calling the store and it's passing

523
00:32:51,518 --> 00:32:54,930
through all the layers down to the SQL store and

524
00:32:55,000 --> 00:32:58,574
going back through the layers again to the app. The SQL

525
00:32:58,622 --> 00:33:02,082
store is at the bottom, it's taking care of all the SQL queries

526
00:33:02,146 --> 00:33:05,574
and all that stuff. The retry layer is going to take care of the

527
00:33:05,612 --> 00:33:09,366
repeatable errors. The cache layer is going to cache things

528
00:33:09,468 --> 00:33:12,762
and it's going to invalidate the caches and it's going to take care

529
00:33:12,816 --> 00:33:16,762
of, maintain and use the cache. The search

530
00:33:16,816 --> 00:33:20,766
layer is going to take care of, maintain and use the

531
00:33:20,868 --> 00:33:24,346
search indexes in elasticsearch or bleep. The timer

532
00:33:24,378 --> 00:33:28,494
layer is going to take care of all

533
00:33:28,532 --> 00:33:32,666
this timing around all this collecting information about

534
00:33:32,708 --> 00:33:36,494
the times and sending that to Prometheus

535
00:33:36,622 --> 00:33:40,386
and it is not here, but optionally you can have

536
00:33:40,408 --> 00:33:43,838
the open tracing layer. The open tracing layer is optional

537
00:33:43,934 --> 00:33:47,618
because have an important performance impact.

538
00:33:47,714 --> 00:33:51,078
So we can enable and disable it and usually

539
00:33:51,164 --> 00:33:55,078
it's disabled. But if you enable that, it's going to wrap this

540
00:33:55,164 --> 00:33:58,666
store entirely and it's going to provide that

541
00:33:58,688 --> 00:34:02,154
information to the open tracing service. This is

542
00:34:02,192 --> 00:34:05,654
how we build the onion. We instantiate the SQL

543
00:34:05,702 --> 00:34:09,494
store, we wrap that into the retry layer, we wrap

544
00:34:09,542 --> 00:34:13,166
that into the local cache layer, we wrap that into

545
00:34:13,188 --> 00:34:16,314
the search layer and we wrap that into the timer layer.

546
00:34:16,362 --> 00:34:20,334
And finally we return that final store. Because everything

547
00:34:20,532 --> 00:34:24,274
there implements the store interface, we can just say

548
00:34:24,312 --> 00:34:28,498
that they are all stores. The SQL store is

549
00:34:28,584 --> 00:34:32,498
a store, the retry layer wrapping a SQL store is a store

550
00:34:32,664 --> 00:34:36,510
and the SQL store wrapped by a retry layer

551
00:34:36,590 --> 00:34:39,302
and wrapped by a local cache layer is a store.

552
00:34:39,436 --> 00:34:42,982
We can reorganize all this and change

553
00:34:43,116 --> 00:34:47,262
where the layers are. For example, I can move the timer layer

554
00:34:47,426 --> 00:34:51,034
right after the SQL store.

555
00:34:51,152 --> 00:34:54,954
And that way we are going to measure only the

556
00:34:54,992 --> 00:34:58,426
time that the SQL store is taking. If you consider

557
00:34:58,528 --> 00:35:02,430
that the local cache layer, the cache layer that we are using

558
00:35:02,580 --> 00:35:06,126
is contaminating the data because you are interested

559
00:35:06,228 --> 00:35:10,366
on how much time the database is taking and you

560
00:35:10,388 --> 00:35:13,746
don't care about how much time is the store taking in

561
00:35:13,768 --> 00:35:16,974
general, only about the database. You can move the timer

562
00:35:17,022 --> 00:35:20,642
layer up there. Even you can create

563
00:35:20,696 --> 00:35:24,242
another timer layer and have different information,

564
00:35:24,376 --> 00:35:27,990
the SQL store information and the store information.

565
00:35:28,140 --> 00:35:31,462
You can play with this concept of everything as a store.

566
00:35:31,596 --> 00:35:35,174
To move the layers and make decisions about

567
00:35:35,372 --> 00:35:38,394
how we set up the layers and

568
00:35:38,432 --> 00:35:42,026
disable any of these layers is just not adding the

569
00:35:42,048 --> 00:35:45,226
wrapping. So if you want to enable or if you want

570
00:35:45,248 --> 00:35:48,870
to disable the search layer, you can just decide

571
00:35:48,950 --> 00:35:52,750
by a config setting if you want to have a search layer or not.

572
00:35:52,820 --> 00:35:56,746
And you just don't wrap the store with this layer

573
00:35:56,778 --> 00:36:00,446
and that's it. Well, there's some drawbacks. As I

574
00:36:00,468 --> 00:36:03,982
said already, all the layer has to share the same interface.

575
00:36:04,046 --> 00:36:07,870
That is a problem because you don't have enough flexibility

576
00:36:08,030 --> 00:36:11,538
to add certain things like the hints for the cache without

577
00:36:11,624 --> 00:36:15,026
modifying the whole store. So you

578
00:36:15,048 --> 00:36:18,406
have to modify the whole store interface if you want to add these

579
00:36:18,508 --> 00:36:21,894
hints for the cache, but if you want to add other kind

580
00:36:21,932 --> 00:36:25,942
of hints for the search, or if you want to add other kind of

581
00:36:25,996 --> 00:36:30,106
extra information for open tracing or for timing, you have

582
00:36:30,128 --> 00:36:33,466
to add more and more and more information to

583
00:36:33,488 --> 00:36:37,274
the store interface. And that is something that doesn't scale well.

584
00:36:37,392 --> 00:36:40,598
So I think this is the price to pay you have

585
00:36:40,624 --> 00:36:43,898
to accept that you have to use the same interface

586
00:36:43,994 --> 00:36:47,098
if you want to build this layer based approach.

587
00:36:47,274 --> 00:36:50,606
Probably there are some tricks that you can try,

588
00:36:50,708 --> 00:36:54,194
but it's not something that

589
00:36:54,312 --> 00:36:58,146
by design is going to fit well then the

590
00:36:58,168 --> 00:37:01,646
other problem is embedding is not inheritance.

591
00:37:01,758 --> 00:37:04,802
So it is not a problem per se,

592
00:37:04,936 --> 00:37:08,950
but it's something that can generate problems

593
00:37:09,020 --> 00:37:12,646
if the people doesn't understand well that the team of the people that

594
00:37:12,668 --> 00:37:16,694
is touching the store in this case needs to understand that

595
00:37:16,732 --> 00:37:20,550
the embedding is not inheritance. Embedding is struct

596
00:37:20,630 --> 00:37:24,442
embedding. So you need to understand that well and how

597
00:37:24,496 --> 00:37:27,946
embedding works to not end up

598
00:37:28,048 --> 00:37:32,778
having weird bugs that are really hard to debug. Well, some reference

599
00:37:32,954 --> 00:37:36,446
if you want to see how we implemented the store and the store layers and

600
00:37:36,468 --> 00:37:40,094
the generators and all that stuff is publicly available in our

601
00:37:40,132 --> 00:37:44,430
mattermost server repo in the store directory.

602
00:37:45,890 --> 00:37:49,006
If you want to see our old version of

603
00:37:49,028 --> 00:37:52,878
that with the middlewares and all that stuff, you can check the version 50

604
00:37:52,964 --> 00:37:56,998
zero that is a bit old already,

605
00:37:57,164 --> 00:38:00,566
but you can check that and well, it can be interesting.

606
00:38:00,748 --> 00:38:04,214
If you want to know more about stroke embedding, there's a

607
00:38:04,332 --> 00:38:07,830
talk really interesting from

608
00:38:07,900 --> 00:38:11,222
Gophercon UK. And if you want to know more about code

609
00:38:11,276 --> 00:38:14,838
generation, there's another talk from Gophercon UK that is really interesting

610
00:38:14,924 --> 00:38:16,500
too. So thank you.

