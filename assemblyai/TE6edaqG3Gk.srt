1
00:00:39,010 --> 00:00:41,922
Hello, a very good morning, good afternoon and a good evening,

2
00:00:41,986 --> 00:00:45,606
depending on the location you are connected from. And thank you so much

3
00:00:45,708 --> 00:00:48,962
for joining me in this session. Efficiency in motion

4
00:00:49,106 --> 00:00:52,510
mastering is delivery without compromising stability

5
00:00:52,850 --> 00:00:56,586
where I will be talking about my experience working with teams

6
00:00:56,698 --> 00:00:59,550
who thought they were doing microservices.

7
00:00:59,890 --> 00:01:02,974
But eventually they realized that it was

8
00:01:03,012 --> 00:01:06,322
actually a trap of a distributed monolith and they really

9
00:01:06,376 --> 00:01:09,902
couldn't take a full advantage of a microservices

10
00:01:09,966 --> 00:01:13,870
architecture, which tells you that you can ship a feature

11
00:01:14,030 --> 00:01:17,714
as soon as possible the moment it is developed.

12
00:01:17,842 --> 00:01:21,254
So what we will look at is what all changes this

13
00:01:21,292 --> 00:01:25,446
team had to go through to ensure that they can really embrace a

14
00:01:25,468 --> 00:01:29,482
continuous delivery of a single microservice as

15
00:01:29,536 --> 00:01:33,034
a shippable unit. And about me I

16
00:01:33,072 --> 00:01:36,826
work as a senior architect with a company simpler who is

17
00:01:36,848 --> 00:01:40,794
into the domain of intranet platforms and has been positioned

18
00:01:40,842 --> 00:01:44,782
as a leader in 2023. Gartner Magic Quadrant in

19
00:01:44,836 --> 00:01:49,054
intranet packaged solution I specialize in

20
00:01:49,172 --> 00:01:53,514
creating products using microservices and event driven architecture.

21
00:01:53,642 --> 00:01:57,442
I also publish blogs on the site that you see on the screen

22
00:01:57,576 --> 00:02:01,118
and if you want to connect me, these are my LinkedIn credentials

23
00:02:01,214 --> 00:02:05,246
and this is how I look as of today. So let's dive

24
00:02:05,278 --> 00:02:09,080
in and see what we have got in this session for you.

25
00:02:09,530 --> 00:02:13,046
So this diagram is pretty self explanatory. If you

26
00:02:13,068 --> 00:02:17,794
look in any of a product organization, you have got multiple stakeholders

27
00:02:17,922 --> 00:02:21,418
who work together to deliver a product. You have a

28
00:02:21,424 --> 00:02:24,986
product team who works with the end users and the

29
00:02:25,008 --> 00:02:28,554
customers to understand the requirements, produce some

30
00:02:28,592 --> 00:02:32,510
documents, brds and srds, and then

31
00:02:32,660 --> 00:02:36,430
it's the dev team who works with the product team to understand

32
00:02:36,500 --> 00:02:40,430
the requirements better. Work with the architects, come up with

33
00:02:40,580 --> 00:02:44,502
the design and they try hard to produce a feature

34
00:02:44,586 --> 00:02:48,706
which can be released into the prod environment as soon as possible.

35
00:02:48,888 --> 00:02:52,738
Now, as soon as possible is the crux here. So the intent is

36
00:02:52,824 --> 00:02:56,434
you release the feature soon and you wait for the

37
00:02:56,472 --> 00:02:59,570
feedback from the users who will be using this feature.

38
00:02:59,730 --> 00:03:03,142
And if they find everything okay, nothing like it,

39
00:03:03,196 --> 00:03:06,806
but we generally do not see that happening. So they

40
00:03:06,828 --> 00:03:10,442
will have some feedback, they'll pass it on to the product team.

41
00:03:10,576 --> 00:03:14,730
Product team will again come back to the developers and then this cycle goes

42
00:03:14,800 --> 00:03:18,138
on and on. So the way I said,

43
00:03:18,224 --> 00:03:21,694
the key is you want to deliver the feature as

44
00:03:21,732 --> 00:03:25,002
soon as possible. And you can smell

45
00:03:25,146 --> 00:03:29,150
the team is trying to do a continuous delivery, which is

46
00:03:29,220 --> 00:03:32,366
a software development process of getting the

47
00:03:32,388 --> 00:03:35,842
code changes deployed into production quickly,

48
00:03:35,976 --> 00:03:39,458
safely and with high quality. So we understand

49
00:03:39,544 --> 00:03:43,314
all these buzzwords, not really a buzzword, but a key

50
00:03:43,352 --> 00:03:46,740
things, which is you want to do it as soon as possible.

51
00:03:47,430 --> 00:03:51,222
You want to ensure that whatever you are delivering is

52
00:03:51,276 --> 00:03:54,726
not breaking any of the existing features. And of

53
00:03:54,748 --> 00:03:58,682
course, it's all bug free. And that is where it says the high

54
00:03:58,736 --> 00:04:02,822
quality. And one of the software

55
00:04:02,886 --> 00:04:06,794
architects that complements this kind

56
00:04:06,832 --> 00:04:11,082
of development process is known as microservices

57
00:04:11,146 --> 00:04:15,226
architecture, which is nothing but an independent

58
00:04:15,338 --> 00:04:18,874
deployable unit modeled around a business domain.

59
00:04:18,922 --> 00:04:22,786
And generally these microservices collaborate with

60
00:04:22,808 --> 00:04:26,130
each other to deliver a larger business use case.

61
00:04:26,280 --> 00:04:30,174
So majority of us have done monolith architecture

62
00:04:30,302 --> 00:04:33,506
and we have looked at the pain that

63
00:04:33,528 --> 00:04:37,014
this architecture offers, and then people have

64
00:04:37,052 --> 00:04:40,646
slowly, and I would say majority of the companies are by

65
00:04:40,668 --> 00:04:43,910
default going with microservices architecture because they understand

66
00:04:43,980 --> 00:04:47,426
the advantage that this architecture gives to them.

67
00:04:47,548 --> 00:04:51,514
It's like smaller units, easy to comprehend, easy to understand,

68
00:04:51,632 --> 00:04:55,034
easy to develop, test, deploy. I mean,

69
00:04:55,072 --> 00:04:58,662
that is the real advantage of a microservice architecture,

70
00:04:58,726 --> 00:05:02,554
right? And one of the key advantage

71
00:05:02,682 --> 00:05:06,880
is team autonomous. So I can have multiple services

72
00:05:07,570 --> 00:05:11,594
being owned by different teams. And because these teams

73
00:05:11,642 --> 00:05:15,294
own the service, they understand the in and out and

74
00:05:15,332 --> 00:05:18,622
is typically modeled around a business domain. So tomorrow,

75
00:05:18,686 --> 00:05:21,426
if there is a change which is supposed to be done in one of the

76
00:05:21,448 --> 00:05:24,866
service, it is just easy for them to go and make

77
00:05:24,888 --> 00:05:28,334
a change and deploy the service without impacting

78
00:05:28,382 --> 00:05:31,990
any other service. So in this case, you see there is service a,

79
00:05:32,060 --> 00:05:35,510
which is on version one, and there is a change

80
00:05:35,580 --> 00:05:39,526
which is supposed to be done in the same service. So this service

81
00:05:39,708 --> 00:05:43,194
will simply make some changes, do enough testing, ensure that

82
00:05:43,232 --> 00:05:47,366
things are not breaking, and they can just go and deploy the version

83
00:05:47,398 --> 00:05:50,678
two of the same service. And they don't have to collaborate

84
00:05:50,774 --> 00:05:54,794
with any of the other services because they know that the requirement

85
00:05:54,842 --> 00:05:58,286
is only for them. So they have full authority to

86
00:05:58,308 --> 00:06:02,046
make a change to deploy as and when they feel okay and

87
00:06:02,068 --> 00:06:05,506
they feel confident. But this is what

88
00:06:05,528 --> 00:06:09,426
is expected, that I can go and deploy my service as and

89
00:06:09,448 --> 00:06:13,026
when I feel. But for many of the companies,

90
00:06:13,208 --> 00:06:16,406
when you look at the way they

91
00:06:16,428 --> 00:06:19,702
ship their features, things really

92
00:06:19,756 --> 00:06:23,094
go crazy. And that is what I am going to talk about

93
00:06:23,132 --> 00:06:26,710
in this session. So majority of the companies,

94
00:06:26,860 --> 00:06:30,300
if you look at a deployment pattern, this is how

95
00:06:31,150 --> 00:06:35,354
you will get to know that you have got multiple services who

96
00:06:35,392 --> 00:06:38,854
have their artifacts in a single artifact

97
00:06:38,902 --> 00:06:42,590
repository. But when they are trying to ship a feature,

98
00:06:42,930 --> 00:06:47,002
it's not just one service which is being deployed. There are multiple

99
00:06:47,066 --> 00:06:50,926
services which is being deployed in

100
00:06:50,948 --> 00:06:54,594
the prod environment. And there

101
00:06:54,632 --> 00:06:57,700
could be many reasons for that to happen.

102
00:06:58,150 --> 00:07:00,942
But when you look at this kind of architecture,

103
00:07:01,006 --> 00:07:05,402
right, it gives you a feeling that this is not microservices,

104
00:07:05,486 --> 00:07:08,998
this is more like a distributed monolith. And yes, you're absolutely

105
00:07:09,084 --> 00:07:11,910
true, this is a distributed monolith.

106
00:07:12,410 --> 00:07:16,194
And honestly, there can be many reasons

107
00:07:16,242 --> 00:07:19,850
which are quite technical. Maybe the service

108
00:07:19,920 --> 00:07:23,594
boundary of a microservice is not correct.

109
00:07:23,712 --> 00:07:27,610
Maybe a single microservices was broken further down into

110
00:07:27,680 --> 00:07:31,406
so many services that a single requirement in that

111
00:07:31,428 --> 00:07:35,354
domain leads to lot of changes happening across multiple

112
00:07:35,402 --> 00:07:39,038
services. And maybe because of that reason you're forced to deploy these services

113
00:07:39,124 --> 00:07:43,006
together. Other reason could be that you have an underlying

114
00:07:43,038 --> 00:07:46,494
data storage which is being shared across multiple

115
00:07:46,542 --> 00:07:50,226
services, a kind of entire pattern that

116
00:07:50,248 --> 00:07:53,602
we say in microservices, where a change in the data

117
00:07:53,656 --> 00:07:57,122
storage which is being shared, it can trigger a change,

118
00:07:57,176 --> 00:08:00,546
a cascading impact to majority

119
00:08:00,578 --> 00:08:03,686
of the services. And this could be also one of the reason why there are

120
00:08:03,708 --> 00:08:07,158
so many changes happening and things are getting deployed even for a

121
00:08:07,164 --> 00:08:11,194
single feature to be shaped. And one

122
00:08:11,232 --> 00:08:13,980
more could be like too many shared libraries, right?

123
00:08:15,390 --> 00:08:18,762
You are trying to share some code by

124
00:08:18,816 --> 00:08:22,778
way of creating libraries. So one change in that library

125
00:08:22,954 --> 00:08:26,734
and then you are forced to update all

126
00:08:26,772 --> 00:08:30,814
the services which are using this library, and then you

127
00:08:30,852 --> 00:08:34,194
will have to deploy those services once again when you're doing a

128
00:08:34,232 --> 00:08:38,146
release. But there is one more reason

129
00:08:38,328 --> 00:08:42,242
for such a deployment pattern. And this is pretty common for

130
00:08:42,296 --> 00:08:46,226
companies like SaaS, companies who follow a specific

131
00:08:46,408 --> 00:08:50,450
release cadence like they have a predefined feature releases schedule

132
00:08:50,610 --> 00:08:54,374
where let's say, they say that we will do

133
00:08:54,412 --> 00:08:57,686
a shipment every one month and

134
00:08:57,708 --> 00:09:01,146
then we will accumulate all the features who were developed even in

135
00:09:01,168 --> 00:09:04,906
the first week of the month. They are just holding onto it. They are just

136
00:09:04,928 --> 00:09:08,554
waiting for the four week slot to be over,

137
00:09:08,672 --> 00:09:12,814
the final day of release to come. And then they will ship the

138
00:09:12,852 --> 00:09:16,480
features like multiple features being shipped the same day,

139
00:09:16,930 --> 00:09:20,062
and then there could be valid reasons for it.

140
00:09:20,196 --> 00:09:23,662
Some of the nontechnical reasons for doing this stuff

141
00:09:23,716 --> 00:09:26,702
is maybe you want to create a market buzz.

142
00:09:26,846 --> 00:09:31,294
Your customers are asking for a feature which is very in high in demand,

143
00:09:31,422 --> 00:09:34,626
and then you want to create a market buzz that okay, we are

144
00:09:34,648 --> 00:09:38,214
doing this feature in so and so release, and then you want to have that

145
00:09:38,252 --> 00:09:41,640
craze going in the market. Other reason could be

146
00:09:42,970 --> 00:09:46,146
your customers, they don't really have an appetite.

147
00:09:46,258 --> 00:09:50,374
So as a company, you are okay to release

148
00:09:50,422 --> 00:09:53,238
so many features, maybe daily,

149
00:09:53,414 --> 00:09:56,970
if not weekly or monthly, but then your customers

150
00:09:57,040 --> 00:10:00,474
are saying like, no, let me absorb whatever you have already

151
00:10:00,512 --> 00:10:04,400
shipped, and then we are not in a position to absorb more,

152
00:10:06,050 --> 00:10:09,294
you want to share, like maybe from a compliance season, you are

153
00:10:09,332 --> 00:10:12,686
forced to share some report with every release that

154
00:10:12,708 --> 00:10:15,538
you make. One of the example could be like a pen test that you are

155
00:10:15,544 --> 00:10:19,714
doing for your product, where you want to release your security posture of

156
00:10:19,752 --> 00:10:23,106
the product. And maybe you will

157
00:10:23,128 --> 00:10:26,514
have to train your customer support teams. You want to publish

158
00:10:26,562 --> 00:10:32,006
user guides, a lot of other stuff because of which you

159
00:10:32,028 --> 00:10:36,710
are actually doing a release in a very specific cadence.

160
00:10:37,050 --> 00:10:40,634
So we understand now that we

161
00:10:40,672 --> 00:10:44,154
wanted to do microservices. We wanted

162
00:10:44,192 --> 00:10:47,562
to embrace deploying one

163
00:10:47,616 --> 00:10:51,366
service at a time with the assumption that one feature fits.

164
00:10:51,398 --> 00:10:54,666
One service may not be the case always, but in majority of the cases,

165
00:10:54,698 --> 00:10:57,870
that's how it should be. If that's not the case, then you have done something

166
00:10:57,940 --> 00:11:01,486
wrong with breaking up your domain and assigning the

167
00:11:01,508 --> 00:11:04,866
domain to a service. But then what

168
00:11:04,888 --> 00:11:08,226
is the problem that we are trying to address here? Like what exactly the

169
00:11:08,248 --> 00:11:10,930
issues that this distributed monolith causes?

170
00:11:11,430 --> 00:11:15,598
Well, a very high risk

171
00:11:15,774 --> 00:11:19,394
that you are getting into when you're doing this bulky deployment

172
00:11:19,522 --> 00:11:23,318
is you do not know if something goes wrong,

173
00:11:23,484 --> 00:11:27,714
why it went wrong. And this is coming, when I say distributed monolith,

174
00:11:27,842 --> 00:11:31,434
this feature is coming from like this negative feature is

175
00:11:31,472 --> 00:11:34,938
coming from the monolith world where you're doing a

176
00:11:34,944 --> 00:11:38,378
bulky deployment, releasing so many things in

177
00:11:38,384 --> 00:11:42,350
a single release package, and then you really do not know what went wrong

178
00:11:42,500 --> 00:11:46,126
if things are not working as expected, right, and then

179
00:11:46,228 --> 00:11:49,742
lot of debugging time it consumes for you

180
00:11:49,796 --> 00:11:53,122
to at least understand that what could have gone wrong,

181
00:11:53,176 --> 00:11:56,914
why things are not working as expected. Second is high

182
00:11:56,952 --> 00:12:00,638
deployment time. With microservices,

183
00:12:00,734 --> 00:12:04,318
the expectation is it should be like zero downtime,

184
00:12:04,414 --> 00:12:08,406
or maybe roughly near zero downtime is what we say. But in

185
00:12:08,428 --> 00:12:12,102
this case, with so many microservices getting

186
00:12:12,156 --> 00:12:15,682
released together, your deployment time is eventually

187
00:12:15,746 --> 00:12:19,098
going to increase, which might have an impact on the

188
00:12:19,104 --> 00:12:22,778
user experience for the customers who are using your product,

189
00:12:22,864 --> 00:12:27,500
when you are actually doing a release. And the most important

190
00:12:27,870 --> 00:12:31,342
is what I would say, it literally burns out the

191
00:12:31,396 --> 00:12:35,002
engineering team. Now, some of the teams

192
00:12:35,066 --> 00:12:39,162
which I have worked with who were doing this kind of deployment.

193
00:12:39,306 --> 00:12:42,558
So every team will have a designated person

194
00:12:42,644 --> 00:12:46,242
on a release day. They will get into a conference room or maybe

195
00:12:46,296 --> 00:12:50,210
onto a bridge where one person represents one service,

196
00:12:50,280 --> 00:12:54,014
or maybe more than one service the person or the team owns.

197
00:12:54,142 --> 00:12:57,974
And then there will be a kind of checklist that will

198
00:12:58,012 --> 00:13:01,142
go first service a, followed by b,

199
00:13:01,196 --> 00:13:04,982
followed by c, and followed by d, and so on. And once

200
00:13:05,116 --> 00:13:08,742
every service is deployed, then you give a signal to

201
00:13:08,876 --> 00:13:12,074
your automation team that you know what, we are done with

202
00:13:12,112 --> 00:13:16,134
all kind of deployments, with all the services in all the predefined sequence.

203
00:13:16,262 --> 00:13:19,926
Now it's time for you to go and just

204
00:13:19,968 --> 00:13:22,986
perform the sanity. And then you just pray,

205
00:13:23,178 --> 00:13:26,842
maybe the release God that things work as expected,

206
00:13:26,986 --> 00:13:29,680
which generally may not be the case always.

207
00:13:31,330 --> 00:13:33,838
And then you just have to wait for the outcome.

208
00:13:33,934 --> 00:13:35,940
If things pass,

209
00:13:37,270 --> 00:13:41,294
you are one of those lucky ones. But if things fail,

210
00:13:41,422 --> 00:13:45,846
then you do not know what went wrong or which service

211
00:13:46,028 --> 00:13:48,680
resulted into such kind of situation.

212
00:13:49,530 --> 00:13:54,194
And honestly, some of the reasons

213
00:13:54,242 --> 00:13:57,618
which I have also heard by the teams who are

214
00:13:57,644 --> 00:14:01,370
not very proficient with microservices, it's like they

215
00:14:01,440 --> 00:14:05,514
tend to avoid, they assume that my

216
00:14:05,552 --> 00:14:09,274
network is always available. And once

217
00:14:09,472 --> 00:14:12,842
I am able to somehow pass this kind of engagement

218
00:14:12,906 --> 00:14:16,670
where every service is deployed together, all my use cases are passing.

219
00:14:17,330 --> 00:14:20,766
Things will never fail after that. Right? So a

220
00:14:20,788 --> 00:14:23,978
kind of myth, that network is always available,

221
00:14:24,164 --> 00:14:27,266
but just a comment I wanted to

222
00:14:27,288 --> 00:14:30,466
make. But then overall, you see everyone is

223
00:14:30,488 --> 00:14:34,146
so occupied on the release day that the entire day is gone and

224
00:14:34,168 --> 00:14:37,778
the productivity of the team, it goes to literally zero.

225
00:14:37,864 --> 00:14:41,880
And just imagine the pressure the QA team will be having. And then followed by

226
00:14:42,410 --> 00:14:45,654
the dev team where they just have to wait for the results to come out.

227
00:14:45,772 --> 00:14:49,974
And if they feel something is not working as expected, then they

228
00:14:50,012 --> 00:14:53,434
just have to work on it. And if they cannot fix

229
00:14:53,472 --> 00:14:56,874
it in a given amount of time, then they will have to roll back.

230
00:14:56,992 --> 00:15:00,302
But then what? To roll back, literally roll back

231
00:15:00,356 --> 00:15:03,742
everything. And that is something we do not want and that is something

232
00:15:03,796 --> 00:15:07,342
that microservices is not we use for.

233
00:15:07,476 --> 00:15:11,486
Right. All right, so we

234
00:15:11,508 --> 00:15:14,978
looked at the situation that the teams are into.

235
00:15:15,144 --> 00:15:18,786
We looked at the problem that something like this

236
00:15:18,888 --> 00:15:22,466
is going to have if you try to go

237
00:15:22,488 --> 00:15:25,810
with this deployment model. But then what's the solution?

238
00:15:26,470 --> 00:15:30,454
If you look at the solution, it's pretty simple, right? Like you just

239
00:15:30,492 --> 00:15:34,738
deploy the service as soon as a feature is developed,

240
00:15:34,914 --> 00:15:38,200
and I'm not kidding, that is the solution, right?

241
00:15:38,570 --> 00:15:42,234
Logically, you're done, just go and deploy it.

242
00:15:42,432 --> 00:15:45,866
The task is done, right? And let people use it if they want

243
00:15:45,888 --> 00:15:49,834
to use it. Again, I'm saying deploy the service

244
00:15:49,952 --> 00:15:53,454
as soon as a feature is developed. What exactly it means,

245
00:15:53,572 --> 00:15:56,766
we'll understand in a bit. But then the moment you

246
00:15:56,788 --> 00:16:00,590
make this statement, you immediately get two

247
00:16:00,660 --> 00:16:03,200
questions, which I generally get. One,

248
00:16:03,650 --> 00:16:07,326
what happens to the release cadence? We just discussed

249
00:16:07,358 --> 00:16:10,706
about it, right. I want to create a market bus. Now, what happens to

250
00:16:10,728 --> 00:16:14,420
the market buzz I cannot create. Right. With this. And second,

251
00:16:15,590 --> 00:16:18,854
with whatever branching strategy that you follow,

252
00:16:19,052 --> 00:16:22,598
there will always be a situation where multiple developers in

253
00:16:22,604 --> 00:16:26,406
the same service are trying to work on different features. They check

254
00:16:26,428 --> 00:16:29,898
in the code. As a best practice, they should check in

255
00:16:29,904 --> 00:16:34,406
the code on a daily basis in the branch. And feature

256
00:16:34,598 --> 00:16:37,642
X is done, but feature Y is not yet

257
00:16:37,696 --> 00:16:41,194
done. And I want to release feature X,

258
00:16:41,312 --> 00:16:44,446
but the dev who's working on feature y, they come and say you

259
00:16:44,468 --> 00:16:47,838
cannot do it. Like you cannot just go and deploy the

260
00:16:47,844 --> 00:16:50,798
artifact because my feature is not ready.

261
00:16:50,964 --> 00:16:54,618
And if it is not ready, end users can

262
00:16:54,644 --> 00:16:58,114
see the buttons on the UI, they can just click it and things

263
00:16:58,152 --> 00:17:01,186
will not work. In that case, what's going to

264
00:17:01,208 --> 00:17:04,594
happen? Right? So a very fair and

265
00:17:04,632 --> 00:17:08,530
important questions, I would say, and the answer lies

266
00:17:08,610 --> 00:17:12,742
like this, a deployment of a service into

267
00:17:12,796 --> 00:17:16,870
production is not equal to a feature release.

268
00:17:17,210 --> 00:17:20,730
Now, all I had said was we deploy the service

269
00:17:20,880 --> 00:17:24,538
into the prod environment, but not

270
00:17:24,624 --> 00:17:27,642
essentially releasing a feature. Now,

271
00:17:27,696 --> 00:17:31,278
what exactly it means is that I will

272
00:17:31,444 --> 00:17:34,800
ensure that every feature which I develop

273
00:17:35,410 --> 00:17:39,390
goes behind something called as a feature toggle,

274
00:17:39,730 --> 00:17:44,814
a feature flag, right? It's simply whichever

275
00:17:44,862 --> 00:17:48,206
language you have been programming, you always have an if condition.

276
00:17:48,398 --> 00:17:52,334
So if the flag for feature x is enabled,

277
00:17:52,462 --> 00:17:56,246
my code will execute. If the flag is off, my code will

278
00:17:56,268 --> 00:18:00,118
not execute. And I just assume we all trust

279
00:18:00,204 --> 00:18:03,734
the if continuous, right? So if something is

280
00:18:03,772 --> 00:18:07,394
true, it will execute. If something is false, it will not execute,

281
00:18:07,442 --> 00:18:10,810
it will escape. And if I can ensure that

282
00:18:10,880 --> 00:18:14,614
every feature which I write it is behind a feature

283
00:18:14,662 --> 00:18:17,386
toggle, my job is done.

284
00:18:17,568 --> 00:18:20,762
So if I go to the next slide,

285
00:18:20,906 --> 00:18:25,886
and if you look at this diagram, right, you have a

286
00:18:25,908 --> 00:18:28,830
diagram that says a trunk based development,

287
00:18:29,650 --> 00:18:33,306
the branching strategy where multiple features

288
00:18:33,338 --> 00:18:37,054
are being worked on at the same time. So every developer

289
00:18:37,102 --> 00:18:40,450
just ensures that whatever feature they are working on,

290
00:18:40,600 --> 00:18:43,950
they just go behind a feature flag. By default,

291
00:18:44,030 --> 00:18:48,230
the flags will be turned off. And if you are done with the feature

292
00:18:48,570 --> 00:18:51,750
you deploy into the production,

293
00:18:53,290 --> 00:18:57,526
you still keep the feature flag off only when you think,

294
00:18:57,708 --> 00:19:00,874
and only when you think that it's time for you to turn

295
00:19:00,912 --> 00:19:05,020
the feature on. Simply go and turn the feature flag on.

296
00:19:05,390 --> 00:19:09,242
You don't have to redeploy the service and your job is

297
00:19:09,296 --> 00:19:12,814
done. So now with this, you are not

298
00:19:12,852 --> 00:19:15,760
waiting for all the dependencies to be available.

299
00:19:16,610 --> 00:19:20,862
Even half built code can still make into the production because

300
00:19:20,996 --> 00:19:24,930
the flag is turned off for everyone by default.

301
00:19:25,430 --> 00:19:28,546
And if you see this is what we are

302
00:19:28,568 --> 00:19:31,902
trying to do, we are trying to do a continuous delivery.

303
00:19:31,966 --> 00:19:35,070
So in this case, multiple service lines,

304
00:19:35,150 --> 00:19:38,802
like multiple service owners, they can work on their feature

305
00:19:38,866 --> 00:19:42,454
set and they can keep the feature flag on and

306
00:19:42,492 --> 00:19:45,830
off depending on whether they want to release the features

307
00:19:46,330 --> 00:19:49,834
to the end users for them to use or they just want to

308
00:19:49,872 --> 00:19:54,074
deploy into the production and let

309
00:19:54,112 --> 00:19:57,866
the right time come for them to release a feature. That means

310
00:19:57,968 --> 00:20:01,998
simpplr go and turn the feature flag on for

311
00:20:02,084 --> 00:20:05,802
the customers to use. If I go to the next slide

312
00:20:05,946 --> 00:20:09,150
now, this is important, like how it helps.

313
00:20:10,210 --> 00:20:13,618
We are looking at the solution and there are some advantages to it.

314
00:20:13,704 --> 00:20:16,914
So how it helps is you

315
00:20:16,952 --> 00:20:20,830
are able to take advantage of a microservices

316
00:20:20,910 --> 00:20:25,114
architecture. Now you are talking about deploying

317
00:20:25,182 --> 00:20:28,370
microservice as a single unit of deployment.

318
00:20:28,530 --> 00:20:31,960
So the risk is literally zero.

319
00:20:32,330 --> 00:20:35,378
You have near real zero downtime deployment.

320
00:20:35,474 --> 00:20:39,558
The risk has gone to absolutely to the bottom, because now

321
00:20:39,724 --> 00:20:43,434
things will work. Nothing like it. If things don't work,

322
00:20:43,552 --> 00:20:46,906
you know why things are not working? It is because of your service. And you

323
00:20:46,928 --> 00:20:50,538
can either turn the feature flag off or for some reason if you have

324
00:20:50,544 --> 00:20:53,966
to roll back, you know, you just have to roll back your service, like you

325
00:20:53,988 --> 00:20:57,486
don't have to depend on other service, no coordination needed,

326
00:20:57,668 --> 00:21:01,306
and all good. It gives you enough flexibility

327
00:21:01,418 --> 00:21:04,894
on the feature release. So we discussed that majority

328
00:21:04,942 --> 00:21:08,814
of the SaaS based companies, they have this cadence of deployment.

329
00:21:08,942 --> 00:21:12,914
So they generally define that, okay, one release four weeks

330
00:21:12,952 --> 00:21:16,546
down the line, all these features will go. But with this approach, if you have

331
00:21:16,568 --> 00:21:20,374
got something which is readily available, like, which is ready upfront and

332
00:21:20,412 --> 00:21:24,374
you want to ship it, because maybe you have a

333
00:21:24,412 --> 00:21:27,926
customer churn happening, you want to make them happy or

334
00:21:28,028 --> 00:21:31,546
you are getting enough push from the customers that we want this

335
00:21:31,568 --> 00:21:34,906
release as soon as possible and you had a plan to

336
00:21:34,928 --> 00:21:38,826
ship it maybe in the second month, but because the feature has been

337
00:21:38,848 --> 00:21:42,138
developed, you can just ship it right away. You don't

338
00:21:42,154 --> 00:21:45,914
even have to wait for the cadence to come. You can do dark

339
00:21:45,962 --> 00:21:49,134
launches. One of the beauty I would

340
00:21:49,172 --> 00:21:52,686
say of this approach is you can

341
00:21:52,708 --> 00:21:55,902
do beta launches, you can do selective

342
00:21:56,046 --> 00:21:59,540
customer launch. Maybe you want to understand,

343
00:22:00,550 --> 00:22:03,714
you are not very clear what the impact would be in terms of the

344
00:22:03,752 --> 00:22:06,898
performance, in terms of the infrastructure, rollout, the need and all.

345
00:22:06,984 --> 00:22:10,550
So you can do a silent launch, maybe for one customer, two customers

346
00:22:10,700 --> 00:22:14,726
who can be your test bed as well. So you understand the

347
00:22:14,748 --> 00:22:17,986
feature, how this is being used, if this is being acknowledged,

348
00:22:18,178 --> 00:22:22,250
the load and all, you understand, you fix the performance issues

349
00:22:22,320 --> 00:22:26,474
with these customers and then your customers are actually the live testers for

350
00:22:26,512 --> 00:22:30,234
you if you think the other way around. And once you really

351
00:22:30,272 --> 00:22:34,238
harden it, you can just deploy it for maybe

352
00:22:34,404 --> 00:22:37,678
across regions or maybe for bigger enterprise customers.

353
00:22:37,844 --> 00:22:41,054
And this way you are launching something which

354
00:22:41,092 --> 00:22:44,210
is already hardened by some of your real users.

355
00:22:44,710 --> 00:22:48,034
You can test in production, right? Maybe in

356
00:22:48,072 --> 00:22:52,226
some cases you have situations where you cannot test

357
00:22:52,328 --> 00:22:55,410
some kind of integrations in a lower environment.

358
00:22:55,830 --> 00:22:59,238
Maybe you do not have enough licenses, or there could be lot of

359
00:22:59,244 --> 00:23:02,546
other reasons as well. So you want to deploy into production

360
00:23:02,658 --> 00:23:06,534
and you want to test in production. So maybe you can just open the

361
00:23:06,572 --> 00:23:09,610
feature flag only for a specific user,

362
00:23:09,950 --> 00:23:13,306
maybe a specific test user. You can perform enough testing in

363
00:23:13,328 --> 00:23:16,710
your production and then get a certification

364
00:23:16,790 --> 00:23:20,474
that yes, whatever you have done is working, though you could

365
00:23:20,512 --> 00:23:23,230
not test it in the lower environments.

366
00:23:24,050 --> 00:23:27,774
You can embrace trunk based development. We all understand there

367
00:23:27,812 --> 00:23:30,974
are different kind of the branching strategies. We all have

368
00:23:31,012 --> 00:23:34,734
gone through the pain and hassle of all the merges and conflicts,

369
00:23:34,782 --> 00:23:37,966
a lot of other stuff. Trunk based development is something that helps

370
00:23:37,998 --> 00:23:40,580
you eliminate those kind of issues.

371
00:23:41,350 --> 00:23:45,134
So with this approach, you can also embrace trunk based

372
00:23:45,192 --> 00:23:49,298
development. And because you are doing deployment

373
00:23:49,394 --> 00:23:53,142
so many times in the production, you kind

374
00:23:53,196 --> 00:23:56,982
of master the art of deployment. So tomorrow, if something goes wrong,

375
00:23:57,116 --> 00:24:00,838
because you are doing things day in, day out, you know, what needs to

376
00:24:00,844 --> 00:24:03,818
be done, like what's the next course of action? Should I roll back,

377
00:24:03,984 --> 00:24:07,706
should I fix it, should I turn the feature flag off compared to where

378
00:24:07,728 --> 00:24:11,370
you are doing a deployment to prod once, maybe in a week,

379
00:24:11,440 --> 00:24:15,520
maybe in a month, a kind. And then if something really goes wrong,

380
00:24:15,970 --> 00:24:19,214
you generally do not know what to be done

381
00:24:19,332 --> 00:24:23,030
and you land up, maybe simply doing a rollback,

382
00:24:23,210 --> 00:24:26,594
right? But as the saying goes,

383
00:24:26,712 --> 00:24:30,290
nothing comes for free, right? We looked at the solution,

384
00:24:31,030 --> 00:24:33,522
we all understand, we acknowledge it,

385
00:24:33,656 --> 00:24:36,626
but it is not going to be that easy.

386
00:24:36,728 --> 00:24:40,758
Right? So there are quite a few challenges that you have to address

387
00:24:40,844 --> 00:24:44,774
before you say that. No, this is something that I

388
00:24:44,812 --> 00:24:48,546
want to adopt. So you need to be very thorough

389
00:24:48,578 --> 00:24:52,378
with what you're getting into, which is going to be fruitful in long run.

390
00:24:52,464 --> 00:24:56,330
But then initially there will be hiccups, it will take a lot of effort.

391
00:24:57,630 --> 00:25:01,294
So that is what this slide talks about. So low

392
00:25:01,332 --> 00:25:05,120
fault tolerance. So now if you see your entire product,

393
00:25:05,970 --> 00:25:09,710
you have feature flags everywhere.

394
00:25:10,130 --> 00:25:13,458
So whatever service, homegrown product,

395
00:25:13,544 --> 00:25:17,458
or maybe a third party product that you are using for

396
00:25:17,624 --> 00:25:21,278
leveraging feature flag, the availability

397
00:25:21,454 --> 00:25:25,060
of that service or that feature flag product

398
00:25:25,530 --> 00:25:29,366
has to be pretty high. If that one service goes down,

399
00:25:29,548 --> 00:25:32,310
your entire product goes for a toss.

400
00:25:32,970 --> 00:25:35,240
So that is something pretty important,

401
00:25:35,930 --> 00:25:39,334
high testing and validation effort. So we all

402
00:25:39,372 --> 00:25:42,746
understand when we write a microservice or as

403
00:25:42,768 --> 00:25:46,140
a matter of fact, when you write any piece of code, we ensure that

404
00:25:46,990 --> 00:25:50,214
whatever functions we have written, whatever conditions we have written,

405
00:25:50,342 --> 00:25:53,982
we write unit test cases. Then we write integration test

406
00:25:54,036 --> 00:25:57,806
cases, we write API test cases, we write end to

407
00:25:57,828 --> 00:26:02,110
end test cases, all sort of sanities and regressions and

408
00:26:02,180 --> 00:26:06,226
a lot of things that we do from an automation perspective, which itself is a

409
00:26:06,248 --> 00:26:10,590
very high, effort consuming task. But with feature flag

410
00:26:10,750 --> 00:26:14,146
now I'm adding more complexity. Now the

411
00:26:14,168 --> 00:26:18,006
complexity is all about lot of branching that will

412
00:26:18,028 --> 00:26:20,550
be happening. So let's say you have a feature.

413
00:26:21,130 --> 00:26:24,598
The feature can be either on or it can be off.

414
00:26:24,764 --> 00:26:27,834
Now, there could be other services who are dependent on this

415
00:26:27,872 --> 00:26:31,574
feature. Now, when you execute your test, when you execute

416
00:26:31,622 --> 00:26:35,834
your test suit, right, you need to ensure that

417
00:26:36,032 --> 00:26:39,530
your overall product is not breaking.

418
00:26:40,210 --> 00:26:44,126
If the feature flag is off or the

419
00:26:44,148 --> 00:26:47,978
feature flag is on, like things should work as expected,

420
00:26:48,074 --> 00:26:52,154
even if you have a half baked code lying in the production

421
00:26:52,282 --> 00:26:56,058
behind a feature flag which is turned off. So there are

422
00:26:56,084 --> 00:26:59,474
so many branching that would be happening. So for every test cases, you will have

423
00:26:59,512 --> 00:27:03,022
lot of situations, lot of feature flags, lot of combinations

424
00:27:03,086 --> 00:27:06,658
that will be there. And there comes a very important question,

425
00:27:06,744 --> 00:27:10,326
right, that do I need to do all the permutations in

426
00:27:10,348 --> 00:27:13,814
combinations? So every feature flag will have, let's say a state

427
00:27:13,852 --> 00:27:17,670
of true and false, and I have like hundreds of feature flags.

428
00:27:18,490 --> 00:27:21,594
Do I need to have a combination with each one of them? In that case,

429
00:27:21,632 --> 00:27:25,434
I will never be able to release something. Forget about fast, right?

430
00:27:25,472 --> 00:27:28,794
Because it will take a lot of time for you to execute it.

431
00:27:28,992 --> 00:27:33,194
Now that's where you have to take a smart decision.

432
00:27:33,322 --> 00:27:36,474
You need to identify some of your core use cases,

433
00:27:36,522 --> 00:27:41,390
some of your core services who are behind feature flag, and making

434
00:27:41,460 --> 00:27:45,790
sure that at least those core use cases, those core

435
00:27:46,470 --> 00:27:50,222
services are not breaking. Things are working as expected,

436
00:27:50,366 --> 00:27:53,666
and then if you have got more cpu capacity, you have

437
00:27:53,688 --> 00:27:57,506
got more time. You can just write more test cases and execute more test cases.

438
00:27:57,538 --> 00:28:01,506
Nothing like it, but at least have some core combination

439
00:28:01,538 --> 00:28:05,090
of feature flags just to ensure that your key critical

440
00:28:05,170 --> 00:28:09,274
components are not breaking and your key use cases are passing as

441
00:28:09,312 --> 00:28:12,570
expected enforced governance.

442
00:28:13,230 --> 00:28:16,906
When you work with feature flags, right, you need to be very careful in

443
00:28:16,928 --> 00:28:20,202
terms of how you name

444
00:28:20,256 --> 00:28:23,834
the feature flag. Looking at the feature flag, can I identify which

445
00:28:23,872 --> 00:28:27,566
service is using the feature flag? How many feature flags you want

446
00:28:27,588 --> 00:28:31,198
to keep in your product? You cannot just keep on adding feature flags, right?

447
00:28:31,284 --> 00:28:34,738
Once your feature flag is released, maybe in an early stage with the

448
00:28:34,744 --> 00:28:37,970
beta customers, eventually it will go ga,

449
00:28:38,710 --> 00:28:42,674
right? So you cannot just keep on adding feature flags. You have to

450
00:28:42,712 --> 00:28:46,406
decide upfront that the lifecycle of this

451
00:28:46,428 --> 00:28:49,990
feature flag is going to be, let's say two weeks or maybe two months,

452
00:28:50,140 --> 00:28:54,278
and then you will have to write enough test

453
00:28:54,444 --> 00:28:58,780
in terms of identifying that

454
00:29:00,190 --> 00:29:03,946
this feature flag was supposed to have a lifecycle of

455
00:29:03,968 --> 00:29:07,894
two weeks. The two weeks are gone. The feature flag still lies.

456
00:29:08,022 --> 00:29:11,646
Now something is wrong, right? So you have to

457
00:29:11,668 --> 00:29:15,262
write what you call as a fitness functions around these

458
00:29:15,316 --> 00:29:20,318
feature flags that helps you identify that the

459
00:29:20,404 --> 00:29:24,580
life of this feature flag has expired. So the dev team

460
00:29:25,030 --> 00:29:30,222
has to take some action to get that clean operational

461
00:29:30,286 --> 00:29:35,154
ownership. Now this is something pretty important with

462
00:29:35,192 --> 00:29:38,646
so many feature flags happening turned on and off for

463
00:29:38,668 --> 00:29:42,246
some of the customers, for some of the beta customers, who is

464
00:29:42,268 --> 00:29:45,366
going to take the responsibility of turning the feature flags on

465
00:29:45,388 --> 00:29:49,274
and off. So there are

466
00:29:49,472 --> 00:29:53,610
many ways by which this can be done. You have got many stakeholders

467
00:29:54,030 --> 00:29:57,642
who can be involved, who can take actions, who can

468
00:29:57,696 --> 00:30:01,646
streamline the process. What we

469
00:30:01,668 --> 00:30:05,434
have realized is, at least in the production

470
00:30:05,482 --> 00:30:08,590
environment, if this ownership goes to the product

471
00:30:08,660 --> 00:30:12,526
team, because they understand well in

472
00:30:12,548 --> 00:30:15,826
terms of the feature is to be rolled out for which customer or

473
00:30:15,848 --> 00:30:19,650
maybe which beta customer or test customer or friendly customer,

474
00:30:19,720 --> 00:30:23,534
whatever name you want to call it. So they know when the feature

475
00:30:23,582 --> 00:30:27,026
will go Ga and for whom to

476
00:30:27,048 --> 00:30:30,840
releases, at what point of time, if a new customer is getting signed up,

477
00:30:31,370 --> 00:30:34,806
is this feature to be released for the customer or not? So if

478
00:30:34,828 --> 00:30:38,774
the product owners own the

479
00:30:38,812 --> 00:30:42,154
feature flags, at least in the prod environment, that will

480
00:30:42,192 --> 00:30:45,990
be good to have in lower environments. It depends.

481
00:30:46,070 --> 00:30:49,542
You can have the pod leads or the function leads, the architects,

482
00:30:49,606 --> 00:30:53,118
they can own and they can just play around with

483
00:30:53,204 --> 00:30:56,734
the feature flags. Or maybe your QA architect, they can also do the same

484
00:30:56,772 --> 00:31:00,670
thing. By default you are

485
00:31:00,820 --> 00:31:04,766
actually accumulating the tech debt. So all the feature flags

486
00:31:04,798 --> 00:31:08,110
that you add in the code, they eventually have to be removed,

487
00:31:08,190 --> 00:31:11,906
right? Once your feature goes GA, and that

488
00:31:11,928 --> 00:31:15,750
is what you have to be on toes to understand

489
00:31:15,820 --> 00:31:19,974
which feature flag has expired and it's time for you to go

490
00:31:20,012 --> 00:31:24,390
and remove the code. And again, it depends

491
00:31:25,050 --> 00:31:28,914
on how you write the code involving feature

492
00:31:28,962 --> 00:31:32,474
flag. And that's why there is a high learning curve. You don't want to

493
00:31:32,512 --> 00:31:35,980
scatter the feature flags around your product.

494
00:31:36,590 --> 00:31:39,814
With that it will be really hard to understand which feature

495
00:31:39,862 --> 00:31:43,166
flag is being used, where, in which service and how do

496
00:31:43,188 --> 00:31:46,814
I clean it up. So there are well defined patterns that you can

497
00:31:46,852 --> 00:31:51,150
use to ensure that the feature flags

498
00:31:51,570 --> 00:31:54,754
is easy to remove. I would say is easy to

499
00:31:54,792 --> 00:31:57,938
add for sure, but then it's easy to remove as well. Again,

500
00:31:58,024 --> 00:32:01,714
without breaking anything is a key. Now,

501
00:32:01,752 --> 00:32:05,026
observability cannot be an afterthought. We all understand the

502
00:32:05,048 --> 00:32:08,566
importance of observability, why it exists and why it should

503
00:32:08,588 --> 00:32:12,006
be there. Especially with Microservices, you cannot take a

504
00:32:12,028 --> 00:32:15,894
chance and it has to be a day zero thought process. But the moment you

505
00:32:15,932 --> 00:32:19,130
add feature flags, it cannot be a day one,

506
00:32:19,200 --> 00:32:23,014
it has to be a day zero thought process. Because now with feature

507
00:32:23,062 --> 00:32:26,906
flags being added, different services will be

508
00:32:26,928 --> 00:32:30,394
owning their own feature flags. Something being turned on, turned off

509
00:32:30,432 --> 00:32:34,062
by mistake. You want to know that something is breaking and

510
00:32:34,116 --> 00:32:37,914
you want to react like, you have to be proactive in identifying

511
00:32:37,962 --> 00:32:41,566
something has gone wrong, rather than your customer coming to you and saying that

512
00:32:41,748 --> 00:32:45,534
this service was working up till now, and now it is not working.

513
00:32:45,652 --> 00:32:48,718
And then you go and okay, somehow the feature flag got turned

514
00:32:48,734 --> 00:32:52,514
on or turned off, let me reverse it. And then you go back saying

515
00:32:52,552 --> 00:32:55,814
that, okay, now just try it out. And things work. So you

516
00:32:55,852 --> 00:32:59,830
want things to be identified by you and not by somebody

517
00:32:59,900 --> 00:33:03,990
else. And resiliency cannot be an afterthought.

518
00:33:04,330 --> 00:33:08,986
So resiliency is very important in

519
00:33:09,008 --> 00:33:12,742
a world of microservices. A microservice has to be resilient.

520
00:33:12,806 --> 00:33:16,534
But many times what we have seen is people tend

521
00:33:16,582 --> 00:33:20,714
to ignore the resiliency part. They assume the

522
00:33:20,752 --> 00:33:24,670
service they are dependent on will always be available and

523
00:33:24,740 --> 00:33:29,194
my network will always be behaving good with me. The bandwidth

524
00:33:29,242 --> 00:33:33,154
will always be enough. So they generally tend to avoid those

525
00:33:33,192 --> 00:33:36,594
kind of design and handling that in the code. But with

526
00:33:36,632 --> 00:33:40,580
feature flags, you really cannot take those chances. So that's why

527
00:33:41,110 --> 00:33:44,802
resiliency and observability, they just

528
00:33:44,856 --> 00:33:48,994
cannot be an afterthought. It has to go as a day zero implementation,

529
00:33:49,042 --> 00:33:52,502
I would say. Well, the last

530
00:33:52,556 --> 00:33:56,070
piece is to summarize whatever we discussed,

531
00:33:57,950 --> 00:34:02,022
use feature flags and define operational and governance

532
00:34:02,086 --> 00:34:06,300
model for it. This will help you to

533
00:34:07,070 --> 00:34:10,742
embrace the microservice architecture.

534
00:34:10,886 --> 00:34:14,138
This will help you to deploy microservice

535
00:34:14,234 --> 00:34:17,454
as a unit of deployment. The moment you are done

536
00:34:17,652 --> 00:34:20,798
with the development of your feature, you have tested enough

537
00:34:20,884 --> 00:34:24,286
without dependent on others, without having coordination with other teams.

538
00:34:24,318 --> 00:34:28,100
You can just go and confidently deploy the service

539
00:34:28,470 --> 00:34:31,730
in the environment, in the prod environment again,

540
00:34:31,800 --> 00:34:35,806
you can deploy, and if you think that it's time for you to

541
00:34:35,848 --> 00:34:39,286
release, you can just turn the feature flag on and the

542
00:34:39,308 --> 00:34:43,350
feature is released as well. You can embrace

543
00:34:43,850 --> 00:34:47,882
trunk driven development and get rid of all the pains that happens

544
00:34:47,936 --> 00:34:50,860
because of all the merge conflicts, a lot of other stuff,

545
00:34:51,310 --> 00:34:55,322
and finally have enough

546
00:34:55,456 --> 00:34:59,334
test automation in place for the key components

547
00:34:59,382 --> 00:35:01,390
for key use cases,

548
00:35:02,450 --> 00:35:05,662
playing with the toggle flags on and off,

549
00:35:05,716 --> 00:35:09,386
and ensure that things are always working as expected.

550
00:35:09,498 --> 00:35:12,714
Even you have a half big code in the production

551
00:35:12,762 --> 00:35:16,494
environment and I'm sure, and I can assure you

552
00:35:16,532 --> 00:35:20,094
that once you follow whatever is

553
00:35:20,132 --> 00:35:23,454
mentioned here, you are all set to

554
00:35:23,492 --> 00:35:27,222
embrace continuous delivery for a microservice as

555
00:35:27,276 --> 00:35:30,920
a unit of deployment. Thank you so much

556
00:35:31,530 --> 00:35:33,090
for joining me in this session.

