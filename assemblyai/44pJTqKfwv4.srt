1
00:02:13,080 --> 00:02:16,212
Um, hello and welcome

2
00:02:16,266 --> 00:02:20,256
to this session. Unleashing deploy velocity feature flags. Feature Flags I'm

3
00:02:20,288 --> 00:02:23,940
excited to be able to join you today as part of Comp 42 site

4
00:02:24,010 --> 00:02:27,152
reliability engineering series. And today we're

5
00:02:27,216 --> 00:02:29,748
talking about feature flags and we're really seeing how we're going to be able to

6
00:02:29,754 --> 00:02:33,396
use feature flags in order to not just enable faster deployments to

7
00:02:33,418 --> 00:02:37,132
production, but also just enable these deployments in general

8
00:02:37,186 --> 00:02:40,172
to have greater value and what we can do with them. You might call them

9
00:02:40,226 --> 00:02:43,788
feature flags. You might call these toggle switches or flippers. We'll explore them in a

10
00:02:43,794 --> 00:02:47,756
couple different ways today. Just before we get started, a little about

11
00:02:47,778 --> 00:02:50,988
myself. My name is Travis Goslin and I

12
00:02:50,994 --> 00:02:54,332
work as a principal software engineer for a company called SPS Commerce.

13
00:02:54,396 --> 00:02:58,128
And my focus is really on developer experience. And so anything in the

14
00:02:58,134 --> 00:03:01,312
software development lifecycle, I'm very much interested in and exactly

15
00:03:01,366 --> 00:03:05,076
how we can make micro feedback loops a little bit better for engineers and so

16
00:03:05,098 --> 00:03:08,660
you can get faster, more continuous feedback on whatever you're doing.

17
00:03:08,730 --> 00:03:11,280
And feature flags definitely bring us down this route.

18
00:03:11,440 --> 00:03:15,428
SPS commerce isn't a household name, it's a b, two b organization.

19
00:03:15,604 --> 00:03:19,144
You probably haven't heard of it, but we are the world's largest retail network with

20
00:03:19,182 --> 00:03:22,868
over 4200 retailers supplying data interchange

21
00:03:22,964 --> 00:03:26,576
invoices, purchase orders. Between those suppliers

22
00:03:26,628 --> 00:03:30,316
and retailers, Costco, Walmart, Target, academy, sports, you'll find

23
00:03:30,338 --> 00:03:34,092
us all with the biggest retailers in the market. And like

24
00:03:34,146 --> 00:03:38,892
many, our organization has really been on this DevOps and

25
00:03:38,946 --> 00:03:42,544
agile paths over the last decade and beyond. And we think about

26
00:03:42,582 --> 00:03:45,904
DevOps a lot as a culture and a state of mind, a shift really,

27
00:03:45,942 --> 00:03:49,756
in how we approach and how we focus on engineering.

28
00:03:49,948 --> 00:03:54,032
And for us, much like it is for you, probably continuous

29
00:03:54,096 --> 00:03:57,236
and automation are really key principles of how we

30
00:03:57,258 --> 00:04:01,168
approach it. The idea of continuously getting that feedback a little bit faster

31
00:04:01,264 --> 00:04:04,756
through automation, and whether it be just that local

32
00:04:04,858 --> 00:04:08,216
development and debugging feedback loop, or whether it be that feedback loop all the way

33
00:04:08,238 --> 00:04:12,328
to production on a finished feature, we're really focusing on making those

34
00:04:12,414 --> 00:04:16,088
tighter, faster and quicker as we go, and of course

35
00:04:16,174 --> 00:04:19,416
sharing that. And that's why I'm excited to be with you today in order to

36
00:04:19,438 --> 00:04:23,016
share our progress and our journey and some of the takeaways that we've

37
00:04:23,048 --> 00:04:26,216
had in hopes that maybe it has an impact on you and it's

38
00:04:26,248 --> 00:04:30,056
information that you can take away. However, like many organizations

39
00:04:30,088 --> 00:04:33,728
focusing down this road, we counted a pretty major roadblock and a problem that I

40
00:04:33,734 --> 00:04:36,976
wanted to share with you today. I think it's a problem that you'll be able

41
00:04:36,998 --> 00:04:41,136
to relate to. And so let's dive in and look at that. First is

42
00:04:41,238 --> 00:04:44,948
let's talk a little bit about our structure for development. It's pretty standard.

43
00:04:45,114 --> 00:04:48,176
We typically have a source control system specified in GitHub.

44
00:04:48,208 --> 00:04:51,284
So a repository that's there, we use

45
00:04:51,482 --> 00:04:54,336
main branch. Our default branch, you might call it master,

46
00:04:54,448 --> 00:04:58,452
is typically always deployable. We try to follow more pure

47
00:04:58,516 --> 00:05:02,356
CI practices around continuous integration. We do carve

48
00:05:02,388 --> 00:05:06,216
off feature branches though and use a lot of the capabilities and

49
00:05:06,238 --> 00:05:10,236
the functionality that is available inside of

50
00:05:10,418 --> 00:05:13,996
GitHub. So pull requests and status checks and all

51
00:05:14,018 --> 00:05:17,324
that capability. So that way we can automate pr checks coming

52
00:05:17,362 --> 00:05:20,796
back in through automation. So we develop these features in these short

53
00:05:20,818 --> 00:05:24,160
lived feature branches and use the validation in the pull request

54
00:05:24,820 --> 00:05:27,970
sequence to come back into our main branch when we're ready.

55
00:05:28,420 --> 00:05:31,664
Like any good CI system, then we automatically kick off and build

56
00:05:31,702 --> 00:05:35,076
that. We use git semantic versioning and releasing to

57
00:05:35,098 --> 00:05:38,932
look at these git commit messages and then devise a semantic version number,

58
00:05:38,986 --> 00:05:42,468
in this case one, two, x, whatever number you want,

59
00:05:42,634 --> 00:05:46,436
and we go ahead and we deploy that through continuous deployment automatically

60
00:05:46,468 --> 00:05:50,520
to our dev environment, which is pretty straightforward and obvious these days.

61
00:05:50,670 --> 00:05:54,116
And when we're ready to go to production and replace our existing release

62
00:05:54,148 --> 00:05:57,572
one 10 there we get blocked

63
00:05:57,636 --> 00:06:01,072
in a lot of cases. This is a big problem in many of our teams

64
00:06:01,156 --> 00:06:04,364
and we're blocked by this thing that we'll call a gate here.

65
00:06:04,482 --> 00:06:07,916
And you might be asking, well, what is this gate? This gate is

66
00:06:07,938 --> 00:06:10,876
many different things for different organizations and different teams,

67
00:06:10,908 --> 00:06:13,984
even within SPS commerce. It could be this

68
00:06:14,022 --> 00:06:17,904
gate is a product owner who doesn't want that particular feature released until

69
00:06:17,942 --> 00:06:21,824
next Tuesday. This could also be these fact that

70
00:06:21,942 --> 00:06:25,856
you're producing coordinated release and well it's just not finished yet. There are other applications

71
00:06:25,888 --> 00:06:29,424
that need to be released first before yours, or perhaps a UI

72
00:06:29,472 --> 00:06:32,708
that isn't quite ready yet. This could also be

73
00:06:32,714 --> 00:06:35,844
the fact that you've discovered a bug, you've been examining it in the dev

74
00:06:35,882 --> 00:06:39,876
environment or your test or your integration environment and it's just not working.

75
00:06:40,058 --> 00:06:43,188
It's just not as you expected or the AC isn't quite right.

76
00:06:43,274 --> 00:06:46,476
And so you get held up. You need to deploys this, but you can't to

77
00:06:46,498 --> 00:06:50,316
finish deploying it to production. At the same time you have additional features that

78
00:06:50,338 --> 00:06:53,532
are in the backlog and they're coming in and you're starting to develop them,

79
00:06:53,586 --> 00:06:56,396
but you're a little bit nervous to deploy those back into the main branch now

80
00:06:56,418 --> 00:06:59,116
because you know, you have an unresolved dependency that hasn't gone all these way to

81
00:06:59,138 --> 00:07:02,892
production, so you're kind of stuck there now. Your feature two

82
00:07:02,946 --> 00:07:05,856
is a little bit more longer lived than you wanted it to be, and you

83
00:07:05,878 --> 00:07:08,588
really just want to get it merged in and deployed, but you're waiting,

84
00:07:08,764 --> 00:07:11,996
and at the same time you discover that you need a critical bug

85
00:07:12,028 --> 00:07:15,536
fix in production. And at that point you

86
00:07:15,558 --> 00:07:17,956
make the bug fix and you push it all the way through and get a

87
00:07:17,978 --> 00:07:21,956
version and built. But that's when you run into the problem, because your pipeline is

88
00:07:21,978 --> 00:07:25,376
actually blocked. If this was an engineer maybe doing a critical bug fix that didn't

89
00:07:25,408 --> 00:07:28,744
realize that there was a hold up in the pipeline, he might have accidentally gone

90
00:07:28,782 --> 00:07:32,436
ahead, or she might have accidentally gone ahead and deploys that to production.

91
00:07:32,628 --> 00:07:36,436
In this case we can't because we're blocked. Our green feature can't go to production

92
00:07:36,468 --> 00:07:39,544
yet until next week maybe. Of course there's things

93
00:07:39,582 --> 00:07:42,984
you could have done, right, we could have cherry picked off main branches.

94
00:07:43,032 --> 00:07:47,132
We could have just branched off the bug fix branch from release 1.1

95
00:07:47,186 --> 00:07:50,536
tag and then released that directly to production.

96
00:07:50,728 --> 00:07:54,304
You don't want to release it to dev necessarily, because while we practice and

97
00:07:54,342 --> 00:07:58,412
really believe a lot in backwards compatibility, forwards compatibility,

98
00:07:58,476 --> 00:08:01,952
in the reverse of that is a whole nother scenario, especially if you're using

99
00:08:02,006 --> 00:08:05,548
other dependencies and database migrations, it might not be

100
00:08:05,574 --> 00:08:09,204
feasible to say, oh, I'm going to deploys version eleven in my dev

101
00:08:09,242 --> 00:08:12,948
environment, when it could be a week later after that migration has happened.

102
00:08:13,034 --> 00:08:16,168
Maybe it is, maybe it's not. And of course releasing that

103
00:08:16,174 --> 00:08:19,236
main branch directly to production with your immutable versioned artifacts

104
00:08:19,268 --> 00:08:22,584
is just odd and could

105
00:08:22,622 --> 00:08:26,168
cause some problems. Not a great idea. At the same time,

106
00:08:26,254 --> 00:08:29,944
you have other services that are waiting, right? Your service one and your service two

107
00:08:30,062 --> 00:08:33,368
are waiting either for those features, those critical bug fixes, and they're

108
00:08:33,384 --> 00:08:36,668
saying I can't continue on my parallel development without some of these contracts fulfilled and

109
00:08:36,674 --> 00:08:39,112
some of these updates, I want to use it now for my own development.

110
00:08:39,176 --> 00:08:42,432
That's likely an internal scenario. And so

111
00:08:42,486 --> 00:08:45,936
we've created then a lot of confusion and complexity here in

112
00:08:45,958 --> 00:08:49,536
our deployment pipelines because we've coupled together this idea

113
00:08:49,558 --> 00:08:52,736
of deploys and release. And so that's where we look at feature flags as an

114
00:08:52,758 --> 00:08:56,444
opportunity to decouple those in a solution. So let's

115
00:08:56,492 --> 00:08:59,828
examine a solution then together in this scenario, we'll have our

116
00:08:59,834 --> 00:09:02,964
main branch again and our feature branch. But when we're writing that feature code,

117
00:09:03,002 --> 00:09:06,304
we'll go ahead and we'll feature flag it. And for the sake of this discussion,

118
00:09:06,352 --> 00:09:09,464
the mental model we need here is just an if statement in code that is

119
00:09:09,502 --> 00:09:13,060
ensuring our new code execution path doesn't actually execute.

120
00:09:13,220 --> 00:09:17,076
And so here we'll automatically disable that feature if there's

121
00:09:17,108 --> 00:09:20,160
no app configuration to enable it. And so that already enables

122
00:09:20,180 --> 00:09:23,388
some initial value as I merge that feature back to the main or

123
00:09:23,394 --> 00:09:26,796
the default branches, even others doing development as

124
00:09:26,818 --> 00:09:30,232
they rebase their branch. Now they're not going to accidentally get an incompleted feature.

125
00:09:30,296 --> 00:09:33,504
So I can enable myself through a feature flag to even

126
00:09:33,702 --> 00:09:36,668
get some of these prs and these merges back to main and do shorter lived

127
00:09:36,684 --> 00:09:40,016
branches. Or I could even commit directly to main if

128
00:09:40,038 --> 00:09:43,920
I wanted to and follow some of those more pure CI CD practices.

129
00:09:44,840 --> 00:09:48,150
Of course we go ahead and we do the normal versioning here,

130
00:09:48,760 --> 00:09:52,324
build it and then deploy it to our dev environment. And here

131
00:09:52,362 --> 00:09:56,512
where we typically be blocked before we're not now because we're no longer releasing

132
00:09:56,576 --> 00:10:00,328
the feature because it is behind a feature flag that is inherently turned off.

133
00:10:00,494 --> 00:10:04,164
And so we can go ahead and deploys that directly to production without any blockage

134
00:10:04,212 --> 00:10:07,764
or without any dependencies in our pipeline. In reality,

135
00:10:07,812 --> 00:10:11,276
what we've done is taken that feature flag, and in

136
00:10:11,298 --> 00:10:15,064
a more advanced structure and architecture, we move that to a feature decision provider.

137
00:10:15,192 --> 00:10:18,652
Think of a feature decision provider as a microservice or a tiny service

138
00:10:18,706 --> 00:10:22,396
that exists abstracted from these environments that you can ask in

139
00:10:22,418 --> 00:10:25,484
a simple API request and say is feature one enabled?

140
00:10:25,532 --> 00:10:28,800
Yes or no? You might extend that to say is feature one enabled in dev?

141
00:10:28,870 --> 00:10:32,844
Is feature one enabled in prod? And then each individual environment can easily

142
00:10:32,892 --> 00:10:36,336
determine whether that feature is enabled and turned

143
00:10:36,368 --> 00:10:39,604
on or off. And so our gate then no longer exists between

144
00:10:39,642 --> 00:10:43,156
environments, but is abstracted to sit on the outside plane where it

145
00:10:43,178 --> 00:10:46,756
is blocking whether the feature decision provider should enable it or not.

146
00:10:46,938 --> 00:10:50,296
So this is fantastic, because now we can ensure that we

147
00:10:50,318 --> 00:10:53,944
haven't deploys, or I should say we haven't released that

148
00:10:53,982 --> 00:10:57,316
feature that can't go to next Tuesday until the product owner goes ahead and clicks

149
00:10:57,348 --> 00:11:01,304
that button, perhaps, or updates a value in the featured decision provider to enable

150
00:11:01,352 --> 00:11:04,380
it. That critical bug fix that we had no problem,

151
00:11:04,450 --> 00:11:07,676
right, can release it all the way through to production because we're now keeping our

152
00:11:07,698 --> 00:11:11,216
pipeline flowing without this facade of true CI that

153
00:11:11,238 --> 00:11:13,936
we're actually stopping our pipeline every now and again.

154
00:11:14,118 --> 00:11:17,824
And those service one and service two can also now

155
00:11:17,942 --> 00:11:21,792
be used as a part of this to integrate with early

156
00:11:21,846 --> 00:11:25,188
features if they need to. Using context, our feature decision provider can

157
00:11:25,194 --> 00:11:28,580
offer contextual decisions. So what do I mean by that?

158
00:11:28,650 --> 00:11:32,036
Perhaps service one is authorized as an internal service, we can

159
00:11:32,058 --> 00:11:36,052
detect that and we can ask feature decision provider, is feature one

160
00:11:36,106 --> 00:11:39,604
enabled in production for service one specifically?

161
00:11:39,652 --> 00:11:42,936
We can say yes and turn it on just for them. And so we have

162
00:11:42,958 --> 00:11:46,980
taken away then this coupling, as we talked about of deploy and release.

163
00:11:47,060 --> 00:11:50,604
They're no longer the same and they are separated and they exist in different

164
00:11:50,642 --> 00:11:53,580
parts now, not as a part of the infrastructure or the pipelines.

165
00:11:54,480 --> 00:11:57,548
This allows us to have some pretty powerful capability that we're going

166
00:11:57,554 --> 00:12:01,096
to talk about today. First, what is a feature flag

167
00:12:01,128 --> 00:12:04,448
by definition? My favorite definition is from Martin Fowler, which is a

168
00:12:04,454 --> 00:12:08,572
powerful technique allowing teams to modify system behavior, so modifying behaviors.

169
00:12:08,636 --> 00:12:12,416
And the key part of that is without changing code. So we added an

170
00:12:12,438 --> 00:12:16,128
app configuration file before, maybe a microservices. The key is that we don't

171
00:12:16,144 --> 00:12:20,416
want to change code in order to modify it. Martin Fowler

172
00:12:20,448 --> 00:12:24,356
also defines four types of feature flags to be aware of.

173
00:12:24,458 --> 00:12:28,036
The first is the release type of flag, and a release type of flag is

174
00:12:28,058 --> 00:12:31,704
really the kind we've been talking about the idea that something's still in development as

175
00:12:31,742 --> 00:12:35,348
a feature, or it shouldn't be released yet till Tuesday, or we're

176
00:12:35,364 --> 00:12:39,000
just coordinating it across a couple of different projects and deployable units.

177
00:12:39,500 --> 00:12:43,080
Whereas an operations type of flag is something that's more technical

178
00:12:43,240 --> 00:12:46,412
for us as engineers, something we want to do, we want to modify the system

179
00:12:46,466 --> 00:12:49,800
behavior, but it's not an actual feature. Might be performance related,

180
00:12:49,960 --> 00:12:53,504
might be for temporary migrations, we'll see an example of that in a bit.

181
00:12:53,622 --> 00:12:57,004
Might be for traffic shaping or switches or degradation,

182
00:12:57,132 --> 00:13:00,796
those types of things. And of course these third type is experimental,

183
00:13:00,828 --> 00:13:03,488
which I'm sure you've heard of. The idea that I want to test variations of

184
00:13:03,494 --> 00:13:06,748
a feature on different users and see what works for

185
00:13:06,774 --> 00:13:09,968
them, what doesn't. Maybe I just want to test it on a portion of users

186
00:13:09,984 --> 00:13:13,604
out there and see how it performs. And of course, the fourth type

187
00:13:13,642 --> 00:13:17,348
is the permission type. And the permission type then designates a certain feature for alpha

188
00:13:17,364 --> 00:13:21,464
testing or maybe for specific customers that are likely to

189
00:13:21,662 --> 00:13:24,916
be okay with the risk of preview features, those types

190
00:13:24,948 --> 00:13:28,216
of permissions. And so feature flags give

191
00:13:28,238 --> 00:13:31,756
us a ton of flexibility. We talked about the branching strategy. I can now have

192
00:13:31,778 --> 00:13:35,356
shortlived lived branches I'm no longer coupled to when I

193
00:13:35,378 --> 00:13:39,116
can merge into my main deployable branches at

194
00:13:39,138 --> 00:13:41,496
any time. I can do that and turn it off with a feature flag.

195
00:13:41,528 --> 00:13:45,056
I can ensure that I don't have multiple active release versions where

196
00:13:45,078 --> 00:13:48,112
I'm keeping different branches per version. I no longer need that because I have a

197
00:13:48,166 --> 00:13:51,664
deployable central main branch and this

198
00:13:51,702 --> 00:13:55,056
is really enabling. True, at least the way that I think it should be

199
00:13:55,078 --> 00:13:59,136
done, which is we're not just integrating in isolation in our feature branches

200
00:13:59,168 --> 00:14:02,496
and validating the build, we're actually integrating as multiple features are developed

201
00:14:02,528 --> 00:14:06,004
in a single branches and validating your code earlier. The fact that I can

202
00:14:06,042 --> 00:14:09,896
see that the refactoring that you're doing while I build my changes just

203
00:14:09,918 --> 00:14:13,400
enables us to be slightly faster and have faster feedback loops.

204
00:14:14,700 --> 00:14:18,056
And of course I can ship faster, right? We're enabled to be a lot

205
00:14:18,078 --> 00:14:22,056
more confident in our deploys, and we do that because

206
00:14:22,158 --> 00:14:25,336
while we're shipping all the time now, we're deploying

207
00:14:25,368 --> 00:14:28,428
as opposed to releasing and our rollback when we do have to roll back a

208
00:14:28,434 --> 00:14:31,240
feature is not a change to the immutable artifacts,

209
00:14:31,320 --> 00:14:34,864
it's actually just a change to the feature flags provider to say turn this off

210
00:14:34,902 --> 00:14:38,796
in a lot of cases. And one of my favorite capabilities

211
00:14:38,828 --> 00:14:42,396
that features gives us is once we are in production,

212
00:14:42,588 --> 00:14:45,708
we can test there. We don't need other environments. We can

213
00:14:45,734 --> 00:14:48,976
easily do a b testing, we can easily use canary releases,

214
00:14:49,088 --> 00:14:52,340
and we can release to a set of users that we want to,

215
00:14:52,410 --> 00:14:56,544
maybe even just ourselves for testing. This enables less environments.

216
00:14:56,672 --> 00:15:00,212
At SPS commerce, we had five environments

217
00:15:00,276 --> 00:15:03,668
at one point in time. Now we have that down to two, using feature flags

218
00:15:03,684 --> 00:15:07,044
where we can contextually give access to certain features in those environments.

219
00:15:07,172 --> 00:15:10,504
There's a huge ridiculous overhead to maintaining five environments,

220
00:15:10,552 --> 00:15:14,460
not just infrastructure costs, but promotional costs and overhead that is just

221
00:15:14,530 --> 00:15:18,108
not necessary, not needed when we have some of these capabilities shifted into the

222
00:15:18,114 --> 00:15:21,548
code base. Of course,

223
00:15:21,634 --> 00:15:24,512
when we think about feature flags, we think about culture as well as a large

224
00:15:24,566 --> 00:15:29,744
aspect, which is this idea that product owners are now involved more

225
00:15:29,782 --> 00:15:33,136
integrated as part of the release process for us. They can make some of those

226
00:15:33,158 --> 00:15:35,590
decisions independently of the deploy process.

227
00:15:37,000 --> 00:15:40,336
And when we think about culture, we think about this new term, progressive delivery,

228
00:15:40,368 --> 00:15:44,176
that you may have heard of. And progressive delivery is defined by launchdarkly

229
00:15:44,208 --> 00:15:48,436
as a modern software development lifecycle that builds upon the core tenets of continuous

230
00:15:48,468 --> 00:15:52,136
integration and continuous delivery. It was a term coined by the

231
00:15:52,158 --> 00:15:55,636
folks over at Redmonk working with Azure DevOps team and exploring

232
00:15:55,668 --> 00:15:59,228
a little bit how Microsoft deploys Azure DevOps using

233
00:15:59,394 --> 00:16:02,924
what they call progressive experimentation and rolling through rings of

234
00:16:02,962 --> 00:16:06,204
release at a time and working with them,

235
00:16:06,242 --> 00:16:08,940
then putting together kind of these concepts.

236
00:16:09,280 --> 00:16:13,260
Launchdarkly then of course a feature flagging

237
00:16:13,340 --> 00:16:16,496
service, the most predominant one, provides us then

238
00:16:16,518 --> 00:16:19,856
with a lot of information about how to use progressive delivery and exactly more what

239
00:16:19,878 --> 00:16:23,380
it means by definition. And these three of them together

240
00:16:23,450 --> 00:16:27,460
then define progressive delivery as not this idea that it's something

241
00:16:27,530 --> 00:16:31,424
above continuous delivery. So it's not like I do continuous integration,

242
00:16:31,472 --> 00:16:35,076
then continuous delivery and then progressive delivery. It's different than

243
00:16:35,098 --> 00:16:38,624
that, right? Progressive delivery is a named pattern that we can use

244
00:16:38,762 --> 00:16:42,008
to achieve continuous delivery, which is the breath of fresh air.

245
00:16:42,094 --> 00:16:44,936
If you've been working in that space long and you know that there are so

246
00:16:44,958 --> 00:16:48,516
many different ways to approach it, and how do you actually achieve continuous

247
00:16:48,548 --> 00:16:52,216
delivery and deployment? Well, progressive delivery is one important way to achieve

248
00:16:52,248 --> 00:16:55,288
that. It has two main tenets worth mentioning.

249
00:16:55,384 --> 00:16:58,668
First is the idea of release progressions. You're familiar with that? The idea I want

250
00:16:58,674 --> 00:17:01,570
to progressively roll out to more and more users at a time.

251
00:17:02,980 --> 00:17:07,004
The second part to that is progressive delegation. And progressive delegation

252
00:17:07,052 --> 00:17:10,368
is this idea going back to the culture we were just talking about where

253
00:17:10,454 --> 00:17:14,450
I want to give control to turn on the features flag basically

254
00:17:14,900 --> 00:17:18,596
to these person who owns it at that given time. It might be the

255
00:17:18,618 --> 00:17:22,128
product owner is a key example. It might be someone else in your pipeline.

256
00:17:22,144 --> 00:17:25,204
As you float through that, the engineer no longer has to worry about, okay,

257
00:17:25,242 --> 00:17:28,756
I'll turn this on when I'm asked by so and so. Well, why would you

258
00:17:28,778 --> 00:17:32,104
turn it on? Just get the person who is owning that particular feature, get them,

259
00:17:32,142 --> 00:17:35,236
delegate it to them, whatever group they're in, in order to enable and roll

260
00:17:35,268 --> 00:17:38,616
that features out. When we

261
00:17:38,638 --> 00:17:42,680
think about software delivery and performance, in my mind, the ultimate goal

262
00:17:42,760 --> 00:17:46,460
is really to deliver high quality software. It has to solve a business problem,

263
00:17:46,610 --> 00:17:50,044
and we need to do it as quickly as possible. Speed to market is important.

264
00:17:50,242 --> 00:17:53,868
I love the state of DevOps report from puppet.

265
00:17:53,964 --> 00:17:57,584
The most recent one, 2021, and the others before it define some

266
00:17:57,622 --> 00:18:01,420
key metrics in helping us understand what are high and elite performers

267
00:18:01,500 --> 00:18:05,488
like in shipping high quality software.

268
00:18:05,664 --> 00:18:09,392
And they talk about these four key metrics that are worth noting.

269
00:18:09,456 --> 00:18:13,264
And the reason they're important is because feature flags can actually help us achieve,

270
00:18:13,312 --> 00:18:17,240
in some cases, a bulk of this or a portion of some of these metrics

271
00:18:18,940 --> 00:18:22,132
pretty easily. So if we look at them, deployment frequency,

272
00:18:22,196 --> 00:18:25,128
how often do you deploy? Well, is that whenever you want?

273
00:18:25,214 --> 00:18:28,296
Well, it could be if we knew our code base was always deployable and we

274
00:18:28,318 --> 00:18:31,816
don't really have the facade of it. Well, it's always deployable. I nerd

275
00:18:31,848 --> 00:18:35,020
something and now you have to wait. It's like, no, it's always deployable because

276
00:18:35,090 --> 00:18:38,780
I wouldn't have something in Maine that wasn't behind a feature flag that was controllable.

277
00:18:39,200 --> 00:18:42,364
So that's a pretty big enable lead time

278
00:18:42,402 --> 00:18:46,336
for changes. Then can I get something from inception out

279
00:18:46,358 --> 00:18:49,116
to production in less than an hour? Well, I could if I had the ability

280
00:18:49,148 --> 00:18:51,836
to use some of these advanced release and contextual techniques.

281
00:18:51,868 --> 00:18:55,136
Right, same with meantime to restore my service goes

282
00:18:55,158 --> 00:18:58,624
down. Can I fix it in less than an hour? Well, typically with feature

283
00:18:58,672 --> 00:19:02,212
flags, yeah, especially if I have operational flags that are helping me support

284
00:19:02,266 --> 00:19:04,884
that and use some knobs and levers in order to restore it quite a bit

285
00:19:04,922 --> 00:19:08,360
faster. And my favorite is change failure rate.

286
00:19:08,430 --> 00:19:11,784
And change failure rate is interesting because in

287
00:19:11,822 --> 00:19:15,224
my mind, it's not a metric that makes sense to me

288
00:19:15,342 --> 00:19:18,536
based on the results of this survey. The idea is, when I do

289
00:19:18,558 --> 00:19:21,916
make a change to production, basically I deploy how often do

290
00:19:21,938 --> 00:19:25,292
you fail? Is it less than 5% of the time? And we know

291
00:19:25,346 --> 00:19:29,244
from these report and from others that the more you deploy, the less you should

292
00:19:29,282 --> 00:19:32,704
fail. Which is weird because you think I'm deploying more often. I should

293
00:19:32,742 --> 00:19:36,448
just fail either the same amount percentage wise or more, maybe even

294
00:19:36,534 --> 00:19:40,112
with the number of complexities that are these. But in reality, the more often

295
00:19:40,166 --> 00:19:43,516
that you deploy, and especially using techniques

296
00:19:43,548 --> 00:19:47,232
like progressive delivery, you fail less. And so I'm excited

297
00:19:47,296 --> 00:19:50,324
that that's also proven true,

298
00:19:50,522 --> 00:19:53,556
obviously with feature flags, because if you're using these techniques, you're going to be able

299
00:19:53,578 --> 00:19:58,280
to much more confidently do those deploys

300
00:19:58,620 --> 00:20:02,216
and degrade and not turn on a particular change on the

301
00:20:02,238 --> 00:20:05,956
entire user basic at a given time. At ESPs commerce, we have a fantastic

302
00:20:05,988 --> 00:20:10,136
continuous improvement team who's been tracking our change rate and

303
00:20:10,158 --> 00:20:13,132
our failure rate at SPS commerce over the last many years.

304
00:20:13,186 --> 00:20:16,636
Going back as far as 2014 and as part of our journey, you can see

305
00:20:16,658 --> 00:20:19,944
that these is exactly proven true by our stats

306
00:20:19,992 --> 00:20:23,856
as well. We do about 1000 changes to production a month now on

307
00:20:23,878 --> 00:20:27,184
our platform and you can see that that change failure rate is just at two

308
00:20:27,222 --> 00:20:31,296
to 2.1%, which is fantastic. Using DevOps best

309
00:20:31,318 --> 00:20:34,660
practices, using patterns like feature flagging.

310
00:20:36,120 --> 00:20:40,084
Enough of that. Let's dive in. Let's actually explore what a feature flag is.

311
00:20:40,202 --> 00:20:43,636
And so I want to examine a really simple feature flag with you today.

312
00:20:43,818 --> 00:20:47,444
And this feature flag is just setting up a new user, maybe in an identity

313
00:20:47,492 --> 00:20:50,648
system or platform of your choice, and it comes in with

314
00:20:50,654 --> 00:20:54,072
a user context object. And that user context object might have

315
00:20:54,126 --> 00:20:57,448
username, might have first name, last name, email on it as

316
00:20:57,454 --> 00:21:00,430
an example, and then it goes ahead and creates that.

317
00:21:02,000 --> 00:21:05,916
Our feature flag then is going to check if Sendgrid email is

318
00:21:05,938 --> 00:21:09,516
enabled. So in this case we're going to send a new welcome user email to

319
00:21:09,538 --> 00:21:13,140
our users if we're using Sendgrid. And that's

320
00:21:13,160 --> 00:21:17,228
our feature flag right there. Sendgrid is a popular software as a service provider

321
00:21:17,244 --> 00:21:20,672
for sending emails by API, and so we want to use that as a simple

322
00:21:20,726 --> 00:21:24,224
integration here. And so the new code will simply say hey, use the API to

323
00:21:24,262 --> 00:21:28,244
send the email. But what does that feature flag if statement actually look like?

324
00:21:28,362 --> 00:21:31,988
In this case, we've hard coded return true, but going back to

325
00:21:31,994 --> 00:21:34,644
our definition of a feature flag, we know that we can't hard code this.

326
00:21:34,682 --> 00:21:38,132
While it might be centralized using a couple spots in our application code

327
00:21:38,186 --> 00:21:41,416
base, we can't hard code it to true

328
00:21:41,438 --> 00:21:43,816
because then we can't modify it from outside the code. We have to be able

329
00:21:43,838 --> 00:21:47,096
to change this behavior easily. So you might in its simplest form change

330
00:21:47,118 --> 00:21:51,160
it to be app configuration usengrid. So just check an app configuration

331
00:21:51,240 --> 00:21:54,750
might be a local file, might be a centralized database key value,

332
00:21:55,200 --> 00:21:58,412
but in reality using it as a microservice makes a lot of sense,

333
00:21:58,466 --> 00:22:01,276
doesn't it? And you could just pass that key along to say, hey, should I

334
00:22:01,298 --> 00:22:03,500
be using this feature Sendgrid?

335
00:22:04,080 --> 00:22:06,896
And that would work. That would tell us whether it's on or off. That could

336
00:22:06,918 --> 00:22:10,256
be on a per environment kind of basis. But we also find

337
00:22:10,278 --> 00:22:13,504
that with feature flags, it's not just simply a new piece

338
00:22:13,542 --> 00:22:16,916
of behavior being added, but it's actually an augmentation. So you often end

339
00:22:16,938 --> 00:22:19,844
up with an if and an ifelse statement like this, where we want to send

340
00:22:19,962 --> 00:22:23,456
local SMTP email is actually the old code and we've

341
00:22:23,488 --> 00:22:25,796
placed it inside the else statement now to separate it out as part of the

342
00:22:25,818 --> 00:22:29,576
feature flag. And while this looks good, we've actually

343
00:22:29,678 --> 00:22:32,904
missed out on a ton of value so far, right? We were not able to

344
00:22:32,942 --> 00:22:36,228
truly test this in production the way we want. If I deployed

345
00:22:36,244 --> 00:22:39,336
this out to production and I had it disabled and I want to enable it

346
00:22:39,358 --> 00:22:43,336
to test well, did I configure the API key right for Sendgrid?

347
00:22:43,448 --> 00:22:46,828
I would actually have to turn and enable that on for everyone. So turn it

348
00:22:46,834 --> 00:22:50,108
on for everyone, test it really quick and prod, and then turn it off if

349
00:22:50,114 --> 00:22:53,036
it was failing. That's not the kind of experience we're going for. That's still an

350
00:22:53,058 --> 00:22:55,852
advantage to ensure I can keep my pipeline moving, but I'm not getting the value

351
00:22:55,906 --> 00:22:58,668
after that. And so the key part here is that we actually need to go

352
00:22:58,674 --> 00:23:02,372
back to our if statement and modify it, so that in this case

353
00:23:02,506 --> 00:23:06,036
the is Sangrid enabled has a user that

354
00:23:06,058 --> 00:23:11,188
we pass into the same user context we had. Then we modify our

355
00:23:11,354 --> 00:23:14,644
check here, our method in the bottom to pass that user context along.

356
00:23:14,682 --> 00:23:18,196
So now in production, I can say, is Sangrid email enabled

357
00:23:18,388 --> 00:23:21,672
for Travis specifically? Right? And I can say, yes it is.

358
00:23:21,726 --> 00:23:25,396
And then we can test out Travis with the welcome email message in production

359
00:23:25,428 --> 00:23:28,670
without affecting anyone. Very, very cool.

360
00:23:29,760 --> 00:23:33,752
However, if you've been following around this conversation

361
00:23:33,816 --> 00:23:37,736
so far, you might have had some important realizations of some questions. And that's

362
00:23:37,768 --> 00:23:41,080
where it kind of comes to this stop of our future flagging honeymoon maybe is

363
00:23:41,090 --> 00:23:43,810
over, because there's some important realizations here.

364
00:23:44,900 --> 00:23:47,570
Let's dive into those and explore them just a little bit.

365
00:23:48,340 --> 00:23:51,808
First would be the idea that we are shifting left, right? So we're moving the

366
00:23:51,814 --> 00:23:55,368
complexity that we had previously in our infrastructure, in our deployment

367
00:23:55,404 --> 00:23:59,140
pipelines, and we're now moving that into the code base where we have the code

368
00:23:59,210 --> 00:24:02,356
that is no longer separate branches for different code

369
00:24:02,378 --> 00:24:05,712
paths, but actually in the same branch is different code paths.

370
00:24:05,856 --> 00:24:09,604
But this is good. I'm actually a fan of this because shifting that left means

371
00:24:09,642 --> 00:24:12,584
that we can handle the complexities of some of these releases in our code base.

372
00:24:12,622 --> 00:24:15,464
We can do interesting things now at the runtime as a part of that.

373
00:24:15,502 --> 00:24:18,570
That's where we get our user context. So that's okay.

374
00:24:19,100 --> 00:24:22,268
But it does mean that our maintainability is affected and you need

375
00:24:22,274 --> 00:24:25,676
to be aware of that. It adds complexity. Right. It's much more

376
00:24:25,698 --> 00:24:28,972
difficult to reason about these state of a system at any given

377
00:24:29,026 --> 00:24:32,112
time because it's no longer, is this features out, yes or no,

378
00:24:32,166 --> 00:24:35,932
a binary decision? It's actually, well, was this features enabled

379
00:24:35,996 --> 00:24:39,440
at that time for that user in these environment?

380
00:24:39,780 --> 00:24:43,328
Much more complex question. And you need to have the observability to answer that in

381
00:24:43,334 --> 00:24:46,852
your log statements. In your other things. When you go to debug a problem,

382
00:24:46,986 --> 00:24:50,884
you can't assume the same things about the system. It's actually not

383
00:24:50,922 --> 00:24:53,430
a binary question anymore, not at all.

384
00:24:54,280 --> 00:24:56,900
Additionally, you have management of the flag.

385
00:24:57,240 --> 00:24:59,736
You need to create these flags, you need to manage the lifecycle of them,

386
00:24:59,758 --> 00:25:03,864
the removal of them, lots of interesting aspects. And of course,

387
00:25:04,062 --> 00:25:07,208
one of the key, I guess, scenarios that I looked at when

388
00:25:07,214 --> 00:25:10,120
I was coming into feature flags is I didn't understand how I could have zero

389
00:25:10,190 --> 00:25:13,356
risk with a feature flag going to production when I have a code change in

390
00:25:13,378 --> 00:25:16,748
my mind. Any code change can result in risk right.

391
00:25:16,834 --> 00:25:20,384
Even behind a feature flag there's still the if statement, the binary decision that

392
00:25:20,422 --> 00:25:24,156
happens that we have to consider is a potential

393
00:25:24,188 --> 00:25:28,384
risk to production. And I have broken production with a feature flag. Absolutely. But in

394
00:25:28,422 --> 00:25:31,808
reality, yes, you're making changes, but we

395
00:25:31,814 --> 00:25:34,796
can unit test those changes pretty easily. And like I said, they're binary decisions.

396
00:25:34,828 --> 00:25:38,644
Typically in a code based perspective, they are things that you will add to a

397
00:25:38,682 --> 00:25:42,116
service that you'll have abstractions for, you'll get good at. You will

398
00:25:42,138 --> 00:25:44,756
practice it and it will become second nature and it's not going to be as

399
00:25:44,778 --> 00:25:48,504
big a problem as you might think. But getting started with it, for sure,

400
00:25:48,542 --> 00:25:50,170
there's risk there to understand.

401
00:25:51,820 --> 00:25:55,464
And the other suggestion here is there's a lot of engineering goes into

402
00:25:55,502 --> 00:25:59,188
building a fully aware user contextual feature management provider.

403
00:25:59,284 --> 00:26:02,796
So you want to be aware of that. And so from your perspective, should you

404
00:26:02,818 --> 00:26:06,536
purchase one, should you build one? I like to stay away from undifferentiated

405
00:26:06,568 --> 00:26:09,244
engineering and this is a great space that you can use one of the other

406
00:26:09,282 --> 00:26:12,108
providers in. Let's take a look at some of those providers so you get an

407
00:26:12,114 --> 00:26:15,552
idea of what we're talking about. Might be as simple as

408
00:26:15,606 --> 00:26:18,924
the simple case, which is a key value pair inside a database or a config

409
00:26:18,972 --> 00:26:22,844
file. Might be AWS like parameter store or Microsoft

410
00:26:22,892 --> 00:26:26,656
Azure, app configuration or even console Zookeeper eTcD

411
00:26:26,688 --> 00:26:29,780
have key value pairs that you can target and use

412
00:26:29,850 --> 00:26:33,732
as a simple method of feature management where you're not going to pay extra.

413
00:26:33,866 --> 00:26:37,556
But if you want to use an open source provider that does provide contextual management,

414
00:26:37,668 --> 00:26:41,256
you might use unleash or flag or flipped. But of course if

415
00:26:41,278 --> 00:26:45,604
you do have the option to use a full service, any of these are fantastic.

416
00:26:45,732 --> 00:26:49,204
Launch directly, of course is the predominant leader and is what we use at SPS

417
00:26:49,252 --> 00:26:52,664
commerce. But when you compare that across features management

418
00:26:52,712 --> 00:26:55,868
providers and on this g two grid, focusing on

419
00:26:55,874 --> 00:26:59,128
the feature management space, you can see that launchdarkly is your clear leader,

420
00:26:59,224 --> 00:27:02,316
kind of in the top right there. From a cost perspective, there might be other

421
00:27:02,338 --> 00:27:05,872
good options that you want to consider, including optimizedly, which is

422
00:27:05,926 --> 00:27:08,608
near the top right there, which is great. And you can see where some of

423
00:27:08,614 --> 00:27:11,910
these other providers that we talked about kind of fall into place.

424
00:27:12,520 --> 00:27:16,196
It's worth noting this extract from a

425
00:27:16,218 --> 00:27:19,616
recent Thoughtworks tech radar. If you're not familiar with TechRadar,

426
00:27:19,728 --> 00:27:23,188
it's I believe, a quarterly release where

427
00:27:23,194 --> 00:27:27,492
they talk about different technologies to adopt different technologies that thoughtworks

428
00:27:27,556 --> 00:27:30,712
consultants have seen over the past few

429
00:27:30,766 --> 00:27:34,424
months and whether it's something that you should consider bringing in or

430
00:27:34,462 --> 00:27:37,896
just spiking and taking a look at. In this

431
00:27:37,918 --> 00:27:41,624
discussion talks about the usage of simplest possible feature flag toggles. The idea

432
00:27:41,662 --> 00:27:45,228
is that you don't necessarily need a full service provider to get started, and it

433
00:27:45,234 --> 00:27:48,488
might just be a barrier to entry, especially from a cost perspective. And while I'm

434
00:27:48,504 --> 00:27:51,484
a big fan of some of these full service providers, depending on what you need

435
00:27:51,522 --> 00:27:54,720
for your application and who your audience is, and if it's an internal only service,

436
00:27:54,790 --> 00:27:58,224
it's not always necessary. So you might consider what are the features are,

437
00:27:58,262 --> 00:28:02,044
what are the release capability, and what is the longevity of your project before deciding

438
00:28:02,092 --> 00:28:05,024
on exactly what level of provider you might need. Okay,

439
00:28:05,062 --> 00:28:08,356
let's move on and take a look at a UI routing example. This takes us

440
00:28:08,378 --> 00:28:11,348
to a little different position than our previous example that we looked at,

441
00:28:11,354 --> 00:28:14,384
our simple example, which is kind of in a backend API.

442
00:28:14,512 --> 00:28:18,552
In this example we will basically trim and change out

443
00:28:18,606 --> 00:28:22,708
navigational structure in a UI web application. This is using Launchdarkly's

444
00:28:22,724 --> 00:28:26,056
feature flag router, which is a react component that

445
00:28:26,078 --> 00:28:29,620
we'll use, and it gives you the ability to specify then this fallback

446
00:28:29,700 --> 00:28:32,748
as well as this new feature. And of course if you don't have access to

447
00:28:32,754 --> 00:28:36,364
the feature, then you get the fallback and the existing feature shows up.

448
00:28:36,402 --> 00:28:39,676
And so really we're just security trimming, but instead of based on security, we're just

449
00:28:39,698 --> 00:28:42,968
doing it based on your feature flag status and the contextual

450
00:28:43,064 --> 00:28:47,288
usage for that particular user. You can see here then how that materializes.

451
00:28:47,384 --> 00:28:51,636
The top screen is demonstrating the react application took

452
00:28:51,658 --> 00:28:54,868
a long time to style it, so I hope you appreciate that. And you can

453
00:28:54,874 --> 00:28:57,876
see where it has the those option and the existing feature. I can click on

454
00:28:57,898 --> 00:29:01,428
it and it shows me existing feature in the URL. If I turn on the

455
00:29:01,434 --> 00:29:05,616
feature flag and launch sharkly turn it on, you can see it immediately materializes

456
00:29:05,648 --> 00:29:09,656
on the top as the new feature without me refreshing the

457
00:29:09,678 --> 00:29:12,996
page. And so another consideration that's different is on the UI

458
00:29:13,108 --> 00:29:17,000
you have to evaluate and change the flags very dynamically. You might have

459
00:29:17,070 --> 00:29:20,188
a web application that is a spa, and that spa could

460
00:29:20,194 --> 00:29:23,788
be living on somebody's desktop for many many weeks,

461
00:29:23,874 --> 00:29:27,628
even potentially without being refreshed. So having a live websocket or

462
00:29:27,634 --> 00:29:31,404
long polling connection that can update that in real time could be very essential

463
00:29:31,452 --> 00:29:35,676
for you also using it on the UI. You now have UI connections

464
00:29:35,788 --> 00:29:39,964
from browsers potentially across the world, as opposed to a backend

465
00:29:40,092 --> 00:29:44,336
API only needs feature flags from internally

466
00:29:44,528 --> 00:29:48,276
and is much lower volume potentially, and much lower,

467
00:29:48,458 --> 00:29:51,604
I guess, access points from

468
00:29:51,642 --> 00:29:55,316
a geography perspective. So you'll need to consider the reality of

469
00:29:55,338 --> 00:29:59,104
well, am I building a UI application? Is live

470
00:29:59,162 --> 00:30:03,108
changes to the flag important when you're deciding on your feature decision provider,

471
00:30:03,204 --> 00:30:05,588
and if you're going to use something simple and build your own, or if you're

472
00:30:05,604 --> 00:30:09,380
going to use a full service provider, you can use

473
00:30:09,550 --> 00:30:12,540
feature flags in many different ways inside APIs.

474
00:30:13,040 --> 00:30:16,264
For example, this users API, you might have an existing V one users

475
00:30:16,312 --> 00:30:19,832
endpoint. You might use a feature flag to enable early or preview

476
00:30:19,896 --> 00:30:23,116
access to a V two profiles URL or address that isn't

477
00:30:23,148 --> 00:30:26,672
normally accessible. You might also use a feature flag to

478
00:30:26,726 --> 00:30:29,936
enable or start shifting engineers over to use V

479
00:30:29,958 --> 00:30:33,424
two users automatically if they're using V one

480
00:30:33,462 --> 00:30:37,076
users. If there's a major shift that's happening, or perhaps you haven't versioned in your

481
00:30:37,098 --> 00:30:40,384
URL, you're versioning in a header and you want to transition some of those default

482
00:30:40,432 --> 00:30:44,404
users over. You might also want to test interesting use

483
00:30:44,442 --> 00:30:48,016
cases, so you might want to validate that. Well, actually in V two users,

484
00:30:48,048 --> 00:30:51,736
what happens in this test case scenario? You might bake that test case as

485
00:30:51,758 --> 00:30:55,224
a feature flag you can turn on to create some failure in the system,

486
00:30:55,342 --> 00:30:58,376
something you don't typically think about doing in production, but you can easily do with

487
00:30:58,398 --> 00:31:01,676
a feature flag. And while feature flags don't give

488
00:31:01,698 --> 00:31:05,016
us the ability to really not version

489
00:31:05,048 --> 00:31:08,508
our APIs, we can get away with some interesting small changes that

490
00:31:08,514 --> 00:31:12,056
you might want to experiment with a bit. Perhaps you've accidentally made

491
00:31:12,098 --> 00:31:16,972
your V one users endpoint with a particular request.

492
00:31:17,036 --> 00:31:20,704
You've accidentally made it a 200 on a operations instead of a 204

493
00:31:20,742 --> 00:31:23,936
where it has no content. You might swap that out and

494
00:31:23,958 --> 00:31:28,000
fix that contract without reversioning the whole thing, even though it is contract breaking,

495
00:31:28,160 --> 00:31:31,364
and then monitor the failure rates automated with it and understand that,

496
00:31:31,402 --> 00:31:34,516
okay, that did not break any of our downstream internal clients. I can go

497
00:31:34,538 --> 00:31:38,004
ahead and just make that change without busting out a whole new

498
00:31:38,042 --> 00:31:41,576
major version on your API. So you have some of these options available to

499
00:31:41,598 --> 00:31:44,468
you in different ways. You can slice the usage of feature flags.

500
00:31:44,644 --> 00:31:48,552
One of my favorite ways that I've seen feature flags used is in

501
00:31:48,606 --> 00:31:51,992
a monolithic pattern where we want to strangle out some microservices.

502
00:31:52,136 --> 00:31:55,784
In this case, this was a monolithic gateway API and a database

503
00:31:55,832 --> 00:31:59,340
behind it, and we wanted to pull out a scheduling API that could be used.

504
00:31:59,410 --> 00:32:03,264
And so we built the scheduling API and the scheduling database, and it was all

505
00:32:03,462 --> 00:32:07,948
new and shiny and had new technologies

506
00:32:08,044 --> 00:32:10,928
that we wanted to use in there. And so what we did then is go

507
00:32:10,934 --> 00:32:14,448
back to connect these two using a feature flag. And the feature flag gives us

508
00:32:14,454 --> 00:32:17,796
the ability to start redirecting read traffic over to the scheduling API and

509
00:32:17,818 --> 00:32:21,156
play around with it a bit, even just for internal users only as a point

510
00:32:21,178 --> 00:32:24,724
of getting started. Of course, they have different databases, so we did have to run

511
00:32:24,762 --> 00:32:28,100
a bi directional real time synchronization

512
00:32:28,760 --> 00:32:32,068
between these models and different transformations that were there.

513
00:32:32,234 --> 00:32:34,628
You might do it a different way, though. If you don't want to synchronize the

514
00:32:34,634 --> 00:32:37,976
data continuously, you might actually change and use two flags

515
00:32:38,008 --> 00:32:40,812
here. An interesting way to approach it would be instead of turning on the read

516
00:32:40,866 --> 00:32:44,184
flag first and testing the load, you might actually just turn on a write flag

517
00:32:44,232 --> 00:32:47,676
that doesn't say write either left or right. It actually says, should I write just

518
00:32:47,698 --> 00:32:50,844
to the old one or should I write to both? You start writing to both,

519
00:32:50,882 --> 00:32:53,330
then after one time synchronization of the data,

520
00:32:54,660 --> 00:32:57,968
and then now you can kind of control that your read flag. Then you would

521
00:32:57,974 --> 00:33:01,456
turn on when you're ready to shift the read traffic for certain users to one

522
00:33:01,478 --> 00:33:05,584
or the other both, continuing to remain in sync as you write to both destinations.

523
00:33:05,712 --> 00:33:08,784
So it's an interesting way that you can start to perform some traffic

524
00:33:08,832 --> 00:33:12,336
shaping and some migrations and be very successful.

525
00:33:12,448 --> 00:33:15,140
In our examples of doing this at SPS Commerce,

526
00:33:15,640 --> 00:33:18,904
we turned that flag on and off several times and discovered a lot

527
00:33:18,942 --> 00:33:23,044
of production load issues that you could only really discover in production.

528
00:33:23,172 --> 00:33:26,504
Right. And we were able to affect very little users as part of that,

529
00:33:26,542 --> 00:33:28,860
if not any, just by doing it internally.

530
00:33:30,560 --> 00:33:34,028
You might also use feature flags for coordination. I might use the

531
00:33:34,034 --> 00:33:37,496
same feature flag in the UI in a public API, maybe an internal

532
00:33:37,528 --> 00:33:40,952
API, and then turn on together a feature

533
00:33:41,016 --> 00:33:43,824
in coordination. Now there are implications to that.

534
00:33:43,862 --> 00:33:47,568
Obviously, I want to be able to just turn on a feature, maybe in the

535
00:33:47,574 --> 00:33:50,844
UI without turning on everywhere for personal testing and production.

536
00:33:50,892 --> 00:33:54,640
So maybe I actually want these to be independent feature flags.

537
00:33:54,980 --> 00:33:58,468
But depending on how you slice it, you'll have to consider whether you have a

538
00:33:58,474 --> 00:34:01,988
single flag or different flags. And this starts getting into architecting how you're going

539
00:34:01,994 --> 00:34:06,080
to use your flags across your organization. And unfortunately,

540
00:34:06,240 --> 00:34:09,892
there's other considerations here. You might have to consider, well, what is my user context

541
00:34:10,036 --> 00:34:13,272
if I want to enable this? For a user in UI and a user in

542
00:34:13,326 --> 00:34:16,680
internal one API, those might have two completely

543
00:34:16,750 --> 00:34:20,088
different contexts, and that makes it difficult for me to manage a single flag across

544
00:34:20,174 --> 00:34:23,912
those. And we haven't talked a lot about user context

545
00:34:23,976 --> 00:34:26,936
and so this is a good area to define a little bit about that user

546
00:34:26,968 --> 00:34:30,824
context and what it could be. We talked earlier about how the user context

547
00:34:30,872 --> 00:34:34,464
could be first name, last name, email, could be some type

548
00:34:34,502 --> 00:34:37,996
of user identifier in your system, could be additional user

549
00:34:38,028 --> 00:34:41,408
details that you want to include there for easy reference. You got

550
00:34:41,414 --> 00:34:44,528
to think about from a delegation of that flag will

551
00:34:44,614 --> 00:34:48,084
downstream delegation of it want to use first

552
00:34:48,122 --> 00:34:50,948
name and last name or email in order to target users? How you want to

553
00:34:50,954 --> 00:34:54,096
target it is critical. And so when you're thinking about targeting,

554
00:34:54,288 --> 00:34:58,664
targeting by individual users is nice, especially for testing in

555
00:34:58,702 --> 00:35:02,180
production for your own feature that you're building as an engineer,

556
00:35:02,260 --> 00:35:05,576
but in reality turning it on as a role or a particular

557
00:35:05,678 --> 00:35:09,252
group or an organization, or even internal versus

558
00:35:09,316 --> 00:35:12,604
external employee. Sorry, internal employees versus external customers.

559
00:35:12,722 --> 00:35:15,848
Or even if you have a set of beta customers, you don't have to define

560
00:35:15,864 --> 00:35:18,616
that and do it in a consistent way across your organization.

561
00:35:18,808 --> 00:35:22,264
And that might be something for you to think about as you're architecting it.

562
00:35:22,402 --> 00:35:26,352
In this example here, you can see I'm using user id 123456.

563
00:35:26,406 --> 00:35:30,880
My name is Travis Goslin. I'm initializing in one provider there,

564
00:35:30,950 --> 00:35:34,348
but in another application I might initialize it totally separately. I might initialize

565
00:35:34,364 --> 00:35:37,316
it. Yeah, the user id is the same. So if I target the user id,

566
00:35:37,418 --> 00:35:40,788
I'll get the same consistent feature flag turned on. But if I were

567
00:35:40,794 --> 00:35:44,276
to target this flag and use first name, am I going to get a

568
00:35:44,298 --> 00:35:47,604
consistent enablement of it across applications in coordinating?

569
00:35:47,732 --> 00:35:51,016
No. In fact, these contacts are not equal to each

570
00:35:51,038 --> 00:35:54,712
other at all. Those could be even derived as two different users, and there may

571
00:35:54,766 --> 00:35:58,708
even be a potential monetary problem associated

572
00:35:58,724 --> 00:36:02,616
with that configuration. By that I mean if these are coming out as different users,

573
00:36:02,648 --> 00:36:05,676
you might actually be paying them for twice as many users across your system as

574
00:36:05,698 --> 00:36:10,060
not. So you want to think ahead, you want to provide these, the capability

575
00:36:10,960 --> 00:36:14,064
and an organized strategy in your organization of how you'll use these.

576
00:36:14,182 --> 00:36:18,220
As an example, in our organization we only use the

577
00:36:18,300 --> 00:36:21,836
level component and so we don't actually allow targeting by individual users

578
00:36:21,868 --> 00:36:25,456
unless they're internal. External users are only ever enabled@the.org

579
00:36:25,488 --> 00:36:29,204
level, which is basically a company, a connection within

580
00:36:29,242 --> 00:36:32,624
our network. And that made a lot of sense for how we strategically

581
00:36:32,672 --> 00:36:36,356
position feature flags in our applications. As you

582
00:36:36,378 --> 00:36:39,340
may be realizing, there are so many other scenarios that you can use feature flags

583
00:36:39,360 --> 00:36:43,016
for the sky is really the limit you think about log level verbosity and

584
00:36:43,038 --> 00:36:45,752
the idea that I could have something in production and change it to a lower

585
00:36:45,806 --> 00:36:49,300
level more verbose level of logging.

586
00:36:49,380 --> 00:36:52,456
You could even do that automatically and change a feature flag based on an incoming

587
00:36:52,488 --> 00:36:55,756
error rate. That'd be pretty cool. You might want

588
00:36:55,778 --> 00:36:59,132
to use dynamic configuration, so it's not just a Boolean value

589
00:36:59,186 --> 00:37:02,940
for a feature flag. It can be JSOn blobs or multivariate configurations.

590
00:37:03,360 --> 00:37:06,364
You might want to use kill switches. So the idea that I want to disable

591
00:37:06,412 --> 00:37:10,128
a third party that's acting up, perhaps we are having an issue with a particular

592
00:37:10,214 --> 00:37:14,016
service that's really degrading some of our performance. And so we can

593
00:37:14,038 --> 00:37:16,836
turn off that service, whether it be on the front end or turn off a

594
00:37:16,858 --> 00:37:20,804
feature. Having the ability to kill something is

595
00:37:20,842 --> 00:37:23,796
important, especially as you're putting out there for the first time. Or you can think

596
00:37:23,818 --> 00:37:27,376
about our migration scenario where we killed the new service, the scheduling

597
00:37:27,408 --> 00:37:30,730
API, and shifted back and forth as we needed until we got it right.

598
00:37:31,180 --> 00:37:34,916
We talk a lot about feature flags for the creation of new features,

599
00:37:34,948 --> 00:37:38,296
but you can also sunset features with it in an interesting way. So as

600
00:37:38,318 --> 00:37:41,144
an example you might say, well, I'll place a stake in the sand now,

601
00:37:41,182 --> 00:37:43,788
so no net new customers are going to get this feature, and then I take

602
00:37:43,794 --> 00:37:47,416
it away from them. And then you can pass it off to your marketing

603
00:37:47,448 --> 00:37:51,676
team, to your customer success team in order to work with your existing customers to

604
00:37:51,778 --> 00:37:54,816
downgrade that particular feature, remove it from them as they're able to

605
00:37:54,838 --> 00:37:58,556
do so, goes back to our progressive delegation as a part of progressive delivery

606
00:37:58,588 --> 00:38:02,160
capability. And of course, timed features are always

607
00:38:02,230 --> 00:38:05,428
cool and interesting. You have the ability to think about a timed feature in

608
00:38:05,434 --> 00:38:09,284
the sense of holiday release, something that you

609
00:38:09,322 --> 00:38:13,540
want to specify for a certain schedule, for its appearance.

610
00:38:14,120 --> 00:38:17,424
And while that's all the time we have for today talking about feature flags,

611
00:38:17,472 --> 00:38:20,884
there are obviously many other topics to dive into and explore as you architect

612
00:38:20,932 --> 00:38:24,216
feature flags across your organization. But I think you'll find that if

613
00:38:24,238 --> 00:38:28,172
you separate out, deploy and release and decouple them from each other,

614
00:38:28,306 --> 00:38:31,928
the value that that provides in terms of velocity, true CI

615
00:38:32,024 --> 00:38:35,644
decoupling, testing and production is

616
00:38:35,682 --> 00:38:38,908
just very high and very

617
00:38:38,994 --> 00:38:42,224
valuable in what is provided to SPS commerce and encourage you. If you're not using

618
00:38:42,262 --> 00:38:45,820
feature flags, this is a place that you want to explore

619
00:38:45,980 --> 00:38:49,520
to be high or a lead performer. In DevOps,

620
00:38:50,980 --> 00:38:54,556
however, we did talk about a little bit of it. It's not free,

621
00:38:54,598 --> 00:38:58,020
right? There's a price to pay for some of these things. I am changing code.

622
00:38:58,090 --> 00:39:01,636
There is still risk. There is additional complexities here to

623
00:39:01,658 --> 00:39:05,300
worry about, especially observability. But I do believe that it is absolutely

624
00:39:05,370 --> 00:39:07,988
worth it for the value you're going to get. And I do think that a

625
00:39:07,994 --> 00:39:11,092
lot of those risks mitigate as you practice it and as it becomes just another

626
00:39:11,146 --> 00:39:14,228
one of your patterns. So thank you.

627
00:39:14,314 --> 00:39:17,896
Happy to reach out and chat some more about future flags.

628
00:39:18,008 --> 00:39:18,330
Take care.

