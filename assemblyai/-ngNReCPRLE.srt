1
00:00:19,930 --> 00:00:23,470
Hi and welcome to my session about

2
00:00:23,540 --> 00:00:27,174
test driven development. Went with Golang. First of

3
00:00:27,212 --> 00:00:30,710
all, I would like to thanks the organization

4
00:00:31,050 --> 00:00:34,854
for giving me this amazing opportunity to

5
00:00:34,892 --> 00:00:37,458
be able to speak in front of you.

6
00:00:37,644 --> 00:00:41,466
First, let me introduce myself who I am,

7
00:00:41,648 --> 00:00:45,802
what I do I'm Ivan Pesenti, 27 years

8
00:00:45,856 --> 00:00:49,858
old and I worked as a software developer

9
00:00:49,974 --> 00:00:53,918
since 2014. After my school years

10
00:00:54,084 --> 00:00:57,854
I work remotely for a global company which

11
00:00:57,892 --> 00:01:01,530
is Solintlab. I'm mostly experienced

12
00:01:01,610 --> 00:01:05,870
in server side programming. Part of my daily

13
00:01:05,950 --> 00:01:09,422
tech stack involve Go postgres,

14
00:01:09,486 --> 00:01:14,110
SQL, AWS, platform Docker,

15
00:01:14,190 --> 00:01:18,738
docker compose and some other minor technologies.

16
00:01:18,914 --> 00:01:22,706
I strongly believe in values such as kindness,

17
00:01:22,818 --> 00:01:26,978
sharing and determination. In my spare time I'm

18
00:01:27,074 --> 00:01:31,034
involved within a lot of activities such

19
00:01:31,072 --> 00:01:35,718
as speaking, training, technical writing

20
00:01:35,894 --> 00:01:39,482
and also mentoring. I've just finished my

21
00:01:39,536 --> 00:01:42,922
first course about Golang and tests.

22
00:01:43,066 --> 00:01:46,670
I love also anime, tattoo and football

23
00:01:47,170 --> 00:01:50,798
in what this session will be different from others

24
00:01:50,884 --> 00:01:52,960
that you may joined before.

25
00:01:53,730 --> 00:01:58,186
This session won't rely on trivial examples,

26
00:01:58,298 --> 00:02:01,940
okay, such as most of the tutorial out there.

27
00:02:02,310 --> 00:02:07,082
But in this session you will make your handlers DRT

28
00:02:07,246 --> 00:02:10,854
with a real world application. So you

29
00:02:10,892 --> 00:02:15,046
will be able to apply test driven development in a

30
00:02:15,068 --> 00:02:18,934
real world application. Not only a trivial Qatar

31
00:02:19,062 --> 00:02:23,354
such as a simple program to sum up two numbers,

32
00:02:23,552 --> 00:02:28,102
or a simple Qatar such as Fitzbuds

33
00:02:28,246 --> 00:02:31,886
or Fibonacci or all of that stuff. Here we

34
00:02:31,908 --> 00:02:36,302
are going to build a real application. Plus you

35
00:02:36,356 --> 00:02:39,722
will be aware of the theoretical introduction

36
00:02:39,786 --> 00:02:43,522
about tests and code coverage, and a good

37
00:02:43,576 --> 00:02:47,090
part of this demo will be about Golang

38
00:02:47,830 --> 00:02:51,854
which will be our chosen programming

39
00:02:51,902 --> 00:02:55,446
languages. So you will learn how to write good,

40
00:02:55,548 --> 00:02:58,406
clean and idiomatic go code.

41
00:02:58,588 --> 00:03:02,022
Also, I'm going to share some of my experience

42
00:03:02,156 --> 00:03:05,526
with the tests. How do I mock a

43
00:03:05,548 --> 00:03:09,274
database? And how do I mock the

44
00:03:09,312 --> 00:03:12,460
service that made up my application?

45
00:03:13,070 --> 00:03:17,558
First, let's start with a small, boring introduction

46
00:03:17,734 --> 00:03:21,582
about test driven development that for sure most

47
00:03:21,636 --> 00:03:25,806
of you will already know. The test driven development is

48
00:03:25,828 --> 00:03:29,870
an ethereum iterative cycle which involves three

49
00:03:29,940 --> 00:03:34,098
parts is known also as red green

50
00:03:34,184 --> 00:03:37,314
refactor phases. We all start from the

51
00:03:37,352 --> 00:03:41,294
red phase where we have to write a failing

52
00:03:41,342 --> 00:03:44,862
test. Then we have to

53
00:03:44,936 --> 00:03:49,014
move as fast as we can out of this and enter

54
00:03:49,132 --> 00:03:53,014
the green area in which we have to fix

55
00:03:53,132 --> 00:03:55,794
our broken tests. Lastly,

56
00:03:55,922 --> 00:03:59,338
we'll move to the refactor phase in which

57
00:03:59,424 --> 00:04:03,034
we can make all of the improvements to our code

58
00:04:03,152 --> 00:04:06,406
that is certified by tests

59
00:04:06,518 --> 00:04:08,570
that are running successfully.

60
00:04:11,170 --> 00:04:15,146
The mantra of test driven development

61
00:04:15,338 --> 00:04:19,066
is made up of three simple rules.

62
00:04:19,178 --> 00:04:23,086
We have to follow this rule. As a rule

63
00:04:23,118 --> 00:04:26,814
of thumb, we have to be self disciplinate

64
00:04:26,942 --> 00:04:31,090
in order to be successful with test driven development.

65
00:04:31,430 --> 00:04:35,246
So let's deep dive into them. The first one

66
00:04:35,368 --> 00:04:38,502
is that we are not allowed to write

67
00:04:38,636 --> 00:04:42,374
any production code unless it is to

68
00:04:42,412 --> 00:04:45,480
make a failing unit test pass.

69
00:04:45,850 --> 00:04:49,718
That means that first we have to write tests

70
00:04:49,814 --> 00:04:52,730
and then we can write production code,

71
00:04:52,880 --> 00:04:56,906
not the opposite. Second rule is we

72
00:04:56,928 --> 00:05:00,646
are not allowed to write more of a unit

73
00:05:00,678 --> 00:05:04,250
test than is sufficient to fail,

74
00:05:04,410 --> 00:05:07,642
and compilation failures are failures.

75
00:05:07,786 --> 00:05:11,502
This is pretty self explanatory. We can write only

76
00:05:11,556 --> 00:05:15,170
one unit test failing, okay?

77
00:05:15,320 --> 00:05:18,994
And the first ideal test that we have

78
00:05:19,032 --> 00:05:23,234
to write is a compilation failure because

79
00:05:23,352 --> 00:05:27,062
we didn't have write the production code yet.

80
00:05:27,196 --> 00:05:30,582
The final rule is that

81
00:05:30,636 --> 00:05:33,814
we are not allowed to write any more

82
00:05:33,852 --> 00:05:37,882
production code than it's sufficient to pass the one

83
00:05:37,936 --> 00:05:42,058
failing unit test. So we have to write

84
00:05:42,224 --> 00:05:45,354
only the list code to

85
00:05:45,392 --> 00:05:49,254
make a building test running correctly.

86
00:05:49,382 --> 00:05:52,814
Okay. No fancy other thing,

87
00:05:52,932 --> 00:05:56,750
only the working code, the minimum working code.

88
00:05:56,820 --> 00:06:00,346
I will say a basic building blocks

89
00:06:00,458 --> 00:06:03,778
of unit of test driven development is

90
00:06:03,864 --> 00:06:06,980
test, but only clean test.

91
00:06:07,350 --> 00:06:11,166
Because in order to be successful with test driven

92
00:06:11,198 --> 00:06:14,698
development, it's better to write clean tests.

93
00:06:14,894 --> 00:06:18,578
That is always a good thing. What are the aspect

94
00:06:18,674 --> 00:06:22,200
and key characteristics of a clean test?

95
00:06:23,050 --> 00:06:27,590
First, it must obey to the triple h paradigm,

96
00:06:28,350 --> 00:06:31,126
which is the acronym for arrange,

97
00:06:31,238 --> 00:06:35,258
act and assert. These three parts should be

98
00:06:35,344 --> 00:06:38,650
distinct in our test code.

99
00:06:38,720 --> 00:06:42,414
In our test function, we don't have

100
00:06:42,452 --> 00:06:44,974
to mix and match them.

101
00:06:45,172 --> 00:06:48,590
Second, our test must

102
00:06:48,660 --> 00:06:51,934
not contain code smells that are not

103
00:06:51,972 --> 00:06:55,490
errors, but something that smell.

104
00:06:56,150 --> 00:06:59,394
For example, a function that has

105
00:06:59,512 --> 00:07:02,580
tons of parameters. Okay,

106
00:07:03,110 --> 00:07:07,254
an easy fix for this is to build a

107
00:07:07,292 --> 00:07:11,286
struct in order to gator and collect all of

108
00:07:11,308 --> 00:07:15,430
them into a structured format.

109
00:07:15,770 --> 00:07:19,514
Third point is the test must

110
00:07:19,552 --> 00:07:23,722
not contain magic numbers. With magic numbers, I also

111
00:07:23,776 --> 00:07:27,862
refer to magic strings, which are literals

112
00:07:28,006 --> 00:07:32,458
spread into our code that can bring magic

113
00:07:32,554 --> 00:07:36,542
into our code. Okay? Because if they

114
00:07:36,596 --> 00:07:40,634
don't have any meaning, they are just literals.

115
00:07:40,762 --> 00:07:45,422
The easy fix for this is to extrapolate these values

116
00:07:45,566 --> 00:07:49,394
and create constants that will

117
00:07:49,432 --> 00:07:53,266
be referred to throughout the rest of our program.

118
00:07:53,448 --> 00:07:56,374
A test must have a meaningful name.

119
00:07:56,572 --> 00:08:00,630
From the name we can assume, which are

120
00:08:00,700 --> 00:08:04,610
its input and which are its output.

121
00:08:04,770 --> 00:08:09,222
And the last one, taken directly from the test driven development

122
00:08:09,286 --> 00:08:13,082
manifesto, is that a clean test should follow

123
00:08:13,216 --> 00:08:17,178
the first principle, which is the acronym for

124
00:08:17,344 --> 00:08:21,986
fast, independent, repeatable, self validating,

125
00:08:22,118 --> 00:08:25,022
and through test. Okay,

126
00:08:25,156 --> 00:08:29,342
before going ahead, let's spend a couple of minutes talking

127
00:08:29,396 --> 00:08:33,266
about code coverage, which is one of the

128
00:08:33,288 --> 00:08:36,782
most important aspect when it comes to test driven

129
00:08:36,846 --> 00:08:40,034
development. Code coverage, as most of

130
00:08:40,072 --> 00:08:44,002
you surely knows, is how much code is

131
00:08:44,056 --> 00:08:47,418
covered by tests and the code covered

132
00:08:47,454 --> 00:08:51,382
is the production code. I mean, there are three

133
00:08:51,436 --> 00:08:54,390
different kinds of code coverage,

134
00:08:54,730 --> 00:08:58,694
the function, the statement and the branch coverage.

135
00:08:58,822 --> 00:09:02,906
During this demo, we are only interested at

136
00:09:03,008 --> 00:09:07,242
statement coverage and a

137
00:09:07,296 --> 00:09:11,230
common misconception is that you have to

138
00:09:11,380 --> 00:09:14,942
reach and aim 100% of

139
00:09:14,996 --> 00:09:19,294
code coverage in your code. However, this is

140
00:09:19,332 --> 00:09:23,154
not mandatory at all. What is important is to cover the

141
00:09:23,192 --> 00:09:26,930
most critical business logic part within

142
00:09:27,000 --> 00:09:30,900
our solution, within our program. Not everything.

143
00:09:31,350 --> 00:09:34,990
If we follow the test driven development approach,

144
00:09:35,150 --> 00:09:39,042
we'll always have this 100% code coverage

145
00:09:39,186 --> 00:09:42,694
because first we have to write test and

146
00:09:42,732 --> 00:09:45,400
then we can write production code.

147
00:09:46,330 --> 00:09:50,540
Let's barst another mice. This mice is

148
00:09:50,910 --> 00:09:55,206
test driven development is not about testing

149
00:09:55,398 --> 00:09:57,530
but about designing,

150
00:09:58,270 --> 00:10:01,646
okay? In fact, test is

151
00:10:01,668 --> 00:10:05,882
a very good nice to have, but it's not the main purpose

152
00:10:05,946 --> 00:10:09,822
of test driven development, which is to

153
00:10:09,876 --> 00:10:14,294
help you design your solution with the tests.

154
00:10:14,442 --> 00:10:17,986
Okay? So you have to hear for the

155
00:10:18,008 --> 00:10:21,826
feedback provided by your tests and make

156
00:10:21,928 --> 00:10:25,906
the needed adjustment in the solution,

157
00:10:26,098 --> 00:10:30,086
in the design of the solution. I know

158
00:10:30,188 --> 00:10:31,990
this is a common reaction.

159
00:10:34,250 --> 00:10:37,790
Okay, in order to be more practical

160
00:10:37,970 --> 00:10:41,994
in this demo, we are going to rely on

161
00:10:42,112 --> 00:10:44,778
the to do application. Okay,

162
00:10:44,944 --> 00:10:49,158
so we are going to build the edit

163
00:10:49,334 --> 00:10:52,766
handlers function, which is by far the

164
00:10:52,788 --> 00:10:55,838
most difficult one, usually because it involves a

165
00:10:55,844 --> 00:10:59,040
lot of different scenarios. Okay,

166
00:11:01,410 --> 00:11:05,502
let's focus on what we get in. We'll accept

167
00:11:05,566 --> 00:11:08,914
an HTTP request, which method will be

168
00:11:08,952 --> 00:11:12,706
the put method, which is reserved for the

169
00:11:12,808 --> 00:11:15,640
edit operation. Okay,

170
00:11:16,250 --> 00:11:20,978
the route is to DOS colonid,

171
00:11:21,154 --> 00:11:24,690
in which colon id is a route parameter

172
00:11:24,850 --> 00:11:28,074
that we expect in perequest p

173
00:11:28,112 --> 00:11:31,738
load will looks like something similar

174
00:11:31,904 --> 00:11:36,010
to the snippet of code in the right section,

175
00:11:36,830 --> 00:11:39,050
which has three keys.

176
00:11:39,550 --> 00:11:42,782
Description of type string, which is the

177
00:11:42,836 --> 00:11:46,526
to do description is completed. It's a

178
00:11:46,548 --> 00:11:50,480
boolean value that determine if

179
00:11:50,930 --> 00:11:53,780
the to do is completed or not,

180
00:11:54,230 --> 00:11:58,530
and the due date is a string value that

181
00:11:58,600 --> 00:12:02,034
represents the deadline for our to do to be

182
00:12:02,072 --> 00:12:05,302
completed. One of the most

183
00:12:05,356 --> 00:12:09,654
important part about test driven development is

184
00:12:09,772 --> 00:12:12,866
to identify the possible outcome

185
00:12:13,058 --> 00:12:17,074
that our code can take. Okay? So it's

186
00:12:17,122 --> 00:12:21,862
very important to define the possible scenarios.

187
00:12:22,006 --> 00:12:26,010
If you don't do this, you cannot be successfully with

188
00:12:26,080 --> 00:12:30,220
test driven development. I did this

189
00:12:31,810 --> 00:12:35,566
and I can summarize the five possible scenarios in

190
00:12:35,588 --> 00:12:39,422
this list. The first scenario is

191
00:12:39,476 --> 00:12:42,720
when we pass in an invalid id.

192
00:12:43,110 --> 00:12:46,546
Remember, the id is passed in as a

193
00:12:46,568 --> 00:12:50,466
route parameter. For example, we are going to pass in

194
00:12:50,568 --> 00:12:54,580
ABC instead of an integer number.

195
00:12:55,130 --> 00:12:58,630
So in this case we'll expect back a 400

196
00:12:58,700 --> 00:13:02,546
bad request status code. The second scenario

197
00:13:02,658 --> 00:13:06,610
is when the request payload is not valid.

198
00:13:06,770 --> 00:13:10,374
Okay, for example, the request

199
00:13:10,422 --> 00:13:14,362
payload has the description set to string empty. That's not

200
00:13:14,416 --> 00:13:18,250
possible. So we would like to have back a 400 bad

201
00:13:18,320 --> 00:13:22,138
request status code. The third scenario

202
00:13:22,314 --> 00:13:26,026
is when there are some unknown database error,

203
00:13:26,138 --> 00:13:29,840
okay, such as connectivity issue or

204
00:13:30,210 --> 00:13:33,538
other stuff like that. In this case

205
00:13:33,624 --> 00:13:37,438
we would like to have back a 500 internal

206
00:13:37,534 --> 00:13:41,438
server error. The fourth

207
00:13:41,534 --> 00:13:45,730
scenario is when the to do is not found in our database.

208
00:13:45,890 --> 00:13:49,286
And in this case we would like to have back a

209
00:13:49,308 --> 00:13:53,110
404 status not found error.

210
00:13:54,170 --> 00:13:57,650
The last one is the positive path, okay,

211
00:13:57,820 --> 00:14:01,610
when everything goes fine. And in this case

212
00:14:01,680 --> 00:14:05,814
we would like to have the 202 status accepted status

213
00:14:05,862 --> 00:14:10,410
code without an empty response payload.

214
00:14:11,170 --> 00:14:15,600
All right, the ingredients of our

215
00:14:15,970 --> 00:14:19,114
session, we can divide

216
00:14:19,162 --> 00:14:22,522
them into two categories. The first

217
00:14:22,596 --> 00:14:27,166
is related to production code. The demo is realized

218
00:14:27,278 --> 00:14:31,122
with the gene web framework that is

219
00:14:31,176 --> 00:14:34,306
the de facto standard when it

220
00:14:34,328 --> 00:14:38,406
comes to designing and building a

221
00:14:38,428 --> 00:14:42,454
web service. Recently the

222
00:14:42,492 --> 00:14:46,818
other competitor, which is GorillaMax, was publicly

223
00:14:46,914 --> 00:14:50,598
archived, so it's no longer maintained.

224
00:14:50,774 --> 00:14:54,566
So this event forced us to switch

225
00:14:54,678 --> 00:14:58,618
to a still maintained solution and we started

226
00:14:58,704 --> 00:15:03,200
to use gin which has

227
00:15:04,050 --> 00:15:07,434
more or less 70,000 of stars

228
00:15:07,562 --> 00:15:10,858
in GitHub, while Gorilla Max,

229
00:15:11,034 --> 00:15:15,002
it has only 20,000 of stars.

230
00:15:15,146 --> 00:15:19,426
So I think it will still be a valid option to follow.

231
00:15:19,608 --> 00:15:23,230
Second is gorm, which is the package

232
00:15:23,390 --> 00:15:26,118
for using an ORM with go.

233
00:15:26,284 --> 00:15:29,000
If you are going to build a real world application,

234
00:15:29,370 --> 00:15:33,670
chances are that you are going to rely on an Orm.

235
00:15:34,170 --> 00:15:38,202
Not always, but probably so that's why I

236
00:15:38,256 --> 00:15:41,274
introduced it in this demo,

237
00:15:41,392 --> 00:15:45,162
so you can make out the most of it. The third

238
00:15:45,216 --> 00:15:49,162
one is the postgres driver, which is the

239
00:15:49,216 --> 00:15:54,030
driver that are actually used to talk to our database.

240
00:15:54,450 --> 00:15:57,982
While for the test code we are going to relying on

241
00:15:58,116 --> 00:16:03,410
testing package which is part of the Go standard library.

242
00:16:03,750 --> 00:16:07,470
Conversely to other programming languages,

243
00:16:07,630 --> 00:16:11,554
with go we don't have to bring in any frameworks in

244
00:16:11,592 --> 00:16:14,842
order to be able to write tests.

245
00:16:15,006 --> 00:16:17,682
So that's awesome in my opinion.

246
00:16:17,826 --> 00:16:21,202
The second package is Go SQL mock,

247
00:16:21,346 --> 00:16:25,490
which is the most used package for mocking

248
00:16:25,650 --> 00:16:29,130
an actual database. Thanks to it

249
00:16:29,280 --> 00:16:33,930
we can postpone the decision about the database

250
00:16:34,350 --> 00:16:38,138
engine that we are going to use to the latest part of the project

251
00:16:38,304 --> 00:16:41,882
and program against an abstract

252
00:16:41,946 --> 00:16:46,558
layer, let's say. Okay, which decouple the actual

253
00:16:46,724 --> 00:16:50,974
underlying database. The third package is

254
00:16:51,012 --> 00:16:54,942
the subpackage assert provided by the testify package.

255
00:16:55,086 --> 00:16:58,206
Thanks to it, it's easier to do assertion

256
00:16:58,318 --> 00:17:02,418
in our code. Last one is the HTTP test

257
00:17:02,504 --> 00:17:06,406
sub package which assists us in building

258
00:17:06,588 --> 00:17:10,934
HTTP response and HTTP request without

259
00:17:11,052 --> 00:17:15,080
worrying too much about the protocol stuff.

260
00:17:16,330 --> 00:17:19,946
Okay, we already talked a lot. Now if

261
00:17:19,968 --> 00:17:23,322
you are ready like me. Let's switch to vs code

262
00:17:23,456 --> 00:17:27,322
and start. Make your hands dirty. All right,

263
00:17:27,456 --> 00:17:31,338
we are in vs code. Now let's start building

264
00:17:31,424 --> 00:17:35,094
our application about handling the edit

265
00:17:35,142 --> 00:17:37,840
route of our to do app application.

266
00:17:38,210 --> 00:17:42,074
First of all, I've opened a folder in my vs

267
00:17:42,122 --> 00:17:46,274
code. The folder is called to do app and

268
00:17:46,312 --> 00:17:50,626
the first thing that we have to do is to initialize a

269
00:17:50,648 --> 00:17:53,806
module. So we run go mode

270
00:17:53,838 --> 00:17:57,110
init followed by the name of the module.

271
00:17:58,010 --> 00:18:00,520
In our example is to do app.

272
00:18:02,010 --> 00:18:07,286
There we go. Then we

273
00:18:07,308 --> 00:18:10,126
have to define the handlers,

274
00:18:10,258 --> 00:18:14,522
right? So what is

275
00:18:14,576 --> 00:18:18,342
meant to deal the HTTP request and reply

276
00:18:18,406 --> 00:18:21,994
with an HTTP response? First thing to

277
00:18:22,032 --> 00:18:26,890
do is to create a folder called handlers.

278
00:18:27,890 --> 00:18:31,502
Within that folder we are going to create our first

279
00:18:31,556 --> 00:18:35,134
file called handlers underscore

280
00:18:35,182 --> 00:18:37,380
test go.

281
00:18:39,350 --> 00:18:43,250
We define the package name that is handlers

282
00:18:43,830 --> 00:18:45,140
and there we go.

283
00:18:47,290 --> 00:18:50,710
Now before moving ahead, let's recap

284
00:18:51,130 --> 00:18:54,374
in a list this scenario that we have to manage.

285
00:18:54,572 --> 00:18:57,670
The first one is id, not integer.

286
00:18:59,870 --> 00:19:02,890
The second one is validation error.

287
00:19:04,270 --> 00:19:07,210
The third one is db error.

288
00:19:08,430 --> 00:19:11,902
The fourth is to do not

289
00:19:11,956 --> 00:19:15,262
found, and the last

290
00:19:15,316 --> 00:19:17,630
one is the FP path.

291
00:19:21,570 --> 00:19:24,738
Well now let's start by defining our first

292
00:19:24,824 --> 00:19:25,460
test.

293
00:19:32,390 --> 00:19:35,534
The test name must must

294
00:19:35,592 --> 00:19:38,280
be prefixed with the right test,

295
00:19:38,730 --> 00:19:42,854
then followed by the name of the function that we are willing to test.

296
00:19:43,052 --> 00:19:47,694
In our case is update to do in the signature

297
00:19:47,842 --> 00:19:51,626
we have to involve the t parameter which

298
00:19:51,648 --> 00:19:56,198
is of type pointer to t provided

299
00:19:56,294 --> 00:20:00,278
in the testing package. If we save

300
00:20:00,384 --> 00:20:04,446
it automatically import in

301
00:20:04,468 --> 00:20:07,150
the import section the testing package.

302
00:20:07,650 --> 00:20:10,782
Now let's start by setting the

303
00:20:10,836 --> 00:20:15,038
mode of gene. In our case is gene

304
00:20:15,214 --> 00:20:19,026
test mode. Then we

305
00:20:19,048 --> 00:20:22,660
define an HTTP recorder for our test

306
00:20:23,430 --> 00:20:27,138
which is provided by the package HTTP test

307
00:20:27,304 --> 00:20:30,998
new recorder. And then

308
00:20:31,084 --> 00:20:34,166
we need a gene context for

309
00:20:34,188 --> 00:20:35,080
our test.

310
00:20:38,030 --> 00:20:42,634
Create test context only which expect a

311
00:20:42,672 --> 00:20:46,970
response writer as the first argument,

312
00:20:47,870 --> 00:20:51,790
and then an engine of gene.

313
00:20:52,210 --> 00:20:56,270
In this case we can use gene default

314
00:20:56,850 --> 00:21:00,602
if we save it automatically imports the package.

315
00:21:00,666 --> 00:21:05,326
Here, however, we have to actually download

316
00:21:05,438 --> 00:21:08,402
it. We can do in two ways.

317
00:21:08,536 --> 00:21:12,254
The first one is by issuing a goget followed

318
00:21:12,302 --> 00:21:15,830
by the path of the module of the package.

319
00:21:16,810 --> 00:21:20,358
The second one is by running the

320
00:21:20,444 --> 00:21:24,280
command go mode tidb. So we enter

321
00:21:26,330 --> 00:21:29,434
our folder and then we issue the

322
00:21:29,472 --> 00:21:32,954
command go mode, tidy it,

323
00:21:32,992 --> 00:21:36,234
automatically download the package and now the

324
00:21:36,272 --> 00:21:37,660
error goes away.

325
00:21:39,390 --> 00:21:43,614
The only error that we still have is that c is declared but

326
00:21:43,652 --> 00:21:47,306
not used. So let's

327
00:21:47,338 --> 00:21:50,990
moving ahead and use c

328
00:21:51,060 --> 00:21:54,226
in order to build our call. So the

329
00:21:54,248 --> 00:21:58,258
first thing that we have to do is to set

330
00:21:58,424 --> 00:22:01,778
the request on this context and we are going

331
00:22:01,784 --> 00:22:06,390
to set it of type HTTP request,

332
00:22:06,970 --> 00:22:10,870
and we initialize the header field by using

333
00:22:10,940 --> 00:22:12,920
the built in make function.

334
00:22:17,710 --> 00:22:22,794
Then we

335
00:22:22,832 --> 00:22:28,394
set the parameter for

336
00:22:28,432 --> 00:22:31,980
our request. In this case

337
00:22:34,210 --> 00:22:37,326
the params is a slice which contains all

338
00:22:37,348 --> 00:22:41,450
of the parameter for our handlers.

339
00:22:41,610 --> 00:22:44,720
But now we would like to append another one.

340
00:22:45,810 --> 00:22:49,074
So with the built in append function we

341
00:22:49,112 --> 00:22:52,930
invoke it in order to append another

342
00:22:53,000 --> 00:22:57,320
param which has a key called id

343
00:22:57,930 --> 00:23:01,778
and a value abc.

344
00:23:01,954 --> 00:23:05,478
Because this test is about Id

345
00:23:05,564 --> 00:23:08,570
not valid, so id not integer.

346
00:23:08,910 --> 00:23:12,140
Let's add this suffix to this test.

347
00:23:12,670 --> 00:23:16,730
All right, so now we prepared

348
00:23:18,350 --> 00:23:21,918
our request. The next step is to

349
00:23:22,084 --> 00:23:24,670
actually invoke our handler.

350
00:23:25,650 --> 00:23:29,790
We issue update to do and we provide the gene context.

351
00:23:31,330 --> 00:23:34,770
Then we have to do the assertion. So if

352
00:23:34,840 --> 00:23:38,660
code is not equal to 400,

353
00:23:39,190 --> 00:23:43,700
then we let the test fail with

354
00:23:44,150 --> 00:23:49,110
a format message. In this case expected

355
00:23:49,530 --> 00:23:52,946
percentage d comma

356
00:23:53,058 --> 00:23:55,560
got percentage d.

357
00:23:56,010 --> 00:23:59,482
So the code expected was 400,

358
00:23:59,616 --> 00:24:02,780
but we got the actual code.

359
00:24:04,990 --> 00:24:08,860
All right, now we can

360
00:24:09,470 --> 00:24:13,534
run our first test and look if we

361
00:24:13,572 --> 00:24:16,986
got an undefined error, a compilation

362
00:24:17,098 --> 00:24:22,474
error, because we didn't write this

363
00:24:22,532 --> 00:24:26,034
function yet. In order to run

364
00:24:26,072 --> 00:24:29,698
our test, we need to switch in the

365
00:24:29,784 --> 00:24:33,250
handlers folder, then issue

366
00:24:33,320 --> 00:24:37,478
the command go test v, which means

367
00:24:37,564 --> 00:24:41,330
verbose because we are interested in a verbose

368
00:24:41,410 --> 00:24:44,662
output cover in order

369
00:24:44,716 --> 00:24:47,430
to also include the code coverage.

370
00:24:48,990 --> 00:24:52,602
If we run it, we get back an

371
00:24:52,656 --> 00:24:56,618
undefined update to do so.

372
00:24:56,704 --> 00:24:59,900
Now let's define this update function.

373
00:25:03,890 --> 00:25:08,650
First of all, we are going to create another file

374
00:25:08,810 --> 00:25:10,960
called handlers go.

375
00:25:14,630 --> 00:25:18,866
I'm going to put the production code on

376
00:25:18,888 --> 00:25:22,466
the right side while the test code will be

377
00:25:22,488 --> 00:25:26,150
on the left side because I'm used with this setup

378
00:25:27,850 --> 00:25:31,782
package Android because the

379
00:25:31,916 --> 00:25:35,574
production code will belong to

380
00:25:35,612 --> 00:25:39,546
the same package of the test, at least in

381
00:25:39,568 --> 00:25:42,970
this demo. And then we are going to define

382
00:25:43,870 --> 00:25:48,090
the update to do function which

383
00:25:48,160 --> 00:25:51,390
expect a pointer of gene context.

384
00:25:55,330 --> 00:25:57,950
Now if we rerun the tests,

385
00:26:00,610 --> 00:26:04,062
we get back this error. Now the compiler,

386
00:26:04,126 --> 00:26:07,380
the compile error error goes away.

387
00:26:08,310 --> 00:26:12,402
Now we got 400 bad request error instead

388
00:26:12,456 --> 00:26:15,782
of 200. Okay, that's why if we

389
00:26:15,836 --> 00:26:19,286
didn't specify anything in

390
00:26:19,308 --> 00:26:23,270
the body of the function, this is the default behavior.

391
00:26:23,930 --> 00:26:27,474
So let's fix this in order

392
00:26:27,532 --> 00:26:31,350
to move to the green area. C writer

393
00:26:31,430 --> 00:26:34,634
write either 400 and then we

394
00:26:34,672 --> 00:26:38,154
force the writing of the eater. So c

395
00:26:38,192 --> 00:26:41,834
dot writer and now in order to

396
00:26:41,872 --> 00:26:45,310
write and force the eater to be written.

397
00:26:46,050 --> 00:26:49,760
If we rerun the test now we got a

398
00:26:52,390 --> 00:26:56,306
successful result. Now we

399
00:26:56,328 --> 00:26:59,246
could enter in the refactor phase.

400
00:26:59,438 --> 00:27:02,802
So first of all, let's get rid of these

401
00:27:02,936 --> 00:27:06,600
magic numbers and instead using

402
00:27:11,530 --> 00:27:15,110
the constant provided by the HTTP package,

403
00:27:17,710 --> 00:27:21,034
if we rerun it. We get

404
00:27:21,152 --> 00:27:23,980
still the positive result,

405
00:27:28,430 --> 00:27:31,786
but we can do better. We can use the assert

406
00:27:31,978 --> 00:27:36,014
package provided by the

407
00:27:36,052 --> 00:27:40,122
testify package. So with assert we can invoke

408
00:27:40,186 --> 00:27:45,186
equal and providing the

409
00:27:45,208 --> 00:27:49,106
test which is the one provided in

410
00:27:49,128 --> 00:27:52,750
the signature, then followed by the expected,

411
00:27:52,830 --> 00:27:55,986
in our case HTTP bed request,

412
00:27:56,178 --> 00:27:59,720
and then the actual code that we got.

413
00:28:03,450 --> 00:28:04,760
And here we go.

414
00:28:09,470 --> 00:28:12,922
Now let's install this

415
00:28:12,976 --> 00:28:16,586
new package by running the

416
00:28:16,608 --> 00:28:18,090
go mode tidy.

417
00:28:23,010 --> 00:28:24,000
All right,

418
00:28:27,010 --> 00:28:31,226
there is a warning, so let's rerun this gomode tidy

419
00:28:31,418 --> 00:28:34,100
and let the warning goes away.

420
00:28:36,310 --> 00:28:41,602
Then we reenter the handlers folder so

421
00:28:41,656 --> 00:28:45,140
we are good to go. The next step

422
00:28:45,450 --> 00:28:49,160
here is to also assert for the body,

423
00:28:49,530 --> 00:28:53,014
okay, because now we assert only the

424
00:28:53,052 --> 00:28:56,946
status code that is 400 by the request.

425
00:28:57,138 --> 00:29:02,122
However, we also would

426
00:29:02,176 --> 00:29:05,914
like also to be sure that the

427
00:29:05,952 --> 00:29:10,274
body contains this string.

428
00:29:10,422 --> 00:29:15,280
So now let's duplicate this test and

429
00:29:16,050 --> 00:29:20,160
let's append this suffix that is body.

430
00:29:23,510 --> 00:29:27,154
Let's get rid of this assertion because the

431
00:29:27,192 --> 00:29:28,820
scenario is the same.

432
00:29:30,310 --> 00:29:33,634
What change here is that we need to

433
00:29:33,672 --> 00:29:37,762
assert something else. So we still make use of the assert

434
00:29:37,826 --> 00:29:42,226
package, but this time we invoke the function contains,

435
00:29:42,418 --> 00:29:45,670
which expect t as the first parameter,

436
00:29:46,330 --> 00:29:49,882
then the string to search in,

437
00:29:50,016 --> 00:29:54,310
which is double view body string,

438
00:29:54,390 --> 00:29:58,474
and then the string to look for. So id

439
00:29:58,592 --> 00:29:59,770
not integer.

440
00:30:03,170 --> 00:30:06,080
Now if we rerun the test,

441
00:30:07,970 --> 00:30:12,000
we are in the red area, because our second test

442
00:30:13,030 --> 00:30:17,234
we return this error that is string empty does not

443
00:30:17,272 --> 00:30:20,914
contain id not integer. That's why

444
00:30:20,952 --> 00:30:26,242
we didn't manage and or handlers where

445
00:30:26,296 --> 00:30:29,240
spots p load. So let's do this.

446
00:30:30,810 --> 00:30:32,600
In order to fix this,

447
00:30:33,530 --> 00:30:37,400
we have to invoke c string, which expect

448
00:30:38,670 --> 00:30:42,346
the HTTP status code to return as the first

449
00:30:42,448 --> 00:30:46,554
argument, and the second argument, a string to

450
00:30:46,592 --> 00:30:50,526
be written on. The response in

451
00:30:50,548 --> 00:30:53,150
our case is id not integer.

452
00:30:54,610 --> 00:30:57,662
Then we can safely remove the write either now,

453
00:30:57,716 --> 00:31:01,374
because now we

454
00:31:01,412 --> 00:31:05,486
don't have to force the write of the eaters because it's

455
00:31:05,518 --> 00:31:07,490
already done by the string.

456
00:31:09,270 --> 00:31:12,402
Let's rerun the test and now we are back

457
00:31:12,456 --> 00:31:14,020
in the positive area.

458
00:31:16,650 --> 00:31:20,086
All right, let's refactor this a little bit,

459
00:31:20,268 --> 00:31:23,746
because now we are allowed to do refactoring.

460
00:31:23,938 --> 00:31:27,706
Let's introduce a

461
00:31:27,728 --> 00:31:32,038
constant in order to get rid of the Id not integer literals,

462
00:31:32,214 --> 00:31:35,514
which is a magic number, as you

463
00:31:35,552 --> 00:31:37,930
might remember from our slide.

464
00:31:38,990 --> 00:31:42,510
So id not integer error

465
00:31:42,930 --> 00:31:45,710
equal to id not integer.

466
00:31:46,050 --> 00:31:51,054
And then we switch the

467
00:31:51,092 --> 00:31:56,414
usage of the literals to this variable constant.

468
00:31:56,542 --> 00:32:00,722
I mean, if we

469
00:32:00,776 --> 00:32:04,180
rerun the test, everything is still fine.

470
00:32:05,210 --> 00:32:09,126
Now we have two tests that are

471
00:32:09,308 --> 00:32:11,590
challenging the same scenario.

472
00:32:12,250 --> 00:32:15,800
We can merge these two into one,

473
00:32:16,650 --> 00:32:20,490
keep in mind that it's completely safe to delete test

474
00:32:20,560 --> 00:32:24,694
because test as the normal code can be adjusted,

475
00:32:24,742 --> 00:32:28,586
deleted or improved. So it's completely

476
00:32:28,688 --> 00:32:33,226
fine as long as we keep testing every scenario

477
00:32:33,418 --> 00:32:37,146
in our code. So let's move this assert

478
00:32:37,338 --> 00:32:41,134
in the first test and then let's get rid of

479
00:32:41,172 --> 00:32:42,560
this second test.

480
00:32:47,190 --> 00:32:50,594
If we save and run the test,

481
00:32:50,792 --> 00:32:55,022
we still have the 100% code coverage because now

482
00:32:55,096 --> 00:32:58,230
we are only dealing with one scenario.

483
00:33:01,370 --> 00:33:04,998
Now let's write the second test for the second

484
00:33:05,084 --> 00:33:09,020
scenario, which is validation error in our case.

485
00:33:09,550 --> 00:33:14,122
So we are going to duplicate this just

486
00:33:14,176 --> 00:33:17,510
for the sake of time. And then we renamed

487
00:33:17,590 --> 00:33:19,770
this to validation.

488
00:33:24,210 --> 00:33:28,160
Then the first thing to do is to fix

489
00:33:28,530 --> 00:33:31,774
this param. Now we are

490
00:33:31,812 --> 00:33:37,426
good. So we passed in a right int

491
00:33:37,528 --> 00:33:40,740
id value such as one.

492
00:33:43,830 --> 00:33:47,542
All right, then we have to pass also

493
00:33:47,596 --> 00:33:50,946
the payload because now we are dealing

494
00:33:50,978 --> 00:33:54,034
with the payload because we are validating the incoming

495
00:33:54,082 --> 00:33:58,620
payload of the HTTP request. So we need a way to

496
00:33:59,070 --> 00:34:02,394
pass it to our handlers. So first

497
00:34:02,432 --> 00:34:06,410
of all, let's set the method

498
00:34:07,230 --> 00:34:10,090
which is put on the request.

499
00:34:11,330 --> 00:34:15,422
Then let's set one

500
00:34:15,476 --> 00:34:19,422
either. So c

501
00:34:19,556 --> 00:34:22,946
request either and set set is

502
00:34:22,968 --> 00:34:26,546
a method that expect two values, both of

503
00:34:26,568 --> 00:34:30,082
type string. The first one is the key and the second one

504
00:34:30,136 --> 00:34:33,860
is the value. So the key will be

505
00:34:34,470 --> 00:34:39,046
content type and

506
00:34:39,068 --> 00:34:43,910
the second one will be application Json.

507
00:34:45,610 --> 00:34:48,540
Then we have to set also the body,

508
00:34:50,510 --> 00:34:54,330
and the body is of type I o

509
00:34:54,480 --> 00:34:58,902
knob closer just to wrap our writer

510
00:34:58,966 --> 00:35:03,422
into a reader which

511
00:35:03,476 --> 00:35:06,846
has also the close method, so it's a no

512
00:35:06,868 --> 00:35:12,426
utility method. This one I will say inside

513
00:35:12,548 --> 00:35:17,106
of him we

514
00:35:17,128 --> 00:35:20,654
have to invoke the strings new reader

515
00:35:20,702 --> 00:35:24,050
function which expect in a string.

516
00:35:24,630 --> 00:35:28,454
The string is provided within backticks in

517
00:35:28,492 --> 00:35:31,894
order to not have to escape every

518
00:35:31,932 --> 00:35:35,586
single double quotes within it. So a pair

519
00:35:35,618 --> 00:35:39,094
of curly braces and then let's start by defining

520
00:35:39,142 --> 00:35:42,714
our p load. In this case we will leave

521
00:35:42,752 --> 00:35:47,340
the description empty in order to understand

522
00:35:48,430 --> 00:35:53,070
this validation scenario is complex

523
00:35:54,850 --> 00:35:58,640
equal to true and due date

524
00:35:59,810 --> 00:36:04,658
equal to 2023 50

525
00:36:04,744 --> 00:36:06,980
five good.

526
00:36:08,710 --> 00:36:12,142
So now we have defined our payload,

527
00:36:12,206 --> 00:36:15,414
which is invalid because the description should

528
00:36:15,452 --> 00:36:19,394
be populated because we won't

529
00:36:19,442 --> 00:36:22,390
allow a to do without a description.

530
00:36:24,490 --> 00:36:27,602
All right, in the assertion part

531
00:36:27,676 --> 00:36:32,154
we can leave this assertion because it's still 400,

532
00:36:32,272 --> 00:36:36,140
the status quote that we are expecting here.

533
00:36:36,590 --> 00:36:40,698
However, the body should contain

534
00:36:40,794 --> 00:36:44,682
another error message, which is validation

535
00:36:44,826 --> 00:36:49,242
error. So let's

536
00:36:49,306 --> 00:36:52,602
rerun the test and check if we are

537
00:36:52,676 --> 00:36:56,354
in the red area or not. If we

538
00:36:56,392 --> 00:37:00,082
run this test we get back an id

539
00:37:00,136 --> 00:37:03,650
not integer, does not contain validation error.

540
00:37:04,150 --> 00:37:07,422
So we have to move in green.

541
00:37:07,496 --> 00:37:11,046
In the green area and we have to do some adjustment in

542
00:37:11,068 --> 00:37:14,674
this code. The adjustment

543
00:37:14,722 --> 00:37:18,570
that we have to do is to invoke

544
00:37:20,590 --> 00:37:24,074
the function etoy which

545
00:37:24,112 --> 00:37:28,150
is responsible for converting a string into an integer

546
00:37:28,230 --> 00:37:31,514
value and provided an error. If this conversion

547
00:37:31,562 --> 00:37:35,374
is not possible of the param that

548
00:37:35,412 --> 00:37:39,790
we got in, let's capture

549
00:37:40,130 --> 00:37:43,854
this result into a variable called error

550
00:37:43,982 --> 00:37:47,842
and for now blank identifier because we don't need the id right

551
00:37:47,896 --> 00:37:51,954
now. Okay, so let's not grab the

552
00:37:51,992 --> 00:37:55,590
id just for the sake of it. If we will need

553
00:37:55,660 --> 00:37:58,246
the id, we will grab the id.

554
00:37:58,428 --> 00:38:02,802
Now we only interested at understanding

555
00:38:02,866 --> 00:38:06,322
if the id is an integer

556
00:38:06,386 --> 00:38:07,160
or not.

557
00:38:09,070 --> 00:38:12,810
If error is not equal to nil,

558
00:38:14,750 --> 00:38:19,770
then we return this string and

559
00:38:19,840 --> 00:38:22,380
we immediately exit from the function.

560
00:38:23,950 --> 00:38:27,566
If this is not the case, we are going

561
00:38:27,588 --> 00:38:30,910
to return the validation error

562
00:38:32,630 --> 00:38:36,974
message because now our handler

563
00:38:37,022 --> 00:38:40,894
is only handling two scenario

564
00:38:41,022 --> 00:38:44,610
the id, not integer and validation error.

565
00:38:45,450 --> 00:38:49,830
So we have only 50% of probability

566
00:38:53,690 --> 00:38:56,120
if we rerun the test.

567
00:38:56,810 --> 00:39:00,294
Now we are in 100% of code coverage

568
00:39:00,342 --> 00:39:02,810
and both of the tests are passing.

569
00:39:05,630 --> 00:39:08,330
Now it's time for refactoring.

570
00:39:08,990 --> 00:39:12,762
Let's get rid of these magic numbers validation

571
00:39:12,826 --> 00:39:16,270
error by introducing another constant.

572
00:39:17,810 --> 00:39:21,230
This constant is named validation error.

573
00:39:25,670 --> 00:39:29,890
If I save my Gofund tool

574
00:39:30,040 --> 00:39:34,178
will format the constant in this way like

575
00:39:34,344 --> 00:39:35,990
the import section.

576
00:39:36,970 --> 00:39:40,920
Then we have to switch the magic number to

577
00:39:41,690 --> 00:39:45,686
the validation error constant and also do the

578
00:39:45,708 --> 00:39:53,534
same in the testament.

579
00:39:53,682 --> 00:39:56,810
All right, the tests are still passing.

580
00:39:59,890 --> 00:40:04,110
Now let's introduce the logic about the database

581
00:40:05,490 --> 00:40:09,038
because our third scenario is when we got

582
00:40:09,124 --> 00:40:12,994
a database error, something unexpected such

583
00:40:13,032 --> 00:40:17,506
as a connectivity issue or a

584
00:40:17,528 --> 00:40:21,662
query that takes too much to be executed

585
00:40:21,726 --> 00:40:26,274
or whatever, something that can be unpredictable

586
00:40:26,322 --> 00:40:30,034
to us. So let's duplicate

587
00:40:30,082 --> 00:40:33,830
again this test and now

588
00:40:33,900 --> 00:40:38,630
we are going to call it db error.

589
00:40:42,570 --> 00:40:45,846
In order to be sure, let's fix

590
00:40:45,948 --> 00:40:49,898
the description. Now we got invalid descriptions

591
00:40:50,034 --> 00:40:52,030
as Lorem ipsum.

592
00:41:02,390 --> 00:41:06,814
All right, now let's

593
00:41:06,862 --> 00:41:10,510
introduce the package SQL mock

594
00:41:10,670 --> 00:41:15,010
which assists us in mocking a real database.

595
00:41:16,230 --> 00:41:24,386
So we

596
00:41:24,408 --> 00:41:27,830
are going to call the package sQl mock

597
00:41:29,210 --> 00:41:31,900
dot new, the function new,

598
00:41:34,830 --> 00:41:38,554
and we capture the results into

599
00:41:38,672 --> 00:41:42,786
three variable. The first one is db,

600
00:41:42,918 --> 00:41:46,334
the second one is mock, and the third one will

601
00:41:46,372 --> 00:41:49,486
be the error. But for the sake of demo we

602
00:41:49,508 --> 00:41:52,766
are not going to handle it and we leave the blank

603
00:41:52,798 --> 00:41:56,100
identifier. All right,

604
00:41:59,750 --> 00:42:04,126
we have to import this SQl mock. So let's navigate

605
00:42:04,318 --> 00:42:08,306
up of one level and run the

606
00:42:08,328 --> 00:42:10,310
go mode tidy command.

607
00:42:11,370 --> 00:42:14,550
This way we successfully imported

608
00:42:14,890 --> 00:42:18,330
our mock go SQl mock package.

609
00:42:20,910 --> 00:42:24,874
In the new function we can provide the

610
00:42:24,912 --> 00:42:28,474
criteria based on which it has to

611
00:42:28,512 --> 00:42:31,886
match the query because now we

612
00:42:31,908 --> 00:42:35,002
are defining the behavior of our mock.

613
00:42:35,066 --> 00:42:39,434
So which query we are going to perform, which commands

614
00:42:39,482 --> 00:42:43,650
we are going to perform, with which parameter and which

615
00:42:43,720 --> 00:42:46,482
result we have to expect. Okay,

616
00:42:46,616 --> 00:42:50,206
in order to match this query or SQL statement

617
00:42:50,318 --> 00:42:53,378
in general, we have various options.

618
00:42:53,544 --> 00:42:56,200
We can match them exactly,

619
00:42:56,890 --> 00:43:00,098
which will be our option for today's session,

620
00:43:00,274 --> 00:43:04,150
or we can match them with a regular expression,

621
00:43:04,650 --> 00:43:08,406
for example. So we have to specify

622
00:43:08,518 --> 00:43:12,730
the behavior in this case is SQL mock

623
00:43:13,390 --> 00:43:16,890
query matcher option and within

624
00:43:16,960 --> 00:43:20,810
the brackets we are going to write SQl mock

625
00:43:20,970 --> 00:43:22,990
query matcher equal.

626
00:43:27,730 --> 00:43:32,026
Then we have to defer a close request

627
00:43:32,218 --> 00:43:33,650
to the DB.

628
00:43:38,070 --> 00:43:43,246
All right, and then we have to define our gorm

629
00:43:43,278 --> 00:43:47,078
dB connection because to our handler we are going to pass

630
00:43:47,164 --> 00:43:52,760
a gorm client, not a row SQl stuff.

631
00:43:54,090 --> 00:43:57,000
So we need a way to retrieve it.

632
00:43:57,470 --> 00:44:01,430
The first thing is to define a new variable

633
00:44:01,510 --> 00:44:05,318
called connection which represents the underlying

634
00:44:05,414 --> 00:44:08,170
connection to our fake database.

635
00:44:10,450 --> 00:44:14,190
So we are going to invoke db.com

636
00:44:14,340 --> 00:44:17,582
and we provide a context. In this case

637
00:44:17,636 --> 00:44:21,120
we have the gene context that fits well here.

638
00:44:23,910 --> 00:44:28,210
Then we defer a close invocation

639
00:44:29,510 --> 00:44:33,502
and now we are ready to instantiate

640
00:44:33,566 --> 00:44:37,414
a gorm client. The gorm client is an

641
00:44:37,452 --> 00:44:40,694
abstract client upon the

642
00:44:40,732 --> 00:44:43,590
underlying socket connection to the database.

643
00:44:43,930 --> 00:44:47,806
In this case we can define

644
00:44:47,858 --> 00:44:51,654
the Gormdb variable and another blank

645
00:44:51,702 --> 00:44:55,014
identifier and invoke a method

646
00:44:55,062 --> 00:44:56,570
of the Gorma package.

647
00:44:57,710 --> 00:44:59,820
This method is called open.

648
00:45:02,770 --> 00:45:06,462
The first thing to do is to import our

649
00:45:06,516 --> 00:45:10,510
package always

650
00:45:10,580 --> 00:45:13,858
with the Gomode tidy we are going to download it

651
00:45:13,944 --> 00:45:15,090
from GitHub.

652
00:45:21,270 --> 00:45:25,206
All right then here we

653
00:45:25,228 --> 00:45:30,102
expect a dialector and

654
00:45:30,156 --> 00:45:39,514
we use the driver of postgres and

655
00:45:39,552 --> 00:45:43,514
we invoke the function new. Again we have

656
00:45:43,552 --> 00:45:47,082
to install this brighter. So let's switch back

657
00:45:47,136 --> 00:45:51,630
to our terminal and rerun the go mode tidy.

658
00:45:54,450 --> 00:45:57,994
Thanks to this command we have downloaded

659
00:45:58,042 --> 00:46:01,902
the postgres driver. You can see here

660
00:46:01,956 --> 00:46:06,162
the latest two packages installed gorm and

661
00:46:06,296 --> 00:46:07,970
postgres driver.

662
00:46:10,710 --> 00:46:14,322
Now within it we are going to

663
00:46:14,376 --> 00:46:17,942
invoke a postgres config struct and we

664
00:46:17,996 --> 00:46:21,366
set the con field to

665
00:46:21,388 --> 00:46:25,794
the con that we declared

666
00:46:25,922 --> 00:46:27,000
up here.

667
00:46:29,230 --> 00:46:34,202
Here we go. Now we can pass this to

668
00:46:34,256 --> 00:46:37,722
our request context. In order

669
00:46:37,776 --> 00:46:41,438
to do this we need to invoke the set

670
00:46:41,524 --> 00:46:44,670
method on our gene context.

671
00:46:45,250 --> 00:46:48,494
The first parameter is a

672
00:46:48,532 --> 00:46:52,014
key which is a DB and the second one is

673
00:46:52,052 --> 00:46:54,850
the value that is a GormDB.

674
00:46:57,270 --> 00:46:58,260
All right,

675
00:46:59,830 --> 00:47:03,506
now we have to set up the mock because

676
00:47:03,608 --> 00:47:07,186
we need to say to SQL

677
00:47:07,218 --> 00:47:10,630
mock how to behave in this particular condition.

678
00:47:11,450 --> 00:47:15,110
So let's do this. On mock

679
00:47:15,450 --> 00:47:19,030
we are going to issue an expect query method

680
00:47:19,530 --> 00:47:24,102
which expect a string which

681
00:47:24,156 --> 00:47:27,882
represents the query that we are going to perform

682
00:47:28,016 --> 00:47:31,200
on the database. In this case,

683
00:47:31,730 --> 00:47:35,694
we use a backtick in order to not escape the

684
00:47:35,732 --> 00:47:39,486
double quote within it. So select

685
00:47:39,588 --> 00:47:43,154
star from our table that

686
00:47:43,192 --> 00:47:46,980
is called to dos where

687
00:47:48,230 --> 00:47:52,900
todos id

688
00:47:54,310 --> 00:47:57,446
is equal to dollar one, which is a

689
00:47:57,468 --> 00:48:01,602
placeholder for the first argument. The arguments

690
00:48:01,666 --> 00:48:05,800
will be replaced in a positional way.

691
00:48:09,230 --> 00:48:12,620
Then order by

692
00:48:13,950 --> 00:48:16,380
todos id,

693
00:48:21,090 --> 00:48:23,870
limit one to close the query.

694
00:48:26,850 --> 00:48:30,414
Then we invoke also the

695
00:48:30,452 --> 00:48:34,210
ARG with the with arcs method to specify that

696
00:48:34,280 --> 00:48:39,714
we are calling this query with this argument and

697
00:48:39,752 --> 00:48:41,570
it will return an error.

698
00:48:44,150 --> 00:48:48,374
To create an error we use the package font together with

699
00:48:48,412 --> 00:48:52,290
the error f function and we provide the string

700
00:48:52,370 --> 00:48:53,670
db error.

701
00:48:58,910 --> 00:49:02,346
All right, now let's switch to

702
00:49:02,368 --> 00:49:03,900
the assertion part.

703
00:49:07,390 --> 00:49:11,246
In the assertion part we are going to

704
00:49:11,428 --> 00:49:15,610
get rid of this and leave only an assertion

705
00:49:15,690 --> 00:49:19,294
on the status code that should be

706
00:49:19,332 --> 00:49:22,834
equal to 500 in this case because it's an

707
00:49:22,872 --> 00:49:24,370
unexpected error.

708
00:49:25,910 --> 00:49:29,554
However, what we have to do is also assert that

709
00:49:29,592 --> 00:49:33,234
the mock were actually used as

710
00:49:33,272 --> 00:49:36,886
we expect to do this, we are going to

711
00:49:36,908 --> 00:49:41,254
invoke mock expectations were

712
00:49:41,292 --> 00:49:45,174
met. It will return an error if some

713
00:49:45,372 --> 00:49:48,380
of the expectation were not met.

714
00:49:50,830 --> 00:49:54,810
If we got an error, we let the test fail

715
00:49:56,110 --> 00:49:58,758
with this string.

716
00:49:58,934 --> 00:50:02,560
Not all expectations were met,

717
00:50:03,490 --> 00:50:07,200
followed by percentage v

718
00:50:08,050 --> 00:50:09,310
and the error.

719
00:50:13,750 --> 00:50:17,170
Now we should be able to run the test and see

720
00:50:17,240 --> 00:50:21,060
if we are in the red area.

721
00:50:21,990 --> 00:50:26,230
And there we go. We got two errors,

722
00:50:26,810 --> 00:50:30,374
the expected status code that

723
00:50:30,412 --> 00:50:34,390
is different and the expectations

724
00:50:34,810 --> 00:50:38,246
because we didn't run this query

725
00:50:38,358 --> 00:50:42,362
on our db. That's why we

726
00:50:42,416 --> 00:50:46,230
didn't retrieve the GorMDB client

727
00:50:46,310 --> 00:50:49,910
in our Android. So let's fix

728
00:50:50,000 --> 00:50:54,462
them. Let's start by

729
00:50:54,516 --> 00:50:58,026
fixing the 500 internal server

730
00:50:58,058 --> 00:50:59,440
error status code.

731
00:51:00,850 --> 00:51:05,458
All right, first of all, we have to

732
00:51:05,544 --> 00:51:08,078
involve a third scenario.

733
00:51:08,254 --> 00:51:12,130
So we are going to have another if checking

734
00:51:13,990 --> 00:51:16,790
for the validation scenario.

735
00:51:17,290 --> 00:51:21,042
To do this, we need to define a DTO struct.

736
00:51:21,186 --> 00:51:25,142
A DTO struct is a struct that is meant to

737
00:51:25,196 --> 00:51:28,506
transport back and forth the data

738
00:51:28,688 --> 00:51:32,170
from the client to the server and the way

739
00:51:32,240 --> 00:51:36,410
around. So type

740
00:51:36,560 --> 00:51:43,354
to do DTO struct it

741
00:51:43,392 --> 00:51:47,390
will have three fields description of type string

742
00:51:48,050 --> 00:51:50,750
with this gzone annotation.

743
00:51:54,630 --> 00:51:58,030
Then binding with required

744
00:51:58,190 --> 00:52:03,138
annotation is

745
00:52:03,304 --> 00:52:06,862
completed. A boolean

746
00:52:06,926 --> 00:52:12,530
value with

747
00:52:12,680 --> 00:52:16,630
this gzone annotation and the binding is

748
00:52:16,780 --> 00:52:17,670
required.

749
00:52:20,990 --> 00:52:25,290
Due date of type string JSOn

750
00:52:25,870 --> 00:52:35,322
due date binding

751
00:52:35,386 --> 00:52:38,654
required one of the

752
00:52:38,692 --> 00:52:42,554
beauty of Gogen web framework is that

753
00:52:42,612 --> 00:52:46,020
it has a lot of features built in.

754
00:52:46,790 --> 00:52:50,094
This one is a great example. We can do the validation

755
00:52:50,142 --> 00:52:53,922
in this way. Just add an annotation here

756
00:52:54,056 --> 00:52:57,910
and then invoke a method over the gene context.

757
00:52:58,650 --> 00:53:02,006
Let's do this. First of all we

758
00:53:02,028 --> 00:53:05,958
are going to define a variable called to do of type

759
00:53:06,044 --> 00:53:07,430
to do DTO.

760
00:53:10,510 --> 00:53:13,990
Then we run the method should bind

761
00:53:14,150 --> 00:53:18,220
over the gene context and it automatically understand

762
00:53:19,550 --> 00:53:23,134
that it has to try to unmarshall the

763
00:53:23,172 --> 00:53:27,470
body of the request onto our struct

764
00:53:27,890 --> 00:53:31,470
and we have to pass the pointer to our variable.

765
00:53:33,510 --> 00:53:37,938
Then we capture the error and

766
00:53:38,024 --> 00:53:41,746
if the error is not nil we

767
00:53:41,768 --> 00:53:43,620
are going to return this.

768
00:53:48,490 --> 00:53:52,520
Otherwise we are going to set the

769
00:53:52,970 --> 00:53:56,520
HTTP internal server error status code

770
00:53:57,210 --> 00:54:01,180
c writer write either 500

771
00:54:02,510 --> 00:54:05,980
and then we force to write the eater now.

772
00:54:10,050 --> 00:54:13,710
Now we can run the test to see if the first

773
00:54:13,780 --> 00:54:15,680
assertion goes away.

774
00:54:17,970 --> 00:54:20,926
If we run go test b cover.

775
00:54:21,108 --> 00:54:24,834
Now the complaint about the status code has

776
00:54:24,872 --> 00:54:28,740
gone away. Now we can try to fix

777
00:54:29,430 --> 00:54:32,580
the second assertion which is

778
00:54:35,850 --> 00:54:39,286
the assertion about

779
00:54:39,388 --> 00:54:42,854
the query. In order to do

780
00:54:42,892 --> 00:54:45,640
this, we have to define a model.

781
00:54:46,970 --> 00:54:50,794
The model is the actual model that

782
00:54:50,832 --> 00:54:54,314
will be mapped as a table in our

783
00:54:54,352 --> 00:54:57,850
database because the Orm

784
00:54:58,270 --> 00:55:02,414
its purpose is to map object that

785
00:55:02,452 --> 00:55:07,150
are code stuff such as struct over relation

786
00:55:07,570 --> 00:55:11,582
that are table in the database. So let's define the

787
00:55:11,636 --> 00:55:15,314
to do struct. The to

788
00:55:15,352 --> 00:55:19,614
do struct will have an id of type unsigned

789
00:55:19,662 --> 00:55:23,410
integer, then a description of type

790
00:55:23,480 --> 00:55:27,078
string, then the is completed field

791
00:55:27,164 --> 00:55:30,934
of type bool and then the due date of

792
00:55:30,972 --> 00:55:32,150
type string.

793
00:55:35,850 --> 00:55:39,580
All right here,

794
00:55:39,950 --> 00:55:43,862
first of all we have to get the db

795
00:55:44,006 --> 00:55:48,122
and to get the db we are going to read this

796
00:55:48,176 --> 00:55:51,518
value from our context. So c

797
00:55:51,604 --> 00:55:55,514
dot mustget which is a method

798
00:55:55,562 --> 00:55:59,118
that expecting a DB key in our case

799
00:55:59,204 --> 00:56:00,350
is db.

800
00:56:02,870 --> 00:56:06,782
And then we typecast it because it's a pointer

801
00:56:06,846 --> 00:56:08,610
to a GormDB.

802
00:56:10,470 --> 00:56:13,710
Then we have our db. Now let's

803
00:56:13,790 --> 00:56:17,910
actually invoke our query.

804
00:56:18,330 --> 00:56:22,166
First of all we need the id here

805
00:56:22,268 --> 00:56:25,880
because now we will use the id so

806
00:56:26,410 --> 00:56:30,602
DB model and then

807
00:56:30,656 --> 00:56:34,810
we pass in to do struct

808
00:56:36,270 --> 00:56:39,820
the model method is to indicate on which

809
00:56:40,210 --> 00:56:43,630
model we are going to perform our action.

810
00:56:46,210 --> 00:56:50,430
Then we will invoke the first method,

811
00:56:51,730 --> 00:56:55,026
the destination. We don't care about it for now,

812
00:56:55,208 --> 00:56:58,914
so we leave an empty to do and

813
00:56:58,952 --> 00:57:02,866
then we provide the id parameter because we

814
00:57:02,888 --> 00:57:05,960
are going to search by the primary key.

815
00:57:08,650 --> 00:57:13,574
That's all. Let's see if

816
00:57:13,612 --> 00:57:16,470
we manage also the second assertion.

817
00:57:19,790 --> 00:57:21,180
And there we go.

818
00:57:22,990 --> 00:57:26,954
We got printed on our terminal the

819
00:57:26,992 --> 00:57:30,178
DB error which is actually returned

820
00:57:30,294 --> 00:57:35,406
by our fake database. So now we

821
00:57:35,428 --> 00:57:38,746
are talking over a database to a database,

822
00:57:38,858 --> 00:57:42,494
but we didn't have it yet because in the

823
00:57:42,532 --> 00:57:46,914
EDD cycle we first needed to make

824
00:57:46,952 --> 00:57:51,380
sure to design the behavior correctly. Then we can choose

825
00:57:51,990 --> 00:57:54,660
on which database actually talk to.

826
00:57:56,330 --> 00:57:59,590
Now we can do some improvements.

827
00:58:00,890 --> 00:58:04,806
First of all, let's create another

828
00:58:04,908 --> 00:58:07,560
package which is called model.

829
00:58:09,550 --> 00:58:13,722
In our terminal go up of one level and

830
00:58:13,856 --> 00:58:16,330
create a folder called models.

831
00:58:19,890 --> 00:58:23,674
Then in our models folder

832
00:58:23,802 --> 00:58:28,462
place a file called models go which

833
00:58:28,596 --> 00:58:30,910
belong to the package models.

834
00:58:33,910 --> 00:58:38,162
Then we cut the constant from

835
00:58:38,216 --> 00:58:42,260
here and we put them here.

836
00:58:46,710 --> 00:58:51,000
Now visual studio code start to complain because

837
00:58:51,450 --> 00:58:54,550
id, not integer is undefined.

838
00:58:55,290 --> 00:58:58,626
All right, so let's

839
00:58:58,658 --> 00:59:03,254
import our new created package to

840
00:59:03,292 --> 00:59:06,698
do app models. In the import

841
00:59:06,784 --> 00:59:10,434
section to do app is the name of the module,

842
00:59:10,582 --> 00:59:12,830
models is the name of the package.

843
00:59:14,050 --> 00:59:17,534
Then we prepend the package name to

844
00:59:17,572 --> 00:59:21,470
the constant in order to be successfully recognized.

845
00:59:23,750 --> 00:59:27,522
Here we go. The file handlers is

846
00:59:27,576 --> 00:59:31,102
okay. However the test file

847
00:59:31,166 --> 00:59:34,370
is not fixed. We have to do the same here.

848
00:59:34,520 --> 00:59:38,790
So let's start by importing the package

849
00:59:41,370 --> 01:00:01,120
and then switch the variable to use the new package it.

850
01:00:03,010 --> 01:00:06,878
Let's save the file and

851
01:00:06,964 --> 01:00:08,640
rerun our test.

852
01:00:13,410 --> 01:00:16,450
The test is still successfully.

853
01:00:17,830 --> 01:00:22,882
Another thing that we should do is to cut

854
01:00:22,936 --> 01:00:26,902
away from here this to do definition because it's a model.

855
01:00:27,036 --> 01:00:30,834
It's not something related to the HTTP protocol,

856
01:00:30,962 --> 01:00:35,254
so its house is not here. It's within the

857
01:00:35,292 --> 01:00:38,970
model's file. So let's cut this

858
01:00:39,040 --> 01:00:42,954
from here and paste it here we save the

859
01:00:42,992 --> 01:00:47,142
file and the Android go file is complaining

860
01:00:47,206 --> 01:00:51,114
because it doesn't recognize to do let's

861
01:00:51,162 --> 01:01:01,706
prepend also this to do with the model's package named

862
01:01:01,898 --> 01:01:03,860
and rerun the test.

863
01:01:07,470 --> 01:01:11,322
The last two small things that we have to do is

864
01:01:11,376 --> 01:01:14,646
define a constant

865
01:01:14,758 --> 01:01:16,380
called tb key.

866
01:01:21,010 --> 01:01:25,214
This constant will be used to set the

867
01:01:25,252 --> 01:01:29,460
key instead of these magic numbers.

868
01:01:29,990 --> 01:01:34,082
So let's switch it and

869
01:01:34,136 --> 01:01:35,780
also in the test code.

870
01:01:38,470 --> 01:01:42,434
And then let's switch also the HTTP status

871
01:01:42,482 --> 01:01:46,150
code to HTTP internal server error.

872
01:01:53,790 --> 01:01:57,274
Let's rerun the test and check if

873
01:01:57,312 --> 01:02:00,860
everything is still okay. And that's the case.

874
01:02:04,270 --> 01:02:08,558
Now what we have to do is

875
01:02:08,644 --> 01:02:12,574
to assert also for the body of

876
01:02:12,612 --> 01:02:16,462
it. So let's duplicate this

877
01:02:16,596 --> 01:02:17,280
test.

878
01:02:20,550 --> 01:02:24,126
The scenario is the same, so we don't

879
01:02:24,158 --> 01:02:26,820
have any reason for change anything here.

880
01:02:27,190 --> 01:02:31,060
However, the assertion is different.

881
01:02:33,450 --> 01:02:37,000
Now we would like to assert over the body.

882
01:02:37,450 --> 01:02:41,090
So we're going to use the contains

883
01:02:41,250 --> 01:02:46,598
function with the body string

884
01:02:46,694 --> 01:03:03,870
method and we expect a dB error issued.

885
01:03:04,230 --> 01:03:08,114
We have to add a suffix here which

886
01:03:08,152 --> 01:03:09,220
is body.

887
01:03:13,190 --> 01:03:17,190
All right, then we can see if we are back in the

888
01:03:17,340 --> 01:03:21,586
red area, and indeed

889
01:03:21,698 --> 01:03:24,838
we are in the red area because

890
01:03:24,924 --> 01:03:27,902
string empty does not contain db error.

891
01:03:28,066 --> 01:03:34,154
Let's fix this in

892
01:03:34,192 --> 01:03:38,218
our production code. Let's replace these

893
01:03:38,304 --> 01:03:43,246
two lines here.

894
01:03:43,428 --> 01:03:47,520
We are going to invoke string which expect

895
01:03:48,930 --> 01:03:52,510
status code as the first parameter. And then we provide

896
01:03:52,580 --> 01:03:56,126
the string TBR and we get rid

897
01:03:56,158 --> 01:04:01,202
of the line to force if

898
01:04:01,256 --> 01:04:04,930
we issue the same command. Now we are back

899
01:04:05,000 --> 01:04:08,754
in the green area, but let's refactor

900
01:04:08,802 --> 01:04:12,818
this magic number by introducing another constant

901
01:04:12,914 --> 01:04:16,294
here. And this constant is

902
01:04:16,492 --> 01:04:17,990
db error.

903
01:04:19,790 --> 01:04:22,650
Its label is dB error.

904
01:04:25,470 --> 01:04:30,586
Here we are going to switch to this new constant which

905
01:04:30,608 --> 01:04:33,806
is model dB error and also

906
01:04:33,908 --> 01:04:36,000
in our test code.

907
01:04:44,390 --> 01:04:49,682
Let's rerun the test and everything is still good as

908
01:04:49,736 --> 01:04:54,002
before. Let's cut this assertion and put

909
01:04:54,136 --> 01:04:58,370
this assertion within the first dB

910
01:04:58,450 --> 01:05:02,006
error test method because we

911
01:05:02,028 --> 01:05:05,346
are testing the same scenario here. So it's

912
01:05:05,378 --> 01:05:09,130
completely fine to have a single test for it with

913
01:05:09,200 --> 01:05:13,690
two assertion plus another for the mock.

914
01:05:15,870 --> 01:05:19,882
If we rerun the test now,

915
01:05:19,936 --> 01:05:24,302
everything is still good and we have 100%

916
01:05:24,356 --> 01:05:25,790
of code coverage.

917
01:05:30,210 --> 01:05:33,634
All right, now let's move to the

918
01:05:33,672 --> 01:05:37,746
fourth scenario. That is the to do not found

919
01:05:37,848 --> 01:05:38,500
situation.

920
01:05:41,110 --> 01:05:44,606
So we are going to duplicate the latest file,

921
01:05:44,798 --> 01:05:47,880
the latest test, I mean,

922
01:05:48,570 --> 01:05:52,520
and we are going to rename it with not found.

923
01:05:57,630 --> 01:06:00,826
The assertion here is different because in

924
01:06:00,848 --> 01:06:05,260
this case we would like to have the 404

925
01:06:07,230 --> 01:06:10,518
status code. So let's switch the assertion.

926
01:06:10,614 --> 01:06:14,458
First we'll like the 404

927
01:06:14,544 --> 01:06:17,020
status code. However,

928
01:06:17,870 --> 01:06:21,802
now the mock is behaving in a little

929
01:06:21,856 --> 01:06:25,474
different way. It's not going to return a

930
01:06:25,512 --> 01:06:29,874
generic error, but is returning a specific error which

931
01:06:29,912 --> 01:06:33,714
is provided by the gorm package and

932
01:06:33,752 --> 01:06:37,206
the error is called error record

933
01:06:37,308 --> 01:06:40,840
not found. All right,

934
01:06:43,210 --> 01:06:46,786
everything else is still the same except the mock behavior

935
01:06:46,898 --> 01:06:50,454
because if the mock we reply with this specific error,

936
01:06:50,582 --> 01:06:54,700
we would like to reply to our client with the 404

937
01:06:55,310 --> 01:06:57,420
not found status code.

938
01:07:02,830 --> 01:07:06,170
All right, now let's rerun the test

939
01:07:06,240 --> 01:07:09,340
and see if we are in the red area.

940
01:07:10,990 --> 01:07:14,110
And there we go. Because 404

941
01:07:14,180 --> 01:07:16,640
is not equal to 500,

942
01:07:20,530 --> 01:07:24,026
so we are allowed to write some production

943
01:07:24,058 --> 01:07:27,950
code. Now first of all, let's grab

944
01:07:28,030 --> 01:07:31,858
the result of this transaction in a variable called

945
01:07:31,944 --> 01:07:35,634
error. In this way we can

946
01:07:35,672 --> 01:07:39,560
inspect this error if

947
01:07:40,010 --> 01:07:42,840
errors is,

948
01:07:43,210 --> 01:07:46,614
which is a function introduced by the GO

949
01:07:46,732 --> 01:07:50,598
113 version that can assert if

950
01:07:50,684 --> 01:07:53,994
an error is of a specific type and

951
01:07:54,032 --> 01:07:57,580
it return a boolean representing this match.

952
01:07:59,710 --> 01:08:03,458
The second parameter is the actual error,

953
01:08:03,654 --> 01:08:07,600
that is error record not found.

954
01:08:08,290 --> 01:08:09,360
If so,

955
01:08:11,730 --> 01:08:16,434
we are going to write the 404 not

956
01:08:16,472 --> 01:08:22,594
found status code and

957
01:08:22,712 --> 01:08:26,530
we force it to be written

958
01:08:28,390 --> 01:08:29,640
and we return.

959
01:08:31,210 --> 01:08:34,514
Otherwise, the old logic

960
01:08:34,562 --> 01:08:41,086
still relying

961
01:08:41,218 --> 01:08:46,538
if we rerun the test now

962
01:08:46,704 --> 01:08:50,906
we have in the red, in the green area because we

963
01:08:50,928 --> 01:08:52,650
got a positive outcome.

964
01:08:55,250 --> 01:08:59,694
What we can do is do a tiny refactoring by

965
01:08:59,732 --> 01:09:03,146
using HTTP status

966
01:09:03,258 --> 01:09:06,710
not found constant

967
01:09:06,890 --> 01:09:13,122
provided by the HTTP package and

968
01:09:13,176 --> 01:09:14,900
everything is still good.

969
01:09:19,610 --> 01:09:23,222
Now let's do

970
01:09:23,276 --> 01:09:26,934
something more. On this scenario we

971
01:09:26,972 --> 01:09:31,270
would like also to test the body. So let's duplicate

972
01:09:31,950 --> 01:09:36,566
this test and then let's

973
01:09:36,678 --> 01:09:38,890
append the body suffix.

974
01:09:39,550 --> 01:09:43,094
All right, and let's

975
01:09:43,142 --> 01:09:47,166
change this assertion because now we

976
01:09:47,268 --> 01:09:50,974
would like to write an assertion for

977
01:09:51,012 --> 01:09:54,974
the body. So we are going to use the contains function of

978
01:09:55,012 --> 01:09:58,180
the assert package and

979
01:09:58,710 --> 01:10:01,954
in the body string we

980
01:10:01,992 --> 01:10:05,474
expect this particular message

981
01:10:05,672 --> 01:10:09,146
to do not found because in this scenario

982
01:10:09,278 --> 01:10:11,990
the to do is not found in our database.

983
01:10:12,810 --> 01:10:16,642
For example, we have only ten to dos

984
01:10:16,786 --> 01:10:20,598
and we request for the to do with the id number

985
01:10:20,684 --> 01:10:24,506
20. So in this scenario we would like to

986
01:10:24,528 --> 01:10:28,662
return and inform the client that the to do is unknown

987
01:10:28,806 --> 01:10:30,060
on our system.

988
01:10:32,270 --> 01:10:35,774
All right, let's rerun the

989
01:10:35,812 --> 01:10:39,246
test and we are in the

990
01:10:39,268 --> 01:10:42,522
red area because string empty does not contain

991
01:10:42,586 --> 01:10:43,840
to do not found.

992
01:10:47,930 --> 01:10:51,000
So we are going to change it a little bit

993
01:10:52,490 --> 01:10:55,702
with c string and then

994
01:10:55,836 --> 01:10:59,814
to do not found we

995
01:10:59,852 --> 01:11:03,674
no longer need the force of the eder and

996
01:11:03,712 --> 01:11:07,402
then we can rerun our test and our

997
01:11:07,456 --> 01:11:09,290
tests are successfully.

998
01:11:12,450 --> 01:11:15,482
Now let's introduce another constant

999
01:11:15,546 --> 01:11:19,514
to get rid of this magic number. So let's duplicate

1000
01:11:19,562 --> 01:11:24,062
the latest variable constant defined here and

1001
01:11:24,116 --> 01:11:29,762
add a not found there with

1002
01:11:29,816 --> 01:11:33,922
the label to do not found here

1003
01:11:33,976 --> 01:11:41,622
we switch it to the variable and

1004
01:11:41,676 --> 01:11:43,800
we switch also in our test,

1005
01:11:54,030 --> 01:11:57,900
if we rerun our tests, everything is okay.

1006
01:12:00,350 --> 01:12:04,502
Now we can merge these

1007
01:12:04,576 --> 01:12:12,830
two files into one's,

1008
01:12:13,490 --> 01:12:17,780
rerun our tests to be sure that we still are

1009
01:12:18,390 --> 01:12:21,614
with 100% of code coverage.

1010
01:12:21,662 --> 01:12:25,620
And there we go is exactly in this way.

1011
01:12:27,370 --> 01:12:31,478
Now we can do another refactoring because

1012
01:12:31,644 --> 01:12:35,654
it's very unlikely that we are going to reply with

1013
01:12:35,692 --> 01:12:39,746
a string, a plain text response

1014
01:12:39,778 --> 01:12:43,750
payload. Usually when designing a rest API,

1015
01:12:43,830 --> 01:12:47,126
it's pretty common to reply with the JSON format,

1016
01:12:47,318 --> 01:12:50,554
maybe a common format for all

1017
01:12:50,592 --> 01:12:54,254
of the error. So let's define this because

1018
01:12:54,292 --> 01:12:57,070
now we can improve our working solution.

1019
01:12:57,730 --> 01:12:59,950
So I'm going to switch to models.

1020
01:13:01,570 --> 01:13:05,266
I'm going to define a new struct called to

1021
01:13:05,288 --> 01:13:09,182
do error. Sorry for the naming,

1022
01:13:09,246 --> 01:13:12,674
but it's only a

1023
01:13:12,712 --> 01:13:16,130
session so you can choose for sure better

1024
01:13:16,200 --> 01:13:19,720
names for your real world project.

1025
01:13:21,290 --> 01:13:25,334
And we are going to add two

1026
01:13:25,532 --> 01:13:29,750
fields, one code of type string

1027
01:13:30,510 --> 01:13:33,340
with the JSON annotation code.

1028
01:13:34,430 --> 01:13:38,106
This code will contain only a short description of

1029
01:13:38,128 --> 01:13:42,250
the error and it will be represented by our

1030
01:13:42,320 --> 01:13:45,678
case by our constants that

1031
01:13:45,764 --> 01:13:48,990
map one to one with our scenario.

1032
01:13:49,570 --> 01:13:53,582
And then we will have a message with a more

1033
01:13:53,716 --> 01:13:56,914
verbose explanation of what was wrong.

1034
01:13:57,112 --> 01:14:00,820
So from the message

1035
01:14:01,830 --> 01:14:11,860
you can highlight and spot the error. Hopefully it

1036
01:14:12,630 --> 01:14:13,860
here we go.

1037
01:14:15,670 --> 01:14:19,634
Now instead of returning a string, let's return a

1038
01:14:19,672 --> 01:14:20,650
G's zone,

1039
01:14:23,230 --> 01:14:26,250
the JSON expect as the string,

1040
01:14:26,670 --> 01:14:30,090
the status code as the first parameter and then

1041
01:14:30,160 --> 01:14:33,470
an object to be serialized on the response.

1042
01:14:33,890 --> 01:14:37,246
In our case is models to

1043
01:14:37,268 --> 01:14:40,526
do error and we are going

1044
01:14:40,548 --> 01:14:46,898
to specify the code and

1045
01:14:46,984 --> 01:14:50,260
also the message because here we have the message,

1046
01:14:55,350 --> 01:14:58,658
we we replicate the same behavior

1047
01:14:58,754 --> 01:15:02,070
also for the validation error,

1048
01:15:04,170 --> 01:15:07,670
models to do error

1049
01:15:13,870 --> 01:15:22,970
and also the message also

1050
01:15:23,040 --> 01:15:26,586
for the latest two which are

1051
01:15:26,768 --> 01:15:27,770
JSON.

1052
01:16:15,970 --> 01:16:16,960
All right,

1053
01:16:19,330 --> 01:16:22,830
now the message with the error.

1054
01:16:24,050 --> 01:16:28,386
Here we go. So we refactor everything

1055
01:16:28,568 --> 01:16:32,542
with the usage of the JSOn format.

1056
01:16:32,686 --> 01:16:36,050
So we are going to reply instead of textplane

1057
01:16:37,370 --> 01:16:40,710
type of response with the application JSON.

1058
01:16:42,170 --> 01:16:46,982
Now let's rerun the test and

1059
01:16:47,036 --> 01:16:48,680
everything is still okay.

1060
01:16:50,590 --> 01:16:54,218
So now we are ready to face the last

1061
01:16:54,304 --> 01:16:57,734
scenario which is the EPIPH scenario,

1062
01:16:57,862 --> 01:17:00,940
the scenario in which everything goes well.

1063
01:17:01,710 --> 01:17:04,794
No id, poorly formatted,

1064
01:17:04,922 --> 01:17:08,320
no invalid request type.

1065
01:17:08,850 --> 01:17:13,034
Vdb is behaving correctly, no unexpected

1066
01:17:13,082 --> 01:17:17,122
error and the to do is present is

1067
01:17:17,176 --> 01:17:20,100
existent within our code base.

1068
01:17:20,470 --> 01:17:24,450
So everything goes okay and we have to reply

1069
01:17:25,990 --> 01:17:30,280
with the 202 accepted status code.

1070
01:17:31,290 --> 01:17:38,054
So let's rename it to EPIPH and

1071
01:17:38,092 --> 01:17:43,210
then let's refactor a little bit our

1072
01:17:43,280 --> 01:17:47,562
code first

1073
01:17:47,616 --> 01:17:50,998
of all we have to define a new variable

1074
01:17:51,094 --> 01:17:54,734
called rows. These rows are

1075
01:17:54,772 --> 01:17:57,902
the rows returned by our query because

1076
01:17:57,956 --> 01:18:01,262
now we actually found our

1077
01:18:01,316 --> 01:18:05,390
record. So sql mock

1078
01:18:05,750 --> 01:18:09,886
new rows. It will expect a slice

1079
01:18:09,918 --> 01:18:14,100
of string which are the column to return.

1080
01:18:15,990 --> 01:18:19,670
We set up the description, sorry, the id,

1081
01:18:19,740 --> 01:18:23,430
the description is completed

1082
01:18:27,210 --> 01:18:28,680
and the due date.

1083
01:18:31,470 --> 01:18:34,986
Then we invoke the method row which expect

1084
01:18:35,088 --> 01:18:38,586
the actual value to return. Here we

1085
01:18:38,608 --> 01:18:42,498
are going to return one as id sample

1086
01:18:42,614 --> 01:18:46,586
to do as description false

1087
01:18:46,778 --> 01:18:51,270
as is completed and 2023

1088
01:18:51,280 --> 01:18:55,442
215 as

1089
01:18:55,496 --> 01:18:56,340
the date.

1090
01:18:59,510 --> 01:19:03,042
Then in our expect query, instead of

1091
01:19:03,096 --> 01:19:06,914
returning an error, we actually return the

1092
01:19:06,952 --> 01:19:11,190
rows and the rows are the one that we just defined.

1093
01:19:14,330 --> 01:19:18,694
Furthermore, here we have also to forecast a

1094
01:19:18,732 --> 01:19:22,074
command. So we have to issue an

1095
01:19:22,112 --> 01:19:26,954
expect begin and

1096
01:19:26,992 --> 01:19:30,010
then we expect also a commit.

1097
01:19:30,990 --> 01:19:34,926
So we wrap the command between a begin and

1098
01:19:34,948 --> 01:19:38,800
the commit. If we expect something wrong

1099
01:19:39,250 --> 01:19:43,470
instead of commit we are going to expect the rollback

1100
01:19:45,430 --> 01:19:50,798
inside. We expect an exec provided

1101
01:19:50,894 --> 01:19:54,850
within backtick and the command is update

1102
01:19:56,630 --> 01:20:00,420
to DOS set

1103
01:20:02,230 --> 01:20:11,094
description equal

1104
01:20:11,142 --> 01:20:15,690
to dollar one, then is completed

1105
01:20:19,070 --> 01:20:20,780
equal to dollar two,

1106
01:20:21,630 --> 01:20:26,906
then due date equal

1107
01:20:26,938 --> 01:20:28,320
to dollar free.

1108
01:20:30,930 --> 01:20:36,340
Where to dos Id

1109
01:20:40,550 --> 01:20:42,820
equal to dollar four.

1110
01:20:45,990 --> 01:20:49,186
Keep in mind that we have to add this condition,

1111
01:20:49,298 --> 01:20:52,722
otherwise we end up in editing

1112
01:20:52,866 --> 01:20:56,310
or updating all the records of the table.

1113
01:20:57,290 --> 01:21:00,586
Another quick note that I

1114
01:21:00,608 --> 01:21:04,054
would like to mention. If we specify the query

1115
01:21:04,102 --> 01:21:08,182
matcher equal. You have also to keep attention

1116
01:21:08,326 --> 01:21:12,614
to the spaces in our query because the query should be exactly

1117
01:21:12,752 --> 01:21:13,680
the same.

1118
01:21:16,930 --> 01:21:19,870
Now we have to specify the arguments,

1119
01:21:20,930 --> 01:21:25,082
all right, and the arguments can be found here

1120
01:21:25,236 --> 01:21:28,690
in the payload that we accept from our client.

1121
01:21:29,030 --> 01:21:33,090
So the description is lorem ipsum.

1122
01:21:36,550 --> 01:21:39,240
The is completed is true.

1123
01:21:40,650 --> 01:21:45,030
The due date is 2023 50

1124
01:21:45,100 --> 01:21:48,280
five and the id is one.

1125
01:21:51,070 --> 01:21:55,420
This will return a result and this result

1126
01:21:58,030 --> 01:22:01,802
with zero as last insert id and

1127
01:22:01,856 --> 01:22:03,520
rows affected one.

1128
01:22:08,450 --> 01:22:10,480
So we are good to go.

1129
01:22:11,810 --> 01:22:15,874
The assertion that we have to change is we

1130
01:22:15,912 --> 01:22:19,394
no longer assert on the body because in this scenario we

1131
01:22:19,432 --> 01:22:23,090
won't have a body. We only have a

1132
01:22:23,240 --> 01:22:27,830
status code and then we put 202

1133
01:22:27,900 --> 01:22:30,360
as the expected status code.

1134
01:22:32,170 --> 01:22:36,790
Here we go. We can run our

1135
01:22:36,860 --> 01:22:40,360
handlers now we can run our test

1136
01:22:41,390 --> 01:22:49,690
and we got an error

1137
01:22:50,270 --> 01:22:53,742
because we are trying to access

1138
01:22:53,876 --> 01:22:57,294
a nil value. If we look

1139
01:22:57,492 --> 01:23:01,262
closer to the stack trace we can see that

1140
01:23:01,316 --> 01:23:04,478
the line involved is the 39.

1141
01:23:04,644 --> 01:23:08,002
If you can see from this line it says

1142
01:23:08,056 --> 01:23:11,780
that is the 39. That's why here

1143
01:23:12,150 --> 01:23:15,170
we are trying to access this error.

1144
01:23:16,150 --> 01:23:20,054
All right, but this error is

1145
01:23:20,092 --> 01:23:23,906
nil because now the mock is not returning

1146
01:23:23,938 --> 01:23:27,240
any error. All right,

1147
01:23:28,570 --> 01:23:36,474
so let's fix this by avoiding to

1148
01:23:36,512 --> 01:23:39,180
invoke this. In this case,

1149
01:23:40,910 --> 01:23:45,214
if we rerun the test we

1150
01:23:45,252 --> 01:23:49,230
can see that there are this actual

1151
01:23:49,300 --> 01:23:52,766
error. The error is we expect

1152
01:23:52,868 --> 01:23:56,178
202 but we got 500 and also

1153
01:23:56,264 --> 01:24:00,610
there are unmatched expectation because

1154
01:24:00,680 --> 01:24:04,414
we expect a begin, we expect a command and we didn't

1155
01:24:04,462 --> 01:24:07,598
write the command yet, right?

1156
01:24:07,784 --> 01:24:09,640
So let's fix this.

1157
01:24:11,050 --> 01:24:14,550
The first thing that we have to do is

1158
01:24:14,620 --> 01:24:18,214
to declare a

1159
01:24:18,252 --> 01:24:21,722
variable of type to do and this to do is the one

1160
01:24:21,776 --> 01:24:24,570
that will be updated on the database.

1161
01:24:25,950 --> 01:24:29,354
So we are going to instantiate a to do to

1162
01:24:29,392 --> 01:24:33,370
save variable of type models

1163
01:24:34,210 --> 01:24:38,494
to do and we set only the

1164
01:24:38,532 --> 01:24:42,526
column that we are going to change description to

1165
01:24:42,548 --> 01:24:46,690
do DTO description when is completed

1166
01:24:47,510 --> 01:24:50,370
from the to do DTO is completed,

1167
01:24:50,710 --> 01:24:53,954
then the

1168
01:24:54,072 --> 01:24:57,860
due date from the to do DTO due date.

1169
01:24:58,570 --> 01:25:02,018
Keep in mind that this logic is the mapping logic

1170
01:25:02,114 --> 01:25:06,054
between the DTO and our model. In an

1171
01:25:06,092 --> 01:25:09,602
even more complex application it can be extrapolated

1172
01:25:09,666 --> 01:25:13,530
into a service and we can write tests against this

1173
01:25:13,600 --> 01:25:17,194
service. However, for the sake of

1174
01:25:17,232 --> 01:25:20,490
the time we are not going to deal

1175
01:25:20,560 --> 01:25:23,230
with such complex scenario.

1176
01:25:25,810 --> 01:25:29,534
Then with this to

1177
01:25:29,572 --> 01:25:32,030
do we are going to invoke the updates,

1178
01:25:33,250 --> 01:25:36,594
the updates method and we pass a

1179
01:25:36,632 --> 01:25:39,460
pointer to this variable to do to save.

1180
01:25:42,980 --> 01:25:46,640
Then we check for the error.

1181
01:25:46,980 --> 01:25:50,500
So we prepend an if and we check

1182
01:25:50,570 --> 01:25:51,700
for the error.

1183
01:25:56,040 --> 01:25:59,750
We move this logic within

1184
01:26:00,680 --> 01:26:04,552
the dave. So this logic will be

1185
01:26:04,606 --> 01:26:09,012
executed only if the GormDB

1186
01:26:09,076 --> 01:26:13,332
client will return an error, otherwise we can skip

1187
01:26:13,396 --> 01:26:16,892
it at all. Now in this case

1188
01:26:16,946 --> 01:26:22,008
we are sure that the error is always populated

1189
01:26:22,184 --> 01:26:26,408
so it's safe to invoke error error and

1190
01:26:26,514 --> 01:26:28,210
return from it.

1191
01:26:32,660 --> 01:26:36,496
If no error is encountered, we are going to

1192
01:26:36,518 --> 01:26:40,260
return our header

1193
01:26:41,240 --> 01:26:52,768
and we have to force it's

1194
01:26:52,944 --> 01:26:56,410
if we run go test v cover.

1195
01:26:57,260 --> 01:27:01,144
Now everything is okay and we

1196
01:27:01,262 --> 01:27:04,280
meet all of the expectation of the mock.

1197
01:27:06,080 --> 01:27:08,940
Let's do a small refactor.

1198
01:27:16,080 --> 01:27:18,690
All right, here we go. Now,

1199
01:27:20,020 --> 01:27:24,016
the last part that I would like to mention is that

1200
01:27:24,198 --> 01:27:27,952
usually this db logic is not placed here

1201
01:27:28,086 --> 01:27:31,808
because this method is becoming

1202
01:27:31,904 --> 01:27:35,780
too much bloated. So let's define a new package,

1203
01:27:38,280 --> 01:27:41,460
this package, it will be called repo package.

1204
01:27:46,460 --> 01:27:50,520
We are going to create a repo,

1205
01:27:51,100 --> 01:27:53,800
a repo file within the repo package.

1206
01:28:00,480 --> 01:28:03,992
All right, let's define the package which is a repo,

1207
01:28:04,056 --> 01:28:07,692
and also define the function that is updated.

1208
01:28:07,756 --> 01:28:11,360
To do it will expect adb

1209
01:28:12,340 --> 01:28:15,440
as Gorm db,

1210
01:28:17,460 --> 01:28:21,012
an Id as integer, and also a

1211
01:28:21,066 --> 01:28:24,772
to do to save of

1212
01:28:24,826 --> 01:28:29,636
type models to

1213
01:28:29,658 --> 01:28:33,160
do and it will return an error.

1214
01:28:37,020 --> 01:28:42,612
Let's put return nil in order to satisfy

1215
01:28:42,676 --> 01:28:47,644
his complaint and then let's copy this

1216
01:28:47,682 --> 01:28:55,260
logic over there's

1217
01:28:57,700 --> 01:29:01,344
all right here we

1218
01:29:01,382 --> 01:29:04,768
had a couple of refactoring to do. First of all,

1219
01:29:04,854 --> 01:29:07,040
let's assign the error.

1220
01:29:09,080 --> 01:29:12,224
Then let's add the eros

1221
01:29:12,272 --> 01:29:16,212
package and also add

1222
01:29:16,266 --> 01:29:19,140
the net HTTP.

1223
01:29:25,740 --> 01:29:30,504
Then we have to return an

1224
01:29:30,542 --> 01:29:32,650
error model, only the model.

1225
01:29:45,580 --> 01:29:49,308
All right, and the same applies

1226
01:29:49,404 --> 01:29:50,050
here.

1227
01:29:56,820 --> 01:30:02,404
Now go is complaining about

1228
01:30:02,522 --> 01:30:05,908
the fact that to do error is not a

1229
01:30:05,914 --> 01:30:09,316
valid error. That's why in order to be

1230
01:30:09,338 --> 01:30:13,560
recognized as an error, it has to implement an interface.

1231
01:30:14,780 --> 01:30:18,840
So we are going to implement this interface.

1232
01:30:20,300 --> 01:30:24,440
The interface method is called error without

1233
01:30:24,510 --> 01:30:27,660
any arguments and it will return a string.

1234
01:30:35,520 --> 01:30:37,980
Here we go. Now we satisfied,

1235
01:30:40,980 --> 01:30:45,024
we satisfied his

1236
01:30:45,062 --> 01:30:48,880
complaint. However, we can do even

1237
01:30:48,950 --> 01:30:52,884
better because now we typecast it.

1238
01:30:53,082 --> 01:30:56,436
We typecast the error here and then we

1239
01:30:56,458 --> 01:31:00,710
have to typecast also the error here in order to understand

1240
01:31:01,080 --> 01:31:04,280
which status code actually returned to the client.

1241
01:31:05,100 --> 01:31:08,936
A smart way of achieving this is to add

1242
01:31:09,118 --> 01:31:12,010
another field here,

1243
01:31:12,460 --> 01:31:15,784
maybe a field called status code of

1244
01:31:15,822 --> 01:31:19,488
type int. And we add a JSOn

1245
01:31:19,524 --> 01:31:23,356
annotation dash, which means in

1246
01:31:23,378 --> 01:31:27,424
your it. So when you are about to marshall it, you can

1247
01:31:27,462 --> 01:31:28,930
ignore this field.

1248
01:31:31,300 --> 01:31:35,568
So in this way we can assert and

1249
01:31:35,654 --> 01:31:39,812
use the status code and set the

1250
01:31:39,946 --> 01:31:43,524
HTTP response status code by reading that value,

1251
01:31:43,642 --> 01:31:47,988
and that value will not be copied again within

1252
01:31:48,074 --> 01:31:49,700
the response payload.

1253
01:31:52,060 --> 01:31:56,280
So let's do this HTTP not

1254
01:31:56,350 --> 01:32:00,120
found and then

1255
01:32:00,270 --> 01:32:13,080
also for this HTTP

1256
01:32:13,500 --> 01:32:17,650
internal it.

1257
01:32:19,460 --> 01:32:23,250
Now let's switch the code here because now

1258
01:32:23,700 --> 01:32:27,490
what we have to do here is to

1259
01:32:28,100 --> 01:32:31,684
define a to do error which

1260
01:32:31,722 --> 01:32:35,440
is typecasted from the models.

1261
01:32:35,520 --> 01:32:39,476
To do error in this way, to do error is

1262
01:32:39,578 --> 01:32:43,192
our error and we can use its value and

1263
01:32:43,246 --> 01:32:46,904
its fields such as the status code. And we actually

1264
01:32:47,022 --> 01:32:48,330
are going to do this.

1265
01:32:50,700 --> 01:32:54,164
The gzone status code is the status code

1266
01:32:54,302 --> 01:32:58,444
within the to do error variable, and then we

1267
01:32:58,482 --> 01:33:02,750
simply reference it this way

1268
01:33:03,680 --> 01:33:06,300
if we rerun the tests.

1269
01:33:18,450 --> 01:33:19,680
Oh my God,

1270
01:33:22,530 --> 01:33:24,160
let me redo this.

1271
01:33:40,070 --> 01:33:40,980
All right,

1272
01:33:43,510 --> 01:33:46,850
let me redo. All right,

1273
01:33:46,920 --> 01:33:50,260
here we could try to run our test.

1274
01:33:50,950 --> 01:33:54,806
However, we need to invoke the

1275
01:33:54,828 --> 01:34:01,810
new function created. So repo update

1276
01:34:01,890 --> 01:34:05,850
to do and we actually pass the db,

1277
01:34:07,630 --> 01:34:15,866
the id and the to do to save it

1278
01:34:15,968 --> 01:34:19,374
when if we run it, everything should

1279
01:34:19,412 --> 01:34:20,320
be okay.

1280
01:34:25,490 --> 01:34:28,842
Now we have successfully designed our handler,

1281
01:34:28,906 --> 01:34:32,834
our models, our repo. Let's wire them up

1282
01:34:32,952 --> 01:34:36,594
in a main file because at the end

1283
01:34:36,792 --> 01:34:40,322
we need to have something that actually run our

1284
01:34:40,376 --> 01:34:44,242
application. So let's define

1285
01:34:44,306 --> 01:34:45,750
a main method.

1286
01:34:47,690 --> 01:34:50,930
So here in the workspace root

1287
01:34:51,090 --> 01:34:55,946
we are going to create a package main with

1288
01:34:55,968 --> 01:34:57,420
the funk main.

1289
01:35:00,910 --> 01:35:06,186
But before running this we

1290
01:35:06,208 --> 01:35:09,674
have to run a postgres, a docker

1291
01:35:09,722 --> 01:35:13,034
command in order to spin up a postgres

1292
01:35:13,082 --> 01:35:17,040
instance. So the command is docker run

1293
01:35:18,210 --> 01:35:22,146
d for detached mode, p for the

1294
01:35:22,168 --> 01:35:26,098
port mapping, and we map this port

1295
01:35:26,264 --> 01:35:29,700
from my host machine to the container port.

1296
01:35:31,030 --> 01:35:35,682
Then we set an environment variable called postgres

1297
01:35:35,746 --> 01:35:39,014
password equal to

1298
01:35:39,052 --> 01:35:43,494
postgres and then the image to

1299
01:35:43,532 --> 01:35:45,430
base our container.

1300
01:35:47,310 --> 01:35:50,682
In this case it successfully spin up

1301
01:35:50,736 --> 01:35:52,330
a docker container.

1302
01:35:54,270 --> 01:35:56,780
Now we are ready to connect.

1303
01:35:57,890 --> 01:36:02,782
First of all, let's define a DSN which

1304
01:36:02,836 --> 01:36:06,350
involves host equal to localhost,

1305
01:36:08,610 --> 01:36:14,340
then port equal to 54322,

1306
01:36:16,550 --> 01:36:21,410
a user which is postgres password

1307
01:36:23,370 --> 01:36:27,846
which is postgres db name

1308
01:36:28,028 --> 01:36:30,310
which is still postgres,

1309
01:36:31,530 --> 01:36:35,030
and the SSL mode equal to disable.

1310
01:36:36,190 --> 01:36:39,580
This is for sure for the sake of demo.

1311
01:36:40,110 --> 01:36:43,530
I'm not expecting that any of you actually pass

1312
01:36:43,600 --> 01:36:46,940
a connection string or DSN in this way,

1313
01:36:48,530 --> 01:36:51,790
but it's completely fine for local development.

1314
01:36:52,850 --> 01:36:56,030
Then we are going to instantiate a gormdb

1315
01:36:56,610 --> 01:37:00,598
and the error by invoking the gorm

1316
01:37:00,794 --> 01:37:04,740
open function which expect in

1317
01:37:05,190 --> 01:37:08,994
a dialector which is provided by

1318
01:37:09,032 --> 01:37:13,750
the postgres open with

1319
01:37:13,820 --> 01:37:14,790
DSN.

1320
01:37:18,970 --> 01:37:22,962
If the error is not nil, we immediately

1321
01:37:23,026 --> 01:37:26,538
stop the application because the connectivity is not working

1322
01:37:26,624 --> 01:37:27,610
properly.

1323
01:37:32,670 --> 01:37:36,890
Then we have to run the auto migration

1324
01:37:37,970 --> 01:37:42,026
in order to auto

1325
01:37:42,058 --> 01:37:46,426
create the tables.

1326
01:37:46,618 --> 01:37:50,910
In this case, if we don't have the table, the table will be created

1327
01:37:50,990 --> 01:37:54,706
if we have other column. This column will be added and

1328
01:37:54,728 --> 01:37:58,590
so on and so forth. It will keep automatically synchronized

1329
01:37:58,670 --> 01:38:01,570
our structure to our tables.

1330
01:38:03,370 --> 01:38:06,360
Then we add a start,

1331
01:38:08,490 --> 01:38:12,294
let's say an initial to do

1332
01:38:12,412 --> 01:38:18,154
just for the sake of demo models to

1333
01:38:18,192 --> 01:38:22,326
do and we specify the id equal

1334
01:38:22,358 --> 01:38:25,930
to one, the description equal to

1335
01:38:26,080 --> 01:38:35,882
sample to do where

1336
01:38:35,936 --> 01:38:41,010
is completed equal to false,

1337
01:38:42,310 --> 01:38:47,906
and the due date equal to 2023

1338
01:38:47,928 --> 01:38:51,140
215.

1339
01:38:53,530 --> 01:38:56,870
Then we have to take care of gain.

1340
01:38:57,690 --> 01:39:01,670
We have to set up the mode which is gin

1341
01:39:02,650 --> 01:39:06,026
debug mode. And then we

1342
01:39:06,048 --> 01:39:10,118
have to create a router by invoking

1343
01:39:10,214 --> 01:39:12,060
the default function.

1344
01:39:15,310 --> 01:39:19,582
Then we instrument the router to reply to

1345
01:39:19,636 --> 01:39:25,214
the put action at

1346
01:39:25,252 --> 01:39:28,810
this route and then we invoke

1347
01:39:28,890 --> 01:39:33,022
Android update

1348
01:39:33,086 --> 01:39:37,310
to do error

1349
01:39:37,470 --> 01:39:40,340
run to run our application.

1350
01:39:42,970 --> 01:39:47,126
The last thing that we missed is to actually

1351
01:39:47,228 --> 01:39:51,030
provide the GormDB. In this case

1352
01:39:51,100 --> 01:39:54,434
we are going to use a middleware for injecting

1353
01:39:54,482 --> 01:39:58,214
the Gormdb in each HTTP request session

1354
01:39:58,262 --> 01:39:59,580
that we are going to manage.

1355
01:40:04,270 --> 01:40:08,358
The first thing when you are about to inject

1356
01:40:08,454 --> 01:40:12,494
some code in a middleware is to remember to

1357
01:40:12,612 --> 01:40:15,914
call the next middleware. So I suggest

1358
01:40:15,962 --> 01:40:19,438
you to do it first and then

1359
01:40:19,524 --> 01:40:23,730
leave this invocation at the bottom of this code snippet

1360
01:40:25,510 --> 01:40:29,378
here we are going to invoke set as we did in our test

1361
01:40:29,464 --> 01:40:34,114
and we provide Android db

1362
01:40:34,162 --> 01:40:38,390
key which is the constant we defined in the Android package.

1363
01:40:40,010 --> 01:40:45,706
And then we pass the Gormdb as

1364
01:40:45,728 --> 01:40:49,660
a best practice. Keep in mind to always use

1365
01:40:50,270 --> 01:40:53,414
the timeout context in order to cancel

1366
01:40:53,542 --> 01:40:57,938
and avoid to do unnecessary operation on IO

1367
01:40:57,974 --> 01:41:00,190
resources such as a database.

1368
01:41:01,170 --> 01:41:05,514
So let's do this. Let's define a new concepts

1369
01:41:05,642 --> 01:41:09,614
called timeout context and a

1370
01:41:09,652 --> 01:41:10,740
cancel function.

1371
01:41:13,110 --> 01:41:16,914
We invoke the context with timeout function and

1372
01:41:16,952 --> 01:41:20,542
we passed to it the request

1373
01:41:20,606 --> 01:41:24,360
context together with the expiration time.

1374
01:41:25,210 --> 01:41:28,790
For our demo we can do 5 seconds.

1375
01:41:29,610 --> 01:41:33,522
Keep in mind to defer the invocation of the cancel

1376
01:41:33,586 --> 01:41:37,466
function. Then we

1377
01:41:37,488 --> 01:41:41,274
are going to use the with context in order to give

1378
01:41:41,312 --> 01:41:45,434
a context timeout to our GormdB. And we

1379
01:41:45,472 --> 01:41:47,770
passed the timeout context.

1380
01:41:50,850 --> 01:41:54,878
All right, now we can run

1381
01:41:54,964 --> 01:41:58,366
some tests with Postman. So in

1382
01:41:58,388 --> 01:42:02,414
order to run our application, let's switch

1383
01:42:02,462 --> 01:42:05,700
back to the main and issue a go run.

1384
01:42:06,710 --> 01:42:11,122
As you can see here, the server is starting and

1385
01:42:11,176 --> 01:42:14,710
is waiting for incoming request to be managed.

1386
01:42:17,930 --> 01:42:21,814
Here we go. We are in postman now and

1387
01:42:21,932 --> 01:42:25,574
I prepared the scenario. One request

1388
01:42:25,622 --> 01:42:29,926
for each scenario. The first one is the epipath.

1389
01:42:30,038 --> 01:42:33,594
So let's run it and we got a 202

1390
01:42:33,632 --> 01:42:37,774
status accepted. The second one is with a

1391
01:42:37,812 --> 01:42:41,614
wrong integer ABC. So if

1392
01:42:41,652 --> 01:42:45,150
we still run it, we have a bad request.

1393
01:42:46,690 --> 01:42:51,090
The table not found scenario is not easy to test

1394
01:42:51,240 --> 01:42:54,994
because we had to actually change the code and maybe we can do

1395
01:42:55,032 --> 01:42:58,974
it later. The validation error

1396
01:42:59,102 --> 01:43:04,946
instead doesn't have a description set and

1397
01:43:05,048 --> 01:43:07,750
we have the 400 build request.

1398
01:43:08,570 --> 01:43:13,750
The last one is the to do not found which

1399
01:43:13,820 --> 01:43:17,900
actually reply 404 status not found.

1400
01:43:18,430 --> 01:43:23,898
Now we can try to test

1401
01:43:23,984 --> 01:43:27,854
this scenario with

1402
01:43:27,892 --> 01:43:31,166
a small tweaks, a small gotcha that I'm going to

1403
01:43:31,188 --> 01:43:34,910
show you in the code. All right,

1404
01:43:35,060 --> 01:43:39,034
in the code we can mock the database

1405
01:43:39,082 --> 01:43:43,570
error. In this way you have to go to the repo,

1406
01:43:45,430 --> 01:43:48,978
define a variable called test of type

1407
01:43:49,064 --> 01:43:53,926
string and then issue a

1408
01:43:53,948 --> 01:43:59,160
sample command, a command that emulate some

1409
01:43:59,770 --> 01:44:02,658
intensive workload on the database.

1410
01:44:02,834 --> 01:44:06,942
In our case it will be a simple weight.

1411
01:44:07,106 --> 01:44:11,226
So in the row let's add select

1412
01:44:11,408 --> 01:44:15,420
PG underscore sleep and

1413
01:44:16,030 --> 01:44:19,870
we told him to sleep for 10 seconds.

1414
01:44:20,370 --> 01:44:25,280
In this way we are going to wait for

1415
01:44:26,290 --> 01:44:29,840
the connection for 10 seconds and this

1416
01:44:30,470 --> 01:44:34,878
should return a concepts exceeded

1417
01:44:34,974 --> 01:44:38,626
error. Then we invoke the

1418
01:44:38,648 --> 01:44:42,730
scan in order to actually materialize the query

1419
01:44:42,830 --> 01:44:46,694
to the database and we passed in the point the

1420
01:44:46,732 --> 01:44:48,550
address of the test variable.

1421
01:44:50,570 --> 01:44:53,718
All right, now we should

1422
01:44:53,884 --> 01:44:57,740
be able to rerun our application again.

1423
01:44:59,790 --> 01:45:03,530
In the postman we can try to issue okay,

1424
01:45:03,600 --> 01:45:07,306
let me redo this again.

1425
01:45:07,408 --> 01:45:10,794
In postman we can test for this newly

1426
01:45:10,842 --> 01:45:14,334
created scenario. Now if we run any

1427
01:45:14,452 --> 01:45:18,558
of our query it will be post for 10 seconds and

1428
01:45:18,644 --> 01:45:22,046
it should cause an error 500 error.

1429
01:45:22,158 --> 01:45:25,518
So let's invoke it. It hangs

1430
01:45:25,614 --> 01:45:29,314
for a while and

1431
01:45:29,352 --> 01:45:32,980
then we got back this

1432
01:45:33,350 --> 01:45:37,422
message. DB error and concepts deadline exceeded

1433
01:45:37,566 --> 01:45:41,538
500 so we would able to test also

1434
01:45:41,704 --> 01:45:45,850
this scenario. All right, this finish

1435
01:45:45,920 --> 01:45:49,834
my session about test driven development with go

1436
01:45:50,032 --> 01:45:52,460
on the screen you can see my social.

1437
01:45:53,230 --> 01:45:56,858
If you'd like, you can add me on each of them.

1438
01:45:56,944 --> 01:46:00,714
I will be more than happy. Thanks to all

1439
01:46:00,752 --> 01:46:01,350
for their attention.

