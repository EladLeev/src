1
00:00:00,570 --> 00:00:05,274
All right, let's talk about geodistributed applications

2
00:00:05,402 --> 00:00:08,906
and see how to build those by using the global

3
00:00:08,938 --> 00:00:12,490
cloud infrastructure. In this session,

4
00:00:12,570 --> 00:00:16,318
we are going to talk about high level architectural design

5
00:00:16,404 --> 00:00:19,722
patterns and consideration. This session

6
00:00:19,786 --> 00:00:23,034
is not tailored to any specific programming language.

7
00:00:23,162 --> 00:00:27,154
Instead, we will see how to build those applications,

8
00:00:27,202 --> 00:00:30,434
how to design the data layer, how to arrange

9
00:00:30,482 --> 00:00:34,674
our microservices, and there are other parts of the application stack.

10
00:00:34,802 --> 00:00:38,154
But then when it comes to the development, it will be up to

11
00:00:38,192 --> 00:00:41,674
you. You will decide how to take these design patterns and

12
00:00:41,712 --> 00:00:45,622
considerations and implement with your favorite programming language.

13
00:00:45,686 --> 00:00:49,482
All right, so, speaking about their

14
00:00:49,536 --> 00:00:53,326
agenda, we will walk through three

15
00:00:53,428 --> 00:00:57,002
steps. Step number one, we need to remind

16
00:00:57,066 --> 00:01:01,226
ourselves of the global cloud infrastructure that is provided

17
00:01:01,258 --> 00:01:04,946
by major cloud vendors. We are going to

18
00:01:04,968 --> 00:01:08,050
talk about different resources, about regions and zones.

19
00:01:08,790 --> 00:01:12,974
After that, we will do an introduction to geodistributed

20
00:01:13,022 --> 00:01:17,174
applications, how those applications are different from standard

21
00:01:17,292 --> 00:01:21,346
applications, what are the benefits, what are the tradeoffs?

22
00:01:21,538 --> 00:01:26,130
And eventually, with step number three, we will practice

23
00:01:26,290 --> 00:01:30,354
in designing and architecting a geodistributed

24
00:01:30,402 --> 00:01:33,574
application by taking a slate like corporate

25
00:01:33,622 --> 00:01:36,060
messenger as an example. Okay,

26
00:01:36,750 --> 00:01:40,118
so the global cloud infrastructure when it comes to

27
00:01:40,144 --> 00:01:43,294
the infrastructure, you know that every cloud

28
00:01:43,412 --> 00:01:46,762
provides various resources. We have virtual

29
00:01:46,826 --> 00:01:51,322
machines, we have network, we have disks

30
00:01:51,386 --> 00:01:55,102
and other types of hardware. And those resources

31
00:01:55,166 --> 00:01:58,318
are grouped and located within regions.

32
00:01:58,494 --> 00:02:02,354
A region is an independent geographic location, such as

33
00:02:02,392 --> 00:02:06,486
US west one, Europe west two. On this map, we have regions in

34
00:02:06,508 --> 00:02:10,230
North America and South America, Africa and other continents.

35
00:02:10,970 --> 00:02:14,338
When it comes to their speed and latency

36
00:02:14,434 --> 00:02:17,990
within your region, all the resources of a single

37
00:02:18,060 --> 00:02:21,450
region are interconnected through a high performance network.

38
00:02:21,870 --> 00:02:25,738
But what if you need to send, let's say,

39
00:02:25,824 --> 00:02:29,450
requests from one region to another

40
00:02:29,520 --> 00:02:33,550
region? The latency will vary. The latency will depend

41
00:02:33,620 --> 00:02:37,134
on how far each regions are located from each

42
00:02:37,172 --> 00:02:40,494
other. If to take Google compute platform as an

43
00:02:40,532 --> 00:02:44,450
example, then the numbers as follows.

44
00:02:44,950 --> 00:02:48,740
Let's say that we have an instance of application running

45
00:02:50,070 --> 00:02:54,174
in Oregon us west, and we want to send the request

46
00:02:54,222 --> 00:02:58,070
and get an acknowledgment or response from North Virginia.

47
00:02:58,650 --> 00:03:02,742
The average round trip is around 60 milliseconds pretty

48
00:03:02,796 --> 00:03:06,454
fast, right across the country. But if the

49
00:03:06,492 --> 00:03:09,850
same application from Oregon needs to send a request

50
00:03:10,350 --> 00:03:14,074
to London, the latency will double. It will be around

51
00:03:14,112 --> 00:03:17,782
zones hundred and 30 milliseconds. The latency

52
00:03:17,846 --> 00:03:21,398
will be even worse. If our application from Oregon

53
00:03:21,494 --> 00:03:25,214
needs to go to Mumbai in India, the latency will be

54
00:03:25,252 --> 00:03:28,910
around 220 milliseconds. But at the same time,

55
00:03:28,980 --> 00:03:32,870
if your application needs to go to Tokyo through the Pacific,

56
00:03:32,970 --> 00:03:36,782
somewhere here, then the latency will be 90 milliseconds,

57
00:03:36,846 --> 00:03:40,674
much faster than a request and response to

58
00:03:40,712 --> 00:03:44,900
and from Mumbai. So what the conclusion can we make?

59
00:03:45,690 --> 00:03:49,320
All the regions are interconnected through different

60
00:03:49,690 --> 00:03:53,286
networking channels. Some of the channels are

61
00:03:53,308 --> 00:03:57,094
faster, some of the channels are slower. That's why when we

62
00:03:57,132 --> 00:04:00,230
will be talking about geodistributed applications,

63
00:04:00,390 --> 00:04:03,622
the components of those applications, such as the data layer,

64
00:04:03,686 --> 00:04:07,446
application layer microservices will span across the globe.

65
00:04:07,638 --> 00:04:11,054
And you need to be careful about when you pick

66
00:04:11,172 --> 00:04:14,814
specific remote regions because you

67
00:04:14,852 --> 00:04:19,130
have various regions and the connectivity between those regions varies.

68
00:04:19,210 --> 00:04:22,960
Or you need just to apply different patterns that we are going to discuss

69
00:04:25,110 --> 00:04:29,070
going from the regions. Every region consists

70
00:04:29,150 --> 00:04:33,022
of zones and zone is a separate physical

71
00:04:33,086 --> 00:04:36,518
location within a regions. So on this

72
00:04:36,604 --> 00:04:39,858
map we have proximity boundaries

73
00:04:39,954 --> 00:04:43,846
of the US west zones. We have three zones in

74
00:04:43,868 --> 00:04:47,422
this regions. And usually you have three or more zones

75
00:04:47,506 --> 00:04:52,042
for the high availability needs. If you, let's say deploy your

76
00:04:52,096 --> 00:04:56,490
application, your solution across

77
00:04:56,560 --> 00:05:00,346
three zones, like instance of the application such as NgINX web

78
00:05:00,368 --> 00:05:03,550
server is running zone one, zones two and zone three.

79
00:05:03,700 --> 00:05:06,778
Then you can withstand zone level outages.

80
00:05:06,874 --> 00:05:10,222
If this zone goes down, your application web server is still running

81
00:05:10,356 --> 00:05:13,970
because it's running in other zones. That's why we have zones.

82
00:05:14,310 --> 00:05:18,034
The latency between the zones is

83
00:05:18,072 --> 00:05:22,286
extremely low. All the resources within the zones are interconnected

84
00:05:22,318 --> 00:05:26,598
through a high performance network. If to refer to Google cloud platform

85
00:05:26,684 --> 00:05:30,406
again, and to talk about Google's infrastructure, then the

86
00:05:30,428 --> 00:05:34,594
round trip network latency is under 55 milliseconds

87
00:05:34,642 --> 00:05:38,266
on the 95th percentile. And that's extremely fast. It's just the

88
00:05:38,288 --> 00:05:40,570
round trip between the zones.

89
00:05:42,190 --> 00:05:46,102
And finally, we have regions. Every resources

90
00:05:46,166 --> 00:05:49,530
within a region are scattered across the zones.

91
00:05:49,890 --> 00:05:53,802
But also many cloud providers expand

92
00:05:53,866 --> 00:05:57,354
their infrastructure to densely populated metropolitan

93
00:05:57,402 --> 00:06:01,294
areas. And they have services or

94
00:06:01,332 --> 00:06:05,362
like products named as local zones or local edges or

95
00:06:05,416 --> 00:06:10,850
edge nodes. What's the purpose of those local

96
00:06:10,920 --> 00:06:14,580
zones? They are usually required for

97
00:06:15,050 --> 00:06:18,354
applications that are looking for single digit

98
00:06:18,402 --> 00:06:22,150
millisecond latency for their end users. The best example

99
00:06:22,220 --> 00:06:26,418
here is gaming applications or streaming applications.

100
00:06:26,514 --> 00:06:30,742
So if you have a lot of the users who live in Seattle,

101
00:06:30,886 --> 00:06:34,906
Atlanta, London or New York, you want

102
00:06:35,008 --> 00:06:38,490
them just to consume, to use your service

103
00:06:38,560 --> 00:06:41,886
the fastest way possible. And you want to store the data. You want

104
00:06:41,908 --> 00:06:46,046
to run instances of your microservices the closest way

105
00:06:46,068 --> 00:06:49,680
possible. That's what those local zones are designed for

106
00:06:50,530 --> 00:06:54,446
anyway. As you see, the global cloud infrastructure

107
00:06:54,558 --> 00:06:58,078
is really broad. And with that infrastructure,

108
00:06:58,254 --> 00:07:01,570
we as architects can design and build application.

109
00:07:01,720 --> 00:07:04,318
They have several characteristics.

110
00:07:04,414 --> 00:07:08,426
First, your global or geodistributed

111
00:07:08,478 --> 00:07:11,862
applications can provide similar performance and experience

112
00:07:11,996 --> 00:07:16,166
to your end users without, regardless of

113
00:07:16,188 --> 00:07:19,738
the user's whereabouts. So let's say that

114
00:07:19,904 --> 00:07:23,846
you have an application, and originally this application was launched

115
00:07:23,878 --> 00:07:27,926
in use by your customers from Europe. But right now it's

116
00:07:27,958 --> 00:07:31,902
gaining popularity in Asia and you want your users from

117
00:07:31,956 --> 00:07:35,834
Asia to have the same level of experience as your european

118
00:07:35,882 --> 00:07:39,982
users have. And with the global cloud infrastructure, it's extremely easy

119
00:07:40,036 --> 00:07:43,466
to do this if your application, your data layer,

120
00:07:43,578 --> 00:07:47,650
your application layer parents and also

121
00:07:47,720 --> 00:07:51,186
exists, has a representation in your

122
00:07:51,208 --> 00:07:54,610
asian data center. The second

123
00:07:54,680 --> 00:07:58,370
benefit of the global cloud infrastructure that we can take advantage of is

124
00:07:58,440 --> 00:08:01,670
you can comply with data residency requirements.

125
00:08:02,250 --> 00:08:05,842
Let's take another approach. Let's say that you launch an application primarily

126
00:08:05,906 --> 00:08:09,302
for APEC asian market,

127
00:08:09,436 --> 00:08:13,670
but right now you see that citizens from Europe

128
00:08:15,150 --> 00:08:18,806
kind of looking at it, you see a lot of the demand

129
00:08:18,838 --> 00:08:22,558
from Europe. And if you want to launch and expand this application

130
00:08:22,644 --> 00:08:25,806
to Europe, it's highly likely that you have to comply with the

131
00:08:25,828 --> 00:08:28,350
local requirements such as GDPR.

132
00:08:29,250 --> 00:08:32,702
And again, the cloud infrastructure allows us to do that. Right?

133
00:08:32,756 --> 00:08:36,354
You can have, let's say you can keep the data of your application

134
00:08:36,552 --> 00:08:40,878
in the european data centers and you can deploy instances of your microservices.

135
00:08:40,974 --> 00:08:45,258
The only topic that is left is how to architect such a geodistributed

136
00:08:45,294 --> 00:08:49,314
application. And finally, with this architecture you can tolerate

137
00:08:49,362 --> 00:08:53,014
cloud failures. For instance, what if,

138
00:08:53,052 --> 00:08:56,646
let's say you have us west and you

139
00:08:56,668 --> 00:09:00,070
have a region in US west and you have a region in US

140
00:09:00,140 --> 00:09:03,654
south? If the region in US west goes down, your traffic

141
00:09:03,702 --> 00:09:07,770
for north american users can redirect it to another region. It's possible

142
00:09:07,840 --> 00:09:11,454
to do. It's all about how to implement it, as can application and

143
00:09:11,492 --> 00:09:13,550
data layer. The infrastructure exists.

144
00:09:14,690 --> 00:09:18,398
Having said that, let's do a quick introduction to

145
00:09:18,404 --> 00:09:20,750
the geodistributed applications.

146
00:09:21,250 --> 00:09:25,406
A geodistributed application is the application that spans

147
00:09:25,518 --> 00:09:28,754
across multiple geographic applications. For what

148
00:09:28,792 --> 00:09:32,254
reasons? For high availability, compliance and performance

149
00:09:32,302 --> 00:09:36,546
needs. On this picture, we will start talking about our geodistributed

150
00:09:36,578 --> 00:09:40,742
corporate messenger. And this picture shows that our

151
00:09:40,876 --> 00:09:44,134
messenger instances and

152
00:09:44,332 --> 00:09:48,294
components of this solution run across the globe. We have North America,

153
00:09:48,342 --> 00:09:50,970
South America, Asia and other locations.

154
00:09:53,150 --> 00:09:56,890
But let's quickly step back and review

155
00:09:56,960 --> 00:10:00,198
what are the downsides of standard applications,

156
00:10:00,294 --> 00:10:03,866
the applications that are usually deployed and run in

157
00:10:03,888 --> 00:10:07,070
a single vulnerability zone of your cloud environment.

158
00:10:08,050 --> 00:10:12,030
On this picture we have the same corporate messenger,

159
00:10:12,450 --> 00:10:15,666
but it's deployed in one of the regions and it's deployed in one of the

160
00:10:15,688 --> 00:10:19,246
availability zones. That's a default actually deployment

161
00:10:19,278 --> 00:10:23,234
mode and configuration for most of the applications. And what happens,

162
00:10:23,352 --> 00:10:26,710
what are the downsides? If the zone goes

163
00:10:26,780 --> 00:10:30,306
down, so does your application. Your application, your messenger becomes

164
00:10:30,338 --> 00:10:34,066
unavailable. Your users will be disappointed,

165
00:10:34,178 --> 00:10:36,920
at least disappointed. Some of them will never return.

166
00:10:38,110 --> 00:10:41,980
If the outage takes a lot of time to recover from

167
00:10:42,750 --> 00:10:46,266
other downsides that you can, or roadblocks that

168
00:10:46,288 --> 00:10:50,506
you can experience later. Let's say that initially this application

169
00:10:50,608 --> 00:10:53,838
messenger was designed for your north american market

170
00:10:54,004 --> 00:10:57,802
and their startup founders told you, hey, no worries,

171
00:10:57,866 --> 00:11:02,042
we're just going to build and break and disrupt. But let's do this incrementally.

172
00:11:02,186 --> 00:11:05,794
Let's kind of build this application and deploy it and test it with

173
00:11:05,832 --> 00:11:09,474
our north american users. But then what

174
00:11:09,512 --> 00:11:13,182
happens in, let's say, in half a year, the plans are changed and you suddenly

175
00:11:13,246 --> 00:11:16,918
have to expand this application to Europe. How are

176
00:11:16,924 --> 00:11:20,102
you going to comply with the local data

177
00:11:20,156 --> 00:11:23,814
residency requirements? How much effort and time should you put

178
00:11:23,852 --> 00:11:27,846
in redesigning your architecture? Okay, so that's the

179
00:11:27,868 --> 00:11:31,350
problem with single zone applications and data layers.

180
00:11:31,510 --> 00:11:34,858
And final one is user experience. Again, the same application.

181
00:11:35,024 --> 00:11:38,582
But then let's say in a year and a half you decided

182
00:11:38,646 --> 00:11:42,990
to expand to asian market, to Japan, to Singapore,

183
00:11:43,650 --> 00:11:47,534
to India. And you want those users from

184
00:11:47,572 --> 00:11:51,386
those locations to have the same level of experience, the same speed

185
00:11:51,418 --> 00:11:55,946
and the same scale. But if those users from Japan or India

186
00:11:56,058 --> 00:11:59,646
needs to send the applications need to send requests

187
00:11:59,678 --> 00:12:03,742
to your data center in Europe or in America,

188
00:12:03,806 --> 00:12:06,870
then the experience will not be the same, it will be poor.

189
00:12:08,010 --> 00:12:11,766
So that's what geodistributed applications are

190
00:12:11,788 --> 00:12:15,334
dealing with. And when it comes to geodistributed apps, there are

191
00:12:15,372 --> 00:12:18,666
two primary deployment modes, right?

192
00:12:18,768 --> 00:12:21,130
When we are talking about geodistributed apps,

193
00:12:22,030 --> 00:12:25,878
they have to be resilient and withstand various cloud outages.

194
00:12:25,974 --> 00:12:29,974
They have to be performant even if you deploy them across multiple

195
00:12:30,022 --> 00:12:33,850
zones or regions. And they have to comply with data residency requirements

196
00:12:33,930 --> 00:12:37,594
if necessary. So let's quickly review multi zones

197
00:12:37,722 --> 00:12:41,646
type of deployment because the multiregion one we will review in detail

198
00:12:41,748 --> 00:12:45,506
while designing the slack like corporate messenger. So on

199
00:12:45,528 --> 00:12:48,846
this picture, we have the same messenger application, but right now it's

200
00:12:48,878 --> 00:12:52,910
deployed within the same regions, but across multiple availability

201
00:12:52,990 --> 00:12:56,630
zones. You have, let's say instances and

202
00:12:56,780 --> 00:13:00,646
data layer in zone one, zone two and zone three. So what

203
00:13:00,668 --> 00:13:04,594
are the advantages and disadvantages? So from the resilience

204
00:13:04,642 --> 00:13:07,846
system point, such architecture is much better than a

205
00:13:07,868 --> 00:13:11,642
single zone deployment. Because if any of these zones goes down,

206
00:13:11,776 --> 00:13:14,890
the other zones alive and you are happy,

207
00:13:14,960 --> 00:13:18,934
right? And your customers and users are happy. So this configuration can withstand

208
00:13:18,982 --> 00:13:23,120
tolerate zones, level outages from the performance standpoint remember

209
00:13:24,690 --> 00:13:26,960
if to speak for the Google cloud platform,

210
00:13:29,250 --> 00:13:33,086
a round trip is under five milliseconds. So the

211
00:13:33,108 --> 00:13:36,546
communication, if you have the data layer here, the communication, you need

212
00:13:36,568 --> 00:13:39,794
to replicate changes. You need to keep copy for the same message across

213
00:13:39,912 --> 00:13:43,218
multiple zones. It's fast. It's like extremely fast

214
00:13:43,384 --> 00:13:47,350
from the data residency requirements. The thing is not the trivial. I mean,

215
00:13:47,500 --> 00:13:50,946
it depends on where your region is. If your region is in North

216
00:13:50,978 --> 00:13:55,266
America and then in half a year you need to expand

217
00:13:55,298 --> 00:13:58,538
your messenger to Europe, then it's going

218
00:13:58,544 --> 00:14:02,218
to be a little bit complicated because this solution is in

219
00:14:02,224 --> 00:14:06,202
North America. But you need to keep data of your

220
00:14:06,336 --> 00:14:10,346
european users in the european data centers. That's where the

221
00:14:10,368 --> 00:14:14,234
multi region deployments come into play. With multi region deployments,

222
00:14:14,282 --> 00:14:18,074
from the resilience system point, you can tolerate region level outages.

223
00:14:18,202 --> 00:14:21,678
If let's say your US west coast region is completely down,

224
00:14:21,844 --> 00:14:25,634
then your users can be directed and read and

225
00:14:25,672 --> 00:14:29,410
write messages to, let's say Midwest

226
00:14:29,750 --> 00:14:32,978
regions. From that performance point,

227
00:14:33,144 --> 00:14:36,434
as long as your deployment deployment spans

228
00:14:36,482 --> 00:14:39,030
multiple regions, on average,

229
00:14:39,770 --> 00:14:42,946
the performance will be lower if you compare to multizone

230
00:14:42,978 --> 00:14:46,994
deployments and latencies will be higher. But with multiregion deployments,

231
00:14:47,042 --> 00:14:50,954
there are multiple deployment options and we are going to review those a little

232
00:14:50,992 --> 00:14:54,140
bit later. Just fasten your seatbelts and wait.

233
00:14:55,150 --> 00:14:59,290
So it's not that standard.

234
00:14:59,440 --> 00:15:02,462
And from the data residency requirement, we are good.

235
00:15:02,516 --> 00:15:06,394
I mean, if you deploy across multiple regions, if one day you need to scale

236
00:15:06,442 --> 00:15:09,658
to Europe or to Asia,

237
00:15:09,834 --> 00:15:13,454
you can easily do that, right? So now let's

238
00:15:13,502 --> 00:15:18,546
architect that slack like corporate messenger to

239
00:15:18,568 --> 00:15:22,322
remind you most likely, I believe that most of you have heard about

240
00:15:22,376 --> 00:15:26,114
Slack or use this messenger daily. With that messenger,

241
00:15:26,242 --> 00:15:29,234
your company, your employer,

242
00:15:29,362 --> 00:15:32,514
creates a workspace, you create channels and you communicate

243
00:15:32,562 --> 00:15:36,326
and chat and talk with your colleagues. Also, like many

244
00:15:36,428 --> 00:15:39,994
communities, open source communities or other communities use

245
00:15:40,032 --> 00:15:43,500
slack for conversation between their members.

246
00:15:44,350 --> 00:15:47,766
And Slack, believe me or not, actually is A-J-O distributed

247
00:15:47,798 --> 00:15:51,062
application. So if you check this engineering

248
00:15:51,126 --> 00:15:55,050
block by the Slack team, you'll see how their story eventually

249
00:15:55,130 --> 00:15:59,178
they started, let's say standard application with MySqL,

250
00:15:59,194 --> 00:16:04,346
but then they scaled, they turned their architecture into a geodistributed

251
00:16:04,378 --> 00:16:07,698
one. In our case, we are not going to replicate like we are going to

252
00:16:07,704 --> 00:16:11,058
use other components. But at least let's review

253
00:16:11,224 --> 00:16:14,706
when we will be architecting our messenger. We are

254
00:16:14,728 --> 00:16:18,246
going to look at several microservices. So like our application,

255
00:16:18,348 --> 00:16:22,050
our messenger will be comprised of four microservices.

256
00:16:22,210 --> 00:16:25,462
The first one is the messaging one, the primary one.

257
00:16:25,596 --> 00:16:29,702
It allows our users to exchange messages in channels within workspaces.

258
00:16:29,766 --> 00:16:32,870
Across workspaces we have the profile

259
00:16:33,030 --> 00:16:36,298
that keeps your data, such as email,

260
00:16:36,464 --> 00:16:40,006
name, age, et cetera, whatever you think is reasonable to

261
00:16:40,048 --> 00:16:44,394
share. Also, we have two utility microservices

262
00:16:44,522 --> 00:16:48,986
reminders and the status one with the reminders microservice,

263
00:16:49,098 --> 00:16:52,862
you can ask the messenger to remind about any

264
00:16:52,916 --> 00:16:56,478
discussion a little bit later. For instance, right now you're extremely busy,

265
00:16:56,574 --> 00:17:00,270
you're doing something and you want to return to this conversation,

266
00:17:00,350 --> 00:17:04,574
let's say next week. And you can use a special service, you can use reminders

267
00:17:04,622 --> 00:17:07,662
for that. With the status microservice,

268
00:17:07,806 --> 00:17:11,206
your colleagues can see what are you busy with, whether you are available or

269
00:17:11,228 --> 00:17:14,630
not. So generally, if you're on vacation, you can change the status to

270
00:17:14,700 --> 00:17:18,102
vacationing. If you are in a meeting, the status can be

271
00:17:18,156 --> 00:17:21,754
in the meeting. Simple. And when it comes to the

272
00:17:21,792 --> 00:17:25,706
architecture, we need to review and consider

273
00:17:25,808 --> 00:17:29,402
and talk about all the components. We are going to talk about the data

274
00:17:29,456 --> 00:17:32,986
layer that needs to deploy and span across multiple regions.

275
00:17:33,098 --> 00:17:37,434
It needs to be highly available, comply with local data residency requirements,

276
00:17:37,562 --> 00:17:41,438
and remain high performance. Right then we will have the application

277
00:17:41,524 --> 00:17:45,406
there. These four microservices need to deploy their instances

278
00:17:45,438 --> 00:17:49,554
across the globe so that the requests from users from

279
00:17:49,592 --> 00:17:53,090
Europe, Asia and America are processed the fastest way possible.

280
00:17:53,240 --> 00:17:57,240
And finally, the cloud cloud balancer. That's a special service

281
00:17:57,930 --> 00:18:01,910
that is provided by major cloud vendors

282
00:18:02,970 --> 00:18:06,498
that captures traffic from your users and redirects

283
00:18:06,514 --> 00:18:10,354
the traffic in those queries to their microservice instances

284
00:18:10,402 --> 00:18:13,766
into the database instances closest to the user's

285
00:18:13,798 --> 00:18:17,306
location. Okay, let's move forward. Let's talk about

286
00:18:17,328 --> 00:18:20,486
the data layer. In our case, for the data layer,

287
00:18:20,518 --> 00:18:24,234
we are going to use Yugabyte DB, which is a distributed

288
00:18:24,282 --> 00:18:28,554
postgres compliance SQL database. Our messaging,

289
00:18:28,682 --> 00:18:32,858
our corporate messenger is a transactional application.

290
00:18:33,044 --> 00:18:37,134
We cannot afford losing any message. We cannot allow ourselves

291
00:18:37,262 --> 00:18:40,750
to any inconsistencies. But we have to be global.

292
00:18:40,910 --> 00:18:44,954
That's why we selected Yugabyte. Yugabyte consists

293
00:18:45,022 --> 00:18:48,422
of two primary components. The first

294
00:18:48,476 --> 00:18:51,906
one is the pluggable query layer, and presently

295
00:18:51,938 --> 00:18:55,350
the query layer supports SQL.

296
00:18:55,690 --> 00:18:59,674
Yugabyte picks the postgres dialect of SQL, and also

297
00:18:59,712 --> 00:19:03,814
those of you who use Cassandra. You can find Cassandra

298
00:19:03,862 --> 00:19:07,270
APIs handy. Under the pluggable query layer,

299
00:19:07,350 --> 00:19:10,586
we have the storage layer. That's the layer that

300
00:19:10,608 --> 00:19:13,280
is different from what vanilla postgres has.

301
00:19:13,890 --> 00:19:17,326
That's where your data is located. Your data will be sharded and

302
00:19:17,348 --> 00:19:21,242
partitioned automatically for you across your zones and regions.

303
00:19:21,386 --> 00:19:25,266
Your requests will be load balanced and also all

304
00:19:25,288 --> 00:19:28,466
the changes all the messages that you're going to send to

305
00:19:28,488 --> 00:19:31,870
your microservices will be transactional

306
00:19:32,030 --> 00:19:35,814
regardless of how far the nodes of your database are

307
00:19:35,852 --> 00:19:38,966
located. Speaking about the

308
00:19:38,988 --> 00:19:43,558
compatibility level of how

309
00:19:43,724 --> 00:19:47,474
what it is. So generally speaking, Yugabyte DB

310
00:19:47,522 --> 00:19:51,154
reuses postgres source code Yugabyte

311
00:19:51,202 --> 00:19:55,654
query layer uses the writer, planner executed

312
00:19:55,702 --> 00:19:58,010
and optimizer of postgres.

313
00:19:58,590 --> 00:20:02,494
It's basically the same postgres, but with several components that

314
00:20:02,532 --> 00:20:06,522
are enhanced so that they can interact

315
00:20:06,666 --> 00:20:10,266
and take advantage of their underlying distributed

316
00:20:10,298 --> 00:20:14,014
storage layer. So for instance, we enhance the planner,

317
00:20:14,062 --> 00:20:17,262
executor and optimizer so that whenever

318
00:20:17,326 --> 00:20:21,118
you execute your SQL queries across a Yugabyte DB cluster,

319
00:20:21,214 --> 00:20:25,002
the planner and optimizer can come up with the best execution

320
00:20:25,086 --> 00:20:28,534
plan and the executor can send this execution plan

321
00:20:28,572 --> 00:20:32,150
to your distributed cluster properly. Okay,

322
00:20:32,220 --> 00:20:37,590
so to repeat, our geodistributed messenger

323
00:20:37,950 --> 00:20:40,810
will spread across multiple regions.

324
00:20:41,230 --> 00:20:45,530
And this time let's talk about the messaging and profile microservices.

325
00:20:46,110 --> 00:20:49,260
Those are the key microservices of our application.

326
00:20:50,210 --> 00:20:53,680
They are mission critical for the success of our application.

327
00:20:54,210 --> 00:20:58,286
They will be experiencing thousands of requests per second.

328
00:20:58,468 --> 00:21:02,222
They have to remain highly available events if regions go

329
00:21:02,276 --> 00:21:05,554
down. Because if your microservice is not

330
00:21:05,592 --> 00:21:09,374
available, if your messaging service is not available, then the impact

331
00:21:09,422 --> 00:21:12,754
and reputation and business of our company will be

332
00:21:12,872 --> 00:21:16,438
in danger. Also, when it comes to

333
00:21:16,444 --> 00:21:19,926
the data residency requirements, the messages and

334
00:21:19,948 --> 00:21:23,942
profile data of our users have to reside in

335
00:21:23,996 --> 00:21:28,086
their locations of

336
00:21:28,108 --> 00:21:31,770
the locations where they live. If for instance, we have

337
00:21:31,920 --> 00:21:35,382
users from european region, we have to comply with the JDPR

338
00:21:35,446 --> 00:21:38,826
requirements and the data of those folks have to be

339
00:21:38,848 --> 00:21:42,506
located in european cloud regions.

340
00:21:42,698 --> 00:21:45,914
So what happens? What do we do? From the architectural standpoint,

341
00:21:45,962 --> 00:21:49,694
those are requirements. We are going to deploy a single cluster of

342
00:21:49,732 --> 00:21:53,410
yugabyte that spans multiple continents.

343
00:21:53,750 --> 00:21:56,130
But there is one important note.

344
00:21:56,710 --> 00:22:00,206
In this cluster, there will be a group of nodes

345
00:22:00,318 --> 00:22:03,570
that keep data from specific geographic applications.

346
00:22:03,910 --> 00:22:07,494
So a group of nodes from Europe will

347
00:22:07,532 --> 00:22:11,350
keep messages and profiles for the european citizens.

348
00:22:11,770 --> 00:22:16,018
And there will be a group of zones who keep data and messages

349
00:22:16,114 --> 00:22:19,500
for the asian customers.

350
00:22:20,910 --> 00:22:23,180
Which means that whenever you have,

351
00:22:24,190 --> 00:22:27,546
everything will be distributed and executed for

352
00:22:27,568 --> 00:22:31,070
us transparently. We just need to deploy this geodistributed cluster.

353
00:22:31,410 --> 00:22:34,494
The data will be partitioned based on the value of the

354
00:22:34,532 --> 00:22:38,414
country column. If the country column is

355
00:22:38,532 --> 00:22:41,162
set to UK, France,

356
00:22:41,306 --> 00:22:45,134
Italy or Germany, then these messages will reside

357
00:22:45,182 --> 00:22:49,006
and will be kept in our european

358
00:22:49,038 --> 00:22:52,974
nodes. And that's done for you. We just need to configure

359
00:22:53,022 --> 00:22:56,482
this database. We need to create these tables and we need to specify

360
00:22:56,546 --> 00:22:59,938
and say that the country is our partitioning column.

361
00:23:00,114 --> 00:23:03,670
When it comes to the performance, when it comes to the latency,

362
00:23:04,250 --> 00:23:08,006
it's obvious that if you have users from

363
00:23:08,108 --> 00:23:11,546
Europe and all those users work from company that is based in

364
00:23:11,568 --> 00:23:16,102
Europe, all the messages and all the data will be here locally.

365
00:23:16,246 --> 00:23:19,894
So that whenever you insert messages, whenever you share messages,

366
00:23:19,942 --> 00:23:23,630
or do like perform any other tasks, the performance will be high.

367
00:23:23,700 --> 00:23:28,394
The latency will be low because the users from Europe will be interacting

368
00:23:28,442 --> 00:23:31,966
and reading and writing data to the european nodes of

369
00:23:31,988 --> 00:23:35,254
Yugabyte. And the same is true for North America.

370
00:23:35,402 --> 00:23:39,266
Colleagues, let's say that you have people in North America. You need to send

371
00:23:39,368 --> 00:23:42,546
messages. You need to send and read and write

372
00:23:42,648 --> 00:23:46,006
channels from your database. You will be communicating to your

373
00:23:46,028 --> 00:23:49,430
north american group of nodes. Excellent.

374
00:23:50,250 --> 00:23:53,190
Another type of multi regions database deployment.

375
00:23:54,090 --> 00:23:58,298
It is when we deploy a primary cluster in one

376
00:23:58,384 --> 00:24:02,406
geographic location and in other distant geographic locations,

377
00:24:02,598 --> 00:24:06,266
we configure read replicas. We are going

378
00:24:06,288 --> 00:24:10,954
to use this deployment mode of Yugabyte for the reminders

379
00:24:11,082 --> 00:24:14,554
microservice. Again with the reminders

380
00:24:14,602 --> 00:24:18,142
microservice, we can ask the messenger to remind us

381
00:24:18,196 --> 00:24:21,406
about any specific conversation in an

382
00:24:21,428 --> 00:24:24,740
hour, next day, or any week.

383
00:24:26,390 --> 00:24:30,100
And generally what happens here.

384
00:24:30,790 --> 00:24:34,690
All the reminders, whenever someone will be creating a reminder,

385
00:24:35,210 --> 00:24:38,754
this write operation will be handled in the primary

386
00:24:38,802 --> 00:24:42,950
cluster. So if you have, let's say, a user who lives

387
00:24:43,020 --> 00:24:46,262
in South Korea and this

388
00:24:46,316 --> 00:24:49,786
guy schedules a reminder, this reminder will

389
00:24:49,808 --> 00:24:53,526
be written automatically forwarded from the read replica

390
00:24:53,638 --> 00:24:57,414
in this location to the primary cluster in North America.

391
00:24:57,542 --> 00:25:01,262
But whenever you are going to read any data from this local

392
00:25:01,316 --> 00:25:05,182
read replicas, such as in Europe and Asia, the data

393
00:25:05,236 --> 00:25:09,520
will be retrieved extremely fast using the local data,

394
00:25:09,970 --> 00:25:13,546
and this data will be synchronously replicated from the primary cluster

395
00:25:13,578 --> 00:25:16,866
to the read replicas. For instance, we are

396
00:25:16,888 --> 00:25:20,398
expecting batch reads. It's when in every location,

397
00:25:20,574 --> 00:25:24,386
close to every read replica, we will have a special walker that's a

398
00:25:24,408 --> 00:25:27,826
process that wakes up every minute, connects to

399
00:25:27,848 --> 00:25:31,302
the database, and pulls all the reminders that have

400
00:25:31,436 --> 00:25:34,646
just expired. And it will be doing this only for

401
00:25:34,668 --> 00:25:38,154
the local data. So in Asia, we will have a special worker that will connect

402
00:25:38,192 --> 00:25:41,798
to the replica, read all this data in bulk,

403
00:25:41,894 --> 00:25:45,702
and then we'll notify those users whose reminders

404
00:25:45,846 --> 00:25:49,514
have just expired within the last minute. So that's how

405
00:25:49,552 --> 00:25:53,406
you can minimize network traffic from the primary cluster to

406
00:25:53,428 --> 00:25:57,280
the distant locations if you need to read a lot of the data.

407
00:25:58,370 --> 00:26:01,866
And another, the third final multiregion deployment mode

408
00:26:01,898 --> 00:26:05,726
for our data layer for our database is when we are deploying

409
00:26:05,838 --> 00:26:09,806
multiple standalone databases in every distant location,

410
00:26:09,998 --> 00:26:13,822
and if necessary, we can synchronize

411
00:26:13,886 --> 00:26:17,910
those databases using can asynchronous protocol.

412
00:26:19,530 --> 00:26:23,314
In our case, with our messenger, we are going to use this deployment

413
00:26:23,362 --> 00:26:26,978
mode for the data layer when it comes to the status microservice.

414
00:26:27,074 --> 00:26:30,278
Again, if you're on vacation, you want your colleagues to know about that.

415
00:26:30,364 --> 00:26:33,766
If you are in a meeting also, you want to change your status respectively.

416
00:26:33,798 --> 00:26:37,226
Or if you are active and ready to chat, your status also will

417
00:26:37,248 --> 00:26:40,042
be set to active. And in this case,

418
00:26:40,176 --> 00:26:43,422
we decided, all right, we do expect that

419
00:26:43,476 --> 00:26:46,334
we still have high availability, right?

420
00:26:46,452 --> 00:26:50,346
But we're not expecting that the status will be changed, let's say thousands

421
00:26:50,378 --> 00:26:53,694
of times a second. It will happen, but it will happen. Not that

422
00:26:53,732 --> 00:26:57,486
requests. At the same time, when my colleague connects to

423
00:26:57,508 --> 00:27:00,734
the opens my messenger, he wants to see statuses

424
00:27:00,782 --> 00:27:03,618
of all the colleagues. So, like, I want to have fast reads, but when it

425
00:27:03,624 --> 00:27:06,760
comes to writes, I don't care. And also,

426
00:27:08,010 --> 00:27:11,606
asynchronous replication is suitable here. For instance, let's say

427
00:27:11,628 --> 00:27:16,134
that someone who lives in Europe went

428
00:27:16,172 --> 00:27:19,502
to a meeting and his status is changed accordingly.

429
00:27:19,666 --> 00:27:23,254
This information will be written to the European data Center, because that's

430
00:27:23,302 --> 00:27:26,618
where this user resides. But then this information,

431
00:27:26,704 --> 00:27:31,390
if necessary, can be replicated to North America and to APAC.

432
00:27:32,690 --> 00:27:36,394
The replication can take, let's say like few seconds,

433
00:27:36,442 --> 00:27:40,160
like 510, and depends on how fast the connectivity between

434
00:27:41,730 --> 00:27:45,442
these users. But generally it's not a big deal.

435
00:27:45,496 --> 00:27:49,582
Let's say if a teammate of this guy who lives in North America

436
00:27:49,646 --> 00:27:52,914
will see his colleague from Europe start

437
00:27:52,952 --> 00:27:56,418
to channels in five or 10 seconds, right? It's not a big deal. So that's

438
00:27:56,434 --> 00:28:00,230
why it's totally fine to use the asynchronous applications between

439
00:28:00,300 --> 00:28:03,526
these distant clusters. That's why we selected this for

440
00:28:03,548 --> 00:28:07,206
the status microservice. Okay, to conclude, that's it

441
00:28:07,228 --> 00:28:10,700
for the data layer component of our geodistributed application

442
00:28:11,150 --> 00:28:14,346
for this. As I said, when it come, there are two

443
00:28:14,368 --> 00:28:18,054
primary deployment modes. You have a multizone deployment

444
00:28:18,102 --> 00:28:20,330
for your data layer, or you have multiregion.

445
00:28:21,150 --> 00:28:24,558
Multizone is easy, but with multiregion, we also have three options.

446
00:28:24,644 --> 00:28:28,302
We can deploy a single geodistributed cluster, and every data

447
00:28:28,356 --> 00:28:32,046
will be pinned automatically based on the value of your

448
00:28:32,068 --> 00:28:35,966
partitioning column, such as the country one. We use it for our mission

449
00:28:35,998 --> 00:28:39,986
critical microservices, messaging and the profile one.

450
00:28:40,168 --> 00:28:44,258
Also, the other deployment mode for the multiregion databases is

451
00:28:44,424 --> 00:28:47,662
the primary cluster with read replicas in distant location.

452
00:28:47,806 --> 00:28:51,446
We use that for the reminders. Keep this in your toolbox as well.

453
00:28:51,548 --> 00:28:54,550
And the final one when you don't actually care about,

454
00:28:54,620 --> 00:28:57,618
let's say, if you allow, let's say, distant locations,

455
00:28:57,714 --> 00:29:01,386
read stale data that will be synchronized later. Then you

456
00:29:01,408 --> 00:29:04,742
can use multiple standalone clusters

457
00:29:04,806 --> 00:29:08,486
in every location and then set up bi directional or unidirectional

458
00:29:08,518 --> 00:29:12,330
replication between them. It's enough for the data layer.

459
00:29:12,410 --> 00:29:15,966
Let's talk about the application layer when it comes to the application.

460
00:29:16,068 --> 00:29:19,290
Again, we have four microservices, messaging, profile,

461
00:29:19,450 --> 00:29:22,618
reminders and status, and we have customers across the

462
00:29:22,644 --> 00:29:25,874
globe. We are going to deploy an instance of every

463
00:29:25,912 --> 00:29:29,362
microservice in every location in

464
00:29:29,416 --> 00:29:32,370
North America, Europe and Asia.

465
00:29:33,430 --> 00:29:36,902
Also, we are going to allocate those

466
00:29:36,956 --> 00:29:40,386
instances with the local yugabyte

467
00:29:40,418 --> 00:29:45,874
nodes. For instance, if my Yugabyte

468
00:29:45,922 --> 00:29:49,922
DB zones are deployed in the London data center cloud

469
00:29:49,996 --> 00:29:53,574
region, then I want the instance of the microservice

470
00:29:53,622 --> 00:29:56,966
for the messaging and for the reminders to be located in the same region.

471
00:29:57,078 --> 00:30:01,642
Why? So that the latency, the performance remember if,

472
00:30:01,696 --> 00:30:04,526
even if to take Google compute platform as an example,

473
00:30:04,708 --> 00:30:08,174
the latency between the availability zones within the same

474
00:30:08,212 --> 00:30:12,358
regions is under five milliseconds, which is excellent. So like whenever

475
00:30:12,474 --> 00:30:16,462
our messaging microservice instance receives a request

476
00:30:16,526 --> 00:30:19,954
to write or read the message from

477
00:30:19,992 --> 00:30:24,130
a european customer, it will get it and it will instantaneously

478
00:30:24,810 --> 00:30:27,954
request or write data to or from the database

479
00:30:28,082 --> 00:30:29,750
fast, right? It's calculated.

480
00:30:31,610 --> 00:30:35,046
So here is what technology to use. How exactly do

481
00:30:35,068 --> 00:30:38,194
you deploy your microservice instances?

482
00:30:38,242 --> 00:30:41,722
It's up to you. You can use, let's say app engine

483
00:30:41,776 --> 00:30:45,098
of Google Cloud platform or a similar service

484
00:30:45,264 --> 00:30:48,922
in AWS or Microsoft Azure. Or you can deploy everything

485
00:30:48,976 --> 00:30:52,902
in Kubernetes. It's highly likely that Kubernetes like containers

486
00:30:52,966 --> 00:30:56,462
and Kubernetes as an orchestration layer are the best option

487
00:30:56,516 --> 00:31:00,366
here. But anyway, we will leave this question and

488
00:31:00,388 --> 00:31:03,474
answer it's up to you, literally whatever is more

489
00:31:03,512 --> 00:31:07,134
preferable for your architecture. It's just that you need to deploy

490
00:31:07,182 --> 00:31:09,730
those instances across various locations.

491
00:31:10,070 --> 00:31:13,570
Same for the communication and the connectivity

492
00:31:14,550 --> 00:31:18,398
layers and patterns between your different microservices.

493
00:31:18,574 --> 00:31:22,850
It's true that the messaging microservice needs to read profiles

494
00:31:22,930 --> 00:31:26,290
from the profile microservices. The reminders microservices

495
00:31:26,450 --> 00:31:30,250
need to kind of pin the reminders to a specific message

496
00:31:30,320 --> 00:31:33,674
and it will communicate the message in microservices. So here

497
00:31:33,712 --> 00:31:36,890
is again, I'll give you flexibility.

498
00:31:37,470 --> 00:31:40,574
Use a communication pattern that works best for

499
00:31:40,612 --> 00:31:44,826
your deployment. You can use message brokers to communicate between microservices.

500
00:31:44,938 --> 00:31:48,366
GrPC like sidecar or whatever is

501
00:31:48,388 --> 00:31:51,594
more applicable. Okay, data layer,

502
00:31:51,642 --> 00:31:55,374
application layer, and finally we have the cloud cloud

503
00:31:55,422 --> 00:31:58,542
balancer because right now we have a global architecture,

504
00:31:58,686 --> 00:32:03,006
we have database zones, we have microservice instances

505
00:32:03,198 --> 00:32:07,278
across various continents, but we want this

506
00:32:07,384 --> 00:32:10,614
back end and data layer to be as simple as

507
00:32:10,652 --> 00:32:14,018
possible for our front end, for our end users.

508
00:32:14,194 --> 00:32:17,894
That's why my suggestion would be to have a look and benefit

509
00:32:17,942 --> 00:32:20,970
from the global cloud load balancers.

510
00:32:21,310 --> 00:32:24,540
It's usually like every major cloud provider has them.

511
00:32:25,630 --> 00:32:29,610
So what's the purpose of their global load balancers?

512
00:32:30,370 --> 00:32:34,234
Load balancer provides you with any cast

513
00:32:34,282 --> 00:32:38,174
IP address, that's a single external IP address that

514
00:32:38,212 --> 00:32:42,374
can be used by your front end applications and your mobile applications,

515
00:32:42,522 --> 00:32:44,866
and when someone, let's say,

516
00:32:45,048 --> 00:32:48,626
connects to your front end. Depending on

517
00:32:48,648 --> 00:32:52,386
the location of this user, the global cloud balancer will

518
00:32:52,408 --> 00:32:55,858
send this request to the closest microservices and to

519
00:32:55,864 --> 00:32:59,030
the closest database nodes that are located

520
00:32:59,450 --> 00:33:03,046
close to this user. Let's take an example. Let's say

521
00:33:03,068 --> 00:33:07,186
that we have a user who is based off Europe and this user opens

522
00:33:07,218 --> 00:33:10,774
up your messaging application on iPhone,

523
00:33:10,902 --> 00:33:14,186
iPhone, uses this anycast ip address and

524
00:33:14,208 --> 00:33:18,070
connects to the global load balancer. The user refreshes

525
00:33:18,230 --> 00:33:21,998
a discussion in one of the channels and you want to read all the

526
00:33:22,004 --> 00:33:25,786
messages from this channel. So the global load balancer received

527
00:33:25,818 --> 00:33:29,710
this request. It sees that, okay, the request comes from a person

528
00:33:29,780 --> 00:33:32,898
in Europe. So then we have an instance of

529
00:33:32,904 --> 00:33:35,922
our microservice in Europe. Let's forward this request there.

530
00:33:36,056 --> 00:33:39,780
This microservice instance received this request and

531
00:33:41,350 --> 00:33:45,214
it's already connected to our geodistributed database and it will send

532
00:33:45,352 --> 00:33:48,178
this request to our local database nodes.

533
00:33:48,274 --> 00:33:51,826
Easy right? So that's how you can take advantage of the global

534
00:33:51,858 --> 00:33:55,186
cloud load balancers. Also, this load balancer

535
00:33:55,218 --> 00:33:58,834
is fault tolerant. Basically it supports automatic

536
00:33:58,882 --> 00:34:01,514
failover in case of outages. If, let's say,

537
00:34:01,552 --> 00:34:04,906
your data center or instance of your

538
00:34:04,928 --> 00:34:09,062
microservice is down here due to different zone or region level outages,

539
00:34:09,206 --> 00:34:12,606
the global cloud balancer can redirect the user's traffic to the

540
00:34:12,628 --> 00:34:16,446
other nearby location to the other nearby instance. It's all

541
00:34:16,548 --> 00:34:20,030
done for you. Wonderful. So as a summary,

542
00:34:20,530 --> 00:34:24,670
geodistributed applications are becoming a new norma, new normal

543
00:34:25,330 --> 00:34:27,890
when we are building cloud native applications,

544
00:34:28,310 --> 00:34:32,014
because usually the user base for our applications is global.

545
00:34:32,142 --> 00:34:35,874
Even if you're planning that your application is going to be

546
00:34:35,912 --> 00:34:39,170
used primarily in North America or in Asia,

547
00:34:39,330 --> 00:34:42,386
it's highly likely that on some day, if you become successful,

548
00:34:42,418 --> 00:34:46,146
then you will become the victim of your own success. You will get a global

549
00:34:46,178 --> 00:34:49,434
user base. And it matters a lot what was

550
00:34:49,472 --> 00:34:52,842
the foundation of your architecture, even if the first

551
00:34:52,896 --> 00:34:56,890
version of your application was deploying your messenger application

552
00:34:57,040 --> 00:35:01,050
and your database within a single region across multiple zones.

553
00:35:01,630 --> 00:35:05,086
But if it can scale to other regions and

554
00:35:05,108 --> 00:35:08,638
to other locations easily, then you are in a win win situation.

555
00:35:08,724 --> 00:35:11,838
So right now you're using the resources that you need. But let's say in a

556
00:35:11,844 --> 00:35:15,762
month or like in a week, you need to expand to Europe. You just spans

557
00:35:15,816 --> 00:35:19,314
your database across, let's say North America, in Europe, or use

558
00:35:19,432 --> 00:35:23,214
let's say any other multi region deployment mode that we discussed.

559
00:35:23,342 --> 00:35:26,850
So that's why think globally when you're building

560
00:35:26,920 --> 00:35:30,646
new cloud native applications and have a look and consider

561
00:35:30,828 --> 00:35:35,202
the different design and consideration

562
00:35:35,266 --> 00:35:39,254
patterns when you're building geodistributed applications.

563
00:35:39,382 --> 00:35:42,954
If you want to learn more, my advice would be to check these two

564
00:35:42,992 --> 00:35:46,662
books by Orali architecting for scale in designing data intensive

565
00:35:46,726 --> 00:35:50,286
applications. They give us more

566
00:35:50,308 --> 00:35:53,806
details on how to design highly available

567
00:35:53,988 --> 00:35:57,774
and high performance distributed applications, and that

568
00:35:57,892 --> 00:36:01,834
resonates really well with the topic of today with the geodistributed

569
00:36:01,882 --> 00:36:05,620
apps. Also, if you are curious about the

570
00:36:06,790 --> 00:36:10,482
data layer component, about the yugabyte, how it works,

571
00:36:10,536 --> 00:36:14,206
how to deploy it, and how those multi region deployment

572
00:36:14,318 --> 00:36:17,346
mode works, just my suggestion would

573
00:36:17,368 --> 00:36:21,126
be go and complete one of our free courses. That's the easiest way

574
00:36:21,148 --> 00:36:24,374
to get to know our database data and this

575
00:36:24,412 --> 00:36:28,214
corporate messenger flag. Like corporate messenger, we have a gitpod sandbox

576
00:36:28,262 --> 00:36:31,898
environment. Go to this GitHub project

577
00:36:31,984 --> 00:36:35,510
and you can run this in your Gitpad

578
00:36:35,590 --> 00:36:39,466
workspace. So right now we support as of

579
00:36:39,488 --> 00:36:43,374
time of this recording, you would be able to start to

580
00:36:43,412 --> 00:36:46,846
deploy your various you would be able to

581
00:36:46,868 --> 00:36:51,066
deploy Yugo by DB in various configuration modes for multiregion

582
00:36:51,098 --> 00:36:54,766
deployment like geode distributed primary cluster with red

583
00:36:54,788 --> 00:36:59,054
replica, et cetera. And then over the time we are planning to improve this

584
00:36:59,172 --> 00:37:02,634
sandbox, we are going to add the front end and the back end, et cetera.

585
00:37:02,682 --> 00:37:06,646
So you can subscribe and watch to the changes. If you

586
00:37:06,668 --> 00:37:10,246
have any other questions, you can always find tag me and send me

587
00:37:10,268 --> 00:37:13,574
a message on Twitter. Or if you are particularly interested in

588
00:37:13,612 --> 00:37:17,686
Yugabyte DB then join our communication like community. And the

589
00:37:17,708 --> 00:37:21,286
easiest way to experiment with Yugabyte is by using our cloud

590
00:37:21,388 --> 00:37:24,582
product. Thanks for joining, thanks for watching and

591
00:37:24,636 --> 00:37:26,370
enjoy the rest of the conference.

