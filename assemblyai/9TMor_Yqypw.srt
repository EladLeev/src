1
00:00:17,290 --> 00:00:21,086
Okay, let's begin. First we are

2
00:00:21,108 --> 00:00:24,910
going to talk about the Darwin kernel.

3
00:00:25,530 --> 00:00:29,906
Darwin kernel is the kernel of all Apple

4
00:00:30,018 --> 00:00:34,102
operating systems. Was created in 2000

5
00:00:34,236 --> 00:00:37,438
by Apple based on BSD

6
00:00:37,554 --> 00:00:41,290
and match with parts from OpenStep.

7
00:00:41,630 --> 00:00:45,814
You know that OpenStep was an open API created

8
00:00:45,862 --> 00:00:49,514
by Next and San microsystems based

9
00:00:49,632 --> 00:00:53,694
on the work that SteveJots made in next

10
00:00:53,812 --> 00:00:58,558
computer. Because next computer is

11
00:00:58,644 --> 00:01:02,000
not solvent in financial way,

12
00:01:02,710 --> 00:01:07,362
Steve Jobs thinks about to make an

13
00:01:07,416 --> 00:01:10,978
open API with open step with

14
00:01:11,144 --> 00:01:14,562
the possibility to work in Windows or

15
00:01:14,616 --> 00:01:18,214
even in Apple machines. And in

16
00:01:18,252 --> 00:01:22,166
this project, the result from this was

17
00:01:22,268 --> 00:01:26,002
open step. And this is the core of the iOS

18
00:01:26,066 --> 00:01:30,154
ten operating system. It supports all

19
00:01:30,272 --> 00:01:33,638
Apple OS, macOS, iOS,

20
00:01:33,734 --> 00:01:37,702
watchos and tvos. And maybe the next reality,

21
00:01:37,766 --> 00:01:41,806
iOS. It's an open source project and it

22
00:01:41,828 --> 00:01:45,630
iOS a kernel that supports the Appkit or

23
00:01:45,700 --> 00:01:49,342
Uikit development APIs. You know that

24
00:01:49,396 --> 00:01:54,534
Appkit is from macOS and Uikit

25
00:01:54,682 --> 00:01:58,558
is from iOS and the other mobile

26
00:01:58,654 --> 00:02:02,338
development, mobile systems like TBOS or

27
00:02:02,424 --> 00:02:05,762
watchOS, including the macOS interface.

28
00:02:05,906 --> 00:02:09,446
Aqua that. It's the interface, the API for

29
00:02:09,468 --> 00:02:12,950
the interface. IOS built in C and

30
00:02:13,020 --> 00:02:16,514
C. Okay? It's the kernel,

31
00:02:16,642 --> 00:02:20,890
it's the core of the operating system,

32
00:02:21,040 --> 00:02:24,314
and it's the same core for all the

33
00:02:24,352 --> 00:02:27,510
operating systems from Apple.

34
00:02:27,670 --> 00:02:31,822
We are going more deeper and for

35
00:02:31,956 --> 00:02:35,722
understand all the things about the security of the iPhone,

36
00:02:35,866 --> 00:02:39,866
we are going to talk in a brief,

37
00:02:39,978 --> 00:02:43,294
secure history of the first iPhone.

38
00:02:43,422 --> 00:02:47,780
Because I think it's very important to

39
00:02:48,230 --> 00:02:51,794
know the past, to understand the

40
00:02:51,832 --> 00:02:55,878
present and the future. And we are going to make this

41
00:02:55,964 --> 00:02:59,494
brief security, this brief, secure history of

42
00:02:59,532 --> 00:03:03,334
the iPhone. Okay? Today, there is no

43
00:03:03,372 --> 00:03:06,390
doubt that January 9,

44
00:03:06,540 --> 00:03:10,394
2007, the wall changed with

45
00:03:10,432 --> 00:03:13,366
the introduction of the first iPhone.

46
00:03:13,558 --> 00:03:16,506
Okay. But the first iPhone model,

47
00:03:16,608 --> 00:03:20,060
however, was far from the current ones.

48
00:03:20,370 --> 00:03:24,414
In fact, it was way less secure than

49
00:03:24,452 --> 00:03:27,962
the actual iPhones. For example, the iPhone

50
00:03:28,026 --> 00:03:31,722
edge was a full feature smartphone,

51
00:03:31,786 --> 00:03:35,730
but it had no apps. It's a closer device.

52
00:03:36,470 --> 00:03:39,794
When asked for apps, Apple's answer

53
00:03:39,912 --> 00:03:43,122
was web app, not third

54
00:03:43,176 --> 00:03:46,790
party apps that runs naturally in the

55
00:03:46,940 --> 00:03:49,858
device. Apple defended to the hilt.

56
00:03:49,954 --> 00:03:53,874
It was not necessary to have third party software

57
00:03:53,922 --> 00:03:57,802
on the iPhone. And these closed functions were

58
00:03:57,856 --> 00:04:01,466
enough. The first idea

59
00:04:01,568 --> 00:04:06,058
about the iPhone is to make a device similar

60
00:04:06,144 --> 00:04:09,606
to an iPod with closed functions.

61
00:04:09,718 --> 00:04:12,414
Not the possibility to expand it,

62
00:04:12,612 --> 00:04:15,822
but with more functions, but all

63
00:04:15,876 --> 00:04:19,534
the functions that the

64
00:04:19,572 --> 00:04:23,600
mayor of the users needs to work needs

65
00:04:23,910 --> 00:04:27,694
for his device. But Apple and Steve

66
00:04:27,742 --> 00:04:31,422
Jobs was not sure about apps

67
00:04:31,486 --> 00:04:35,162
could bring something interesting to the users.

68
00:04:35,246 --> 00:04:39,030
And well, for now they

69
00:04:39,100 --> 00:04:42,882
speak about to use web apps.

70
00:04:43,026 --> 00:04:46,550
The iPhone was totally closed in system

71
00:04:46,700 --> 00:04:50,110
and kernel. It's like I said, a closed

72
00:04:50,130 --> 00:04:53,862
device. Otherwise, the initial

73
00:04:53,926 --> 00:04:57,930
scroll, the pinch, or the capacitive touch screen

74
00:04:58,080 --> 00:05:00,986
were some of its milestones.

75
00:05:01,178 --> 00:05:04,494
And let someone talk about this with

76
00:05:04,532 --> 00:05:08,174
software. Now, software on mobile phones is

77
00:05:08,212 --> 00:05:12,302
like baby software. It's not

78
00:05:12,356 --> 00:05:15,746
so powerful. And today we're going to show

79
00:05:15,768 --> 00:05:19,522
you a software breakthrough. Software that's at least five years

80
00:05:19,576 --> 00:05:22,514
ahead of what's on any other phone. Now,

81
00:05:22,552 --> 00:05:26,390
how do we do this? Well, we start with a strong foundation.

82
00:05:26,810 --> 00:05:29,160
IPhone runs OS ten.

83
00:05:31,850 --> 00:05:33,400
That's the key. Now,

84
00:05:35,770 --> 00:05:39,386
why would we want

85
00:05:39,408 --> 00:05:42,810
to run such a sophisticated operating system

86
00:05:42,960 --> 00:05:45,946
on a mobile device? Well, because it's got everything we need.

87
00:05:45,968 --> 00:05:50,454
Good question. It's got multitasking, it's got the best networking.

88
00:05:50,582 --> 00:05:54,346
It already knows how to power manage. We've been doing this on mobile computers

89
00:05:54,378 --> 00:05:57,694
for years. It's got awesome security and to write

90
00:05:57,732 --> 00:06:01,406
apps. It's got everything from Cocoa and

91
00:06:01,428 --> 00:06:05,146
the graphics, and it's got code animation built in, and it's

92
00:06:05,178 --> 00:06:08,354
got the audio and video that OS X is famous for.

93
00:06:08,392 --> 00:06:12,590
It's got all the stuff we want and it's built right into iPhone.

94
00:06:12,670 --> 00:06:17,026
And that has let us create desktop class applications

95
00:06:17,058 --> 00:06:21,174
and networking. That's the

96
00:06:21,292 --> 00:06:25,240
most important key about the iPhone because

97
00:06:26,330 --> 00:06:29,226
it runs os ten.

98
00:06:29,408 --> 00:06:33,580
And like Steve Job said, it's got awesome security.

99
00:06:33,950 --> 00:06:37,542
But the iPhone was software locked

100
00:06:37,686 --> 00:06:41,180
to what it has preinstalled, like I said before.

101
00:06:41,790 --> 00:06:45,350
And it used the Darwin kernel

102
00:06:45,430 --> 00:06:48,910
and the new Coco touch library on top of

103
00:06:48,980 --> 00:06:52,930
it. It's an extensive framework with

104
00:06:53,000 --> 00:06:56,878
Uikit and other framework, other APIs

105
00:06:57,054 --> 00:07:00,690
like your session or cocore animation,

106
00:07:01,670 --> 00:07:05,738
core audio and the other APIs that Stigob

107
00:07:05,774 --> 00:07:09,270
said in the keynote presentation.

108
00:07:10,650 --> 00:07:16,134
The kernel being based on BSD is

109
00:07:16,252 --> 00:07:19,786
the same kernel that we said before.

110
00:07:19,968 --> 00:07:24,154
The Darwin kernel that fits without any

111
00:07:24,192 --> 00:07:28,042
problem in its 128

112
00:07:28,176 --> 00:07:32,110
megabytes of rAM that the iPhone

113
00:07:32,530 --> 00:07:36,334
has. Okay, but you know

114
00:07:36,372 --> 00:07:40,254
that native apps were programmed in object

115
00:07:40,372 --> 00:07:44,222
C. And Apple, this is the most important thing about

116
00:07:44,276 --> 00:07:48,098
security. Implemented digital signatures for

117
00:07:48,184 --> 00:07:52,114
code execution. And this

118
00:07:52,152 --> 00:07:56,130
is the way that we guarantee

119
00:07:56,290 --> 00:07:59,110
the security of the device.

120
00:07:59,610 --> 00:08:02,930
And for make this to ensure

121
00:08:03,010 --> 00:08:06,470
this security, app used this on

122
00:08:06,620 --> 00:08:10,482
certificate authority to disallow the execution

123
00:08:10,546 --> 00:08:13,990
of code that was not signed of

124
00:08:14,060 --> 00:08:17,514
them on the system. Because of this,

125
00:08:17,632 --> 00:08:20,650
as you know, if you try to execute

126
00:08:20,730 --> 00:08:24,142
any software on the iPhone, even if

127
00:08:24,196 --> 00:08:28,094
you could compile a program for

128
00:08:28,132 --> 00:08:31,918
this, it's not execute because it's not

129
00:08:32,004 --> 00:08:36,306
signing by app. But do

130
00:08:36,328 --> 00:08:39,934
you know that Apple think about third party

131
00:08:39,982 --> 00:08:42,580
software from the beginning? Yes.

132
00:08:44,790 --> 00:08:48,322
Let's read this. We define

133
00:08:48,386 --> 00:08:52,054
everything that is on the phone. You don't want your

134
00:08:52,092 --> 00:08:55,254
phone to be like a pc. The last thing you want is

135
00:08:55,292 --> 00:08:59,274
to have loaded three app on your phone and then you

136
00:08:59,312 --> 00:09:02,890
go to make a call and it doesn't work anymore.

137
00:09:03,310 --> 00:09:07,114
These are more like ipods than they

138
00:09:07,152 --> 00:09:11,230
are like computers. This is the first

139
00:09:11,380 --> 00:09:15,662
way that Apple see its

140
00:09:15,716 --> 00:09:19,598
device. But jobs add

141
00:09:19,684 --> 00:09:23,294
this. That doesn't mean there's not

142
00:09:23,332 --> 00:09:27,442
coding to be software to buy that you can load on them coming

143
00:09:27,496 --> 00:09:31,154
from us, it doesn't mean we have to write it all,

144
00:09:31,272 --> 00:09:34,674
but it means it has to be more of

145
00:09:34,712 --> 00:09:36,930
a controlled environment.

146
00:09:38,310 --> 00:09:42,390
Steve Job said this on January Twelveth,

147
00:09:42,730 --> 00:09:46,998
three days later from the

148
00:09:47,164 --> 00:09:51,340
iPhone keynote presentation on the New York Times.

149
00:09:52,590 --> 00:09:55,994
As you see, Apple was thinking

150
00:09:56,112 --> 00:10:02,670
about the possibility of the App Store. But first they

151
00:10:02,740 --> 00:10:06,510
want to know if the iPhone will be

152
00:10:06,580 --> 00:10:09,600
a success or not. Obviously.

153
00:10:10,130 --> 00:10:14,626
Okay, well, but we

154
00:10:14,648 --> 00:10:18,254
are going to talk about the security of this first iPhone,

155
00:10:18,302 --> 00:10:22,706
that it's way far from

156
00:10:22,808 --> 00:10:26,440
the actual security because of this.

157
00:10:26,970 --> 00:10:31,602
Okay. The first iPhone has a cryptographic coprocessor.

158
00:10:31,746 --> 00:10:35,638
Well it's so. Well, because it

159
00:10:35,724 --> 00:10:39,638
needs to validate the digital

160
00:10:39,734 --> 00:10:43,402
signature of the software. It has two

161
00:10:43,536 --> 00:10:47,450
AES keys engraved in the ship which

162
00:10:47,520 --> 00:10:51,506
cannot be extracted a Giid,

163
00:10:51,638 --> 00:10:55,486
a global key which is the same for all the

164
00:10:55,508 --> 00:10:59,390
devices and other that iOS unique for

165
00:10:59,460 --> 00:11:03,170
each device. The combination of these

166
00:11:03,240 --> 00:11:07,460
two keys makes the way for the

167
00:11:08,150 --> 00:11:12,114
cipher for the cryptography needs to

168
00:11:12,312 --> 00:11:16,670
encrypt or decrypt data or validate

169
00:11:16,830 --> 00:11:20,790
the detailed signature of the programs

170
00:11:21,210 --> 00:11:24,770
in the boot process. The did and the UID keys

171
00:11:24,850 --> 00:11:28,026
are used to create the keys to

172
00:11:28,048 --> 00:11:32,310
be used by the device and those limits its exposure.

173
00:11:32,390 --> 00:11:37,962
Okay, the passcode was

174
00:11:38,016 --> 00:11:42,330
recorded in the keychain with no hash.

175
00:11:42,490 --> 00:11:45,680
It's open even more.

176
00:11:47,010 --> 00:11:50,570
If you clean the record in the keychain

177
00:11:50,650 --> 00:11:54,622
for the passcode, you are open the iPhone

178
00:11:54,766 --> 00:11:57,060
and that was passcoded to anyone.

179
00:11:57,590 --> 00:12:01,282
Okay, well this is the security.

180
00:12:01,416 --> 00:12:04,942
It's so easy. It was so easy to

181
00:12:05,096 --> 00:12:08,422
clean a passcode in the first iPhone and

182
00:12:08,476 --> 00:12:12,662
obviously was

183
00:12:12,716 --> 00:12:17,298
increment version by version. The security of the

184
00:12:17,404 --> 00:12:21,242
device, the device keychain was and still iOS,

185
00:12:21,296 --> 00:12:23,878
an sqlite three database.

186
00:12:24,054 --> 00:12:27,990
But most important, only the password elements

187
00:12:28,070 --> 00:12:31,838
were encrypted, were encrypted. The other was

188
00:12:31,924 --> 00:12:35,790
open in plain text. The encrypted elements were

189
00:12:35,860 --> 00:12:39,818
encrypted with the device key and a random initialization

190
00:12:39,914 --> 00:12:43,714
vector. But it was only one key for the

191
00:12:43,752 --> 00:12:46,946
whole keychain because if you make

192
00:12:47,048 --> 00:12:50,226
a brute force attack, you could

193
00:12:50,328 --> 00:12:53,730
extract the key and access to

194
00:12:53,800 --> 00:12:57,734
all the keychain and all the items, not only

195
00:12:57,852 --> 00:13:01,622
the items in the keychain, also the

196
00:13:01,676 --> 00:13:05,746
future keys in the keychain could be extracted

197
00:13:05,858 --> 00:13:09,126
if you make this brute

198
00:13:09,158 --> 00:13:12,860
force attack to this only key,

199
00:13:13,630 --> 00:13:17,062
I repeat only for the password

200
00:13:17,126 --> 00:13:20,230
elements. The other are recorded

201
00:13:20,400 --> 00:13:23,498
in the keychain in plain text format.

202
00:13:23,674 --> 00:13:27,102
The iPhone Os one file system was not

203
00:13:27,156 --> 00:13:30,958
encrypted. Use a file system similar

204
00:13:31,044 --> 00:13:37,378
to the iPod and you

205
00:13:37,384 --> 00:13:40,946
can see all the folders with a special

206
00:13:41,048 --> 00:13:44,754
software. But any executable maybe

207
00:13:44,872 --> 00:13:48,498
the most important using about the security of this iPhone

208
00:13:48,594 --> 00:13:51,954
had to be signed by Apple to run on the iPhone.

209
00:13:52,082 --> 00:13:55,318
But maybe you are thinking about

210
00:13:55,484 --> 00:13:59,146
what is a digital signature. Okay, we are going

211
00:13:59,168 --> 00:14:03,526
to talk about it. The digital signature, it's a method

212
00:14:03,638 --> 00:14:07,386
to ensure that a certain file or

213
00:14:07,488 --> 00:14:10,714
data is not modified in the

214
00:14:10,752 --> 00:14:14,790
time since it was digital

215
00:14:14,870 --> 00:14:18,974
signature detail signed, okay. It is a

216
00:14:19,012 --> 00:14:22,758
method to ensure the integrity

217
00:14:22,874 --> 00:14:27,234
of a data and the

218
00:14:27,272 --> 00:14:30,580
fact that this was not modified, okay,

219
00:14:31,430 --> 00:14:35,214
works in this way. First we have

220
00:14:35,352 --> 00:14:39,622
a document and then we are coding

221
00:14:39,676 --> 00:14:44,102
to calculate a cryptographic hash of this

222
00:14:44,236 --> 00:14:48,358
document. A cryptographic hash that validates

223
00:14:48,534 --> 00:14:52,566
its content. Okay, we have this cryptographic

224
00:14:52,598 --> 00:14:56,362
hash. Then we used a

225
00:14:56,496 --> 00:15:00,386
private signing key from a certificate.

226
00:15:00,518 --> 00:15:04,622
The private key is used to encrypt and

227
00:15:04,676 --> 00:15:08,062
the public key is used to

228
00:15:08,196 --> 00:15:11,482
decrypt it. IOS like you have the rare

229
00:15:11,626 --> 00:15:14,590
or unrar or thief or antip,

230
00:15:15,510 --> 00:15:20,018
something like this, okay, you have two ways

231
00:15:20,104 --> 00:15:23,086
to make or extract,

232
00:15:23,198 --> 00:15:27,826
okay? With the private key you can encrypt

233
00:15:27,938 --> 00:15:32,120
something. You can encrypt this

234
00:15:32,490 --> 00:15:36,134
cryptographic hash, but with

235
00:15:36,172 --> 00:15:39,658
the public key that you can put

236
00:15:39,744 --> 00:15:43,082
in something or give to anyone. With this

237
00:15:43,136 --> 00:15:46,682
public key you can only do

238
00:15:46,816 --> 00:15:50,922
a decryption. You can't encrypt

239
00:15:51,066 --> 00:15:55,182
with this public. You only come to decrypt with

240
00:15:55,236 --> 00:15:59,018
this private signing key, you encrypt

241
00:15:59,194 --> 00:16:02,966
the hash. Then when you are encrypting

242
00:16:03,098 --> 00:16:06,786
the hash, then you are going to

243
00:16:06,888 --> 00:16:10,414
attach this hash to the document.

244
00:16:10,542 --> 00:16:14,906
And now we said that you have assigned

245
00:16:15,038 --> 00:16:17,880
document, okay, well,

246
00:16:18,490 --> 00:16:22,486
and then time goes by and

247
00:16:22,668 --> 00:16:26,274
later on we can check the signature

248
00:16:26,402 --> 00:16:30,730
and the integrity of a file, a file

249
00:16:31,470 --> 00:16:35,254
with its digital signature attached

250
00:16:35,302 --> 00:16:38,746
on it. Well, the next step

251
00:16:38,848 --> 00:16:43,930
is to calculate the cryptographic

252
00:16:44,010 --> 00:16:47,840
hash without the encrypted signature part.

253
00:16:48,210 --> 00:16:51,690
We are going to recalculate the cryptographic hash

254
00:16:51,770 --> 00:16:55,854
because we need to know what is this hash

255
00:16:55,902 --> 00:16:59,698
for the file. And then we used the public

256
00:16:59,784 --> 00:17:03,838
key to decrypt the signed

257
00:17:03,934 --> 00:17:05,810
cryptographic hash.

258
00:17:06,550 --> 00:17:10,494
When we have the cryptographic

259
00:17:10,542 --> 00:17:14,402
hash under the decrypted cryptographic hash for the digital

260
00:17:14,466 --> 00:17:17,190
signature, we are going to compare.

261
00:17:17,710 --> 00:17:21,260
If these two hashes are the same,

262
00:17:23,230 --> 00:17:26,694
it means that has not been altered

263
00:17:26,742 --> 00:17:30,302
and is validated and has been signed by the

264
00:17:30,356 --> 00:17:35,070
authority that encrypted the hash in the first steps.

265
00:17:35,650 --> 00:17:39,070
That's it. This is a digital signature.

266
00:17:41,490 --> 00:17:45,010
Well, let's talk about next step

267
00:17:45,080 --> 00:17:48,862
with the a seven code. The secure enclave

268
00:17:49,006 --> 00:17:52,238
chip. Apple evolves

269
00:17:52,334 --> 00:17:56,674
the encryption engine that has from the

270
00:17:56,872 --> 00:18:00,254
first iPhone to a

271
00:18:00,312 --> 00:18:04,006
multipurpose chips intended for all security and

272
00:18:04,028 --> 00:18:07,898
encryption functions on the systems, including the

273
00:18:07,984 --> 00:18:11,740
biometric features with a new

274
00:18:12,110 --> 00:18:15,770
security chip called Secure Enclave,

275
00:18:16,190 --> 00:18:20,310
a chip that iOS iOS property

276
00:18:20,480 --> 00:18:23,770
is a property of the kernel of the systems.

277
00:18:23,930 --> 00:18:27,582
As you can see, the keys never

278
00:18:27,716 --> 00:18:31,578
leave the chip to another context.

279
00:18:31,754 --> 00:18:35,198
The keys that the system uses

280
00:18:35,374 --> 00:18:38,754
or the biometric data for

281
00:18:38,792 --> 00:18:42,274
Touch ID or Face ID never

282
00:18:42,472 --> 00:18:45,422
leave the chip to another context.

283
00:18:45,566 --> 00:18:48,274
Secure Enclave is a black box.

284
00:18:48,472 --> 00:18:51,538
It's a black box responsible

285
00:18:51,634 --> 00:18:56,566
for encrypting and decrypting any data. But you put

286
00:18:56,668 --> 00:19:01,638
a data on secure enclave and secure enclave returns

287
00:19:01,814 --> 00:19:06,010
the data with the encryption or

288
00:19:06,080 --> 00:19:08,650
the data decrypted.

289
00:19:08,990 --> 00:19:13,342
But you never know how

290
00:19:13,476 --> 00:19:16,266
this chip works internally.

291
00:19:16,458 --> 00:19:20,526
Okay? This is the most important thing and

292
00:19:20,708 --> 00:19:25,138
we don't know how iOS or what is

293
00:19:25,304 --> 00:19:30,638
this mathematical way to storage.

294
00:19:30,814 --> 00:19:34,990
All the things about the geometry, the Touch ID and the Face ID

295
00:19:35,160 --> 00:19:39,670
and other thing that Apple makes is

296
00:19:39,740 --> 00:19:43,922
to encrypt each file with an independent

297
00:19:43,986 --> 00:19:48,362
and unique key for each file, not one

298
00:19:48,416 --> 00:19:51,580
key for all the file systems, okay?

299
00:19:52,030 --> 00:19:55,434
And again, all inside this

300
00:19:55,472 --> 00:19:59,478
secure enclave, only the chip finger

301
00:19:59,574 --> 00:20:02,954
is able to access the contents of the chip memory.

302
00:20:03,082 --> 00:20:06,654
Even if we read the memory, we will not be able to

303
00:20:06,692 --> 00:20:08,960
extract anything of it.

304
00:20:09,890 --> 00:20:14,302
Sand hackers and security investigators

305
00:20:14,366 --> 00:20:17,474
try to read this memory, but this

306
00:20:17,512 --> 00:20:21,282
memory is not able to track anything.

307
00:20:21,416 --> 00:20:25,650
The chip has an as 256

308
00:20:25,800 --> 00:20:29,638
bitelectic curve, cryptographic key

309
00:20:29,804 --> 00:20:33,458
enzyme and four megabytes of ram

310
00:20:33,554 --> 00:20:36,840
in its first version. With this,

311
00:20:37,550 --> 00:20:41,782
we have this black box and ensure

312
00:20:41,926 --> 00:20:45,900
all the checks about encrypting data,

313
00:20:46,270 --> 00:20:49,594
signing data or biometric data,

314
00:20:49,712 --> 00:20:53,022
and all the things related to the security of

315
00:20:53,076 --> 00:20:57,150
the device. And obviously the system behaves in a very

316
00:20:57,220 --> 00:21:01,566
fluid way because there is no weight for these tax

317
00:21:01,748 --> 00:21:04,000
on the system. Okay,

318
00:21:05,090 --> 00:21:08,466
we are going to talk about additional layers of security

319
00:21:08,568 --> 00:21:11,698
that have been incorporated over time.

320
00:21:11,864 --> 00:21:14,820
For example, access to user information,

321
00:21:15,130 --> 00:21:18,582
extensions, services, or even iCloud is

322
00:21:18,636 --> 00:21:22,390
controlled by digital signed entitlements.

323
00:21:22,730 --> 00:21:26,134
But what is an entitlement? An entitlement allows the

324
00:21:26,172 --> 00:21:30,378
app to use certain functions or obtain specific

325
00:21:30,544 --> 00:21:34,134
permission to run some services or features

326
00:21:34,262 --> 00:21:38,298
on the system. If you want to use

327
00:21:38,464 --> 00:21:43,310
something that is not allowed for certain functionality,

328
00:21:45,170 --> 00:21:48,606
you can activate this entitlement. In fact,

329
00:21:48,708 --> 00:21:53,118
Apple could authorize

330
00:21:53,214 --> 00:21:56,978
you for certain entitlements after

331
00:21:57,064 --> 00:22:00,894
you ask the permission for certain features.

332
00:22:01,022 --> 00:22:04,770
Okay? And these entitlements allows you

333
00:22:04,840 --> 00:22:08,502
to use certain kind of APIs that

334
00:22:08,636 --> 00:22:13,720
in the first way it's forbidden for you. For example the

335
00:22:14,490 --> 00:22:17,480
diecloud or something else. Okay.

336
00:22:18,510 --> 00:22:22,314
Another thing that was implemented in the

337
00:22:22,352 --> 00:22:26,298
iPhone was ASLR or

338
00:22:26,384 --> 00:22:30,086
address space layer randomization that

339
00:22:30,128 --> 00:22:32,960
iOS incorporated in the system.

340
00:22:33,570 --> 00:22:37,534
This was a kind of security that iOS in

341
00:22:37,652 --> 00:22:40,410
each operating systems like Windows,

342
00:22:40,490 --> 00:22:42,190
Linux, et cetera.

343
00:22:42,870 --> 00:22:46,654
This function creates a table that ships

344
00:22:46,782 --> 00:22:50,750
important areas of the system such as the kernel,

345
00:22:50,910 --> 00:22:54,482
so that they are not always in the same place. And your

346
00:22:54,536 --> 00:22:58,022
process must have permission to ask

347
00:22:58,156 --> 00:23:01,750
about these tables to know what

348
00:23:01,900 --> 00:23:05,874
is the memory address of the kernel

349
00:23:06,002 --> 00:23:10,060
or other operating system important

350
00:23:10,510 --> 00:23:13,738
parts to access to them.

351
00:23:13,904 --> 00:23:18,138
Obviously you are not allowed to ask about this

352
00:23:18,304 --> 00:23:22,414
in your app, but the system have

353
00:23:22,612 --> 00:23:26,430
this security to guarantee the

354
00:23:26,500 --> 00:23:29,360
security and the integrity of all the system.

355
00:23:30,370 --> 00:23:34,670
About this iOS use Armxn

356
00:23:34,750 --> 00:23:38,290
or execute never. This is a way which

357
00:23:38,360 --> 00:23:42,734
marks memory pages as nonexecutable.

358
00:23:42,862 --> 00:23:46,770
If you put some code in the memory,

359
00:23:46,930 --> 00:23:50,838
you cannot execute this

360
00:23:50,924 --> 00:23:54,258
code. You are not allowed to execute

361
00:23:54,434 --> 00:23:58,634
code in any memory position in

362
00:23:58,672 --> 00:24:02,746
the device. Why? Because you

363
00:24:02,928 --> 00:24:07,190
need a valid entitlement of the associated

364
00:24:07,270 --> 00:24:10,698
app, but will be able to execute

365
00:24:10,794 --> 00:24:12,910
this code in memory.

366
00:24:14,210 --> 00:24:18,270
Each app has its own entitlement

367
00:24:18,610 --> 00:24:22,474
and if a code is not

368
00:24:22,612 --> 00:24:26,114
from this certain app is

369
00:24:26,232 --> 00:24:29,458
not allowed to execute this code

370
00:24:29,624 --> 00:24:32,750
in this place in the memory.

371
00:24:32,910 --> 00:24:36,742
Okay. This is the way that

372
00:24:36,876 --> 00:24:41,126
the system guarantees that you are not

373
00:24:41,228 --> 00:24:45,346
allowed to execute or to inject

374
00:24:45,458 --> 00:24:49,414
any code on the system to execute

375
00:24:49,462 --> 00:24:53,802
it. If this code is

376
00:24:53,856 --> 00:24:57,500
not from an autorespond app that

377
00:24:59,970 --> 00:25:03,120
it was a valid digital signature. Okay.

378
00:25:06,210 --> 00:25:09,754
Another thing iOS about network communications,

379
00:25:09,882 --> 00:25:12,702
we're going to talk about app transport security.

380
00:25:12,836 --> 00:25:17,378
ATS ETS is a set of requirements for

381
00:25:17,464 --> 00:25:21,410
securing network communications. It force

382
00:25:21,910 --> 00:25:25,650
the exclusive use of your session and URL

383
00:25:25,730 --> 00:25:29,650
connection even for third party network

384
00:25:29,730 --> 00:25:32,678
APIs. Because of this,

385
00:25:32,844 --> 00:25:36,706
all the third party network APIs

386
00:25:36,898 --> 00:25:40,438
are wrappers of Apple's native

387
00:25:40,534 --> 00:25:44,058
APIs. If you use Af

388
00:25:44,144 --> 00:25:48,140
networking or Alamo fire,

389
00:25:48,750 --> 00:25:52,602
you are using a wrapper of URL session.

390
00:25:52,746 --> 00:25:56,746
Okay? From iOS

391
00:25:56,938 --> 00:26:01,214
nine. This set of requirements are

392
00:26:01,332 --> 00:26:05,042
mandates for things like the users

393
00:26:05,096 --> 00:26:08,498
of TLS one two or even

394
00:26:08,584 --> 00:26:12,334
TLS one two three on all server

395
00:26:12,382 --> 00:26:18,354
certificates, 2048 arse

396
00:26:18,482 --> 00:26:22,918
encryption or 256

397
00:26:23,004 --> 00:26:27,080
bits elliptic curve key signed with

398
00:26:27,390 --> 00:26:31,820
SHA 2056

399
00:26:32,190 --> 00:26:35,514
using AC DHe with

400
00:26:35,632 --> 00:26:38,778
firewall secret this is a

401
00:26:38,784 --> 00:26:42,494
protocol to key agreement between two

402
00:26:42,532 --> 00:26:46,526
servers. You make a

403
00:26:46,548 --> 00:26:49,854
public key and send to another server and this

404
00:26:49,892 --> 00:26:52,802
server makes another public key and sent to you.

405
00:26:52,856 --> 00:26:56,738
And with this you can create a key agreement and

406
00:26:56,824 --> 00:27:00,660
create a private key that iOS shared between

407
00:27:01,990 --> 00:27:05,506
two sites from our server

408
00:27:05,538 --> 00:27:09,394
and the other server or from our device to a server

409
00:27:09,522 --> 00:27:13,400
and we have a private key that iOS

410
00:27:13,930 --> 00:27:17,706
different from each side but you

411
00:27:17,728 --> 00:27:21,242
can use it to decrypt the same data with

412
00:27:21,296 --> 00:27:25,370
this public key associated this is a key agreement

413
00:27:25,710 --> 00:27:28,998
protocol communication encryption.

414
00:27:29,094 --> 00:27:32,954
Okay, allow exceptions

415
00:27:33,082 --> 00:27:36,682
for this. If you don't want to use a secure

416
00:27:36,746 --> 00:27:40,062
connection through HTTPs or

417
00:27:40,116 --> 00:27:43,698
another protects, you can allow

418
00:27:43,864 --> 00:27:47,122
Apple allow the exception for for example

419
00:27:47,256 --> 00:27:51,182
multimedia content streams with AV foundation

420
00:27:51,326 --> 00:27:55,070
that can do it in HTTP or

421
00:27:55,160 --> 00:27:58,674
webview request or maybe local host

422
00:27:58,802 --> 00:28:02,674
usage when are working in debug

423
00:28:02,722 --> 00:28:03,880
code. Okay.

424
00:28:06,890 --> 00:28:10,454
All these things are mandatory standards

425
00:28:10,582 --> 00:28:14,902
since the end of 2016 which evolved

426
00:28:14,966 --> 00:28:18,842
year after year to comply with best practices in

427
00:28:18,896 --> 00:28:22,814
communications security. We must know all

428
00:28:22,852 --> 00:28:25,998
these rules to ensure the security of

429
00:28:26,084 --> 00:28:29,486
our app. Okay, well we

430
00:28:29,508 --> 00:28:33,106
are going to talk about data encryption. The use

431
00:28:33,128 --> 00:28:37,070
of data encryption is free to use but with recommendations

432
00:28:37,150 --> 00:28:40,914
for Apple. For example, Apple does not recommend the use of R

433
00:28:40,952 --> 00:28:45,130
C, four or three DES algorithms.

434
00:28:45,310 --> 00:28:49,170
Both are compromised and will be removed to avoid

435
00:28:49,250 --> 00:28:53,174
their use in future versions. For encryption you must

436
00:28:53,292 --> 00:28:57,046
use AesGCM or

437
00:28:57,148 --> 00:29:01,980
Chacha 20. That is two

438
00:29:02,350 --> 00:29:06,538
encryption algorithms that both support from

439
00:29:06,624 --> 00:29:10,234
Apple's cryptokit API that it's available

440
00:29:10,352 --> 00:29:13,798
for the system from iOS 13.

441
00:29:13,974 --> 00:29:17,514
Cryptokit is a swift native

442
00:29:17,642 --> 00:29:20,826
APIs API for encryption.

443
00:29:21,018 --> 00:29:24,398
Also if you work with SwiftuI

444
00:29:24,494 --> 00:29:28,398
in open source, you can use Swift crypto

445
00:29:28,494 --> 00:29:32,738
that is the same as cryptokid but

446
00:29:32,824 --> 00:29:36,374
using the coding SSL Google engine

447
00:29:36,492 --> 00:29:39,814
to make the same things with the

448
00:29:39,852 --> 00:29:43,350
same specification with the same interface.

449
00:29:43,770 --> 00:29:47,502
Because of this you can work in encryption

450
00:29:47,666 --> 00:29:51,674
in for example server side in vapor or in

451
00:29:51,712 --> 00:29:54,790
your app using Cocotach or Cocoa.

452
00:29:54,870 --> 00:29:58,106
With cryptokit these algorithms have the

453
00:29:58,128 --> 00:30:02,078
advantage of allowing not only encryption but also

454
00:30:02,244 --> 00:30:05,706
checking whether the data has been modified.

455
00:30:05,898 --> 00:30:09,582
We can validate the integrity of any

456
00:30:09,636 --> 00:30:14,610
data that it's encrypt of the crypt with these algorithms.

457
00:30:15,670 --> 00:30:19,310
Also all the files on the device are encrypted

458
00:30:19,390 --> 00:30:22,978
and we have several encryption modes to set for

459
00:30:23,064 --> 00:30:26,982
each file that we can use when

460
00:30:27,116 --> 00:30:30,470
users the metal safe from a

461
00:30:30,540 --> 00:30:34,550
data type. For example,

462
00:30:34,700 --> 00:30:38,458
we are going to talk about these four

463
00:30:38,624 --> 00:30:42,070
system code for encrypting data in storage.

464
00:30:42,230 --> 00:30:46,234
The first one iOS NS file protection known there

465
00:30:46,272 --> 00:30:50,286
is no encryption on the data. It remains open even when

466
00:30:50,308 --> 00:30:53,674
the device iOS locked. However, it requires

467
00:30:53,722 --> 00:30:58,254
the file system to be mounted because when

468
00:30:58,372 --> 00:31:02,490
your device is turned off the

469
00:31:02,580 --> 00:31:05,874
file system is not mounted. It needs that

470
00:31:05,912 --> 00:31:09,634
the file system is mounted and then anyone

471
00:31:09,752 --> 00:31:12,766
can access to these files.

472
00:31:12,958 --> 00:31:16,662
The next level is the NS file protection, complete until

473
00:31:16,716 --> 00:31:20,520
first user authentication. As you can see

474
00:31:21,290 --> 00:31:27,458
this name is from objective c. Obviously this

475
00:31:27,564 --> 00:31:30,460
option is the default for the system,

476
00:31:31,150 --> 00:31:36,006
it means that the file is encrypt and inaccessible

477
00:31:36,198 --> 00:31:39,922
inaccessible until the device is unlocked

478
00:31:40,006 --> 00:31:44,170
for the first time. When you put the first time your passcode

479
00:31:44,250 --> 00:31:47,440
or your password okay.

480
00:31:47,810 --> 00:31:51,694
It also locked after 20 or maybe

481
00:31:51,812 --> 00:31:55,134
44 hours which requires real locking

482
00:31:55,262 --> 00:31:58,850
with passcode instead of touch id or face id.

483
00:31:59,000 --> 00:32:02,722
Do you know that between 24 hours

484
00:32:02,856 --> 00:32:06,742
or maybe later the device will ask

485
00:32:06,796 --> 00:32:09,570
you again for the passcode?

486
00:32:09,730 --> 00:32:13,062
And because the system rancrypt all

487
00:32:13,116 --> 00:32:16,294
the file system and needs you to

488
00:32:16,332 --> 00:32:18,700
put your passcode again.

489
00:32:20,110 --> 00:32:23,754
Like I said, this is the default code for all

490
00:32:23,792 --> 00:32:27,946
the files and it's a code that

491
00:32:28,128 --> 00:32:32,446
allows to access the files even when

492
00:32:32,468 --> 00:32:35,680
the device is locked. Okay,

493
00:32:37,890 --> 00:32:41,994
but you must put the first passcode

494
00:32:42,042 --> 00:32:45,566
at the beginning for processes that need continuous

495
00:32:45,598 --> 00:32:48,690
access to data, music, podcast,

496
00:32:49,110 --> 00:32:52,462
Bluetooth devices, your location, et cetera.

497
00:32:52,606 --> 00:32:55,990
Even if you have your device locked,

498
00:32:56,730 --> 00:33:00,486
your files are visible to

499
00:33:00,588 --> 00:33:05,000
the file system and the apps can access them

500
00:33:05,530 --> 00:33:09,382
while the device iOS not in mode.

501
00:33:09,526 --> 00:33:13,290
For asking you to put again the passcode,

502
00:33:14,910 --> 00:33:18,774
the next step is NS file protection

503
00:33:18,822 --> 00:33:22,478
complete unless open. In this

504
00:33:22,644 --> 00:33:26,938
kind of security, all the files are encrypted

505
00:33:27,034 --> 00:33:30,474
and can only be opened when the device is unlocked.

506
00:33:30,602 --> 00:33:34,562
When you locked the device, the file iOS encrypted and

507
00:33:34,616 --> 00:33:38,098
iOS not allowed to access to any app

508
00:33:38,264 --> 00:33:41,810
or any process in background.

509
00:33:42,550 --> 00:33:46,178
But there is one exception.

510
00:33:46,354 --> 00:33:50,034
Files are not locked or encrypted

511
00:33:50,162 --> 00:33:54,262
when the device is locked. If they're being used, they wait

512
00:33:54,316 --> 00:33:57,394
to encrypt when no threat is using it.

513
00:33:57,452 --> 00:34:01,162
Imagine you have a background process and

514
00:34:01,216 --> 00:34:04,810
you locked the device.

515
00:34:05,230 --> 00:34:09,430
Well if you lock the device and the file

516
00:34:09,510 --> 00:34:13,066
is using, the file is not encrypted

517
00:34:13,178 --> 00:34:15,690
unless it's closed.

518
00:34:15,850 --> 00:34:23,794
Unless complete. Unless open okay when

519
00:34:23,832 --> 00:34:27,326
the process is finished, then encrypt

520
00:34:27,358 --> 00:34:30,946
the file and the process or any other app

521
00:34:31,048 --> 00:34:34,290
cannot access to them. Okay recommended for the process

522
00:34:34,440 --> 00:34:37,942
when you have uploading or downloading data over

523
00:34:37,996 --> 00:34:41,446
network, which must be encrypted when

524
00:34:41,468 --> 00:34:45,880
the background process will finish. Okay, and the

525
00:34:46,650 --> 00:34:50,378
perfect method the method I use for most

526
00:34:50,464 --> 00:34:54,026
of my data is NS file protection complete.

527
00:34:54,208 --> 00:34:57,690
NS file protection complete is the higher security code.

528
00:34:58,110 --> 00:35:01,978
IOS files are encrypted and inaccessible

529
00:35:02,074 --> 00:35:05,870
until the device is unlocked. Okay, if you have

530
00:35:05,940 --> 00:35:10,062
your device unlocked, okay your device your

531
00:35:10,116 --> 00:35:14,114
files are ready to access, but if you locked the

532
00:35:14,152 --> 00:35:18,194
device, then all the files will

533
00:35:18,232 --> 00:35:22,350
be encrypted and it was impossible

534
00:35:22,430 --> 00:35:25,670
to access for any app or process.

535
00:35:25,820 --> 00:35:29,670
Okay, files are locked and

536
00:35:29,740 --> 00:35:33,970
any threats to them are cut off when the device

537
00:35:34,050 --> 00:35:38,982
is locked. Okay recommended

538
00:35:39,046 --> 00:35:42,394
for most update how can

539
00:35:42,432 --> 00:35:46,586
you use it? How can you use this?

540
00:35:46,768 --> 00:35:50,814
Well, using this code as you can see

541
00:35:50,932 --> 00:35:54,560
you have a try data

542
00:35:55,330 --> 00:35:59,694
write to URL and then you users options.

543
00:35:59,892 --> 00:36:04,398
And in these options you can put enumerations

544
00:36:04,574 --> 00:36:07,698
in an array. The first

545
00:36:07,864 --> 00:36:09,970
is atomic.

546
00:36:10,470 --> 00:36:14,286
Atomic. It's a mode that opens

547
00:36:14,318 --> 00:36:17,874
a temporary file to write

548
00:36:17,992 --> 00:36:21,526
all the data buffer, all the process to

549
00:36:21,548 --> 00:36:25,010
write the data buffer to this temporary file.

550
00:36:25,170 --> 00:36:29,190
And when all the data buffer is

551
00:36:29,340 --> 00:36:33,530
write to this temporary file, the temporary file is

552
00:36:33,600 --> 00:36:37,494
closed and then moved to the final location

553
00:36:37,622 --> 00:36:41,374
in the disk on the disk on the

554
00:36:41,492 --> 00:36:45,342
location of the app. Okay? This is a

555
00:36:45,396 --> 00:36:48,926
secure way to ensure that

556
00:36:49,028 --> 00:36:53,220
any other process cannot access to a

557
00:36:53,750 --> 00:36:57,650
writing process. In my application also

558
00:36:57,720 --> 00:37:01,630
you have complete file protection. Complete file protection

559
00:37:01,710 --> 00:37:05,990
iOS, the last mode that we

560
00:37:06,060 --> 00:37:09,974
are talk the code that encrypt the

561
00:37:10,012 --> 00:37:13,778
file in the moment that you locked

562
00:37:13,874 --> 00:37:17,426
your device. Okay? This is the way you

563
00:37:17,468 --> 00:37:21,530
can use this. With all

564
00:37:21,600 --> 00:37:24,540
these things in our hands,

565
00:37:25,310 --> 00:37:28,090
we have to ask you ourselves,

566
00:37:29,390 --> 00:37:32,030
are our iPhone secure?

567
00:37:32,370 --> 00:37:36,250
No. No system iOS secure.

568
00:37:36,410 --> 00:37:40,074
Even with all present of feature security features,

569
00:37:40,202 --> 00:37:43,810
no device iOS ever 100%

570
00:37:43,960 --> 00:37:47,746
secure. They never will

571
00:37:47,928 --> 00:37:51,470
be. Never. It's impossible.

572
00:37:51,630 --> 00:37:55,460
Okay, if someone says you

573
00:37:56,550 --> 00:38:00,454
something, someone says you that your iPhone or

574
00:38:00,492 --> 00:38:03,938
any other device is 100% secure,

575
00:38:04,114 --> 00:38:06,520
it lies to you. Okay?

576
00:38:07,470 --> 00:38:10,726
Every operating system and even hardware

577
00:38:10,838 --> 00:38:14,762
can have bugs in its design or iOS code

578
00:38:14,816 --> 00:38:18,454
that allow vulnerabilities to exploit

579
00:38:18,502 --> 00:38:22,094
it and do things that a system is

580
00:38:22,132 --> 00:38:25,582
supposed to be protected against. It's easy

581
00:38:25,636 --> 00:38:29,758
to understand what is a zero day because

582
00:38:29,924 --> 00:38:33,890
it's a software that tries

583
00:38:34,550 --> 00:38:39,122
you not to do something has

584
00:38:39,176 --> 00:38:42,882
a bag and this back

585
00:38:43,016 --> 00:38:46,200
that allows you to do it.

586
00:38:47,210 --> 00:38:51,410
That's it. And there's

587
00:38:51,570 --> 00:38:55,382
no system without this kind

588
00:38:55,436 --> 00:38:59,082
of errors. How can I protect against

589
00:38:59,216 --> 00:39:03,180
this? Okay, the only way to be protected is

590
00:39:03,870 --> 00:39:07,686
update our system as soon as patches

591
00:39:07,798 --> 00:39:12,030
are released for the bugs that are discovered.

592
00:39:12,370 --> 00:39:15,838
But part of our responsibility as

593
00:39:15,924 --> 00:39:20,154
developers is to take into account best development

594
00:39:20,202 --> 00:39:24,434
practice that improve security and make it more

595
00:39:24,552 --> 00:39:27,758
difficult for civil criminals to compromise

596
00:39:27,854 --> 00:39:32,034
our systems. Okay? If we

597
00:39:32,232 --> 00:39:35,494
do the right using to

598
00:39:35,612 --> 00:39:39,622
make our app more secure will

599
00:39:39,676 --> 00:39:43,154
be hard for these civil criminals

600
00:39:43,202 --> 00:39:48,310
to compromise our app and our users'data.

601
00:39:48,750 --> 00:39:51,660
Okay, that's it.

602
00:39:53,230 --> 00:39:56,620
We are going to talk about Swift Swift security

603
00:39:57,070 --> 00:40:00,170
because Swift has security as its

604
00:40:00,240 --> 00:40:04,346
core. Why? Okay, Swiftui, like many other languages,

605
00:40:04,458 --> 00:40:08,080
is made in c, in c language, okay,

606
00:40:08,450 --> 00:40:11,898
but Swift is strictly typed,

607
00:40:11,994 --> 00:40:15,714
value oriented language. But what

608
00:40:15,752 --> 00:40:19,650
does that mean? Okay. Means that

609
00:40:19,800 --> 00:40:23,522
data is self initialized to

610
00:40:23,576 --> 00:40:27,350
data types and isolates them by

611
00:40:27,420 --> 00:40:31,030
default. When you put a number

612
00:40:31,100 --> 00:40:34,790
one in your code, one is not a value,

613
00:40:34,940 --> 00:40:38,200
it's a type. It's a data type.

614
00:40:38,650 --> 00:40:42,710
That's because we are talking about value

615
00:40:42,860 --> 00:40:47,190
typed because the values are typed

616
00:40:47,270 --> 00:40:50,880
and converted automatically into

617
00:40:51,330 --> 00:40:56,426
data types because it's self initialized

618
00:40:56,618 --> 00:40:59,882
and there's no values in Swiftui,

619
00:41:00,026 --> 00:41:03,394
there's data types. Because of

620
00:41:03,432 --> 00:41:07,506
this. You can infer when you put let

621
00:41:07,608 --> 00:41:11,090
a equals one, a iOS

622
00:41:11,240 --> 00:41:14,466
integral type because one is not a

623
00:41:14,488 --> 00:41:18,166
value, one is an integral type.

624
00:41:18,348 --> 00:41:22,440
Self initialize it. Okay? This is

625
00:41:24,810 --> 00:41:29,338
value typed language, okay? And is

626
00:41:29,504 --> 00:41:32,538
strictly typed. Because of this,

627
00:41:32,704 --> 00:41:36,650
the different data types are not allowed to

628
00:41:36,800 --> 00:41:40,650
work between them. Also, swift runtime

629
00:41:40,730 --> 00:41:43,934
is static. It's not dynamic, so it

630
00:41:43,972 --> 00:41:47,630
does not allow runtime injection of

631
00:41:47,700 --> 00:41:51,214
any elements. Because of this, when you work

632
00:41:51,332 --> 00:41:55,646
with TDD, with test driven development,

633
00:41:55,838 --> 00:41:59,490
you have to create code,

634
00:41:59,910 --> 00:42:03,310
the injections or the mock

635
00:42:03,390 --> 00:42:07,286
objects, et cetera. You cannot use

636
00:42:07,468 --> 00:42:11,750
an API that injects dynamically

637
00:42:12,170 --> 00:42:15,782
like objectise or even other languages like

638
00:42:15,836 --> 00:42:19,514
Java because Swiftui has this

639
00:42:19,712 --> 00:42:26,474
static runtime and you cannot modify anything

640
00:42:26,672 --> 00:42:30,602
in the execution of your app collection

641
00:42:30,666 --> 00:42:33,946
types even is fully

642
00:42:34,058 --> 00:42:38,154
dynamic, so it avoids buffer

643
00:42:38,202 --> 00:42:42,470
overflows as its foundation. A string

644
00:42:42,650 --> 00:42:46,722
data, an array or dictionary has

645
00:42:46,856 --> 00:42:50,290
no initialization for

646
00:42:50,440 --> 00:42:54,306
the initial storage if all

647
00:42:54,408 --> 00:42:58,646
this kind of data are 100%

648
00:42:58,828 --> 00:43:02,134
dynamic. A string has

649
00:43:02,172 --> 00:43:06,946
a dynamic storage and creates more storage

650
00:43:07,058 --> 00:43:09,580
when it needs in real time.

651
00:43:10,030 --> 00:43:13,820
Okay? Because of this, it's impossible to

652
00:43:14,990 --> 00:43:18,454
do a buffer overflow when you code in impure

653
00:43:18,502 --> 00:43:21,806
swiftui. Okay, the use

654
00:43:21,908 --> 00:43:25,898
of uninitialized variables is prevented.

655
00:43:26,074 --> 00:43:30,378
As you know, we all know the optional values

656
00:43:30,554 --> 00:43:34,706
and iOS a compiler error for Swiftui forcing a

657
00:43:34,808 --> 00:43:38,322
defined initialization or the use of

658
00:43:38,376 --> 00:43:41,842
optional values. As you know, all the

659
00:43:41,896 --> 00:43:45,962
data in Swiftui must be initialized

660
00:43:46,126 --> 00:43:49,814
before we are going to users it.

661
00:43:49,932 --> 00:43:53,560
Okay? And if some data

662
00:43:54,810 --> 00:43:58,620
we don't know the data, we are going to storage them,

663
00:43:59,870 --> 00:44:04,438
we must users the optional values. Optional values

664
00:44:04,534 --> 00:44:07,818
are an uninitialized variables. No,

665
00:44:07,904 --> 00:44:11,520
because an optional value when you're defined it

666
00:44:12,370 --> 00:44:16,986
has an inferred initialization equals

667
00:44:17,098 --> 00:44:22,510
nil when you put bar something column

668
00:44:23,350 --> 00:44:27,300
int question mark and

669
00:44:27,670 --> 00:44:31,214
the compiler inferred equals

670
00:44:31,342 --> 00:44:34,782
nil. Because of this, all the data

671
00:44:34,936 --> 00:44:38,838
are initialized before we

672
00:44:39,004 --> 00:44:40,600
used. Okay.

673
00:44:42,090 --> 00:44:46,178
Also, code compiled in Swift is obfuscated

674
00:44:46,274 --> 00:44:49,802
by default. Any code

675
00:44:49,936 --> 00:44:53,718
compiled in Swift is not readable,

676
00:44:53,814 --> 00:44:57,206
is not accessible. You cannot

677
00:44:57,318 --> 00:45:00,966
read a compiled code in Swiftui because it's

678
00:45:01,078 --> 00:45:04,862
obfuscate. And obfuscation is when you

679
00:45:04,996 --> 00:45:09,034
change the name of the mail dots and the variables

680
00:45:09,162 --> 00:45:12,640
to something is not readable like

681
00:45:13,510 --> 00:45:16,146
randomized characters. Okay?

682
00:45:16,328 --> 00:45:20,674
You have a table for

683
00:45:20,712 --> 00:45:24,942
the corresponding names between the readable

684
00:45:25,006 --> 00:45:28,274
names and the non readable name that it's obfuscated.

685
00:45:28,402 --> 00:45:33,074
Okay, this table is the symbols.

686
00:45:33,202 --> 00:45:36,722
When you strip the symbols in Swiftui compilation.

687
00:45:36,866 --> 00:45:39,990
You're making this table and this table

688
00:45:40,150 --> 00:45:44,060
later you have to upload, for example

689
00:45:45,870 --> 00:45:49,754
to chrysalytics in Firebase to make the

690
00:45:49,792 --> 00:45:53,422
match between the obfuscated names and the

691
00:45:53,476 --> 00:45:57,054
names that the program used. Okay, this is

692
00:45:57,092 --> 00:46:00,270
the script symbols functionality, the feature

693
00:46:03,410 --> 00:46:07,378
let's go. And we are talking about insecure that

694
00:46:07,464 --> 00:46:11,410
data recording. We are going to talk about best

695
00:46:11,480 --> 00:46:15,302
practices with data. We have to know

696
00:46:15,356 --> 00:46:19,270
that any data recorded in flat persistent is

697
00:46:19,340 --> 00:46:22,562
visible by anyone such as using JSon,

698
00:46:22,626 --> 00:46:26,690
paylist or even core data or sqlite databases.

699
00:46:26,850 --> 00:46:30,300
It is wise to audit the sensitivity of the data

700
00:46:31,150 --> 00:46:35,114
before developing and decide how it will be

701
00:46:35,152 --> 00:46:38,570
persisted and where and if any data

702
00:46:38,720 --> 00:46:42,734
needs encryption or maybe any data have

703
00:46:42,772 --> 00:46:47,722
to be storage in certain locations,

704
00:46:47,866 --> 00:46:52,014
for example the keychain to

705
00:46:52,052 --> 00:46:56,450
avoid the access or read from

706
00:46:56,520 --> 00:46:59,774
anyone in the flat persistent,

707
00:46:59,902 --> 00:47:03,780
okay. Sometimes they are very sensitive data

708
00:47:04,310 --> 00:47:08,520
that either should not go on the device. For example,

709
00:47:08,970 --> 00:47:12,546
some data must be only in server

710
00:47:12,578 --> 00:47:16,838
side and if you work with this data

711
00:47:17,004 --> 00:47:21,046
only in your memory, this data iOS secure.

712
00:47:21,238 --> 00:47:25,706
But if you storage in your device with

713
00:47:25,808 --> 00:47:29,350
a JSoN, with a paylist, with a database,

714
00:47:29,430 --> 00:47:34,110
et cetera will be visible

715
00:47:34,530 --> 00:47:38,030
in, like I said before, persistent,

716
00:47:38,450 --> 00:47:42,334
flat persistent, okay. Because of this,

717
00:47:42,532 --> 00:47:45,966
the best way to work with certain

718
00:47:46,068 --> 00:47:50,434
data is not to a storage on the device works

719
00:47:50,552 --> 00:47:54,050
only with server size and with

720
00:47:54,200 --> 00:47:58,098
memory or have their own container

721
00:47:58,194 --> 00:48:01,458
in the system to be stored. The keychain

722
00:48:01,634 --> 00:48:05,046
health data or maybe honky data

723
00:48:05,228 --> 00:48:08,922
has its own container in the system and

724
00:48:08,976 --> 00:48:12,810
you have to use it. Okay, even more,

725
00:48:12,880 --> 00:48:16,490
the users of local databases should be

726
00:48:16,560 --> 00:48:20,742
properly encrypted. It's a best practice

727
00:48:20,806 --> 00:48:25,294
to make a transparent ledger between

728
00:48:25,492 --> 00:48:28,974
your database, for example with

729
00:48:29,012 --> 00:48:32,742
core data or even when you store directly

730
00:48:32,826 --> 00:48:35,806
in your application a JSON file.

731
00:48:35,998 --> 00:48:39,678
Maybe it's a good idea to make a transparent

732
00:48:39,774 --> 00:48:42,750
layer for encryption in these databases.

733
00:48:42,910 --> 00:48:46,614
Okay. If you users realm, for example

734
00:48:46,732 --> 00:48:49,110
realm has this feature,

735
00:48:49,850 --> 00:48:53,938
you can set an encryption

736
00:48:54,034 --> 00:48:57,698
key on realm and then all the data

737
00:48:57,804 --> 00:49:01,242
in this database will be encrypted and is not

738
00:49:01,296 --> 00:49:05,610
visible to anyone that try to read

739
00:49:05,760 --> 00:49:10,342
the database. Okay. But with code data you

740
00:49:10,496 --> 00:49:14,282
must create this transparent layer

741
00:49:14,346 --> 00:49:17,950
for encryption and decryption. It's not so

742
00:49:18,020 --> 00:49:22,390
hard because you can users extensions

743
00:49:22,490 --> 00:49:27,026
for the data types, okay, but well you

744
00:49:27,048 --> 00:49:30,478
must do it. This is your responsibility.

745
00:49:30,654 --> 00:49:34,594
If we persist, for example, an enumeration that is part

746
00:49:34,712 --> 00:49:38,134
of a sensitive data set, we should not

747
00:49:38,172 --> 00:49:42,082
duty its value as a string or sequential

748
00:49:42,226 --> 00:49:45,862
numbering, okay, if you users an

749
00:49:45,916 --> 00:49:49,290
enumeration and you are

750
00:49:49,440 --> 00:49:52,170
typing with string,

751
00:49:52,990 --> 00:49:56,986
it's more secure to put strings that

752
00:49:57,088 --> 00:50:02,414
is not equivalent to its

753
00:50:02,452 --> 00:50:05,760
value. Okay, because of this, when someone

754
00:50:06,210 --> 00:50:09,760
read your code, when someone read your data,

755
00:50:11,490 --> 00:50:14,858
they don't know the equivalent,

756
00:50:14,954 --> 00:50:18,410
the equivalent of these values.

757
00:50:18,490 --> 00:50:19,120
Okay,

758
00:50:21,490 --> 00:50:24,806
more now we are going to talk about

759
00:50:24,948 --> 00:50:28,294
data encryption and has calculation. Okay,

760
00:50:28,492 --> 00:50:32,050
maybe you are thinking, but to use encryption,

761
00:50:32,130 --> 00:50:36,038
okay, we are going to see it. The first things we want to know.

762
00:50:36,124 --> 00:50:39,818
IOS cryptographically secure random numbers

763
00:50:39,984 --> 00:50:43,738
okay, what is this? Okay, first of all,

764
00:50:43,904 --> 00:50:47,706
before playing with cryptography, it iOS necessary to

765
00:50:47,728 --> 00:50:50,670
be able to generate random numbers,

766
00:50:50,820 --> 00:50:54,382
but secure random numbers.

767
00:50:54,516 --> 00:50:57,438
Cryptographically secure random numbers,

768
00:50:57,524 --> 00:51:00,926
cryptographically strong random numbers

769
00:51:01,108 --> 00:51:04,706
which are built in arrays of bytes in

770
00:51:04,728 --> 00:51:08,660
a data type and not with numbers.

771
00:51:09,030 --> 00:51:13,090
Why we use them? Because these do not use

772
00:51:13,160 --> 00:51:16,758
any type of value from the device itself like other

773
00:51:16,844 --> 00:51:18,790
randomized algorithms.

774
00:51:21,050 --> 00:51:24,834
With this way we use algorithm,

775
00:51:24,882 --> 00:51:28,778
algorithmic formulas that guarantee that no

776
00:51:28,864 --> 00:51:32,922
pattern can be found that will discover them.

777
00:51:33,056 --> 00:51:36,742
It's a totally, absolutely randomized

778
00:51:36,886 --> 00:51:41,546
number with created without pattern,

779
00:51:41,658 --> 00:51:45,806
okay, it's a cryptographically strong

780
00:51:45,988 --> 00:51:49,902
random number, okay, how can

781
00:51:50,036 --> 00:51:53,794
we create it? Okay, it's so easy. We can

782
00:51:53,832 --> 00:51:57,406
use the sec random copy

783
00:51:57,438 --> 00:52:01,538
bytes method from the security

784
00:52:01,704 --> 00:52:05,102
of the keychain and all the things

785
00:52:05,176 --> 00:52:08,418
about the security framework in Swift.

786
00:52:08,594 --> 00:52:12,760
And then we can use

787
00:52:13,130 --> 00:52:17,314
something that is so good from

788
00:52:17,452 --> 00:52:21,142
swift five. The array

789
00:52:21,286 --> 00:52:25,082
of u int eight and

790
00:52:25,136 --> 00:52:28,838
signed integral of eight bits.

791
00:52:29,014 --> 00:52:32,960
An array of this swift native type

792
00:52:33,410 --> 00:52:37,370
is convertible, is directly convertible

793
00:52:37,450 --> 00:52:40,746
to data type with the constructor.

794
00:52:40,858 --> 00:52:41,520
Okay,

795
00:52:44,310 --> 00:52:47,998
as you know, you can convert a double

796
00:52:48,094 --> 00:52:51,678
number in int or int in double,

797
00:52:51,774 --> 00:52:54,890
okay, you can put an in number double

798
00:52:54,990 --> 00:52:59,270
parentheses in number parentheses, and then you have a

799
00:52:59,420 --> 00:53:04,402
direct creation, a direct transformation

800
00:53:04,466 --> 00:53:07,942
between types using the constructors, okay,

801
00:53:08,076 --> 00:53:12,698
an array of u int eight has

802
00:53:12,864 --> 00:53:16,746
direct transformation with

803
00:53:16,928 --> 00:53:20,526
data type. If you have an array of

804
00:53:20,548 --> 00:53:24,686
using eight, you can put this data in

805
00:53:24,788 --> 00:53:28,080
data constructor and you are

806
00:53:28,450 --> 00:53:32,122
making a new data type, a new row bytes

807
00:53:32,186 --> 00:53:35,890
data type. We are creating an array

808
00:53:36,630 --> 00:53:40,658
with empty values with zeros. Then we

809
00:53:40,744 --> 00:53:44,626
send to sec random copy bytes with

810
00:53:44,728 --> 00:53:48,178
the property ksec random default.

811
00:53:48,354 --> 00:53:51,634
Then the count bytes bytes

812
00:53:51,762 --> 00:53:55,414
we desire and then the reference with

813
00:53:55,452 --> 00:53:58,502
the ampersand of random bytes.

814
00:53:58,646 --> 00:54:02,858
Then sec random copy bytes returns in

815
00:54:02,944 --> 00:54:06,726
random bytes. The strong, the cryptoker,

816
00:54:06,758 --> 00:54:09,990
the cryptographically strong random number.

817
00:54:10,080 --> 00:54:15,054
Okay, it's so easy to make with

818
00:54:15,092 --> 00:54:19,018
this we can use data encryption.

819
00:54:19,114 --> 00:54:23,090
For example, when you have to store

820
00:54:23,240 --> 00:54:26,674
a password, you must store not in

821
00:54:26,712 --> 00:54:30,530
plain text, please, you must store

822
00:54:30,680 --> 00:54:32,450
in hash.

823
00:54:34,970 --> 00:54:38,598
With a password hashing, even the

824
00:54:38,684 --> 00:54:42,630
best way to do it is with hmac

825
00:54:42,970 --> 00:54:48,470
256 algorithm,

826
00:54:48,630 --> 00:54:52,054
okay, hmac, what is hmac?

827
00:54:52,102 --> 00:54:55,382
It's an algorithm that uses a key to ensure

828
00:54:55,526 --> 00:54:59,514
that hashes are not repeated in their

829
00:54:59,552 --> 00:55:02,942
calculation. For the same data. One of the

830
00:55:02,996 --> 00:55:06,542
most important problems when you calculate a hash is

831
00:55:06,596 --> 00:55:09,770
the collision, okay? When you have a collision

832
00:55:09,850 --> 00:55:13,458
in a hash calculation, it means you have two

833
00:55:13,544 --> 00:55:17,086
different data that has the same hash,

834
00:55:17,198 --> 00:55:21,042
okay. And that it's a great problem to

835
00:55:21,096 --> 00:55:23,780
try to resolve this.

836
00:55:24,550 --> 00:55:28,054
HMac put a key when

837
00:55:28,092 --> 00:55:31,734
you calculate the hash. Because of this, if you

838
00:55:31,772 --> 00:55:35,778
don't have the key, you cannot

839
00:55:35,874 --> 00:55:39,114
check the data. You cannot create the

840
00:55:39,152 --> 00:55:41,818
same hash for the same data.

841
00:55:41,904 --> 00:55:45,910
Because for validate a hash,

842
00:55:46,070 --> 00:55:49,722
you must have the data and

843
00:55:49,776 --> 00:55:53,950
the equivalent and the key we use to create this

844
00:55:54,020 --> 00:55:57,854
hash. Okay, how can

845
00:55:57,892 --> 00:56:01,738
you do it? Okay, using cryptokit,

846
00:56:01,914 --> 00:56:05,300
this iOS the easiest way

847
00:56:07,110 --> 00:56:10,658
you received a key, a key

848
00:56:10,824 --> 00:56:17,606
that can be a

849
00:56:17,628 --> 00:56:21,622
cryptographically strong random number. We create

850
00:56:21,756 --> 00:56:25,622
in the path before, okay, we use

851
00:56:25,676 --> 00:56:29,002
this number and then we send us a key,

852
00:56:29,136 --> 00:56:32,534
okay, with this cryptokit

853
00:56:32,582 --> 00:56:35,722
creates with the data a symmetric key.

854
00:56:35,856 --> 00:56:41,310
And then with hMAC 256

855
00:56:41,460 --> 00:56:46,618
dot authentication code, we obtain

856
00:56:46,794 --> 00:56:50,746
the hash for a string

857
00:56:50,938 --> 00:56:55,700
using the key, okay. And then because

858
00:56:56,310 --> 00:56:59,634
a code authentication code returns an

859
00:56:59,672 --> 00:57:02,514
array of using eight,

860
00:57:02,712 --> 00:57:06,898
then we are returning in the constructor

861
00:57:06,994 --> 00:57:11,014
of data, okay. Then this data

862
00:57:11,132 --> 00:57:15,238
can convert to, for example, a base

863
00:57:15,324 --> 00:57:17,720
64 string. For example,

864
00:57:19,790 --> 00:57:23,594
how can you use this function,

865
00:57:23,712 --> 00:57:27,850
okay, in this way? It's so simple.

866
00:57:28,000 --> 00:57:33,340
Random key generator of 2048.

867
00:57:34,510 --> 00:57:38,910
Then H Mac 256 ck

868
00:57:39,730 --> 00:57:43,614
string and the key and then obtain

869
00:57:43,662 --> 00:57:46,690
the base 64 encoded string.

870
00:57:47,670 --> 00:57:51,506
Then this base 64 encoded string is

871
00:57:51,608 --> 00:57:55,294
the value you must to store.

872
00:57:55,432 --> 00:58:00,070
Okay, then how can you validate

873
00:58:00,730 --> 00:58:04,198
a password? Okay, the validation of

874
00:58:04,284 --> 00:58:08,110
a hash is to convert

875
00:58:08,290 --> 00:58:10,890
the plain text password,

876
00:58:11,390 --> 00:58:14,780
making the hash again with the sync key.

877
00:58:15,150 --> 00:58:18,938
And then you compared the

878
00:58:19,104 --> 00:58:21,982
encrypted hash with the new one.

879
00:58:22,116 --> 00:58:26,138
And if it's the same, it's the same password.

880
00:58:26,234 --> 00:58:29,534
Okay, why we

881
00:58:29,572 --> 00:58:33,550
use hash? Because hash is an algorithm

882
00:58:33,710 --> 00:58:37,540
that avoid to make

883
00:58:39,350 --> 00:58:43,650
the transformation, the decryption of the data.

884
00:58:43,800 --> 00:58:47,800
When you have the hash, it's impossible to

885
00:58:50,730 --> 00:58:54,454
know the data we are

886
00:58:54,492 --> 00:58:58,140
hashing. Okay, this is the security

887
00:58:58,910 --> 00:59:03,146
way to ensure this

888
00:59:03,248 --> 00:59:07,514
feature. Okay, when you want to validate an

889
00:59:07,552 --> 00:59:10,874
authentication code for hash, the only thing you need

890
00:59:10,912 --> 00:59:14,638
is to make HMAC SH 256

891
00:59:14,724 --> 00:59:18,606
iOS validated authentication code. And then when

892
00:59:18,628 --> 00:59:22,158
you put in authenticating the plain text

893
00:59:22,244 --> 00:59:26,222
password that the user introduces with

894
00:59:26,276 --> 00:59:30,726
this, you are comparing the HK

895
00:59:30,858 --> 00:59:35,022
that is the hash with the value in plain text in

896
00:59:35,096 --> 00:59:38,534
Cadena, okay. And then using the

897
00:59:38,572 --> 00:59:42,082
key, the key for validate

898
00:59:42,146 --> 00:59:44,200
the hash. Okay, it's so easy.

899
00:59:45,690 --> 00:59:49,318
Next step, we are trying to make encryption,

900
00:59:49,414 --> 00:59:53,738
okay. AES 2056

901
00:59:53,904 --> 00:59:56,010
GCM encryption.

902
00:59:56,750 --> 01:00:00,826
The AA. The AES GCM

903
01:00:00,938 --> 01:00:04,030
is a galua code code.

904
01:00:04,850 --> 01:00:08,174
It's a cipher mode that is one of the

905
01:00:08,212 --> 01:00:11,390
most widely used for its performance and

906
01:00:11,460 --> 01:00:15,582
efficiency and it's recommended by Apple. It requires

907
01:00:15,726 --> 01:00:19,554
two keys, a cryptographic key

908
01:00:19,752 --> 01:00:23,762
as well as an encryption authentication data.

909
01:00:23,896 --> 01:00:28,114
You need two values to make this encryption.

910
01:00:28,242 --> 01:00:31,798
If we do not have both values, we cannot decrypt the

911
01:00:31,804 --> 01:00:35,478
content. Okay. The operation is an

912
01:00:35,564 --> 01:00:39,900
authenticated encryption algorithm designed to provide both

913
01:00:40,270 --> 01:00:43,498
data authenticity, the integrity of the data

914
01:00:43,664 --> 01:00:46,650
and the confidentiality. Okay.

915
01:00:46,800 --> 01:00:49,290
Makes these things altogether.

916
01:00:49,970 --> 01:00:54,762
GCM can take full advantage of parallel processing

917
01:00:54,906 --> 01:00:58,622
if we have many threads. The algorithm use these

918
01:00:58,676 --> 01:01:02,870
many threads and implementing GCM can make efficient

919
01:01:02,970 --> 01:01:06,734
use of an instruction pipeline, of a hardware

920
01:01:06,782 --> 01:01:10,402
pipeline. For example, when you have many threads and have

921
01:01:10,536 --> 01:01:14,562
an encryption engine like an M one

922
01:01:14,616 --> 01:01:16,840
for example, okay,

923
01:01:17,610 --> 01:01:22,310
how can I do it? It's so easy. With cryptokit

924
01:01:22,970 --> 01:01:26,470
you have to create a sealed box.

925
01:01:26,620 --> 01:01:30,890
Okay, with try you are using AES

926
01:01:31,630 --> 01:01:35,498
GCM seal and in

927
01:01:35,664 --> 01:01:39,754
this seal you have to provide the

928
01:01:39,792 --> 01:01:43,966
data you want to encrypt, the key

929
01:01:44,068 --> 01:01:47,710
you are using and the authenticating

930
01:01:48,130 --> 01:01:51,358
data. Okay. With this

931
01:01:51,524 --> 01:01:55,634
you obtain a sealed box and

932
01:01:55,672 --> 01:01:58,306
when you access to combined property,

933
01:01:58,488 --> 01:02:02,690
you can extract an

934
01:02:02,760 --> 01:02:05,170
encrypted string.

935
01:02:05,770 --> 01:02:09,142
You can storage on

936
01:02:09,196 --> 01:02:12,200
base 64 for example. Okay,

937
01:02:12,810 --> 01:02:15,240
how can I decrypt this?

938
01:02:15,850 --> 01:02:19,954
Making the same. But in this time you are creating

939
01:02:20,002 --> 01:02:25,238
a celebrate box. Okay. With AasgCM

940
01:02:25,414 --> 01:02:28,826
you use the

941
01:02:28,848 --> 01:02:31,954
initialization initialize

942
01:02:32,022 --> 01:02:35,934
function sealed box with the combined data

943
01:02:36,132 --> 01:02:40,542
you are storage before. With this combined data

944
01:02:40,676 --> 01:02:44,594
you are creating a new sealed box and

945
01:02:44,632 --> 01:02:48,466
then you can open providing it

946
01:02:48,648 --> 01:02:52,894
the sealed box, the key and the authentication,

947
01:02:53,022 --> 01:02:57,154
and then it returns the data decrypted.

948
01:02:57,282 --> 01:03:00,886
This data you can convert with

949
01:03:00,988 --> 01:03:05,062
string, for example, string data with

950
01:03:05,196 --> 01:03:08,906
the data that returns this function.

951
01:03:09,088 --> 01:03:14,118
And in UTF

952
01:03:14,214 --> 01:03:18,906
eight, okay. And with this you can see

953
01:03:19,008 --> 01:03:22,270
the new data decrypted. Okay. It's so easy,

954
01:03:22,420 --> 01:03:23,840
it's not hard.

955
01:03:28,740 --> 01:03:32,368
Next step, swiftui code security

956
01:03:32,534 --> 01:03:36,596
best practices one

957
01:03:36,618 --> 01:03:41,172
of the things we are so

958
01:03:41,226 --> 01:03:46,052
important is to try

959
01:03:46,186 --> 01:03:50,488
not to show any sensitive data when your app goes

960
01:03:50,574 --> 01:03:53,624
to background. Because of this,

961
01:03:53,822 --> 01:03:57,384
the app makes a screenshot of the last screen it

962
01:03:57,422 --> 01:04:01,884
showed and then your

963
01:04:01,922 --> 01:04:06,108
application the screens when you buy

964
01:04:06,194 --> 01:04:09,644
from one application to another. In this screenshot you

965
01:04:09,682 --> 01:04:13,810
can see maybe any sensitive data.

966
01:04:14,420 --> 01:04:18,252
Well, this could result in an unintentional capture

967
01:04:18,316 --> 01:04:21,760
of sensitive data and we have to do some process

968
01:04:21,830 --> 01:04:24,768
to control it. What process?

969
01:04:24,854 --> 01:04:28,196
For example, if you use SwiftuI, you have a new

970
01:04:28,218 --> 01:04:32,292
modifier, privacy sensitive you

971
01:04:32,346 --> 01:04:36,004
can put in any view. If you put

972
01:04:36,042 --> 01:04:39,704
this modifier, when you put the app

973
01:04:39,742 --> 01:04:43,304
in background, this data will be

974
01:04:43,342 --> 01:04:47,572
blurred and the user

975
01:04:47,636 --> 01:04:51,196
cannot see. It's so simple. But when

976
01:04:51,218 --> 01:04:54,764
you use another framework or maybe if

977
01:04:54,802 --> 01:04:58,280
you use SwiftuI or even UI kit

978
01:04:58,440 --> 01:05:02,732
we can capture system notifications. Okay, you can capture

979
01:05:02,796 --> 01:05:07,196
the system notification UI application will resign active notification

980
01:05:07,388 --> 01:05:11,152
and did become active notification will resign iOS

981
01:05:11,206 --> 01:05:15,344
when the app goes to background and did become active

982
01:05:15,392 --> 01:05:18,976
is when the app is going foreground.

983
01:05:19,168 --> 01:05:24,132
Well with this you can use this code you

984
01:05:24,186 --> 01:05:27,812
make an observer to UI application will resign

985
01:05:27,876 --> 01:05:31,252
active notification in the main queue

986
01:05:31,396 --> 01:05:35,192
and then creates a black view controller and then

987
01:05:35,326 --> 01:05:40,760
put it on your present

988
01:05:40,830 --> 01:05:44,284
it in the root view controller. Okay?

989
01:05:44,402 --> 01:05:48,270
With this you can create

990
01:05:51,440 --> 01:05:55,104
a UIB control that puts in

991
01:05:55,142 --> 01:05:58,944
front of your screen at the moment you

992
01:05:58,982 --> 01:06:03,424
are entered to background. Your app will your

993
01:06:03,542 --> 01:06:06,710
app screenshot will see blank. Okay,

994
01:06:07,320 --> 01:06:11,392
how can you dismiss this blank

995
01:06:11,536 --> 01:06:15,444
interface? Okay, capturing another

996
01:06:15,562 --> 01:06:18,280
notification it become active notification.

997
01:06:18,620 --> 01:06:22,436
In this you make UI application shared Windows first root

998
01:06:22,468 --> 01:06:26,040
view controller dismiss and then the

999
01:06:26,190 --> 01:06:29,884
black view controller dismiss it. And then you

1000
01:06:29,922 --> 01:06:33,400
can see the app when you enter infogram

1001
01:06:33,480 --> 01:06:36,030
again. Okay, that's so easy.

1002
01:06:37,760 --> 01:06:41,192
Another thing is to avoid backup copies of key files.

1003
01:06:41,256 --> 01:06:45,024
An iTunes backup, for example, can allow access to files in a very

1004
01:06:45,062 --> 01:06:48,690
simple way. Okay, since iOS eight

1005
01:06:49,060 --> 01:06:53,200
three, Apple does not allow access to the sandboxing.

1006
01:06:53,860 --> 01:06:57,524
But if you make or someone

1007
01:06:57,642 --> 01:07:01,092
makes an unencrypted backup in itunes of your

1008
01:07:01,146 --> 01:07:01,860
devices,

1009
01:07:05,480 --> 01:07:09,336
they code to extract data, compromise your

1010
01:07:09,518 --> 01:07:13,076
security or your privacy. We have to configure

1011
01:07:13,108 --> 01:07:16,170
the resource of the URL file itself.

1012
01:07:17,980 --> 01:07:23,628
In this way you prevent that

1013
01:07:23,714 --> 01:07:28,040
a file will be included in iTunes

1014
01:07:28,200 --> 01:07:31,988
backup. Okay. Or maybe iCloud.

1015
01:07:32,184 --> 01:07:35,664
It's important to remember that except jailbreak, the only

1016
01:07:35,702 --> 01:07:39,712
way to explore the file system on an iOS device is

1017
01:07:39,766 --> 01:07:42,960
through an iTunes and encrypted backup.

1018
01:07:43,300 --> 01:07:47,716
We should never trust any device that

1019
01:07:47,738 --> 01:07:51,156
is not ours when it show us

1020
01:07:51,258 --> 01:07:54,420
the alert to trust in this device.

1021
01:07:54,920 --> 01:07:58,104
How can I do it? Okay, it's so

1022
01:07:58,142 --> 01:08:02,472
easy. You have to modify the values of the URL type by

1023
01:08:02,526 --> 01:08:06,232
adding a URL resource value object like

1024
01:08:06,286 --> 01:08:09,444
this. If I want to write

1025
01:08:09,582 --> 01:08:14,156
a data one TxT, you have to

1026
01:08:14,338 --> 01:08:17,852
config URL resource value is

1027
01:08:17,906 --> 01:08:21,148
excluded from backup. True. And then set

1028
01:08:21,234 --> 01:08:24,832
resource value with this your

1029
01:08:24,966 --> 01:08:29,308
data one TXT are not included

1030
01:08:29,404 --> 01:08:33,244
in your iTunes backup or in your iCloud

1031
01:08:33,292 --> 01:08:40,452
backup. Final conclusions as

1032
01:08:40,506 --> 01:08:44,372
developers, okay, we are always

1033
01:08:44,506 --> 01:08:48,840
behind the system. We have the responsibility with

1034
01:08:48,910 --> 01:08:51,640
great power code, great responsibility.

1035
01:08:52,220 --> 01:08:56,276
As you know, if it is vulnerable,

1036
01:08:56,388 --> 01:09:00,124
so is our app. But doing our

1037
01:09:00,162 --> 01:09:03,640
job well is a guarantee for our users.

1038
01:09:03,720 --> 01:09:07,500
Okay? Everything we have said

1039
01:09:07,650 --> 01:09:11,692
should be a lawyer. That is part of your day

1040
01:09:11,746 --> 01:09:15,440
to day part of your development routine.

1041
01:09:16,500 --> 01:09:19,900
Make your APIs, make your helper

1042
01:09:19,980 --> 01:09:24,912
functions, make all the things you need to secure

1043
01:09:24,976 --> 01:09:28,304
your application. Make a swift package,

1044
01:09:28,352 --> 01:09:32,480
for example, and use it in all your apps

1045
01:09:32,640 --> 01:09:36,324
to ensure you make the

1046
01:09:36,362 --> 01:09:40,328
best secure coding in iOS or

1047
01:09:40,414 --> 01:09:42,680
other Apple systems.

1048
01:09:43,420 --> 01:09:47,352
Being responsible for security, data and good

1049
01:09:47,486 --> 01:09:51,720
development practice will make our developments

1050
01:09:51,880 --> 01:09:53,980
better and more efficient.

1051
01:09:55,120 --> 01:09:59,576
And don't

1052
01:09:59,608 --> 01:10:03,020
forget to update any third party libraries

1053
01:10:03,180 --> 01:10:07,232
you use. But maybe

1054
01:10:07,286 --> 01:10:11,520
it's better not to use it. Maybe a better option

1055
01:10:11,670 --> 01:10:15,536
if you can iOS try to go completely native

1056
01:10:15,648 --> 01:10:19,844
because many times and don't forget this,

1057
01:10:20,042 --> 01:10:23,796
we don't know who is behind a

1058
01:10:23,818 --> 01:10:27,716
third party library and we are relying

1059
01:10:27,828 --> 01:10:31,960
on their good faith and

1060
01:10:32,030 --> 01:10:35,560
good security practice blindly.

1061
01:10:38,300 --> 01:10:40,430
That's not a good option.

1062
01:10:41,280 --> 01:10:44,350
Remember, don't trust anyone,

1063
01:10:45,440 --> 01:10:48,776
okay? And that's

1064
01:10:48,808 --> 01:10:52,464
it. Thank you so much. I hope

1065
01:10:52,582 --> 01:10:56,704
you like this talk and I hope

1066
01:10:56,822 --> 01:11:00,096
you are now you

1067
01:11:00,118 --> 01:11:04,144
know kung fu in security

1068
01:11:04,342 --> 01:11:07,952
and then your code will

1069
01:11:08,006 --> 01:11:12,012
be more secure. Thanks to conf

1070
01:11:12,076 --> 01:11:15,712
42 for the opportunity to make this

1071
01:11:15,846 --> 01:11:18,984
talk and as I said,

1072
01:11:19,102 --> 01:11:23,048
always in my podcast and

1073
01:11:23,214 --> 01:11:24,520
live streams.

1074
01:11:26,220 --> 01:11:29,860
Best regards and good apple coding.

