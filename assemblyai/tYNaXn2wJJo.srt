1
00:00:17,530 --> 00:00:20,990
Welcome to MongoDB. Schema design best practices.

2
00:00:21,650 --> 00:00:23,200
Let's jump in here.

3
00:00:24,530 --> 00:00:28,054
Oh, okay. Just got to click. There we go. Okay, so first

4
00:00:28,092 --> 00:00:31,558
of all, why is schema design so important when you're working on a

5
00:00:31,564 --> 00:00:35,222
database? Well, did you know that it's one of the most

6
00:00:35,276 --> 00:00:39,390
critical parts about improving performance and stability of any database?

7
00:00:39,490 --> 00:00:43,034
This is especially true, though, for MongoDB and just

8
00:00:43,072 --> 00:00:47,034
a personal opinion, it's one of the things that people get wrong

9
00:00:47,152 --> 00:00:50,842
the most when they're setting up a MongoDB database. All right,

10
00:00:50,976 --> 00:00:54,030
cool. Well, we're going to jump more into that. Don't worry.

11
00:00:54,370 --> 00:00:57,598
So, my name is Joe Carlson. I work for a

12
00:00:57,604 --> 00:01:00,654
company called MongoDB and I'm a developer, advocate and

13
00:01:00,692 --> 00:01:04,606
software engineer. If you're at all interested in hanging out with me at

14
00:01:04,628 --> 00:01:08,146
all ever again, you can totally hit me up on here. Twitter is the best

15
00:01:08,168 --> 00:01:11,426
place to get a hold of me. And if you

16
00:01:11,448 --> 00:01:14,180
want any of the links, video,

17
00:01:14,550 --> 00:01:17,874
resources, slides, anything, you can find that at that

18
00:01:17,912 --> 00:01:21,158
link below. Or anytime you see a QR code that will take

19
00:01:21,164 --> 00:01:24,600
you to a page that shows you all of the resources for this talk.

20
00:01:26,010 --> 00:01:29,526
And, oh, I didn't even say this here. So also, opinions are

21
00:01:29,548 --> 00:01:32,630
my own. If I say anything weird, just know that I'm going to be putting

22
00:01:32,700 --> 00:01:35,420
lots of my own personal opinions in this talk.

23
00:01:35,870 --> 00:01:38,506
All right, so what are we going to be talking about today? Well, first of

24
00:01:38,528 --> 00:01:42,170
all, we're going to be talking about traditional relational

25
00:01:42,250 --> 00:01:45,834
SQL type databases and comparing those to MongoDB

26
00:01:45,882 --> 00:01:49,498
databases and particularly from a schema

27
00:01:49,514 --> 00:01:52,910
design approach. Next thing we'll be discussing today is

28
00:01:52,980 --> 00:01:56,594
embedding versus referencing. What's the differences? And these are the two key

29
00:01:56,632 --> 00:02:00,450
ways of organizing a schema with a MongoDB database.

30
00:02:00,870 --> 00:02:04,574
And lastly, we're going to be discussing lots of different types of database

31
00:02:04,622 --> 00:02:07,966
relationships and how to model those in MongoDB.

32
00:02:08,078 --> 00:02:11,362
We're not going to cover all of them today, but this is an introductory

33
00:02:11,426 --> 00:02:14,870
course to designing a schema. All right,

34
00:02:14,940 --> 00:02:18,662
cool. So first off, relational versus

35
00:02:18,726 --> 00:02:20,380
MongoDB schema design.

36
00:02:21,790 --> 00:02:25,834
The thing I see the most when people

37
00:02:25,872 --> 00:02:30,006
are coming from an SQL background to MongoDB is they

38
00:02:30,128 --> 00:02:34,186
are designing their MongoDB schemas like they would with their traditional SQL

39
00:02:34,218 --> 00:02:38,666
database. Most developer advocate

40
00:02:38,698 --> 00:02:41,934
see a difference and a lot of times

41
00:02:41,972 --> 00:02:46,066
I see like, hey Joe, why is my schema performing badly or my database is

42
00:02:46,088 --> 00:02:50,818
getting slow? It's because they're designing their schemas in

43
00:02:50,904 --> 00:02:54,034
the old way or in the SQL way.

44
00:02:54,072 --> 00:02:57,720
Right. And that can lead to some performance issues in the future.

45
00:02:58,810 --> 00:03:02,326
This is my reaction. Anyone comes to me

46
00:03:02,428 --> 00:03:06,114
with this type of databases. Okay, so relational

47
00:03:06,242 --> 00:03:09,366
schema design, what does that look like? So if

48
00:03:09,388 --> 00:03:12,902
you're in charge of an SQL database and you're designing a schema for that relational

49
00:03:12,966 --> 00:03:16,406
database, what you're going to be doing is designing

50
00:03:16,438 --> 00:03:19,679
your schema independently of the queries you are going to

51
00:03:20,179 --> 00:03:23,950
be making with the application using that data set or database.

52
00:03:24,290 --> 00:03:27,710
The question most devs ask themselves when designing a schema for

53
00:03:27,780 --> 00:03:31,326
a relational database is, what data do

54
00:03:31,348 --> 00:03:33,700
I have? Did that go in there?

55
00:03:37,910 --> 00:03:42,046
Okay, so typically we have a very prescribed

56
00:03:42,078 --> 00:03:45,666
approach to doing that, and that's called normalization with a legacy SQL

57
00:03:45,698 --> 00:03:49,094
database. And typically we normalize to the third

58
00:03:49,132 --> 00:03:52,134
form. I think there's five forms. Four or five.

59
00:03:52,252 --> 00:03:56,280
But traditionally most developers are normalizing to the third form.

60
00:03:57,130 --> 00:04:00,554
So you don't have to know about normalization to understand this talk.

61
00:04:00,592 --> 00:04:04,566
But I just want to tell you that normalization means you're trying to dedup

62
00:04:04,598 --> 00:04:08,278
your data as much as possible by splitting it up into separate tables.

63
00:04:08,454 --> 00:04:12,094
Cool. So with a relational database, this is a

64
00:04:12,132 --> 00:04:15,898
typical user type normalization,

65
00:04:15,994 --> 00:04:19,326
right? You have like a user table and

66
00:04:19,428 --> 00:04:22,734
you might have other tables saving data, and you're linking that data

67
00:04:22,772 --> 00:04:26,114
together using foreign keys you see there in the professions and

68
00:04:26,152 --> 00:04:29,762
cars table. Both of those are using a user id foreign key

69
00:04:29,816 --> 00:04:31,490
to match that to the user.

70
00:04:33,030 --> 00:04:36,962
Okay, so those are the basics of SQL or

71
00:04:37,096 --> 00:04:39,480
relational database schema design.

72
00:04:40,970 --> 00:04:44,278
If you've never done it before, you're probably at least vaguely familiar that that's what

73
00:04:44,284 --> 00:04:47,838
that kind of looks like, right? Rows and columns linking together with foreign keys.

74
00:04:48,034 --> 00:04:51,926
Okay, great. So MongoDB

75
00:04:52,038 --> 00:04:55,434
schema design, how do we do that?

76
00:04:55,552 --> 00:04:58,938
Well, first of all, there's a couple of

77
00:04:58,944 --> 00:05:02,286
things I should tell you. There's no rules to it.

78
00:05:02,388 --> 00:05:05,930
And if you're used to coming from a relational databases,

79
00:05:06,090 --> 00:05:10,590
that's going to be kind of tricky. There's no process and

80
00:05:10,660 --> 00:05:13,758
there's no pre prescribed algorithm for how to split

81
00:05:13,774 --> 00:05:16,290
up that data. Holy cow.

82
00:05:16,790 --> 00:05:21,714
This can be freeing and kind of scary because

83
00:05:21,752 --> 00:05:25,026
there's no rules here. There's no rules. We got no rules in

84
00:05:25,048 --> 00:05:25,780
this house.

85
00:05:28,090 --> 00:05:31,000
So if there's no rules, what do we do? Well,

86
00:05:31,370 --> 00:05:35,378
schema design for MongoDB

87
00:05:35,474 --> 00:05:38,886
is based on the needs of your application.

88
00:05:39,068 --> 00:05:42,940
So instead of asking what data we have, we're asking how do we

89
00:05:43,310 --> 00:05:46,998
want to use this data? And there's

90
00:05:47,014 --> 00:05:50,506
a couple of things that we are mostly concerned about when we're designing our

91
00:05:50,528 --> 00:05:54,606
MongoDB schema. The first thing is we're wondered with how

92
00:05:54,628 --> 00:05:58,442
to store that data. Duh. Right. We're also concerned with the performance.

93
00:05:58,506 --> 00:06:04,126
Right. We want to make sure that we're querying and updating and

94
00:06:04,228 --> 00:06:07,460
maintaining the correct amount of performance that we need for our application.

95
00:06:07,990 --> 00:06:11,758
And we also want to make sure that we're not using ridiculous amount of hardware

96
00:06:11,854 --> 00:06:15,366
and spending way too much money. Right. No one wants to spend too much money.

97
00:06:15,388 --> 00:06:18,514
Our bosses don't, we don't. My side projects don't.

98
00:06:18,562 --> 00:06:23,010
Right. We want to try to minimize costs

99
00:06:23,170 --> 00:06:26,150
and optimize for performance.

100
00:06:27,450 --> 00:06:31,222
So let's say we have the same user table and

101
00:06:31,276 --> 00:06:34,758
we want to model the same exact data set in MongoDB.

102
00:06:34,854 --> 00:06:37,946
How would we do something like that? Well, if we were going to do this

103
00:06:37,968 --> 00:06:41,774
with MongoDB, we would of course be using MongoDB documents and

104
00:06:41,812 --> 00:06:45,354
a lot of things. Stuff. We would just be using keys

105
00:06:45,402 --> 00:06:48,894
and values, right.

106
00:06:48,932 --> 00:06:52,426
We just save that stuff as key value pairs, first name, last name, surname,

107
00:06:52,458 --> 00:06:56,026
cell, whatever, location, whatever. Right. We're just saving as key value pairs.

108
00:06:56,058 --> 00:06:59,346
But those other tables were saving more data. We might need to do

109
00:06:59,368 --> 00:07:02,562
something a little bit differently. Right, because key values are one to one.

110
00:07:02,696 --> 00:07:06,018
But if we have that professions and cars data, we need

111
00:07:06,024 --> 00:07:09,290
to keep track of, and the user can have multiple professions and multiple cars,

112
00:07:09,390 --> 00:07:12,502
we need to model that data a little bit differently. And of course,

113
00:07:12,556 --> 00:07:16,066
MongoDB documents, we can save that like we would with any JSON document

114
00:07:16,098 --> 00:07:20,170
with any nesting, with keys or with objects or with

115
00:07:20,240 --> 00:07:23,834
arrays. So if we had our professions table and

116
00:07:23,872 --> 00:07:28,166
a user could have two or more professions,

117
00:07:28,278 --> 00:07:31,046
I'd probably just save that as an array, right? We could just have an array

118
00:07:31,078 --> 00:07:34,398
of professions we could embed there. So that would show that a user would have

119
00:07:34,404 --> 00:07:38,382
more than one profession or cars. Right. Cars have

120
00:07:38,436 --> 00:07:41,774
multiple data. Now we have the model and year we also need to keep track

121
00:07:41,812 --> 00:07:45,620
of that makes sense to have an array of objects to track that data with.

122
00:07:46,710 --> 00:07:49,460
My indentation got a little bit weird there, but you know what I'm saying.

123
00:07:50,150 --> 00:07:53,890
Okay, cool. So not too bad. Let's do a quick recap here.

124
00:07:53,960 --> 00:07:57,570
So first thing we started talking about was starting from a base

125
00:07:57,640 --> 00:08:00,838
of relational schema design. I think a lot of us are coming from that way

126
00:08:00,924 --> 00:08:03,606
and trying to understand how to do that. I think it's a helpful place to

127
00:08:03,628 --> 00:08:07,494
start. So we discussed relational schema design, and we

128
00:08:07,532 --> 00:08:11,026
discussed how we traditionally model our data using

129
00:08:11,068 --> 00:08:14,698
a normalization, and we're modeling our data independent of the queries we

130
00:08:14,704 --> 00:08:18,726
need to actually be making. We are then also normalizing

131
00:08:18,758 --> 00:08:21,034
in the third form. Right. We talked about the rows and columns we have.

132
00:08:21,072 --> 00:08:24,240
And then we discussed MongodB schema design.

133
00:08:24,610 --> 00:08:28,186
Remember, there's no rules, no process, and no pre prescribed algorithm

134
00:08:28,218 --> 00:08:31,678
for how to actually do that. The things that we're most concerned with when we're

135
00:08:31,684 --> 00:08:35,630
designing our schema is how we're actually saving that data and query performance.

136
00:08:35,710 --> 00:08:38,450
And of course we don't want to use too much hardware.

137
00:08:39,910 --> 00:08:43,278
The most important thing you can ever remember when you're designing

138
00:08:43,294 --> 00:08:46,766
a schema is you're going to be designing

139
00:08:46,798 --> 00:08:50,326
your schema based on the needs of your application. And every application is

140
00:08:50,348 --> 00:08:53,766
different and uses data differently. So we're looking at exactly what

141
00:08:53,788 --> 00:08:57,410
your database needs and how your application is going to be using that data

142
00:08:57,500 --> 00:09:00,730
or modeling our data to optimize for query performance.

143
00:09:01,550 --> 00:09:05,206
And the two ways that we do that are through embedding

144
00:09:05,238 --> 00:09:09,914
and referencing in MongoDB. So let's discuss what

145
00:09:09,952 --> 00:09:13,310
each of them are and then we'll be discussing when to use each of them.

146
00:09:13,460 --> 00:09:17,150
So embedding, of course,

147
00:09:17,220 --> 00:09:20,910
refers to actually embedding that data within our

148
00:09:20,980 --> 00:09:24,922
object, right? We can deeply nest arrays,

149
00:09:24,986 --> 00:09:28,706
objects, keys, whatever in any structure that makes sense for us, but we can

150
00:09:28,728 --> 00:09:30,930
embed that directly in the document.

151
00:09:31,590 --> 00:09:35,102
Referencing you might recall too, from is similar

152
00:09:35,176 --> 00:09:38,870
to a join that we make with foreign keys on

153
00:09:38,940 --> 00:09:42,866
a legacy SQL relationships database.

154
00:09:43,058 --> 00:09:46,930
So we're not embedding that data directly in there, we're actually referencing

155
00:09:47,010 --> 00:09:50,710
based on keys to make queries that pull together from separate documents

156
00:09:50,790 --> 00:09:54,214
or collections. So embedding,

157
00:09:54,262 --> 00:09:57,558
why would we want to use embedding? Well, if we're

158
00:09:57,574 --> 00:10:00,858
able to embed that document, all that data in a single document, we can

159
00:10:00,864 --> 00:10:03,694
get that with a single query. If all the data we need is in one

160
00:10:03,732 --> 00:10:05,710
place, we don't have to do any joins.

161
00:10:07,010 --> 00:10:10,154
Joins, and if you do not know, joins are very expensive.

162
00:10:10,202 --> 00:10:13,246
It's a blocking operation. They tend to be time consuming and what

163
00:10:13,348 --> 00:10:16,674
the compiler is doing or the database, when you're making

164
00:10:16,712 --> 00:10:20,494
a join in a legacy SQL database is they are bringing

165
00:10:20,542 --> 00:10:24,082
all that data together in memory and then doing a filter or search

166
00:10:24,136 --> 00:10:27,314
on that data once it's been joined in memory. This is time consuming,

167
00:10:27,362 --> 00:10:31,202
expensive, and if you have huge data sets, this can use up an enormous

168
00:10:31,266 --> 00:10:35,640
amount of energy or like computing power in order to get this data.

169
00:10:37,050 --> 00:10:40,518
Also, by default, update operations

170
00:10:40,614 --> 00:10:45,450
in MongoDB are atomic. If you're updating on a single document,

171
00:10:45,870 --> 00:10:49,590
you can have atomic asset compliant considerations

172
00:10:49,670 --> 00:10:53,034
for multiple documents, which we'll discuss later as well. Okay,

173
00:10:53,072 --> 00:10:55,840
so embedding, what are some cons? Well,

174
00:10:56,930 --> 00:10:59,838
if you're embedding all of your data within a document, that could be a lot

175
00:10:59,844 --> 00:11:03,342
of overhead. And sending lots of data over the wire every single time

176
00:11:03,396 --> 00:11:06,974
could be overkill. So the question you should be asking yourself is, do I

177
00:11:07,012 --> 00:11:10,754
actually need all this data to be embedded within my document or not? And if

178
00:11:10,792 --> 00:11:13,780
not, you might need to actually reference, which we'll talk about in a second.

179
00:11:14,230 --> 00:11:17,442
Also, there is a 16 megabyte document limit

180
00:11:17,506 --> 00:11:20,834
per MongoDB document, right? So you cannot

181
00:11:20,882 --> 00:11:24,550
exceed 16 megabytes per document in MongoDB.

182
00:11:25,690 --> 00:11:29,762
And again, if you're getting that close, probably time to start thinking about maybe referencing.

183
00:11:29,826 --> 00:11:32,294
I get asked that all the time, like, hey Joe, my documents are huge.

184
00:11:32,332 --> 00:11:35,914
What do I do? It's like, well, that's a code smell in MongoDB. We probably

185
00:11:35,952 --> 00:11:40,106
want to look at how we can split that data up and reference it in

186
00:11:40,128 --> 00:11:44,010
other documents. Okay, so what about referencing,

187
00:11:44,090 --> 00:11:47,338
right? Just like you can do a join but using foreign keys,

188
00:11:47,354 --> 00:11:50,926
you can do the same thing. In MongoDB. Traditionally we use

189
00:11:50,948 --> 00:11:54,574
a unique identifier or the object id, and we can

190
00:11:54,612 --> 00:11:57,906
do queries that do joins for us, right? Just like you can

191
00:11:57,928 --> 00:12:01,326
with a join in a SQL statement. We're splitting

192
00:12:01,358 --> 00:12:05,266
that data up into separate documents and doing joins on our queries, updates or

193
00:12:05,288 --> 00:12:08,598
whatever our crud operations, right? So why would we want to

194
00:12:08,604 --> 00:12:12,278
use referencing over embedding? Of course we

195
00:12:12,284 --> 00:12:15,506
can start splitting up our documents and making those smaller. If you're hitting that 16

196
00:12:15,538 --> 00:12:19,290
megabyte limit, again, probably want to start referencing.

197
00:12:20,670 --> 00:12:24,374
And just like you would with a dedupe

198
00:12:24,422 --> 00:12:28,262
in normalization with a relational database,

199
00:12:28,326 --> 00:12:31,230
you're going to be deduping your data or reducing duplication.

200
00:12:31,890 --> 00:12:35,690
That's not to say that deduplication is an anti pattern,

201
00:12:35,770 --> 00:12:39,326
either in SQL or MongoDB databases. Don't be afraid of

202
00:12:39,348 --> 00:12:42,986
duplicating your data. A common way to increase

203
00:12:43,018 --> 00:12:46,366
performance with an SQL database is to denormalize,

204
00:12:46,478 --> 00:12:49,550
or that means starting to consolidate your joins

205
00:12:49,630 --> 00:12:53,458
in a single data or collection or table. So you

206
00:12:53,464 --> 00:12:57,270
don't have to be doing those expensive joins. It makes querying actually much faster.

207
00:12:57,850 --> 00:13:01,398
So it's not even a problem in SQL, right? Neither of

208
00:13:01,404 --> 00:13:05,080
them. Don't be afraid of deduplicating your data or duplicating your data,

209
00:13:08,490 --> 00:13:11,638
for example, too. If you have data that you're not accessing often or you don't

210
00:13:11,654 --> 00:13:15,226
need every single time you query that document, probably want to

211
00:13:15,408 --> 00:13:18,854
yank that off into a separate document and reference that with a reference

212
00:13:18,902 --> 00:13:22,154
id. Okay, so we got some cons now,

213
00:13:22,192 --> 00:13:25,486
right? So if you're referencing and you need to get that data. You will have

214
00:13:25,508 --> 00:13:29,146
to do joins or lookups in order to retrieve all that data, which can slow

215
00:13:29,178 --> 00:13:30,750
down your query performance.

216
00:13:32,290 --> 00:13:35,818
Okay, cool. So embedding and referencing, the two key ways of designing

217
00:13:35,834 --> 00:13:39,346
your schema, that's the building blocks. And the question you should be asking yourself is,

218
00:13:39,368 --> 00:13:43,518
should I embed this or should I reference it? So embedding

219
00:13:43,614 --> 00:13:47,134
is where you embed that data directly in your document.

220
00:13:47,182 --> 00:13:50,150
You do not need to have object id references to look up that data.

221
00:13:50,220 --> 00:13:55,878
All the data you need is in one place and

222
00:13:55,964 --> 00:13:58,190
makes it easy to look it up with a single query. You don't have to

223
00:13:58,200 --> 00:14:01,418
do any expensive joins and it updates everything with a single

224
00:14:01,584 --> 00:14:04,906
atomic operation. All right. On the flip side,

225
00:14:05,088 --> 00:14:08,598
it also can cause problems if you have large documents.

226
00:14:08,774 --> 00:14:12,202
And if you're hitting that 16 megabyte document limit, you need to make sure

227
00:14:12,256 --> 00:14:15,994
we're handling that, in which case you want to probably reference

228
00:14:16,042 --> 00:14:19,354
that with an object id. You're going to have smaller documents.

229
00:14:19,402 --> 00:14:22,606
You're less likely to hit that 16 megabyte limit, which we'll talk about. Maybe you

230
00:14:22,628 --> 00:14:25,886
could, still could, right? We're dedupling our data, which is

231
00:14:25,908 --> 00:14:29,566
not an anti pattern, but it is a consideration to make. And we

232
00:14:29,588 --> 00:14:31,886
don't have to have all the data every single time, right? If you don't need

233
00:14:31,908 --> 00:14:35,746
that data, let's not query it every single time. That's a waste of, of computing

234
00:14:35,778 --> 00:14:39,238
power, space, data transfer, over the

235
00:14:39,244 --> 00:14:41,590
wire, et cetera, et cetera.

236
00:14:43,210 --> 00:14:46,134
Okay, but if you are referencing, just note that you will have to be doing

237
00:14:46,172 --> 00:14:49,402
separate lookups in order to get that data, which is a consideration to make when

238
00:14:49,456 --> 00:14:52,886
you're considering performance of your database

239
00:14:52,918 --> 00:14:56,202
operations. Okay, so let's look at

240
00:14:56,256 --> 00:14:59,462
types of relationships you would see when designing a schema.

241
00:14:59,606 --> 00:15:03,782
I think it's helpful for us to start in a place where we are designing

242
00:15:03,846 --> 00:15:07,086
relationships like we would with a legacy SQL database, which again,

243
00:15:07,108 --> 00:15:09,406
I think a lot of us are. If you're not great, you don't have all

244
00:15:09,428 --> 00:15:12,766
that baggage, which is great. But it's still important to understand how

245
00:15:12,788 --> 00:15:16,162
these relationships work and how we can model them.

246
00:15:16,216 --> 00:15:19,522
In MongoDB, we're going to start with the most

247
00:15:19,576 --> 00:15:23,394
simple operations and move away up to more complicated, more interesting, in my

248
00:15:23,432 --> 00:15:27,106
opinion, more interesting schemas. So the first one we

249
00:15:27,128 --> 00:15:30,214
need to be aware of is one to one, right?

250
00:15:30,332 --> 00:15:33,394
DJ Khaled would definitely be a big fan of this one, right? We're just adding

251
00:15:33,442 --> 00:15:36,646
one single new piece of data to our

252
00:15:36,828 --> 00:15:39,974
document. One to one is really easy for us

253
00:15:40,012 --> 00:15:42,840
to create, right?

254
00:15:43,610 --> 00:15:46,822
It's just key value pairs, right? Nothing too complicated.

255
00:15:46,886 --> 00:15:50,140
If you have a single piece of data and a single

256
00:15:51,390 --> 00:15:54,858
option for that, using a one to one relationship with

257
00:15:54,864 --> 00:15:57,680
the key value pair is the way to go. Right.

258
00:15:58,610 --> 00:16:01,786
Just use key value pairs. Okay. So that one's

259
00:16:01,818 --> 00:16:05,838
pretty easy. But let's get to some more interesting stuff here. Right? We already previewed

260
00:16:05,854 --> 00:16:09,426
this one too. But the one to few, right? One to few would be

261
00:16:09,448 --> 00:16:13,250
modeled by perhaps doing an array, array of

262
00:16:13,320 --> 00:16:17,266
some sort of documents in there. All right, we have our

263
00:16:17,368 --> 00:16:20,774
data. All one to few means that you're not going to have

264
00:16:20,812 --> 00:16:23,894
mass amounts of them. So someone could have a couple of addresses, but someone probably

265
00:16:23,932 --> 00:16:27,846
doesn't have 16 megabytes of addresses, which might be like

266
00:16:28,028 --> 00:16:31,474
millions and millions of items

267
00:16:31,522 --> 00:16:34,986
in there, right? So those are pretty safe to put in there because

268
00:16:35,008 --> 00:16:37,466
it's probably not going to max anything out. So we're just going to embed that

269
00:16:37,488 --> 00:16:41,606
right in there. We're going to prefer it, right. There could be cases

270
00:16:41,638 --> 00:16:44,006
where you don't want to do that, especially if you're not going to be referencing

271
00:16:44,038 --> 00:16:48,522
that very often, or don't need it on every single call. But prefer embedding

272
00:16:48,586 --> 00:16:50,878
if you have only a couple of things you need to be tracking in a

273
00:16:50,884 --> 00:16:52,560
dish. Like more than one.

274
00:16:57,910 --> 00:17:01,586
I told you there was no rules before. Understand the

275
00:17:01,608 --> 00:17:05,646
irony of this, but I have a couple of personal rules

276
00:17:05,678 --> 00:17:08,902
I follow when designing a MongoDB schema for a data

277
00:17:08,956 --> 00:17:12,834
set or for an application. But I favor embedding.

278
00:17:12,962 --> 00:17:16,546
That's my first go to thing, unless I can articulate

279
00:17:16,578 --> 00:17:20,406
a reason why I do not want to embed it. So just

280
00:17:20,428 --> 00:17:22,586
your go to should be embedding. But if you say like, I don't need this

281
00:17:22,608 --> 00:17:25,786
every time, cool, that's a compelling reason. Or this is too huge,

282
00:17:25,888 --> 00:17:29,210
cool, that's a compelling reason. Let's pull that out and reference it.

283
00:17:29,280 --> 00:17:31,520
But prefer embedding if possible.

284
00:17:32,210 --> 00:17:35,886
Rule two, needing to access an object on

285
00:17:35,908 --> 00:17:39,040
its own is a compelling reason to embed it.

286
00:17:39,490 --> 00:17:42,718
So for example, it's addresses. If another piece, your application is just going to

287
00:17:42,724 --> 00:17:46,546
be using those addresses, even though that's a one to few, you might want

288
00:17:46,568 --> 00:17:50,420
to just split that off. That might be a good call for your application.

289
00:17:50,950 --> 00:17:54,514
That could increase performance and it could decrease the amount

290
00:17:54,552 --> 00:17:57,798
of data being transferred over for that separate query on a different part of

291
00:17:57,804 --> 00:18:00,946
your application. Okay, so let's

292
00:18:00,978 --> 00:18:04,418
move it on up one to many relationships.

293
00:18:04,514 --> 00:18:08,230
So let's say, for example, you're designing an application for

294
00:18:08,300 --> 00:18:11,586
a product and your product that you're keeping

295
00:18:11,618 --> 00:18:14,906
track of has lots of parts. So you want to keep track of what

296
00:18:14,928 --> 00:18:19,180
these products are and all the separate parts and components that make up this

297
00:18:19,630 --> 00:18:23,162
product that we're designing. Maybe we're manufacturing, maybe we're an ecommerce company,

298
00:18:23,216 --> 00:18:26,746
maybe we're doing supports and we need to understand the parts that we're supporting.

299
00:18:26,778 --> 00:18:30,106
Right. Whatever it is. But we have products, and products are made up of lots

300
00:18:30,138 --> 00:18:33,614
of parts, and we need to figure out how to design a schema for this

301
00:18:33,652 --> 00:18:38,526
things. So we have one product that has many parts

302
00:18:38,558 --> 00:18:40,420
to it. You see where I'm going with this?

303
00:18:41,350 --> 00:18:44,526
And potentially that bicycle could have thousands of parts,

304
00:18:44,558 --> 00:18:48,374
or if it's more complicated, like a car or a

305
00:18:48,412 --> 00:18:52,214
tractor or Xbox or something. Right. These could have

306
00:18:52,332 --> 00:18:56,360
thousands and thousands and thousands of parts. That's a many type relationship.

307
00:18:57,610 --> 00:19:01,226
So this is the first one we're going to actually start considering doing

308
00:19:01,328 --> 00:19:05,338
a reference. So we have our one product,

309
00:19:05,504 --> 00:19:09,494
and the product is made up of many parts in order to reduce

310
00:19:09,542 --> 00:19:12,922
the amount of parts that are like or

311
00:19:12,976 --> 00:19:16,810
the data that's being tracked in our product. What I'm doing is doing referencing

312
00:19:16,970 --> 00:19:20,254
for each of those parts, but I'm tracking each of those parts within the

313
00:19:20,292 --> 00:19:23,534
product. So the part can have lots of different things

314
00:19:23,572 --> 00:19:27,534
in there. Right. We have quantity, price, cost, name, product number,

315
00:19:27,572 --> 00:19:31,086
et cetera, et cetera. We probably don't need that in there. Also, if you're designing

316
00:19:31,118 --> 00:19:34,446
an application, let's say you're designing an ecommerce site and you're keeping

317
00:19:34,478 --> 00:19:38,360
track of your products and all the parts that make up that, chances are

318
00:19:39,130 --> 00:19:42,486
you're going to be using that product information much more often than

319
00:19:42,508 --> 00:19:46,582
the parts. Like parts would be. Something if someone needed support or wanted

320
00:19:46,636 --> 00:19:50,198
more information about what made up this product on your ecommerce store, you can

321
00:19:50,204 --> 00:19:53,434
make a separate query to go get that, but you probably don't need that every

322
00:19:53,472 --> 00:19:57,158
single time. So we've made a call here that we don't actually need the parts

323
00:19:57,174 --> 00:20:00,646
all that often, and we're worried about hitting that 16

324
00:20:00,678 --> 00:20:04,462
megabyte limit. So we want to start splitting that up to kind of help

325
00:20:04,516 --> 00:20:07,962
us mitigate the risk of going over that limit.

326
00:20:08,106 --> 00:20:12,506
But it still works, right? We're matching the ids

327
00:20:12,698 --> 00:20:16,750
from the product to the parts, and we can do that many, many times easily

328
00:20:16,830 --> 00:20:19,620
and making queries and crud operations for all of that.

329
00:20:20,470 --> 00:20:23,570
We're going to prefer referencing for this instead of embedding,

330
00:20:24,070 --> 00:20:28,230
especially if you're hitting thousands and thousands and thousands of sub things

331
00:20:28,300 --> 00:20:30,934
in there. Right? That'd be the many. Right. Okay,

332
00:20:31,052 --> 00:20:34,514
so rule three, I want you to avoid joins

333
00:20:34,562 --> 00:20:37,922
and lookups if they can, but joins

334
00:20:37,986 --> 00:20:41,542
are not an anti pattern. And if you have a better

335
00:20:41,596 --> 00:20:44,982
schema because you need includes a reference,

336
00:20:45,046 --> 00:20:48,746
go for it. Right. I prefer embedding, but if I can justify a

337
00:20:48,768 --> 00:20:52,650
reason to split it up and use joins and lookups,

338
00:20:52,730 --> 00:20:55,966
great, go for it. That's a great use case for your

339
00:20:55,988 --> 00:20:59,360
application. It depends entirely on what you are building.

340
00:21:01,570 --> 00:21:05,166
Now we're getting to some fun stuff here. One to squillions. So before with one

341
00:21:05,188 --> 00:21:08,580
to many, we're talking like one to maybe a couple thousand

342
00:21:09,030 --> 00:21:12,178
subparts in there and we're going to be referencing. But one to squillions is on

343
00:21:12,184 --> 00:21:16,274
another level. So let's imagine you're building an application for logs,

344
00:21:16,402 --> 00:21:21,282
right? And I'm not talking about timber

345
00:21:21,346 --> 00:21:25,094
logs here. I'm talking about like you are being tasked with

346
00:21:25,132 --> 00:21:29,026
building a log system for your server farm. And your server

347
00:21:29,058 --> 00:21:32,442
farm, if it's blowing up, might be generating thousands or

348
00:21:32,496 --> 00:21:35,498
potentially millions and millions and millions, especially over time. Right.

349
00:21:35,584 --> 00:21:39,226
Depends how verbose your logging system you're designing is.

350
00:21:39,248 --> 00:21:42,838
But you could have squillions.

351
00:21:42,934 --> 00:21:45,486
I know it's a made up word. I don't even know where that word comes

352
00:21:45,508 --> 00:21:49,422
from. But you could have potentially squillions of log

353
00:21:49,476 --> 00:21:52,894
files for this burning server farm you're building. So how

354
00:21:52,932 --> 00:21:56,286
do we build that? Because the problem we have

355
00:21:56,308 --> 00:21:59,538
here is that we could keep track of an array of object ids like we

356
00:21:59,544 --> 00:22:03,406
did with one to many. But an array file growing

357
00:22:03,438 --> 00:22:07,262
at the unbounded size, even if it's only tracking object ids,

358
00:22:07,326 --> 00:22:10,646
could potentially run out your 16 megabyte limit, especially if

359
00:22:10,668 --> 00:22:14,680
you're leaving your log system on for six months without clearing up that data.

360
00:22:15,450 --> 00:22:18,722
That could be a problem. So how do we mitigate that risk?

361
00:22:18,866 --> 00:22:22,310
Well, we have a one to squillions relationship you could be developing.

362
00:22:22,390 --> 00:22:26,006
So we have a single host file, which would be like a single server instance

363
00:22:26,038 --> 00:22:29,370
on your server farm. And we're using,

364
00:22:29,520 --> 00:22:32,654
instead of keeping track of all the log files and array in that

365
00:22:32,692 --> 00:22:36,446
host, what we're doing is keeping track of the host in the

366
00:22:36,468 --> 00:22:39,594
log. Right. You see what we're doing here? Each of the logs

367
00:22:39,642 --> 00:22:43,626
here, it keeps

368
00:22:43,658 --> 00:22:47,138
track of the host id in the log file. That way we don't have

369
00:22:47,144 --> 00:22:50,414
to worry about running that unbounded array out to our 16

370
00:22:50,462 --> 00:22:52,900
megabyte limit in our host object.

371
00:22:53,430 --> 00:22:57,570
We don't have to worry about that. Right. We're doing a reverse reference

372
00:22:57,730 --> 00:23:01,126
and we're keeping track of the one host in

373
00:23:01,148 --> 00:23:05,366
the log message. We can start doing queries just on if

374
00:23:05,388 --> 00:23:09,126
you need to get metadata about the host, or we can just do queries on

375
00:23:09,148 --> 00:23:12,154
that object ids and group them. Right. We could do all that stuff,

376
00:23:12,272 --> 00:23:16,154
no problem. But we're tracking both

377
00:23:16,192 --> 00:23:19,430
of those host files or host

378
00:23:19,510 --> 00:23:22,490
object ids in each of the log messages.

379
00:23:23,730 --> 00:23:27,390
We're going to obviously prefer referencing here because you could be going

380
00:23:27,540 --> 00:23:31,086
massively growing here. So rule four, and I think this

381
00:23:31,108 --> 00:23:33,610
is honestly one of the most important ones you can have or one of the

382
00:23:33,620 --> 00:23:37,314
most important rules. But if you have an array that

383
00:23:37,352 --> 00:23:40,814
you think could be growing at an unbounded

384
00:23:40,862 --> 00:23:44,846
size without any stop gaps, that is an anti pattern,

385
00:23:45,038 --> 00:23:48,566
that is a code smell, you should probably try

386
00:23:48,588 --> 00:23:52,214
to avoid that. So anytime you have an array that is growing at

387
00:23:52,252 --> 00:23:55,926
unbounded size, like a log file, you want to be

388
00:23:56,028 --> 00:23:59,190
referencing. And I prefer doing the one to squillions.

389
00:23:59,270 --> 00:24:01,498
Right. So you don't want to make sure any of those arrays are going to

390
00:24:01,504 --> 00:24:03,500
be growing unbounded ever.

391
00:24:04,830 --> 00:24:06,380
Okay, cool.

392
00:24:09,150 --> 00:24:12,366
This is the last

393
00:24:12,548 --> 00:24:15,166
relationship we'll be discussing here in detail,

394
00:24:15,268 --> 00:24:18,830
but I want to discuss a many to many relationship.

395
00:24:18,980 --> 00:24:22,474
So follow me if you will, dear listener.

396
00:24:22,522 --> 00:24:25,940
But let's say you are hypothetically designing a to do list,

397
00:24:26,390 --> 00:24:29,986
right? And a to do item can have many

398
00:24:30,088 --> 00:24:34,610
users and a user can have many to do items.

399
00:24:35,110 --> 00:24:38,566
Let's say we're designing like a kanban type board and multiple people can

400
00:24:38,588 --> 00:24:42,614
be working on a single item on that board at a single time.

401
00:24:42,812 --> 00:24:45,320
How do we do this? Well,

402
00:24:47,130 --> 00:24:50,458
this is where we use a many to many approach. So we have

403
00:24:50,544 --> 00:24:53,946
users and we have tasks that we're keeping track of in our

404
00:24:53,968 --> 00:24:59,290
system. So a user obviously can have an

405
00:24:59,360 --> 00:25:02,446
array of tasks that they are responsible for

406
00:25:02,628 --> 00:25:07,070
and these tasks would be correlated with different

407
00:25:07,140 --> 00:25:10,734
task documents in there. So we're doing a reference, we're doing an array of

408
00:25:10,772 --> 00:25:15,040
references to our tasks and we would also need

409
00:25:15,650 --> 00:25:18,802
another that didn't show up on there. Oh, well,

410
00:25:18,936 --> 00:25:21,394
let's see here. I'm just going to show you the point here. And then also

411
00:25:21,432 --> 00:25:24,706
the tasks then have an array of owners that they're also

412
00:25:24,728 --> 00:25:28,246
keeping track of. So with a many to many type relationship,

413
00:25:28,348 --> 00:25:31,942
what you're doing is storing that many to many relationship in

414
00:25:31,996 --> 00:25:35,766
each of the reference subtasks with each other so

415
00:25:35,788 --> 00:25:39,318
that they can each have a many, many to many relationship.

416
00:25:39,404 --> 00:25:42,790
So these tasks, for example, they only have one owner

417
00:25:42,870 --> 00:25:45,658
and we're keeping track of that owner using that reference id.

418
00:25:45,824 --> 00:25:48,966
But it is possible in the system to have many owners

419
00:25:49,078 --> 00:25:50,910
responsible for a single task.

420
00:25:53,730 --> 00:25:56,862
So this one's really important

421
00:25:56,916 --> 00:26:00,782
too. How you model your data depends entirely on your application's needs,

422
00:26:00,836 --> 00:26:04,318
right? There's no rules, but every application has separate needs.

423
00:26:04,404 --> 00:26:08,306
And how you're using that data dictates how you're going to

424
00:26:08,328 --> 00:26:11,506
be designing the schema. Right? So what may

425
00:26:11,528 --> 00:26:14,334
work for someone else's project may not work for yours.

426
00:26:14,382 --> 00:26:18,866
And it's up to you to make sure that you're taking apart

427
00:26:19,058 --> 00:26:22,614
or taking into consideration your performance needs for that application and

428
00:26:22,652 --> 00:26:26,326
how you're going to be using that data. Okay, so let's go

429
00:26:26,348 --> 00:26:29,706
through it. Types of relationships. The first one we went through today was one to

430
00:26:29,728 --> 00:26:34,730
one, right? We're just preferring using embedding or

431
00:26:34,800 --> 00:26:38,218
using key value pairs. Right. Or embedding that data right in the document. Piece of

432
00:26:38,224 --> 00:26:41,338
cake. Not a problem. One to few, right? Easy.

433
00:26:41,424 --> 00:26:44,806
We're just going to be embedding that data within our document,

434
00:26:44,838 --> 00:26:47,246
right. We have a subarray with some data in there. It's not going to be

435
00:26:47,268 --> 00:26:49,694
growing at a huge rate. You only have a couple of items in there.

436
00:26:49,732 --> 00:26:50,880
Just throw it in there.

437
00:26:55,250 --> 00:26:59,218
There we go. Computer is going slow here. And then

438
00:26:59,224 --> 00:27:04,260
we have the one to many relationship, right? We're having a computer

439
00:27:04,810 --> 00:27:08,518
pause. You would have your one

440
00:27:08,604 --> 00:27:12,994
product keeping track of potentially thousands of subparts

441
00:27:13,122 --> 00:27:16,642
on there. And we're doing that using, referencing and referencing

442
00:27:16,706 --> 00:27:20,698
that object id of the subpart in another document. And we're embedding that

443
00:27:20,704 --> 00:27:24,154
object id of that subpart into a parts array in our

444
00:27:24,192 --> 00:27:27,926
one product, one to many. And then we discussed

445
00:27:27,958 --> 00:27:30,720
one to questions, which was really fun, right?

446
00:27:33,890 --> 00:27:37,134
And we gave the example of our logging system. So we have

447
00:27:37,172 --> 00:27:40,506
a single host document keeping track of all the metadata

448
00:27:40,538 --> 00:27:44,186
for that server. And then each log file

449
00:27:44,218 --> 00:27:48,142
is a separate document and the document keeps track of the host's

450
00:27:48,286 --> 00:27:52,610
object id in it. So we don't have to worry about having an unbounded array

451
00:27:53,110 --> 00:27:55,220
appear for us in that host object.

452
00:27:56,310 --> 00:27:59,154
And then we had the many to many example, when I gave the example of

453
00:27:59,192 --> 00:28:03,570
writing a to do list where multiple users can keep track of multiple items

454
00:28:03,650 --> 00:28:06,998
or to do tasks and a task can have multiple owners. Right? So you can

455
00:28:07,004 --> 00:28:10,390
have many things to do and many people can own a single task.

456
00:28:10,730 --> 00:28:13,974
And we do that by doing arrays of sub reference

457
00:28:14,022 --> 00:28:17,706
ids to all the tasks in the user object. And then in each of

458
00:28:17,728 --> 00:28:21,514
the task objects, we're keeping track of all of the owners who

459
00:28:21,552 --> 00:28:24,510
own that object in an embedded array.

460
00:28:25,250 --> 00:28:28,590
All right? And then we had some rules here today too. So first thing is

461
00:28:28,660 --> 00:28:32,158
favor embedding. That's your go to thing, unless you have a

462
00:28:32,164 --> 00:28:34,980
compelling reason not to embed that data.

463
00:28:36,310 --> 00:28:40,226
And basically everything here is about deciding when you want to

464
00:28:40,248 --> 00:28:43,986
stop embedding that data, right? And needing to access that data on

465
00:28:44,008 --> 00:28:47,206
its own is not a compelling, or is a compelling reason to not embed it

466
00:28:47,228 --> 00:28:51,750
or to reference it in a separate document. You want to avoid joins and lookups

467
00:28:52,970 --> 00:28:57,186
if they can be avoided, but it is not an anti pattern

468
00:28:57,218 --> 00:29:00,826
to use them, right? It's not a bad thing to do joins and lookups in

469
00:29:00,848 --> 00:29:04,700
MongoDB if you have a compelling reason to use them.

470
00:29:05,950 --> 00:29:09,706
It's just in my experience, most people coming from a normalization approach just

471
00:29:09,728 --> 00:29:13,406
by default will split it up in order to normalize their data like

472
00:29:13,428 --> 00:29:17,166
they did in SQL. But the very nature of

473
00:29:17,188 --> 00:29:20,814
a MongoDB document allows us to be more creative and do more

474
00:29:20,852 --> 00:29:23,806
interesting things with our data set, including embedding it. Let's take advantage of it.

475
00:29:23,828 --> 00:29:26,658
This is a unique way to save our data. We might as well use it

476
00:29:26,664 --> 00:29:30,014
and take advantage of it, right? Note your array

477
00:29:30,062 --> 00:29:33,326
should not grow without bound. If you have an unbounded array

478
00:29:33,358 --> 00:29:36,918
anywhere in your data set, let's get rid of

479
00:29:36,924 --> 00:29:40,306
that. That's a huge code smell

480
00:29:40,338 --> 00:29:44,198
for me. And lastly, and most importantly, how you model your

481
00:29:44,204 --> 00:29:47,750
data depends entirely on the needs of your unique application, right?

482
00:29:47,820 --> 00:29:51,194
Everyone has different needs for the applications, but these are the most

483
00:29:51,232 --> 00:29:55,340
important. Okay, here, home stretch here,

484
00:29:57,390 --> 00:30:00,694
let's go through what we just talked about. One last recap.

485
00:30:00,742 --> 00:30:04,426
So the first thing we discussed today was relational database

486
00:30:04,458 --> 00:30:07,786
design versus MongoDB schema design. With a relational schema

487
00:30:07,818 --> 00:30:11,674
design, what we're doing is modeling our data independently

488
00:30:11,722 --> 00:30:15,006
of our queries. And typically we do that through normalization to

489
00:30:15,028 --> 00:30:18,686
the third form and splitting that data up using foreign keys into separate

490
00:30:18,718 --> 00:30:22,498
tables and columns and data sets. Right? And we're doing joins on

491
00:30:22,504 --> 00:30:26,146
those foreign keys to bring that data together with MongoDB

492
00:30:26,178 --> 00:30:29,846
schema design. No rules, no process,

493
00:30:29,948 --> 00:30:33,762
no algorithms we can follow. We're just worried

494
00:30:33,826 --> 00:30:37,542
about how we're saving that data and query performance based

495
00:30:37,596 --> 00:30:39,080
on the needs of our application.

496
00:30:41,370 --> 00:30:45,298
Okay, so there's two key ways of us designing

497
00:30:45,314 --> 00:30:48,618
the schema for application. That's either embedding that data directly in the

498
00:30:48,624 --> 00:30:52,538
document or referencing it with an object id. So if you embed it, obviously you're

499
00:30:52,554 --> 00:30:56,046
just sticking that data directly in that database, right? That'd be the

500
00:30:56,068 --> 00:30:59,946
equivalent of doing a join on data sets with a relational database

501
00:30:59,978 --> 00:31:03,742
or data set. And get all that data,

502
00:31:03,796 --> 00:31:07,262
all that's there, single query, super fast atomic operations.

503
00:31:07,326 --> 00:31:11,070
But you have to be aware of data growing massively

504
00:31:11,150 --> 00:31:14,802
and growing out of the bounds of that document or getting too much data

505
00:31:14,856 --> 00:31:18,198
that you do not actually need. Right. And if that's the case, then you want

506
00:31:18,204 --> 00:31:21,254
to make sure you're referencing that data using object ids and

507
00:31:21,292 --> 00:31:24,578
using joins and lookups. So you get smaller documents,

508
00:31:24,754 --> 00:31:28,486
you're deduping your data again, not a code smell and you

509
00:31:28,508 --> 00:31:32,662
can access. We're reducing the size of the

510
00:31:32,716 --> 00:31:36,218
data going over so you're not over fetching any data for your users or for

511
00:31:36,224 --> 00:31:39,226
your app, which would slow it down. But you do have to be aware that

512
00:31:39,248 --> 00:31:42,454
you are going to be making queries and lookups which can slow down

513
00:31:42,512 --> 00:31:45,646
and decrease performance of your application. Okay,

514
00:31:45,748 --> 00:31:49,200
then the next thing we did was we discussed a bunch of SQL type

515
00:31:50,290 --> 00:31:53,790
relationships that we can also use. So we have the one to one. Awesome.

516
00:31:53,860 --> 00:31:56,542
We're going to use key value pairs just to keep track of all that data

517
00:31:56,596 --> 00:31:59,666
together if you have a one to few. So that's just like

518
00:31:59,688 --> 00:32:02,834
a subarray. We're just going to embed that in the data set. If it's not

519
00:32:02,872 --> 00:32:06,306
too huge, just embed it one to many. Right. This is where

520
00:32:06,328 --> 00:32:10,030
it start growing largely. And we gave the example of that product

521
00:32:10,120 --> 00:32:13,686
having many subparts and we're using referencing on those

522
00:32:13,708 --> 00:32:16,198
object needs to make sure that we're not going to be getting too big.

523
00:32:16,284 --> 00:32:18,902
And for the needs of this application, we didn't actually need to let part data

524
00:32:18,956 --> 00:32:22,326
every single time. It may only be a unique part of

525
00:32:22,348 --> 00:32:25,562
our application. It may be overkill to get that every single time.

526
00:32:25,696 --> 00:32:29,114
And then we gave the example of one to squillions with our log files and

527
00:32:29,152 --> 00:32:31,210
many to many with our to do lists.

528
00:32:32,110 --> 00:32:35,278
And we'll skip through this really fast here, but I just want to

529
00:32:35,284 --> 00:32:37,840
point out this last part again,

530
00:32:38,690 --> 00:32:41,806
if you're going to take anything away from this talk. What I want you to

531
00:32:41,828 --> 00:32:45,426
remember is when you're modeling a schema for

532
00:32:45,448 --> 00:32:49,534
MongoDB databases and for your application, just know that every database

533
00:32:49,582 --> 00:32:53,540
schema design is different and it depends on the unique needs of your application.

534
00:32:53,910 --> 00:32:57,686
Consider how you're going to be querying that data or using it,

535
00:32:57,788 --> 00:33:01,814
and you need to figure out what

536
00:33:02,012 --> 00:33:05,458
performance needs you need for your application and you're going to be designing

537
00:33:05,474 --> 00:33:09,478
your schema based on those requirements. Then that's it, right? There's no pre prescribed

538
00:33:09,494 --> 00:33:11,820
approach. Every need is different.

539
00:33:13,230 --> 00:33:17,100
Okay, questions? I'm in the chat too. If you have any questions

540
00:33:18,750 --> 00:33:22,554
and what's next? So if I've inspired you at all in this

541
00:33:22,592 --> 00:33:25,902
talk and you want to get involved or learn more,

542
00:33:26,036 --> 00:33:29,486
you should know that we have the MongoDB University, which you can totally check out

543
00:33:29,508 --> 00:33:34,850
there. We have the MongoDB developer hub developer mongodb.com.

544
00:33:35,000 --> 00:33:38,466
It's a place where you find amazing blog posts, articles, cool to

545
00:33:38,488 --> 00:33:41,170
do things, examples,

546
00:33:41,670 --> 00:33:45,186
getting started guides, quick start guide. It's amazing. And if you

547
00:33:45,208 --> 00:33:49,062
want to take advantage of our MongoDB DB University, I'd recommend

548
00:33:49,196 --> 00:33:52,994
if you haven't started with the m one or like intro to MongoDB

549
00:33:53,042 --> 00:33:56,294
course and you want to learn more about MongoDB schema design

550
00:33:56,332 --> 00:33:59,462
because we just scratched the surface here today. But I recommend

551
00:33:59,516 --> 00:34:02,682
taking the m 320 course on data modeling. It's a great place

552
00:34:02,736 --> 00:34:06,426
to learn more about database design. Lastly too,

553
00:34:06,448 --> 00:34:10,294
if I've inspired you all to want to get better at schema design or MongoDB

554
00:34:10,342 --> 00:34:14,046
or just be a better developer, what I'd recommend is just getting out there and

555
00:34:14,068 --> 00:34:17,454
doing it right. Just on your next project,

556
00:34:17,572 --> 00:34:21,034
spin up a MongoDB database and just use on your backend.

557
00:34:21,082 --> 00:34:24,446
But practice it. Going to these talks is a good

558
00:34:24,468 --> 00:34:27,634
way to learn if this is something you're interested in learning more about.

559
00:34:27,752 --> 00:34:31,214
But in order to fully

560
00:34:31,262 --> 00:34:34,978
grok a new piece of tech, I think the best way to do that is

561
00:34:35,064 --> 00:34:37,858
to actually build it.

562
00:34:37,944 --> 00:34:41,334
Figure out what errors are going to come up. Like just do it.

563
00:34:41,372 --> 00:34:44,998
There's tons of resources for you from MongoDB, but get out

564
00:34:45,004 --> 00:34:48,726
there and build something. Build something just for you, right? But try to use it.

565
00:34:48,908 --> 00:34:52,186
And if you want $100 in

566
00:34:52,208 --> 00:34:55,370
free MongoDB credits, use code Joe K 100.

567
00:34:55,440 --> 00:34:59,100
Or you can scan that little QR code for a bunch of free credits.

568
00:35:00,450 --> 00:35:05,002
If you want to work for MongoDB, we're always hiring, baby. We're always hiring.

569
00:35:05,146 --> 00:35:09,294
Check out the MongoDB careers. That's careers mongodb.com

570
00:35:09,332 --> 00:35:13,066
or go to Joecarlson dev Mongodbcareers.

571
00:35:13,258 --> 00:35:16,670
Here's a bunch of resources I'd also recommend checking out again,

572
00:35:16,740 --> 00:35:20,286
my name is Joe Carlson. I work for MongoDB and it has been

573
00:35:20,308 --> 00:35:23,440
a pleasure chatting with all y'all today.

574
00:35:23,970 --> 00:35:27,238
If I've if you want to hang out with me ever again, best place to

575
00:35:27,244 --> 00:35:30,786
do that is on Twitter. I also make dumb jokes on TikTok and I stream

576
00:35:30,818 --> 00:35:34,200
on the MongoDB Twitch stream every Friday at noon eastern time.

577
00:35:34,890 --> 00:35:38,822
Thank you so much everyone. You're the best. Ooh, I love you.

578
00:35:38,876 --> 00:35:42,340
You're great. Oh so good. See you next time.

