1
00:00:00,730 --> 00:00:04,366
What if you could work with some of the world's most innovative companies,

2
00:00:04,548 --> 00:00:08,746
all from the comfort of a remote workplace? Andela has matched

3
00:00:08,778 --> 00:00:12,970
thousands of technologists across the globe to their next career adventure.

4
00:00:13,130 --> 00:00:16,474
We're empowering new talent worldwide, from Sao

5
00:00:16,522 --> 00:00:19,802
Paulo to Egypt and Lagos to Warsaw.

6
00:00:19,946 --> 00:00:23,038
Now the future of work is yours to create.

7
00:00:23,204 --> 00:00:27,030
Anytime, anywhere. The world is at your fingertips.

8
00:00:27,370 --> 00:00:29,190
This is Andela.

9
00:01:12,790 --> 00:01:16,210
So welcome to today's talk in Peernet. My name is Akilan Selvacoumar and

10
00:01:16,280 --> 00:01:19,826
I'm a software engineer at Peernet and I work towards the Peernet core repository.

11
00:01:19,938 --> 00:01:24,114
And today I'm excited to talk about Peernet and the core protocol

12
00:01:24,242 --> 00:01:27,538
we've been working on, or the new standard and implementation of our peer

13
00:01:27,554 --> 00:01:30,326
to peer network, which we built purely using Golang.

14
00:01:30,518 --> 00:01:34,122
So just to recap or just a good way to start

15
00:01:34,176 --> 00:01:37,942
or a high overview of Purenet is Purenet is a peer to peer protocol

16
00:01:38,006 --> 00:01:39,450
designed for file sharing.

17
00:01:41,070 --> 00:01:44,654
But what we have done is we have actually used the best techniques available out

18
00:01:44,692 --> 00:01:48,574
there for sharing files between two peers, learning about

19
00:01:48,612 --> 00:01:52,126
peers in the network. We have implemented our technique, or the

20
00:01:52,148 --> 00:01:54,400
best techniques used for escaping that.

21
00:01:55,330 --> 00:01:58,898
And because we'll talk about the

22
00:01:58,904 --> 00:02:02,606
whole protocol is purely in pure go. So the advantage

23
00:02:02,638 --> 00:02:06,386
of this is we can run completely cross platform. So if you run

24
00:02:06,408 --> 00:02:10,002
on an Android phone, you can basically run pure. Net natively

25
00:02:10,066 --> 00:02:13,414
on an Android phone and various other architectures like Risk V and so

26
00:02:13,452 --> 00:02:17,080
forth. This is the reason why we've written purely in go.

27
00:02:18,170 --> 00:02:21,900
And also another benefit is it's easy to extend your application

28
00:02:22,430 --> 00:02:25,878
on top of Peernet because it's a single binary.

29
00:02:25,974 --> 00:02:28,986
We have a good set of APIs, and if you're a go developer, you can

30
00:02:29,008 --> 00:02:32,634
actually call function calls from the packages to

31
00:02:32,672 --> 00:02:36,862
make sure it's something customized to a certain function you're writing in your

32
00:02:36,916 --> 00:02:40,499
go application. But in a higher overview, Peernet is a

33
00:02:40,999 --> 00:02:44,386
simple peer to pay protocol for sharing files, and we're building a browser on

34
00:02:44,408 --> 00:02:47,726
top of it, which helps

35
00:02:47,758 --> 00:02:51,278
in file sharing to regular users. But for now it's

36
00:02:51,294 --> 00:02:54,942
only a Windows machine. But today's talk is just about the Purenet

37
00:02:55,006 --> 00:02:59,074
standard and the implementation we've done so far with our open source protocol,

38
00:02:59,202 --> 00:03:02,646
which is available on GitHub. So just

39
00:03:02,668 --> 00:03:06,182
to start, these are the design considerations of pure. Net. So the first

40
00:03:06,236 --> 00:03:09,766
packet must establish a connection we're talking about here about we do handshaking,

41
00:03:09,798 --> 00:03:13,066
which does this. We want

42
00:03:13,088 --> 00:03:16,826
to secure against eavesdropping. We want to ensure that there's no sniffing or

43
00:03:16,848 --> 00:03:20,726
spoofing. The third point is we want to secure against message forgery.

44
00:03:20,758 --> 00:03:24,234
So we want to ensure that the message is coming from an actual peer.

45
00:03:24,282 --> 00:03:27,710
For example, peer B gets a message from peer a,

46
00:03:27,780 --> 00:03:30,986
it is from peer a and not from some other node

47
00:03:31,018 --> 00:03:33,700
called peer c acting as peer a.

48
00:03:34,310 --> 00:03:37,170
We want to secure against tampering can extension,

49
00:03:37,670 --> 00:03:41,426
and by extension a bitflip. Basically when we

50
00:03:41,448 --> 00:03:45,038
transfer packets maybe over a larger network or two nodes

51
00:03:45,054 --> 00:03:47,410
between completely different countries,

52
00:03:48,070 --> 00:03:51,766
there's a chance that the packet could get corrupted due to some

53
00:03:51,788 --> 00:03:55,318
reason, and we want to ensure that we can identify this. Either we

54
00:03:55,324 --> 00:03:58,886
can identify this and correct it, or just retransmit, or ask

55
00:03:58,908 --> 00:04:02,666
for a new packet which is not corrupted. The fifth point is

56
00:04:02,688 --> 00:04:05,674
we want the packets to be as small as possible. So if nodes are far

57
00:04:05,712 --> 00:04:09,578
away it increases deliverability and lesser packet loss. And the

58
00:04:09,584 --> 00:04:13,594
last point is we want TCP like acknowledgments because Purenet is built purely

59
00:04:13,642 --> 00:04:17,274
using UDP. We want UDP to act like TCP.

60
00:04:17,322 --> 00:04:21,386
So we basically want a reliable version of UDP and we use something called UDT,

61
00:04:21,498 --> 00:04:24,766
which we'll talk about later. So this

62
00:04:24,788 --> 00:04:27,330
is Purenet architecture at a high overview.

63
00:04:27,990 --> 00:04:31,474
So what you see on your right side right here is a browser command line

64
00:04:31,512 --> 00:04:35,458
and the Peernet core which is the implementation of the standard

65
00:04:35,624 --> 00:04:38,758
slash protocol which is in Purego as you mentioned.

66
00:04:38,844 --> 00:04:41,974
So basically the entire

67
00:04:42,092 --> 00:04:45,506
core, or the entire core library comes built in with the command

68
00:04:45,538 --> 00:04:49,046
line project itself. So it's part of the command

69
00:04:49,078 --> 00:04:53,078
line package when you build the binary and the browser interacts

70
00:04:53,094 --> 00:04:56,410
with the command line using a set of rest API calls.

71
00:04:59,630 --> 00:05:03,386
If you could replace this browser with your own application as well on top of

72
00:05:03,408 --> 00:05:07,146
it and do a set of rest API calls with Peernet running locally

73
00:05:07,178 --> 00:05:10,346
on your phone and you have a peer to peer network overlay.

74
00:05:10,378 --> 00:05:13,918
But this is just Peernet at a very high overview. We're going

75
00:05:13,924 --> 00:05:16,178
to talk about in the next slides. We're going to talk about few of the

76
00:05:16,184 --> 00:05:20,066
important modules independently. And just to recap, we do

77
00:05:20,088 --> 00:05:23,026
UDP connection with other peers in the network as well.

78
00:05:23,128 --> 00:05:26,754
So let's talk about blockchain, our fancy link list.

79
00:05:26,792 --> 00:05:30,194
Or I like to think of blockchain as a fancy link list. So the blockchain

80
00:05:30,242 --> 00:05:33,698
does two things. The first thing we use it to store file

81
00:05:33,714 --> 00:05:37,286
metadata. The next thing we use it to store user profile information.

82
00:05:37,468 --> 00:05:40,330
So what happens is when we have a blockchain,

83
00:05:41,070 --> 00:05:44,700
we share it across other peers in the network, and then

84
00:05:46,350 --> 00:05:49,798
once the other peers get the blockchain, they know about a file

85
00:05:49,814 --> 00:05:52,798
metadata. So when searching they can just look up our blockchain and see if we

86
00:05:52,804 --> 00:05:56,606
have the following file. If we have it, get that information

87
00:05:56,788 --> 00:06:00,586
from, get that information from up here or download

88
00:06:00,618 --> 00:06:04,046
the file. And something interesting is

89
00:06:04,068 --> 00:06:07,746
our blockchain is actually kind of mutable. So that

90
00:06:07,768 --> 00:06:11,298
means the blockchain does not always grow in size. So if

91
00:06:11,304 --> 00:06:15,010
we delete a file, that entry also gets deleted from the blockchain.

92
00:06:15,510 --> 00:06:18,786
So how does this work? Doesn't it define? So how does this

93
00:06:18,808 --> 00:06:22,246
work? So basically what happens is if we delete a file rather than removing that

94
00:06:22,268 --> 00:06:25,798
entry from the block, what we do is we remove the entry and at the

95
00:06:25,804 --> 00:06:29,206
same time we change the version number of the blockchain with

96
00:06:29,228 --> 00:06:32,458
a new version number and then we propagate that new version number.

97
00:06:32,544 --> 00:06:35,878
So within the minute all the nodes in the peer

98
00:06:35,894 --> 00:06:39,100
to peer network should have the new blockchain version number

99
00:06:39,470 --> 00:06:43,354
or with the new blockchain itself. So what happens

100
00:06:43,392 --> 00:06:47,166
in the end is Peernet is kind of like a Merkle forest if

101
00:06:47,188 --> 00:06:50,958
we want to think of it with a ton of blockchains, which can be

102
00:06:50,964 --> 00:06:54,298
like a Merkel tree. But basically every peer in Peernet

103
00:06:54,314 --> 00:06:57,266
has their own blockchain and they share it with each other's peers. So all the

104
00:06:57,288 --> 00:07:00,862
peers will have a bunch of blockchains of other peers in the network.

105
00:07:00,926 --> 00:07:04,130
This will help using during search specifically.

106
00:07:04,890 --> 00:07:08,546
So let's talk about the packet structure

107
00:07:08,578 --> 00:07:11,974
of Peernet. So in Peernet we have something called

108
00:07:12,012 --> 00:07:14,678
announce, which is a pseudo generated random number.

109
00:07:14,844 --> 00:07:19,054
And basically this helps against preventing replay attacks

110
00:07:19,202 --> 00:07:23,174
and so forth. The next one we have is something called a protocol

111
00:07:23,222 --> 00:07:27,658
version. By default it's zero for in our case because

112
00:07:27,744 --> 00:07:31,494
peer nets in the initial stages, but eventually we'll have one version

113
00:07:31,542 --> 00:07:34,986
one version two. And this is just to ensure that two nodes

114
00:07:35,018 --> 00:07:37,694
can communicate with each other. This is just to ensure two nodes of the same

115
00:07:37,732 --> 00:07:41,326
version communicate with each other. Or if

116
00:07:41,348 --> 00:07:44,874
we have something like backwards compatibility, we can just address it by ensuring

117
00:07:44,922 --> 00:07:48,066
all nodes that within the packet itself that both nodes are

118
00:07:48,088 --> 00:07:51,874
of the same version. This is obviously a future using, but not right now.

119
00:07:52,072 --> 00:07:55,286
The next one is command. We'll talk about this in the next step. The next

120
00:07:55,308 --> 00:07:59,222
one is sequence. We're talking about packet sequences over here, pretty self

121
00:07:59,276 --> 00:08:03,000
explanatory. The next one is the size of

122
00:08:03,690 --> 00:08:07,874
the payload data, basically the size of payload

123
00:08:07,922 --> 00:08:11,050
you're sending. And the payload over here could be anything.

124
00:08:11,120 --> 00:08:14,954
It could be a part file, it could be maybe a get block message,

125
00:08:15,072 --> 00:08:19,034
something related to the announcement, depending on what the user is sending through the

126
00:08:19,072 --> 00:08:23,034
packet. And the last one is the

127
00:08:23,072 --> 00:08:26,622
randomly generated packets. Now this is kind of important because

128
00:08:26,676 --> 00:08:29,566
this is to ensure that a router cannot just say this is a peer net

129
00:08:29,588 --> 00:08:32,614
packet based on the size of a packets.

130
00:08:32,762 --> 00:08:36,446
And basically this protects against fingerprinting.

131
00:08:36,558 --> 00:08:39,746
So yeah, this is one way

132
00:08:39,768 --> 00:08:43,522
we use to skip the firewall. So part of our

133
00:08:43,656 --> 00:08:48,626
packet itself, the last one is in

134
00:08:48,648 --> 00:08:51,366
pure net, most of the pack. For example, if you do get block or most

135
00:08:51,388 --> 00:08:55,138
of the commands, they are encrypted using salsa 20. But if you do a file

136
00:08:55,154 --> 00:08:58,934
transfer, for now it's actually unencrypted and it's rather in

137
00:08:58,972 --> 00:09:03,162
plain text. So the reason for this is because

138
00:09:03,216 --> 00:09:06,506
of efficiency reasons, there has been like high cpu usage when

139
00:09:06,528 --> 00:09:09,738
we encrypt and send for each and every single, when we do

140
00:09:09,744 --> 00:09:13,398
a file transfer, because in file transfers we send a bunch of packets,

141
00:09:13,574 --> 00:09:16,506
because of course it's a file, we're transferring a huge file to the network.

142
00:09:16,538 --> 00:09:20,000
So we generate multiple smaller packets and transmit them through.

143
00:09:20,370 --> 00:09:23,422
And of course signing and sending actually slows down,

144
00:09:23,476 --> 00:09:26,802
increases cpu performance. So this is an open

145
00:09:26,856 --> 00:09:30,130
problem. We're still looking into it. We want to find an efficient way to

146
00:09:30,280 --> 00:09:33,170
anchor packets and send them over for file transfers.

147
00:09:34,710 --> 00:09:37,846
Next one is peer discovery, something simple. So one way is

148
00:09:37,868 --> 00:09:40,834
we use something called bootstrapping. So initially when you start Peernet,

149
00:09:40,882 --> 00:09:45,346
you would connect to a set of root peers. These root peers are basically Peernet

150
00:09:45,378 --> 00:09:49,190
servers, basically running Peernet itself.

151
00:09:49,340 --> 00:09:53,286
And basically it's a single point or it could be multiple root

152
00:09:53,318 --> 00:09:56,570
peers where all peers connect to these root peers. To learn about

153
00:09:56,640 --> 00:09:59,994
more nodes in the network. This helps immediately learn

154
00:10:00,032 --> 00:10:03,734
have a larger peer list, and this means we can find more files

155
00:10:03,782 --> 00:10:07,134
in the network increases, dispersing more peers, increasing our

156
00:10:07,172 --> 00:10:08,990
discovery to other peers.

157
00:10:10,450 --> 00:10:13,230
This looks like a centralized approach, but this is the only time.

158
00:10:13,300 --> 00:10:16,686
Maybe it's centralized, but you could have your own set

159
00:10:16,708 --> 00:10:19,966
of root peers or your own set of bootstrap nodes,

160
00:10:19,998 --> 00:10:22,658
and this could be even some computer in your house. So when you're running a

161
00:10:22,664 --> 00:10:26,226
private network, you want to ensure you learn about nodes in your private network through

162
00:10:26,248 --> 00:10:29,650
your bootstrap node or just through your root node

163
00:10:29,730 --> 00:10:33,574
so you can have your own list

164
00:10:33,612 --> 00:10:37,154
of it. But for now we've

165
00:10:37,202 --> 00:10:40,650
provided punit nodes to ensure you can learn them quickly.

166
00:10:40,800 --> 00:10:43,130
The next one is exchanging pls,

167
00:10:44,270 --> 00:10:47,478
basically exchanging, this is just part of the bootstrap

168
00:10:47,494 --> 00:10:51,258
process, or exchanging pls is I communicate to node b,

169
00:10:51,344 --> 00:10:54,846
I share my pls to node b, node B shares his or her

170
00:10:54,868 --> 00:10:58,334
pls to node to node a, which is me. And then I learn

171
00:10:58,372 --> 00:11:01,866
about new nodes from, let's say node a and node b knows

172
00:11:01,898 --> 00:11:05,418
about new nodes from me and so forth helps

173
00:11:05,434 --> 00:11:08,498
about learning about new peers in the network. The next step is if we want

174
00:11:08,504 --> 00:11:12,354
to quickly discover nodes in our local network, we use

175
00:11:12,392 --> 00:11:15,966
two things. One is an IPV four broadcast, and the other

176
00:11:16,008 --> 00:11:19,986
one is something called an IPV six multicast. So with an IPV

177
00:11:20,018 --> 00:11:23,990
four broadcast, we send, let's say an announcement message

178
00:11:24,140 --> 00:11:27,634
to a single IP address to actually a broadcast

179
00:11:27,682 --> 00:11:31,238
IP address in the network, and then that's sent to other nodes.

180
00:11:31,334 --> 00:11:34,918
Basically that broadcast IP sends the announcement messages to all nodes

181
00:11:34,934 --> 00:11:38,378
in the network. And whichever node is running Peernet in

182
00:11:38,384 --> 00:11:42,446
your local network will respond back to the broadcast address itself or

183
00:11:42,548 --> 00:11:46,160
respond to our node actually, and then

184
00:11:48,290 --> 00:11:51,146
we would know about that new node or new nodes in our network.

185
00:11:51,178 --> 00:11:54,686
And IPV six multicast is sending a datagram

186
00:11:54,798 --> 00:11:57,970
to a specific group of nodes in the network.

187
00:11:58,390 --> 00:12:01,666
These are just two techniques we use to learn about more nodes in

188
00:12:01,688 --> 00:12:04,994
our network. So we

189
00:12:05,032 --> 00:12:08,466
use two techniques, escape NAT. One is something, one is called UPnP

190
00:12:08,498 --> 00:12:12,326
and UDP holepunching. So UPnP just stands for universal plug and

191
00:12:12,348 --> 00:12:15,474
play. This means this is actually only certain routers

192
00:12:15,522 --> 00:12:18,886
support UPnP. This depends on your router model and

193
00:12:18,908 --> 00:12:22,620
whether it's enabled or not. And what UPnP does is something really simple.

194
00:12:23,150 --> 00:12:27,002
You tell your router, open the following external port for me and

195
00:12:27,056 --> 00:12:30,570
map it to my computer, which is running Peernet.

196
00:12:31,230 --> 00:12:34,414
And this will ensure that nodes outside your network can

197
00:12:34,452 --> 00:12:37,070
communicate through you by escaping NAT.

198
00:12:37,570 --> 00:12:40,414
And of course this is only if your router is enabled. And many people also

199
00:12:40,452 --> 00:12:44,026
disable it, sometimes for security reasons. So let's

200
00:12:44,058 --> 00:12:47,590
say you don't have UPNP. Another way you can do or PNN automatically

201
00:12:47,610 --> 00:12:51,202
will do it for you is using UDP hole punching where you'd use another

202
00:12:51,256 --> 00:12:54,594
server or actually use another node, which is any node in the network which is

203
00:12:54,632 --> 00:12:58,498
escape NAT to communicate. So this helps if two nodes

204
00:12:58,514 --> 00:13:02,194
are behind nats to communicate with each other. We use the rendezvous server,

205
00:13:02,322 --> 00:13:06,246
which is our middle server, and for example client a.

206
00:13:06,348 --> 00:13:09,654
Basically what we do here is

207
00:13:09,692 --> 00:13:12,986
both nodes, both of us connect to the middle server to know about each other.

208
00:13:13,168 --> 00:13:17,286
And basically it's useful

209
00:13:17,318 --> 00:13:20,406
if both nodes are behind the firewall. So for example, what will happen is client

210
00:13:20,438 --> 00:13:24,026
a will connect to this. Let's say this node behind Nat

211
00:13:24,138 --> 00:13:28,426
and this node behind Nat would communicate to client b stating

212
00:13:28,458 --> 00:13:32,014
that the messages come from client a and then client b based

213
00:13:32,052 --> 00:13:35,478
on that information about client a from the rendezvous server or their middle server

214
00:13:35,514 --> 00:13:39,682
would directly do a peer to peer connection with client a.

215
00:13:39,736 --> 00:13:42,574
It's a widely based concept,

216
00:13:42,622 --> 00:13:45,970
escape Nat. You can see it commonly used a lot with WebRTC as well.

217
00:13:46,040 --> 00:13:49,446
And we have it within ourselves because

218
00:13:49,468 --> 00:13:53,506
our protocol is UDP, it works perfectly. We can easily implement holepunching

219
00:13:53,538 --> 00:13:57,894
and we already have it implemented, tested and it works really well for

220
00:13:57,932 --> 00:14:00,070
nodes behind nets.

221
00:14:01,610 --> 00:14:05,082
The next step is, the next one we want to talk about is something interesting

222
00:14:05,216 --> 00:14:08,954
we've been working on. It's something really simple and we intend to improve a lot

223
00:14:08,992 --> 00:14:13,166
more on this later. And this is called a decentralized search.

224
00:14:13,348 --> 00:14:16,702
So decentralized search is really simple

225
00:14:16,756 --> 00:14:21,166
implementation. So in a peer to peer protocol we

226
00:14:21,188 --> 00:14:24,334
don't like searching using hashes or maybe a file name or

227
00:14:24,372 --> 00:14:26,900
basically some IP address with the file name.

228
00:14:27,910 --> 00:14:31,086
We just want to search for a keyword and then we want all the results

229
00:14:31,118 --> 00:14:35,010
of nodes in the network with that keyword.

230
00:14:37,190 --> 00:14:40,934
So what we do is, I'm sorry about that. So what we do is the

231
00:14:40,972 --> 00:14:44,582
nodes with these key. So basically when we search. So let's actually step

232
00:14:44,636 --> 00:14:47,710
back a bit. So when we upload a file to the network,

233
00:14:47,810 --> 00:14:51,270
what we do is we generate something called indexes.

234
00:14:51,430 --> 00:14:55,020
So basically what happens is

235
00:14:56,190 --> 00:14:59,850
we take a file name and if there are spaces in the file,

236
00:15:00,350 --> 00:15:03,674
we consider them as separate words and each of these words are

237
00:15:03,712 --> 00:15:06,782
indexes. For example, we can have a file saying go first,

238
00:15:06,836 --> 00:15:10,814
talk 2022 mp4 and each of them with a dash or

239
00:15:10,852 --> 00:15:14,126
space or an underscore. We remove those underscores and each

240
00:15:14,148 --> 00:15:17,886
of those words are an index. And all this index is mapped to the hash

241
00:15:17,918 --> 00:15:21,346
of the file. And basically if we search using this

242
00:15:21,368 --> 00:15:25,634
hash of the files, we can get the file metadata.

243
00:15:25,682 --> 00:15:30,886
And using this metadata we

244
00:15:30,908 --> 00:15:34,246
can either download the file or even get more information about the file from the

245
00:15:34,268 --> 00:15:37,826
peer to peer network. And that's how we do indexing.

246
00:15:37,858 --> 00:15:41,354
And that's why we do indexing. And when we search, we also

247
00:15:41,392 --> 00:15:44,874
do the same thing. When you search, let's say, for something specific,

248
00:15:44,992 --> 00:15:48,262
we make sure that all of them are lowercase. We remove

249
00:15:48,326 --> 00:15:52,190
spaces, we remove quotations, and then based on your search,

250
00:15:52,260 --> 00:15:55,994
we search against our index table. We get the multiple

251
00:15:56,042 --> 00:15:59,418
hashes of the files and then let's

252
00:15:59,434 --> 00:16:02,798
say we query them, let's say from our

253
00:16:02,804 --> 00:16:06,066
blockchains we have, and then we get the metadata and we display it.

254
00:16:06,088 --> 00:16:09,906
And then that's as simple as that. When you search a file, how you get

255
00:16:09,928 --> 00:16:13,890
the results of your files in the network.

256
00:16:15,510 --> 00:16:18,566
Actually we'll do a live demo which will make so much more sense of what

257
00:16:18,588 --> 00:16:22,710
I'm talking about right now. So we have,

258
00:16:22,860 --> 00:16:26,182
we'll just jump quickly. So this is something also

259
00:16:26,236 --> 00:16:29,850
super interesting. And this is a warehouse. This is where we actually

260
00:16:29,920 --> 00:16:33,066
store our files in Purenet, kind of like

261
00:16:33,088 --> 00:16:36,970
our file system where we store files. And let's talk about how

262
00:16:37,040 --> 00:16:40,950
a warehouse works. So as we know, just to

263
00:16:40,960 --> 00:16:44,446
recap, a blockchain only stores metadata, whereas a

264
00:16:44,468 --> 00:16:47,694
warehouse actually stores the files, as I mentioned.

265
00:16:47,892 --> 00:16:51,054
So what are the features of warehouse? What we have is

266
00:16:51,092 --> 00:16:54,462
automatic deblication. So to ensure that it's

267
00:16:54,526 --> 00:16:58,130
kind of like when we create our little Merkel tree for every file,

268
00:16:58,550 --> 00:17:00,420
we do not have redundant data.

269
00:17:02,550 --> 00:17:06,494
We address files based on hash. This is important content based addressing.

270
00:17:06,542 --> 00:17:09,558
So you search a file rather than the files name, you search based on the

271
00:17:09,564 --> 00:17:13,334
content or based on the hash. We can do three simple actions from

272
00:17:13,372 --> 00:17:17,250
our warehouse. We can read a file, write a file, or remove a file.

273
00:17:17,330 --> 00:17:20,934
The next part is something interesting. We can read parts or chunks,

274
00:17:20,982 --> 00:17:24,646
or we can seek parts of the file. So for example, if a peer

275
00:17:24,678 --> 00:17:28,374
is downloading a file from, let's say node b or peer

276
00:17:28,422 --> 00:17:31,982
b, basically peer B can also

277
00:17:32,036 --> 00:17:35,614
seek a certain part of the file and transmit it over to

278
00:17:35,652 --> 00:17:38,734
node to peer a, which is

279
00:17:38,772 --> 00:17:41,950
important. And we can store, and the next

280
00:17:42,020 --> 00:17:45,902
part is we can store file as large as what our disk supports,

281
00:17:46,046 --> 00:17:48,740
which is trivial and obviously should be the case.

282
00:17:50,390 --> 00:17:53,554
This is something, and this is, I would say the

283
00:17:53,592 --> 00:17:57,506
last part about the technical bits of Peernet. So this is

284
00:17:57,528 --> 00:18:00,966
something we've been working on for a long time. It took us a long time

285
00:18:00,988 --> 00:18:04,230
to integrate. So we can elaborate about this.

286
00:18:04,300 --> 00:18:07,890
And this is something we are very happy to announce that we have full

287
00:18:08,060 --> 00:18:11,594
support and we've fully written in Golang about this. And this is the

288
00:18:11,632 --> 00:18:15,114
UDP protocol. UDT protocol is

289
00:18:15,152 --> 00:18:18,650
basically making UDP more reliable,

290
00:18:21,410 --> 00:18:24,030
making UDP act like TCP,

291
00:18:24,370 --> 00:18:28,090
but except most of the transport layer or most of the implementation

292
00:18:28,170 --> 00:18:31,690
like congestion control, is on the application layer.

293
00:18:31,770 --> 00:18:35,440
So the benefit of this is that,

294
00:18:36,610 --> 00:18:39,906
for example, when we know two nodes are close by to each other, we can

295
00:18:39,928 --> 00:18:43,454
actually have a larger packet size because we know there's going to be lesser

296
00:18:43,502 --> 00:18:46,918
packet loss and this would increase. Essential. We're utilizing most of

297
00:18:46,924 --> 00:18:50,466
the bandwidth. We can modify ascending

298
00:18:50,498 --> 00:18:54,402
window size, we can modify a lot of things which normally

299
00:18:54,466 --> 00:18:57,994
can only be done at a kernel level. And because

300
00:18:58,112 --> 00:19:01,626
we have all these major things at an application

301
00:19:01,728 --> 00:19:04,518
level, like sending acknowledgments, receiving,

302
00:19:04,694 --> 00:19:08,726
sending a NAC packet not acknowledged packet, having our bucket

303
00:19:08,758 --> 00:19:12,094
of peers, having a packet of packets not

304
00:19:12,132 --> 00:19:14,670
sent, setting the size of the packet,

305
00:19:16,290 --> 00:19:19,662
maybe even defining how the packet looks like. Like how we mentioned

306
00:19:19,716 --> 00:19:24,714
in a previous slide, having all this at an application layer ensures

307
00:19:24,762 --> 00:19:28,720
that it's cross platform. We can really optimize it

308
00:19:29,830 --> 00:19:33,074
to utilize most amount of bandwidth available and

309
00:19:33,112 --> 00:19:36,886
the stack. And yeah, just having these two benefits makes

310
00:19:36,908 --> 00:19:40,246
a big deal for us and over the future is going to improve the

311
00:19:40,268 --> 00:19:44,278
protocol dramatically with whatever we have plans with.

312
00:19:44,364 --> 00:19:48,294
And Unity has won multiple bandwidth competitions

313
00:19:48,342 --> 00:19:52,282
and making this work in Purego was not

314
00:19:52,336 --> 00:19:56,074
easy. I think we're the only project that

315
00:19:56,112 --> 00:19:59,420
actually fully utilizes UDT in pure go.

316
00:19:59,950 --> 00:20:03,326
So we're glad about this and

317
00:20:03,348 --> 00:20:06,506
we want to improve UDP because we fully have a lot of things to improve

318
00:20:06,538 --> 00:20:09,706
on. But this is majorly

319
00:20:09,738 --> 00:20:12,990
the backbone behind how we do file transfers between

320
00:20:13,060 --> 00:20:16,290
from the most lowest level but having it completely

321
00:20:16,360 --> 00:20:19,090
implemented in Golang at an application layer.

322
00:20:19,830 --> 00:20:22,466
So this means that you as a contributor, it's going to be really simple to

323
00:20:22,488 --> 00:20:26,146
modify it customly for your use case if you want to get to

324
00:20:26,168 --> 00:20:30,134
the finer details. And you wouldn't have to change anything on

325
00:20:30,172 --> 00:20:33,160
your operating system or kernel itself.

326
00:20:35,050 --> 00:20:38,134
So let's jump to a lifetime of Peernet. Finally we're here.

327
00:20:38,332 --> 00:20:42,026
I'm just going to quickly open my terminal right here. So let

328
00:20:42,048 --> 00:20:45,626
me get a clear command. So what you see here is

329
00:20:45,648 --> 00:20:48,570
the command line repository. I will, sorry, 1 minute.

330
00:20:49,710 --> 00:20:53,138
Quickly, right here. Quickly put it right here. So this is the command

331
00:20:53,174 --> 00:20:56,558
line repository as you can see here. All you have to

332
00:20:56,564 --> 00:21:00,286
do is clone this repository. I will show you the link soon and all you

333
00:21:00,308 --> 00:21:04,334
do is go build and

334
00:21:04,372 --> 00:21:07,586
that's it. It takes a few seconds, obviously I've built it so it's all in

335
00:21:07,608 --> 00:21:10,766
my cache, but normally it just takes a few seconds

336
00:21:10,798 --> 00:21:14,274
to build. And once you're done building you can just run

337
00:21:14,312 --> 00:21:17,998
that binary and you have right here. Let me

338
00:21:18,024 --> 00:21:21,350
just position this in a way so that you can see what I'm talking about.

339
00:21:21,420 --> 00:21:25,734
Okay cool. 1 second. Okay here so

340
00:21:25,852 --> 00:21:29,126
we have a set of commands which we have improved. I'm just going to show

341
00:21:29,148 --> 00:21:32,586
a few commands right now. We just wanted to show that this works. So if

342
00:21:32,608 --> 00:21:34,780
I do status, sorry.

343
00:21:36,350 --> 00:21:38,940
I can see a set of nodes in my network right here.

344
00:21:39,950 --> 00:21:43,494
These are basically public IP addresses of all nodes in a network.

345
00:21:43,542 --> 00:21:47,280
So we identify each node by their public IP address.

346
00:21:47,890 --> 00:21:51,258
We can get more information. If you want to find more information about each node

347
00:21:51,274 --> 00:21:56,194
we can do something called pure, pure bliss which

348
00:21:56,232 --> 00:21:59,518
is right here. We can see all the adapters

349
00:21:59,614 --> 00:22:02,050
available in these specific nodes,

350
00:22:02,470 --> 00:22:05,640
which could be, which is substantially useful for us.

351
00:22:07,130 --> 00:22:08,280
But for now,

352
00:22:10,170 --> 00:22:13,510
this question mark right here, we have these other commands.

353
00:22:14,330 --> 00:22:17,746
We're not going to talk about this. Today's talk, you can play around and easily

354
00:22:17,778 --> 00:22:21,686
figure out what they do, since they're pretty well documented

355
00:22:21,798 --> 00:22:25,322
for what they do. But just

356
00:22:25,376 --> 00:22:29,066
explain, I'll explain a few important commands. For example, if you

357
00:22:29,088 --> 00:22:32,554
want to test out and see how your file transfers, you can use something

358
00:22:32,592 --> 00:22:35,902
called probe file transfer. So what this does is

359
00:22:36,036 --> 00:22:39,854
you can have a file added to your warehouse in node a, and node b

360
00:22:39,892 --> 00:22:43,386
also has that file added to the warehouse and you can just do probe file

361
00:22:43,418 --> 00:22:46,842
transfer. You put that node id of node b, for example,

362
00:22:46,916 --> 00:22:50,946
of who you want to test against, and you put your file hash and this

363
00:22:50,968 --> 00:22:54,290
will basically do a file transfer and show you the speeds you're getting

364
00:22:54,360 --> 00:22:57,606
and ensure that the file is fully transferred by comparing the

365
00:22:57,628 --> 00:23:00,806
hashes towards the end. And this is a

366
00:23:00,828 --> 00:23:04,120
great way to debug and ensure that the changes you're doing are working,

367
00:23:04,490 --> 00:23:07,378
how efficiently they're working, and so forth.

368
00:23:07,474 --> 00:23:10,986
So just wanted to mention about the command. You can also of

369
00:23:11,008 --> 00:23:13,820
course try out the other commands which are super interesting.

370
00:23:15,550 --> 00:23:18,854
As you can see, we're going to add commands

371
00:23:18,902 --> 00:23:21,978
soon in the upcoming releases where you can actually just add a

372
00:23:21,984 --> 00:23:25,246
files, remove a file and do the basic stuff. But for now you would have

373
00:23:25,268 --> 00:23:28,874
to use the browser to do that. Or you could read the rest API docs

374
00:23:28,922 --> 00:23:32,634
which help you add remove files. But we will soon add them to the command

375
00:23:32,682 --> 00:23:36,606
line which is using certain functions which will make it easier

376
00:23:36,638 --> 00:23:40,738
for us to integrate directly to the command line without having any complicated code.

377
00:23:40,904 --> 00:23:44,034
So just bear with us. We will get the basic functionality like

378
00:23:44,072 --> 00:23:47,478
add remove files soon so that you can directly talk with your

379
00:23:47,484 --> 00:23:51,094
friends peer from any creating system just using a few command line

380
00:23:51,132 --> 00:23:54,758
instructions. The next thing I

381
00:23:54,764 --> 00:23:58,390
wanted to talk about was actually the peony browser itself

382
00:23:58,460 --> 00:24:01,846
which is right over here. You can see this is

383
00:24:01,868 --> 00:24:05,786
proprietary, but this browser uses the punt protocol itself.

384
00:24:05,888 --> 00:24:08,666
So you can see right here, if you go to the explore tab, you can

385
00:24:08,688 --> 00:24:12,582
see a set of videos recently

386
00:24:12,646 --> 00:24:16,014
uploaded to Peernet itself. If we go to the home

387
00:24:16,052 --> 00:24:19,790
tab right here, for example, I can type Ukraine if I'm

388
00:24:19,860 --> 00:24:22,894
spelling it correctly, and just give it some time.

389
00:24:23,092 --> 00:24:26,574
We have a set of just this is to prove that our peer net

390
00:24:26,612 --> 00:24:30,146
search or search works in our peer to peer protocol as per how we

391
00:24:30,328 --> 00:24:33,874
explained it in the slides. You can go here. If you hover over

392
00:24:33,912 --> 00:24:38,280
your peer, you can find out from which country it's been uploaded from.

393
00:24:38,890 --> 00:24:40,280
If you click play,

394
00:24:42,570 --> 00:24:48,054
you can play the video as well. Currently this is a bit slow, but this

395
00:24:48,092 --> 00:24:51,766
works fine. This is actually an older release, but if you do check our Twitter

396
00:24:51,798 --> 00:24:55,754
pages for the new releases with the new video players and

397
00:24:55,872 --> 00:24:59,178
something interesting over here is that when you

398
00:24:59,184 --> 00:25:02,726
play a video, the video is played on memory and

399
00:25:02,768 --> 00:25:05,930
not on disk. So yeah, it's only temporarily.

400
00:25:06,010 --> 00:25:09,914
So it's great. First, eventually it's going to be great for streaming

401
00:25:09,962 --> 00:25:13,550
videos as well and actually already is, but we haven't released that version,

402
00:25:13,630 --> 00:25:16,180
so stay tuned to get that version from us.

403
00:25:17,670 --> 00:25:21,790
So I'm going to quickly jump back to the slides

404
00:25:21,870 --> 00:25:25,780
right here. I'm going to go here view

405
00:25:27,830 --> 00:25:31,302
that was just a very quick demo of Peernet to understand what we've been working

406
00:25:31,356 --> 00:25:34,646
on and feel free to try it out yourself. We love to see

407
00:25:34,668 --> 00:25:37,720
the ideas you like us to implement next.

408
00:25:39,130 --> 00:25:42,314
So these are a few ideas on how you could extend Peernet. This is just

409
00:25:42,352 --> 00:25:45,946
our few ideas we found interesting, but of course you

410
00:25:45,968 --> 00:25:49,820
can implement it using your own ways. One way is

411
00:25:50,670 --> 00:25:54,286
to ensure that you build a distributed game engine in such a way that when

412
00:25:54,308 --> 00:25:57,982
you're playing a game or you are loading a map, you could basically

413
00:25:58,116 --> 00:26:01,726
load a map from the peer nearest to you by just searching based

414
00:26:01,748 --> 00:26:05,906
on the hash. IPFS has a few examples. It could be interesting to

415
00:26:05,928 --> 00:26:09,218
also extend it with Peernet because in Peernet over time

416
00:26:09,304 --> 00:26:13,650
we are going to be way more efficient in terms of discovering peers,

417
00:26:14,550 --> 00:26:18,680
transferring content between peers using

418
00:26:19,450 --> 00:26:23,126
our implementation compared to other peer to peer networks. But this

419
00:26:23,148 --> 00:26:25,702
is underbuilding and we're very soon to accomplish this.

420
00:26:25,836 --> 00:26:29,094
So one is building a decentralized game engine.

421
00:26:29,132 --> 00:26:31,962
It'll be very interesting to see how if you could have a decentralized game engine

422
00:26:32,016 --> 00:26:36,490
on top of Peernet, another one we really want to improve our NLP searches.

423
00:26:37,230 --> 00:26:40,442
Sorry, we really want to improve our searching. It'll be interesting

424
00:26:40,496 --> 00:26:43,994
if we could actually someway embed NLP to the Peernet protocol

425
00:26:44,042 --> 00:26:48,046
as an external open source project. And potentially we could

426
00:26:48,068 --> 00:26:51,486
also add it'll be interesting. We're also keen to find out

427
00:26:51,508 --> 00:26:55,490
how we could introduce files ranking when doing decentralized searches from,

428
00:26:55,560 --> 00:26:59,906
if possible, the core protocol itself to

429
00:26:59,928 --> 00:27:03,346
improve results. But these are a few ideas we think are

430
00:27:03,368 --> 00:27:07,266
interesting, but it's your creativity. We just want you to play

431
00:27:07,288 --> 00:27:10,774
around, try Peernet and use it for your use

432
00:27:10,812 --> 00:27:14,246
cases. So how

433
00:27:14,268 --> 00:27:17,766
do you contribute to Peernet? It's super simple. You can join our Discord channel or

434
00:27:17,788 --> 00:27:22,474
forums on our website. I'll show them the next slide. The links to

435
00:27:22,512 --> 00:27:26,186
discuss about Peernet you can do is you can also create a pr at

436
00:27:26,208 --> 00:27:27,610
our GitHub repository.

437
00:27:31,390 --> 00:27:35,098
If you want to contribute to changes to the Peernet protocol based on modifications

438
00:27:35,114 --> 00:27:38,110
you did on your fork or your project, so forth,

439
00:27:39,570 --> 00:27:42,798
it would be recommended that you create a pr and we discuss through the

440
00:27:42,804 --> 00:27:45,914
changes you want so that we don't have to reject the pr

441
00:27:45,972 --> 00:27:50,034
you create. So yeah, feel free to discuss on

442
00:27:50,072 --> 00:27:53,266
our Discord channel or just create an issue on GitHub and we'll get right back

443
00:27:53,288 --> 00:27:56,626
to you. The last way to contribute to Peernet is if

444
00:27:56,648 --> 00:28:00,006
you have a large proposal, say it's going to take you more than

445
00:28:00,028 --> 00:28:03,734
four months or even six months to complete. The best thing is to email us

446
00:28:03,772 --> 00:28:06,914
at info@peernet.org so that we could potentially

447
00:28:07,042 --> 00:28:10,342
personally talk with you and try to ensure that your idea,

448
00:28:10,396 --> 00:28:13,722
which you want to merge with Peernet, is towards

449
00:28:13,776 --> 00:28:17,226
all our interests and we are on track

450
00:28:17,328 --> 00:28:19,802
and we are all on the same page when discussing about it.

451
00:28:19,856 --> 00:28:23,790
So these are a few things. So just to summarize,

452
00:28:24,290 --> 00:28:27,546
pure net is a completely decentralized network with no intermediaries.

453
00:28:27,738 --> 00:28:30,990
We have a full working browser and a command line implemented.

454
00:28:32,370 --> 00:28:35,438
We can escape nats and firewalls to a certain extent.

455
00:28:35,614 --> 00:28:38,882
Our entire implementation is

456
00:28:38,936 --> 00:28:42,146
a single binary file and you need zero configuration to

457
00:28:42,168 --> 00:28:45,060
get it started and running, which is super cool.

458
00:28:46,330 --> 00:28:49,874
We control most of our transfers at an application layer,

459
00:28:50,002 --> 00:28:53,362
which means we can optimize

460
00:28:53,426 --> 00:28:56,280
our transfer algorithms to take advantage of bandwidth available.

461
00:28:57,370 --> 00:29:02,086
Our implementation can run cross platform and we don't have to really contribute

462
00:29:02,118 --> 00:29:05,130
to the kernel so everything can be done directly to Peernet.

463
00:29:05,630 --> 00:29:09,626
We can ensure also that we can also control packet sizes and

464
00:29:09,648 --> 00:29:13,102
have various controls, which is very useful when we do something

465
00:29:13,156 --> 00:29:16,670
like file transfers and so forth.

466
00:29:18,290 --> 00:29:21,438
These are our links to the Peernet project.

467
00:29:21,524 --> 00:29:25,042
Feel free to look at them. I'll just quickly go through them

468
00:29:25,096 --> 00:29:29,138
with you right now. So here we

469
00:29:29,144 --> 00:29:32,398
have the Peernet GitHub page, we have the peony

470
00:29:32,414 --> 00:29:36,946
core repository right away and you

471
00:29:36,968 --> 00:29:40,786
can see the Punet core. If we go back to Punet itself, we have

472
00:29:40,808 --> 00:29:45,702
the Peernet CMD also. And yeah,

473
00:29:45,756 --> 00:29:48,966
this is the best way to get started. Just clone the repository, build it and

474
00:29:48,988 --> 00:29:52,266
get started. And if you want to find more information about Peernet, you can also

475
00:29:52,288 --> 00:29:55,866
go to peernet.org and

476
00:29:55,968 --> 00:29:59,450
you can actually download the browser from here and get started

477
00:29:59,520 --> 00:30:02,398
right away with Peernet itself.

478
00:30:02,564 --> 00:30:06,426
And of course the last point is join

479
00:30:06,458 --> 00:30:09,934
our Discord channel. We'd love to discuss your

480
00:30:09,972 --> 00:30:13,678
ideas to use Peernet or your

481
00:30:13,684 --> 00:30:16,670
feedback or how you would like to use Peernet in the future.

482
00:30:16,820 --> 00:30:20,346
For your development. So thank you for tolerating

483
00:30:20,378 --> 00:30:23,486
me. Or thank you for listening to this talk today. And I hope to see

484
00:30:23,508 --> 00:30:27,526
you next time. Or we hope to meet you soon in our Discord channel.

485
00:30:27,628 --> 00:30:28,006
Thank you,

