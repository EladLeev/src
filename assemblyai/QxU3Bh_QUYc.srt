1
00:01:44,830 --> 00:01:48,386
Hi, thank you for coming to listen to my talk

2
00:01:48,488 --> 00:01:51,826
about getting pass, getting those passwords out

3
00:01:51,848 --> 00:01:55,650
of your repos, detecting leaked secrets at scale.

4
00:01:56,870 --> 00:02:00,020
So just to give you a little heads up,

5
00:02:00,390 --> 00:02:04,402
we're going to be talking about how we can find

6
00:02:04,456 --> 00:02:08,346
secrets in git repos, what these problem is,

7
00:02:08,448 --> 00:02:12,042
how we can prevent it, and what can possibly go wrong

8
00:02:12,096 --> 00:02:15,418
with some little stories along the lines of

9
00:02:15,504 --> 00:02:19,274
things that have happened that I've seen over

10
00:02:19,392 --> 00:02:23,114
the last kind of five years of working in this wonderful

11
00:02:23,162 --> 00:02:26,910
area of devsecops. So who am I?

12
00:02:27,060 --> 00:02:30,554
My name is Daniel Oatesley. I'm a Devsecops engineer

13
00:02:30,602 --> 00:02:32,980
and co director at Punk Security.

14
00:02:34,310 --> 00:02:37,474
I started doing Devsecops about

15
00:02:37,512 --> 00:02:41,234
five, six years ago and I've kind of loved it ever

16
00:02:41,272 --> 00:02:44,514
since. It's kind of been a passion of mine. I started off

17
00:02:44,552 --> 00:02:47,590
life as a developer, then I became systems operations,

18
00:02:48,250 --> 00:02:52,386
managing servers and databases and firewalls

19
00:02:52,418 --> 00:02:56,434
and such, and then ended up in security doing pen testing, red teaming,

20
00:02:56,482 --> 00:02:59,550
and then fell into this world of devsecops.

21
00:02:59,730 --> 00:03:02,906
And I am a true enthusiast of it. I loved coming out

22
00:03:02,928 --> 00:03:06,506
and talking about it, I love teaching people about it and how to

23
00:03:06,688 --> 00:03:10,250
automate security checks to detect issues

24
00:03:10,400 --> 00:03:14,190
and then how we can deal with those issues rather than just

25
00:03:14,260 --> 00:03:18,398
implementing tools. I like to talk about things such as

26
00:03:18,484 --> 00:03:22,058
how do we ticket them, how do we track and monitor those

27
00:03:22,164 --> 00:03:26,354
issues through to remediation and

28
00:03:26,552 --> 00:03:30,434
making sure that we don't overload people as we're onboarding these

29
00:03:30,472 --> 00:03:33,330
tools into their pipelines.

30
00:03:33,670 --> 00:03:37,490
I put Terraform down because I love terraform

31
00:03:37,570 --> 00:03:40,998
for building everything that I kind

32
00:03:41,004 --> 00:03:44,678
of do in infrastructure world. I am a security

33
00:03:44,764 --> 00:03:48,460
guy. I do lots of ctfs and

34
00:03:51,070 --> 00:03:55,366
playing is probably the best way of saying it. I am a massive geek

35
00:03:55,398 --> 00:03:59,146
as well. I'm a massive Star wars fan. Some of you might have

36
00:03:59,168 --> 00:04:03,182
seen on LinkedIn that I'm busy building the Millennium Falcon at the moment and

37
00:04:03,236 --> 00:04:06,702
I'm busy having the pictures of that just to show how much of a true

38
00:04:06,756 --> 00:04:09,866
geek I actually am. So at punk

39
00:04:09,898 --> 00:04:13,134
security, we're a Devsecops company. Quick little shout out

40
00:04:13,172 --> 00:04:17,022
to our four open source tools which are DNS, Reaper,

41
00:04:17,086 --> 00:04:20,722
secret, Magpie, which we're going to be talking about later on SM,

42
00:04:20,776 --> 00:04:24,286
Beagle and Ponesby. If you're interested in those tools,

43
00:04:24,318 --> 00:04:27,558
they are open source. Please go and have a play with them.

44
00:04:27,644 --> 00:04:31,458
We are also the home of the first devsecops CTF

45
00:04:31,634 --> 00:04:35,174
platform. We're busy enhancing that at the moment. We ran it

46
00:04:35,212 --> 00:04:38,946
last year for our second birthday for punk

47
00:04:38,978 --> 00:04:42,726
security. We intend to run it again for our third. So that's

48
00:04:42,758 --> 00:04:45,260
enough of the bits about me.

49
00:04:45,950 --> 00:04:49,638
This is the bit that we're probably more interested in. So we're

50
00:04:49,654 --> 00:04:53,102
going to cover off. What is the problem? What are we trying

51
00:04:53,156 --> 00:04:56,574
to fix by detecting secrets in

52
00:04:56,692 --> 00:05:00,474
our git repos or in our svcs

53
00:05:00,602 --> 00:05:02,590
or version control systems?

54
00:05:03,330 --> 00:05:06,610
What types of secrets can we leak and where do they live?

55
00:05:06,760 --> 00:05:09,918
What can go wrong? If those secrets do get detected?

56
00:05:10,094 --> 00:05:12,660
How easy is it to actually find these things?

57
00:05:13,910 --> 00:05:17,394
How can we better defend and make sure that our

58
00:05:17,432 --> 00:05:21,046
secrets don't get leaked or aren't accessed in

59
00:05:21,068 --> 00:05:24,774
an insecure way? And then I'm going to quickly talk. I'm going to talk

60
00:05:24,812 --> 00:05:28,474
about and give a little demo of our open source tool,

61
00:05:28,512 --> 00:05:33,066
secret magpie. So what

62
00:05:33,088 --> 00:05:33,980
is the problem?

63
00:05:36,350 --> 00:05:39,918
Essentially, there are two different types of secrets that we

64
00:05:39,924 --> 00:05:43,754
want to use. One is a secret

65
00:05:43,802 --> 00:05:47,134
that we want the web application to use,

66
00:05:47,332 --> 00:05:50,686
such as an AWS key to be

67
00:05:50,708 --> 00:05:55,060
able to access an s three bucket, maybe upload some information.

68
00:05:55,750 --> 00:05:59,314
We want the application to work. What can go wrong,

69
00:05:59,352 --> 00:06:03,202
though, is that those AWS permissions can either be over

70
00:06:03,256 --> 00:06:06,402
permissive or can be accidentally

71
00:06:06,466 --> 00:06:10,306
changed, and then that leads to abuse by attackers.

72
00:06:10,418 --> 00:06:13,640
Now, I've got a real world example of this.

73
00:06:14,490 --> 00:06:18,620
We were helping a consultancy company

74
00:06:19,230 --> 00:06:23,066
recently who got done over twice over a

75
00:06:23,088 --> 00:06:26,262
bank holiday weekend. They accidentally

76
00:06:26,326 --> 00:06:29,946
leaked their AWS keys into a

77
00:06:30,048 --> 00:06:33,598
web application that went up on the Friday before a

78
00:06:33,604 --> 00:06:37,194
bank holiday. An attacker got hold of those AWS

79
00:06:37,242 --> 00:06:40,926
keys, logged into the AWS account and then ran up

80
00:06:40,948 --> 00:06:45,074
a massive crypto farm and cost that

81
00:06:45,112 --> 00:06:46,850
consultancy thousands.

82
00:06:48,230 --> 00:06:51,426
We tried to explain to them that they needed to put secret detection in

83
00:06:51,448 --> 00:06:55,154
and we needed to put various CI pipelines in and to rotate the

84
00:06:55,192 --> 00:06:59,320
AWS key. They did the rotation, but they didn't actually put any

85
00:06:59,930 --> 00:07:03,410
checks in. They didn't implement secret detection.

86
00:07:03,570 --> 00:07:07,802
Next bank holiday came round, they did another release on a Friday, just before

87
00:07:07,936 --> 00:07:11,482
everybody ran off for the bank holiday, thinking everything

88
00:07:11,536 --> 00:07:15,674
was fine, they accidentally uploaded the AWS key again

89
00:07:15,792 --> 00:07:20,074
and got done twice as hard this time. So these things

90
00:07:20,272 --> 00:07:23,454
do happen quite regularly, unfortunately, and quite

91
00:07:23,492 --> 00:07:26,906
scarily. And then we've also got secrets

92
00:07:26,938 --> 00:07:30,814
that shouldn't have been there in the first place. So these might be like

93
00:07:30,852 --> 00:07:34,174
a EMV file that might accidentally get

94
00:07:34,212 --> 00:07:38,318
leaked onto a web server or a configuration file where you've got your database

95
00:07:38,414 --> 00:07:42,340
password for being able to connect into the back end.

96
00:07:42,950 --> 00:07:45,878
These are the kind of things that we don't want up there and we're going

97
00:07:45,884 --> 00:07:49,622
to cover over what those different types of files are and why we probably

98
00:07:49,676 --> 00:07:51,080
wouldn't want them up there.

99
00:07:53,290 --> 00:07:57,254
However, it's not just about detecting secrets in

100
00:07:57,292 --> 00:08:01,226
files. We should also, whilst we're looking at this subject, also think

101
00:08:01,248 --> 00:08:05,386
about how we're managing our secrets as well. So we

102
00:08:05,408 --> 00:08:09,082
should be making sure that secrets aren't being recorded in

103
00:08:09,136 --> 00:08:13,054
log files or trace outputs. So we need to understand theyre

104
00:08:13,092 --> 00:08:16,218
those secrets are how they're being used, where they're

105
00:08:16,234 --> 00:08:19,486
being stored. We should also have a look and

106
00:08:19,508 --> 00:08:23,406
see how these secrets could be used for elevating

107
00:08:23,518 --> 00:08:26,482
permission privileges. So again,

108
00:08:26,536 --> 00:08:30,226
going back to that AWS key, should it be allowed to contact to

109
00:08:30,248 --> 00:08:33,474
EC two s or create new

110
00:08:33,512 --> 00:08:37,514
lambdas, or should it only be locked down and restricted?

111
00:08:37,582 --> 00:08:41,158
And then how do we make sure that those permissions that have been

112
00:08:41,164 --> 00:08:43,990
applied to that AWS key remain in sync?

113
00:08:45,050 --> 00:08:50,186
We also need to think about how an individual might get access to these

114
00:08:50,288 --> 00:08:53,434
secrets. So again, we have

115
00:08:53,472 --> 00:08:59,130
another example where we were trying to figure out how somebody

116
00:08:59,200 --> 00:09:02,814
had abused a secret to log into

117
00:09:02,852 --> 00:09:06,234
a database. It turned out that developer had logged,

118
00:09:06,362 --> 00:09:09,514
used this database

119
00:09:09,562 --> 00:09:13,502
password to connect into a production system and then started

120
00:09:13,556 --> 00:09:17,010
dumping out production data so he could use it in these test environment.

121
00:09:18,310 --> 00:09:22,286
Now we all know that we shouldn't use production data in test environments

122
00:09:22,398 --> 00:09:26,042
because it would be a breach of data protection or GDPR.

123
00:09:26,206 --> 00:09:29,958
But we also need to worry about, well, who's going

124
00:09:29,964 --> 00:09:33,606
to access these secrets. So if we're storing secrets in

125
00:09:33,628 --> 00:09:37,670
a git repository, and that git repository is open to our entire

126
00:09:37,740 --> 00:09:40,726
organization, who's to say that somebody won't log,

127
00:09:40,828 --> 00:09:43,946
go collect that key and then go and use it in a way that we

128
00:09:43,968 --> 00:09:47,558
weren't intending. So again, we need to be thinking about how we're

129
00:09:47,574 --> 00:09:50,560
going to be managing these secrets and who has access to them.

130
00:09:51,810 --> 00:09:55,600
So what types of secrets should we be thinking about?

131
00:09:56,210 --> 00:09:59,038
So we need to think about passwords, obviously,

132
00:09:59,204 --> 00:10:02,570
because hard coded passwords just shouldn't be a thing.

133
00:10:02,660 --> 00:10:06,146
But we do use them. Developers put them

134
00:10:06,168 --> 00:10:09,826
in EMV files, we also use them

135
00:10:09,848 --> 00:10:13,426
in terraform, in TFR files. And we just need to make

136
00:10:13,448 --> 00:10:16,914
sure that those files can get into our git repository.

137
00:10:16,962 --> 00:10:20,406
Now we can either use git ignores or we should be using

138
00:10:20,508 --> 00:10:24,054
other more secure methods of being able to collect those

139
00:10:24,092 --> 00:10:26,470
secrets, such as key vaults.

140
00:10:27,870 --> 00:10:30,902
Then we've also got API keys. I mean these are quite popular,

141
00:10:30,966 --> 00:10:33,930
they're quite useful, especially in these cloud environments.

142
00:10:36,430 --> 00:10:38,810
So we can access other systems,

143
00:10:39,470 --> 00:10:43,054
but we need to think about how we're going to rotate these API keys and

144
00:10:43,092 --> 00:10:47,040
where they're being used and how many different repos might be using them

145
00:10:48,210 --> 00:10:51,466
tokens. Again, we shouldn't

146
00:10:51,498 --> 00:10:55,570
really be storing these things in our git repos,

147
00:10:56,070 --> 00:10:59,422
private keys and private certificates.

148
00:10:59,486 --> 00:11:03,826
I have seen that in the past where an

149
00:11:03,848 --> 00:11:06,966
NgINX server has been spun up. It was a

150
00:11:06,988 --> 00:11:11,286
docker container and they left the private key while

151
00:11:11,308 --> 00:11:15,190
the private certificate for encrypting

152
00:11:16,090 --> 00:11:20,038
the traffic for the NgInx box, they left it inside their git repo

153
00:11:20,134 --> 00:11:23,814
and then posted it up online. Well, if you lose control of your private

154
00:11:23,862 --> 00:11:27,722
key, your data can be decrypted. So you really

155
00:11:27,776 --> 00:11:30,734
need to be protecting these things again.

156
00:11:30,852 --> 00:11:34,666
So where can these different secrets

157
00:11:34,698 --> 00:11:37,898
exist? Well, obviously they can exist inside a file. We've already discussed

158
00:11:37,994 --> 00:11:41,646
things like EMV files, configuration files. Theyre could be

159
00:11:41,668 --> 00:11:46,114
hard coded somewhere inside the source code or

160
00:11:46,152 --> 00:11:50,082
they could just be accidentally dropped in as an extra file inside

161
00:11:50,136 --> 00:11:53,518
the repository. However, they can also be stored

162
00:11:53,614 --> 00:11:57,830
inside a git message. And even

163
00:11:57,900 --> 00:12:01,814
if we've got, I have seen it, theyre people have

164
00:12:01,852 --> 00:12:04,120
put in, in the message,

165
00:12:04,730 --> 00:12:08,658
these password for this is XYZ. But we've

166
00:12:08,674 --> 00:12:11,926
also got to worry about the git history as well. So just because we delete

167
00:12:11,958 --> 00:12:15,494
a file out of our git environment or a git

168
00:12:15,542 --> 00:12:19,514
repo doesn't mean that that file immediately disappears. It's still

169
00:12:19,552 --> 00:12:22,874
there in the history. Even if you get, the only true

170
00:12:22,912 --> 00:12:25,630
way of being able to really get rid of it is to rewrite that history.

171
00:12:25,700 --> 00:12:30,090
And even then, if you know the Shah message hash,

172
00:12:30,170 --> 00:12:33,406
you might be able to go back and go and be able to extract it.

173
00:12:33,428 --> 00:12:35,860
And we're going to have a look at one of those problems in a bit.

174
00:12:37,990 --> 00:12:41,634
But yeah, the only real way of being able to fix it, if you

175
00:12:41,672 --> 00:12:45,206
put a secret inside a repository, rotate that

176
00:12:45,228 --> 00:12:48,200
secret and make sure it's not being used anywhere else.

177
00:12:49,450 --> 00:12:53,122
So we've kind of roughly covered

178
00:12:53,186 --> 00:12:56,786
what can go wrong already. Things like hard coding

179
00:12:56,818 --> 00:13:00,194
credentials is not best practice.

180
00:13:00,242 --> 00:13:04,246
But as we all know, developers do do this, and the developers

181
00:13:04,278 --> 00:13:07,594
aren't doing this to be bad people. They're doing it so then they can

182
00:13:07,632 --> 00:13:11,134
develop quickly and easily and theyre can spin systems up

183
00:13:11,172 --> 00:13:14,734
and down. But this does have issues and

184
00:13:14,852 --> 00:13:18,702
we just need to make sure we're aware of what can

185
00:13:18,756 --> 00:13:22,198
happen if we start storing

186
00:13:22,314 --> 00:13:25,010
those secrets in a git repository.

187
00:13:28,390 --> 00:13:31,906
Ideally, what we should be doing is we just shouldn't be doing it.

188
00:13:32,088 --> 00:13:35,846
There have been multiple occasions theyre attackers can

189
00:13:35,868 --> 00:13:39,718
go and find them. I mean, if we have a quick look on

190
00:13:39,804 --> 00:13:43,030
GitHub. So just give me 2 seconds.

191
00:13:44,490 --> 00:13:48,450
So all I'm going to do is I'm going to go to GitHub

192
00:13:48,530 --> 00:13:52,106
now. I'm going to go up here into the top

193
00:13:52,208 --> 00:13:55,674
and I'm just going to have a quick look for remove aws keys, the same

194
00:13:55,712 --> 00:13:59,914
as any kind of attacker could do very easily go

195
00:13:59,952 --> 00:14:03,294
down to more click on commits and I can

196
00:14:03,332 --> 00:14:07,658
see all the keys that have been recently removed from GitHub.

197
00:14:07,754 --> 00:14:10,442
So these are aws keys that have been removed.

198
00:14:10,586 --> 00:14:14,382
Now I'm not necessarily saying that these people are bad or that whatever

199
00:14:14,436 --> 00:14:17,746
they've done is incorrect, and I certainly am. I'm not going to go

200
00:14:17,768 --> 00:14:21,326
and click on one of their comments,

201
00:14:21,438 --> 00:14:25,190
but if you did, you would most likely see that they'd remove their AWS key.

202
00:14:25,260 --> 00:14:29,702
Now that is just evidence that it

203
00:14:29,756 --> 00:14:33,286
happens. And if it's that easy for us to

204
00:14:33,308 --> 00:14:36,294
just quickly do live on a demo,

205
00:14:36,492 --> 00:14:40,790
imagine what's going on out there. For those that were astute

206
00:14:40,870 --> 00:14:45,114
would have seen there was 15,000 commits recently where

207
00:14:45,152 --> 00:14:47,450
they were removing AWS secrets.

208
00:14:48,670 --> 00:14:52,062
It happens. So if we

209
00:14:52,196 --> 00:14:55,466
have a quick look at like a standard pipeline.

210
00:14:55,498 --> 00:14:59,470
So in this case we've got feature branches, we've got a main branch,

211
00:15:00,050 --> 00:15:03,886
so we can do integration, so we can do pull requests

212
00:15:03,918 --> 00:15:07,442
and stuff like that, we may well have a

213
00:15:07,496 --> 00:15:11,214
junior developer that's just started. He hasn't created a feature branch,

214
00:15:11,262 --> 00:15:15,058
he's just committed straight to Main. He's created a env

215
00:15:15,144 --> 00:15:19,286
file and he's pushed it up because he wanted to deploy this application

216
00:15:19,388 --> 00:15:22,726
out with the username password of

217
00:15:22,748 --> 00:15:26,086
admin, which is not unusual. I'm pretty sure we've all

218
00:15:26,108 --> 00:15:29,254
seen applications out there that have done that and he's nicely

219
00:15:29,302 --> 00:15:32,090
put. The comment of he's added the credentials.

220
00:15:32,750 --> 00:15:36,214
Nice. A senior

221
00:15:36,262 --> 00:15:39,866
developer has seen what he's done and gone oh my God, what have you done?

222
00:15:39,968 --> 00:15:43,246
Or security team have triggered an alert and

223
00:15:43,268 --> 00:15:46,974
gone oh my God, what have you done? You need to get those passwords out

224
00:15:47,012 --> 00:15:50,846
immediately. Junior developer has gone along

225
00:15:50,948 --> 00:15:54,302
and he removed it. He's quite helpfully

226
00:15:54,446 --> 00:15:57,634
decided to put a nice little squiggly open

227
00:15:57,672 --> 00:16:01,454
bracket saying that you need to put the password there and then he's

228
00:16:01,502 --> 00:16:04,290
going to commit as he's removed the password.

229
00:16:04,630 --> 00:16:07,762
Now the problem is that he hasn't rotated that password

230
00:16:07,826 --> 00:16:11,078
inside his application. And you might be thinking,

231
00:16:11,164 --> 00:16:14,920
so what the, so what is that with git history?

232
00:16:15,770 --> 00:16:19,634
It's still there. That password is still there inside the history

233
00:16:19,772 --> 00:16:23,414
as we can see here. So we've still got the same username,

234
00:16:23,462 --> 00:16:27,814
admin, admin and then we've got the password as admin. He hasn't rotated the password

235
00:16:27,942 --> 00:16:31,626
and along comes Mr. Bad Guy

236
00:16:31,808 --> 00:16:35,738
and he can go back through the git history. He's downloaded this repository,

237
00:16:35,834 --> 00:16:39,214
he's done a little search like we were doing on GitHub, discovered that

238
00:16:39,252 --> 00:16:43,106
they did a remove. So he's just gone to one commit before, gone and

239
00:16:43,128 --> 00:16:46,660
extracted the password, tried it and logged straight into the application.

240
00:16:47,590 --> 00:16:51,602
So that is like kind of a very basic example of

241
00:16:51,736 --> 00:16:54,660
what can go wrong in scenario one.

242
00:16:54,970 --> 00:16:58,950
So let's just continue. So what happens

243
00:16:59,020 --> 00:17:02,354
if we do this inside a feature branch?

244
00:17:02,482 --> 00:17:06,262
So we have our junior admin, he comes along,

245
00:17:06,316 --> 00:17:09,980
he's done an EMP file again, he's put admin admin in theyre

246
00:17:10,430 --> 00:17:14,234
and he's put it up there. Our security team have

247
00:17:14,272 --> 00:17:18,266
detected what he's done, raised an alert against him, he's gone

248
00:17:18,288 --> 00:17:22,062
and removed that password, pushed it back up and

249
00:17:22,116 --> 00:17:26,254
he's then done a merge into

250
00:17:26,292 --> 00:17:28,880
the main branch. Now the problem is,

251
00:17:29,410 --> 00:17:33,294
even when we toddle along a little bit longer, there are

252
00:17:33,332 --> 00:17:36,946
certain merge types that just keep all of

253
00:17:36,968 --> 00:17:40,130
that history. So if you just do like a standard merge,

254
00:17:40,470 --> 00:17:43,554
it will keep all of those previous comments and Mr. Bad guy

255
00:17:43,592 --> 00:17:46,898
can just go back quite easily and just go pick it up. And there you

256
00:17:46,904 --> 00:17:50,870
go, he's got the credentials. Even if you do a squash commit

257
00:17:52,570 --> 00:17:55,894
and you know the shard for that particular comment, you can still

258
00:17:55,932 --> 00:17:59,418
go back and be able to extract it. So even just doing squash commits are

259
00:17:59,424 --> 00:18:03,658
not going to protect you realistically. You just shouldn't be committing env

260
00:18:03,744 --> 00:18:07,066
files into your git repository, especially if

261
00:18:07,088 --> 00:18:09,020
theyre got secrets inside that.

262
00:18:10,190 --> 00:18:13,294
There are lots of examples of these exploits out there.

263
00:18:13,332 --> 00:18:17,470
I've already listed three and we've seen on GitHub

264
00:18:18,770 --> 00:18:21,966
people are removing their credentials and if it's that easy to go

265
00:18:21,988 --> 00:18:26,530
and find them, bad guys can on average

266
00:18:27,110 --> 00:18:31,140
probably find an AWS key that's been uploaded within

267
00:18:31,750 --> 00:18:35,480
five to ten minutes. It's pretty easy.

268
00:18:36,570 --> 00:18:40,214
So how can we defend against this? Well this is

269
00:18:40,252 --> 00:18:44,198
where the SEC, the brilliant sec part, the security bit,

270
00:18:44,284 --> 00:18:47,490
gets joined in with development and operations so

271
00:18:47,660 --> 00:18:51,718
we can try and implement automated scanning.

272
00:18:51,814 --> 00:18:55,334
Now we've got two areas where we can put our git

273
00:18:55,382 --> 00:18:59,066
scanning tools and we can either put them on the

274
00:18:59,088 --> 00:19:02,918
developer's machine. So before they do a git commit we

275
00:19:02,944 --> 00:19:06,400
can do a scan and make sure that they haven't got any secrets in there,

276
00:19:06,770 --> 00:19:09,230
and we can also do it on the CI pipeline.

277
00:19:09,970 --> 00:19:13,466
Now some people say only do a pre git commit,

278
00:19:13,498 --> 00:19:17,310
that should be perfectly fine. The issue is that developers can disable

279
00:19:17,390 --> 00:19:21,218
these because they might have a requirement for it. They might

280
00:19:21,304 --> 00:19:24,594
just want to do a test, and they might just want to just get

281
00:19:24,632 --> 00:19:31,014
it stored up there and just get it out of the way, or it

282
00:19:31,052 --> 00:19:34,306
crashes and the application breaks, or there's multiple

283
00:19:34,338 --> 00:19:37,974
different reasons. I would do it in both places. I would do it as

284
00:19:38,012 --> 00:19:41,766
a pre commit, and I would also do it in the CI pipeline.

285
00:19:41,878 --> 00:19:44,700
That way if anything goes wrong on the developer's end,

286
00:19:45,630 --> 00:19:48,666
you can pick it up in the CI pipeline. Yes, the secret's up

287
00:19:48,688 --> 00:19:52,554
there. Yes, it's in the git history. No, I wouldn't bother going and rewriting

288
00:19:52,602 --> 00:19:56,078
the git history. What I would do is I just track record

289
00:19:56,164 --> 00:19:59,582
that happened, and then I would get the

290
00:19:59,716 --> 00:20:03,674
secret rotated out and then make sure that secret

291
00:20:03,722 --> 00:20:07,374
wasn't being used in any other repos or any other applications.

292
00:20:07,502 --> 00:20:11,166
Now, there's lots of tools out there that you can use. There's git

293
00:20:11,198 --> 00:20:15,380
leaks, there's truffle hog, there's Gitguardian, trivial do it.

294
00:20:16,630 --> 00:20:20,906
I'm sure that I've missed a few. I think there's Gitileaks.

295
00:20:21,038 --> 00:20:24,166
There's lots and lots out there. GitHub are doing it now.

296
00:20:24,268 --> 00:20:27,910
Lots of the git repositories like GitHub,

297
00:20:27,990 --> 00:20:31,418
GitLab, Azure radio, they've got these

298
00:20:31,584 --> 00:20:34,886
secret scanning tools pre built in. I mean, they charge

299
00:20:34,918 --> 00:20:38,314
you for it, but it's there and

300
00:20:38,352 --> 00:20:41,210
it's relatively easy to get implemented.

301
00:20:42,290 --> 00:20:45,866
So I definitely do it. But when you're doing the CI pipeline,

302
00:20:45,978 --> 00:20:48,970
think about where you're putting it, where you're scanning.

303
00:20:49,050 --> 00:20:52,654
Do you want to scan on every git push? Probably what

304
00:20:52,692 --> 00:20:55,598
I would do, but then once you've done it on the git push,

305
00:20:55,694 --> 00:20:59,426
do you need to then rescan it on a

306
00:20:59,448 --> 00:21:05,202
pull request or a merge request or anything

307
00:21:05,256 --> 00:21:09,074
else that you might be wanting to do. Do you need to rerun

308
00:21:09,122 --> 00:21:13,574
it after you've done it on the git push? Probably not. So I

309
00:21:13,612 --> 00:21:16,946
probably wouldn't bother. How else can we defend

310
00:21:16,978 --> 00:21:20,806
it? I've already alluded

311
00:21:20,838 --> 00:21:24,342
to the fact that when I'm doing my CI pipelines,

312
00:21:24,486 --> 00:21:28,570
if I'm doing git scanning, secret scanning,

313
00:21:28,910 --> 00:21:32,334
if I detect a secret, what I'll do is I will get it to

314
00:21:32,372 --> 00:21:35,962
automatically raise a development ticket,

315
00:21:36,026 --> 00:21:39,086
and I'll add it into a security backlog or assign it

316
00:21:39,108 --> 00:21:43,574
to the project, depending upon what the configuration

317
00:21:43,642 --> 00:21:46,946
requires. That way we can then track and make sure that

318
00:21:46,968 --> 00:21:50,354
that secret has been rotated. It's not a punishment thing. It's not

319
00:21:50,392 --> 00:21:52,210
to make somebody look stupid.

320
00:21:54,070 --> 00:21:57,278
It's about understanding where that secret, what happened, why that

321
00:21:57,304 --> 00:22:00,390
secret got up there? Has it been rotated?

322
00:22:00,730 --> 00:22:04,134
Has it been used anywhere else? And just making

323
00:22:04,172 --> 00:22:07,590
sure that we can show that we got those tick boxes and show the security

324
00:22:07,660 --> 00:22:12,154
team that we've taken it seriously. We can also make

325
00:22:12,192 --> 00:22:15,978
sure that we rotate those secrets and provide training

326
00:22:16,064 --> 00:22:20,598
to people as well about how to do this and how to handle those secrets

327
00:22:20,774 --> 00:22:24,826
and what the secrets are and why it's a bad idea to put like API

328
00:22:24,858 --> 00:22:28,462
keys into the source code. We should also be maybe

329
00:22:28,516 --> 00:22:31,946
asking our red teamers or our pen testers to do manual verifications

330
00:22:31,978 --> 00:22:35,522
against our git repositories and our git history and make sure that

331
00:22:35,576 --> 00:22:39,554
we've not missed anything. See if they can find anything

332
00:22:39,672 --> 00:22:40,580
in there.

333
00:22:43,750 --> 00:22:47,702
Now one of my pain

334
00:22:47,756 --> 00:22:50,870
points is around secret management

335
00:22:51,450 --> 00:22:55,190
and trying to get people on boarded with

336
00:22:55,260 --> 00:22:58,902
using secret vaults. So rather than you storing your secrets

337
00:22:58,966 --> 00:23:02,410
inside your repositories, get your application to go

338
00:23:02,480 --> 00:23:04,970
and extract the secret out of the vault.

339
00:23:06,910 --> 00:23:10,620
This could be quite easily done. If you're using AWS, you can use

340
00:23:11,310 --> 00:23:15,054
assumed roles and go and get it out of these SSM parameter store.

341
00:23:15,252 --> 00:23:18,718
It's one of the things that I like to do. You can also, if you

342
00:23:18,724 --> 00:23:22,366
really want to, when you're doing your CI pipelines or if

343
00:23:22,388 --> 00:23:25,646
you say you're using Argo CD for

344
00:23:25,668 --> 00:23:28,926
doing your deployments, you can get Argo CD to go and collect the vault,

345
00:23:29,038 --> 00:23:32,834
go collect the secrets and then help it be deployed with your

346
00:23:32,872 --> 00:23:36,546
application. Whenever it's going either into an environment variable or into the

347
00:23:36,568 --> 00:23:40,422
application as it's being spun up. We can also, if we're using

348
00:23:40,476 --> 00:23:44,306
secret vaults, is we can log who's accessing those secrets.

349
00:23:44,338 --> 00:23:47,706
So in the case of when we were doing our investigation of who

350
00:23:47,728 --> 00:23:50,874
was accessing those secrets, rather than having

351
00:23:50,912 --> 00:23:53,260
to go digging through and trying to find,

352
00:23:54,430 --> 00:23:58,010
trying to look at who's potentially used

353
00:23:58,080 --> 00:24:01,454
it, we can go straight to the vault and pull

354
00:24:01,492 --> 00:24:05,114
out an audited log. And that way we can trigger automated alerts.

355
00:24:05,162 --> 00:24:08,782
So say we got a developer a over here

356
00:24:08,836 --> 00:24:12,794
who then tries to access a secret, a production

357
00:24:12,842 --> 00:24:16,400
secret. We can say, right, Mr. Developer, why have you done that?

358
00:24:16,850 --> 00:24:20,514
It may well have a legitimate reason, but if he doesn't, we can say,

359
00:24:20,552 --> 00:24:23,794
right, you shouldn't have been doing that. Now I'm going to have to rotate that

360
00:24:23,832 --> 00:24:27,890
secrets and they can carry out an investigation.

361
00:24:28,470 --> 00:24:32,840
I also believe that these secrets should be rotated quite regularly as well.

362
00:24:33,770 --> 00:24:37,666
I know from my years of being a system administrator,

363
00:24:37,778 --> 00:24:40,922
rotating passwords was quite a big

364
00:24:40,976 --> 00:24:44,506
and challenging thing to do. Quite scary because you didn't know where

365
00:24:44,528 --> 00:24:47,386
that password was being used or how it was being used,

366
00:24:47,488 --> 00:24:50,666
which configuration files it was in. But if we're using a

367
00:24:50,688 --> 00:24:54,602
vault and we're not storing it with the application, it means

368
00:24:54,656 --> 00:24:58,346
that we should be able to rotate them regularly. We might even want to rotate

369
00:24:58,378 --> 00:25:01,594
them with every time we do a release, and then that way we can version

370
00:25:01,642 --> 00:25:05,058
control our secrets and roll our secret back. If we roll our

371
00:25:05,144 --> 00:25:08,900
application back, it's possible. I've seen it being done.

372
00:25:09,350 --> 00:25:12,398
We also should think about the encryption around those secrets.

373
00:25:12,494 --> 00:25:15,814
So where are they being used?

374
00:25:15,932 --> 00:25:19,638
How are we accessing them? Is the

375
00:25:19,724 --> 00:25:23,350
connection between the application and the vault, is that secure?

376
00:25:24,090 --> 00:25:27,930
And when it gets pulled down inside the application, where's it being stored?

377
00:25:29,070 --> 00:25:32,506
How are we keeping it safe? So those are the kind of things that you

378
00:25:32,528 --> 00:25:36,550
should be doing. Now, when we come to implement

379
00:25:36,630 --> 00:25:39,930
CI pipelines with secret scanning,

380
00:25:40,270 --> 00:25:43,310
I've had this multiple times over my career.

381
00:25:43,730 --> 00:25:47,200
There was a large software house that I was working with.

382
00:25:47,650 --> 00:25:51,306
It was building software for the NHS, and their development teams

383
00:25:51,338 --> 00:25:55,218
were dead against doing any kind of CI pipelines, especially with security

384
00:25:55,304 --> 00:25:58,446
scanning, because they were saying, we don't write vulnerabilities.

385
00:25:58,558 --> 00:26:02,002
You can't find any vulnerabilities in our system.

386
00:26:02,136 --> 00:26:06,594
Personally, I prefer to call them security defects because there are a security defect

387
00:26:06,642 --> 00:26:09,414
until somebody can figure a way about how to exploit it.

388
00:26:09,452 --> 00:26:13,174
So Alex changed my terminology of

389
00:26:13,372 --> 00:26:15,270
when I'm talking to developers.

390
00:26:15,850 --> 00:26:19,606
So this particular team, I managed

391
00:26:19,638 --> 00:26:23,894
to convince these eventually that we wanted to do secret scanning. We deployed

392
00:26:23,942 --> 00:26:28,506
in git leaks into their pipeline, and they

393
00:26:28,528 --> 00:26:31,822
were very reluctant, but we got it in. Two days

394
00:26:31,876 --> 00:26:35,566
later, my phone blew up and it was all

395
00:26:35,588 --> 00:26:39,502
these development teams. Well, this particular development team,

396
00:26:39,636 --> 00:26:43,454
I was blocking their pipelines. I was blocking their development. This pipeline's

397
00:26:43,502 --> 00:26:46,690
gone wrong, it's creating false positives.

398
00:26:47,590 --> 00:26:50,750
And basically it was just utter garbage.

399
00:26:50,910 --> 00:26:54,590
So I went and had a look and discovered that they had

400
00:26:54,680 --> 00:26:58,358
actually put a production AWS key

401
00:26:58,524 --> 00:27:01,746
into the source code that was meant to be gained,

402
00:27:01,778 --> 00:27:05,750
delivered to the development environment. The developers obviously

403
00:27:05,820 --> 00:27:10,102
looked very sheepish at that point and suddenly realized

404
00:27:10,246 --> 00:27:14,742
that by me stopping that deployment, it protected

405
00:27:14,806 --> 00:27:18,586
their production environment and stopped them from having to go to the

406
00:27:18,608 --> 00:27:21,946
NHS and look rather foolish because

407
00:27:21,968 --> 00:27:24,800
theyre leaked out this AWS key,

408
00:27:25,650 --> 00:27:28,926
they had these ability to go and rotate it anyway. So they went and

409
00:27:28,948 --> 00:27:32,634
rotated it, we tracked it, we understood what happened and that pipeline

410
00:27:32,682 --> 00:27:36,146
remained and so did the secret scanning. But if you're trying to

411
00:27:36,168 --> 00:27:39,890
deploy secret scanning into a well developed environment

412
00:27:40,310 --> 00:27:44,146
and you've got no idea what's out there, there is no easy way

413
00:27:44,168 --> 00:27:48,134
of being able to scan all your repos at

414
00:27:48,172 --> 00:27:51,414
mass and be able to figure these things out, which is why we

415
00:27:51,452 --> 00:27:53,590
developed secret Magpie.

416
00:27:54,410 --> 00:27:56,230
So Secret Magpie,

417
00:27:57,370 --> 00:28:01,206
we kind of built this as a pre secret scanning

418
00:28:01,238 --> 00:28:05,206
tool. So before you implement secret scanning, you can run secret magpie

419
00:28:05,238 --> 00:28:08,746
against all your git repositories and be

420
00:28:08,768 --> 00:28:11,966
able to understand where your secrets are. Which are

421
00:28:11,988 --> 00:28:15,642
they in a comment? Are they in a version? Are they in a file?

422
00:28:15,786 --> 00:28:19,386
Who's using them? And give you that ability to tune

423
00:28:19,578 --> 00:28:23,134
your git scanning tools before you

424
00:28:23,172 --> 00:28:26,606
start implementing them into a CI pipeline. Now you can implement secret

425
00:28:26,638 --> 00:28:30,002
Magpie into a CI pipeline, but I would recommend

426
00:28:30,056 --> 00:28:33,150
that you keep it as a manual tool, as a verification.

427
00:28:33,310 --> 00:28:36,718
Secret Magpie uses two different secret scanning tools. It uses git

428
00:28:36,734 --> 00:28:40,070
leaks and uses truffle hog. These reason we use two

429
00:28:40,140 --> 00:28:43,494
is because we found that they were these best ones and they

430
00:28:43,532 --> 00:28:46,790
complemented each other quite nicely. They weren't finding the same thing

431
00:28:46,860 --> 00:28:50,774
twice, they were kind of finding slightly different things and then we

432
00:28:50,812 --> 00:28:53,654
built it. So then it gives you a nice easy to read output.

433
00:28:53,702 --> 00:28:57,594
It's a nice HTML file that you can these start pivoting through

434
00:28:57,632 --> 00:29:01,446
with a nice little bit of Javascript. So let's

435
00:29:01,478 --> 00:29:04,880
get on with some demo time because I'm going to do a live demo.

436
00:29:05,410 --> 00:29:08,654
So what I'm going to show you here

437
00:29:08,772 --> 00:29:12,286
is a couple of commands. So we've built it. So then

438
00:29:12,468 --> 00:29:15,790
you can either use it as a docker container or it's a python script.

439
00:29:15,870 --> 00:29:20,354
So you can go on and you can just quickly download and

440
00:29:20,392 --> 00:29:23,886
make sure that you're running the latest version through our GitHub.

441
00:29:24,078 --> 00:29:27,266
We do nightly builds and nightly releases just to make sure that

442
00:29:27,288 --> 00:29:31,080
it's all nicely up to date. And as you can see, mine is.

443
00:29:31,610 --> 00:29:34,470
So what we're now going to do is I'm going to quickly show you the

444
00:29:34,540 --> 00:29:38,106
help file. So as you can look through here, we do it

445
00:29:38,128 --> 00:29:41,574
in multiple different ways. We can integrate with BitBucket,

446
00:29:41,622 --> 00:29:45,814
we can integrate with GitHub, GitLab, Azure DevOps,

447
00:29:45,942 --> 00:29:49,634
or we can just can a flat file system. And if you're

448
00:29:49,702 --> 00:29:53,294
using one of these cloud services, we've also got the

449
00:29:53,332 --> 00:29:59,082
ability for you to pass through the various different authentication

450
00:29:59,146 --> 00:30:02,766
tokens. So with GitHub and Azure Ado you'll have

451
00:30:02,788 --> 00:30:06,642
an organization and a private access key or personal

452
00:30:06,696 --> 00:30:10,354
access key. GitLab is slightly different, BitBucket again

453
00:30:10,392 --> 00:30:14,126
is slightly different again. Or if you just want to download all of the systems

454
00:30:14,158 --> 00:30:17,986
yourselves and just scan a path, you can certainly do that

455
00:30:18,008 --> 00:30:21,606
as well, we've also got some other options inside theyre as well. So you

456
00:30:21,628 --> 00:30:24,886
can control the output of your file. You can also have

457
00:30:24,908 --> 00:30:28,146
it as a CSV or a JSoN or the nice HTML

458
00:30:28,178 --> 00:30:31,542
file which I'm going to show you. You can also disable

459
00:30:31,606 --> 00:30:35,354
parts of it. You can also single it down to a single branch. So rather

460
00:30:35,392 --> 00:30:38,842
than running multiple branches you can have just one single

461
00:30:38,896 --> 00:30:43,070
branch. And by default we limit

462
00:30:43,970 --> 00:30:47,326
these number of branches to 20. But you might have more

463
00:30:47,348 --> 00:30:50,714
than 20 branches. So we limited

464
00:30:50,762 --> 00:30:54,274
it by default to maximum of 20 branches. But if you got more than 20

465
00:30:54,312 --> 00:30:58,340
branches you can certainly push that up. It'll just take longer to scan through,

466
00:30:59,510 --> 00:31:02,180
so it's nice and easy to run,

467
00:31:04,310 --> 00:31:08,242
as we can see here. I'm just going to pass through an output folder

468
00:31:08,306 --> 00:31:12,322
into the docker container. I'm then going to run secret magpie.

469
00:31:12,386 --> 00:31:16,162
I'm going to run it against our GitHub environment. I've created

470
00:31:16,306 --> 00:31:19,702
an organization called Punk security demo

471
00:31:19,836 --> 00:31:22,934
and pass through as an environment variable, my git token,

472
00:31:22,982 --> 00:31:27,098
because obviously I don't want to release that. That would be rather foolish of me.

473
00:31:27,264 --> 00:31:31,082
We're also going to output the file into that output directory

474
00:31:31,146 --> 00:31:34,414
and I think we'll call it results. And then

475
00:31:34,452 --> 00:31:36,350
I want the HTML file.

476
00:31:39,730 --> 00:31:43,566
So as this is busy running, as you can see, you can see

477
00:31:43,588 --> 00:31:47,218
a nice verbose output and with every good security tool

478
00:31:47,304 --> 00:31:51,026
it should have beautiful ASCII art. So we've got some nice beautiful ASCII art

479
00:31:51,048 --> 00:31:54,962
in here. As you can see here we're scanning a repository called

480
00:31:55,016 --> 00:31:58,802
wrong secrets. By default. This has got 22

481
00:31:58,856 --> 00:32:02,706
open branches and we're limiting it to the first 20. So there's

482
00:32:02,738 --> 00:32:06,086
two branches that aren't going to get scanned. I just wanted to be able to

483
00:32:06,108 --> 00:32:08,780
show you guys how that looks and how it works.

484
00:32:09,230 --> 00:32:12,970
We're using this wrong secrets repo. It is actually

485
00:32:13,040 --> 00:32:17,066
an OWASp repository which

486
00:32:17,088 --> 00:32:20,634
you can go and get yourself. So if you do a Google search for

487
00:32:20,672 --> 00:32:23,934
OwAsp wrong secrets, you will find it. It is

488
00:32:23,972 --> 00:32:27,370
a bit of a secret CTF challenge designed by OwAsp.

489
00:32:27,450 --> 00:32:30,686
We're using it in this one just because it's the easiest one to be

490
00:32:30,708 --> 00:32:34,074
able to show you how secret scanning

491
00:32:34,122 --> 00:32:37,794
kind of works. Now I have just

492
00:32:37,832 --> 00:32:41,506
slightly paused the video theyre just for a minute, just whilst it

493
00:32:41,528 --> 00:32:44,258
ran through, because I didn't want to waste any time. But we can have a

494
00:32:44,264 --> 00:32:47,634
quick look through this output and as we look inside this output,

495
00:32:47,682 --> 00:32:52,520
we've scanned through one repository. It's found 536

496
00:32:53,130 --> 00:32:57,278
secrets. 200 of those are unique truffle

497
00:32:57,314 --> 00:33:00,886
hog found sorry, git leaks found the most and truffle

498
00:33:00,918 --> 00:33:04,234
hog found eleven pretty good.

499
00:33:04,432 --> 00:33:07,606
We found some various different interesting things. So like private

500
00:33:07,638 --> 00:33:09,450
keys, AWS keys,

501
00:33:10,750 --> 00:33:14,330
GCP security keys, some fine grained

502
00:33:14,750 --> 00:33:16,010
passwords.

503
00:33:17,970 --> 00:33:21,242
If we want to now have a quick look at the HTML file.

504
00:33:21,306 --> 00:33:25,202
This is the bit that I think gives you more a better

505
00:33:25,256 --> 00:33:29,246
user experience. So we can go inside here and we can quickly filter

506
00:33:29,358 --> 00:33:32,386
on, say, AWS keys. So now it's just

507
00:33:32,408 --> 00:33:36,114
filtered on the AWS filters. We can now see the

508
00:33:36,152 --> 00:33:39,686
files that these are stored in. We can click on those and we should

509
00:33:39,708 --> 00:33:43,414
be able to go straight through to the file and be able to see the

510
00:33:43,452 --> 00:33:47,350
AWS key there, be able to verify it.

511
00:33:47,420 --> 00:33:51,462
We can now go back into secret Magpie, mark that as a confirmed

512
00:33:51,526 --> 00:33:54,874
if you wanted to. So this one's already been marked as

513
00:33:54,912 --> 00:33:58,298
verified because that's what it's done already. But we can now

514
00:33:58,464 --> 00:34:01,926
track inside here whether you want to confirm

515
00:34:01,958 --> 00:34:05,166
that you've rotated it. It needs rotating. You can mark it as

516
00:34:05,188 --> 00:34:08,826
a false positive and the idea is that you can quickly rotate

517
00:34:08,858 --> 00:34:12,554
through these and then export the results as a CSV

518
00:34:12,602 --> 00:34:15,818
file. If you're interested in learning more about it,

519
00:34:16,004 --> 00:34:19,954
please feel free to reach out to us with

520
00:34:19,992 --> 00:34:23,426
any questions that you might have or if you want to use this and then

521
00:34:23,448 --> 00:34:26,914
you found there's a bug or something like that, hit us up on

522
00:34:26,952 --> 00:34:30,914
either LinkedIn or raise an issue on

523
00:34:30,952 --> 00:34:34,434
our git repository and we'll get back to you. So at this

524
00:34:34,472 --> 00:34:37,946
point I just want to say thank you very much. I realize it, I'm three

525
00:34:37,968 --> 00:34:42,026
minutes slightly over my time, but I hope you've enjoyed it. And if

526
00:34:42,048 --> 00:34:45,338
you want to carry on the conversation afterwards, please feel free to

527
00:34:45,344 --> 00:34:45,960
come and find me.

