{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/9e6013f5-a198-4df5-8600-de2b665f6f41", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["api", "apis", "bash", "basic", "basics", "be", "because", "becomes", "before", "beginners", "behind", "believe", "belt", "best", "binaries", "blog", "boot", "bootcamps", "build", "but", "by", "camps", "can", "chat", "checking", "class", "cleanliness", "clis", "code", "coded", "coding", "command", "common", "concept", "conditionals", "conf fourty two", "consider", "contribute", "courses", "curated", "data engineer", "dependencies", "deploying", "developers", "devs", "doesnt", "dollars", "dont", "env", "etc", "explores", "figuring", "from", "from zero to hero", "functions", "gopath", "hardest", "has", "havent", "httpsgoplayspace", "ins", "intro", "java", "learning go", "libraries", "libriares", "linters", "loops", "makes", "meetups", "miriah peterson", "modules", "online", "opensource", "part", "places", "posts", "pr", "practices", "problems", "program", "programing", "programmers", "programming", "project", "projects", "pulled", "resources", "sections", "seems", "servers", "solving", "tests", "these", "things", "thousands", "tools", "topics", "truely", "tutorial", "tutorialhttpssoypetegithubiogolang", "tutorials", "types", "unit", "university", "using", "vscode", "was"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "id": "fe9b5748-26d3-46e6-8c3d-527d250fae7b", "status": "completed", "error": null, "text": "Hi, my name is Mariah Peterson. I'm really excited to be talking to you today at Comp 42 and I thank you all for tuning in to my talk. We're going to be talking today about how to go from zero to hero when learning how to code using go. Just a little bit of background about me I currently work as a data engineer at a software company based out of Lehigh, Utah. It's called Weave. I am also a board member of the Forge foundation, nonprofit where we sponsor local events, conferences, meetup, et cetera, for people in the tech community. I am the mother of two beautiful dogs and you can find me on Twitter, GitHub, LinkedIn, but most easily on Twitch where I do streams multiple times a week on anything and everything that I have learned. New technologies I do learn and I love to just meet new people and chat and answer questions on there. So best place to reach out to me, definitely Twitch. Let's talk a little bit about go. So go is a great, wonderful, amazing programming language. People choose it because it's fast, because it's reliable, because it's compiled, it's super stable, super scalable, has multiple threads. It's amazing. Everybody under the sun uses it. It has a great community. It's the best language in the world. Everyone should use go. But for me, go was my very first programming language. Well, my very first professional programming language. I learned it at my first job, my very first tech job. And if anybody ever asks me, I say my first programming language was Go, which is very, very uncommon. Go and all of its learning materials are really kind of centered on people who've programmed before things is just a little bit, a snapshot of what you can find on the resource section of the Go website. And it's really based for people who have used a command line before, who understand functions and type and all of the basic structures aligned with programming. And so it's very easy to get into go and to read use go if you've programmed before, but because a lot of the tools are based out of the command line, because it's a compiled language and it doesn't really have a lot of learning tools that are built into the web, it's not super accessible to people who have never programmed before. Or in other words, there's a really high barrier of entry for getting into go, which in my opinion is the best programming language, super readable and just ideal first time programmers. So essentially what people end up doing when these want to learn go is they either have learned before and they'll go find some online quick tutorial, go through syntax and these, they can just dive intro the code and that's really easy, super open sourced, good for everybody else. But if you have never programmed before, you usually end up coding to udemy or udacity a boot camps and you're spending tons and tons of money to get the skill of programming before you can learn. Go. And for some people this presents an conditionals barrier to entry, where they have to put in money, research and effort to find quality courses to gain skills when they don't always have that. They might be coming from low income backgrounds, they might be working full time jobs, they might be single parents of children, and they just don't have time to go to school, or they might not have the extra resources to pay for a course. And so I'm a really huge proponent of something I like to call open source learning, or that idea that people who have the skill, people who have spent time learning, can share their knowledge in a way that's more similar to how we interact day to day. We always look for articles that are free, we look for examples that are for free, or tutorials that are free. And once you're in the industry, that's super easy to do and glean skills from, but if you're just coming in, that's really hard to do. And to be frank, it's quite frightening. So coming from that experience, these go ins, my first language, and really being a proponent for this open source learning, I put together a nice little tutorial that's currently available on my GitHub with the idea of capturing that audience who havent never programmed before and teaching them how to program using go. Like I said, there's a lot of challenges to this and it's not easy, but since it is open source, since it's free for everyone to access, we want to have multiple contributions and everybody who's ever wanted to share that knowledge can come in and participate, write some lines of codes, write some example, and really help people overcome the barrier of entry to not just go, but programming in general, and have free resources to learn and to grow and to gain access to good jobs and available income. So just really quickly, I plan on kind of running through a little bit of my strategy, the way I approached it, the way I approached it in relation to go, as well as into learning programming for the first time. And then we'll talk a little bit about some pitfalls, some hurdles, some stuff that's specific to go, and then how anybody listening can get involved in not only creating the course, but also taking it if they want to help out in that nature. So the first section is just can essential intro to programming. Normally, the first project you do in any programming is considered a hello world project, right? Where you just get the program up and running and it just prints out a little hello world. But with go, you have to install a binary, you have to make sure it's set up. You have to get your go environment set up, you have to have a gopath set up on your command line. You have to know how to run all the go tools. And so that barrier for entry for someone who's never programmed before gets higher and higher. So what we tried to do with that is using some online tools like go playground or go play space, in addition to being able to embed those in a site, we're kind of removing, abstracting out the tools and going through things that are much easier. Things like what is a function, what is a package, what are main functions, types, certain organization elements and things. You need to know just the basics, removing all of the necessities of go and just going into it. So we start with your essential hello world program, right, where we just go on to a site and just press run and see the code come up. And we'll just start dissecting what each piece of that code means, so that they can get used to reading code and understanding what's there. The next thing is types. Now, types are very essential to go it ins, how we navigate and manipulate data by creating new types, by using existing types, and by parsing the data through it, right? So we're going to introduce what's an int, what's a string. These are all things that people are familiar with, right? They know what numbers are, they know what words are, these know what letters are, they know chat. Chinese characters are characters, but we havent to introduce that in a way that they now know what the syntax is for programming, right? Know what a byte is? It's just a little fragment of information, right? And a string usually is the text that we see. Ints or numbers. We have floats and doubles, floats mostly, and go and ways to use these numbers and store these numbers to preserve certain types of information. Things that the words, they might not be familiar with, but these concepts everybody gets just from general life. The next thing we want to kind of dive into for somebody who's never programmed before now chat, we know how it's structured. Now that we know how to save data and use data, is kind of the methodologies that we use when telling a program what to do. We use functions for this, right? But now we're teaching people that they can tell, programs tell a computer essentially how to do certain things, and that's new. They've never told these computer what to do thing. They just typed buttons. So there's two aspects we need to work on here, not just defining functions, but how to use them, right? Like talk about the arguments and parameters we take and talk about what we return. Talk about putting logic inside the function and then calling that function inside a main function so that it can be used efficiently and that these can really gain confidence in things. Idea of programming and manipulating code and giving commands and expecting certain kinds of outcomes. The next things that I think is really important and super beneficial is to understand the idea of conditions. Really. This is control flow in these more like computer sciency term. But I didn't want to use control flow because that's a computer sciency term, right. We're trying to keep it in a way that's a little bit less of a barrier to entry. So this idea of programing a condition that has to either be met or not met. So we're doing things like if else statement switch, introducing the idea of boolean conditions that can be met or not met, right? That idea of true or false, yes or no, and that different kinds of functions or different kinds of logic can be run based on meeting these conditions. Right. Now, this is where we start to really make our programs dynamic or smart, or when we start to really gain confidence as a programmer and do things. So by going in ins order and then hitting the conditionals right after the functions, they really start getting a little bit of momentum, a little bit of comfort in the idea chat. They can then tell a program what to do and how to do it. And these, the last thing is, I think, kind of like the meat and potatoes of everything is this idea of running loops, or being able to repeat your code a certain amount of times or an unknown amount of times in order to get a certain result, you do honestly have to have a basics of what types are and functions, how we run functions and loops, how we put loops in functions, and as well as conditionals and how they're met. Before we can really leverage this idea of repeating code effectively, right? Like we may need to count over a slice, which is a type we have defined, or we may need to iterate through an array, or iterate through a map, or run your while style loop until a certain condition is met and until we've had all the background to get loops, we really can't start to write just basic programs that do simple tasks. But now after hitting all of these bullet points in just kind of this basic digest, what is programming and how we do it, regardless of code, we can really start getting into the things that make it, that are required to be an efficient go. Programmers. Yes, we've been doing all of this stuff in go, but we've been using online playgrounds and things that kind of abstract a lot of the go tooling. And now that they're familiar with programming and have a little bit of consider, it's time to dive into a little bit more of like the developer side of tooling and things that make go really have an advantage. When I started to code, the thing I was most scared of was honestly writing in the terminal. I thought I was going to click a wrong button. I thought I was going to nuke my computer and really not be able to go anywhere from there. And to be fair, once you have a basic of programming, like 90% of the code I write every day at work can be done just with a lot of basics. But I have to do a lot of things in the command line to be able to run the code, to be able to test the code and do all those other ins of things to really be an effective developer. So even though they know the basics, they're not even ready to start developing and go. And so that's why this section comes into play, right? Like using your terminal, using your command line, and becoming comfortable with the developer environment. Something that we often take for granted, but is really a massive barrier to entry. I know lots of people coming out of boot camps who have never touched a terminal and chat really is not going to let them get a job. They're really kind of at a disadvantage as far as being able to work efficiently and effectively. So in this idea of touching the command line or learning from the command line, there's so much to learn here, but just high level basics, enough to be able to just get started in your environment and go forward. Most important, of course, like running bash commands, simple things like PWD, CD, CP, MVRM, RM, RF. Right? You're removing, you're moving, you're copying, you have to be able to navigate and copy paste and do all those kinds of things. It's like really critical for that. But when you have a low barrier at entry, you end up with two things. You end up with people on Mac or Linux environments and then people on Windows environments. And those are two totally separate things. I havent never programmed in a Windows environment. But some people only have Windows computers, right? Like we're trying to lower the barrier of entry and that means using whatever tools they have at their disposal. And that might be $100 Chromebook. That might be. I bet we would need the section for Chromebooks. See, things is open source learning. So if you need to go add the stuff for Chromebooks, feel free to go add that to the bash session, right? But they might have an old Windows machine, they might be on a Mac laptop that they used. INS design school. We really want to be able to have resources for everything and go super basic, super high level, let them be able to navigate, right? Create directories, organize their code, and do things that are just considered smart practices. Next thing, git source control is important. And if they're going to get a job, they have to be able to put code on GitLab, BitBucket or GitHub to use as a resume to say, hey look, I've done projects. Hey look, I've contributed to open source projects. Hey, I know how to keep track of my code in an organized manner so that I don't ruin everybody else's commits, right? It's like essentially anymore, to work on a team you have to be able to manage source control, and that's just super basic, super fundamental. And consider how dependencies are managed in go. You really can't do a whole lot without Git and understanding the idea of versions and how to manage that after they've gotten kind of familiar with git bash and that stuff. Time to now install go. This is pretty easy and straightforward, but there are things you have to do, like setting up a path so that the binaries can be accessed, right? You don't have to have a go path. You do have to have a go path so that they know where all of the source folders live and creating those things and having them persist in a way that they can be easily accessed as part of your environment. And last but not least, choosing that ide that's best for them, right? Like I will always recommend vs code for somebody who's never done it before. I use Vim. Some people go way out of their way to use Golan to have a curated environment that was, and these developers need to know what's out there, what's best for them, and how they can work most efficiently. So they might be in a full ide like Golan, or they might be writing really simple scripts in Atom or emacs or whatever works best for them. And so now that we've got, with those basic fundamentals out of the way, you're learning go get rid of that barrier to entry. It's really time to start writing go code, right? You might not be a go developer, you might be new to go, I'm a go developer. And any developers really just want to write code, right? Just want to write something so really basic. In the standard library, you don't have to go external at all. You can just write your simple go server, right? Write up an API, throw messages on it, see the messages print out, come back, and you can do all of those things so quickly and you can save it ins git, and it can become like one of your first example projects, really easy and just kind of like reestablish the things you learn ins typing. Honestly, APIs are how we communicate through almost everything, right? We do so much API connection, it's a really fundamental skill and it just boosts up that confidence, right? And so now you've gone through three sections, right? You've learned how to code, you've learned the basics of a terminal, and you've really produced the first Go program. Now they can say that barrier to entry has been erased, they're now go developers and they can start building projects. And so the next section really of the tutorial or what I had in mind, right? We're going from zero to hero, not zero to I can write code. And so that means you have to start developing skills that make you employable, right? You have to start doing things that make you comfortable, not only in the go ecosystem, but in the ecosystem where you are maintaining projects, where you're deploying code, where you're working with other people, and where you're contributing to larger projects, right? So those are other kinds of things we have to start tackling, or at least introducing, right, in this idea of the tutorial. And nothing like super complicated, really easy. But my thought was, first thing first, we'll start with what has historically been a rough spot and go dependencies, right? Like how do we use libraries outside of the standard library, how do we bring them in? Kind of introduce this idea of what the Gopath ins, how they're managed, doing versions. Go modules are really easy to navigate, really easy to add, to start up to use. You have an entire libraries at package go dev of modules. You can use the docs forum and start pulling things in, right? Using libraries that aren't part of the standard library. That could be the testify library. They could use a muck server. Me, I really like machine learning libraries. None of that's part of the standard library. So I pull in lots of machine learning libraries and use those in. So just build a tiny little project that doesn't use something from the standard library that requires go modules and that can really get them used to things. Idea of looking for tools that somebody's already made, right? Like these next obviously is going to be contributing to open source, right? If there's not a library that does chat you need, then create that library and maybe somebody will use it later. The next important thing is this idea of checking your code. People who are in the go ecosystem tend to be very, very particular about this. People I interact with or have always been very particular about it. First one is linters go. The standard library has like govet built into it, has the format tool, but thumped built into it. It has the import tool built into it, and the community has really piled on that and they've established really strict linting guidelines, just as de facto standard in the community for maintaining certain kinds of code that can be read by any go developer that can last forever, that anyone can get up and use. And it's oftentimes and companies will implement linters, right. For certain coding and standard practices. So it's a good idea for them to get familiar with linting, get familiar with the idea of coding standards, and to be able to use that and leverage that to the best of their need, right? Whether it be in the CLI or in their text editor. A lot of people do it in CI CD. We're not quite there yet, but next, testing, right? This idea that you can write unit tests, that you can test your code, that you can validate that certain pieces of logic of your code, right? Things is where we like one of my favorite concepts when it comes to unit testing, ins writing testable functions, right? You have business logic that you want to be able to test, right? So that really helps you simplify your functions, make them compact and make them handle one piece of logic that can be easily tests and chat. You can have multiple test cases for, and then you can test using the Go test tool that's part of the standard library. Then you could start running the test coverage tool suite that also exists in the standard library and really do things that are just cool. You'll look at Go libraries and they'll tell you how much of it has test coverage. And this is all built into the standard library. These are just essential things that come part of Go that they need to be familiar with to really be effective. Go developers and then tacking intro that writing a project will allow them to implement tests to use test coverage, and writing a project that will let them branch kind of off of this idea of APIs and grow bigger. I actually did this project myself recently on my Twitch stream, and it was really good. It was a really good way for me to practice testing. It was a really good way for me to explore do I want to use an external library? Do I want to write it to myself? It's really simple web crawlers, super basic, almost as basic as an API, but it's a really good way to illustrate these concepts and use these tools and just get familiar with the things around you. And probably the last thing that I put in here, maybe not necessary, but just this idea of deploying a service, right, like deploying is not hard, but it's also not trivial. And with the Waco works, right, you're using binaries or executables or little compiled functions, and it's not hard to be able to just put that in a little Docker container. Get that docker container running on your machine, put your dependencies in Docker and start using Docker and Docker files. It's really basic. I didn't really go much farther than that because then you get into, well, do you want it on a server? Do you want it on a website? Are you doing different kinds of deployments you want on the cloud? And it was like at a certain point they just need to experiment and do it themselves. But Docker seems pretty fundamental and everywhere I've looked it's almost standard anymore. And I feel by this point, once you get familiar with Docker and how it works, you can put a service, run it through a docker container, you're pretty employable. I've seen people with fewer skills trying to get go jobs, so it's a good step out there and it's definitely a way to get forward. And like I said, there's probably a lot more we can get into with deploying a service. And that's why this is an open resources tutorial, right? Anybody can contribute. They can contribute things that are required, things that are optional, things that are good to learn, and little tutorials that can help a person really gain, develop and augment these skills. So if you've liked what you've seen so far, I encourage you to get involved. Feel free to reach out to me, look at the code on GitHub, really do anything. You can sponsor the project on GitHub, right? That way anybody who works on that project will get funded, get a little bit more motivation. They can work on it with more of their time, right? Go ahead and just take the course, run through it, no issues that have come up. Feel free to reach out to me on Twitch. I do a couple of times a week. I've been trying to get on there and work on this course, really get it out there. The next big thing will be implementing the go playground into a site so that the person can start doing those intro to code things right there with the text. They don't have to go to a different site, they don't have to export to the GoPro ground, they don't have to watch a video. They can just read and interact and go from there. And that's my talk. Thank you so much for listening to my ideas of using go as a first time programming language. I really hope that I might have inspired some of you to get involved and contribute to open source learning through courses through meetups. Feel free to contribute to this course on GitHub. I can use all the help I can get and to really enable people to start developing and getting more tools. And I hope to see you guys again soon at another conference on Twitter, on Twitch or wherever, and enjoy the rest of the conference. Bye.", "words": [], "utterances": null, "confidence": 0.962807488718404, "audio_duration": 1463.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Mariah Peterson talks about how to go from zero to hero when learning how to code using go. Currently works as a data engineer at a software company based out of Lehigh, Utah. Best place to reach out to her is Twitch where she streams anything she has learned.\n- My first programming language was Go, which is very, very uncommon. Go is a compiled language and it's not super accessible to people who have never programmed before. I'm a huge proponent of open source learning. I put together a nice little tutorial that's currently available on my GitHub.\n- The first section is just can essential intro to programming. You need to know just the basics, removing all of the necessities of go and just going into it. The next thing is types. These are all things that people are familiar with.\n- The next thing we want to kind of dive into for somebody who's never programmed before now is how it's structured. Talk about putting logic inside the function and then calling that function inside a main function so that it can be used efficiently.\n- You have to understand the idea of conditions. This is where we start to really make our programs dynamic or smart. Like using your terminal, using your command line, and becoming comfortable with the developer environment. We're trying to lower the barrier of entry.\n- Go modules are really easy to navigate and start up to use. Using libraries that aren't part of the standard library. The next important thing is this idea of checking your code. Get familiar with linting and unit testing. And the idea of deploying is not hard but not trivial.", "auto_highlights_result": {"status": "success", "results": [{"count": 1, "rank": 0.07, "text": "Go libraries", "timestamps": [{"start": 1231548, "end": 1232114}]}, {"count": 1, "rank": 0.07, "text": "certain things", "timestamps": [{"start": 515432, "end": 516514}]}, {"count": 1, "rank": 0.07, "text": "go jobs", "timestamps": [{"start": 1346592, "end": 1347350}]}, {"count": 1, "rank": 0.06, "text": "simple things", "timestamps": [{"start": 790002, "end": 790582}]}, {"count": 1, "rank": 0.06, "text": "essential things", "timestamps": [{"start": 1236812, "end": 1237590}]}, {"count": 1, "rank": 0.05, "text": "little compiled functions", "timestamps": [{"start": 1299232, "end": 1300582}]}, {"count": 3, "rank": 0.05, "text": "first time", "timestamps": [{"start": 192374, "end": 192906}, {"start": 349808, "end": 350474}, {"start": 1433212, "end": 1433926}]}, {"count": 1, "rank": 0.05, "text": "go code", "timestamps": [{"start": 959514, "end": 960222}]}, {"count": 1, "rank": 0.05, "text": "codes", "timestamps": [{"start": 322008, "end": 322238}]}, {"count": 1, "rank": 0.05, "text": "little tutorials", "timestamps": [{"start": 1364788, "end": 1365694}]}, {"count": 1, "rank": 0.05, "text": "source projects", "timestamps": [{"start": 871416, "end": 872270}]}, {"count": 1, "rank": 0.05, "text": "new people", "timestamps": [{"start": 81276, "end": 81702}]}, {"count": 1, "rank": 0.05, "text": "other people", "timestamps": [{"start": 1045888, "end": 1046506}]}, {"count": 1, "rank": 0.05, "text": "certain types", "timestamps": [{"start": 483458, "end": 484018}]}, {"count": 2, "rank": 0.05, "text": "certain kinds", "timestamps": [{"start": 551386, "end": 551978}, {"start": 1158442, "end": 1158986}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}