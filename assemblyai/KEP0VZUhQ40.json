{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/4a366d73-7e7e-496f-bf7d-500a4b2073fc", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["agreements", "applications", "applying", "bala", "because", "best", "between", "but", "by", "can", "carry", "challenges", "chaos", "chapter", "commercial", "companies", "conf fourty two", "confidence", "continue", "cse", "customers", "engineers", "experiences", "failures", "fits", "instilling", "largest", "learnings", "microsoft cse", "monitoring", "narmatha", "narmatha bala", "notforprofits", "objectives", "observability confidence observability practices", "practices", "practitioners", "problem", "process", "project", "projects", "properly", "runs", "senior software engineering manager", "sharing", "slas", "slos", "software", "suited", "teams", "technologies", "traditional", "transfer", "wants"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "id": "2fc82805-b9a4-4273-a6e3-d7397fba6a02", "status": "completed", "error": null, "text": "Jamaica make up real time feedback into the behavior of your distributed systems and observing changes exceptions errors in real time allows you to not only experiment with confidence, but respond instantly to get things working again. Cse hi, I'm Narmatha Balasundram. I'm a software engineering manager with a commercial software engineering team at Microsoft. In today's talk, we are going to see how to increase confidence as you're doing your chaos testing, and how having good observability can help take the chaos out of the chaos testing. So what is chaos engineering? Chaos engineering is the art of intentionally breaking the system with the sole purpose of making the system more stable. So in a typical chaos testing environment, we start with a steady state, understand how the system behaves during steady state, and come up with a hypothesis. So if we say the system during high traffic is supposed to scale, then we do best to see if the system behaves as we intend it to behave. And when we find that the system does not behave as we intended to, then we make changes and then do the testing again. And this is a very iterative process. So what is observability? Observability is the ability to answer new questions with existing data. So having observability while doing chaos testing helps us understand what the base state is. How does normal look for the system, and what the deviated state is when there is an unusual activity or unusual events or response in the system, how does that change things? The chaos engineering without doing observability will just lead to chaos. In the talk today, we'll see how we can take that chaos out of testing observability. So what is the true observability in the system and what are the different attributes. Secondly, we'll see what are the golden signals of monitoring and how we can help have actionable failures. Number three, we'll see what is service level agreements and service level objectives, and how can we use this in our chaos testing to understand how the system is behaving. And lastly, monitoring and alerting, identifying based on the service level objectives, we will see how monitoring can help during chaos testing and even before we start the chaos testing process. So the true observability of the system are the things are made up of the things, what the different attributes of the application look like. So we talked about a little earlier, we talked about what chaos testing is, and it is about deviating what the normal looks like. And when the testing is run, what does the deviated state look like. So for us to understand normal, we need to understand what does the health of the components of the system look like when there are requests going against a service and it gives a 200 okay, and that means the service health of the API is doing well. And when there are additional stress that is going on in the system, the resource health of the system could also be constrained. Things like CPU or disk, iOS or memory for that instance. That could be a constraint. And additionally, with these two looking at what the business transaction KPIs are. So let's say if we are looking for number of logins per second, or if we are looking for the number of searches per second, then these are the key business indicators that we should look for as we are looking at these data across the different components. Now, all these data collected by itself, service health, then resource health and the business transaction KPIs separately, does not help in giving the holistic view of the system. Creating a dashboard and having the dashboard represent these values that the different stakeholders of the business are looking for is what makes it cohesive. And let's say at the time of chaos testing. For an SRE engineer coming in, what are the key metrics that they should be aware of and they need to look at? Creating a dashboard for that particular stakeholder or for the SRE teams here makes much more sense than just throwing everything into a combined dashboard. Alerts. Alerts are the end result of a dashboard. So let's say we see a change in the current state from into an abnormal state, then creating alerts and identifying the parties that needed to be alerted on each of these scenarios are very important. We talked about what these different attributes are, but how do we ensure that these attributes are what is getting measured? So Google's SRE team came up with the four golden signals, namely traffic latency errors and saturation. So let's take the example of a scenario where there is a high stress on the system. It could either be because of increased traffic, or it could be because of the vms being down. So we start off with a normal tech, normal. The traffic, for instance, in a normal scenario looks like 200 seconds per request per second, increasing the traffic during the chaos, testing to, let's say, 500 requests per second, or even 600 requests per second. How does that affect the latency? Latency during a normal state looks like 500 milliseconds per request. With an increased traffic, how does that deviate from what the normal state looks like? And how does traffic and latency play a role in errors? Are you seeing more timeout errors? And because of the high traffic that's coming in into the system, are the resources like the cpu, the memory and the disk IO, are they constrained? So these are the key things to watch out for as you're looking at the signals that's coming in, in the system. So looking at the, we talked about the attributes and we talked about what the golden signals are. How do we identify what these actionable failures are and what makes a good actionable failure? The actionable failure is something where the key to the recovery time is very minimum. So from the time you identify a problem to the time it gets recovered needs to be minimum. Meaning any logs that we collect in the system that contain information should have enough contextual information in it, so we get to the problem area faster. Sometimes when logs are built, and this reminds me of one of the scenarios that I had in my previous experience, where just building can observable system meant creating logs, right? We've all done that, where we just go in and log, and we were feeling pretty confident that we did all the good things. We had good logs, we had alert system in place, things seemed fine. And then we realized, as we started looking at the production scenarios and production troubleshooting, that the logs are very atomic and with no correlation between the logs from different components or having no contextual data, it took longer for us to identify what may have caused the issue. And a point for you to remember is logs. There's a lot of logs, and it's just huge volume of logs. And as you're thinking about what your observability looks like, just make sure that these logs are ingested well. And there is good analytical engines at the back end that can actually help crunch through these logs and give the data that you're looking for. Next, we look at service level agreements and objectives. So slas are service level agreements. They are typically agreements between two parties about what the services are going to be and what is the uptime and the response time between the services look like. For instance, let's say an agreements between a mapping provider and let's say a right sharing application. So the kind of agreement that they would get into would be that the mapping provider can come up with the agreements that they say that the maps would be available about 99.99% of the time. And when they make an API changes, it could be something like they give a two week notice to the right sharing company. And this is what is called as an slas. And so when the mapping provider company takes it back, they need to understand what do they need to do to be able to meet the slas. Now, this is the slO, which is a service level objective. So what are the objectives that a team must hit to meet the agreement that they just made with their client? So this boils down to what are the things that they need to monitor to be able to meet the agreement that they just had. So we cannot talk about slas and slos and not talk about error budgets. So error budget is that maximum amount of time that a technical system can fail without the consequences of having any contractual obligations. So let's say if the agreement is about 99.99%, the error budget for the applying provider companies is about 52 minutes per year. So that is the maximum amount of time that the technical system can fail. So we'll look at how knowing what these slas and slos are can help us with our chaos testing. So number one, it identifies before the chaos testing even starts. It helps to understand what does critical issues for the user experience look like. Let's say if it's a streaming providing company, provider company, and then they look at there's a little bit of buffering as the users view the content. Is this something that needs to be identified as a critical issue, or is this something that can be, that resolves by itself? So, knowing what the criticality of the issue is helps for us to be able to make a decision on identifying to fix it or not. Let's say if it's an issue where it is very intermittent and then the reload of the page fixes it, or it's very short lived. Right? So these are the scenarios that helps with chaos testing. So during the chaos testing, we want to be careful when to do the chaos testing. We do not want to be introducing more uncertainty in the network when the user experience is deteriorating or when there's a system performance and things are being slow, we want to be very informed about when we want to start doing the chaos testing. And once the chaos testing starts, we measure how the system is doing with the chaos and without the chaos and what the difference is. And this helps us to increase the load in the system, because we are seeing a real time feedback on how the system is doing by looking at the signals that we are monitoring using our golden signals. And then we figure out, is it good to tune up the traffic or are we hurting the system? And should we be turning back the traffic? Then comes our monitoring and alerts. So monitoring and alerts are a great place to get an overall view of how we are doing. How are the attributes doing with respect to the golden signals? And also, when things do go bad, what do we do with those? So while we are doing the chaos testing, when the system is bound to break, bound to deteriorate, we evaluate what are the missing alarms? Are the alarms even in the right place? Are we looking at the right things or are we just looking at symptoms and they are not truly the causes? Are we measuring the right things? Are we looking at the right latency, or are we looking at the right error numbers, for instance? And then once we do that, then we take a step back and we look at the thresholds of the alerts. And this is a very key component because sometimes the alert fatigue, if the threshold is too low, then that may result in an alert fatigue. Too many alerts, folks that are responsible for fixing the alerts may become immune to the fact that there is an alert. So the threshold of the alerts are key. And lastly, the alerts need to be sent to the right team. So we need to identify who owns or who is responsible for fixing the alerts for each of the segment. So doing this practice while doing chaos testing helps us to make sure that all these different things are aligned when we start seeing things going bad in production. We've already done this, we've already tested this. We know when things go bad. How do we identify things and how do we fix those things? And are these going to the right folks? As we wrap this up, here are a few closing thoughts with observability. I would suggest, depending on where you are in the observability track, I would say always start small. Start with auto instrumentation that's available out of the tool that you're going to use, and start small and keep adding information on top of it. And in our distributed environment, like how our tech stack is built, always have distributed logs that have information correlated with each other, and there are sufficient traces so you could track how things are moving along. And there is enough context for the logs as you're logging them. And secondly, iterate instrumentation. It's a rinse and repeat process. And there are things you discover that needs to be added. And that is all right. As long as we do these as an iterative process, we learn stuff. And as we learn stuff, go and make it better. And lastly, celebrate learnings. So once you figure out something doesn't work, it's quite all right. Go back in and fix it again with that. I just want to say thank you for listening through this presentation and I'm very happy to be a part of this. Thank you. Bye.", "words": [], "utterances": null, "confidence": 0.94879871312527, "audio_duration": 919.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Narmatha Balasundram is a software engineering manager with a commercial software engineering team at Microsoft. In today's talk, we will see how to increase confidence as you're doing your chaos testing. Having good observability can help take the chaos out of the chaos testing, he says.\n-  chaos testing is about deviating what the normal looks like. For an SRE engineer coming in, what are the key metrics that they should be aware of? Creating a dashboard for that particular stakeholder or for the SRE teams makes much more sense than just throwing everything into a combined dashboard.\n- Slas are service level agreements between two parties about what the services are going to be. Error budget is the maximum amount of time that a technical system can fail. It identifies before the chaos testing even starts. Monitoring and alerts are a great place to get an overall view of how the system is doing.\n- As we wrap this up, here are a few closing thoughts with observability. Always have distributed logs that have information correlated with each other. And secondly, iterate instrumentation. As long as we do these as an iterative process, we learn stuff.", "auto_highlights_result": {"status": "success", "results": [{"count": 19, "rank": 0.08, "text": "chaos testing", "timestamps": [{"start": 76268, "end": 77266}, {"start": 82284, "end": 83170}, {"start": 93798, "end": 94566}, {"start": 129772, "end": 130770}, {"start": 173688, "end": 174622}, {"start": 188076, "end": 189058}, {"start": 190768, "end": 191814}, {"start": 204772, "end": 205546}, {"start": 289612, "end": 290622}, {"start": 362644, "end": 363658}, {"start": 617688, "end": 618542}, {"start": 621688, "end": 622366}, {"start": 667048, "end": 667950}, {"start": 668744, "end": 669890}, {"start": 674328, "end": 675242}, {"start": 691504, "end": 692390}, {"start": 693168, "end": 694022}, {"start": 741648, "end": 742550}, {"start": 812916, "end": 814190}]}, {"count": 1, "rank": 0.07, "text": "alert system", "timestamps": [{"start": 458388, "end": 459182}]}, {"count": 1, "rank": 0.07, "text": "observable system", "timestamps": [{"start": 445488, "end": 446410}]}, {"count": 3, "rank": 0.07, "text": "chaos engineering", "timestamps": [{"start": 83932, "end": 85010}, {"start": 85090, "end": 86114}, {"start": 144048, "end": 145190}]}, {"count": 20, "rank": 0.06, "text": "things", "timestamps": [{"start": 19332, "end": 19534}, {"start": 143120, "end": 143642}, {"start": 195312, "end": 195562}, {"start": 196528, "end": 197098}, {"start": 237106, "end": 237414}, {"start": 396352, "end": 396602}, {"start": 455172, "end": 455566}, {"start": 459844, "end": 460238}, {"start": 576088, "end": 576274}, {"start": 685692, "end": 686022}, {"start": 736716, "end": 737030}, {"start": 756036, "end": 756350}, {"start": 761972, "end": 762366}, {"start": 816536, "end": 816754}, {"start": 819064, "end": 819746}, {"start": 826396, "end": 827000}, {"start": 829666, "end": 829894}, {"start": 831052, "end": 831640}, {"start": 876172, "end": 876422}, {"start": 888092, "end": 888294}]}, {"count": 1, "rank": 0.06, "text": "good logs", "timestamps": [{"start": 456196, "end": 457194}]}, {"count": 3, "rank": 0.06, "text": "service level agreements", "timestamps": [{"start": 168200, "end": 169390}, {"start": 501092, "end": 502122}, {"start": 505620, "end": 506762}]}, {"count": 3, "rank": 0.06, "text": "real time", "timestamps": [{"start": 5810, "end": 6382}, {"start": 13412, "end": 14046}, {"start": 705572, "end": 706382}]}, {"count": 2, "rank": 0.06, "text": "real time feedback", "timestamps": [{"start": 5810, "end": 7002}, {"start": 705572, "end": 707290}]}, {"count": 2, "rank": 0.05, "text": "service level objectives", "timestamps": [{"start": 169880, "end": 171246}, {"start": 182364, "end": 184470}]}, {"count": 1, "rank": 0.05, "text": "good observability", "timestamps": [{"start": 79020, "end": 80210}]}, {"count": 2, "rank": 0.05, "text": "service health", "timestamps": [{"start": 225608, "end": 226382}, {"start": 268520, "end": 269282}]}, {"count": 2, "rank": 0.05, "text": "increased traffic", "timestamps": [{"start": 346336, "end": 347366}, {"start": 374728, "end": 375970}]}, {"count": 1, "rank": 0.05, "text": "chaos testing process", "timestamps": [{"start": 190768, "end": 192410}]}, {"count": 1, "rank": 0.05, "text": "more timeout errors", "timestamps": [{"start": 385116, "end": 386386}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}