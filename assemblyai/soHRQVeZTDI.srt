1
00:00:00,410 --> 00:00:06,174
Jamaica make a real

2
00:00:06,212 --> 00:00:10,618
time feedback into the behavior of your distributed systems and observing

3
00:00:10,714 --> 00:00:14,538
changes exceptions errors in real time allows

4
00:00:14,554 --> 00:00:18,858
youd to not only experiment with confidence, but respond instantly

5
00:00:18,954 --> 00:00:25,360
to get things working again cost

6
00:00:47,150 --> 00:00:51,366
everyone and welcome to this talk. Let's build at zero cost inviteonly

7
00:00:51,478 --> 00:00:55,102
website with nextjs and airtable so

8
00:00:55,156 --> 00:00:58,270
before we get started, let me tell you that the slides are already

9
00:00:58,340 --> 00:01:02,394
available online. You can get them by either scanning this QR code or visiting

10
00:01:02,442 --> 00:01:06,078
the link that you see down there in the slide. And the reason why I

11
00:01:06,084 --> 00:01:08,818
like to share the slides first is because I'm going to be showing you a

12
00:01:08,824 --> 00:01:12,306
bunch of code examples youd might be having questions after the

13
00:01:12,328 --> 00:01:15,714
talk, so it's just easier. It's just an easy way to

14
00:01:15,752 --> 00:01:19,186
get all the material if you enjoy this talk. But don't

15
00:01:19,218 --> 00:01:23,030
worry, you'll have the link to the slides even at the end of this presentation.

16
00:01:23,770 --> 00:01:27,190
So what's our mission for today? Today we want to build this

17
00:01:27,260 --> 00:01:30,586
inviteonly website and to understand a little bit

18
00:01:30,608 --> 00:01:34,374
better what that means, lets me give you literally a 15 seconds

19
00:01:34,422 --> 00:01:36,620
demo of this particular idea.

20
00:01:37,470 --> 00:01:41,242
So you can see in this particular slide that we

21
00:01:41,296 --> 00:01:44,506
have on the left side, kind of a spreadsheet

22
00:01:44,538 --> 00:01:47,774
which acts as our database, and there are different

23
00:01:47,812 --> 00:01:52,026
records. Every record has a unique id, and we can use that particular unique

24
00:01:52,058 --> 00:01:55,854
id as a query string parameter here on the website on the right hand

25
00:01:55,892 --> 00:01:59,586
side. And every time we change that query string parameter, you can see that the

26
00:01:59,608 --> 00:02:03,422
invite changes a little bit. We can see in this case Rafaelo.

27
00:02:03,486 --> 00:02:06,994
Before there was a lo Michelangelo and now there is a lo don

28
00:02:07,032 --> 00:02:10,834
adelo. So basically you can have URLs that are customized

29
00:02:10,962 --> 00:02:14,614
for specific people. And if you provide the wrong invite code or

30
00:02:14,652 --> 00:02:18,406
you don't provide an invite code, you shouldn't be able to see anything. So this

31
00:02:18,428 --> 00:02:21,706
is just a simple way to have a database of people that we want to

32
00:02:21,728 --> 00:02:25,414
invite to an event and build a website that allows

33
00:02:25,462 --> 00:02:29,306
only these people to be able to access all the information related to

34
00:02:29,328 --> 00:02:30,700
that particular event.

35
00:02:32,990 --> 00:02:36,462
Okay, so what are the requirements for building something

36
00:02:36,516 --> 00:02:40,314
like this? Imagine that we are actually building this because we really want to host

37
00:02:40,362 --> 00:02:43,422
a particular personal event. We want to invite a few people.

38
00:02:43,556 --> 00:02:46,810
So we just, as software engineers, we want to have a

39
00:02:46,820 --> 00:02:51,090
custom cool website. But of course we don't want to be spending months in building

40
00:02:51,160 --> 00:02:55,026
all of this. So the idea is that we want to iterate quickly. We need

41
00:02:55,048 --> 00:02:58,834
to have a solution that is very simple to host, very simple to maintain

42
00:02:58,882 --> 00:03:03,158
and update. We want a very lightweight back end and

43
00:03:03,244 --> 00:03:06,838
also imagine that you are organizing this with a bunch of friends,

44
00:03:06,924 --> 00:03:10,822
so probably you want to be able to share with them the entire database

45
00:03:10,886 --> 00:03:14,534
because maybe they want to add people to the invitation

46
00:03:14,582 --> 00:03:17,914
list. They want to see whoever is saying that

47
00:03:17,952 --> 00:03:19,740
is participating to the event.

48
00:03:20,510 --> 00:03:23,774
So we need also a back end solution that's very easy to

49
00:03:23,812 --> 00:03:27,294
access for nontechnical people. And now the best

50
00:03:27,332 --> 00:03:30,942
part, we probably want to build all of this in a cheap way and

51
00:03:30,996 --> 00:03:33,700
aust it if not cheap for free.

52
00:03:34,390 --> 00:03:38,382
So let's see if we can find a solution that satisfies

53
00:03:38,446 --> 00:03:39,810
all of these requirements.

54
00:03:41,590 --> 00:03:44,738
But before we get into that, I didn't introduce myself,

55
00:03:44,824 --> 00:03:48,166
so let me do that. My name is Duchano and I am

56
00:03:48,188 --> 00:03:52,594
a Microsoft MVP and a certified AWS solution architect professional.

57
00:03:52,722 --> 00:03:56,038
I work for a company called fourtheorem as a senior architect and

58
00:03:56,044 --> 00:03:59,746
I'm based in Dublin, Ireland. One of the things that I'm

59
00:03:59,778 --> 00:04:03,414
mostly proud about in my career is that I am one of the co authors

60
00:04:03,462 --> 00:04:07,274
of this book called Node JS Design Patterns. If it's a book that you have

61
00:04:07,312 --> 00:04:11,530
read, definitely let me know what you think. I always love to hear feedback and

62
00:04:11,600 --> 00:04:14,606
if you haven't read that already, consider reading it.

63
00:04:14,708 --> 00:04:18,382
I really love to hear what you think about that.

64
00:04:18,516 --> 00:04:22,190
And feel free to connect with me. I am available in all this channel.

65
00:04:22,340 --> 00:04:25,694
So always we're looking forward to talk with people. So don't be shy.

66
00:04:25,742 --> 00:04:28,340
Feel free to reach out and let's connect.

67
00:04:30,310 --> 00:04:33,378
Okay? But fourtheorem, the company that I

68
00:04:33,384 --> 00:04:36,674
work for, it's a service company. We are mainly focused on

69
00:04:36,712 --> 00:04:40,674
cloud and AWS. We do a lot of serverless and cloud migrations.

70
00:04:40,722 --> 00:04:43,480
So if that's something that you are really interested into,

71
00:04:44,010 --> 00:04:47,654
definitely reach out to us. We are always hiring, we are always looking

72
00:04:47,692 --> 00:04:50,986
for new, interesting projects. So again, don't be shy, let's have

73
00:04:51,008 --> 00:04:53,980
a coffee and let's chat about business together.

74
00:04:55,070 --> 00:04:58,986
Okay, back to the talk. What's the agenda for today? So the

75
00:04:59,008 --> 00:05:02,474
first thing we want to do is of course choose a particular tech stack that

76
00:05:02,512 --> 00:05:05,840
could satisfy all the requirements we discussed before.

77
00:05:06,210 --> 00:05:09,646
Then we want to understand what is the data flow for this particular kind of

78
00:05:09,668 --> 00:05:12,320
application. So we are going to deep dive into that.

79
00:05:12,930 --> 00:05:15,998
We are going to be using airtable. So we are going to be discussing a

80
00:05:16,004 --> 00:05:19,982
little bit how airtable works and how can we use it as a database

81
00:05:20,046 --> 00:05:23,522
for a web application. And then we are going to be looking

82
00:05:23,576 --> 00:05:27,218
into nextjs and versailles, which are other two components that we are going

83
00:05:27,224 --> 00:05:30,582
to be using in our architecture. So we want to see how to create

84
00:05:30,636 --> 00:05:33,942
APIs with NextJs we want to also create

85
00:05:33,996 --> 00:05:37,126
a custom react hook for authentication. So we are going to be

86
00:05:37,148 --> 00:05:41,002
discussing all of that, and we are going to be seeing how can

87
00:05:41,056 --> 00:05:45,066
we allow the users to interact with our application.

88
00:05:45,168 --> 00:05:48,598
And now the user interaction can actually affect our database.

89
00:05:48,694 --> 00:05:52,038
For instance, users will be able to tell us if they are

90
00:05:52,064 --> 00:05:55,518
participating or not to our event, and when they select

91
00:05:55,604 --> 00:05:59,022
one of the options that should be immediately reflected in our

92
00:05:59,076 --> 00:06:02,318
back end system. And finally, we are going

93
00:06:02,324 --> 00:06:06,698
to be discussing very quickly about some interesting security considerations.

94
00:06:06,874 --> 00:06:10,142
After all, we are trying to build a website that by default is private,

95
00:06:10,206 --> 00:06:13,746
and only people who have access to that particular website through an

96
00:06:13,768 --> 00:06:17,926
invite code should be able to see meaningful information. So there

97
00:06:17,948 --> 00:06:21,078
are some security consideration there, and we need to make sure

98
00:06:21,164 --> 00:06:24,706
that we are not leaking any private information to people that don't

99
00:06:24,738 --> 00:06:26,680
really have an invite code.

100
00:06:27,610 --> 00:06:30,486
Okay, let's look at the tech stack. We said that we are going to be

101
00:06:30,508 --> 00:06:33,658
using next js, airtable and Purcell. Also we are coming to

102
00:06:33,664 --> 00:06:37,420
be using GitHub as a hosting for all the source code.

103
00:06:38,110 --> 00:06:42,598
So the reason why I like this combination is because next JS,

104
00:06:42,774 --> 00:06:46,126
if you know, react, it's a very nice and

105
00:06:46,148 --> 00:06:49,342
simple framework to use. It gives you the opportunity to do

106
00:06:49,396 --> 00:06:53,066
not just the front end code, but also to create APIs very easily.

107
00:06:53,178 --> 00:06:56,118
And when you use Vercel as a backend, not surprisingly,

108
00:06:56,154 --> 00:07:00,194
because nextjs is built by Vercel as well, it's very very

109
00:07:00,232 --> 00:07:04,094
easy to take your code from GitHub and ship it to production

110
00:07:04,222 --> 00:07:08,194
and then have everything working but of the box with very minimal

111
00:07:08,242 --> 00:07:11,490
configuration for what concernsafetable.

112
00:07:11,570 --> 00:07:15,254
It's a very nice tool that gives you like a spreadsheet kind of experience

113
00:07:15,372 --> 00:07:18,670
where you can create very lightweight databases,

114
00:07:18,770 --> 00:07:22,346
but also there are APIs so you can use that database and

115
00:07:22,368 --> 00:07:25,930
that visual experience as a backend system

116
00:07:26,000 --> 00:07:29,958
for an actual web application. When you combine that with APIs

117
00:07:30,134 --> 00:07:33,494
and there is a very generous free plan. So for

118
00:07:33,552 --> 00:07:37,134
most of the this is not true just for

119
00:07:37,172 --> 00:07:40,366
airtable, but also for Vercel. So the idea here is that with this

120
00:07:40,388 --> 00:07:43,854
particular tech stack, we should be able to host an application that

121
00:07:43,892 --> 00:07:47,154
doesn't have a huge amount of traffic pretty much for free.

122
00:07:47,272 --> 00:07:50,994
So this is kind of one of the reasons why I like this

123
00:07:51,032 --> 00:07:54,546
stack. Because for this kind of site projects where youd may be creating an

124
00:07:54,568 --> 00:07:58,034
invite page for a private party, you are not going to be spending

125
00:07:58,082 --> 00:08:01,542
any money in hosting and you can get everything up and running pretty

126
00:08:01,596 --> 00:08:05,702
quickly. Okay, so making

127
00:08:05,756 --> 00:08:10,266
an XJS website private is maybe not something that you

128
00:08:10,288 --> 00:08:13,258
would want to do every day, because most of the time you are probably building

129
00:08:13,344 --> 00:08:17,142
public websites, I don't know, marketing pages, landing pages,

130
00:08:17,286 --> 00:08:20,554
SaaS application. So what does

131
00:08:20,592 --> 00:08:24,590
it mean to actually make next JS website private?

132
00:08:24,930 --> 00:08:28,554
After all, it's going to be hosted in the public Internet,

133
00:08:28,602 --> 00:08:32,046
because we just want to give people a public URL and

134
00:08:32,068 --> 00:08:35,442
they can access to that. So how do we actually make this thing

135
00:08:35,496 --> 00:08:39,454
that even though it's everything public facing and publicly accessible

136
00:08:39,502 --> 00:08:43,170
to the Internet, only people with a valid invite code can actually

137
00:08:43,240 --> 00:08:45,970
access the information that we want to disclose.

138
00:08:47,270 --> 00:08:50,518
So the idea is that every guest should see something different.

139
00:08:50,604 --> 00:08:54,358
This is actually another requirement that we want to use. If you remember

140
00:08:54,444 --> 00:08:58,258
from the demo we had Michelangelo Elo Rafaelo

141
00:08:58,274 --> 00:09:01,862
elo donatello. So every guests will get a customized

142
00:09:01,926 --> 00:09:05,542
page, and people that don't have an invite

143
00:09:05,606 --> 00:09:09,290
code should not be able to access any content. So they should be seeing only

144
00:09:09,360 --> 00:09:13,120
an error page that says something like, sorry, you don't have access here.

145
00:09:14,530 --> 00:09:18,462
So how do we make all of that happen when we use next

146
00:09:18,516 --> 00:09:21,930
js? So the idea is that we have a react

147
00:09:22,010 --> 00:09:25,022
single page application. This is what nextjs does for us,

148
00:09:25,076 --> 00:09:28,020
allows us to easily build a react single page application.

149
00:09:28,470 --> 00:09:32,430
Now, in this single page application, what we have is that the ability

150
00:09:32,510 --> 00:09:35,598
that if we pass a specific query string parameter,

151
00:09:35,694 --> 00:09:39,282
we can actually read it after the application bootstraps.

152
00:09:39,346 --> 00:09:43,238
So the application bootstraps, and in that state it doesn't display anything.

153
00:09:43,324 --> 00:09:46,914
So the first thing that it needs to do is to check the current URL,

154
00:09:47,042 --> 00:09:50,978
load the secret, so the invitation code from the URL.

155
00:09:51,074 --> 00:09:54,902
And at that point what it can do is to call an API

156
00:09:54,966 --> 00:09:58,266
in the backend, which is going to be hosted on Vercel, and it's going to

157
00:09:58,288 --> 00:10:01,974
tell, okay, I have this invite code. Is that invite code valid?

158
00:10:02,102 --> 00:10:05,834
And the API in return needs to look up into airtable

159
00:10:05,962 --> 00:10:09,738
and check, do I have any invitation with this particular code? So it's

160
00:10:09,754 --> 00:10:13,374
going to try to read data from that particular airtable spreadsheet.

161
00:10:13,502 --> 00:10:17,394
And if airtable says yes, basically what

162
00:10:17,432 --> 00:10:20,578
happens is coming to show the page to

163
00:10:20,584 --> 00:10:24,030
the user. Say, for instance, hello, Michelangelo, you are invited.

164
00:10:24,190 --> 00:10:27,940
Or if airtable says, sorry, I don't have this invitation code,

165
00:10:28,390 --> 00:10:31,814
that basically means that that invitation code is made up. It's somebody

166
00:10:31,852 --> 00:10:35,318
that is trying to see, is trying to guess an invitation code,

167
00:10:35,404 --> 00:10:38,874
or maybe it's an invitation code that we have removed. So in that case,

168
00:10:38,912 --> 00:10:42,906
we need to display something like access denied. So you can see

169
00:10:42,928 --> 00:10:47,066
that there is a kind of a client side check

170
00:10:47,168 --> 00:10:50,602
for given this particular secret, what could

171
00:10:50,656 --> 00:10:54,126
I display? And then that client side application

172
00:10:54,228 --> 00:10:57,950
needs to do API calls to actually make sure to check,

173
00:10:58,020 --> 00:11:02,190
is this invitation code something valid or not? Can I display some information

174
00:11:02,340 --> 00:11:06,126
or should I display access denied? So the first thing that

175
00:11:06,148 --> 00:11:09,522
we need to do to start to implement this solution is to organize the data

176
00:11:09,576 --> 00:11:13,250
in airtable. Now if you never use airtable before,

177
00:11:13,400 --> 00:11:17,074
this is pretty much the idea you can imagine as a dynamic CSV

178
00:11:17,122 --> 00:11:20,902
file with APIs. So we have records there.

179
00:11:21,036 --> 00:11:24,850
Every line contains a UUID, which is the unique

180
00:11:25,010 --> 00:11:28,746
invite code for every guest, and every record

181
00:11:28,928 --> 00:11:33,030
associates that particular build with guest information, for instance

182
00:11:33,110 --> 00:11:37,110
their name. In this case we have the favorite color. We have weapons,

183
00:11:37,190 --> 00:11:42,734
for instance, just to showcase one

184
00:11:42,772 --> 00:11:45,790
particular characteristic that you might have for guests.

185
00:11:46,370 --> 00:11:50,366
And if we want to understand better

186
00:11:50,468 --> 00:11:53,710
what airtable calls all the different things,

187
00:11:53,860 --> 00:11:57,106
we have a base which is pretty much a project. In this

188
00:11:57,128 --> 00:12:01,006
case we are calling it secret pizza party. Then we have the concept

189
00:12:01,038 --> 00:12:03,982
of a table. In our project we only have one table,

190
00:12:04,046 --> 00:12:07,506
which is called invites, but you could be having multiple tables,

191
00:12:07,618 --> 00:12:11,206
and then in every table you have multiple fields. In our case we have

192
00:12:11,228 --> 00:12:13,670
invite name, favorite color, weapon,

193
00:12:14,810 --> 00:12:18,694
and then we have records. For instance, here we have invited four

194
00:12:18,732 --> 00:12:22,666
people, so we have four different records. How do

195
00:12:22,688 --> 00:12:25,914
we start? Now our Nextjs project one of the things

196
00:12:25,952 --> 00:12:29,980
that I really like in nextjs is that there is a very nice

197
00:12:30,910 --> 00:12:34,090
system to bootstrap applications, and you can even specify

198
00:12:34,170 --> 00:12:37,914
whether you want to use typescript or NPM or yarn

199
00:12:37,962 --> 00:12:41,322
or different other tools for dependency management.

200
00:12:41,386 --> 00:12:44,942
So how do you do that? You just say MPX create nextjs app

201
00:12:44,996 --> 00:12:48,782
and you can even specify a version and then you can pass extra parameter.

202
00:12:48,846 --> 00:12:52,258
And after you do that, basically you're going to be having a project

203
00:12:52,344 --> 00:12:55,598
structure already created for you. Now note here that

204
00:12:55,624 --> 00:12:59,314
I'm using next twelve. NextJs 13 has been published

205
00:12:59,362 --> 00:13:03,426
very recently. I haven't tried yet, so I'm sticking

206
00:13:03,458 --> 00:13:06,662
with next twelve. But I don't expect to see big

207
00:13:06,716 --> 00:13:09,110
changes if you use next 13.

208
00:13:10,890 --> 00:13:14,170
Okay, the next thing that we want to do once we have the project started,

209
00:13:14,240 --> 00:13:17,962
because we are using typescript, we can start to create some types that will be

210
00:13:18,016 --> 00:13:21,306
beneficial for us while we build all the front end and

211
00:13:21,328 --> 00:13:24,814
back end for our application. So in our case we want to create

212
00:13:24,852 --> 00:13:28,174
an invite type which contains more or less the same fields that

213
00:13:28,212 --> 00:13:31,566
we had in airtable. Note that here I also have an

214
00:13:31,588 --> 00:13:34,754
optional field called coming, which is basically something we can use

215
00:13:34,792 --> 00:13:38,274
to track the preference of that particular guest to

216
00:13:38,312 --> 00:13:40,340
see if they are coming or not.

217
00:13:42,630 --> 00:13:46,162
Another thing that we need to do to be able to use airtable in our

218
00:13:46,216 --> 00:13:50,306
backend in our nextjs APIs is we need to have API

219
00:13:50,338 --> 00:13:54,130
keys and base id, which are things that we can find in the configuration

220
00:13:54,210 --> 00:13:57,542
of airtable. So the idea here is that we install

221
00:13:57,596 --> 00:14:01,222
the airtable SDK, this is an official package from airtable,

222
00:14:01,366 --> 00:14:04,826
and then we export these environment variables so that we

223
00:14:04,848 --> 00:14:08,554
can use them to actually initialize the client and connect to our

224
00:14:08,592 --> 00:14:09,500
own account.

225
00:14:11,950 --> 00:14:15,034
Now let's have a quick look at the APIs of airtable.

226
00:14:15,082 --> 00:14:18,814
And this is actually one thing that I really like about airtable, because if you

227
00:14:18,852 --> 00:14:22,174
look closely at these APIs, they are

228
00:14:22,212 --> 00:14:25,482
already giving you a documentation page that is already customized

229
00:14:25,546 --> 00:14:28,626
with all the fields that you have in your project. So this is not

230
00:14:28,648 --> 00:14:32,814
just showing a random set of examples, but these are actually real examples

231
00:14:32,862 --> 00:14:36,690
that will work with your particular project structure.

232
00:14:37,050 --> 00:14:40,614
So for instance here, if we zoom a little bit, we can see

233
00:14:40,732 --> 00:14:43,974
that in this example, after we load our

234
00:14:44,012 --> 00:14:47,666
table, the SDK, we initialize a client with the API

235
00:14:47,698 --> 00:14:51,610
key and the base id. You can see that this example

236
00:14:51,680 --> 00:14:54,918
already had invites, which is the name of our table,

237
00:14:55,014 --> 00:14:58,970
and it's showing us how to do a select in that particular table.

238
00:14:59,950 --> 00:15:03,594
So now this is not really very modern JavaScript.

239
00:15:03,642 --> 00:15:07,630
It's not using ESM, it's using VAR rather than constant let,

240
00:15:07,780 --> 00:15:11,246
it's using callbacks. So we are going to be doing something a little bit more

241
00:15:11,268 --> 00:15:14,594
polished, but I still like the idea that this example

242
00:15:14,712 --> 00:15:18,622
is actually fine tuned to your actual data and not some generic

243
00:15:18,686 --> 00:15:22,082
example. Okay, so let's try to do

244
00:15:22,136 --> 00:15:25,662
something ourselves. So what do we do? We want to use ESM,

245
00:15:25,726 --> 00:15:28,918
of course, because we want to write modern javascript. So we're going to be using

246
00:15:29,004 --> 00:15:33,698
import syntax, we are coming to be importing airtable

247
00:15:33,794 --> 00:15:37,110
and our invite type. And then

248
00:15:37,180 --> 00:15:41,034
what we do is we make sure that we have initialized our

249
00:15:41,072 --> 00:15:44,726
environment variables correctly. So if one of those environment variables

250
00:15:44,758 --> 00:15:48,730
is missing, we are not going to be able to call airtable

251
00:15:49,150 --> 00:15:53,070
APIs. So we need to make sure that these environment variables are set.

252
00:15:53,140 --> 00:15:56,846
If not, we're going to be throwing an error. At this point we can

253
00:15:56,868 --> 00:16:00,350
initialize our airtable client and we can

254
00:16:00,500 --> 00:16:04,434
define the base, the project that we want to reference to from

255
00:16:04,472 --> 00:16:08,290
this client. Now all of this code is a utility

256
00:16:09,750 --> 00:16:13,246
file that we created under Udil's airtable ts.

257
00:16:13,358 --> 00:16:16,774
So this way what we can do is easily import

258
00:16:16,892 --> 00:16:19,320
this client and use it somewhere else.

259
00:16:21,850 --> 00:16:25,410
Or another idea is actually that we can export

260
00:16:25,490 --> 00:16:29,890
specific functions. So we build kind of our own data model

261
00:16:29,980 --> 00:16:33,594
layer in this particular file. And for instance, the first

262
00:16:33,632 --> 00:16:36,986
thing that we want to build is if I have an invite code,

263
00:16:37,088 --> 00:16:40,714
can I retrieve an invite for that particular invite

264
00:16:40,762 --> 00:16:44,238
code? So we can create a function here

265
00:16:44,324 --> 00:16:47,534
which returns a promise. And this function,

266
00:16:47,732 --> 00:16:51,754
what it does is basically uses the SDK that we initialize

267
00:16:51,802 --> 00:16:55,810
in this file to do a select. Now this select,

268
00:16:55,960 --> 00:16:59,246
I'm not going to be spending too much time, but you can imagine that it's

269
00:16:59,278 --> 00:17:02,974
just checking in this particular table, if I use this invite

270
00:17:03,022 --> 00:17:07,026
code, is there

271
00:17:07,048 --> 00:17:10,566
a record that has a matching invite code? And we only want

272
00:17:10,588 --> 00:17:13,878
to get one record at a time. That's why we have max record

273
00:17:13,964 --> 00:17:17,174
equal one. Now don't worry too much about this

274
00:17:17,212 --> 00:17:20,886
escape function. It's something that we will be discussing at the end. Just keep it

275
00:17:20,908 --> 00:17:24,554
in the back of your mind. Then what we do, we take the first

276
00:17:24,592 --> 00:17:27,958
page and we want to make sure that if there is an error,

277
00:17:28,054 --> 00:17:30,910
we reject the current promise.

278
00:17:31,410 --> 00:17:35,054
Or if

279
00:17:35,092 --> 00:17:38,446
we get one page, but this page doesn't contain anything, that means that

280
00:17:38,468 --> 00:17:42,106
we didn't find an invite. So that's also something we consider an error.

281
00:17:42,218 --> 00:17:46,066
And finally, if we found an invite code, then what we do, we map all

282
00:17:46,088 --> 00:17:50,162
the data from airtable into an object that represents our data

283
00:17:50,216 --> 00:17:51,860
model in our application.

284
00:17:53,510 --> 00:17:57,494
Okay, the next step is now that we have built all

285
00:17:57,532 --> 00:18:01,398
this data layer that allows us to interact with

286
00:18:01,564 --> 00:18:05,026
airtable and fetch data from airtable. Specifically,

287
00:18:05,058 --> 00:18:08,346
if we have an invite code, we can fetch all the data for that particular

288
00:18:08,448 --> 00:18:12,700
invite. What we need to do next to build an app inside

289
00:18:14,190 --> 00:18:17,718
next JS API layer and that API

290
00:18:17,814 --> 00:18:21,274
needs to expose that information to our

291
00:18:21,312 --> 00:18:25,318
front end layer. So how do we build APIs with

292
00:18:25,344 --> 00:18:28,654
nextjs? This is another thing that I really like in nextjs

293
00:18:28,772 --> 00:18:32,814
that is very easy to build APIs, you just need to create a file inside

294
00:18:32,932 --> 00:18:36,722
pages API. So there is a very specific folder structure in next

295
00:18:36,776 --> 00:18:40,834
JS. It's file based routing, it's called.

296
00:18:41,032 --> 00:18:44,626
And basically the idea is that if you create for instance in this

297
00:18:44,648 --> 00:18:48,006
example a file called, that means that

298
00:18:48,028 --> 00:18:52,306
your application will be exposing an API underapi.

299
00:18:52,498 --> 00:18:55,858
Hello. So if we have this application running in localhost,

300
00:18:55,954 --> 00:18:59,410
we are going to be having something like localost app law.

301
00:18:59,500 --> 00:19:03,674
If we have it running on the web, somewhere there will be some domain name

302
00:19:03,792 --> 00:19:06,906
app, then the interface is

303
00:19:06,928 --> 00:19:10,634
basically saying you need to import this next

304
00:19:10,832 --> 00:19:14,686
API request and next API response. And at this

305
00:19:14,708 --> 00:19:18,014
point you can export an andler and the under takes

306
00:19:18,052 --> 00:19:22,014
a request and a response and then you can use the response to return some

307
00:19:22,052 --> 00:19:25,486
data to the user. In this case we are just returning

308
00:19:25,678 --> 00:19:29,202
200 successful response where the body

309
00:19:29,256 --> 00:19:33,314
is a JSON object containing message hello world. This is the

310
00:19:33,352 --> 00:19:36,806
simplest kind of API you could see. But of course this is not what we

311
00:19:36,828 --> 00:19:40,278
want to build. We actually want to build an API that takes

312
00:19:40,364 --> 00:19:43,926
as input an invite code and it returns all the

313
00:19:43,948 --> 00:19:46,550
information related to that particular invite.

314
00:19:47,610 --> 00:19:50,826
So how do we go and do that? So we want to

315
00:19:50,848 --> 00:19:55,382
create a new endpoint so it needs to live inside pages API

316
00:19:55,526 --> 00:19:59,286
and we are going to be calling it invite. So it's

317
00:19:59,318 --> 00:20:02,846
going to be called invite TS. Now the

318
00:20:02,868 --> 00:20:06,894
first thing that we do, we import our type and we

319
00:20:06,932 --> 00:20:11,038
import our utility from the airtable file we created before.

320
00:20:11,204 --> 00:20:15,214
That allows us to fetch involves using an invite code directly

321
00:20:15,262 --> 00:20:18,786
from airtable. Then we need to create an

322
00:20:18,808 --> 00:20:22,770
andler and this handler will return an invite response.

323
00:20:23,190 --> 00:20:27,106
And there are a few things that we need to check.

324
00:20:27,208 --> 00:20:31,014
For instance, if this request is

325
00:20:31,052 --> 00:20:34,630
not a get, sorry, we are going to refuse because we

326
00:20:34,700 --> 00:20:37,878
only want to accept get and we are going to return

327
00:20:37,964 --> 00:20:41,698
a 405 saying method not allowed. Then if there is

328
00:20:41,724 --> 00:20:45,066
no query string code, this is also another error because we don't

329
00:20:45,088 --> 00:20:48,570
have an invite code. So we are going to be returning a 400 saying

330
00:20:48,640 --> 00:20:50,140
missing invite code.

331
00:20:51,470 --> 00:20:55,086
Now the next thing we want to do is that we need to normalize the

332
00:20:55,188 --> 00:20:59,114
code because in nextjs when you pass query

333
00:20:59,162 --> 00:21:03,118
strings, you might be having the same query string repeated multiple times.

334
00:21:03,204 --> 00:21:06,754
For instance, you might be having the same code repeated more than

335
00:21:06,792 --> 00:21:10,210
once. So what we want to do is to make sure that we take

336
00:21:10,280 --> 00:21:12,900
only the first instance of that code.

337
00:21:13,990 --> 00:21:17,954
And then what we do is we try to read the invite

338
00:21:18,002 --> 00:21:21,714
code using our airtable helper. If we can fetch the invite

339
00:21:21,762 --> 00:21:25,622
code, that's what we return. Otherwise there is an error and

340
00:21:25,676 --> 00:21:29,382
we need to handle that particular error. Either it's an invite

341
00:21:29,446 --> 00:21:33,114
not found or there is a server error and we will be propagating the

342
00:21:33,152 --> 00:21:35,260
error accordingly to that.

343
00:21:37,390 --> 00:21:41,190
So how do we test this? If we have the application running locally,

344
00:21:41,270 --> 00:21:45,454
we can just do a call with an invite code that we know exists and

345
00:21:45,492 --> 00:21:49,486
we should be seeing something like this. So our API is

346
00:21:49,588 --> 00:21:53,026
using a JSON interface. We pass an inviteonly code, we get back a

347
00:21:53,048 --> 00:21:56,194
JSON response with all the details associated to that

348
00:21:56,232 --> 00:21:59,730
particular invite that are coming from airtable.

349
00:22:01,670 --> 00:22:05,294
Now at this point we have everything at the backend layer.

350
00:22:05,342 --> 00:22:08,766
So we have airtable that contains all the data is effectively our

351
00:22:08,808 --> 00:22:12,230
database. We have an API layer that allows us to read data

352
00:22:12,300 --> 00:22:16,262
from that database layer. Now we want to work on our single page

353
00:22:16,316 --> 00:22:20,086
application. So the front end side and the front end side needs to manage

354
00:22:20,188 --> 00:22:23,734
all the lifecycle to bootstrap the application, read the inviteonly

355
00:22:23,782 --> 00:22:27,590
code from the query string, call the API that we just implemented,

356
00:22:27,670 --> 00:22:31,158
and then based on the response of that API, it needs to

357
00:22:31,184 --> 00:22:35,310
display either a page successful page with all the user information,

358
00:22:35,460 --> 00:22:39,646
or it needs to display an error. So we are effectively implementing an

359
00:22:39,668 --> 00:22:43,280
invite validation workflow in the single page application.

360
00:22:44,390 --> 00:22:48,466
So what's the attack plan? So when the SPI loads, we grab the

361
00:22:48,488 --> 00:22:52,466
code from the URL, we call the inviteonly API with that particular

362
00:22:52,568 --> 00:22:56,614
code. If it's valid, then we render the

363
00:22:56,652 --> 00:23:00,246
content of that particular invite. If there is

364
00:23:00,268 --> 00:23:03,634
an error, most likely the invite

365
00:23:03,682 --> 00:23:07,240
code is not valid, so we need to render an error page.

366
00:23:08,250 --> 00:23:12,458
So how do we manage all this data fetching lifecycle in

367
00:23:12,544 --> 00:23:16,330
react and next js? So there are different options,

368
00:23:16,400 --> 00:23:19,706
and I've actually tried to implement this in a bunch of different ways.

369
00:23:19,808 --> 00:23:23,082
The first idea might be we might have a top level component,

370
00:23:23,146 --> 00:23:26,766
for instance app, and we can do all this loading in

371
00:23:26,788 --> 00:23:31,230
that top level component, for instance by using a use effect hook.

372
00:23:32,130 --> 00:23:35,838
Another approach could be we could be creating a context provider.

373
00:23:36,014 --> 00:23:39,710
It's a quite common concept in react.

374
00:23:39,870 --> 00:23:43,134
You can create a context that allows you to expose

375
00:23:43,182 --> 00:23:46,994
some data to your entire application. So that context could take

376
00:23:47,032 --> 00:23:50,882
care of doing all this kind of interaction with our backend APIs,

377
00:23:51,026 --> 00:23:54,678
and eventually it's going to expose some data to the rest of the application

378
00:23:54,844 --> 00:23:58,518
and the rest of the application will render accordingly to the data in

379
00:23:58,524 --> 00:24:02,426
the context. Another idea could be we could be implementing a

380
00:24:02,448 --> 00:24:06,042
specialized react hook. So a custom react hook that takes care

381
00:24:06,096 --> 00:24:09,466
of doing all of this. And this is actually the idea that I like the

382
00:24:09,488 --> 00:24:12,782
most, and I think the one that gave me the

383
00:24:12,836 --> 00:24:16,574
most concise code from a consumer perspective. So it's probably

384
00:24:16,612 --> 00:24:20,254
the easiest solution when you need to integrate it into your

385
00:24:20,292 --> 00:24:23,746
actual application. So the next question is, if you

386
00:24:23,768 --> 00:24:27,074
never built a custom react hook, how do we go and do

387
00:24:27,112 --> 00:24:30,626
that? And a custom react hook is

388
00:24:30,648 --> 00:24:33,954
just a javascript function that had the

389
00:24:33,992 --> 00:24:37,394
name starting with the word use. This is kind of a convention

390
00:24:37,442 --> 00:24:40,870
in react, use effect, use state.

391
00:24:41,020 --> 00:24:45,206
So if you build your own hook, it's going to be called use

392
00:24:45,308 --> 00:24:49,050
something. And this particular

393
00:24:49,120 --> 00:24:53,034
function can also call underneath other hooks. So when we build this

394
00:24:53,072 --> 00:24:57,500
function inside that function, we can use use effect, use state,

395
00:24:58,110 --> 00:25:01,466
use callback, use memo, any other hook

396
00:25:01,658 --> 00:25:04,910
from the react core, or even other custom hooks.

397
00:25:05,490 --> 00:25:08,974
It doesn't need to have any specific signature. So inside the

398
00:25:09,012 --> 00:25:13,422
function, all the common rules of hooks apply. Hooks are

399
00:25:13,476 --> 00:25:16,718
nice to use, but there are some weird rules that you need to

400
00:25:16,724 --> 00:25:20,370
get used to. And when you build a custom hook, the same rules apply.

401
00:25:20,520 --> 00:25:24,466
And the idea is that youd can only call hooks at the top level of

402
00:25:24,488 --> 00:25:27,926
the function. Every react component is effectively a

403
00:25:27,948 --> 00:25:31,590
function and youd can use use state use effect only at the very top

404
00:25:31,660 --> 00:25:34,902
of that function. And when you call use

405
00:25:34,956 --> 00:25:38,354
state use effect or any other hook, they cannot

406
00:25:38,402 --> 00:25:41,990
be inside loops, condition or other nested functions.

407
00:25:42,070 --> 00:25:45,542
And the idea is that every time the component renders, the hook

408
00:25:45,606 --> 00:25:49,578
needs to be always called and always be called with the same order

409
00:25:49,744 --> 00:25:53,626
as opposed to all the other rooks in that function. Now these rules

410
00:25:53,658 --> 00:25:57,226
are defined by react and this is just the way hooks are implemented

411
00:25:57,258 --> 00:26:00,766
in react. And you can find some more details and examples in the

412
00:26:00,788 --> 00:26:02,110
official documentation.

413
00:26:04,130 --> 00:26:07,070
Okay, so how do we create a custom hook?

414
00:26:08,870 --> 00:26:12,260
The first thing we want to do is of course to import our

415
00:26:13,990 --> 00:26:17,682
invite type and then we will have

416
00:26:17,736 --> 00:26:21,186
our fetch invite function, which basically I'm

417
00:26:21,218 --> 00:26:24,566
not showing it here just for brevity, but the idea is that

418
00:26:24,588 --> 00:26:28,030
this is going to be doing a fetch request to the backend API

419
00:26:28,130 --> 00:26:31,450
and it's going to return an invite response or an error.

420
00:26:33,150 --> 00:26:37,094
And now this is actually our custom hook use invite.

421
00:26:37,222 --> 00:26:40,954
So what is the idea of this hook? That when we

422
00:26:41,152 --> 00:26:44,814
want to create a component that wants to

423
00:26:44,852 --> 00:26:48,526
check if a user had a valid invite code, we can

424
00:26:48,548 --> 00:26:52,074
just use this hook. We can just say use invite pass an invite

425
00:26:52,122 --> 00:26:55,620
code and then that hook will give us back

426
00:26:57,430 --> 00:26:59,090
the invite response.

427
00:27:01,670 --> 00:27:05,534
So we have a state that this hook needs to maintain,

428
00:27:05,582 --> 00:27:08,694
some state inside because basically it needs

429
00:27:08,732 --> 00:27:12,374
to say is there an invite associated to this

430
00:27:12,412 --> 00:27:15,606
invite code? And if there is, it's going to be stored inside the

431
00:27:15,628 --> 00:27:18,994
state of this particular hook. Also there might be errors.

432
00:27:19,042 --> 00:27:23,020
So we have another state which is whether there are errors or not.

433
00:27:23,470 --> 00:27:26,746
And then the next thing that it needs to do is to,

434
00:27:26,928 --> 00:27:30,662
when this hook is actually being initialized

435
00:27:30,726 --> 00:27:34,526
in a component, we want to trigger a particular

436
00:27:34,628 --> 00:27:38,494
action. So there is an effect that needs to happens. And inside this

437
00:27:38,532 --> 00:27:41,946
effect what we do is we try to read the code from the query string

438
00:27:41,978 --> 00:27:45,246
parameter. We try to see if there is a query string

439
00:27:45,278 --> 00:27:48,754
parameter called code and we read that particular one.

440
00:27:48,952 --> 00:27:52,706
If there isn't, then that's an error. No code was

441
00:27:52,728 --> 00:27:56,626
provided. We can set the internal state of this hook as

442
00:27:56,728 --> 00:28:00,886
there is an error and the error is that there is no code. Otherwise we

443
00:28:00,908 --> 00:28:04,502
need to fetch the invite. So we are going to be calling our other function

444
00:28:04,556 --> 00:28:08,066
that makes an HTTP request. And if that HTTP

445
00:28:08,098 --> 00:28:11,946
request succeeds, we set the invite response. If it fails, we set

446
00:28:11,968 --> 00:28:15,866
an error with the message of that particular error, and at

447
00:28:15,888 --> 00:28:19,894
that point the hook returns two values in an array invite

448
00:28:19,942 --> 00:28:21,550
response and error.

449
00:28:23,570 --> 00:28:26,880
So how do we use it? It's actually very simple.

450
00:28:28,050 --> 00:28:32,074
Let's say that we have some example component, this is just a react component

451
00:28:32,202 --> 00:28:35,086
and this component is just going to call use invite.

452
00:28:35,198 --> 00:28:38,606
And then inside use invite we are going to be having either an invite

453
00:28:38,638 --> 00:28:42,740
response or an error. Now keep in mind that

454
00:28:43,990 --> 00:28:47,314
all this stuff is asynchronous because use invite will

455
00:28:47,352 --> 00:28:50,530
need to load some data, will need to do HTTP requests

456
00:28:50,610 --> 00:28:54,290
in the background. So we will have here different potential

457
00:28:54,370 --> 00:28:58,754
states. One state is when all the request was completed,

458
00:28:58,802 --> 00:29:02,346
but it was failing with an error. So we need to check, okay, if there

459
00:29:02,368 --> 00:29:06,506
was an error, we need to display the error. If there

460
00:29:06,528 --> 00:29:09,914
wasn't an error, but we don't have an invite response either. That means

461
00:29:09,952 --> 00:29:13,518
that we are still loading the data from the API, so we need

462
00:29:13,524 --> 00:29:16,814
to display some loading information, a spinner or something

463
00:29:16,852 --> 00:29:20,206
like that. And finally, the last date is when we

464
00:29:20,228 --> 00:29:23,426
actually completed everything successfully. So we have some data and

465
00:29:23,448 --> 00:29:26,100
we can render the page with the data.

466
00:29:28,950 --> 00:29:33,058
Okay, now that we know how to build a custom

467
00:29:33,144 --> 00:29:37,182
MOOC that can be used in a component, to actually make sure that we render

468
00:29:37,246 --> 00:29:40,594
information only when the inviteonly code is valid, and we render

469
00:29:40,642 --> 00:29:44,102
an error when the inviteonly code is not valid. The next step

470
00:29:44,156 --> 00:29:47,958
is what if we want to collect some user data? Now we are displaying a

471
00:29:47,964 --> 00:29:51,834
page for every single user, but we want to know if that

472
00:29:51,872 --> 00:29:55,194
particular user is going to attend our party or not.

473
00:29:55,312 --> 00:29:58,730
So we want to allow the user the opportunity to submit data

474
00:29:58,800 --> 00:30:01,738
to our back end. How do we do that?

475
00:30:01,904 --> 00:30:05,166
First of all, we need to do some changes, so we need to

476
00:30:05,188 --> 00:30:08,926
add new fields in airtable. For instance, we can add a

477
00:30:08,948 --> 00:30:12,714
new field called coming, which allows us to store the information

478
00:30:12,852 --> 00:30:16,638
for every single invite in that table.

479
00:30:16,814 --> 00:30:19,954
If the person invited is attending or not,

480
00:30:20,152 --> 00:30:24,126
then we need to add new backend utilities in our airtable helper

481
00:30:24,238 --> 00:30:27,422
to be able to update our table.

482
00:30:27,486 --> 00:30:31,602
When we receive the information from the user, we need to add a new endpoint

483
00:30:31,666 --> 00:30:34,930
to our API and then we need to update our react hook

484
00:30:35,010 --> 00:30:38,646
to also be able to not just read the data related to

485
00:30:38,668 --> 00:30:42,666
an invite, but also be able to change some of the data related to

486
00:30:42,688 --> 00:30:46,534
that particular invite. So adding a field to airtable

487
00:30:46,582 --> 00:30:49,834
is easy. It's a visual tool youd just click and say, add a new

488
00:30:49,872 --> 00:30:53,626
field. And you can also select a particular kind of field where

489
00:30:53,648 --> 00:30:56,942
you have only specific choices. For instance here it can either

490
00:30:56,996 --> 00:31:00,606
be empty or it can be a yes or a no. So there are

491
00:31:00,628 --> 00:31:03,380
three potential states in this particular field.

492
00:31:08,230 --> 00:31:12,286
Now let's build first our RSDP utility

493
00:31:12,398 --> 00:31:15,682
so a user can say whether

494
00:31:15,736 --> 00:31:19,126
they are attending or not. So what we want to do is to

495
00:31:19,148 --> 00:31:22,626
basically add a new piece of functionality

496
00:31:22,658 --> 00:31:26,246
in our airtable helper that basically receives an

497
00:31:26,268 --> 00:31:29,478
invite code receives an or SVP state,

498
00:31:29,564 --> 00:31:32,874
which can either be true I am attending or false I'm not

499
00:31:32,912 --> 00:31:36,474
attending, and it returns a promise. So what it

500
00:31:36,512 --> 00:31:40,554
needs to do is it fetches the particular record for that invite

501
00:31:40,602 --> 00:31:44,494
code and what it does, it calls this

502
00:31:44,532 --> 00:31:47,390
function called update with an id,

503
00:31:47,540 --> 00:31:50,794
and it specifies the fields that needs to be updated.

504
00:31:50,922 --> 00:31:54,466
Now if everything is fine, we resolve. If there is

505
00:31:54,488 --> 00:31:58,180
an error, we reject. Nothing particularly complicated here.

506
00:32:00,870 --> 00:32:04,702
How do we create a new endpoint to be able to rsvp?

507
00:32:04,766 --> 00:32:07,842
So we need to create a new file inside pages API

508
00:32:07,906 --> 00:32:11,046
RSVP. So that means that we will be having an

509
00:32:11,068 --> 00:32:14,950
API endpoint called API RSVP.

510
00:32:15,370 --> 00:32:19,302
And here what we want to do is very similar to

511
00:32:19,356 --> 00:32:22,780
what we did before, but this time we want to

512
00:32:23,630 --> 00:32:27,146
accept only put requests. So if the request is not a

513
00:32:27,168 --> 00:32:31,610
put, we return a four or five. If there is no code

514
00:32:31,680 --> 00:32:34,894
in the query string. Again, we need to have an invite code to be able

515
00:32:34,932 --> 00:32:37,370
to update only that particular invite.

516
00:32:37,530 --> 00:32:41,550
So that's also going to be an error if we don't have an invite.

517
00:32:42,790 --> 00:32:47,746
Now at this point what we need to do is we

518
00:32:47,768 --> 00:32:51,522
are going to be receiving in the request body the

519
00:32:51,576 --> 00:32:54,946
RSVP field. So imagine that we are

520
00:32:54,968 --> 00:32:58,978
going to be building later on some interaction in our UI. That UI

521
00:32:59,154 --> 00:33:02,438
will do a request. It's going to put in the put

522
00:33:02,604 --> 00:33:06,882
payload body a JSON object that represents

523
00:33:07,026 --> 00:33:10,200
for that particular user if they are coming or not.

524
00:33:10,590 --> 00:33:14,326
Imagine in a more advanced application you might be having a bigger

525
00:33:14,358 --> 00:33:17,946
form, maybe with multiple fields. So in the body you might

526
00:33:17,968 --> 00:33:21,774
be having multiple fields. In this case we only have one particular field,

527
00:33:21,892 --> 00:33:24,030
which is going to tell us true or false.

528
00:33:25,570 --> 00:33:28,714
Again, we need to sanitize the query

529
00:33:28,762 --> 00:33:32,606
string. We need to read only one code if there are multiple ones.

530
00:33:32,788 --> 00:33:36,882
And then finally what we do, we call our update RSVP using

531
00:33:36,936 --> 00:33:40,386
the request body coming. And if everything is

532
00:33:40,408 --> 00:33:43,746
fine we return a 200. If there is an error, either the

533
00:33:43,768 --> 00:33:46,834
invite was not found, so that's a particular error,

534
00:33:46,882 --> 00:33:49,270
or there was an internal server error.

535
00:33:52,840 --> 00:33:56,484
So now we need to update our hook to be able to

536
00:33:56,522 --> 00:34:00,024
not just load the invite information, but also

537
00:34:00,062 --> 00:34:04,072
to expose some piece of functionality that allowed us, our single page

538
00:34:04,126 --> 00:34:07,832
application, to update the back end every

539
00:34:07,886 --> 00:34:10,840
time that the user does different kinds of interactions.

540
00:34:11,680 --> 00:34:15,656
So basically before we were just returning

541
00:34:15,688 --> 00:34:17,660
an array with two values,

542
00:34:18,960 --> 00:34:22,636
the error and the invite response. Now it makes sense to

543
00:34:22,658 --> 00:34:26,188
create a proper object because we have more fields.

544
00:34:26,364 --> 00:34:29,724
So the fields that we want to use in addition to the existing

545
00:34:29,772 --> 00:34:33,730
ones is updating, which basically tells us if

546
00:34:34,340 --> 00:34:37,436
the current state of the hook is sending

547
00:34:37,468 --> 00:34:41,204
a request to the back end to update the data. And then

548
00:34:41,242 --> 00:34:44,884
we have another function that can be used by our front end

549
00:34:44,922 --> 00:34:48,336
to actually trigger the update. So when the user tricks

550
00:34:48,528 --> 00:34:52,170
in the coming UI saying I'm coming yes or no,

551
00:34:54,540 --> 00:34:57,912
the front end is going to be able to call this particular function to actually

552
00:34:57,966 --> 00:35:01,112
trigger an action to the backend. So the idea of this

553
00:35:01,166 --> 00:35:04,952
hook is that basically we don't want to expose to whoever

554
00:35:05,016 --> 00:35:08,776
is utilizing the hook all the business logic that is required

555
00:35:08,808 --> 00:35:12,188
to update to interact with the backend. But we just want to

556
00:35:12,194 --> 00:35:16,140
expose an interface and that interface is part of the hook

557
00:35:16,300 --> 00:35:17,650
return data.

558
00:35:20,100 --> 00:35:23,648
Okay, so the next thing that we do

559
00:35:23,734 --> 00:35:27,604
is fill the diesels here and

560
00:35:27,642 --> 00:35:31,860
basically the use invite now is slightly updated

561
00:35:32,280 --> 00:35:35,684
and the changes that we are making is that now we also

562
00:35:35,722 --> 00:35:38,976
have a new additional state which is updating setup

563
00:35:39,008 --> 00:35:42,564
dating. So this is the new piece of information that

564
00:35:42,602 --> 00:35:46,836
we can use to show, for instance a spinner. When the user clicks on

565
00:35:47,018 --> 00:35:50,788
preference for RSVP, we need to show a

566
00:35:50,794 --> 00:35:54,156
spinner while that request is

567
00:35:54,178 --> 00:35:57,710
in progress. And then when updating is not

568
00:35:58,400 --> 00:36:02,764
false, then at that point we can hide the spinner use

569
00:36:02,802 --> 00:36:06,380
effect. Is everything the same. This is used to load the invite

570
00:36:06,460 --> 00:36:09,650
from the backend and this doesn't change.

571
00:36:10,100 --> 00:36:13,424
Then we have a new function called update or SVP. And what

572
00:36:13,462 --> 00:36:17,600
this does is basically checking if there is an invite response.

573
00:36:18,500 --> 00:36:21,924
We want to set the updating field, the updating state

574
00:36:21,962 --> 00:36:25,044
to true because we are about to make a request to the back end and

575
00:36:25,082 --> 00:36:28,448
that request is going to update our table.

576
00:36:28,624 --> 00:36:32,580
So while that request is in progress we need to show the spinner.

577
00:36:32,740 --> 00:36:36,180
At this point we actually do the request and when we receive

578
00:36:36,260 --> 00:36:40,216
a response we are going to be updating our

579
00:36:40,398 --> 00:36:43,964
invite response in the state of the

580
00:36:44,002 --> 00:36:47,480
hook. And finally we set updating to false.

581
00:36:47,560 --> 00:36:51,544
So again, the idea is that this hook needs to somehow

582
00:36:51,672 --> 00:36:54,924
take care of managing all the lifecycle of this data.

583
00:36:55,042 --> 00:36:58,464
This invitation object can change and it will take care

584
00:36:58,502 --> 00:37:02,092
of keeping track of the current value for that invitation

585
00:37:02,156 --> 00:37:05,792
object. Keeping track of if there are any error, keeping track,

586
00:37:05,846 --> 00:37:09,604
if we are in the process of updating the backend and all this

587
00:37:09,642 --> 00:37:13,764
information is available through the hook, so we can use this information to

588
00:37:13,802 --> 00:37:16,420
render different things in our UI.

589
00:37:19,400 --> 00:37:23,396
So finally we can use this hook. And this is just a simplified version

590
00:37:23,428 --> 00:37:26,872
of our actual application. So what we do is

591
00:37:27,006 --> 00:37:30,456
we call use invite, and this time we receive back an

592
00:37:30,478 --> 00:37:34,372
object, and from this object we can destructure the four properties

593
00:37:34,516 --> 00:37:37,192
that we want to use, invite response, error,

594
00:37:37,256 --> 00:37:41,384
updating and update, or SVP. Now if there was an error,

595
00:37:41,432 --> 00:37:44,684
we need to display an error. If there is no invite response, it means

596
00:37:44,722 --> 00:37:48,016
that we are still doing the initial loading from the back end of

597
00:37:48,038 --> 00:37:50,930
that particular invite. So we display a loading information.

598
00:37:51,540 --> 00:37:55,216
Then we create an andler. And this andler says when the

599
00:37:55,238 --> 00:37:58,496
user clicks on a preference whether they are coming or not to

600
00:37:58,518 --> 00:38:02,196
the party, we want to involves this handler. And this andler is

601
00:38:02,218 --> 00:38:06,164
going to read the current preference and use it to update the

602
00:38:06,202 --> 00:38:09,896
back end. And finally we have our form, and in

603
00:38:09,918 --> 00:38:13,640
this form we attach the handler and

604
00:38:13,790 --> 00:38:17,304
we have effectively two checkboxes and the user can

605
00:38:17,342 --> 00:38:20,824
say, I'm coming true, I'm coming false. And every

606
00:38:20,862 --> 00:38:24,284
time they change that preference, it's going to make a request to the back end

607
00:38:24,322 --> 00:38:27,020
and it's going to update the table in airtable.

608
00:38:28,320 --> 00:38:32,184
So that's everything we need to do. Let's see 15 seconds

609
00:38:32,232 --> 00:38:35,784
demo of that. So here I have my airtable

610
00:38:35,832 --> 00:38:39,168
on the left side and the application running on the right side.

611
00:38:39,334 --> 00:38:43,136
So what we want to do initially, we don't have any code, so what

612
00:38:43,158 --> 00:38:47,472
we want to do is to load the first user, the first invitation.

613
00:38:47,536 --> 00:38:51,430
So here we have Leonardo, and Leonardo can say, okay, I'm coming.

614
00:38:52,280 --> 00:38:54,550
Okay, let's try the second one.

615
00:38:57,160 --> 00:39:00,730
Now we have another invitation, and this time we say no.

616
00:39:01,100 --> 00:39:04,570
And this is updating in real time, as you can see.

617
00:39:05,980 --> 00:39:09,304
The third one, we can say no again,

618
00:39:09,502 --> 00:39:13,064
and it's updating in real time. And the fourth

619
00:39:13,112 --> 00:39:16,910
one is going to be saying yes.

620
00:39:17,280 --> 00:39:21,544
And you can see that if I change the preference also this is reflected

621
00:39:21,592 --> 00:39:25,212
more or less in real time. So the UI is making

622
00:39:25,266 --> 00:39:29,420
sure to call the hook, the hook is calling our next JS

623
00:39:29,500 --> 00:39:32,956
backend API. The next JS backend app is connecting

624
00:39:32,988 --> 00:39:36,976
to airtable. And this is how we keep things in sync between

625
00:39:37,078 --> 00:39:39,460
our front end and our database.

626
00:39:41,160 --> 00:39:44,532
How do we deploy all of this? This is actually the easiest part,

627
00:39:44,586 --> 00:39:48,244
because if we use GitHub and Vercel, the only thing that you need to do

628
00:39:48,282 --> 00:39:52,784
is create an account on Vercel using your own GitHub credentials.

629
00:39:52,912 --> 00:39:56,184
So you do an Oauth login using GitHub, and at that

630
00:39:56,222 --> 00:39:59,512
point there is just a few steps that you need to do

631
00:39:59,566 --> 00:40:02,936
to basically say select the repository where your source

632
00:40:02,968 --> 00:40:06,316
code lives. And because that's going to be an XJs application,

633
00:40:06,418 --> 00:40:09,630
Versaille already recognizes that and makes it available

634
00:40:10,640 --> 00:40:14,220
on Versailles, and you get a custom URL

635
00:40:15,440 --> 00:40:18,896
which contains something like Versailles app at the end.

636
00:40:18,998 --> 00:40:22,416
But if you want to use your own custom domains, you can also connect a

637
00:40:22,438 --> 00:40:26,064
custom domain. Okay, now that

638
00:40:26,102 --> 00:40:29,508
we know how to deploy the application, we are pretty much done,

639
00:40:29,594 --> 00:40:33,044
except that I mentioned that one of the last topics I wanted to cover

640
00:40:33,162 --> 00:40:36,660
is some security considerations. Again, we are building a website

641
00:40:36,730 --> 00:40:40,436
that effectively contains some private information. We don't want to

642
00:40:40,458 --> 00:40:43,944
disclose all of that information to everyone in the world. We just want to

643
00:40:43,982 --> 00:40:47,688
make sure that people that have an invite code can see that information.

644
00:40:47,854 --> 00:40:50,996
Other people shouldn't be seeing anything private.

645
00:40:51,188 --> 00:40:54,472
So what kind of problems can we have? How can people actually

646
00:40:54,526 --> 00:40:58,232
try to exploit our website even if they don't have an invite,

647
00:40:58,376 --> 00:41:02,124
they can try to extrapolate some useful information and maybe they

648
00:41:02,162 --> 00:41:04,620
show up at the party even if they are not invited.

649
00:41:05,840 --> 00:41:09,424
So the first thing that we need to be careful is that because

650
00:41:09,462 --> 00:41:13,136
we are building a single page application, most of the information that

651
00:41:13,158 --> 00:41:17,004
we have in our website is effectively going to be compiled inside the client

652
00:41:17,052 --> 00:41:20,836
side javascript that then eventually is made available by the

653
00:41:20,858 --> 00:41:24,916
browser. So if we have a clever user that knows how

654
00:41:24,938 --> 00:41:28,596
to use the debugging tools and read the original source code in

655
00:41:28,618 --> 00:41:32,112
JavaScript, they could be actually finding some sensitive

656
00:41:32,176 --> 00:41:36,004
information. For instance here you can see that we are highlighting

657
00:41:36,132 --> 00:41:39,656
where the event is taking place, the day when it's taking place. And this is

658
00:41:39,678 --> 00:41:42,376
already a quite sensitive piece of information.

659
00:41:42,558 --> 00:41:46,188
So even if they don't have an invite code, because you can see here that

660
00:41:46,274 --> 00:41:50,056
the UI saying invalid code, all that information is still embedded

661
00:41:50,088 --> 00:41:53,788
in the JavaScript bundle. So they can actually look into that

662
00:41:53,874 --> 00:41:57,696
and extrapolate some sensitive information. So this

663
00:41:57,718 --> 00:42:01,490
is probably something that we want to avoid, but how can we avoid that?

664
00:42:02,820 --> 00:42:05,984
And there might be different ways to fix this, but the idea

665
00:42:06,022 --> 00:42:09,156
is that if you had code, anything inside

666
00:42:09,258 --> 00:42:12,660
your react templates, inside your JSX,

667
00:42:13,000 --> 00:42:16,720
that piece of code will end up in the compiled

668
00:42:16,880 --> 00:42:20,196
JavaScript bundle. And that JavaScript bundle is something that is

669
00:42:20,218 --> 00:42:23,432
surfaced to the user regardless if they have an invitation code

670
00:42:23,486 --> 00:42:27,240
or not. So the first thing to do is don't hard code

671
00:42:27,310 --> 00:42:30,936
any sensitive information in your JSX. You should

672
00:42:30,958 --> 00:42:34,636
be using some placeholder in your template, and then you

673
00:42:34,658 --> 00:42:37,960
could populate that placeholder only when you verify

674
00:42:38,040 --> 00:42:41,208
that the user had an invitation code that is valid.

675
00:42:41,304 --> 00:42:45,292
So one idea to do that is basically to update

676
00:42:45,356 --> 00:42:48,924
our API to return with the invitation

677
00:42:49,052 --> 00:42:52,096
data. Also, a set of messages that then can

678
00:42:52,118 --> 00:42:54,640
be interpolated in the UI.

679
00:42:55,140 --> 00:42:58,624
For instance, I don't know, the time

680
00:42:58,742 --> 00:43:02,484
and the place where the party takes place can

681
00:43:02,522 --> 00:43:05,956
be part of the response that we receive only when we

682
00:43:05,978 --> 00:43:09,124
have a valid invite code. So only the app is going to be

683
00:43:09,162 --> 00:43:12,964
aware of this information. The front end only needs to interpolate

684
00:43:13,012 --> 00:43:16,564
that information. If we do that, the Javascript

685
00:43:16,612 --> 00:43:19,928
bundle that we are going to generate is not going to display this information.

686
00:43:20,014 --> 00:43:23,384
It's only going to display some placeholder variables that

687
00:43:23,502 --> 00:43:27,310
cannot be known by a user that doesn't have an invite code.

688
00:43:27,680 --> 00:43:30,892
If you want to see this working, actually I'm going to be giving youd

689
00:43:30,946 --> 00:43:34,196
a repository with the complete example, and I'm implementing

690
00:43:34,248 --> 00:43:38,636
this solution there so you can actually see a working complete implementation

691
00:43:38,668 --> 00:43:39,730
of this idea.

692
00:43:42,580 --> 00:43:46,096
Now, a slightly more complex problem, and this is something that

693
00:43:46,118 --> 00:43:50,196
I was actually figuring out and I reported it to airtable, because this

694
00:43:50,218 --> 00:43:53,444
is something that can be very dangerous. If you ever

695
00:43:53,482 --> 00:43:57,504
used SQL, you probably know of the term SQL injection,

696
00:43:57,632 --> 00:44:01,664
which is basically when you have user data that gets interpolated

697
00:44:01,712 --> 00:44:05,384
into a query, a user, a malicious user, can actually give

698
00:44:05,422 --> 00:44:08,996
you very specific pieces

699
00:44:09,028 --> 00:44:12,424
of information that try to alter the shape of that query to

700
00:44:12,462 --> 00:44:16,152
do something that the user was not really intended to do. For instance

701
00:44:16,216 --> 00:44:19,224
here, even if we are using airtable,

702
00:44:19,272 --> 00:44:23,464
because airtable has a query language and we are using user

703
00:44:23,512 --> 00:44:26,956
data, which is the invite code, which is coming from a query

704
00:44:26,988 --> 00:44:30,352
string parameter. So something that the user could change if they wanted

705
00:44:30,406 --> 00:44:33,808
to. We are basically interpreting that information

706
00:44:33,894 --> 00:44:37,136
in our queries. So we need to be careful that the

707
00:44:37,158 --> 00:44:40,436
user is not really trying to inject anything malicious to

708
00:44:40,458 --> 00:44:44,292
try to break our query. If a user doesn't know

709
00:44:44,426 --> 00:44:47,924
an valid invite code, what they could be doing is

710
00:44:47,962 --> 00:44:51,956
to try to craft an invite code that manipulates our query to

711
00:44:51,978 --> 00:44:55,270
basically say invite equal true.

712
00:44:55,640 --> 00:44:59,156
So an invite should match that particular type of query,

713
00:44:59,268 --> 00:45:02,712
and if they are able to generate the kind of query, they're basically

714
00:45:02,766 --> 00:45:05,996
getting access to our application without knowing an

715
00:45:06,018 --> 00:45:09,644
actual valid invite code. So in a way we are trying to do,

716
00:45:09,762 --> 00:45:13,356
or at least here trying to prevent any injections in

717
00:45:13,378 --> 00:45:17,200
the formula, this is the name that query I'll call in airtable

718
00:45:18,500 --> 00:45:23,200
that the user could be doing to manipulate the formula to their advantage.

719
00:45:24,740 --> 00:45:30,096
So imagine here that we

720
00:45:30,118 --> 00:45:33,780
have an escape function. I mentioned it before, but I didn't show you the code.

721
00:45:33,850 --> 00:45:37,620
Imagine that we didn't have the escape function. This is what

722
00:45:37,690 --> 00:45:40,996
our code could be. It's like leader is saying the invite in the

723
00:45:41,018 --> 00:45:44,456
table needs to be the same as the invite that we are receiving from

724
00:45:44,478 --> 00:45:47,976
the user. Again, keep in mind

725
00:45:47,998 --> 00:45:51,112
that this invite code is something that the user is giving us. So in this

726
00:45:51,166 --> 00:45:54,924
particular string interpolation, the user can do

727
00:45:54,962 --> 00:45:58,424
something to actually change the structure of this particular query.

728
00:45:58,552 --> 00:46:02,428
Let's see an example. So this is actually a valid example.

729
00:46:02,514 --> 00:46:05,744
When the user is giving us this code, what happens is that we

730
00:46:05,782 --> 00:46:09,344
build the following formula, which is totally valid and there is no problem

731
00:46:09,382 --> 00:46:12,576
with it. Now, if there

732
00:46:12,598 --> 00:46:15,920
is a malicious user that gives us this particular query,

733
00:46:16,340 --> 00:46:19,796
in the query string, they put this particular code, which if you

734
00:46:19,818 --> 00:46:23,664
decode it, pretty much looks like this. So code is equal

735
00:46:23,712 --> 00:46:27,332
to an open

736
00:46:27,386 --> 00:46:31,160
string where we say major, equal to zero and something

737
00:46:31,230 --> 00:46:35,176
else. And basically if we interpolate this particular

738
00:46:35,278 --> 00:46:38,856
string, what we get as the final formula is

739
00:46:38,878 --> 00:46:42,488
pretty much this. We are saying the invite is

740
00:46:42,654 --> 00:46:46,320
empty, needs to be measured

741
00:46:46,340 --> 00:46:50,296
or equal than zero and empty. And this is, don't worry

742
00:46:50,328 --> 00:46:53,164
too much about the meaning of this, but the problem with this is that this

743
00:46:53,202 --> 00:46:56,552
formula is always going to be true for every single record.

744
00:46:56,706 --> 00:47:00,512
So if table formula is just going to match whatever record come

745
00:47:00,566 --> 00:47:03,712
first in our table, and what happens if we actually

746
00:47:03,766 --> 00:47:07,136
try to put that into our URL, is that a

747
00:47:07,158 --> 00:47:10,676
user is going to have access straight away and

748
00:47:10,698 --> 00:47:14,368
is going to get any arbitrary user, in this case Donatello,

749
00:47:14,384 --> 00:47:17,232
because it's probably the first one that matches in our table.

750
00:47:17,376 --> 00:47:20,712
But a user without a valid user code was able to actually

751
00:47:20,766 --> 00:47:24,852
get access without a valid user code by crafting

752
00:47:24,916 --> 00:47:28,152
this particular injection. So how can we

753
00:47:28,206 --> 00:47:31,736
prevent this particular flow? And we need

754
00:47:31,758 --> 00:47:35,440
to use an escape function. And unfortunately

755
00:47:35,540 --> 00:47:39,404
airtable doesn't give you an escape function by default. It's something that I

756
00:47:39,442 --> 00:47:43,132
lied to them and hopefully they will be working on it in the future and

757
00:47:43,186 --> 00:47:47,276
provide as part of the SDK, an official sanitization or escape

758
00:47:47,308 --> 00:47:50,508
function. So this is just my own implementation.

759
00:47:50,604 --> 00:47:55,500
But be careful that this implementation might not be 100% bulletproof.

760
00:47:55,580 --> 00:47:58,832
So make sure to review it. And also if you have a similar use case,

761
00:47:58,886 --> 00:48:02,784
make sure to reach out to s tableau because they should be eventually providing

762
00:48:02,832 --> 00:48:06,192
their own custom, sorry, their own official

763
00:48:06,256 --> 00:48:09,664
tested escape functionality to avoid injections

764
00:48:09,712 --> 00:48:13,624
in airtable. So we are done pretty

765
00:48:13,662 --> 00:48:17,290
much with this talk. Let's try to recap and wrap things up.

766
00:48:18,700 --> 00:48:21,812
What are some of the limitations that you might encourage with this solution?

767
00:48:21,876 --> 00:48:25,524
Airtable, when you use the free plan, had a very

768
00:48:25,662 --> 00:48:29,100
strong rate limiting. You can only do five requests per second.

769
00:48:29,170 --> 00:48:32,812
And keep in mind that when we update our record we actually do two

770
00:48:32,866 --> 00:48:36,364
requests because we need to make sure that the invitation code is correct

771
00:48:36,482 --> 00:48:39,090
and then we update the invite code.

772
00:48:40,020 --> 00:48:43,296
So that could be one of the problems. What are some of the

773
00:48:43,318 --> 00:48:47,312
alternatives? You could be using Google spreadsheets. There is also an API and different

774
00:48:47,366 --> 00:48:51,040
packages on NPM. You could be using DynamoDB with amplify.

775
00:48:51,120 --> 00:48:54,240
You could be using Firebase, any atlas, CMS,

776
00:48:54,400 --> 00:48:57,716
Subabase, Strapi. There are many many alternatives that you could

777
00:48:57,738 --> 00:49:01,616
be using as something that could replace airtable

778
00:49:01,728 --> 00:49:05,032
in case you don't like airtable. And most of these things are either

779
00:49:05,086 --> 00:49:09,044
free or there are very generous entry level plans.

780
00:49:09,092 --> 00:49:12,840
So for your small website you're not going to incur in massive costs.

781
00:49:13,980 --> 00:49:17,852
So what are the takeaways from this talk that

782
00:49:17,986 --> 00:49:21,992
we just saw? A case study for a quick and easy and cheap solution

783
00:49:22,136 --> 00:49:25,470
that you can use if you need to build an invite only website.

784
00:49:26,400 --> 00:49:30,364
We learned about next js. We learned specifically about the API endpoints,

785
00:49:30,412 --> 00:49:34,684
how you can build custom react hooks, how can you integrate with backends

786
00:49:34,732 --> 00:49:37,936
such as airtable using their own sdks? And we

787
00:49:37,958 --> 00:49:41,952
also learned a bunch of security related things. Now this solution

788
00:49:42,016 --> 00:49:45,684
is just one of the possible solutions and for a very specific use

789
00:49:45,722 --> 00:49:49,204
case, don't just copy paste it for any other similar use case,

790
00:49:49,322 --> 00:49:53,384
always make sure to evaluate your context and assess whether

791
00:49:53,502 --> 00:49:56,388
your context fits this particular implementation.

792
00:49:56,564 --> 00:49:59,896
Probably if you just copy this code it's not going to fit your

793
00:49:59,918 --> 00:50:02,984
use case. You will need to change something. So the takeaway here

794
00:50:03,022 --> 00:50:06,764
is just take some of the lessons and then try to apply them to your

795
00:50:06,802 --> 00:50:10,220
code base. Don't just copy paste code blindly

796
00:50:11,520 --> 00:50:15,116
and I have written all this information in an article. Probably there are

797
00:50:15,138 --> 00:50:18,972
even more details there and the code that is easy to copy paste. Also,

798
00:50:19,026 --> 00:50:22,540
as I said, there is an entire code base that works with the example

799
00:50:22,610 --> 00:50:26,088
I showed you before on GitHub. So you can check these two links

800
00:50:26,104 --> 00:50:29,572
if you want get all the code, or if you want to read the same

801
00:50:29,626 --> 00:50:32,900
context that I explained here in the form of an article.

802
00:50:33,240 --> 00:50:37,060
And that's everything I have. Thank you very much. I hope you found this

803
00:50:37,130 --> 00:50:40,436
interesting and if you have any questions feel free to reach out to me and

804
00:50:40,458 --> 00:50:43,028
I'm more than happy to try to answer your questions.

