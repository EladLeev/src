1
00:02:01,300 --> 00:02:04,416
Hello all. My name is Vipin Jain and

2
00:02:04,438 --> 00:02:08,396
I am going to speak on a very interesting yet controversial topic,

3
00:02:08,508 --> 00:02:12,516
testing in the production systems. Most of the managers

4
00:02:12,548 --> 00:02:16,152
and customers, if you ask, they are not

5
00:02:16,206 --> 00:02:20,024
very keen to allow the testers to

6
00:02:20,062 --> 00:02:23,608
run certain tests on the production systems. There are

7
00:02:23,614 --> 00:02:27,310
a lot of security issues, there are lot of stability issues,

8
00:02:27,680 --> 00:02:31,260
and they don't want their system to be shut down just because

9
00:02:31,330 --> 00:02:35,672
some test case failed. And this concept

10
00:02:35,736 --> 00:02:39,696
of testing on the production systems is covered well under a

11
00:02:39,718 --> 00:02:42,800
new stream of testing called as chaos testing.

12
00:02:43,540 --> 00:02:47,312
I wrote this paper sometime back when the entire world

13
00:02:47,366 --> 00:02:50,928
was talking about vaccines and immunities due

14
00:02:50,944 --> 00:02:55,396
to the pandemic and hence I use these words for

15
00:02:55,578 --> 00:02:59,092
my topic. Vaccinate your software and

16
00:02:59,146 --> 00:03:03,304
build its immunity. Before we

17
00:03:03,342 --> 00:03:05,370
begin, who am I?

18
00:03:07,420 --> 00:03:10,132
I am a son, a husband and a father.

19
00:03:10,276 --> 00:03:14,190
You can see in this pick. My wife, my daughter and my son are there.

20
00:03:14,880 --> 00:03:18,684
At heart, I am a tester, although by my job I am now

21
00:03:18,722 --> 00:03:21,864
more into deliveries and providing

22
00:03:21,912 --> 00:03:24,796
various solutions to customers all across the world.

23
00:03:24,978 --> 00:03:28,800
Having said that, I am always a speaker by choice because

24
00:03:28,870 --> 00:03:32,720
that led me to travel all across the world and meet people,

25
00:03:32,870 --> 00:03:36,444
hear their ideas, and of course, using the best ideas

26
00:03:36,492 --> 00:03:40,144
into my system. I'm a process advocate

27
00:03:40,192 --> 00:03:43,908
to deliver quality. Since last couple of years I

28
00:03:43,914 --> 00:03:47,568
have entered into blogging and I have written lots of bugs

29
00:03:47,664 --> 00:03:51,444
for various websites. My contacts are here.

30
00:03:51,562 --> 00:03:55,256
You can follow me on LinkedIn, you can follow me on Twitter, and of

31
00:03:55,278 --> 00:03:58,744
course you can always email me if you want to have any kind of

32
00:03:58,782 --> 00:04:01,850
discussion with me.

33
00:04:03,260 --> 00:04:06,764
Now, this image depicts a real life chaos in the system.

34
00:04:06,882 --> 00:04:10,204
You can see the boss is shouting, papers are flying from here and

35
00:04:10,242 --> 00:04:12,110
there people are running,

36
00:04:13,200 --> 00:04:16,736
so there is no system as such. And it looks like the

37
00:04:16,758 --> 00:04:20,876
entire system has gone into a disarray. Now this depicts

38
00:04:20,908 --> 00:04:24,512
chaos. How does this chaos looks

39
00:04:24,566 --> 00:04:27,824
like into a software system?

40
00:04:27,942 --> 00:04:30,310
Let's see everything.

41
00:04:32,520 --> 00:04:36,768
First, let's talk about what exactly is chaos engineering.

42
00:04:36,944 --> 00:04:40,928
Now, as the image depicts chaos engineering like

43
00:04:41,114 --> 00:04:44,744
a vaccine, we inject harm to build immunity into

44
00:04:44,782 --> 00:04:48,324
the system. So if you go by a Google definition,

45
00:04:48,452 --> 00:04:52,276
it says chaos engineering or chaos testing.

46
00:04:52,388 --> 00:04:55,896
It is a highly disciplined approach to test a system's

47
00:04:55,928 --> 00:04:59,304
integrity. How it does that proactively.

48
00:04:59,352 --> 00:05:03,288
It simulates and identify the failures in a given environment

49
00:05:03,464 --> 00:05:07,324
before they lead to unplanned downtime or a negative user

50
00:05:07,372 --> 00:05:11,744
experience. Think of a vaccine or a flu shot where

51
00:05:11,782 --> 00:05:16,204
you inject yourself with a small amount of potentially harmful foreign bodies

52
00:05:16,332 --> 00:05:20,420
in order to build resistance and prevent illness.

53
00:05:21,400 --> 00:05:25,204
Chaos engineering is a tool that we use to build such can

54
00:05:25,242 --> 00:05:28,592
immunity in our technical system by injecting harm.

55
00:05:28,656 --> 00:05:32,128
And what kind of harm we inject into a system, they can

56
00:05:32,154 --> 00:05:35,736
be a latency, it can be a cpu failure, or it can be

57
00:05:35,758 --> 00:05:39,336
a network black hole in order to find and

58
00:05:39,358 --> 00:05:43,064
mitigate potential weaknesses. So this is what

59
00:05:43,102 --> 00:05:46,556
exactly is termed as chaos engineering. And as

60
00:05:46,578 --> 00:05:50,604
I said, like a vaccine, we inject harm into the system

61
00:05:50,722 --> 00:05:52,940
to build the system's immunity.

62
00:05:54,160 --> 00:05:57,344
Let's take a brief look at the history of

63
00:05:57,382 --> 00:06:00,560
how chaos engineering took birth, and where it is

64
00:06:00,630 --> 00:06:04,092
right now in its current shape. So it began

65
00:06:04,156 --> 00:06:07,948
in year 2010, when Netflix designed

66
00:06:08,044 --> 00:06:12,144
what is called as a chaos monkey to test the system stability

67
00:06:12,272 --> 00:06:16,324
by enforcing failures by the pseudo random termination of

68
00:06:16,362 --> 00:06:19,984
instances and services within network Netflix architecture.

69
00:06:20,112 --> 00:06:23,924
So when we are watching a movie on Netflix, what we don't

70
00:06:23,972 --> 00:06:27,464
want is that there should not be

71
00:06:27,502 --> 00:06:31,016
any lag between the two images, between the

72
00:06:31,038 --> 00:06:34,456
videos. The videos should run as a very constant,

73
00:06:34,648 --> 00:06:37,884
regular stream, and we should get a very,

74
00:06:38,002 --> 00:06:41,692
I would say, very smooth movie watching experience,

75
00:06:41,826 --> 00:06:45,004
right? So following their migration to the cloud,

76
00:06:45,122 --> 00:06:49,200
Netflix service was now reliant upon the AWS.

77
00:06:50,100 --> 00:06:53,564
Netflix in 2010 was not able to sustain

78
00:06:53,612 --> 00:06:57,068
its hardware infrastructure, and therefore it moved

79
00:06:57,084 --> 00:07:00,256
to AWS, which basically helped Netflix to

80
00:07:00,278 --> 00:07:04,324
scale up, right? It provided it a technology that

81
00:07:04,362 --> 00:07:07,572
could show them how their system responded when

82
00:07:07,626 --> 00:07:11,224
the critical components of their production service infrastructures were

83
00:07:11,262 --> 00:07:14,900
taken down. Intentionally causing the single failure

84
00:07:14,980 --> 00:07:18,744
would remove any weakness in their system and then guide them

85
00:07:18,782 --> 00:07:22,484
towards automated solutions which gradually handle

86
00:07:22,532 --> 00:07:26,156
failures much, much better way. So this was

87
00:07:26,178 --> 00:07:29,100
the original aim. And that's why in 2010,

88
00:07:29,250 --> 00:07:33,164
Netflix used the first tool called as Chaos monkey to

89
00:07:33,202 --> 00:07:34,190
test everything.

90
00:07:36,100 --> 00:07:38,240
Then it increased.

91
00:07:38,820 --> 00:07:41,820
And in 2011,

92
00:07:41,980 --> 00:07:45,664
apart from Chaos monkeys, Netflix created what is called

93
00:07:45,702 --> 00:07:49,196
as a Simeon army. So it had a geniter monkey,

94
00:07:49,228 --> 00:07:52,272
which identifies and disposes unused resources.

95
00:07:52,416 --> 00:07:56,432
It has a chaos.com, which drops a full AWS region.

96
00:07:56,576 --> 00:07:59,636
It has confirmity monkey, which shut down instances which are

97
00:07:59,658 --> 00:08:03,444
not adhering to the best practices, and similarly, chaos gorilla,

98
00:08:03,492 --> 00:08:06,756
security monkey, Doctor monkey, and latency monkey.

99
00:08:06,868 --> 00:08:10,184
So the entire Simeon army was born, and they

100
00:08:10,222 --> 00:08:14,032
added additional failure injection modes on top of the Chaos monkey

101
00:08:14,116 --> 00:08:17,864
that would allow the testing of more complete suits of failure

102
00:08:17,912 --> 00:08:21,180
states and thus building resilience to those

103
00:08:21,250 --> 00:08:25,832
as well. And in 2020,

104
00:08:25,986 --> 00:08:29,280
just two years ago, Chaos Engineering. Chaos now become

105
00:08:29,350 --> 00:08:33,120
the part of AWS well architectured framework.

106
00:08:35,300 --> 00:08:39,316
This WAF well architectured framework, it is currently into its

107
00:08:39,338 --> 00:08:42,932
8th update, and this was recently announced, which has

108
00:08:42,986 --> 00:08:46,272
included Chaos engineering as the requirement of a stable

109
00:08:46,336 --> 00:08:50,790
system. So, as you can see, within ten years of its

110
00:08:51,180 --> 00:08:54,584
beginning, AWS has

111
00:08:54,622 --> 00:08:58,152
recognized chaos engineering as the requirement of a

112
00:08:58,206 --> 00:09:02,004
reliable system. And when I'm talking about all these historical

113
00:09:02,052 --> 00:09:06,168
things and the products reliable systems, I'm not talking about a simple

114
00:09:06,334 --> 00:09:10,012
software. I'm talking about software which are well

115
00:09:10,066 --> 00:09:13,832
distributed across the world, which relates

116
00:09:13,896 --> 00:09:18,064
to heavy software, I would say, which has a lot

117
00:09:18,102 --> 00:09:21,744
and lot of people footfall. And in these

118
00:09:21,782 --> 00:09:24,960
places, chaos engineering has become very, very crucial.

119
00:09:28,270 --> 00:09:31,734
It has formed something called as chaos testing principles,

120
00:09:31,782 --> 00:09:35,598
which we will be, of course, looking at each one, one at a time.

121
00:09:35,684 --> 00:09:38,654
But just to give you a summary of that.

122
00:09:38,852 --> 00:09:41,918
So, the first principle states that you have to build

123
00:09:42,004 --> 00:09:45,090
a hypothesis around a steady state behavior.

124
00:09:45,750 --> 00:09:49,010
You have to find out some real world events,

125
00:09:49,350 --> 00:09:52,754
some experiments needed to be run on the production system.

126
00:09:52,952 --> 00:09:57,026
Automate these experiments to run continuously and ultimately

127
00:09:57,138 --> 00:10:00,534
minimize the blast radius. I will take you through all

128
00:10:00,572 --> 00:10:04,614
these five to give you a real world idea of how

129
00:10:04,652 --> 00:10:08,810
chaos testing happens and how it is planned.

130
00:10:09,630 --> 00:10:13,622
So, let's first begin with build a hypothesis around steady state behavior

131
00:10:13,686 --> 00:10:16,780
and what exactly this means. So,

132
00:10:17,150 --> 00:10:21,470
let's see this example before I go into any kind of details.

133
00:10:22,290 --> 00:10:25,854
Under dash circumstances, the security team is

134
00:10:25,892 --> 00:10:29,326
notified. This is a simple sentence, and which has a

135
00:10:29,348 --> 00:10:33,730
fill in the blanks. This will lead to under

136
00:10:33,800 --> 00:10:36,978
security control violation circumstances. The security

137
00:10:37,064 --> 00:10:40,786
team is notified. Now, what is happening here?

138
00:10:40,968 --> 00:10:44,626
This blank space is filled by the variables that

139
00:10:44,648 --> 00:10:48,114
you determine. The advanced principles emphasize

140
00:10:48,162 --> 00:10:51,670
building your hypothesis around a steady state definition.

141
00:10:52,090 --> 00:10:55,974
This means focusing on the way the system is

142
00:10:56,012 --> 00:11:00,010
expected to behave and capturing that in a measurement,

143
00:11:00,590 --> 00:11:04,634
you have an idea of what can go wrong. So you

144
00:11:04,672 --> 00:11:07,834
have chosen the exact failure to inject what

145
00:11:07,872 --> 00:11:11,534
happens next? This is an excellent thought

146
00:11:11,572 --> 00:11:15,006
exercise to work through as a team. By discussing the

147
00:11:15,028 --> 00:11:19,002
scenario, you can hypothesize on the expected outcome

148
00:11:19,146 --> 00:11:21,840
before running it in live.

149
00:11:22,630 --> 00:11:26,146
What will be the impact to customers, to your service, or to

150
00:11:26,168 --> 00:11:29,746
your dependencies? This exercise basically

151
00:11:29,848 --> 00:11:32,980
answers that. So, in this particular example,

152
00:11:33,430 --> 00:11:37,138
the entire team sits together, and then they say that, okay,

153
00:11:37,304 --> 00:11:40,418
our first hypothesis is,

154
00:11:40,504 --> 00:11:43,810
under dashed circumstances, security team is notified.

155
00:11:43,970 --> 00:11:48,090
And when all of them agree that under security control

156
00:11:48,160 --> 00:11:51,878
violation circumstances, the security team is notified,

157
00:11:52,054 --> 00:11:55,818
which means everyone is on the same page, that security

158
00:11:55,904 --> 00:12:00,250
team is notified only when there is a security control violation.

159
00:12:02,050 --> 00:12:05,354
Then the second part of this chaos

160
00:12:05,402 --> 00:12:09,482
testing planning is you have to vary the real world events.

161
00:12:09,546 --> 00:12:13,474
Now, what does these mean? It's an advanced principle which

162
00:12:13,512 --> 00:12:17,150
states that the variables in experiments

163
00:12:17,230 --> 00:12:20,178
should reflect real world events. Like for example,

164
00:12:20,264 --> 00:12:23,566
in the previous example around hypothesis,

165
00:12:23,678 --> 00:12:27,286
we talk about a security violation. It's a real world event.

166
00:12:27,388 --> 00:12:30,594
This is not something hypothetical,

167
00:12:30,722 --> 00:12:34,342
right? So while it might seems obvious in the hindsight that,

168
00:12:34,396 --> 00:12:37,830
yes, everyone is using real world events.

169
00:12:39,070 --> 00:12:42,362
Still, it is very important to call this out,

170
00:12:42,496 --> 00:12:45,802
and I'll give you two very good reasons that why

171
00:12:45,856 --> 00:12:49,180
I have decided to explain this here.

172
00:12:50,210 --> 00:12:54,686
What happens is people just don't focus on these things.

173
00:12:54,868 --> 00:12:58,746
People will say that, okay, if I need to gather variables,

174
00:12:58,938 --> 00:13:00,640
let's pick all of them.

175
00:13:02,370 --> 00:13:05,860
So, again, going back to the previous hypothesis example,

176
00:13:06,230 --> 00:13:09,380
without focusing on what is the exact reason,

177
00:13:09,750 --> 00:13:13,474
when the security alarm gets raised, people just

178
00:13:13,512 --> 00:13:17,000
say that, okay, take all the possible reasons where

179
00:13:18,250 --> 00:13:22,182
this security notification has to be made. Or sometimes

180
00:13:22,236 --> 00:13:26,102
they say that, pick any. How does it matter? We just need to run

181
00:13:26,156 --> 00:13:30,306
the scenario. So, variables are often chosen for

182
00:13:30,348 --> 00:13:34,378
what it is easy to do, rather than what provides the most learning value.

183
00:13:34,544 --> 00:13:38,426
That's the first problem. And the second is engineers always have

184
00:13:38,448 --> 00:13:41,982
the tendency to focus on variables that reflect their

185
00:13:42,036 --> 00:13:45,280
experiences rather than the user's experience.

186
00:13:46,050 --> 00:13:49,470
So engineers always remain in a practical state,

187
00:13:49,620 --> 00:13:53,122
they always remain in an experimental state, rather than

188
00:13:53,176 --> 00:13:56,462
thinking about how a user, a real world user,

189
00:13:56,606 --> 00:13:59,380
will see this entire situation.

190
00:13:59,750 --> 00:14:02,900
So, just to explain my two points,

191
00:14:03,590 --> 00:14:07,314
either pick any variable, or the engineers

192
00:14:07,362 --> 00:14:11,394
decide to pick all the variables. And both these scenarios

193
00:14:11,442 --> 00:14:15,302
are completely wrong. You have to really decide what

194
00:14:15,356 --> 00:14:18,762
exactly you want and pick only those variables which have

195
00:14:18,816 --> 00:14:22,282
the most learning value. This becomes the

196
00:14:22,336 --> 00:14:26,374
second program, second principle of chaos

197
00:14:26,422 --> 00:14:29,450
testing. Vary the real world events.

198
00:14:30,910 --> 00:14:34,602
So, what is the next one? We decide that tonight

199
00:14:34,666 --> 00:14:38,522
we test in the production. Wow. Seen from Spartacus

200
00:14:38,666 --> 00:14:42,446
or this is seen from 300. This is seen from 300. Yes.

201
00:14:42,548 --> 00:14:46,322
King Leonidas experimentation teaches us

202
00:14:46,376 --> 00:14:49,746
about the system we are studying. We all know that all

203
00:14:49,768 --> 00:14:53,314
the exploratory testing, all the other types of testings, basically ask

204
00:14:53,352 --> 00:14:56,834
us to experiment while testing in a system. If we are

205
00:14:56,872 --> 00:15:00,594
experimenting in a staging environment, then you build convince. In a staging

206
00:15:00,642 --> 00:15:04,258
environment, if you are experimenting into a pre build phase,

207
00:15:04,354 --> 00:15:08,330
then you are building confidence into the pre build phase. How we are going

208
00:15:08,400 --> 00:15:12,358
to build confidence into the production

209
00:15:12,454 --> 00:15:15,946
system? We are not doing any experiments on

210
00:15:15,968 --> 00:15:19,830
the production system, or I would say we are not allowed

211
00:15:19,910 --> 00:15:23,440
to do any kind of experimentation with the production system.

212
00:15:24,050 --> 00:15:27,738
To the extent that the staging and the production environments

213
00:15:27,834 --> 00:15:31,338
differ, often in ways that a human cannot predict,

214
00:15:31,434 --> 00:15:34,802
you are not building confidence into the environment that I

215
00:15:34,856 --> 00:15:38,450
really care about, which is you care about more

216
00:15:38,520 --> 00:15:41,630
production or the staging? Production,

217
00:15:41,710 --> 00:15:45,362
yes. Every user, the entire business, is based

218
00:15:45,416 --> 00:15:49,074
upon the interactions of real world users with the production

219
00:15:49,122 --> 00:15:52,802
system. But all the experiments, all the user

220
00:15:52,866 --> 00:15:55,954
thinking, all the user planning that the testers

221
00:15:56,002 --> 00:16:00,250
do, how end users would behave, that actually happens on the staging.

222
00:16:00,670 --> 00:16:05,334
So how we are going to build convince

223
00:16:05,382 --> 00:16:06,940
about the production system.

224
00:16:08,190 --> 00:16:11,302
Fine. So for this reason, the most advanced chaos

225
00:16:11,366 --> 00:16:14,030
engineering it takes place on the production.

226
00:16:14,530 --> 00:16:18,154
I know that it is very difficult to convince any senior manager

227
00:16:18,202 --> 00:16:21,674
or the owners or the stakeholders to allow the testers

228
00:16:21,722 --> 00:16:25,326
to run testing on the production system. But chaos testing,

229
00:16:25,358 --> 00:16:28,942
this is all about. So most advanced chaos

230
00:16:29,006 --> 00:16:32,334
testing experiments always run on the production

231
00:16:32,382 --> 00:16:32,980
system.

232
00:16:35,610 --> 00:16:39,522
That becomes our third thing. So use production

233
00:16:39,586 --> 00:16:42,966
to run your experiments. What you are going

234
00:16:42,988 --> 00:16:47,270
to see here, someone in real life is testing

235
00:16:47,630 --> 00:16:51,194
the bulletproof vest and how it is going

236
00:16:51,232 --> 00:16:54,554
to test. Someone just wears that and the other

237
00:16:54,592 --> 00:16:57,962
guy stands in front and shoots. Wow,

238
00:16:58,096 --> 00:17:00,938
that's a real good production experiment.

239
00:17:01,114 --> 00:17:04,190
If it fails, the poor guy dies.

240
00:17:05,170 --> 00:17:08,746
If chaos engineering test fails, the production

241
00:17:08,778 --> 00:17:11,200
system can stop working,

242
00:17:11,810 --> 00:17:14,660
affecting millions of users across the world.

243
00:17:15,590 --> 00:17:19,346
But that's again what chaos engineering talks about. We have

244
00:17:19,368 --> 00:17:23,634
to use production to run my experiments now.

245
00:17:23,832 --> 00:17:28,174
Why? It is constantly pushed

246
00:17:28,222 --> 00:17:32,018
that the chaos engineering chaos testing has to be run on the production.

247
00:17:32,194 --> 00:17:35,894
It is a common belief that there is a set of bugs and

248
00:17:35,932 --> 00:17:39,642
there are some set of vulnerabilities that can be found only

249
00:17:39,696 --> 00:17:43,754
in the production environment which uses some live data or

250
00:17:43,792 --> 00:17:46,986
live traffic. This principle is not

251
00:17:47,008 --> 00:17:50,574
without controversy. I've already told you about. Certainly in some

252
00:17:50,612 --> 00:17:54,602
fields, there are regulatory requirements that prelude

253
00:17:54,746 --> 00:17:59,002
the possibility of affecting the production system. In some situations,

254
00:17:59,066 --> 00:18:03,178
there are insurmountable technical barriers to run these experiments.

255
00:18:03,354 --> 00:18:07,454
So it is important to remember that the point of chaos engineering

256
00:18:07,502 --> 00:18:10,754
is to uncover the chaos inherited in the complex system,

257
00:18:10,872 --> 00:18:14,526
not to cause it. If we know that an experiment

258
00:18:14,558 --> 00:18:18,434
is going to generate an undesirable effect on the production

259
00:18:18,482 --> 00:18:22,482
system or the outcomes, then we should not run that experiment.

260
00:18:22,626 --> 00:18:27,494
Remember that and

261
00:18:27,532 --> 00:18:30,982
how to once we are finalized

262
00:18:31,046 --> 00:18:34,726
with an experiment, the next step is automate your experiments

263
00:18:34,758 --> 00:18:38,266
and run them continuously. Fine. We all know

264
00:18:38,288 --> 00:18:42,026
about what automation is and why automation came into existence,

265
00:18:42,138 --> 00:18:45,438
right? This is quite straightforward thing,

266
00:18:45,604 --> 00:18:48,894
but here it is important for such systems in

267
00:18:48,932 --> 00:18:52,954
two distinct ways. Automation provides a meme

268
00:18:53,002 --> 00:18:56,354
to scale out the search for vulnerabilities that could contribute to

269
00:18:56,392 --> 00:19:00,322
these undesirable systematic outcomes. And it

270
00:19:00,376 --> 00:19:03,650
helps in empirically verifying our assumptions over time

271
00:19:03,720 --> 00:19:06,710
as the unknown parts of the systems are changed.

272
00:19:07,210 --> 00:19:10,454
So it helps in covering a large set of

273
00:19:10,492 --> 00:19:13,510
experiments that the humans can cover manually.

274
00:19:13,850 --> 00:19:17,650
In complex systems, the conditions that could possibly contribute

275
00:19:17,810 --> 00:19:22,058
to an incident are so numerous that they cannot be planned for.

276
00:19:22,224 --> 00:19:25,846
In fact, they can't even be counted because they are unknowable

277
00:19:26,038 --> 00:19:29,382
in advance, which means that humans can't

278
00:19:29,446 --> 00:19:32,906
reliably search the solution space of possible contributing

279
00:19:32,938 --> 00:19:35,198
factors. In a reasonable amount of time.

280
00:19:35,364 --> 00:19:38,926
Automation provides a means to scale out

281
00:19:38,948 --> 00:19:42,886
the search of vulnerabilities that could contribute the undesirable

282
00:19:42,938 --> 00:19:47,246
systematic behaviors, and it also helps empirically verifying

283
00:19:47,278 --> 00:19:50,946
our assumptions over time. So imagine a system where the

284
00:19:50,968 --> 00:19:54,686
functionality of a given component relies on some other component

285
00:19:54,798 --> 00:19:57,060
which is outside the scope of this test.

286
00:19:57,450 --> 00:20:00,534
Now, this is the case of almost all the complex systems because

287
00:20:00,572 --> 00:20:04,674
of the third party controls and tools which get connected and communicate

288
00:20:04,722 --> 00:20:08,146
through web services. Without the tight coupling

289
00:20:08,178 --> 00:20:12,730
between the given functionalities and all the dependencies, it is entirely possible

290
00:20:12,880 --> 00:20:15,978
that one of the dependencies will be changed in such a way

291
00:20:16,064 --> 00:20:19,180
that it creates a vulnerability in the entire system.

292
00:20:19,710 --> 00:20:23,674
Continuous experimentation provided by automation can catch

293
00:20:23,722 --> 00:20:27,198
these issues and teach the primary operators about

294
00:20:27,284 --> 00:20:31,120
how the operations of their own system is changing over time.

295
00:20:32,210 --> 00:20:35,506
This could be a change in the performance, like for example the

296
00:20:35,528 --> 00:20:38,462
network is becoming saturated by noisy neighbors,

297
00:20:38,606 --> 00:20:42,318
or a change in functionality. For example, the response

298
00:20:42,334 --> 00:20:45,810
bodies of a downstream services are including extra

299
00:20:45,880 --> 00:20:49,654
information that could impact how they are parsed. Or it

300
00:20:49,692 --> 00:20:52,966
may be just a change in the human expectations, like for

301
00:20:52,988 --> 00:20:56,514
example, the original engineers. They leave the team and the new engineers

302
00:20:56,562 --> 00:20:59,130
are not as familiar with the current role.

303
00:20:59,950 --> 00:21:03,658
So automation definitely has to be here because

304
00:21:03,744 --> 00:21:08,090
it will continuously check all the possible scenarios

305
00:21:08,430 --> 00:21:12,670
that it is made up of and giving us a constant feedback.

306
00:21:14,370 --> 00:21:18,618
And then finally the last principle,

307
00:21:18,794 --> 00:21:22,400
you have to keep the blast radius as small as possible.

308
00:21:23,090 --> 00:21:24,850
What is the blast radius?

309
00:21:26,310 --> 00:21:30,114
When you run chaos test on a production system, we always run

310
00:21:30,152 --> 00:21:32,834
chaos test on a small part of the system,

311
00:21:33,032 --> 00:21:36,694
because we always have to keep this in mind that if something goes

312
00:21:36,732 --> 00:21:39,560
wrong, the production system can stop.

313
00:21:40,330 --> 00:21:44,354
So rather than having a test which can affect the entire production

314
00:21:44,402 --> 00:21:47,334
system, the test should be as small as possible,

315
00:21:47,452 --> 00:21:51,158
so that the blast which happened due

316
00:21:51,174 --> 00:21:54,230
to that test not working correctly,

317
00:21:54,390 --> 00:21:59,914
affects just a very small part of the system which

318
00:21:59,952 --> 00:22:03,502
can be corrected and put the correct fix into the place

319
00:22:03,556 --> 00:22:07,166
in a very quick amount of time. So you have to use a

320
00:22:07,188 --> 00:22:10,714
tightly orchestrated control group to compare within a variable

321
00:22:10,762 --> 00:22:14,338
group. Experiments can be constructed in such a way

322
00:22:14,424 --> 00:22:18,094
that the impact of the discovered hypothesis on the customer traffic

323
00:22:18,142 --> 00:22:21,694
is minimal. How a team goes about achieving

324
00:22:21,742 --> 00:22:24,820
this is highly context sensitive to the complex system.

325
00:22:25,750 --> 00:22:29,458
Some systems it may mean using shadow traffic, or extruding requests

326
00:22:29,474 --> 00:22:32,886
that have high business impacts, like transactions over dollar hundred,

327
00:22:33,068 --> 00:22:36,514
or implementing automated retry logic for requests.

328
00:22:36,642 --> 00:22:40,026
In the experiment that failed in the case of

329
00:22:40,048 --> 00:22:44,470
chaos teams work at Netflix, sampling of requests, sticky sessions

330
00:22:44,550 --> 00:22:47,862
and similar functions not only limited the blast radius,

331
00:22:48,006 --> 00:22:52,830
they had the added benefit of strengthening signal detections however

332
00:22:52,900 --> 00:22:56,446
it is achieved. This advanced principle emphasizes that

333
00:22:56,548 --> 00:23:00,762
in truly sophisticated implementations of chaos engineering,

334
00:23:00,906 --> 00:23:05,106
the potential impact of the experiments has to be limited by

335
00:23:05,208 --> 00:23:08,674
design. So, these are the five principles on

336
00:23:08,712 --> 00:23:12,562
which the chaos testing is built upon and which

337
00:23:12,616 --> 00:23:15,818
helps in your chaos testing, planning,

338
00:23:16,014 --> 00:23:20,022
and the final execution. Now, I will take you to

339
00:23:20,076 --> 00:23:23,590
a real life scenario and how everything

340
00:23:23,660 --> 00:23:26,934
got built up there. So, this is one of

341
00:23:26,972 --> 00:23:30,346
my favorite part of this entire presentation, which is

342
00:23:30,368 --> 00:23:34,122
called as chaos testing execution rules. Now, this is

343
00:23:34,176 --> 00:23:38,010
a simple two by two matrix of known and unknowns.

344
00:23:39,230 --> 00:23:42,586
On the left hand side, known are the things we are aware

345
00:23:42,618 --> 00:23:45,998
of, and unknown are the things we are not aware of.

346
00:23:46,164 --> 00:23:49,950
And on the bottom, knowns are the things we understand,

347
00:23:50,100 --> 00:23:53,662
and unknowns are the things we don't understand. So the difference

348
00:23:53,716 --> 00:23:57,666
is just between things that we are aware of and things that we understand

349
00:23:57,768 --> 00:24:01,074
or don't understand. Point number one is

350
00:24:01,112 --> 00:24:04,786
called as known knowns, things you are aware of

351
00:24:04,888 --> 00:24:08,502
and the things that you understand. Point number two

352
00:24:08,556 --> 00:24:12,230
is called as known unknowns, things you are aware of

353
00:24:12,300 --> 00:24:16,274
but do not fully understand. Unknown knowns

354
00:24:16,322 --> 00:24:20,166
is the point number three, where things you understand but you are not aware

355
00:24:20,198 --> 00:24:24,710
of. And finally, point number four is unknown unknowns,

356
00:24:24,870 --> 00:24:28,086
which means things you are neither aware of nor fully

357
00:24:28,118 --> 00:24:31,514
understand. Don't get confused. I'll take

358
00:24:31,552 --> 00:24:35,150
a real world example, and then I'll try to explain all these four.

359
00:24:35,300 --> 00:24:39,086
But as I've said, this is a very, very simple matrix, which you

360
00:24:39,108 --> 00:24:42,590
will see in the next slide. And just the difference is

361
00:24:42,660 --> 00:24:46,610
between the things that we are aware of and the things that we understand

362
00:24:46,760 --> 00:24:50,466
or the things that we are not aware of and the things that we do

363
00:24:50,488 --> 00:24:54,290
not understand. Let's take a real life

364
00:24:54,440 --> 00:24:58,006
chaos testing scenario. Now, what does

365
00:24:58,028 --> 00:25:01,638
this scenario means? There is

366
00:25:01,644 --> 00:25:05,254
a region a in the entire system right

367
00:25:05,452 --> 00:25:08,982
here. What we is present is we have a primary database

368
00:25:09,046 --> 00:25:13,094
host with two replicas, and then we use a semisync

369
00:25:13,142 --> 00:25:14,170
replication.

370
00:25:17,550 --> 00:25:21,558
We also have a pseudo primary and two pseudo replicas

371
00:25:21,654 --> 00:25:25,610
in different region. So the entire region a gets replicated

372
00:25:25,690 --> 00:25:29,050
into a region b. So the primary

373
00:25:29,130 --> 00:25:32,814
replica one and replica two, they are the real functional ones. And then

374
00:25:32,852 --> 00:25:36,366
there is a pseudo of primary replica one and replica

375
00:25:36,398 --> 00:25:39,458
two. Simple thing. Region A, region B.

376
00:25:39,544 --> 00:25:43,650
Everything in region a is converted is duplicated into

377
00:25:43,720 --> 00:25:47,246
region b. Now, let's try to build the known unknown

378
00:25:47,278 --> 00:25:49,030
matrix on this scenario.

379
00:25:52,510 --> 00:25:56,102
Setting up the knowns and unknowns first is known

380
00:25:56,166 --> 00:25:59,306
knowns. When a replica shuts down,

381
00:25:59,408 --> 00:26:01,950
it will be removed from the cluster.

382
00:26:02,930 --> 00:26:06,954
A new replica will then be cloned from the primary and added

383
00:26:07,002 --> 00:26:10,554
back to the cluster. So if the replica

384
00:26:10,602 --> 00:26:14,250
shuts down, it will be removed from the cluster,

385
00:26:14,410 --> 00:26:18,314
and then a new replica will then be cloned from the primary and added

386
00:26:18,362 --> 00:26:21,920
back to the cluster. So again, if I go back.

387
00:26:24,530 --> 00:26:28,486
Sorry. Yes. So, these two replicas, if any

388
00:26:28,508 --> 00:26:32,098
one of them gets shut down, it is removed

389
00:26:32,114 --> 00:26:36,280
from this cluster, a new clone is made and put here as

390
00:26:36,730 --> 00:26:39,386
a new replica. That's the process.

391
00:26:39,568 --> 00:26:42,250
So this becomes the known knowns.

392
00:26:44,750 --> 00:26:48,086
What is known unknown here. So the clone will occur.

393
00:26:48,118 --> 00:26:51,402
We know that, as we have logs that confirm,

394
00:26:51,466 --> 00:26:55,466
even if it succeeds or fails. So when the replica shuts

395
00:26:55,498 --> 00:26:58,720
down and we try to reclon it,

396
00:26:59,250 --> 00:27:02,730
even if the process fails, there are logs which confirm.

397
00:27:02,810 --> 00:27:06,286
So this is something we know. But what we don't

398
00:27:06,318 --> 00:27:10,114
know is the weekly average of the meantime it takes from

399
00:27:10,152 --> 00:27:13,826
experiencing a failure to adding a clone back to the

400
00:27:13,848 --> 00:27:17,014
cluster. Effectively, it may take few minutes, it may

401
00:27:17,052 --> 00:27:20,054
take an entire hour, or it may take an entire day.

402
00:27:20,172 --> 00:27:24,310
This we don't know. So this becomes the known unknowns.

403
00:27:26,810 --> 00:27:30,706
Then let's go to the unknown unknowns. What is unknown

404
00:27:30,738 --> 00:27:34,346
here? If we shut down the two replicas of the cluster at the

405
00:27:34,368 --> 00:27:37,622
same time, we don't know exactly the meantime,

406
00:27:37,686 --> 00:27:41,354
it would take us to clone two new replicas of the existing

407
00:27:41,402 --> 00:27:44,970
primary. Remember? So just imagine

408
00:27:45,050 --> 00:27:47,920
replica one, replica two, both get shut down.

409
00:27:48,770 --> 00:27:52,526
We have never tried that. So we don't know how much time it

410
00:27:52,548 --> 00:27:56,222
will take for the primary to be cloned

411
00:27:56,366 --> 00:28:00,754
twice and putting both the systems into the

412
00:28:00,792 --> 00:28:04,274
entire system. Both the replicas into the entire system.

413
00:28:04,472 --> 00:28:08,166
But what is known is we have a pseudo primary and two

414
00:28:08,188 --> 00:28:11,954
replicas which will also recording all the transactions

415
00:28:12,002 --> 00:28:15,846
that are happening here. So it's a pseudo thing, which is.

416
00:28:15,948 --> 00:28:19,254
So we know about that. So this becomes unknown

417
00:28:19,382 --> 00:28:22,474
and known. And finally, the last

418
00:28:22,512 --> 00:28:26,106
one. Unknowns. Unknowns. What would happen if

419
00:28:26,128 --> 00:28:29,754
we shut down this entire cluster, the primary replica one,

420
00:28:29,792 --> 00:28:32,860
replica two. What would happen if this entire thing goes down?

421
00:28:33,870 --> 00:28:37,162
Will the pseudo region be able to fail over effectively?

422
00:28:37,226 --> 00:28:40,446
Because we have not run yet this scenario. So if

423
00:28:40,468 --> 00:28:43,726
this entire system goes down, we don't know whether the pseudo region

424
00:28:43,758 --> 00:28:47,890
will also go down gracefully or effectively.

425
00:28:48,870 --> 00:28:52,114
We have never tried that. Why? Because this

426
00:28:52,152 --> 00:28:55,778
primary, pseudo one and pseudo two are the production system.

427
00:28:55,944 --> 00:28:58,520
We have never tried to shut it down completely.

428
00:28:58,970 --> 00:29:02,178
Hence, we don't even know whether the pseudo would shut

429
00:29:02,194 --> 00:29:05,586
down effectively or not. So chaos testing

430
00:29:05,618 --> 00:29:09,798
is the highly disciplined approach to test a system's integrity.

431
00:29:09,974 --> 00:29:13,446
This I have already talked about. And chaos testing

432
00:29:13,478 --> 00:29:16,986
relies on the production identification of errors within a

433
00:29:17,008 --> 00:29:20,822
system. So, with this metrics that I have created of

434
00:29:20,896 --> 00:29:24,926
known and unknowns, things that you understand and things that you know,

435
00:29:25,108 --> 00:29:28,846
you can create your entire hypothesis and entire

436
00:29:28,948 --> 00:29:32,954
planning about how to go about performing chaos

437
00:29:33,002 --> 00:29:36,354
testing. Okay, we have said

438
00:29:36,392 --> 00:29:40,258
many things about chaos testing and principles and everything.

439
00:29:40,424 --> 00:29:44,478
But the point is, does it have any benefits except

440
00:29:44,654 --> 00:29:47,918
finding certain bugs which can be present only in

441
00:29:47,944 --> 00:29:51,160
the production because of the live traffic that is coming in?

442
00:29:52,490 --> 00:29:56,342
Or is it more beneficial to not to run those scenarios because

443
00:29:56,396 --> 00:30:00,760
then the system will remain up and everything which is working fine on

444
00:30:01,130 --> 00:30:04,874
your pre prod systems will be just replicated on the

445
00:30:04,912 --> 00:30:08,982
production? The answer is chaos testing

446
00:30:09,046 --> 00:30:12,814
definitely has benefits and it has benefits for customers.

447
00:30:12,932 --> 00:30:16,782
It has benefits for technical people and for the business.

448
00:30:16,916 --> 00:30:20,910
And here are the benefits benefits

449
00:30:20,980 --> 00:30:24,466
of performing chaos testing for the customers. Definitely there

450
00:30:24,488 --> 00:30:27,460
is an increased availability and durability of the service.

451
00:30:29,110 --> 00:30:32,722
It means there is no outage disrupt their

452
00:30:32,776 --> 00:30:36,406
day to day lives. That's number one.

453
00:30:36,508 --> 00:30:40,006
Because most of the effects that

454
00:30:40,108 --> 00:30:44,086
most of the harmful effects on

455
00:30:44,108 --> 00:30:47,138
the production system due to the live traffic will be caught,

456
00:30:47,234 --> 00:30:50,634
corrected, and the system is made more and more

457
00:30:50,672 --> 00:30:53,980
efficient, which means the customers will not face,

458
00:30:55,870 --> 00:30:59,354
I won't say any downtime, but I would definitely say very

459
00:30:59,392 --> 00:31:03,294
rare downtimes. So this is for the customer. What about

460
00:31:03,332 --> 00:31:06,654
the businesses? The businesses will prevent big

461
00:31:06,692 --> 00:31:10,186
losses in the revenue and the maintenance cost because the systems

462
00:31:10,218 --> 00:31:13,674
are up all the time. They are more happy and more engaged

463
00:31:13,722 --> 00:31:17,202
engineers because they don't have to spend extra weekends and long hours

464
00:31:17,256 --> 00:31:20,702
to correct production failures. The incident

465
00:31:20,766 --> 00:31:23,854
management system also gets improved because of the chaos

466
00:31:23,902 --> 00:31:28,178
testing results. Whatever results that chaos testing identifies,

467
00:31:28,354 --> 00:31:32,274
they actually will be locked under incident management

468
00:31:32,322 --> 00:31:36,066
system. Because if chaos testing is not executed

469
00:31:36,098 --> 00:31:39,402
on the production system, then when the real

470
00:31:39,456 --> 00:31:43,574
user use that production system and find something error,

471
00:31:43,702 --> 00:31:47,226
he will always call upon the incident management system team

472
00:31:47,328 --> 00:31:50,810
and say that hey, this software is not working fine

473
00:31:50,880 --> 00:31:55,582
or I was trying to do some payment and the payment is not going

474
00:31:55,636 --> 00:31:59,914
through. Can you please look it into it urgently now? Because chaos

475
00:31:59,962 --> 00:32:04,066
testing is running on the production system, many of these issues will

476
00:32:04,088 --> 00:32:07,790
be uncovered during the testing phase. Which means the incident

477
00:32:07,870 --> 00:32:11,714
management system already knows a lot of issues

478
00:32:11,832 --> 00:32:14,994
that may come from the real world

479
00:32:15,032 --> 00:32:18,614
users because it has already seen those things as

480
00:32:18,652 --> 00:32:22,326
the output of the chaos testing. So this is

481
00:32:22,348 --> 00:32:26,658
the big advantage. And finally, for the technical teams,

482
00:32:26,834 --> 00:32:30,006
insights from the chaos testing means there are reduction in

483
00:32:30,028 --> 00:32:33,434
incidents because a lot of real world incidents are already caught and

484
00:32:33,472 --> 00:32:37,466
corrected. There is a reduction in the on call burdens because of

485
00:32:37,488 --> 00:32:40,540
course, happy people, happy customers will call less.

486
00:32:40,850 --> 00:32:44,554
There is an increased understanding of the system failure modes.

487
00:32:44,682 --> 00:32:48,734
So by looking at every chaos output, which is

488
00:32:48,772 --> 00:32:50,750
I can say that as a chaos bug,

489
00:32:52,370 --> 00:32:55,966
it won't be an easy bug because all

490
00:32:55,988 --> 00:33:00,370
the easy bugs are identified pre prod and by the qas.

491
00:33:00,870 --> 00:33:04,242
So the bugs has to be the debugs, the bug has to be,

492
00:33:04,376 --> 00:33:07,494
I would say a complex user journey bug. So more

493
00:33:07,532 --> 00:33:10,930
bugs identified on the production system using live traffic.

494
00:33:11,090 --> 00:33:14,902
It always helps in understanding the system failure modes better.

495
00:33:15,036 --> 00:33:18,734
And as I said, the incident management system overall improves

496
00:33:18,802 --> 00:33:22,730
as much as possible. So these are the various benefits

497
00:33:22,880 --> 00:33:25,370
of performing chaos testing.

498
00:33:27,310 --> 00:33:31,086
There is something called as eight fallacies of distributed system which I

499
00:33:31,108 --> 00:33:34,510
picked from a website called as Architecturenodes Co.

500
00:33:34,660 --> 00:33:38,782
Now what exactly these fallacies are and

501
00:33:38,836 --> 00:33:42,906
why I have put this slide into the chaos

502
00:33:42,938 --> 00:33:46,510
testing discussion. Now if you see these fallacies,

503
00:33:46,670 --> 00:33:49,090
first one, the network is reliable.

504
00:33:49,990 --> 00:33:53,234
We all use Internet. We all download things, we all

505
00:33:53,272 --> 00:33:56,610
upload things, we go for our voice calls, we watch movie,

506
00:33:57,030 --> 00:34:00,418
and we never think whether the network will shut

507
00:34:00,434 --> 00:34:03,702
down or not. In the back of the mind there is always

508
00:34:03,756 --> 00:34:07,106
this concept that the network is reliable, it won't

509
00:34:07,138 --> 00:34:10,380
break. Similarly the latency is zero.

510
00:34:10,990 --> 00:34:15,130
Similarly, there is only one administrator of the entire Internet.

511
00:34:15,470 --> 00:34:19,126
The bandwidth is infinite, the network is secured,

512
00:34:19,318 --> 00:34:23,390
the topology never changes, the network is homogeneous,

513
00:34:24,530 --> 00:34:28,142
and finally, the transport cost of any packet from one place

514
00:34:28,196 --> 00:34:32,430
to another is zero. These are the fallacies for

515
00:34:32,500 --> 00:34:35,006
every user who is using Internet.

516
00:34:35,198 --> 00:34:37,540
But does any of them,

517
00:34:39,030 --> 00:34:41,540
any of them? Are they correct?

518
00:34:41,910 --> 00:34:45,374
Is there only one admin? Is the bandwidth

519
00:34:45,422 --> 00:34:49,190
infinite? Is the network reliable? Is it secured?

520
00:34:49,850 --> 00:34:52,840
We know that no, this is not the case.

521
00:34:53,690 --> 00:34:57,720
But to give a user the experience of his life,

522
00:34:58,270 --> 00:35:00,940
a smooth network usage experience,

523
00:35:01,870 --> 00:35:04,982
these fallacies need to be tested continuously.

524
00:35:05,046 --> 00:35:08,854
And that can be done if we do chaos

525
00:35:08,902 --> 00:35:12,842
testing on the systems. So many of these fallacies,

526
00:35:12,906 --> 00:35:16,506
they drive the design of chaos engineering experiments.

527
00:35:16,618 --> 00:35:20,430
For example, packet loss attacks or latency attacks.

528
00:35:20,770 --> 00:35:24,766
For example, if a network outage can cause a range of failures

529
00:35:24,958 --> 00:35:27,860
for applications that severely impact customers,

530
00:35:28,470 --> 00:35:31,538
applications may stall while they wait endlessly for a

531
00:35:31,544 --> 00:35:34,834
packet. Applications may permanently consume energy

532
00:35:34,952 --> 00:35:38,214
on, let's say, a Linux system. And even

533
00:35:38,252 --> 00:35:41,446
after a network outage has passed, application may fail to

534
00:35:41,468 --> 00:35:45,510
retry the stalled operations or it may retry too aggressively.

535
00:35:46,010 --> 00:35:49,434
Applications may even require a manual start. So each

536
00:35:49,472 --> 00:35:53,338
of these examples, they need to be tested and prepared. And these can be done

537
00:35:53,424 --> 00:35:57,082
only if we are running chaos testing on

538
00:35:57,136 --> 00:35:58,810
our production systems.

539
00:36:01,070 --> 00:36:05,178
So I know that this is not easy to convince any managers,

540
00:36:05,274 --> 00:36:08,862
but when you try to convince them by explaining these things,

541
00:36:08,916 --> 00:36:12,558
when you try to convince them by saying

542
00:36:12,724 --> 00:36:16,260
that, look, every production system has certain issues.

543
00:36:16,630 --> 00:36:21,346
Because the production system receives its data live and

544
00:36:21,448 --> 00:36:24,930
we don't have any control on the live data, we may

545
00:36:25,000 --> 00:36:27,670
uncover certain very good bugs,

546
00:36:28,090 --> 00:36:31,862
which makes our system more and more reliable for the end users across

547
00:36:31,916 --> 00:36:35,174
the world. Right. Allow us

548
00:36:35,212 --> 00:36:39,098
to perform chaos testing and then plan for the chaos testing in

549
00:36:39,104 --> 00:36:42,140
a very proficient way. Very efficient way.

550
00:36:43,070 --> 00:36:46,726
Put your blast radius, very small, plan for automation

551
00:36:46,838 --> 00:36:50,006
and all the other build your hypothesis.

552
00:36:50,118 --> 00:36:53,286
So, all the five points that I explained earlier, then prepare

553
00:36:53,318 --> 00:36:57,098
your own metrics and finally run your experiments.

554
00:36:57,274 --> 00:37:00,830
And then show the managers, show the stakeholders that

555
00:37:00,900 --> 00:37:04,074
yes, the time and money that we have invested in chaos

556
00:37:04,122 --> 00:37:08,094
testing has actually made

557
00:37:08,132 --> 00:37:10,510
their system more and more reliable.

558
00:37:11,890 --> 00:37:15,440
With this, I come to the end of

559
00:37:15,930 --> 00:37:19,190
this talk. Thank you for hearing me patiently.

