{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/73606a47-42b6-4819-8f54-8ccd82093984", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["aiding", "build", "conf fourty two", "dataset", "healthcare", "incoming enterprise software engineering intern", "ml", "predictions", "project", "state farm", "train", "utilizing", "yogesh seenichamy"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "id": "be556976-439e-47a3-aa50-0c634a70f13f", "status": "completed", "error": null, "text": "So, hello and welcome to everyone who's decided to join me for this talk today. I'm Irisini Chami, and today I'll be discussing how we can utilize the power of machine learning in healthcare. So, to start off, I think the best way of fully showing how useful machine learning is in healthcare is to try to find a specific problem we can apply to. For this presentation, I chose heart failure just because of how impactful it was. I'll talk about heart failure in general for the first part. Then I'll talk about neural networks and the algorithms behind it. Then I'll talk about how we can apply the algorithm of neural networks to the problem of heart failure, and then how we can try to make that neural network that predicts heart failure into like, an actual deployable model. So just some background on heart failure. Basically, heart failure has been proven to be a major public health concern that's negatively affected millions of people worldwide. It's basically when the heart is unable to pump blood effectively, which can cause a buildup of fluid in the lungs as well as other organs. As you can see by these various metrics here, one out of every five deaths in the United States are caused by heart disease. The average cost in the United States for treating heart failure is $30,000. And there's limited accuracy for traditional methods of predicting heart failure. When I say traditional methods, I mean like clinical assessments, which are the long standing method of predicting heart failure, which are basically like a doctor looking at a patient's symptoms, looking at their medical history, and conducting a physical examination. And also imaging techniques like ct scans, mris, and also biomarkers, which are basically measurable substances in the body that can indicate a biological process. All these have limitations in various forms with clinical assessments and biomarkers. They're not specific enough where it could lead to delayed diagnosis in the treatment of heart failure. And then there's modern imaging techniques, which are basically too expensive, and there hasn't been a lot of research surrounding it. So just some more background on the current limitations of heart failure. It's the leading cause of death. As I said earlier, it accounts for approximately 655,000 United States each year. Traditional methods, like the clinical assessment, can lead to inconsistencies and errors in diagnosis, and it's costly and time consuming. This time consuming process can create delays in diagnosis, which could result in a negative patient outcome. And this is where machine learning comes in. Specifically, neural networks is what I'm going to talk about in this presentation. But as you guys, I'm sure all familiar with. It's a field that's been growing in popularity recently and has potential to be really useful in problems like these. Machine learning's ability to analyze large volumes of data makes them very useful because it can look at trends that aren't apparent with the traditional methods that I'm explaining earlier. There's already been a lot of literature in the machine learning field that examines the use of machine learning algorithms for heart failure prediction. And they found that machine learning is more accurate compared to traditional models. So in this presentation, I just chose to do neural networks because that's what seems to be really popular right now. So basically, neural networks are in interconnected layers of neurons. It attempts to mimic the brain in that it has neurons, which are each of these dots here that are connected with each other. And basically, when one fires, it triggers a sense in the layers following it. So it typically consists of an input layer and an output layer with multiple hidden layers. And in each of these input layers, in our case, the input layer would be various characteristics of the patient, so it would be like their age, their maximum heart rate, et cetera. Hidden layers are just here for complexity in that it allows the neural networks to basically learn using two main algorithms, forward propagation and backward propagation. And the output layer in our scenario is just going to be one neuron from zero to one, where zero would basically mean that the patient does not have that high of an outcome, of that high of a likelihood of getting heart failure where one is, the model is confident that the patient will get heart failure. So hang on. For any task like this, we need data. This is from Kaggle. If you guys wanted to find any other data sets you wanted to use, I think Kaggle would be a great resource here. This guy's compiled from different hospitals, from the UCI machine learning repository, and combined the common features into one big one. And that makes this better than other hard failure prediction data sets that are out there, because this allows me to have more rows and more data to train on. So I have the link here, and you guys should be able to find the slide deck if you guys want to follow along. Just some information about the data set. It has various numerical characteristics, like age, resting blood pressure and cholesterol, and it also has categorical columns like the chest train type and the gender and the resting electrocardiogram results. So these are all just various attributes that will allow us to help in the predictions of heart failure. Moving on. Sorry. Yeah, in this demo, I'm just going to use Google Colab because it's pretty easy to follow along with. You don't really need a lot of gpus materials as well as it already has tensorflow installed in it. So to start off, go to the Kaggle data set that I mentioned earlier and download the csv. And then in a new Google Colab notebook we can import pandas. And that basically allows us to manipulate CSVs and read them in. So we set a variable and set it equal to reading in the csV. And then I call the dot head function on it, which allows me to see the first five rows. And we can see that these are basically different patient records. So each of these rows represents a different patient. And we can see like this guy was 40, a male, had a resting blood pressure of 140, and he had a heart disease column of zero. So this means that the patient did not actually end up getting heart failure. So it's just pretty interesting to see. Normally you would do a lot of analyzing the data, but I think with the scope of this presentation, I'm just going to hop straight into the pre processing the data. So neural networks take in basically numbers exclusively. So we need to convert the categorical columns into numerical columns. And we can do this through something called one hot encoding, which is basically like, you take in, I'll go back to this part, you take in each of these columns and then set it equal to, sorry, take in each one of these outputs that are possible from one of these categorical columns and then set each of these equal to a new column. Then we would go through each value inside of this categorical column and set it equal to one for the thing that's actually matching on the value for it and set it equal to zero for everything else, which is just a way of converting the categorical columns into numerical columns. So we do that for each of the categorical columns in the data set. And then we remove the categorical columns and add these numerical columns that we just added. And then now we can call head. So we can see before that our 40 year old patient had an ascent at eight chest pain type. And now if we go here, there's no column for chest pain type. Instead there's just these different columns. So we can see here that for ATA, the guy has one and zero for everything else, which just allows us, the neural network, to have that kind of information that's preserved from the categories. So then we get our input and our output arrays. So our x or our input is just everything except the heart disease column. And our output, which is what we're predicting, is just the heart disease column. And then we can use sklearn functions to further preprocess the data. We can import their train test split to split up the input and output into a training and testing data set. I put the test size as 0.2, so we can use 20% of the data set for testing accuracy. I think there's around 1000 rows, so there should be around 800 records for the model to learn on and around 200 for us to do testing on. So then from there we can do feature scaling on it. Because neural network essentially likes to have small numbers, and doing a standard scalar on it allows us to achieve that. So then we fit the training and testing on the standard scalar. So now we have an x train and x test, and then from here we can create a model or the neural network. This is kind of like the architecture I chose for it, to be honest, a lot of the choices are arbitrary. In the real world, I think you would mess around a lot more with these values and to try to see what could give you the best accuracy. But for the purposes of this demonstration, we have our input layer, and that connects to a hidden layer containing 16 neurons connecting to another hidden layer containing 16 neurons, and that connects to another output layer, which contains just one neuron. All these connected together makes up our sequential model. I use keras to create the neural network, which is just like an extension of tensorflow. To make it easier to create them, all I had to do was just import the sequential model from Keras models and the dense layer from keras layers, and then I could set my model equal to sequential and then add my different layers. So this line of code basically takes in my input layer. So I set the dimensions of the input layer equal to whatever the shape of my first value in my training data set was. So it would like scale with it. And then I set 16 neurons for the next layer. So it just matches up just like this. That connects to another layer containing 16 neurons, and then our output layer contains one neuron. One thing I do want to note is like the activation functions, Relu means rectified linear unit. And that's basically a graph that looks just like zero for everything up to zero, and then the value from zero onwards. So it's basically like a piecewise function where it's like it's zero for everything that's negative, and then it's just a positive value for anything that's positive. And that adds like a nonlinear complexity that allows the neural network to learn. Sigmoid just squishes all values between zero and one, which is essentially what we need in our output layer to create a prediction value for a patient. So that allows us to achieve that. We then compile our model using an optimizer. I chose Adam, a loss function, which basically is what the model uses to see how bad it is when learning, so it can adjust its weights and biases in these different arrows to try to create a better output. Um, from there, I chose a metric of accuracy. So then you fit the model on our training data with a validation split of 33%, which just gives us information as the model is training about how well it's doing. And then epochs equals 100, so that's how many times it forward propagates and backward propagates. Generally, more is better accuracy up to a certain point where there's minimal train. So then I trained the model on it, and then I tested the accuracy of it on the actual testing data set. So, like data it's never seen before, this is like the best indicator of what the data looks like in the real world. So I set a variable of predictions equal to the model predicting on every single value from the x underscore test. And then what I did was, for each of those predictions, if it was greater than 0.5, I made that a one. And if it was less than 0.5 or equal to it, I made it e zero. So if it was less than or equal to 0.5, the model basically predictions that the patient doesn't have heart failure in the future, and if it was greater than 0.5, then the model predictions that the patient does have heart failure. And when we ended up doing that and use the accuracy score metric from Sklearn, we got an accuracy of around 79%, which isn't too bad considering how few lines of code this really is. And I feel like if I tweaked it around more, we could get a much better accuracy. But other than that, that's basically it for the model creation part of it. What you could do next is try to take this model variable and host it somewhere. So, this is something that when I was trying to choose machine learning models to use on the data set, I made like an input form where you could input your age values, your resting blood pressure, and it would give you a heart failure prediction. So it's just something that I thought was cool, and you could also learn more about heart failure and stuff. But other than that, that's it for this talk. Thank you for joining me. If you're curious and you want to play around with the code a little bit more. I've left the colab link, which I think you can see in the slides here, but other than that, thank you for your time.", "words": [], "utterances": null, "confidence": 0.946136031144784, "audio_duration": 964.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- One out of every five deaths in the United States are caused by heart disease. There's limited accuracy for traditional methods of predicting heart failure. Machine learning can look at trends that aren't apparent with traditional methods. This is where neural networks come in.\n- In this demo, I'm just going to use Google Colab because it's pretty easy to follow along with. We need to convert the categorical columns into numerical columns. And then we can use sklearn functions to further preprocess the data. From here we can create a model or the neural network.", "auto_highlights_result": {"status": "success", "results": [{"count": 2, "rank": 0.08, "text": "heart failure prediction", "timestamps": [{"start": 224248, "end": 225406}, {"start": 940524, "end": 941426}]}, {"count": 20, "rank": 0.08, "text": "heart failure", "timestamps": [{"start": 45922, "end": 46514}, {"start": 50612, "end": 51146}, {"start": 62212, "end": 63270}, {"start": 68334, "end": 68894}, {"start": 72712, "end": 73650}, {"start": 74648, "end": 75422}, {"start": 101098, "end": 101546}, {"start": 106378, "end": 107370}, {"start": 115678, "end": 116286}, {"start": 150064, "end": 150994}, {"start": 162932, "end": 163850}, {"start": 224248, "end": 224686}, {"start": 308372, "end": 309194}, {"start": 313748, "end": 314670}, {"start": 384588, "end": 385590}, {"start": 454932, "end": 455978}, {"start": 884748, "end": 885266}, {"start": 890828, "end": 891850}, {"start": 940524, "end": 941026}, {"start": 945628, "end": 946146}]}, {"count": 1, "rank": 0.07, "text": "machine learning models", "timestamps": [{"start": 930476, "end": 931506}]}, {"count": 1, "rank": 0.07, "text": "other hard failure prediction data sets", "timestamps": [{"start": 344272, "end": 345798}]}, {"count": 4, "rank": 0.07, "text": "heart disease", "timestamps": [{"start": 97808, "end": 98742}, {"start": 450784, "end": 451334}, {"start": 577564, "end": 578194}, {"start": 581548, "end": 582034}]}, {"count": 1, "rank": 0.06, "text": "traditional models", "timestamps": [{"start": 229068, "end": 230242}]}, {"count": 1, "rank": 0.06, "text": "Keras models", "timestamps": [{"start": 698352, "end": 699318}]}, {"count": 2, "rank": 0.06, "text": "Hidden layers", "timestamps": [{"start": 265518, "end": 266686}, {"start": 280250, "end": 280994}]}, {"count": 8, "rank": 0.06, "text": "machine learning", "timestamps": [{"start": 32668, "end": 33270}, {"start": 39682, "end": 40310}, {"start": 188572, "end": 189190}, {"start": 220264, "end": 220802}, {"start": 223048, "end": 223602}, {"start": 226776, "end": 227478}, {"start": 338066, "end": 338662}, {"start": 930476, "end": 931030}]}, {"count": 1, "rank": 0.06, "text": "keras layers", "timestamps": [{"start": 700352, "end": 701610}]}, {"count": 1, "rank": 0.06, "text": "interconnected layers", "timestamps": [{"start": 241392, "end": 242534}]}, {"count": 7, "rank": 0.06, "text": "neural networks", "timestamps": [{"start": 53972, "end": 54666}, {"start": 60372, "end": 61114}, {"start": 190818, "end": 191478}, {"start": 232732, "end": 233554}, {"start": 239184, "end": 240054}, {"start": 286092, "end": 286786}, {"start": 470072, "end": 471086}]}, {"count": 1, "rank": 0.06, "text": "machine learning algorithms", "timestamps": [{"start": 223048, "end": 224046}]}, {"count": 1, "rank": 0.06, "text": "multiple hidden layers", "timestamps": [{"start": 265112, "end": 266686}]}, {"count": 1, "rank": 0.05, "text": "more data", "timestamps": [{"start": 349776, "end": 350362}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}