1
00:00:24,090 --> 00:00:28,006
Conference for 2023. My name

2
00:00:28,028 --> 00:00:32,022
is Roman Boykar and I work senior Senior Senior Senior senior specialist

3
00:00:32,076 --> 00:00:35,446
Solutions architect serverless. Today I'm going to

4
00:00:35,468 --> 00:00:39,240
talk a little bit about rusts and why I think

5
00:00:39,610 --> 00:00:43,554
it is the best fit for writing your serverless workloads

6
00:00:43,602 --> 00:00:47,302
and especially lambda functions. To be honest, when I

7
00:00:47,356 --> 00:00:50,958
started looking at Rust and learning it a years ago,

8
00:00:51,044 --> 00:00:54,990
I was something a little bit skeptical about

9
00:00:55,060 --> 00:00:58,858
that. Yeah, I would use rusts as my primary

10
00:00:58,954 --> 00:01:02,558
language for writing lambda functions. But over time

11
00:01:02,644 --> 00:01:06,146
I came to the conclusion that yeah, rust is the best fit

12
00:01:06,248 --> 00:01:09,602
for writing the lambda functions, especially given how

13
00:01:09,656 --> 00:01:13,326
lambda runtime runs your code. So let's

14
00:01:13,358 --> 00:01:16,594
get started and look at today's

15
00:01:16,642 --> 00:01:19,750
agenda. So first of all,

16
00:01:19,820 --> 00:01:24,098
I will remind you a little bit about lambda,

17
00:01:24,274 --> 00:01:28,458
what it does and how it rusts your code and

18
00:01:28,624 --> 00:01:32,522
give a short overview. And then we will

19
00:01:32,656 --> 00:01:36,042
look at how you can kickstart your new

20
00:01:36,096 --> 00:01:39,938
project and run and create your lambda

21
00:01:39,974 --> 00:01:43,066
functions and what tools

22
00:01:43,098 --> 00:01:46,974
and options are there. Then we will be talking a little

23
00:01:47,012 --> 00:01:50,798
bit about lambda extensions. This is another way

24
00:01:50,964 --> 00:01:55,202
where you can apply rust and it perfectly fits there

25
00:01:55,256 --> 00:01:58,386
as well. And we will look at how to write a

26
00:01:58,408 --> 00:02:02,242
lambda extension with rust and then yeah, we will

27
00:02:02,296 --> 00:02:06,566
cover and summarize all the things

28
00:02:06,748 --> 00:02:09,878
we will be looking at today.

29
00:02:10,044 --> 00:02:14,070
So let's first talk a little bit about

30
00:02:14,220 --> 00:02:17,442
lambda and how it runs your

31
00:02:17,516 --> 00:02:21,478
code. Essentially, from the developer standpoint,

32
00:02:21,574 --> 00:02:25,260
you can think of lambda as another compute option,

33
00:02:26,110 --> 00:02:29,466
which given a code written in

34
00:02:29,648 --> 00:02:33,242
many different languages, it just provides

35
00:02:33,306 --> 00:02:37,646
compute runtimes, compute resources to

36
00:02:37,748 --> 00:02:41,614
run that code. And essentially then you write code and

37
00:02:41,652 --> 00:02:45,060
that code interacts with different

38
00:02:45,430 --> 00:02:48,626
underlying resources such as AWS services,

39
00:02:48,728 --> 00:02:52,350
databases, or any other resources.

40
00:02:52,510 --> 00:02:56,226
And Lambda essentially allows

41
00:02:56,258 --> 00:03:00,342
you to react to different incoming events from

42
00:03:00,476 --> 00:03:04,658
other AWS services or external APIs.

43
00:03:04,834 --> 00:03:08,410
And as you see, you can use different languages.

44
00:03:08,910 --> 00:03:12,460
Probably you can't see Rust here because

45
00:03:13,150 --> 00:03:16,634
in lambda we have different types of languages. We have so

46
00:03:16,672 --> 00:03:20,590
called provided runtimes which provide

47
00:03:20,740 --> 00:03:23,898
some environment for you, for Python,

48
00:03:23,994 --> 00:03:27,918
JavaScript, Java, or you can

49
00:03:28,004 --> 00:03:32,774
use so called bring your own runtimes

50
00:03:32,842 --> 00:03:38,254
where you can create a custom runtime and execute

51
00:03:38,302 --> 00:03:42,610
that runtime and run any language whatever

52
00:03:42,680 --> 00:03:46,326
you want. So with rusts it is

53
00:03:46,348 --> 00:03:50,706
usually a custom runtime, but don't

54
00:03:50,738 --> 00:03:55,202
think that you will spend a lot of time creating

55
00:03:55,346 --> 00:03:59,946
all that primitives yourself. I will explain in

56
00:03:59,968 --> 00:04:03,370
the future that you don't need to care

57
00:04:03,520 --> 00:04:05,500
a lot about this,

58
00:04:06,910 --> 00:04:11,082
but if we look at bigger picture,

59
00:04:11,226 --> 00:04:14,878
yeah, you have your code, then probably

60
00:04:15,044 --> 00:04:18,240
you will need to provide some configuration options,

61
00:04:19,490 --> 00:04:23,058
referring maybe to some external resources or

62
00:04:23,144 --> 00:04:25,490
some configuration parameters.

63
00:04:26,310 --> 00:04:29,918
Then of course, because your lambda

64
00:04:29,934 --> 00:04:33,266
function needs to react to different events, you will need

65
00:04:33,288 --> 00:04:36,680
to configure either event source mapping or

66
00:04:38,090 --> 00:04:42,162
provide a way how your lambda function will receive those events

67
00:04:42,226 --> 00:04:43,830
from the external sources.

68
00:04:45,130 --> 00:04:49,180
And there are different things which allows you to

69
00:04:49,710 --> 00:04:53,862
version your lambda functions, to use different deployment

70
00:04:53,926 --> 00:04:57,786
strategies, et cetera. But I'm not

71
00:04:57,808 --> 00:05:01,194
going to focus a lot on these aspects.

72
00:05:01,322 --> 00:05:05,406
And of course security is very important thing and

73
00:05:05,588 --> 00:05:09,162
you need to think what resources

74
00:05:09,226 --> 00:05:12,702
are available for your lambda functions or who

75
00:05:12,756 --> 00:05:16,798
on the other hand can run and execute your lambda functions.

76
00:05:16,894 --> 00:05:21,694
And this is clearly defined and protected

77
00:05:21,742 --> 00:05:25,150
by assigning appropriate IAM

78
00:05:25,230 --> 00:05:28,934
and lambda permissions and using executions roles on the

79
00:05:28,972 --> 00:05:32,680
lambda functions. And in the end,

80
00:05:33,210 --> 00:05:36,566
once you write your code, there are two different options how

81
00:05:36,588 --> 00:05:40,154
you can package the code and deploy it in the

82
00:05:40,192 --> 00:05:44,502
lambda runtime. The most commonly used packaging

83
00:05:44,566 --> 00:05:48,154
is zip archives, so you can package all the

84
00:05:48,192 --> 00:05:52,160
things as a zip archive and deploy it

85
00:05:52,850 --> 00:05:57,034
into a lambda runtime. Or you can also use container

86
00:05:57,082 --> 00:06:01,178
images. For example, if you already build some pipelines

87
00:06:01,274 --> 00:06:04,586
around producing containers

88
00:06:04,698 --> 00:06:08,670
and container images, then you can probably adopt and

89
00:06:08,740 --> 00:06:12,654
use them to produce also images for lambda functions.

90
00:06:12,782 --> 00:06:16,450
In terms of rusts, in the end you will have a binary,

91
00:06:16,530 --> 00:06:20,582
and then this binary you can package both as a

92
00:06:20,636 --> 00:06:23,190
zip or as a container image.

93
00:06:24,490 --> 00:06:28,666
There are some differences and usually

94
00:06:28,848 --> 00:06:32,698
I encourage you starting with zip because it

95
00:06:32,704 --> 00:06:35,958
is easier to implement and to deploy

96
00:06:36,134 --> 00:06:40,118
unless you have some specific requirements where you want

97
00:06:40,224 --> 00:06:43,470
and need to use container images.

98
00:06:45,090 --> 00:06:47,440
Another very important thing,

99
00:06:47,970 --> 00:06:52,414
especially in terms of rust, is how

100
00:06:52,452 --> 00:06:55,566
you can considered how much resources

101
00:06:55,758 --> 00:06:59,490
in terms of hardware are available to your lambda functions.

102
00:06:59,830 --> 00:07:03,186
And if you look at configuration options, you will

103
00:07:03,208 --> 00:07:06,886
see that there are not plenty of options here.

104
00:07:07,068 --> 00:07:11,122
And essentially the only option you can configure

105
00:07:11,186 --> 00:07:15,026
is the amount of memory given to your lambda

106
00:07:15,058 --> 00:07:18,040
function. But interestingly enough,

107
00:07:18,670 --> 00:07:22,620
the amount of memory you give to your lambda function also

108
00:07:23,310 --> 00:07:27,818
tells how much lambda runtime will give

109
00:07:27,904 --> 00:07:31,534
cpu cycles to this or that function.

110
00:07:31,732 --> 00:07:35,998
And this cpu capacity is allocated proportionally to

111
00:07:36,084 --> 00:07:39,230
the amount of memory. So the bigger

112
00:07:39,570 --> 00:07:44,034
amount of memory you give to the function, the maximum is

113
00:07:44,152 --> 00:07:48,114
ten gigs here, the bigger number

114
00:07:48,152 --> 00:07:51,266
of cpu cycles your function will get.

115
00:07:51,448 --> 00:07:55,542
And essentially, if you think about

116
00:07:55,676 --> 00:07:59,926
virtual CPUs, if you give your function around

117
00:08:00,108 --> 00:08:03,618
one and 80 megs of memory,

118
00:08:03,794 --> 00:08:08,126
it will transform into one full VCPU

119
00:08:08,258 --> 00:08:11,914
and it will scale up to six

120
00:08:12,032 --> 00:08:15,574
virtual CPUs. If you give the maximum

121
00:08:15,622 --> 00:08:19,594
amount of ten gigs to your lumber function, that essentially means

122
00:08:19,632 --> 00:08:23,374
that that function will be assigned six

123
00:08:23,572 --> 00:08:25,630
full virtual cpus.

124
00:08:26,290 --> 00:08:29,582
And here comes another very important

125
00:08:29,716 --> 00:08:32,750
aspect is the pricing

126
00:08:33,110 --> 00:08:37,454
and the pricing for your lambda functions.

127
00:08:37,502 --> 00:08:41,298
Consists of two options of two things. The first

128
00:08:41,384 --> 00:08:45,278
one is the number of rusts. So the more requests

129
00:08:45,454 --> 00:08:49,050
you assign and the more rusts

130
00:08:49,070 --> 00:08:52,374
you issued the lambda function, the more you will pay.

131
00:08:52,572 --> 00:08:55,590
And another dimension is the duration.

132
00:08:56,010 --> 00:09:00,202
And duration is calculated in gigabytes per second,

133
00:09:00,336 --> 00:09:03,466
so it is essentially the amount of

134
00:09:03,488 --> 00:09:07,242
memory you give and contribute for this

135
00:09:07,296 --> 00:09:11,502
particular function and the time your function is

136
00:09:11,556 --> 00:09:14,810
running. So essentially

137
00:09:14,890 --> 00:09:18,480
that means the more memory you assign to a lambda function,

138
00:09:18,930 --> 00:09:22,240
and the longer this function is running,

139
00:09:22,550 --> 00:09:26,274
the more you will pay. But the

140
00:09:26,312 --> 00:09:29,682
duration is metered in one milliseconds, so it is quite

141
00:09:29,736 --> 00:09:33,314
granular. If you can optimize the

142
00:09:33,352 --> 00:09:37,046
time of how long your

143
00:09:37,148 --> 00:09:40,982
lambda function is running, it essentially means

144
00:09:41,036 --> 00:09:43,880
that you can optimize also on the cost.

145
00:09:44,330 --> 00:09:48,234
And another very important thing to realize here is

146
00:09:48,352 --> 00:09:51,866
that you will pay

147
00:09:51,968 --> 00:09:56,602
the same for the function which runs 100

148
00:09:56,656 --> 00:10:00,290
milliseconds with two gigs of ram configured,

149
00:10:00,470 --> 00:10:04,670
or the function if it runs for 200

150
00:10:04,740 --> 00:10:08,346
milliseconds with one gig of ram configured.

151
00:10:08,538 --> 00:10:12,106
But what if you can minimize

152
00:10:12,218 --> 00:10:15,698
both things so you can have less

153
00:10:15,784 --> 00:10:20,530
memory considered, and your function runs less

154
00:10:20,600 --> 00:10:24,386
amount of time. So it essentially means that you will pay

155
00:10:24,488 --> 00:10:27,782
less. And here rusts comes

156
00:10:27,836 --> 00:10:31,926
into play, because again, it is

157
00:10:32,108 --> 00:10:35,654
super fast and super optimized, and it

158
00:10:35,692 --> 00:10:39,942
essentially allows you to run your functions faster

159
00:10:40,006 --> 00:10:43,834
in terms of time. And in many cases it

160
00:10:43,872 --> 00:10:47,702
also can run in a less memory

161
00:10:47,766 --> 00:10:51,994
and less cpu, because again, it is quite optimized.

162
00:10:52,122 --> 00:10:56,266
And essentially that will imply that your functions

163
00:10:56,298 --> 00:11:00,414
will cost you less. So let's talk

164
00:11:00,452 --> 00:11:04,162
a little bit about Rust's performance and

165
00:11:04,216 --> 00:11:07,714
cost characteristics applied to serverless workloads and to

166
00:11:07,752 --> 00:11:11,794
lambda functions. First of all, there are different

167
00:11:11,912 --> 00:11:15,960
tests run by different people.

168
00:11:16,410 --> 00:11:20,534
Probably one of the most well

169
00:11:20,572 --> 00:11:25,190
known is this test of

170
00:11:25,260 --> 00:11:29,146
hello world application. Essentially it

171
00:11:29,168 --> 00:11:31,894
is not super real world scenario,

172
00:11:31,942 --> 00:11:35,642
but it can give you high

173
00:11:35,696 --> 00:11:39,878
level view on different runtimes and the

174
00:11:39,984 --> 00:11:43,310
amount of time it will take to run these

175
00:11:43,380 --> 00:11:46,862
simple but loads. But again,

176
00:11:46,996 --> 00:11:50,510
in real life, probably we won't be running hello world

177
00:11:50,580 --> 00:11:54,660
applications. Often there are

178
00:11:55,510 --> 00:11:59,138
a lot of data and a

179
00:11:59,144 --> 00:12:02,814
lot of people already compared

180
00:12:02,942 --> 00:12:06,726
different runtimes, Python versus rust, like in

181
00:12:06,748 --> 00:12:10,482
this example, or node js and typescript versus

182
00:12:10,546 --> 00:12:13,670
rust. And essentially in many cases,

183
00:12:14,170 --> 00:12:18,030
we observe that customers who adopt rusts

184
00:12:18,210 --> 00:12:22,938
compared to any other runtimes on

185
00:12:23,024 --> 00:12:26,586
lambda, they observe both.

186
00:12:26,688 --> 00:12:30,682
They can see the performance gains

187
00:12:30,826 --> 00:12:34,478
and usually those performance gains applied to

188
00:12:34,564 --> 00:12:38,734
how lambda bill. You also

189
00:12:38,932 --> 00:12:42,754
convert into the price and

190
00:12:42,792 --> 00:12:46,066
cost gains. And essentially, if you look

191
00:12:46,088 --> 00:12:47,730
at the cost efficiency,

192
00:12:49,590 --> 00:12:52,562
there are a lot of samples. For example,

193
00:12:52,696 --> 00:12:56,520
one of our customers, they see that

194
00:12:59,290 --> 00:13:03,266
the reduction of amount of cpu and memory

195
00:13:03,458 --> 00:13:07,026
used in production dropped significantly.

196
00:13:07,138 --> 00:13:10,854
And essentially, yeah, it is good in terms of performance,

197
00:13:10,902 --> 00:13:14,502
but if you look at lambda, as I explained,

198
00:13:14,566 --> 00:13:17,802
it also means you pay less.

199
00:13:17,936 --> 00:13:21,790
Another great example, I have a customer

200
00:13:21,940 --> 00:13:25,758
who was running

201
00:13:25,844 --> 00:13:29,230
the majority of their workloads in node js,

202
00:13:29,570 --> 00:13:33,794
and essentially they

203
00:13:33,832 --> 00:13:37,902
were quite happy. But then they realized

204
00:13:37,966 --> 00:13:41,810
that there are certain types of workloads that require

205
00:13:43,350 --> 00:13:47,110
lower latency, and they started to optimize

206
00:13:48,170 --> 00:13:51,510
on the latency and started

207
00:13:51,580 --> 00:13:56,166
evaluating different options. And in the end they came to

208
00:13:56,188 --> 00:14:00,234
the conclusion and essentially they rebuilt some

209
00:14:00,272 --> 00:14:04,234
of their applications in rust, and they

210
00:14:04,352 --> 00:14:09,766
observed first of all the lower

211
00:14:09,888 --> 00:14:14,606
memory usage for their functions. So the same function

212
00:14:14,788 --> 00:14:19,070
running on, for example, node runtime and rusts

213
00:14:19,490 --> 00:14:22,110
required different memory configurations,

214
00:14:23,110 --> 00:14:27,042
and they could get the same or even better

215
00:14:27,096 --> 00:14:30,594
performance at lower memory configurations for

216
00:14:30,632 --> 00:14:33,982
their lambda functions running in rusts compared to node

217
00:14:34,046 --> 00:14:38,166
or go runtimes. And essentially because the

218
00:14:38,188 --> 00:14:41,574
memory is less, the speed is better.

219
00:14:41,772 --> 00:14:45,510
They also observed some cost

220
00:14:45,660 --> 00:14:48,938
gains as well. So this is

221
00:14:49,024 --> 00:14:52,906
a quite common pattern. You may ask, does it

222
00:14:52,928 --> 00:14:56,054
mean that I should rewrite

223
00:14:56,102 --> 00:14:59,210
all my lambda functions in rust immediately?

224
00:14:59,710 --> 00:15:04,378
Of course not. Of course it will take time and effort

225
00:15:04,554 --> 00:15:09,230
to teach your years rust and rewrite

226
00:15:09,890 --> 00:15:13,186
everything in rust. Probably even you don't need

227
00:15:13,208 --> 00:15:16,366
to do that immediately.

228
00:15:16,478 --> 00:15:22,274
I have another quite interesting customer example that

229
00:15:22,472 --> 00:15:27,522
the team was primarily using node

230
00:15:27,586 --> 00:15:31,718
js for their serverless application.

231
00:15:31,884 --> 00:15:35,526
And essentially their serverless application consisted of

232
00:15:35,628 --> 00:15:38,490
hundred of different functions,

233
00:15:39,150 --> 00:15:42,762
but they identified two

234
00:15:42,816 --> 00:15:47,066
or three hot functions that essentially almost

235
00:15:47,168 --> 00:15:50,798
every request coming into their system hit

236
00:15:50,884 --> 00:15:54,106
those two or three lambda functions.

237
00:15:54,218 --> 00:15:57,662
And essentially they decided that, yeah,

238
00:15:57,716 --> 00:16:01,680
we want to optimize those functions, we want to

239
00:16:02,050 --> 00:16:05,780
minimize the latency, we want to

240
00:16:07,670 --> 00:16:11,362
make those functions the most performant ones.

241
00:16:11,496 --> 00:16:15,638
And essentially they started rewriting only those three

242
00:16:15,724 --> 00:16:19,238
functions in rusts, and they already

243
00:16:19,324 --> 00:16:23,474
observed quite great impacts

244
00:16:23,522 --> 00:16:27,834
in terms of performance. First, because those

245
00:16:27,872 --> 00:16:31,034
functions were hot, and as

246
00:16:31,072 --> 00:16:34,986
I mentioned, all requests coming into the system

247
00:16:35,168 --> 00:16:39,162
has to pass through those functions. And also

248
00:16:39,216 --> 00:16:42,474
they absorbed some cost gains,

249
00:16:42,522 --> 00:16:45,680
because again, those functions were

250
00:16:46,770 --> 00:16:50,318
most called

251
00:16:50,404 --> 00:16:55,906
the majority of time, and reducing the

252
00:16:55,928 --> 00:16:59,282
cost was also a great benefit. But they

253
00:16:59,336 --> 00:17:03,166
happily stay with no chairs

254
00:17:03,198 --> 00:17:07,254
on all other functions, and they

255
00:17:07,292 --> 00:17:10,934
still haven't rewritten the

256
00:17:10,972 --> 00:17:14,678
whole application in rust. So usually this is the best

257
00:17:14,764 --> 00:17:18,266
strategy. If you already invested a lot in

258
00:17:18,288 --> 00:17:22,858
your serverless applications and you already run

259
00:17:23,024 --> 00:17:26,474
in different runtimes, identify the

260
00:17:26,512 --> 00:17:30,006
most important, the most critical parts of your application,

261
00:17:30,128 --> 00:17:35,166
and probably rewrite those in rust. And it

262
00:17:35,188 --> 00:17:37,600
is quite obvious.

263
00:17:38,770 --> 00:17:42,410
Another very important thing about rusts

264
00:17:42,500 --> 00:17:46,574
is sustainability. Again, because you use less compute

265
00:17:46,622 --> 00:17:52,180
resources, you can use it

266
00:17:53,030 --> 00:17:56,118
more efficiently and in the

267
00:17:56,124 --> 00:18:00,886
end with serverless it is already quite

268
00:18:00,988 --> 00:18:06,214
sustainable because again, you don't have to run those

269
00:18:06,332 --> 00:18:10,074
resources 24/7 serverless automatically scales up

270
00:18:10,112 --> 00:18:13,930
and down depending on your workloads. But again,

271
00:18:14,000 --> 00:18:18,250
applying rust to serverless will make you even

272
00:18:18,320 --> 00:18:22,318
more sustainable. And again, rust is

273
00:18:22,404 --> 00:18:26,350
heavily used under the hood by different

274
00:18:26,420 --> 00:18:29,822
parts of AWS. And for example, if we look

275
00:18:29,876 --> 00:18:33,106
at lambda under the

276
00:18:33,128 --> 00:18:37,138
hood, lambda is using firecracker vms to

277
00:18:37,224 --> 00:18:41,614
isolate your workloads. And those firecracker

278
00:18:41,742 --> 00:18:45,170
vms, they're written

279
00:18:45,610 --> 00:18:48,280
completely in rust. So already,

280
00:18:48,970 --> 00:18:53,574
even if you don't use rusts as your

281
00:18:53,612 --> 00:18:56,966
language to implement lambda functions, under the

282
00:18:56,988 --> 00:19:00,940
hood, lambda will already use rust and

283
00:19:01,630 --> 00:19:05,642
it will already be

284
00:19:05,696 --> 00:19:08,730
beneficial in terms of sustainability.

285
00:19:10,450 --> 00:19:13,920
But how you can start for example,

286
00:19:14,610 --> 00:19:18,654
you know rust, but you

287
00:19:18,692 --> 00:19:22,442
want to run some and

288
00:19:22,516 --> 00:19:26,100
create some functions in rust. How you can do that

289
00:19:28,390 --> 00:19:32,274
I personally recommend you looking into a

290
00:19:32,312 --> 00:19:35,970
tool called cargo lambda. It is an extension

291
00:19:37,670 --> 00:19:41,190
for cargo tool and

292
00:19:41,340 --> 00:19:44,914
essentially it provides you with a set of workflows

293
00:19:44,962 --> 00:19:48,780
which allow you to bootstrap a new application

294
00:19:49,870 --> 00:19:53,914
to test that application locally to deploy it to

295
00:19:54,032 --> 00:19:57,674
your test AWS account to

296
00:19:57,712 --> 00:20:01,438
build that application. Again,

297
00:20:01,524 --> 00:20:04,634
it supports for example cross compilation.

298
00:20:04,762 --> 00:20:08,880
And for example you can target different

299
00:20:09,330 --> 00:20:12,866
lambda runtimes because in

300
00:20:12,888 --> 00:20:16,434
lambda we have two different cpu options. You can

301
00:20:16,552 --> 00:20:20,670
run your functions in x 86 or an RM

302
00:20:20,750 --> 00:20:24,770
architecture, and with cargo lambda you can

303
00:20:24,840 --> 00:20:28,950
easily build for both of those architectures.

304
00:20:29,930 --> 00:20:33,286
Again, here you can find a link to

305
00:20:33,308 --> 00:20:36,886
the cargo lambda. So if

306
00:20:36,908 --> 00:20:40,506
you scan this car code it will

307
00:20:40,528 --> 00:20:44,140
navigate you to the site and there you will have

308
00:20:44,590 --> 00:20:48,346
quite great documentation how to use

309
00:20:48,448 --> 00:20:53,158
this tool. Another thing which I personally like around cargo

310
00:20:53,174 --> 00:20:57,994
lambda is that it is agnostic

311
00:20:58,042 --> 00:21:01,886
to infrastructure AWS code tools. So you

312
00:21:01,908 --> 00:21:05,326
may use this kagalamda with different

313
00:21:05,428 --> 00:21:09,438
infrastructure tools. For example, if you use terraform

314
00:21:09,534 --> 00:21:12,526
or if you use SAM or if you use CDK,

315
00:21:12,638 --> 00:21:16,390
you can integrate them with kaga lambda.

316
00:21:16,810 --> 00:21:20,040
Then once you bootstrapped your application,

317
00:21:22,090 --> 00:21:26,214
let's look at some sample application and

318
00:21:26,332 --> 00:21:32,282
I will guide you quickly through how

319
00:21:32,336 --> 00:21:35,926
typical small serverless application written

320
00:21:35,958 --> 00:21:40,220
in rust may look like. So this is small application

321
00:21:40,610 --> 00:21:44,750
consisting of API gateway for receiving

322
00:21:45,730 --> 00:21:48,762
incoming HTTP requests.

323
00:21:48,906 --> 00:21:51,934
Then we have a lambda function where we

324
00:21:51,972 --> 00:21:55,554
implement some business logic and for example quite

325
00:21:55,592 --> 00:21:59,970
common use case to have a dynamodb as a data storage.

326
00:22:01,190 --> 00:22:04,658
And we have

327
00:22:04,744 --> 00:22:07,750
quite good documentation how to build

328
00:22:07,820 --> 00:22:11,590
and how to use lambda functions

329
00:22:11,930 --> 00:22:16,070
with rust. Again, you can follow this link

330
00:22:16,220 --> 00:22:20,410
on the page and get quite comprehensive

331
00:22:21,310 --> 00:22:26,234
tutorial and guide how to build and how to use

332
00:22:26,432 --> 00:22:28,650
rust with lambda functions.

333
00:22:31,010 --> 00:22:34,830
Let's briefly look at main

334
00:22:34,980 --> 00:22:38,334
things in this sample project.

335
00:22:38,532 --> 00:22:42,670
First of all, as you see, we input

336
00:22:43,510 --> 00:22:46,722
number of libraries, and essentially there are two

337
00:22:46,776 --> 00:22:51,330
important libraries. First is lambda HTTP.

338
00:22:51,670 --> 00:22:55,220
And essentially, remember I mentioned that

339
00:22:57,050 --> 00:23:00,342
if you want to use rust on lambda, you need to create

340
00:23:00,396 --> 00:23:04,102
your custom runtime. And essentially if you need to

341
00:23:04,236 --> 00:23:07,682
create a custom runtime, that custom runtime is

342
00:23:07,756 --> 00:23:11,162
responsible how your code is interacting with

343
00:23:11,216 --> 00:23:15,670
lambda, and there are certain specifications

344
00:23:15,830 --> 00:23:19,434
you need to follow, how you can get the events from

345
00:23:19,472 --> 00:23:22,958
lambda runtime, how you should

346
00:23:23,124 --> 00:23:27,134
pass the responses back, and yeah,

347
00:23:27,172 --> 00:23:31,102
you can implement that yourself, but we

348
00:23:31,156 --> 00:23:36,558
already done it for you. And we have this rust

349
00:23:36,654 --> 00:23:39,582
runtime for AWS Lambda.

350
00:23:39,646 --> 00:23:43,198
It's an open source project and it encapsulates

351
00:23:43,294 --> 00:23:47,730
all the interactions between your code and lambda runtime.

352
00:23:47,890 --> 00:23:51,720
And essentially it also adds a lot of

353
00:23:52,330 --> 00:23:56,626
syntactic sugar. For example, if your lambda

354
00:23:56,658 --> 00:24:00,614
function consumes and gets events from API

355
00:24:00,662 --> 00:24:03,946
gateway, there's another abstraction on

356
00:24:03,968 --> 00:24:07,542
top of lambda rust runtime

357
00:24:07,686 --> 00:24:11,614
which encapsulates how those

358
00:24:11,732 --> 00:24:16,586
HTTP events are coming into the lambda

359
00:24:16,618 --> 00:24:19,902
function and how you can interact with

360
00:24:19,956 --> 00:24:23,822
them. And another important input

361
00:24:23,886 --> 00:24:29,534
here is dynamodb interaction.

362
00:24:29,582 --> 00:24:33,662
And for that we're using AWS

363
00:24:33,726 --> 00:24:37,606
SDK for rusts and it essentially allows you

364
00:24:37,628 --> 00:24:41,480
to interact with dynamo or any other AWS services.

365
00:24:42,410 --> 00:24:46,520
Then the most important function in

366
00:24:47,630 --> 00:24:50,922
your code will be

367
00:24:51,056 --> 00:24:54,794
function handler. And essentially this

368
00:24:54,912 --> 00:24:58,860
handler function is the main

369
00:24:59,390 --> 00:25:03,582
function where you can write and put the

370
00:25:03,636 --> 00:25:06,480
code. And for example,

371
00:25:06,850 --> 00:25:11,326
in this example it

372
00:25:11,428 --> 00:25:15,138
gets the event, and this event

373
00:25:15,224 --> 00:25:18,978
abstracts the data which is

374
00:25:19,144 --> 00:25:23,662
coming from API gateway or any other HTTP

375
00:25:23,726 --> 00:25:27,222
sources. And in the end

376
00:25:27,356 --> 00:25:31,494
your function should return result type

377
00:25:31,612 --> 00:25:36,086
and if you successfully complete

378
00:25:36,188 --> 00:25:42,410
the function, you should return okay and some

379
00:25:42,480 --> 00:25:45,660
response from your lambda function.

380
00:25:46,670 --> 00:25:50,398
Then within the handler it's an

381
00:25:50,484 --> 00:25:56,494
arbitrary rusts code. You can again write

382
00:25:56,692 --> 00:26:00,414
some basic things in the handler function, but in

383
00:26:00,452 --> 00:26:03,934
reality if you have more sophisticated business logic,

384
00:26:03,982 --> 00:26:07,346
you will put that logic in

385
00:26:07,448 --> 00:26:10,578
separate rust functions, methods outside

386
00:26:10,664 --> 00:26:14,778
the handler function and you can essentially

387
00:26:14,974 --> 00:26:17,960
interact and call them for sure.

388
00:26:18,730 --> 00:26:21,942
Another thing is that you can do

389
00:26:21,996 --> 00:26:25,746
within handler function, you can interact with lambda environment.

390
00:26:25,858 --> 00:26:29,958
For example, you can use printer LAN

391
00:26:30,134 --> 00:26:34,230
or tracing mechanism

392
00:26:34,310 --> 00:26:37,878
to emit logs for Cloudwatch.

393
00:26:38,054 --> 00:26:41,786
For sure you can interact with local

394
00:26:41,968 --> 00:26:45,546
Tnp file system. It's an ephemeral file

395
00:26:45,578 --> 00:26:49,200
system available for the lambda function during

396
00:26:51,090 --> 00:26:54,626
runtime of this or that function

397
00:26:54,728 --> 00:26:58,594
lifecycle. And of course you can make

398
00:26:58,712 --> 00:27:02,734
any network calls to external resources,

399
00:27:02,782 --> 00:27:04,980
to any other AWS services.

400
00:27:06,810 --> 00:27:10,742
Another thing you should add into your lambda function is

401
00:27:10,876 --> 00:27:14,854
a main function, and essentially this is the

402
00:27:14,892 --> 00:27:18,694
entry point which will be called by a

403
00:27:18,732 --> 00:27:22,330
lambda runtime or the start of those

404
00:27:22,400 --> 00:27:26,246
runtime. And here the only thing you should be aware

405
00:27:26,278 --> 00:27:30,090
of this is an asynchronous

406
00:27:30,850 --> 00:27:34,350
invocation, and we use Tokyo for that.

407
00:27:34,420 --> 00:27:37,694
So you must annotate the

408
00:27:37,732 --> 00:27:41,760
main function with Tokyo main and

409
00:27:43,190 --> 00:27:46,290
make it a synchronous invocation.

410
00:27:47,670 --> 00:27:51,458
Another very important thing is that because

411
00:27:51,544 --> 00:27:55,038
this main function is called

412
00:27:55,144 --> 00:27:59,062
during the initialization of your

413
00:27:59,116 --> 00:28:04,226
lambda runtime, you can declare some independent resources

414
00:28:04,338 --> 00:28:07,480
which will be reused by your handler function.

415
00:28:07,870 --> 00:28:11,734
Usually you can define some external

416
00:28:11,782 --> 00:28:15,274
dependencies, creating an

417
00:28:15,312 --> 00:28:19,142
SDK client or getting the configuration

418
00:28:19,206 --> 00:28:22,494
options for the function. And then those

419
00:28:22,612 --> 00:28:26,202
configuration options and those SDK clients,

420
00:28:26,266 --> 00:28:31,310
they will be preserved in memory. And your

421
00:28:31,380 --> 00:28:35,518
handler function doesn't need to reinitiate

422
00:28:35,614 --> 00:28:39,330
and recreate all that shared resources

423
00:28:40,070 --> 00:28:42,130
for the subsequent calls.

424
00:28:42,550 --> 00:28:46,134
And essentially this is a best practice how

425
00:28:46,172 --> 00:28:49,842
you should initialize

426
00:28:49,986 --> 00:28:54,454
some common resources which

427
00:28:54,492 --> 00:28:57,320
will be reused in your handler function.

428
00:28:57,950 --> 00:29:02,314
And then, as I already mentioned, okay statement in

429
00:29:02,352 --> 00:29:06,922
your handler function just ends the

430
00:29:06,976 --> 00:29:11,226
execution. And usually you return a JSON document

431
00:29:11,418 --> 00:29:15,066
if it's a synchronous invocation,

432
00:29:15,178 --> 00:29:18,686
or if it's asynchronous, for example, then you

433
00:29:18,708 --> 00:29:22,158
can return something, but you can

434
00:29:22,244 --> 00:29:25,738
also return empty okay response,

435
00:29:25,834 --> 00:29:29,246
because essentially for synchronous invocations,

436
00:29:29,358 --> 00:29:33,426
lambda runtime won't forward any data back

437
00:29:33,528 --> 00:29:37,622
to the caller. This is quite good

438
00:29:37,676 --> 00:29:41,080
thing, and you can build your

439
00:29:42,490 --> 00:29:45,926
business logic with lambda functions. But another

440
00:29:46,028 --> 00:29:50,694
quite interesting application for rust and

441
00:29:50,892 --> 00:29:54,326
in terms of lambda and serverless is

442
00:29:54,508 --> 00:29:57,962
so called lambda extensions. First of all,

443
00:29:58,016 --> 00:30:01,242
let me briefly describe what lambda extensions

444
00:30:01,306 --> 00:30:05,658
are. It is additional

445
00:30:05,834 --> 00:30:09,422
process which runs alongside you with your main

446
00:30:09,476 --> 00:30:13,566
function and your main code, and it essentially allows

447
00:30:13,598 --> 00:30:16,450
you to capture some diagnostic information,

448
00:30:16,600 --> 00:30:20,420
maybe run some instrumentation for the main code,

449
00:30:21,430 --> 00:30:24,954
fetch some configuration settings out of external

450
00:30:25,022 --> 00:30:29,922
parameter stores, or react

451
00:30:29,986 --> 00:30:34,562
to some function activity, maybe imposing

452
00:30:34,626 --> 00:30:39,370
some additional security guardrails

453
00:30:40,030 --> 00:30:43,530
into your lambda functions. And essentially,

454
00:30:44,030 --> 00:30:47,498
in terms of extensions, there are two different

455
00:30:47,584 --> 00:30:51,594
types, but for today's talk we will be focusing

456
00:30:51,642 --> 00:30:54,714
more on external extensions and external

457
00:30:54,762 --> 00:30:58,606
extensions. It's like a separate process that

458
00:30:58,708 --> 00:31:01,962
runs in the same runtime

459
00:31:02,106 --> 00:31:07,666
in the same execution environment. And usually

460
00:31:07,768 --> 00:31:11,940
you can query different parameters from

461
00:31:13,430 --> 00:31:18,040
your lambda runtime, or you can again use

462
00:31:19,050 --> 00:31:22,402
this separate process for monitoring

463
00:31:22,466 --> 00:31:24,680
observability and security.

464
00:31:26,490 --> 00:31:29,658
And one important

465
00:31:29,744 --> 00:31:33,254
thing here is that this external extension,

466
00:31:33,382 --> 00:31:37,302
it still shares the same runtime environment. And essentially

467
00:31:37,366 --> 00:31:41,498
that means that it shares the resources like memory,

468
00:31:41,594 --> 00:31:45,582
cpu and all other

469
00:31:45,636 --> 00:31:49,280
things. And another very important thing is that

470
00:31:49,810 --> 00:31:53,374
your extension doesn't have to be written

471
00:31:53,422 --> 00:31:57,122
in the same language as your main

472
00:31:57,256 --> 00:32:01,234
lambda function. So that essentially means that you can create

473
00:32:01,432 --> 00:32:05,618
extensions in rust and augment

474
00:32:05,714 --> 00:32:09,510
the behavior of lambda functions written in

475
00:32:09,580 --> 00:32:13,222
node js in Python in Java or any

476
00:32:13,276 --> 00:32:16,342
other languages. But here,

477
00:32:16,396 --> 00:32:19,798
important thing, that those extensions,

478
00:32:19,894 --> 00:32:23,162
they can impact the performance of the main function

479
00:32:23,296 --> 00:32:27,354
because the resources are shared. And here

480
00:32:27,472 --> 00:32:32,014
where rusts comes into play because again it

481
00:32:32,052 --> 00:32:35,450
is the most performant language.

482
00:32:35,530 --> 00:32:39,120
And essentially now I see a lot of

483
00:32:40,370 --> 00:32:43,774
extensions are being created with rust.

484
00:32:43,902 --> 00:32:47,058
So it is a perfect fit.

485
00:32:47,144 --> 00:32:50,354
If you want to augment the behavior of the

486
00:32:50,392 --> 00:32:53,518
function and you want to create an extension,

487
00:32:53,694 --> 00:32:56,486
rust is a great option.

488
00:32:56,588 --> 00:33:00,534
Here. Again, if you

489
00:33:00,572 --> 00:33:04,322
use cargo lambda extension,

490
00:33:04,466 --> 00:33:09,850
you can easily bootstrap a new lambda

491
00:33:11,070 --> 00:33:14,554
extension. And essentially here you see

492
00:33:14,592 --> 00:33:17,866
that there's another method which you need

493
00:33:17,888 --> 00:33:21,870
to implement. It is event extension method

494
00:33:22,450 --> 00:33:25,898
and it gets the lambda events.

495
00:33:25,994 --> 00:33:30,000
And then depending on what

496
00:33:31,890 --> 00:33:36,942
happens with your lambda runtime, you can interact

497
00:33:37,006 --> 00:33:40,738
with the main code

498
00:33:40,824 --> 00:33:44,740
and you can react when the

499
00:33:45,050 --> 00:33:49,138
lambda is being invoked, lambda function is being invoked.

500
00:33:49,234 --> 00:33:53,110
Then you can react to those invoke events or

501
00:33:53,180 --> 00:33:56,886
when the lambda runtime is being shut down.

502
00:33:56,988 --> 00:34:00,438
So you can again do some maintains

503
00:34:00,614 --> 00:34:04,154
clearance or emitting some logs or

504
00:34:04,352 --> 00:34:06,860
doing some other things,

505
00:34:08,350 --> 00:34:12,318
and then you have this main function

506
00:34:12,404 --> 00:34:16,270
as well. And essentially this

507
00:34:16,340 --> 00:34:19,950
main function just passes and

508
00:34:20,020 --> 00:34:23,940
executes this events extension function.

509
00:34:24,630 --> 00:34:28,034
So here I encourage you,

510
00:34:28,152 --> 00:34:31,694
looking at extensions,

511
00:34:31,822 --> 00:34:35,114
there are pretty good samples.

512
00:34:35,182 --> 00:34:38,946
What you can do with lambda extensions,

513
00:34:39,058 --> 00:34:43,382
probably one of the most well

514
00:34:43,436 --> 00:34:46,870
known ones is lambda adapter.

515
00:34:47,210 --> 00:34:51,098
And essentially it was created by one of

516
00:34:51,184 --> 00:34:55,670
my colleagues. And this lambda adapter allows

517
00:34:55,830 --> 00:35:00,050
you to get API gateway HTTP events

518
00:35:00,230 --> 00:35:04,186
and transform them back to actual HTTP

519
00:35:04,218 --> 00:35:08,910
calls. So that for example, if you want to run in your lambda functions,

520
00:35:09,490 --> 00:35:13,310
some legacy applications written in traditional

521
00:35:13,390 --> 00:35:17,010
frameworks like Express Js, like flask,

522
00:35:17,350 --> 00:35:21,394
like PHP, for example, you can

523
00:35:21,432 --> 00:35:25,494
take that application and you don't have to

524
00:35:25,532 --> 00:35:29,462
change anything. So this application will still listen on a

525
00:35:29,516 --> 00:35:32,674
particular port, but you can't expose

526
00:35:32,722 --> 00:35:36,390
a port with lambda function directly.

527
00:35:36,890 --> 00:35:40,570
And this adapter written in rust

528
00:35:40,910 --> 00:35:46,650
in the form of extension, essentially it makes

529
00:35:46,720 --> 00:35:50,798
a call to a port which your

530
00:35:50,964 --> 00:35:54,990
application listening inside lambda runtime,

531
00:35:56,290 --> 00:36:00,026
get the response and transform that response

532
00:36:00,058 --> 00:36:03,914
back to actual JSON

533
00:36:03,962 --> 00:36:07,234
payload understood by API gateway, for example.

534
00:36:07,352 --> 00:36:12,606
So a nice example what you can achieve with rusts

535
00:36:12,718 --> 00:36:14,770
and lambda extensions.

536
00:36:15,450 --> 00:36:20,246
So in summary, rust is

537
00:36:20,268 --> 00:36:23,602
the best fit for lambda functions,

538
00:36:23,746 --> 00:36:27,126
and it essentially allows you

539
00:36:27,148 --> 00:36:30,798
to get the best cost performance group heuristics.

540
00:36:30,914 --> 00:36:34,554
So I highly encourage you, if you want to

541
00:36:34,592 --> 00:36:38,202
use rust with lambda, go and

542
00:36:38,256 --> 00:36:41,902
experiment. And essentially with rust, you can

543
00:36:42,036 --> 00:36:45,760
both build business logic in terms of

544
00:36:46,450 --> 00:36:50,350
normal lambda functions, or you can also use

545
00:36:50,500 --> 00:36:54,594
rust to create different lambda extensions and

546
00:36:54,712 --> 00:36:57,774
to extend capabilities of your lambda functions,

547
00:36:57,822 --> 00:37:01,620
even if the business logic is still running

548
00:37:02,070 --> 00:37:04,770
and executed in other languages.

549
00:37:05,430 --> 00:37:08,802
And there are a lot of tools. Not only

550
00:37:08,856 --> 00:37:12,706
cargo lambda, we have support for rusts in Sam,

551
00:37:12,898 --> 00:37:16,262
so you can start using and

552
00:37:16,316 --> 00:37:19,782
start building with those tools quite

553
00:37:19,836 --> 00:37:25,302
easily. New projects with

554
00:37:25,356 --> 00:37:28,886
that. Thank you very much. Hopefully I

555
00:37:28,988 --> 00:37:32,654
encouraged you enough to start

556
00:37:32,852 --> 00:37:35,978
and to try build some lambda

557
00:37:35,994 --> 00:37:40,640
functions with rust. In case you will have any questions

558
00:37:41,730 --> 00:37:45,454
and want to communicate, feel free to reach

559
00:37:45,492 --> 00:37:49,214
out and ping me on Twitter with

560
00:37:49,252 --> 00:37:53,134
that. Thank you very much and hope you enjoy this

561
00:37:53,172 --> 00:37:53,530
conference.

