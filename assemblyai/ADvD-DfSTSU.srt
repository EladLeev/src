1
00:00:25,810 --> 00:00:29,686
Hi. Have you ever struggled with git commands? Have you ever wondered how it

2
00:00:29,708 --> 00:00:32,994
works behind the scenes? Have you ever wondered what all those files

3
00:00:33,042 --> 00:00:36,082
are in the git folder? We'll start with an empty terminal.

4
00:00:36,146 --> 00:00:39,606
We'll build up come git history, and we'll look at every single

5
00:00:39,708 --> 00:00:43,058
file inside the git folder. We'll visualize

6
00:00:43,154 --> 00:00:47,138
objects. We'll take a look at branches and tags.

7
00:00:47,234 --> 00:00:50,570
We'll look at logs and x's.

8
00:00:50,650 --> 00:00:54,014
We'll look at temporary files and hooks. You'll leave

9
00:00:54,052 --> 00:00:57,178
here understanding how git works internally,

10
00:00:57,274 --> 00:01:00,170
and that'll help you to be much more productive with Git.

11
00:01:00,250 --> 00:01:02,810
Here's the part where I tell you, I'm definitely going to post my slides.

12
00:01:02,890 --> 00:01:06,894
Well, there are no slides. This is it. You can get

13
00:01:06,932 --> 00:01:10,350
to my website@robrich.org click on presentations.

14
00:01:10,430 --> 00:01:13,506
You can see the definitive deep dive into the git folder here at the

15
00:01:13,528 --> 00:01:16,306
top. Click through to the code and you'll be able to see the code that

16
00:01:16,328 --> 00:01:19,986
we're going to look at today. So it is online right now. While you're

17
00:01:20,018 --> 00:01:24,054
here, click on about me and you'll get to this spot where we look

18
00:01:24,092 --> 00:01:27,458
at some of the things that I've done recently. I'm a Microsoft MVP,

19
00:01:27,554 --> 00:01:30,750
a friend of Redgate, a developer advocate for Cyral,

20
00:01:30,850 --> 00:01:34,950
and let me tell you about AZ givecamp AZ Givecamp brings volunteer developers

21
00:01:35,030 --> 00:01:38,746
together with charities to build free software. We start Friday after work.

22
00:01:38,848 --> 00:01:42,038
Sunday afternoon, we deliver that completed software to the charities.

23
00:01:42,134 --> 00:01:45,646
Sleep is optional caffeine provided. If you're in Phoenix, come join us for

24
00:01:45,668 --> 00:01:49,086
the next AZ give camp. Or if you'd like a give camp here or where

25
00:01:49,108 --> 00:01:52,606
you're connecting from, hit me up on email or Twitter and let's get

26
00:01:52,628 --> 00:01:55,806
a give camp in your neighborhood too. Some of the other things that I've done

27
00:01:55,908 --> 00:01:59,698
I worked on the Gulp team in version two and version three. That was a

28
00:01:59,704 --> 00:02:03,102
lot of fun. And I replied to a Net Rocks podcast episode.

29
00:02:03,166 --> 00:02:06,318
They read my comment on the air and they sent me a mug. Woohoo.

30
00:02:06,414 --> 00:02:09,458
So there's my claim to fame, my coveted net rocks mug.

31
00:02:09,554 --> 00:02:13,254
So let's dig into git. Now we want to look at git and

32
00:02:13,292 --> 00:02:16,962
our goal is to look at every file inside the git folder.

33
00:02:17,026 --> 00:02:19,690
Well, here we have an empty directory,

34
00:02:20,590 --> 00:02:24,330
all the way empty. So let's create a new repository here.

35
00:02:24,400 --> 00:02:28,218
Now when we create a new repository, we could choose to

36
00:02:28,304 --> 00:02:31,546
clone a repository. In this case, we're just going to create a

37
00:02:31,568 --> 00:02:35,294
new one. Git init. Now when we say git in it, it creates this

38
00:02:35,332 --> 00:02:38,926
new git folder. Now this git folder may be hidden by

39
00:02:38,948 --> 00:02:43,054
default in your operating system. You may need to come to view options

40
00:02:43,172 --> 00:02:46,394
and choose to show hidden files and folders. Now that you've got it,

41
00:02:46,452 --> 00:02:49,858
we've got a lot of stuff here in the git folder already. Now I'm going

42
00:02:49,864 --> 00:02:53,566
to open up this folder inside vs. Code. Now I'm not opening

43
00:02:53,598 --> 00:02:57,474
up the containing folder, I'm actually opening up the git

44
00:02:57,522 --> 00:03:01,330
folder because vs code hides the git folder by default

45
00:03:01,410 --> 00:03:04,946
and I really want to look at what's inside. So let's

46
00:03:04,978 --> 00:03:07,854
create come content here in our git folder.

47
00:03:08,002 --> 00:03:11,674
I'm going to say echo file one and

48
00:03:11,712 --> 00:03:14,570
redirect that to file one txt.

49
00:03:15,230 --> 00:03:18,826
I now have a file one txt okay,

50
00:03:18,928 --> 00:03:21,040
git add file one.

51
00:03:21,810 --> 00:03:25,406
Git commit m and I'm going to break convention. Instead of

52
00:03:25,428 --> 00:03:28,574
calling this initial commit, I'm going to call

53
00:03:28,612 --> 00:03:30,720
it file one.

54
00:03:32,550 --> 00:03:35,954
Okay, git log. Now we can see this

55
00:03:35,992 --> 00:03:39,940
content. We have this commit. Here's the content in it.

56
00:03:40,790 --> 00:03:44,466
Let's take a look at some of the things that are

57
00:03:44,648 --> 00:03:48,386
inside of this commit. I'm going to open up the git folder

58
00:03:48,418 --> 00:03:52,370
here inside vs code. And let's first look at objects.

59
00:03:52,530 --> 00:03:56,374
Now we have a bunch of folders inside objects. And inside each

60
00:03:56,412 --> 00:03:59,814
folder we have some files. And what we saw here was

61
00:03:59,852 --> 00:04:03,546
that this commit was d 32 D. Let's look for that one.

62
00:04:03,728 --> 00:04:08,842
Well, we have a d three folder here inside the objects folder and

63
00:04:08,896 --> 00:04:12,554
yep, that's the file. Let's pop it open. Now it's a binary

64
00:04:12,602 --> 00:04:16,158
file, so it looks really

65
00:04:16,244 --> 00:04:19,582
weird. Well, what's inside this? Well, this is a

66
00:04:19,636 --> 00:04:23,674
zlib complete file. So how do we uncompress

67
00:04:23,722 --> 00:04:27,874
it? Well, we could pipe it to gunzip, or we

68
00:04:27,912 --> 00:04:31,778
could pipe it to a bunch of stuff. Here's a c program

69
00:04:31,864 --> 00:04:35,434
that is able to do it. There's a python or there's perl.

70
00:04:35,582 --> 00:04:39,634
And so knowing that it's just deflated, I wrote

71
00:04:39,682 --> 00:04:42,982
a program here called Unzipper. Now,

72
00:04:43,036 --> 00:04:46,390
unzipper is pretty easy. It just

73
00:04:46,540 --> 00:04:49,814
unzips it. Let's open the file,

74
00:04:49,942 --> 00:04:53,322
let's read the file, let's zlib inflate it and

75
00:04:53,376 --> 00:04:57,066
print the contents of it. Okay, so I

76
00:04:57,088 --> 00:04:59,370
want to go after that d three file.

77
00:05:03,170 --> 00:05:10,350
So let me unzipper gitobjects

78
00:05:11,250 --> 00:05:15,438
d three whats file and let's

79
00:05:15,454 --> 00:05:18,606
take a look at it. Okay, so here's that commit.

80
00:05:18,718 --> 00:05:22,674
It's got all of this content. There's my name and

81
00:05:22,712 --> 00:05:26,866
email, and here's the date, time, and time zone of this commit,

82
00:05:26,978 --> 00:05:30,582
it says file one. Oh, zero b nine f

83
00:05:30,636 --> 00:05:34,902
29. I remember seeing that here. Zero b nine

84
00:05:34,956 --> 00:05:38,474
f 29. Okay, so let's unzipper that.

85
00:05:38,512 --> 00:05:43,194
10 b nine

86
00:05:43,232 --> 00:05:46,506
two f nine. And here's the contents of that. It's a

87
00:05:46,528 --> 00:05:49,818
tree node and we've got this content here that's kind

88
00:05:49,824 --> 00:05:53,726
of interesting. Well, there are built in git commands for

89
00:05:53,748 --> 00:05:57,086
us to do this as well. And so we can say git cat

90
00:05:57,188 --> 00:06:00,734
file and we

91
00:06:00,772 --> 00:06:04,580
will give it a git hash. So like zero d.

92
00:06:05,830 --> 00:06:08,020
Oh, that wasn't descriptive enough.

93
00:06:09,190 --> 00:06:13,538
Zero b nine f zero b

94
00:06:13,624 --> 00:06:15,060
nine f.

95
00:06:17,130 --> 00:06:20,934
Oh yes, I need to get cat file and pass in

96
00:06:20,972 --> 00:06:25,126
the type. Okay, so let's say t zero

97
00:06:25,228 --> 00:06:28,786
b nine f. And we can see that this is a tree

98
00:06:28,818 --> 00:06:32,406
node. Okay, if we go look at

99
00:06:32,428 --> 00:06:36,294
this one d thirty two d. Let's get cat file

100
00:06:36,422 --> 00:06:39,906
t. We will see that this one is a commit node.

101
00:06:40,038 --> 00:06:43,662
Well, what type is that? Third one. Whats third one? E two one

102
00:06:43,716 --> 00:06:46,910
two git cat file

103
00:06:47,970 --> 00:06:50,240
t. E two one two.

104
00:06:52,450 --> 00:06:56,446
It is a type blob. So we see that we have commits,

105
00:06:56,558 --> 00:07:00,690
types and blobs. Let's take a look at the contents of the commit.

106
00:07:02,150 --> 00:07:05,362
Okay, so d three two eight. But instead of saying t,

107
00:07:05,416 --> 00:07:08,854
I'm going to say p to get out the contents. Here's the

108
00:07:08,892 --> 00:07:12,914
contents of that file. And we saw this before, the author and the committer

109
00:07:12,962 --> 00:07:16,370
name, email, date, time and time zone.

110
00:07:16,450 --> 00:07:20,370
And it references this tree node. So let's go look at this tree node.

111
00:07:20,530 --> 00:07:23,466
Git cat file p.

112
00:07:23,648 --> 00:07:27,574
There's that hash. Now why am I not putting in the entire hash?

113
00:07:27,702 --> 00:07:31,078
We only need to put in enough to make it unique.

114
00:07:31,174 --> 00:07:34,346
So as long as I have three or four characters. But that's

115
00:07:34,378 --> 00:07:37,710
why often you'll see git logs truncated to

116
00:07:37,780 --> 00:07:41,134
seven characters is we only need enough to make it unique. Okay,

117
00:07:41,172 --> 00:07:45,110
so when I looked at this tree node, it includes file

118
00:07:45,130 --> 00:07:48,670
one txt and here's the file permissions.

119
00:07:48,750 --> 00:07:52,386
It is a blob. And here is that blob e 2129.

120
00:07:52,488 --> 00:07:56,430
Hey, that's the last commit that we had, git cat file

121
00:07:56,590 --> 00:08:00,454
t. That one. It is of type blob. We knew

122
00:08:00,492 --> 00:08:04,134
that because it was a blob here. But let's say p.

123
00:08:04,252 --> 00:08:08,358
And we see that here is the contents of that blob file one.

124
00:08:08,444 --> 00:08:12,086
Yeah, that's the contents of our file right here. Here in the git

125
00:08:12,118 --> 00:08:15,558
folder, we put file one inside that file.

126
00:08:15,654 --> 00:08:19,494
Cool. So we get to see all of the objects. We have commit nodes,

127
00:08:19,542 --> 00:08:23,002
we have tree nodes and we have blob nodes.

128
00:08:23,146 --> 00:08:26,474
Okay, so let's commit some more things. Echo file

129
00:08:26,522 --> 00:08:29,486
two. We'll redirect that to file two.

130
00:08:29,588 --> 00:08:34,078
Txt git add file two git

131
00:08:34,174 --> 00:08:38,100
commits. M file two.

132
00:08:38,630 --> 00:08:42,270
And now if we come in here and we refresh the objects folder,

133
00:08:42,350 --> 00:08:45,586
now we have six commits.

134
00:08:45,698 --> 00:08:49,014
Well, kind of. We have

135
00:08:49,052 --> 00:08:52,562
six nodes. We only have two commits. Each commit

136
00:08:52,626 --> 00:08:56,486
includes a commit, one or more tree nodes, and one or

137
00:08:56,508 --> 00:09:00,230
more blob nodes. So in this case, because we're only committing one file

138
00:09:00,310 --> 00:09:03,802
and in the root directory, then it only ended up being three.

139
00:09:03,936 --> 00:09:07,562
If only there was a way to visualize these without looking at

140
00:09:07,616 --> 00:09:11,606
each one. Well, that's where I'll show you git Explorer

141
00:09:11,718 --> 00:09:15,166
and that's the code linked to this talk. Git Explorer is

142
00:09:15,188 --> 00:09:18,894
a mechanism of being able to visualize the git history.

143
00:09:19,012 --> 00:09:22,254
Once I set my git repo to the path to my

144
00:09:22,292 --> 00:09:25,558
repo not the git folder, but rather the folder

145
00:09:25,594 --> 00:09:29,074
that includes the git folder, then I can start up this website.

146
00:09:29,192 --> 00:09:32,834
So here's my website, let's push refresh and we can

147
00:09:32,872 --> 00:09:35,958
see those six nodes. If I click on a node, I can see the

148
00:09:35,964 --> 00:09:39,686
content. Ooh, that's the blob node. Here's this node and

149
00:09:39,708 --> 00:09:43,430
that's a tree node. Here's another blob node.

150
00:09:44,170 --> 00:09:47,974
Let me show it in alphabetical order. Let me show the

151
00:09:48,092 --> 00:09:51,258
blob history. And now I can kind of click through each one.

152
00:09:51,424 --> 00:09:54,442
Well that's interesting. I can kind of see all of those things,

153
00:09:54,576 --> 00:09:58,410
but I'd really like to understand what type it is straight away.

154
00:09:58,560 --> 00:10:01,866
Let's show the type. Commits will be red, trees will

155
00:10:01,888 --> 00:10:05,434
be blue, logs will be green. Okay, so here's a commit.

156
00:10:05,562 --> 00:10:09,338
It references this tree, B 75. Okay, so let's

157
00:10:09,354 --> 00:10:13,370
click on B 75. B 75 has these two blobs

158
00:10:13,450 --> 00:10:16,830
as part of this commit. Two files are in the repository

159
00:10:16,910 --> 00:10:20,722
at this commits. So we have E 21, E 21

160
00:10:20,776 --> 00:10:24,322
is this one and we also have six c

161
00:10:24,376 --> 00:10:27,826
four, six c four is this one, and here's that other one.

162
00:10:27,928 --> 00:10:30,998
Well, we could look at it this way and that's interesting.

163
00:10:31,164 --> 00:10:35,062
But what if we could do kind of a parent child type of relationship,

164
00:10:35,196 --> 00:10:39,118
not that unlike what we see in a git log. So let's

165
00:10:39,154 --> 00:10:42,522
click on parent build. I'll show the tags again.

166
00:10:42,576 --> 00:10:46,362
Here's the commits and let's show lines referencing them.

167
00:10:46,496 --> 00:10:49,974
So the red ones are the commit nodes. Here's my initial commits

168
00:10:50,022 --> 00:10:53,386
where I commit file one and it references this tree

169
00:10:53,418 --> 00:10:56,894
node. Whats includes this one file. Here's that

170
00:10:57,012 --> 00:11:00,574
blob that references that content. Then in

171
00:11:00,612 --> 00:11:04,414
my next commit I committed this one. Notice how it

172
00:11:04,452 --> 00:11:07,966
now has a parent commit where the other one didn't. The parent commit

173
00:11:07,998 --> 00:11:11,694
is this one and it also has this tree node right here. This tree nodes

174
00:11:11,742 --> 00:11:15,666
says that there are two files in the folder right here. Here's one file file

175
00:11:15,698 --> 00:11:18,502
one and here's another file file two.

176
00:11:18,636 --> 00:11:21,974
That's cool. The objects folder stores all of

177
00:11:22,012 --> 00:11:25,350
the content in the git repository. So as I add new

178
00:11:25,420 --> 00:11:29,378
content into git, then I get new nodes. Well let's see

179
00:11:29,404 --> 00:11:32,698
when they're created. Let's echo file three

180
00:11:32,784 --> 00:11:36,138
to file three. Txt now I have a

181
00:11:36,144 --> 00:11:39,866
new file in my repository. Do I still have six nodes? Yep, I still

182
00:11:39,888 --> 00:11:43,434
have six nodes. Let's git add file

183
00:11:43,482 --> 00:11:47,082
three. Now I've just added that to the repository.

184
00:11:47,146 --> 00:11:50,650
Let's refresh and we see that we now have seven nodes.

185
00:11:50,730 --> 00:11:53,930
Let's do parent child show the type, show the lines,

186
00:11:54,010 --> 00:11:58,110
show the tags. And we have this new blob.

187
00:11:58,270 --> 00:12:02,446
Now this new blob isn't part of any trees, it isn't part of any commits,

188
00:12:02,558 --> 00:12:05,974
but it is staged in the repository. So we have

189
00:12:06,012 --> 00:12:10,146
this blob node. Okay, now let's git commit

190
00:12:10,338 --> 00:12:13,794
m file three. And now when we commit

191
00:12:13,842 --> 00:12:18,006
it, let's refresh this again. Show the type, parent child,

192
00:12:18,108 --> 00:12:22,310
show the lines, show the tags. Now we have this new commit

193
00:12:22,390 --> 00:12:26,346
that references that blob. Well it references this tree. Now this

194
00:12:26,368 --> 00:12:30,314
tree notes that there are three files in the repository at this point. And each

195
00:12:30,352 --> 00:12:33,806
of those files here's one, here's two, here's three. So we don't need

196
00:12:33,828 --> 00:12:36,686
to duplicate the files as we change them.

197
00:12:36,788 --> 00:12:40,558
That's cool. We saw how adding to the staging area

198
00:12:40,644 --> 00:12:44,362
created the blob and how the commit created the tree node

199
00:12:44,426 --> 00:12:47,874
and the commit nodes that referenced those, all of

200
00:12:47,912 --> 00:12:51,534
those here in this objects folder. So let's

201
00:12:51,582 --> 00:12:55,426
do some interesting things. What if we create a file inside of

202
00:12:55,448 --> 00:12:59,062
a folder? Let me create a new folder here and I'm going to say

203
00:12:59,116 --> 00:13:02,770
this is folder. Now this folder is currently empty,

204
00:13:02,850 --> 00:13:07,046
that's totally fine. Let's come back here and we

205
00:13:07,068 --> 00:13:11,830
will say echo file one into folder

206
00:13:11,990 --> 00:13:15,146
file one. Txt git add

207
00:13:15,248 --> 00:13:17,580
folder file one.

208
00:13:18,270 --> 00:13:22,746
Git commit mfolder file

209
00:13:22,778 --> 00:13:27,198
one. And now I've created a commit inside

210
00:13:27,284 --> 00:13:30,526
of the folder. Let's show type parent child, show the

211
00:13:30,548 --> 00:13:33,882
lines, show the tags. Here's that fourth commit.

212
00:13:34,026 --> 00:13:37,614
Now it references this tree node. Now this tree node

213
00:13:37,662 --> 00:13:41,694
says I've got these three files in this folder and I've got this other folder

214
00:13:41,742 --> 00:13:45,782
that is a tree node. So that other 10

215
00:13:45,836 --> 00:13:49,174
b nine f is right here and zero b nine

216
00:13:49,212 --> 00:13:53,030
f says hey, I'm a folder that includes this one file.

217
00:13:53,850 --> 00:13:57,478
Yeah, here's file one and file one

218
00:13:57,564 --> 00:14:01,350
is inside this folder. But file one is also

219
00:14:01,420 --> 00:14:04,794
at the root of the tree too. We still only have three

220
00:14:04,832 --> 00:14:08,070
blob nodes because we have three distinct files.

221
00:14:08,230 --> 00:14:11,866
That's pretty cool. So when we create a

222
00:14:11,888 --> 00:14:15,566
new commit inside of git, it's going to try to reuse the

223
00:14:15,588 --> 00:14:18,846
logs as much as possible and it will try to reuse the

224
00:14:18,868 --> 00:14:22,586
tree nodes. Well, let's go change a file. Let me

225
00:14:22,628 --> 00:14:25,886
come in here out in this folder and I'm going to say file

226
00:14:25,918 --> 00:14:28,340
three, add some code,

227
00:14:28,790 --> 00:14:32,066
change some lines. Okay,

228
00:14:32,168 --> 00:14:35,794
back in our repository git status we can

229
00:14:35,832 --> 00:14:39,318
tell whats we have this file that's modified. Okay, git add

230
00:14:39,404 --> 00:14:42,758
file three. Wait a minute, file three was already in the

231
00:14:42,764 --> 00:14:45,480
repository. Why am I adding it?

232
00:14:45,850 --> 00:14:49,434
Well, what I'm adding is the changes to the

233
00:14:49,472 --> 00:14:52,758
staging area git status,

234
00:14:52,854 --> 00:14:56,614
and I now see that it is stored. Git commit

235
00:14:56,742 --> 00:15:00,226
m modify file

236
00:15:00,278 --> 00:15:03,982
three okay, I've modified file three. Let's refresh our

237
00:15:04,036 --> 00:15:06,894
visualization. We will show type,

238
00:15:07,012 --> 00:15:10,942
parent, child, show the lines, show the tags. Here's that new

239
00:15:10,996 --> 00:15:14,798
commit. It modifies file three. So here

240
00:15:14,884 --> 00:15:18,386
we have a reference to folder. We have a reference to files one, two and

241
00:15:18,408 --> 00:15:22,882
three. But file three is ECA seven. Here's ECA seven

242
00:15:23,016 --> 00:15:26,150
with all of the lines in this file.

243
00:15:26,650 --> 00:15:29,958
Now what if we weren't done modifying this? What if

244
00:15:29,964 --> 00:15:33,586
we noticed, hey, I've got some secrets that I accidentally checked

245
00:15:33,618 --> 00:15:37,346
into file three. So let me modify the

246
00:15:37,468 --> 00:15:40,970
file, remove the secrets.

247
00:15:42,190 --> 00:15:45,130
Maybe I need to add some extra semicolons.

248
00:15:46,110 --> 00:15:49,450
Now I could just say let's get

249
00:15:49,520 --> 00:15:53,230
add file three. Now I could just create another

250
00:15:53,300 --> 00:15:56,686
commit. But we know that that other commit exists and our

251
00:15:56,708 --> 00:15:59,918
goal is to remove the secrets. So here,

252
00:16:00,084 --> 00:16:04,158
let's say no git commit

253
00:16:04,334 --> 00:16:07,422
m file three changed,

254
00:16:07,566 --> 00:16:11,362
but let's say amend. By saying

255
00:16:11,416 --> 00:16:14,638
amend, we are going to rewrite the previous commit.

256
00:16:14,734 --> 00:16:18,102
So we just created a new commit. If I say a

257
00:16:18,156 --> 00:16:21,880
git log, let me shorten that git log

258
00:16:22,250 --> 00:16:26,242
one line. Now I have file three is changed

259
00:16:26,306 --> 00:16:30,614
and it is right on top of folder. Let's refresh our graph.

260
00:16:30,742 --> 00:16:34,266
Now unlike git log, we now get

261
00:16:34,288 --> 00:16:37,590
to see not only just the red commits,

262
00:16:37,750 --> 00:16:40,870
but we also get to see the tree nodes.

263
00:16:41,030 --> 00:16:44,090
And we get to see the blob nodes underneath.

264
00:16:44,250 --> 00:16:47,582
Here's that commit 30 one f.

265
00:16:47,716 --> 00:16:51,214
We saw that right here 30 one f and its parent is

266
00:16:51,252 --> 00:16:54,850
10 f. Here the parent is 10 f.

267
00:16:54,920 --> 00:16:58,434
There's that other commit. But notice how this commit is

268
00:16:58,472 --> 00:17:02,446
still there and types. The secrets

269
00:17:02,478 --> 00:17:05,838
that I checked in are still in my repository.

270
00:17:06,014 --> 00:17:10,210
Now here in this commit, this commit references this tree node

271
00:17:10,290 --> 00:17:13,766
where file three is f. Six. Here's this

272
00:17:13,788 --> 00:17:17,782
one. And that line with the secret is no longer there. But the secret is

273
00:17:17,836 --> 00:17:21,686
in my repository right here and right here. If I've pushed

274
00:17:21,718 --> 00:17:24,694
this repository into a public spot,

275
00:17:24,822 --> 00:17:27,578
or if I've shared this with anyone,

276
00:17:27,744 --> 00:17:31,358
even if it's just on my local machine, I should probably consider

277
00:17:31,444 --> 00:17:35,002
those secrets as exposed. The commits

278
00:17:35,146 --> 00:17:38,638
are still in the repository. Now, the commits will

279
00:17:38,724 --> 00:17:43,120
eventually get collected, but they aren't yet.

280
00:17:43,490 --> 00:17:46,818
As part of every command, git will start up and it'll say, hey, do I

281
00:17:46,824 --> 00:17:50,302
need to do some garbage collection? And if so, it'll run gitGc

282
00:17:50,366 --> 00:17:54,046
behind the scenes. Now in this case, we didn't.

283
00:17:54,238 --> 00:17:57,286
It hasn't been long enough, but here's that

284
00:17:57,388 --> 00:18:01,414
detached head. Okay, so git log

285
00:18:01,612 --> 00:18:05,400
one line. Let's check out here.

286
00:18:06,970 --> 00:18:09,900
Git check out this one.

287
00:18:10,270 --> 00:18:13,980
Ooh, we are in a detached head state.

288
00:18:19,230 --> 00:18:23,054
Well, that is an overly scary message. Did we just get into a

289
00:18:23,092 --> 00:18:26,494
zombie dimension? No, what it says

290
00:18:26,612 --> 00:18:30,442
is that git is not pointing at a branch.

291
00:18:30,506 --> 00:18:34,100
Git is pointing at something else. Git log,

292
00:18:36,790 --> 00:18:37,860
one line.

293
00:18:41,030 --> 00:18:44,654
Head doesn't have main or another branch

294
00:18:44,702 --> 00:18:48,614
label here. Well, let's pivot from looking at objects to looking at

295
00:18:48,652 --> 00:18:51,746
branches and how branches work. So we saw the objects

296
00:18:51,778 --> 00:18:55,170
folder, how we have objects for commits, types,

297
00:18:55,250 --> 00:18:58,546
and blobs. Here in the refs folder,

298
00:18:58,658 --> 00:19:02,458
we have all of the details for where we are.

299
00:19:02,544 --> 00:19:05,850
Here's the main branches. It's at 301 f eight.

300
00:19:06,000 --> 00:19:10,394
Okay, well, I didn't see that here. Instead of git logs oneline,

301
00:19:10,442 --> 00:19:14,346
let's say gitlog oneline graph graph

302
00:19:14,378 --> 00:19:18,142
will give us this ascii art, which is kind of interesting. Let's actually

303
00:19:18,196 --> 00:19:21,966
add, decorate, and decorate will

304
00:19:21,988 --> 00:19:25,282
add branch labels. Well, in this case, we were getting the branch labels without

305
00:19:25,336 --> 00:19:28,674
this because I actually have a setting turned on that shows

306
00:19:28,712 --> 00:19:32,020
them to me all the time. Now let's say all

307
00:19:32,950 --> 00:19:36,466
shows us not only the commits for our current branches, but also

308
00:19:36,488 --> 00:19:39,706
the commits for every branch. So now we see 301.

309
00:19:39,708 --> 00:19:42,294
And we see that main is pointed right there.

310
00:19:42,492 --> 00:19:46,902
Now the cool part about this file is it is just that

311
00:19:46,956 --> 00:19:50,186
commit hash. Now, there is one here called head.

312
00:19:50,368 --> 00:19:54,234
Head is at one eight.

313
00:19:54,272 --> 00:19:57,942
If I wanted to move head to say this commit,

314
00:19:58,086 --> 00:20:01,326
I could say head is over there.

315
00:20:01,508 --> 00:20:05,194
Now let's do a git logs oneline graph

316
00:20:05,322 --> 00:20:09,006
decorate all and here's head pointed at main well,

317
00:20:09,108 --> 00:20:13,214
we kind of messed up our working folder. We still only have the files

318
00:20:13,262 --> 00:20:16,562
as if it was right here. Let's undo that and put head

319
00:20:16,616 --> 00:20:19,282
back where it is. Okay,

320
00:20:19,416 --> 00:20:23,438
types head is back where it is git status

321
00:20:23,614 --> 00:20:27,094
and we're still in a detached head state. That means

322
00:20:27,132 --> 00:20:30,370
that head is pointing at a commit instead of a branch.

323
00:20:30,530 --> 00:20:34,278
Let's check out a branch git checkout b

324
00:20:34,444 --> 00:20:38,002
branch now if we do a git log

325
00:20:38,156 --> 00:20:41,882
oneline graph decorate alt we see that head

326
00:20:41,936 --> 00:20:45,466
is pointing at this branch. Let's pop open the head file and

327
00:20:45,488 --> 00:20:48,998
it now says the ref is refs heads branch.

328
00:20:49,174 --> 00:20:52,734
Okay, so refs heads oh, we have this new file called

329
00:20:52,772 --> 00:20:57,134
branches and branch has one eight

330
00:20:57,172 --> 00:21:00,682
git branch names are just name tags.

331
00:21:00,746 --> 00:21:04,100
They point at commits so we could move them around.

332
00:21:04,550 --> 00:21:08,740
Let's say git merge file three.

333
00:21:09,750 --> 00:21:13,838
And now if we do log one line, we see that branch moved

334
00:21:13,854 --> 00:21:16,982
from file two to file three. It now says one

335
00:21:17,036 --> 00:21:21,160
e 21. The file branch says one e 21.

336
00:21:22,490 --> 00:21:26,150
Head still points at ref's head's branch though. That's cool.

337
00:21:26,300 --> 00:21:30,342
If I were to say git checkout main now head

338
00:21:30,396 --> 00:21:34,250
points at ref's head's main. Now main is still at 30

339
00:21:34,320 --> 00:21:38,006
one, but head points at main instead of pointing at branch.

340
00:21:38,118 --> 00:21:41,566
Git checkout branch and

341
00:21:41,588 --> 00:21:45,290
now let's commit a new file. Echo file

342
00:21:45,370 --> 00:21:49,246
seven redirect whats to file seven

343
00:21:49,348 --> 00:21:54,030
txt git add file seven git

344
00:21:54,110 --> 00:21:57,620
commits m file seven

345
00:21:58,390 --> 00:22:02,462
and now let's go look at our graph

346
00:22:02,526 --> 00:22:05,490
and see how this works. Show types,

347
00:22:05,640 --> 00:22:09,430
show lines, parent child show

348
00:22:09,500 --> 00:22:14,054
tags. Okay, so we've got this new commit that

349
00:22:14,252 --> 00:22:17,542
points at nothing. Oh no,

350
00:22:17,596 --> 00:22:21,802
that's main. Here's Main. We've got refs has main there.

351
00:22:21,936 --> 00:22:25,434
Here's branch refs heads branches and

352
00:22:25,472 --> 00:22:29,386
head is there as well. We still have whats dangling commit with our

353
00:22:29,408 --> 00:22:33,274
secrets in it. But that's how we got those things split out. We have commits

354
00:22:33,322 --> 00:22:36,906
going this way and commits going whats way. Now if we say git

355
00:22:36,938 --> 00:22:40,878
log oneline graph decorate all

356
00:22:40,964 --> 00:22:44,674
we can now see based on this decorate that it goes in different

357
00:22:44,712 --> 00:22:48,590
directions. That's cool. Git merge

358
00:22:48,670 --> 00:22:52,210
main and now we can see whats those

359
00:22:52,280 --> 00:22:56,206
go back together. Now in the log here we're only showing

360
00:22:56,238 --> 00:23:00,166
commit nodes, but we saw how we can see other nodes. Now what if I

361
00:23:00,188 --> 00:23:03,494
want to pick up main and put it where branches. Well I can

362
00:23:03,532 --> 00:23:07,190
take a look at where is main. Main is right here.

363
00:23:07,260 --> 00:23:10,940
Where is branch branch is right here. So I could say

364
00:23:11,310 --> 00:23:15,034
I would like to just move you there. Now we saw that bad

365
00:23:15,072 --> 00:23:18,714
things happened when we did that last time. So let's do this ninja move

366
00:23:18,832 --> 00:23:22,346
git update ref ref heads

367
00:23:22,458 --> 00:23:25,150
main to point at branch.

368
00:23:25,970 --> 00:23:29,374
We'll look at that log and we just picked up main and put

369
00:23:29,412 --> 00:23:33,082
it here. Now that isn't a merge. It doesn't try to reconcile

370
00:23:33,146 --> 00:23:36,754
differences. It just literally picks this thing up and puts it over there.

371
00:23:36,872 --> 00:23:40,658
Do not pass go, do not collect $200. You may lose history,

372
00:23:40,824 --> 00:23:44,322
but update ref refeads main.

373
00:23:44,456 --> 00:23:50,138
We saw how that updated this ref refined

374
00:23:50,174 --> 00:23:53,542
this file. That's perfect. So now let's tag something

375
00:23:53,676 --> 00:23:57,682
git tag v zero one git

376
00:23:57,746 --> 00:24:01,494
log oneline graph decorate

377
00:24:01,622 --> 00:24:05,162
all and now we see a tag. Well tags are just

378
00:24:05,216 --> 00:24:08,586
stored in this tags folder. Here's v zero one and

379
00:24:08,608 --> 00:24:11,130
it just happens to point at this commit.

380
00:24:11,730 --> 00:24:14,586
The marketplace can help with one files.

381
00:24:14,698 --> 00:24:18,654
So here's that tag and it is as branches are just

382
00:24:18,692 --> 00:24:21,934
a name tag pointing to other things. Now so far

383
00:24:21,972 --> 00:24:25,506
we've only been working with our local directory. Now what if

384
00:24:25,528 --> 00:24:29,410
we could push this up to a server? Let's come over here into

385
00:24:29,560 --> 00:24:33,426
this folder, this server folder. This folder is empty and

386
00:24:33,448 --> 00:24:35,858
let's create a new repository over here.

387
00:24:36,024 --> 00:24:39,926
Git in it was how we created a repository before, but let's add

388
00:24:39,948 --> 00:24:42,550
a bear in this case.

389
00:24:42,620 --> 00:24:45,970
Now bear will create a repository,

390
00:24:46,130 --> 00:24:49,074
but it's only the contents of the git folder.

391
00:24:49,122 --> 00:24:52,506
There is no git folder in this case. Now that's perfect for

392
00:24:52,528 --> 00:24:56,598
a server. When we don't need a working directory, we don't need a checkout mechanism,

393
00:24:56,694 --> 00:25:00,830
we just have a server. Okay, so here in this server we have

394
00:25:00,900 --> 00:25:04,766
rafts, we have objects, we have all of the things. Let's add

395
00:25:04,868 --> 00:25:08,378
this as a remote git remote

396
00:25:08,474 --> 00:25:12,046
add origin. Now why is it origin?

397
00:25:12,228 --> 00:25:16,254
By convention? We could call it server, we could call it foo.

398
00:25:16,382 --> 00:25:21,010
And what is the path to that? I could say HTTPs GitHub.com

399
00:25:21,080 --> 00:25:24,562
slash blah blah blah. Or I could point it to a

400
00:25:24,616 --> 00:25:28,680
UNC path server name share

401
00:25:29,050 --> 00:25:33,046
in this case I'm just going to point it to this relative path here

402
00:25:33,148 --> 00:25:36,754
in my folder. So I'll go up a directory server

403
00:25:36,882 --> 00:25:40,614
and so I'm going to add that remote there git

404
00:25:40,662 --> 00:25:43,754
remote v and I can see that there's my

405
00:25:43,792 --> 00:25:47,226
origin server git push origin main

406
00:25:47,408 --> 00:25:50,746
I push all of the content from my machine to

407
00:25:50,768 --> 00:25:54,126
that remote machine. And now if I do a git log,

408
00:25:54,308 --> 00:25:57,230
oneline, graph, decorate all,

409
00:25:57,300 --> 00:26:00,414
I can see origin main there as well. Let's hooks

410
00:26:00,452 --> 00:26:04,666
inside the git folder at the refs and I now have a remotes folder.

411
00:26:04,778 --> 00:26:07,986
Remotes has an origin folder. That's the only remote that I

412
00:26:08,008 --> 00:26:11,970
have. And here's main. Here's where I think the server's main is.

413
00:26:12,120 --> 00:26:15,426
Now, if other people contribute to this and I push and pull,

414
00:26:15,528 --> 00:26:19,634
then this remotes origin main may update.

415
00:26:19,682 --> 00:26:22,834
To do that, well, let's push the other branches that we have. Git,

416
00:26:22,882 --> 00:26:26,962
push Origin branch, and we'll also push tags.

417
00:26:27,106 --> 00:26:30,394
Okay, branch points to branch v 0.1. Points to v

418
00:26:30,432 --> 00:26:33,386
0.1. And so here in my folder now,

419
00:26:33,488 --> 00:26:37,338
I have in remote's origin I have branches and

420
00:26:37,424 --> 00:26:40,378
main and all of the content is there.

421
00:26:40,464 --> 00:26:43,674
Now, I don't have a remote tracking branch for tags,

422
00:26:43,802 --> 00:26:47,210
but I do have a remote tracking branch for branches.

423
00:26:47,370 --> 00:26:51,162
That's kind of interesting. So we took a look at refs,

424
00:26:51,226 --> 00:26:54,766
and refs is how we store our name tags,

425
00:26:54,798 --> 00:26:58,034
our labels, our human readable things because,

426
00:26:58,152 --> 00:27:02,194
well, these git hashes are too long. Let's next look

427
00:27:02,232 --> 00:27:05,922
at hooks. Here's hooks. In the hooks directory we have

428
00:27:05,976 --> 00:27:09,670
various files. Now here's the apply patch message

429
00:27:09,820 --> 00:27:13,222
sample. We can see that it's just a shell script. It does some

430
00:27:13,276 --> 00:27:16,210
interesting things. Here's another one. It's a shell script.

431
00:27:16,290 --> 00:27:19,802
Here's another one. Ooh, this is a perl file. That's pretty cool. Here's another

432
00:27:19,856 --> 00:27:23,718
shell script. Now, they're all named sample, and they're

433
00:27:23,734 --> 00:27:27,414
all named sample because, well, they're just examples.

434
00:27:27,542 --> 00:27:30,666
If we were to remove the sample part, then that hooks

435
00:27:30,698 --> 00:27:34,734
would be active. Let me go reach into my

436
00:27:34,772 --> 00:27:38,334
stash and go grab a copy of all of these

437
00:27:38,452 --> 00:27:41,982
that don't have the sample after

438
00:27:42,036 --> 00:27:45,786
them. Now, in each of these files I

439
00:27:45,828 --> 00:27:49,426
just remove the dot sample and then I also echo the content

440
00:27:49,528 --> 00:27:52,738
that is coming in. What are the arguments that are passed to it?

441
00:27:52,824 --> 00:27:56,694
So commit message. Let's echo commit message and the

442
00:27:56,732 --> 00:27:59,922
arguments. Now, these hooks are great for automating

443
00:27:59,986 --> 00:28:03,714
interesting tasks. For example, let's say echo

444
00:28:03,842 --> 00:28:06,774
file six to file six.

445
00:28:06,892 --> 00:28:10,506
Txt. Did we get any hooks there? No, we're just echoing the

446
00:28:10,528 --> 00:28:13,274
file git add file six.

447
00:28:13,392 --> 00:28:16,742
Let's add it to the staging area. No hooks there. Git,

448
00:28:16,806 --> 00:28:20,394
commit m file six. And now we get some

449
00:28:20,432 --> 00:28:23,786
hooks. This is perfect. We get a pre commits hook. We get

450
00:28:23,808 --> 00:28:27,982
a prepare commit message hook. We have a commit message hook. And at each step

451
00:28:28,036 --> 00:28:31,594
we can do certain actions. For example, at a precommit hook,

452
00:28:31,642 --> 00:28:35,138
we might want to run unit tests or linting on all of the files that

453
00:28:35,144 --> 00:28:38,802
are staged or perhaps the entire project. Prepare commit message

454
00:28:38,856 --> 00:28:42,446
hook we might want to validate the commit message follows our naming

455
00:28:42,478 --> 00:28:46,982
conventions. Maybe we require that it references a particular issue.

456
00:28:47,116 --> 00:28:51,080
And then the commit hook, let's validate that all the things are there.

457
00:28:51,530 --> 00:28:55,106
Git push origin branches let's

458
00:28:55,138 --> 00:28:58,374
push this up to the remote repository and we see

459
00:28:58,412 --> 00:29:02,266
that we get a pre push hooks. At the pre push hook we

460
00:29:02,288 --> 00:29:05,654
could take a look at other content. We could also have hooks on the server

461
00:29:05,702 --> 00:29:08,986
that might trigger a remote build or something interesting there.

462
00:29:09,168 --> 00:29:12,958
Now these hooks have been really interesting in being able to automate a

463
00:29:12,964 --> 00:29:16,826
lot of workflows, so I want to check them into my git repository.

464
00:29:16,938 --> 00:29:20,910
Let me say gitad Githooks

465
00:29:21,890 --> 00:29:26,050
commit message git status.

466
00:29:27,190 --> 00:29:31,422
We can't commit the contents of the git folder.

467
00:29:31,566 --> 00:29:34,994
So how do we share the hooks? Right now the hooks only work on my

468
00:29:35,032 --> 00:29:38,662
machine. They don't work on your machine. There's a package here, and there are many

469
00:29:38,716 --> 00:29:41,846
packages to do this, but this package is in node and

470
00:29:41,868 --> 00:29:45,058
is called git hooks. The cool part is once you install git

471
00:29:45,074 --> 00:29:49,222
hooks, it automatically creates sim links from all of those hooks

472
00:29:49,286 --> 00:29:52,726
inside the hooks directory to another folder.

473
00:29:52,838 --> 00:29:56,342
So you can control where the folder is, but by definition

474
00:29:56,406 --> 00:29:59,574
it is the hooks folder or git hooks

475
00:29:59,622 --> 00:30:03,890
folder. And so now if all of the files are here in this gith

476
00:30:03,990 --> 00:30:07,454
folder, now I can commits them to repository and

477
00:30:07,492 --> 00:30:10,606
share them. And the cool part is the moment that you NPM install,

478
00:30:10,708 --> 00:30:13,914
you get those sim links too. Now the sim links aren't automatic,

479
00:30:14,042 --> 00:30:17,534
but it's pretty cool. And there are similar packages in other libraries.

480
00:30:17,582 --> 00:30:20,974
If you're in Python, for example, you can use a python

481
00:30:21,022 --> 00:30:24,722
library that will do a similar mechanism of moving these hooks into

482
00:30:24,776 --> 00:30:28,786
a spot where you can commit them and sim linking

483
00:30:28,818 --> 00:30:32,374
back the moment that you pip install. So we've got hooks great

484
00:30:32,412 --> 00:30:35,842
ways to automate processes, whether it's unit tests

485
00:30:35,906 --> 00:30:39,722
or whether it's other content. It's a great way to create

486
00:30:39,856 --> 00:30:43,318
automation. Next, let's look at configuration.

487
00:30:43,494 --> 00:30:47,050
Now we have this config file here.

488
00:30:47,200 --> 00:30:51,034
Now this config file tells us the details that we've built into our

489
00:30:51,072 --> 00:30:54,418
repository. This config file actually overrides

490
00:30:54,454 --> 00:30:57,518
the config file that we have in our home directory. Let's go find it.

491
00:30:57,604 --> 00:31:00,958
So in my case, because I'm on windows, I'm going to go to c

492
00:31:01,044 --> 00:31:04,590
users rob and I'm going to open up the git

493
00:31:04,670 --> 00:31:08,446
config file. Now here in this git config file

494
00:31:08,478 --> 00:31:12,030
is all of the details that will apply to all repositories

495
00:31:12,110 --> 00:31:15,734
on my machine and this one actually overrides another one.

496
00:31:15,772 --> 00:31:19,640
So if we come here to open file and we go into

497
00:31:20,090 --> 00:31:23,938
in my case I'm going to go into program files.

498
00:31:24,114 --> 00:31:27,634
Git, I bet it's in git config.

499
00:31:27,682 --> 00:31:31,798
There it is. Now these are the options that I chose

500
00:31:31,894 --> 00:31:35,926
when I installed git on my machine. If I reinstall git,

501
00:31:36,038 --> 00:31:39,306
it will replace this file with the options that I choose there.

502
00:31:39,408 --> 00:31:42,954
Now this is the machine

503
00:31:43,002 --> 00:31:46,206
one, this is the system one which is user specific,

504
00:31:46,308 --> 00:31:49,374
which overrides it. And then this is the local one to

505
00:31:49,412 --> 00:31:53,514
my repository which overrides it still. So let's imagine

506
00:31:53,562 --> 00:31:57,026
that I'm working on a business project and well

507
00:31:57,128 --> 00:32:00,750
when I started off I created this user name and user

508
00:32:00,830 --> 00:32:04,894
email and I put in my personal details, but in this project

509
00:32:05,032 --> 00:32:08,278
I want to create it with my work email.

510
00:32:08,444 --> 00:32:10,502
So let's override this.

511
00:32:10,636 --> 00:32:17,254
Robrich@company.com now

512
00:32:17,372 --> 00:32:20,794
this is the specifics for this repository that

513
00:32:20,832 --> 00:32:24,694
is now tied to my corporate account. Now I could override

514
00:32:24,742 --> 00:32:28,874
anything. I could override the things in my machine config or

515
00:32:28,912 --> 00:32:32,074
in my system config here in my system config

516
00:32:32,122 --> 00:32:34,960
I've identified my merge tool, my diff tool,

517
00:32:35,890 --> 00:32:38,954
long paths and some shortcuts, some aliases.

518
00:32:39,082 --> 00:32:42,286
But here's that default branch setting that is really cool.

519
00:32:42,388 --> 00:32:46,482
If I want to set a default branch in a different way for

520
00:32:46,536 --> 00:32:50,274
this repository I could set it here. Maybe I want to call

521
00:32:50,312 --> 00:32:54,610
it trunk. Now that's just the default branch, that isn't the

522
00:32:54,760 --> 00:32:58,434
branch that I'm currently on and it doesn't even need to exist.

523
00:32:58,562 --> 00:33:01,814
But that's the default branch that will be created when I create

524
00:33:01,852 --> 00:33:05,254
a new repository. So I'm able to override the

525
00:33:05,292 --> 00:33:08,918
configuration in a really elegant way that's in the config file.

526
00:33:09,014 --> 00:33:12,970
There are some other configuration in this repository as well.

527
00:33:13,120 --> 00:33:17,062
Inside the info folder

528
00:33:17,206 --> 00:33:20,366
there is an exclude folder. Now I could choose to

529
00:33:20,388 --> 00:33:23,530
exclude bin, ob nodes,

530
00:33:23,610 --> 00:33:25,950
modules, vn,

531
00:33:26,850 --> 00:33:29,966
all of the directories that get built as part of

532
00:33:29,988 --> 00:33:33,634
my project. Now this exclude file is interesting, but this

533
00:33:33,672 --> 00:33:37,758
exclude file is well in my git folder.

534
00:33:37,934 --> 00:33:41,262
So rather than messing with this configuration

535
00:33:41,326 --> 00:33:45,034
file, let's instead create a new file,

536
00:33:45,182 --> 00:33:48,962
echo bin two git ignore.

537
00:33:49,106 --> 00:33:53,254
And now let's go grab this git ignore file and

538
00:33:53,292 --> 00:33:56,482
we can edit this git ignore file. Now by editing

539
00:33:56,546 --> 00:33:59,850
this git ignore file and putting all of those details there,

540
00:34:00,000 --> 00:34:03,722
now I can actually commit this one git add

541
00:34:03,856 --> 00:34:06,954
git ignore. Now the git ignore is

542
00:34:06,992 --> 00:34:10,330
great, because I can share it, but if I want to override that specific

543
00:34:10,400 --> 00:34:14,366
to my machine, the info exclude folder can work out great there.

544
00:34:14,468 --> 00:34:17,866
Now I'd recommend not doing it in the info exclude

545
00:34:17,898 --> 00:34:21,646
file because it's not shared. There was one gig where

546
00:34:21,668 --> 00:34:24,990
I worked on where there was one machine whats was possessed

547
00:34:25,490 --> 00:34:29,346
and the reason was we had filled up the exclude file with various things

548
00:34:29,448 --> 00:34:33,186
and it was only on that machine. And so yeah, as soon

549
00:34:33,208 --> 00:34:36,598
as we cleaned out the exclude file everything worked out great.

550
00:34:36,684 --> 00:34:40,406
Let's look at other configuration. Here we have the

551
00:34:40,508 --> 00:34:44,306
config, we have the exclude. We also have description.

552
00:34:44,418 --> 00:34:47,714
Now this description is the details

553
00:34:47,842 --> 00:34:50,290
for Git Instaweb.

554
00:34:50,370 --> 00:34:53,658
Gitinstaweb works really well on Linux to just spin up a

555
00:34:53,664 --> 00:34:56,794
quick website to be able to look at the repository. It doesn't work

556
00:34:56,832 --> 00:35:00,406
on Windows and really our websites

557
00:35:00,438 --> 00:35:04,766
have kind of caught up and exceeded this. So probably you're using GitHub or

558
00:35:04,948 --> 00:35:08,526
BitBucket or GitLab and so you probably don't need to

559
00:35:08,548 --> 00:35:11,786
use Instaweb. But if you want to give your repository a description

560
00:35:11,818 --> 00:35:14,670
in Instaweb, here's the description file.

561
00:35:14,830 --> 00:35:18,082
Next, let's look at this index file. Now this

562
00:35:18,136 --> 00:35:21,758
index file is a good mechanism

563
00:35:21,854 --> 00:35:25,186
for looking at, well wow, that's a lot

564
00:35:25,208 --> 00:35:28,786
of garbage. This shows the current directory.

565
00:35:28,898 --> 00:35:32,898
Well how do we read this file? What is in the git index file?

566
00:35:33,074 --> 00:35:36,946
Well, we can take a look at content with Gitls files.

567
00:35:37,058 --> 00:35:40,666
There's also a mechanism here. It describes all of the

568
00:35:40,768 --> 00:35:44,214
mechanism of how that file is built. Here's a python

569
00:35:44,262 --> 00:35:47,862
program called Gin that is able to parse that index

570
00:35:47,926 --> 00:35:50,914
file. But let's actually use that Git command.

571
00:35:51,062 --> 00:35:54,350
Gitls files stage

572
00:35:54,770 --> 00:35:58,346
stage gives us this extra column that tells us what stage

573
00:35:58,378 --> 00:36:02,138
of a merge it's in. Right now it's zero because none of them are merging.

574
00:36:02,234 --> 00:36:06,078
So this shows me all of the files in my current working directory

575
00:36:06,254 --> 00:36:09,474
and the hash of the blob for

576
00:36:09,512 --> 00:36:12,734
each one. So we've got git ignore and git ignore

577
00:36:12,782 --> 00:36:16,638
isn't committed yet, but it is df three c, nine. Let's come

578
00:36:16,664 --> 00:36:20,534
back to our graph, let's refresh it. We will show type,

579
00:36:20,652 --> 00:36:24,822
parent child, let's show the lines, let's show the tags. And here's df three,

580
00:36:24,876 --> 00:36:28,322
c, nine. It shows the blobs.

581
00:36:28,466 --> 00:36:32,426
So that git can quickly look at is the hash of

582
00:36:32,448 --> 00:36:36,374
the file the same as the hash of the blob? If so, that file hasn't

583
00:36:36,422 --> 00:36:40,538
changed and I can ignore it when I'm doing things like staging things.

584
00:36:40,704 --> 00:36:44,094
So this index file is a great reference for all

585
00:36:44,132 --> 00:36:47,678
the things in my working directory. That is cool.

586
00:36:47,844 --> 00:36:51,294
We also have temp files here. In this repository we

587
00:36:51,332 --> 00:36:55,074
have a ridge head. This is the message passed into

588
00:36:55,112 --> 00:36:58,450
the hook. It writes it to disk so that it can pass it along.

589
00:36:58,600 --> 00:37:02,194
Here's the commit edit message. Here's the

590
00:37:02,232 --> 00:37:05,766
message that I was creating inside this commit passed into all

591
00:37:05,788 --> 00:37:08,946
the hooks. Info refs.

592
00:37:09,058 --> 00:37:11,986
You might find a refs folder inside the info folder.

593
00:37:12,018 --> 00:37:15,080
In this case we don't have one. A ridge head.

594
00:37:15,770 --> 00:37:19,178
Where was head before we were about to commit this? That's kind

595
00:37:19,184 --> 00:37:22,742
of interesting. Temp files

596
00:37:22,806 --> 00:37:26,486
just kind of kick around and ultimately ignoring

597
00:37:26,518 --> 00:37:29,962
them is probably good. Next, let's hooks

598
00:37:30,016 --> 00:37:33,766
at logs. Here's a logs folder. Inside logs

599
00:37:33,798 --> 00:37:37,406
is this head file. Now we started out with commit zero and then

600
00:37:37,428 --> 00:37:41,066
we created commit D 32 D. Then we're

601
00:37:41,098 --> 00:37:45,026
at d three. We went to one eight five. And so we can

602
00:37:45,048 --> 00:37:48,734
see that this is a history of all of our commits.

603
00:37:48,862 --> 00:37:52,898
Let's do a git commit m

604
00:37:53,064 --> 00:37:56,280
git ignore git logs,

605
00:37:56,890 --> 00:37:59,058
oneline graph,

606
00:37:59,234 --> 00:38:02,866
decorate all. And now we've

607
00:38:02,898 --> 00:38:06,674
got all of this content. Now I have pushed branch here, but let's

608
00:38:06,722 --> 00:38:10,862
say for example, I said git update refresh

609
00:38:10,946 --> 00:38:14,890
heads branch to over

610
00:38:15,040 --> 00:38:18,874
here. Now this is the ninja move. The do not pass go.

611
00:38:18,992 --> 00:38:23,902
So now if I say show me all the things that

612
00:38:23,956 --> 00:38:27,694
commit is gone. Now whether I deleted the branch or

613
00:38:27,732 --> 00:38:30,826
whether I whats in a detached head state and just moved

614
00:38:30,858 --> 00:38:33,540
on or whatever reason for this,

615
00:38:34,150 --> 00:38:37,326
I've lost that content. Well, have I lost

616
00:38:37,358 --> 00:38:41,026
that content? We're looking for seven. Let's come back to our

617
00:38:41,048 --> 00:38:44,178
graph and let's refresh it. Show type,

618
00:38:44,264 --> 00:38:47,110
parent child, show lines, show tags.

619
00:38:47,930 --> 00:38:51,842
Seven is still there. There just aren't any branches

620
00:38:51,906 --> 00:38:55,170
pointing to it. Eventually git garbage collecting

621
00:38:55,250 --> 00:38:58,426
will come through and delete this one together with any of the

622
00:38:58,448 --> 00:39:01,610
other dangling nodes like these. Well, how do we get back?

623
00:39:01,760 --> 00:39:06,330
Let's use that log file. Let's say git reflog.

624
00:39:07,790 --> 00:39:11,786
Reflog. Git reflog.

625
00:39:11,898 --> 00:39:15,310
Show me where the head has been. Well,

626
00:39:15,460 --> 00:39:19,038
it's at 30 one f eight ad. But it used to

627
00:39:19,044 --> 00:39:22,502
be at seven and before that it was. Ooh,

628
00:39:22,586 --> 00:39:25,538
so seven is where I want to go.

629
00:39:25,704 --> 00:39:30,020
Okay, git checkout seven.

630
00:39:30,390 --> 00:39:33,220
Oh, I didn't copy that. Let me copy it again.

631
00:39:33,830 --> 00:39:37,720
Oh. Now I am in a detached head state,

632
00:39:38,170 --> 00:39:41,830
but if I look at it, I now

633
00:39:41,900 --> 00:39:46,326
have that commits back git checkout b

634
00:39:46,508 --> 00:39:50,182
undelete. And now head

635
00:39:50,236 --> 00:39:54,298
is no longer detached. It's pointing at a branch and I have that commit history

636
00:39:54,384 --> 00:39:57,786
back now. The cool thing is that that was a great way to

637
00:39:57,808 --> 00:40:01,386
read this ref log. And this ref log was for head. But we

638
00:40:01,408 --> 00:40:04,270
also have a ref log for other things. So for example,

639
00:40:04,340 --> 00:40:07,646
here's the ref log for branch, here's the ref log for main,

640
00:40:07,748 --> 00:40:11,386
here's the ref log for undelete. It's only created

641
00:40:11,418 --> 00:40:14,702
moments ago. We also have ref logs for remotes which

642
00:40:14,756 --> 00:40:18,558
can be really helpful so you can parse through the ref logs

643
00:40:18,574 --> 00:40:22,446
to be able to get back to commits if the git garbage

644
00:40:22,478 --> 00:40:26,020
collection hasn't come through and removed them. That's cool.

645
00:40:26,650 --> 00:40:29,830
So we were able to look at the

646
00:40:29,900 --> 00:40:33,506
hooks folder so that we could see automation. We saw the exclude

647
00:40:33,538 --> 00:40:37,794
file, the configuration details. Here's also configuration details. We saw temporary

648
00:40:37,842 --> 00:40:41,366
files including commits message and a ridge head, the index file

649
00:40:41,398 --> 00:40:45,066
that allows us to quickly diff the blobs in our

650
00:40:45,088 --> 00:40:48,346
repository with the files in our working directory. We saw

651
00:40:48,368 --> 00:40:52,134
the refs folder, how we were able to store name tags,

652
00:40:52,182 --> 00:40:55,486
both branches, tags and remotes to be able

653
00:40:55,508 --> 00:40:59,086
to understand where these are in more human readable format. And we were

654
00:40:59,108 --> 00:41:02,750
able to look through the objects to be able to see all of the content

655
00:41:02,820 --> 00:41:06,690
in our repository. Now let's do one of those GitGCs for

656
00:41:06,840 --> 00:41:10,420
a bit. GitGC and this

657
00:41:11,110 --> 00:41:14,798
git GC, this will go enumerate

658
00:41:14,814 --> 00:41:18,054
all the objects and count them and pack them.

659
00:41:18,172 --> 00:41:22,118
And so what we end up with is now instead

660
00:41:22,204 --> 00:41:25,074
of objects having lots of folders,

661
00:41:25,202 --> 00:41:28,098
we have one small pack file.

662
00:41:28,194 --> 00:41:31,322
Well, kind of. We have two files. We have one

663
00:41:31,376 --> 00:41:35,114
that is a pack file and one that is an

664
00:41:35,152 --> 00:41:38,422
IDX. Much like this index file. That IDX

665
00:41:38,486 --> 00:41:42,554
file is a reference of all of the content in that folder.

666
00:41:42,682 --> 00:41:45,706
So we can unpack the references,

667
00:41:45,818 --> 00:41:49,578
but git will do that automatically if it needs to. The visualization

668
00:41:49,674 --> 00:41:54,046
tool knows how to read the pack files though. So if we refresh

669
00:41:54,158 --> 00:41:57,586
we still get all of the show type,

670
00:41:57,768 --> 00:42:01,422
parent, build, show the lines, show the tags,

671
00:42:01,486 --> 00:42:05,262
we still see all of the commit history and yep, that dangling

672
00:42:05,326 --> 00:42:08,690
one is still there. Our secrets are still baked into the repository.

673
00:42:09,110 --> 00:42:11,542
One more thing that I would like to show you, which is pretty cool.

674
00:42:11,596 --> 00:42:15,190
Here's a reference into all of those files. We looked at each one

675
00:42:15,260 --> 00:42:19,206
and if you learn more by reading instead of by watching, I would invite you

676
00:42:19,228 --> 00:42:23,546
to point to this post on get ready.

677
00:42:23,648 --> 00:42:27,466
It describes each of the files and what each one does not.

678
00:42:27,488 --> 00:42:30,582
Whats different from what we talked about here. We have refs,

679
00:42:30,646 --> 00:42:34,714
we have objects, we have hooks, we have configuration, we have temp

680
00:42:34,762 --> 00:42:38,526
files. It is really cool. All of this content

681
00:42:38,628 --> 00:42:42,334
lives inside this git folder. So how do I backup this

682
00:42:42,372 --> 00:42:45,870
repository? Well, I can just copy this git folder to another

683
00:42:45,940 --> 00:42:50,122
location or just push those commits into another repository.

684
00:42:50,266 --> 00:42:53,914
This has been a lot of fun, getting to show you the deep dive

685
00:42:53,962 --> 00:42:58,146
into the git folder. Grab the code for the git Explorer

686
00:42:58,178 --> 00:43:02,226
here on GitHub and you can get to it real easily by going to robrich.org

687
00:43:02,258 --> 00:43:05,634
slash presentations and looking for the definitive deep

688
00:43:05,682 --> 00:43:09,474
dive into the git folder. I'll be at that spot where the conference is designated

689
00:43:09,522 --> 00:43:12,710
for Q A. Or if you're watching this later, hit me up

690
00:43:12,780 --> 00:43:16,550
on Twitter at robrich or by email by clicking on the email

691
00:43:16,620 --> 00:43:19,460
link on my site@robrich.org. Thanks for watching.

