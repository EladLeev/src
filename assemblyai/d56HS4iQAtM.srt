1
00:00:23,110 --> 00:00:26,746
Hello everyone. My name is Maximskov and I work as a

2
00:00:26,768 --> 00:00:30,674
lead microfrontend engineer at Yan X. Let's start by thinking about

3
00:00:30,792 --> 00:00:34,206
what comes to mind when you hear the word monolith.

4
00:00:34,318 --> 00:00:37,582
Most likely you think of something huge, indivisible,

5
00:00:37,646 --> 00:00:40,914
and heavy. It's totally fine. But then it comes

6
00:00:40,952 --> 00:00:44,934
to software development. It's not exactly something you want

7
00:00:44,972 --> 00:00:48,518
to work with. You probably remember a project with a large

8
00:00:48,604 --> 00:00:52,246
code base that was very difficult to understand and

9
00:00:52,348 --> 00:00:55,786
also challenging to make. Change to the complexity of

10
00:00:55,808 --> 00:00:59,654
such projects tends to increase rapidly as the code base grows.

11
00:00:59,782 --> 00:01:03,242
In other words, these projects don't scale well.

12
00:01:03,376 --> 00:01:06,398
On the other hand, monoliths are often compared to

13
00:01:06,484 --> 00:01:09,914
microfrontends, which are frequently discussed at conferences,

14
00:01:10,042 --> 00:01:13,342
giving the impression that this is the best way to build

15
00:01:13,476 --> 00:01:16,846
large scale applications without turning development process

16
00:01:16,948 --> 00:01:20,474
into a nightmare. In this talk, we'll explore

17
00:01:20,522 --> 00:01:23,986
if it's true or not. We'll also delve into the main issue of

18
00:01:24,008 --> 00:01:27,730
monoliths and how microfrontends can help us to address it.

19
00:01:27,800 --> 00:01:31,154
The term glorious in the title signifies a good

20
00:01:31,192 --> 00:01:35,158
monolith, suggesting that not all monoliths are equally bad

21
00:01:35,244 --> 00:01:38,486
or bad at all. Next, we will delve into the

22
00:01:38,508 --> 00:01:41,906
topic of building an effective and scalable monolith

23
00:01:42,018 --> 00:01:45,942
by the end. The aim to understand then it becomes necessary

24
00:01:46,006 --> 00:01:49,514
to seriously consider adapting micro front end

25
00:01:49,552 --> 00:01:53,434
architecture and determine the extent to which we

26
00:01:53,472 --> 00:01:57,370
can rely on the monolith architecture without experiencing

27
00:01:57,450 --> 00:02:00,686
any development issues. So why did I

28
00:02:00,708 --> 00:02:04,366
decide to make this presentation? Well, it's pretty simple.

29
00:02:04,468 --> 00:02:07,710
I've been in web development for over 13 years,

30
00:02:07,860 --> 00:02:11,454
and during that time I've become proficient in building new

31
00:02:11,492 --> 00:02:15,198
products and maintaining large scale existing code bases.

32
00:02:15,294 --> 00:02:19,394
For the past three years, I've been leading the infrastructure team at

33
00:02:19,432 --> 00:02:22,626
Yandexdirect, which is a major online advertising

34
00:02:22,658 --> 00:02:26,726
platform. One of the challenges they faced was the scalability of

35
00:02:26,748 --> 00:02:30,402
the project. And here's the interesting part, they successfully

36
00:02:30,466 --> 00:02:33,778
solved it without adapting microfrontend architecture.

37
00:02:33,874 --> 00:02:37,882
We still have a monolith, and I want to share my experience and

38
00:02:37,936 --> 00:02:41,770
what we ultimately came to. So let's dive in and

39
00:02:41,840 --> 00:02:45,146
explore the world of monoliths. But before the start,

40
00:02:45,248 --> 00:02:49,246
let me share some numbers about Yandex Direct so you can better

41
00:02:49,348 --> 00:02:53,002
understand the scale at which our monolith successfully

42
00:02:53,066 --> 00:02:56,782
operates. Yandex Direct's code base is over 20 years

43
00:02:56,836 --> 00:03:00,414
old, and during this time, a massive amount of code

44
00:03:00,532 --> 00:03:04,178
has been written. When I joined the project a couple of years ago,

45
00:03:04,264 --> 00:03:07,522
the application had several million slides of

46
00:03:07,576 --> 00:03:11,086
code, and that was just the front end part. At that

47
00:03:11,128 --> 00:03:14,534
time, every developer including myself, kindly felt the

48
00:03:14,572 --> 00:03:18,054
pain working with a large monolith that didn't want

49
00:03:18,092 --> 00:03:21,606
to get any bigger. In other words, we found that the

50
00:03:21,628 --> 00:03:25,034
project architecture doesn't scale well to the size of

51
00:03:25,072 --> 00:03:29,082
our code base. So what the challenges does the team face in such

52
00:03:29,136 --> 00:03:33,482
situation? Usually in such project, several things happen.

53
00:03:33,616 --> 00:03:37,454
First, the project reaches a point where it becomes too

54
00:03:37,492 --> 00:03:41,646
complex for one developer to fully grasp. It becomes challenging to

55
00:03:41,668 --> 00:03:45,322
understand all the code and system functionality.

56
00:03:45,466 --> 00:03:48,830
This complexity makes developers hesitant to make changes

57
00:03:48,900 --> 00:03:51,966
to the code, as even a minor modification

58
00:03:52,078 --> 00:03:55,586
in one part of the system can potentially break important

59
00:03:55,688 --> 00:03:59,086
functionality in another one. Writing new code becomes

60
00:03:59,118 --> 00:04:02,850
difficult too, as it's not always clear where to edit.

61
00:04:02,930 --> 00:04:06,294
Multiple solutions to the same problems may exist as

62
00:04:06,332 --> 00:04:10,114
often, it's easier to write new code instead of understanding

63
00:04:10,162 --> 00:04:14,094
the existing code. Moreover, to solve any task,

64
00:04:14,162 --> 00:04:17,802
developers need to immerse themselves in a vast amount

65
00:04:17,856 --> 00:04:21,402
of code base, which takes a significant amount of time.

66
00:04:21,536 --> 00:04:24,794
As a result, the project becomes difficult to move

67
00:04:24,832 --> 00:04:28,126
forward and the development process slows down,

68
00:04:28,228 --> 00:04:31,886
leading to a decrease in productivity and in product quality

69
00:04:31,988 --> 00:04:35,530
too. The chart illustrates how team productivity

70
00:04:35,610 --> 00:04:39,210
decreases as the code base grows. The main reason for

71
00:04:39,220 --> 00:04:42,882
the decrease in productivity is that the complexity of

72
00:04:42,936 --> 00:04:46,414
development in the project is growing much faster

73
00:04:46,542 --> 00:04:50,162
than the size of the code base. And this happens because

74
00:04:50,296 --> 00:04:53,734
the main contribution to the system complexity is

75
00:04:53,772 --> 00:04:57,970
not complex algorithms or complex user interfaces,

76
00:04:58,130 --> 00:05:01,862
but the high coupling between different parts of the system.

77
00:05:01,996 --> 00:05:05,466
For example, in the worst case, two modules or

78
00:05:05,488 --> 00:05:09,846
functions depend on each other, resulting in two connections or dependencies.

79
00:05:09,958 --> 00:05:13,610
The three modules, the number of connections, can increase to six,

80
00:05:13,760 --> 00:05:17,702
and the four modules it can go up to twelve. This pattern

81
00:05:17,766 --> 00:05:21,502
continues until we end up with a big ball of mud where

82
00:05:21,556 --> 00:05:25,130
the boundaries of any functionality are completely blurred.

83
00:05:25,210 --> 00:05:28,366
And to solve any task, we have to delve into the

84
00:05:28,388 --> 00:05:32,274
entire code base. So we need to address this issue and

85
00:05:32,312 --> 00:05:35,966
aim to reduce the coupling. However, since amanolith

86
00:05:35,998 --> 00:05:39,774
is a physically single code base, there are usually no restrictions

87
00:05:39,822 --> 00:05:43,202
on importing code anywhere, leading to a rapid increase

88
00:05:43,266 --> 00:05:46,918
in the number of interdependencies. To regain control other

89
00:05:47,004 --> 00:05:50,646
system complexity, we must learn how to manage the

90
00:05:50,668 --> 00:05:54,394
coupling in our code base. And here comes micro front end.

91
00:05:54,512 --> 00:05:57,754
You may have already heard a lot about them, but if

92
00:05:57,792 --> 00:06:01,402
not, it's the idea of dividing an application into

93
00:06:01,456 --> 00:06:05,386
several smaller applications, like embedding a

94
00:06:05,408 --> 00:06:09,422
widget, displaying currency exchange rates on a news website.

95
00:06:09,556 --> 00:06:12,990
And there are many implementation options from a technical point of view.

96
00:06:13,060 --> 00:06:16,366
But I won't go into detail about that.

97
00:06:16,468 --> 00:06:19,138
What's important is the concept itself,

98
00:06:19,304 --> 00:06:23,774
where they divide one big application into several smaller applications

99
00:06:23,902 --> 00:06:27,646
that are independent of each other. This separation provides

100
00:06:27,678 --> 00:06:30,398
us with several advantages. Firstly,

101
00:06:30,494 --> 00:06:33,798
since each micro front end is a separate application,

102
00:06:33,964 --> 00:06:37,314
this is our own code base. Often in a separate

103
00:06:37,362 --> 00:06:40,934
repository, we can no longer simply import a function from

104
00:06:40,972 --> 00:06:44,806
random file than we need it. These applications usually communicate

105
00:06:44,838 --> 00:06:48,666
with each other according to specific rules, such as through a

106
00:06:48,688 --> 00:06:51,978
public API, events or something. As a result,

107
00:06:52,064 --> 00:06:56,202
the coupling between these applications will be significantly less than

108
00:06:56,336 --> 00:06:59,198
between different parts of a monolith. Also,

109
00:06:59,284 --> 00:07:02,926
dividing the code into multiple applications, on the one hand,

110
00:07:03,028 --> 00:07:06,574
leads to a lower productivity at the beginning of a new project

111
00:07:06,692 --> 00:07:10,014
as it incurs additional constraints and significant

112
00:07:10,062 --> 00:07:13,262
expenses in preparing more advanced infrastructure.

113
00:07:13,406 --> 00:07:16,914
But on the other hand, as the project evolves, we will

114
00:07:16,952 --> 00:07:20,686
experience fewer scaling problems than we would in a monolith.

115
00:07:20,798 --> 00:07:24,198
Making change to smaller applications is easier, resulting in a

116
00:07:24,204 --> 00:07:28,146
less significant decrease in the team's productivity over time compared

117
00:07:28,178 --> 00:07:31,634
to a monolith. Another advantage of dividing a monolith

118
00:07:31,682 --> 00:07:35,910
into different applications is the ability to distribute responsibility

119
00:07:35,990 --> 00:07:39,078
for different parts of the project among different teams.

120
00:07:39,174 --> 00:07:43,094
These teams will have the freedom to develop their own processes,

121
00:07:43,222 --> 00:07:47,138
choose technologies, define style guides, and determine release

122
00:07:47,174 --> 00:07:50,510
circles. As a result, teams can work at their own

123
00:07:50,580 --> 00:07:53,962
pace, with some applications being released more frequently

124
00:07:54,026 --> 00:07:57,562
than others. And what's even more, if a bug

125
00:07:57,626 --> 00:08:01,742
happens in one application, it won't require rolling back releases

126
00:08:01,806 --> 00:08:04,654
from other teams, which can be quite painful.

127
00:08:04,702 --> 00:08:07,934
Process well, it turns out that microfrontend

128
00:08:07,982 --> 00:08:11,666
architecture offers great advantages, scales better than

129
00:08:11,688 --> 00:08:15,094
manoliths, and there is even a certain bias around this

130
00:08:15,132 --> 00:08:18,194
topic that makes us want to try it in our projects.

131
00:08:18,322 --> 00:08:21,702
But does this mean that microfrontends are a good

132
00:08:21,756 --> 00:08:25,954
fit for every application? I don't think so, because adapting

133
00:08:26,082 --> 00:08:28,858
microfrontends brings not only important benefits,

134
00:08:29,024 --> 00:08:32,298
but also comes at a cost that is important to

135
00:08:32,304 --> 00:08:36,134
be aware of. Firstly, everything becomes more complicated.

136
00:08:36,262 --> 00:08:39,779
To connect all micro front end applications into a

137
00:08:40,279 --> 00:08:43,834
unified application, a complex infrastructure is required.

138
00:08:43,962 --> 00:08:47,486
Bundling becomes more challenging and you need to have a

139
00:08:47,508 --> 00:08:50,706
deep understanding of your bundler capabilities and it

140
00:08:50,728 --> 00:08:54,434
will be necessary to decide how applications communicate with each

141
00:08:54,472 --> 00:08:57,922
other and prevent any conflicts between them on a single

142
00:08:57,976 --> 00:09:02,130
page and if you need server side rendering. The complexity

143
00:09:02,210 --> 00:09:05,574
of the infrastructure increases significantly as

144
00:09:05,612 --> 00:09:08,722
it requires a distributed system of microservices,

145
00:09:08,866 --> 00:09:12,402
which has its own set of challenges. It's also necessary

146
00:09:12,466 --> 00:09:15,942
to think more about backward compatibility in releases.

147
00:09:16,086 --> 00:09:20,646
It's important to always remember and not break contracts between micro

148
00:09:20,678 --> 00:09:24,154
front end applications. It would also be more difficult to

149
00:09:24,192 --> 00:09:28,090
update shared dependencies. Trust me, if you ever tried

150
00:09:28,160 --> 00:09:31,738
to update the version of react on a bunch of micro front ends.

151
00:09:31,834 --> 00:09:35,626
You know, it's not the easiest thing to do, and besides,

152
00:09:35,738 --> 00:09:39,054
it's not always necessary to split application among

153
00:09:39,102 --> 00:09:42,930
multiple teams. Maybe you have a relatively small

154
00:09:43,000 --> 00:09:46,434
product that is being worked on by just one

155
00:09:46,472 --> 00:09:49,874
team, or maybe you want to have consistent processes and

156
00:09:49,912 --> 00:09:54,054
technologies across all teams so that you can easily transfer

157
00:09:54,172 --> 00:09:58,134
engineers between teams and focus on critical tasks at

158
00:09:58,172 --> 00:10:02,278
the time. And what should we do if the monolith doesn't scale well

159
00:10:02,364 --> 00:10:05,966
and the microfrontends are complex and often redundant?

160
00:10:06,098 --> 00:10:09,306
Well, there is a solution. We can try to take the

161
00:10:09,328 --> 00:10:13,398
best of both worlds. By combining the advantages of monoliths

162
00:10:13,414 --> 00:10:16,826
and micro front ends, we can create an architecture that can

163
00:10:16,848 --> 00:10:20,618
handle the growth of the code base without incurring significant

164
00:10:20,714 --> 00:10:23,806
infrastructure costs, especially at the beginning of the

165
00:10:23,828 --> 00:10:27,178
new project. In this case, productivity at the beginning

166
00:10:27,274 --> 00:10:31,598
might be slightly lower than in the traditional monolith due

167
00:10:31,614 --> 00:10:35,198
to the need for architecture and development tools setup.

168
00:10:35,294 --> 00:10:38,446
But as the project evolves, productivity won't

169
00:10:38,478 --> 00:10:42,206
decrease as significantly as with traditional monolith.

170
00:10:42,318 --> 00:10:45,642
It will be more similar to that of microfrontends.

171
00:10:45,726 --> 00:10:49,970
To achieve this goal, we can keep all the code in one repository,

172
00:10:50,130 --> 00:10:53,914
which allows us to easily reuse our code, have one

173
00:10:53,952 --> 00:10:57,446
release, and not worry much about backward compatibility.

174
00:10:57,638 --> 00:11:02,070
And it also helps us avoid complicating the development,

175
00:11:02,230 --> 00:11:05,660
deployment, build or maintenance of our application.

176
00:11:06,030 --> 00:11:09,646
At the same time, they need to preserve the advantages of

177
00:11:09,668 --> 00:11:14,074
micro front ends, which enable us to control coupling and system complexity.

178
00:11:14,202 --> 00:11:18,382
In other words, we need to find a way to divide the code

179
00:11:18,516 --> 00:11:22,094
into smaller and isolated parts. And if

180
00:11:22,132 --> 00:11:25,794
to think about it, what prevents us from doing this in a

181
00:11:25,832 --> 00:11:29,380
regular monolith? The only thing that actually stops us

182
00:11:29,750 --> 00:11:33,714
is the fact that in the code base of regular monolith,

183
00:11:33,762 --> 00:11:37,522
they have complete freedom of action. And glorious

184
00:11:37,666 --> 00:11:41,062
monolith differs from a regular one in that

185
00:11:41,196 --> 00:11:44,346
it has a well thought out architecture and

186
00:11:44,448 --> 00:11:48,502
complaints that this architecture is controlled by automated tools

187
00:11:48,566 --> 00:11:52,106
such as linters. So it's important to understand

188
00:11:52,288 --> 00:11:56,326
what architecture exactly is. Software architecture is

189
00:11:56,368 --> 00:12:00,122
mostly about rules and constraints that lead to the creation

190
00:12:00,186 --> 00:12:02,720
of flexible and scalable system.

191
00:12:03,570 --> 00:12:06,846
So let's talk about the rules and constraints that are

192
00:12:06,868 --> 00:12:10,030
essential for building a good monolith. It's worth starting

193
00:12:10,100 --> 00:12:14,370
with the introduction of the module concept. The main idea is that

194
00:12:14,440 --> 00:12:18,766
they need to divide our code base into separate and loosely coupled

195
00:12:18,798 --> 00:12:22,242
parts, which will call modules. The clear boundaries

196
00:12:22,306 --> 00:12:26,022
and weak dependencies between these modules are exactly what

197
00:12:26,076 --> 00:12:28,840
allow us to create scalable system.

198
00:12:29,450 --> 00:12:33,634
In such a system, each module will be responsible for a specific

199
00:12:33,772 --> 00:12:37,146
product or technical functionality, depending on the

200
00:12:37,168 --> 00:12:40,822
application. Examples of modules can include a cash balance

201
00:12:40,886 --> 00:12:44,902
module, data filtering module, maybe something bigger

202
00:12:44,966 --> 00:12:48,670
like a sidebar of an application, or even the entire page.

203
00:12:48,820 --> 00:12:52,334
Typically, modules responsible for a large amount of

204
00:12:52,372 --> 00:12:56,058
functionality are assembled from smaller modules.

205
00:12:56,154 --> 00:12:59,614
Externally. This looks very similar to a microfrontend

206
00:12:59,662 --> 00:13:03,346
architecture, but we are still within the same code base

207
00:13:03,448 --> 00:13:07,742
and do not incur the infrastructure tax for microfrontend.

208
00:13:07,886 --> 00:13:11,654
But unfortunately it won't be sufficient to just

209
00:13:11,692 --> 00:13:15,382
distribute the entire code base into different directories and

210
00:13:15,436 --> 00:13:18,642
consider it as modules. To create a good monolith,

211
00:13:18,706 --> 00:13:22,806
modules need to meet certain requirements. These requirements are

212
00:13:22,828 --> 00:13:26,742
all about how modules structured, how they are isolated

213
00:13:26,806 --> 00:13:29,914
from each other, and how they communicate to each other.

214
00:13:30,032 --> 00:13:33,526
Let's start with how things are structured inside modules.

215
00:13:33,638 --> 00:13:37,114
Inside a module, there can be everything that exists in a regular

216
00:13:37,162 --> 00:13:40,602
monolith application, for example, UI components,

217
00:13:40,746 --> 00:13:43,614
styles, the business logic of an application,

218
00:13:43,812 --> 00:13:47,818
and even technical things like libraries and frameworks.

219
00:13:47,914 --> 00:13:51,026
In general, all the code that exists in an application should

220
00:13:51,048 --> 00:13:54,270
be contained within one of the modules. Additionally,

221
00:13:54,350 --> 00:13:57,954
it's important that each module is implemented in a similar way,

222
00:13:58,072 --> 00:14:02,162
otherwise the team will have difficulty switching between the development

223
00:14:02,226 --> 00:14:05,846
of different modules. It's a good idea to limit both set of

224
00:14:05,868 --> 00:14:09,138
technologies and the high level directory structure.

225
00:14:09,234 --> 00:14:12,742
This will allow logically separating the code of each

226
00:14:12,796 --> 00:14:16,586
module into several segments, each with its own

227
00:14:16,688 --> 00:14:20,554
area of responsibility. For example, you can have four segments like

228
00:14:20,592 --> 00:14:24,998
on the slide, which I took from the feature slice design methodology.

229
00:14:25,174 --> 00:14:28,766
However, depending on the project needs, you can come up with your

230
00:14:28,788 --> 00:14:32,474
own set of segments, like you can add a separate

231
00:14:32,522 --> 00:14:36,442
segment for server side code, which can contain

232
00:14:36,506 --> 00:14:40,610
API endpoints, database connections and something. The key

233
00:14:40,680 --> 00:14:44,722
is that the entire team clearly understands where to put new

234
00:14:44,776 --> 00:14:47,954
code and where to find existing code.

235
00:14:48,072 --> 00:14:51,906
Unfortunately, it might be difficult to perfectly synchronize everyone's

236
00:14:51,938 --> 00:14:55,894
understanding of what each segment is responsible for.

237
00:14:56,012 --> 00:14:59,154
Each engineer might have a slightly different interpretation.

238
00:14:59,282 --> 00:15:02,982
For instance, let's imagine, can a state manager inside

239
00:15:03,036 --> 00:15:07,450
the model segment roll the user a pop up notification about

240
00:15:07,520 --> 00:15:10,970
the successful completion of a data saving operation?

241
00:15:11,470 --> 00:15:15,082
Well, someone might say yes, why not? While someone

242
00:15:15,136 --> 00:15:18,734
else might say no. That's the responsibility of the

243
00:15:18,772 --> 00:15:22,010
UI segment. So we can resolve this ambiguity

244
00:15:22,090 --> 00:15:25,930
by introducing import restrictions between different segments,

245
00:15:26,090 --> 00:15:29,762
like in the layers of the clean architecture. In particular,

246
00:15:29,896 --> 00:15:33,314
what we can do is to put all the segments in

247
00:15:33,352 --> 00:15:37,010
order and prevent lower segments from depending on

248
00:15:37,080 --> 00:15:41,042
higher segments. For example, the UI segment can

249
00:15:41,096 --> 00:15:45,270
use both model and API segments as well as utility code.

250
00:15:45,420 --> 00:15:49,394
On the other hand, the model segments can only use the API

251
00:15:49,442 --> 00:15:52,674
segment and utility code, but it cannot

252
00:15:52,722 --> 00:15:56,374
use anything from the UI. Alright, these simple rules

253
00:15:56,422 --> 00:15:59,578
highlight the code's responsibility and help us

254
00:15:59,664 --> 00:16:03,094
to put it in the right place in the module. This makes decision

255
00:16:03,142 --> 00:16:06,666
making much easier and also comes with additional benefits.

256
00:16:06,848 --> 00:16:10,526
First, all the related code will be in one place within the

257
00:16:10,548 --> 00:16:14,026
module. That makes it easier to understand what the module

258
00:16:14,058 --> 00:16:18,126
is supposed to do and how it works. Secondly, it prevents the

259
00:16:18,148 --> 00:16:22,558
mixing of business logic and UI, which leads to more flexible,

260
00:16:22,654 --> 00:16:26,130
composable and easy to understand code. All of this

261
00:16:26,200 --> 00:16:30,414
make it way simpler to work with a large code base and switch

262
00:16:30,462 --> 00:16:33,586
between different modules with ease during development.

263
00:16:33,698 --> 00:16:38,194
To sum up, the strict structure of modules lets us effectively

264
00:16:38,242 --> 00:16:41,158
solve any tasks in any part of the system,

265
00:16:41,324 --> 00:16:44,374
even in modules we are not familiar with.

266
00:16:44,492 --> 00:16:47,786
The next step is to isolate a module from the rest of

267
00:16:47,808 --> 00:16:51,722
the system and other modules. This is a key part

268
00:16:51,776 --> 00:16:55,194
of the rules that helps us to achieve the two main

269
00:16:55,232 --> 00:16:58,494
goals. First, it makes the module loosely coupled from

270
00:16:58,532 --> 00:17:02,106
the other modules. They achieve this by allowing other modules

271
00:17:02,138 --> 00:17:05,722
to only use the functionality that the module developer

272
00:17:05,786 --> 00:17:08,666
has specifically prepared for this purpose.

273
00:17:08,778 --> 00:17:12,562
And since other modules won't have access to all the inner work

274
00:17:12,616 --> 00:17:16,094
ends of the module, the number of dependencies between modules

275
00:17:16,142 --> 00:17:19,938
won't grow as quickly as in regular monolith. At the same time,

276
00:17:20,024 --> 00:17:23,858
the dependencies themselves will be more obvious and controlled.

277
00:17:23,954 --> 00:17:27,766
Which brings us to the second goal, the ability to make changes

278
00:17:27,868 --> 00:17:31,554
to the module safely. The developer can confidently

279
00:17:31,602 --> 00:17:35,338
make changes to one part of the system without worrying about

280
00:17:35,424 --> 00:17:38,954
unexpected bugs in other parts of the system. And to

281
00:17:38,992 --> 00:17:43,002
gain that confidence, modules need to be isolated at every

282
00:17:43,056 --> 00:17:46,838
level from code to styles and data. So when

283
00:17:46,864 --> 00:17:50,542
it comes to code isolation, it's basically about two things,

284
00:17:50,676 --> 00:17:54,554
making sure there aren't any global side effects in your module

285
00:17:54,682 --> 00:17:58,014
and controlling what functionality is exposed to other

286
00:17:58,052 --> 00:18:01,454
modules. What do I mean by global side effects?

287
00:18:01,582 --> 00:18:05,154
Basically, it's anything that can implicitly change the

288
00:18:05,192 --> 00:18:08,754
behavior of other modules. For example, if our

289
00:18:08,792 --> 00:18:12,594
module patches some global objects, loads polyfills,

290
00:18:12,722 --> 00:18:16,722
it can cause other modules to rely on this behavior.

291
00:18:16,866 --> 00:18:20,950
And if loading order of modules suddenly change

292
00:18:21,100 --> 00:18:24,678
or we decide to remove some legacy modules,

293
00:18:24,774 --> 00:18:28,806
these dependent modules will stop working correctly. That's why global

294
00:18:28,838 --> 00:18:32,042
side effects are highly undesirable and should

295
00:18:32,096 --> 00:18:35,562
be avoided. And then I say controlling what

296
00:18:35,616 --> 00:18:39,230
functionality is exposed. What I really mean

297
00:18:39,300 --> 00:18:42,894
is a set of rules which give us

298
00:18:42,932 --> 00:18:46,362
a way to have one entry point for a module

299
00:18:46,506 --> 00:18:50,306
and treat it like a contract for how the

300
00:18:50,328 --> 00:18:53,218
module interacts with other modules in the system.

301
00:18:53,384 --> 00:18:56,546
And we call it the public API of the

302
00:18:56,568 --> 00:19:00,674
module. So the first thing we need to do to implement such

303
00:19:00,792 --> 00:19:04,374
public API is to create an entry point in each

304
00:19:04,412 --> 00:19:07,458
module, like an index file at the root of your module.

305
00:19:07,554 --> 00:19:11,254
In this file, we'll define everything that is available for

306
00:19:11,292 --> 00:19:15,030
use in other modules. Then we can set up a linter

307
00:19:15,110 --> 00:19:19,174
that will prevent other modules from importing anything except

308
00:19:19,222 --> 00:19:23,062
that index file. For this we can use Eslint

309
00:19:23,126 --> 00:19:27,126
and ready made plugins such as Eslint plugin boundaries.

310
00:19:27,238 --> 00:19:30,814
And how can we describe the public API of a module inside that

311
00:19:30,852 --> 00:19:34,666
index file? There are few options here, mostly depending

312
00:19:34,698 --> 00:19:38,746
on the framework you use in your application and your personal preferences.

313
00:19:38,938 --> 00:19:42,998
You can simply use ES modules and re export the part of the module's

314
00:19:43,034 --> 00:19:46,654
functionality. Alternatively, you can use dependency injection

315
00:19:46,702 --> 00:19:50,830
principle, especially if you are using angular or SJS

316
00:19:50,910 --> 00:19:54,882
frameworks. Or you can use an event driven architecture

317
00:19:54,946 --> 00:19:59,026
and connect all the modules by communicating with events

318
00:19:59,138 --> 00:20:02,934
sent to some sort of event bus. Each of these options has

319
00:20:02,972 --> 00:20:06,138
its advantages and disadvantages. For example,

320
00:20:06,304 --> 00:20:09,770
DI makes dependencies between modules less strong,

321
00:20:09,920 --> 00:20:13,578
but it does complicate the infrastructure a bit.

322
00:20:13,744 --> 00:20:17,014
On the other hand, the event driven architecture decouples

323
00:20:17,062 --> 00:20:20,926
modules even more, but you need to be careful with the

324
00:20:20,948 --> 00:20:24,506
model loading sequence to not miss any important events.

325
00:20:24,618 --> 00:20:28,574
Let's say we want to use ES modules and simply reexport some

326
00:20:28,612 --> 00:20:32,674
of the modules functionality, as shown on the slide. In this example,

327
00:20:32,792 --> 00:20:35,806
we are using the react Redux stack,

328
00:20:35,918 --> 00:20:38,878
so we mainly export react components,

329
00:20:38,974 --> 00:20:42,630
redux selectors and actions using ES

330
00:20:42,700 --> 00:20:46,578
modules in this case allow us to save on infrastructure,

331
00:20:46,674 --> 00:20:49,842
since no additional development is required

332
00:20:49,986 --> 00:20:53,090
for GI or event based architectures,

333
00:20:53,250 --> 00:20:56,842
and it works well with code analyzers out the box.

334
00:20:56,976 --> 00:21:00,762
For example, we can easily build a dependency, graph the system

335
00:21:00,896 --> 00:21:04,650
and use it for selective test execution. For instance.

336
00:21:04,990 --> 00:21:08,922
Yes, modules can also be loaded both statically and dynamically

337
00:21:09,066 --> 00:21:12,782
to implement code splitting technique, and this is available

338
00:21:12,916 --> 00:21:16,590
out of the box too. And sometimes we can still use event

339
00:21:16,660 --> 00:21:20,578
emitters exported from a module entry point to make

340
00:21:20,664 --> 00:21:23,906
the dependency between two modules as weak as possible,

341
00:21:24,088 --> 00:21:27,314
but only in that cases when it's not

342
00:21:27,352 --> 00:21:30,974
crucial to handle all the events and it's safe to lose

343
00:21:31,022 --> 00:21:34,486
some of them. One more thing to keep in mind is to control the

344
00:21:34,508 --> 00:21:38,646
size of public API. It's better to keep it as small as possible

345
00:21:38,828 --> 00:21:42,402
because larger public API increases the chances of additional

346
00:21:42,466 --> 00:21:46,042
dependencies between modules, which in turn makes

347
00:21:46,176 --> 00:21:50,294
the system more complex. In general, there are few factors that contribute

348
00:21:50,342 --> 00:21:53,574
to the size of a public API. This includes,

349
00:21:53,622 --> 00:21:57,390
of course, the number of exports from the entry point and

350
00:21:57,460 --> 00:22:01,550
the number of arguments for each export. For instance,

351
00:22:01,890 --> 00:22:05,370
exporting a component with a high number of arguments

352
00:22:05,450 --> 00:22:09,266
makes it more difficult to use it and also more difficult to

353
00:22:09,288 --> 00:22:12,818
understand its functionality. It's also worth paying

354
00:22:12,904 --> 00:22:16,702
attention to the complexity of the data structures that a module

355
00:22:16,766 --> 00:22:20,558
receives or returns. The more unnecessary data is passed

356
00:22:20,574 --> 00:22:24,722
between modules, the harder it is to make change to the internal implementation

357
00:22:24,786 --> 00:22:28,534
of a module. And again, it creates more opportunities for

358
00:22:28,572 --> 00:22:31,826
additional dependencies in the system, so it's

359
00:22:31,858 --> 00:22:35,750
better to try to keep a public API as small as possible.

360
00:22:35,900 --> 00:22:39,626
Alright, in most cases this rule should be enough to

361
00:22:39,648 --> 00:22:43,542
isolate code between modules, but the main thing is to enforce

362
00:22:43,606 --> 00:22:47,674
these restrictions with automated checks and linters, because it's

363
00:22:47,722 --> 00:22:51,114
almost impossible to remember all the rules and perfectly

364
00:22:51,162 --> 00:22:54,766
synchronize them across the team. So since we are

365
00:22:54,788 --> 00:22:58,154
talking about front end applications, we also have style sheets,

366
00:22:58,202 --> 00:23:01,826
right? It's also important to make sure our styles are

367
00:23:01,928 --> 00:23:05,586
also isolated, because style sheets has

368
00:23:05,608 --> 00:23:09,554
a global scope by default and can affect everything on the page.

369
00:23:09,672 --> 00:23:13,590
For instance, two modules might have the same class name,

370
00:23:13,740 --> 00:23:17,398
or one of the modules might add some sort of

371
00:23:17,484 --> 00:23:21,062
reset css and mess up the layout of all other

372
00:23:21,116 --> 00:23:24,626
modules in the system. So in order to avoid

373
00:23:24,658 --> 00:23:28,202
any unexpected styling issues, we need to make sure we keep

374
00:23:28,256 --> 00:23:32,154
our styles isolated from each other. There are a bunch of

375
00:23:32,192 --> 00:23:35,546
ways to make it happen, and we've only shown a few on the

376
00:23:35,568 --> 00:23:39,342
slide. And each of these options has its own

377
00:23:39,396 --> 00:23:42,862
advantages and disadvantages, and the one you choose

378
00:23:42,916 --> 00:23:47,130
will mostly depend on the project's requirements and your personal preferences.

379
00:23:47,290 --> 00:23:50,802
But the important thing is all of them

380
00:23:50,936 --> 00:23:54,514
work pretty well for building a good monolith, as long

381
00:23:54,552 --> 00:23:58,466
as we'll stick to some additional agreements. For example,

382
00:23:58,648 --> 00:24:01,890
if we go with CSS modules, they work really well

383
00:24:01,960 --> 00:24:05,430
for isolating styles. But as long as we only use

384
00:24:05,500 --> 00:24:08,530
classes and pivotal classes to select elements,

385
00:24:08,690 --> 00:24:12,194
using other selectors could easily cause styles to leak onto

386
00:24:12,242 --> 00:24:15,914
elements of other modules. Also, it's better to not

387
00:24:15,952 --> 00:24:19,062
import CSS files between different modules.

388
00:24:19,206 --> 00:24:23,046
Instead, if we need to override some styles in another module,

389
00:24:23,158 --> 00:24:26,762
we can pass, for example, class name as a component

390
00:24:26,826 --> 00:24:29,946
property and add it to the necessary elements.

391
00:24:30,138 --> 00:24:33,946
But it's even better to avoid style overrides

392
00:24:33,978 --> 00:24:37,546
at all, as it introduces dependency on the module

393
00:24:37,578 --> 00:24:40,942
loading order and selector specificity.

394
00:24:41,086 --> 00:24:45,230
Also, it's important to be careful with CSS custom properties,

395
00:24:45,390 --> 00:24:48,654
since custom properties have a global scope

396
00:24:48,702 --> 00:24:52,386
as well and can easily conflict between different modules.

397
00:24:52,498 --> 00:24:55,650
So it's better to avoid creating new custom properties

398
00:24:55,730 --> 00:24:59,554
inside module styles to prevent any potential

399
00:24:59,682 --> 00:25:03,046
visual bugs. And finally, we can control

400
00:25:03,148 --> 00:25:06,758
all of these rules with the help of the style in plinter.

401
00:25:06,854 --> 00:25:10,534
This overall isolation allows us to avoid any unexpected

402
00:25:10,582 --> 00:25:14,410
visual breaks in an application and safely make change to

403
00:25:14,480 --> 00:25:18,538
module styles. So when it comes to style

404
00:25:18,554 --> 00:25:21,598
sheets, the rules and constraints are quite simple.

405
00:25:21,764 --> 00:25:25,898
But when it comes to data isolation, things can get a bit trickier.

406
00:25:25,994 --> 00:25:29,326
In any system, code and data are highly coupled because

407
00:25:29,428 --> 00:25:33,314
data basically the main reason why we build almost every application,

408
00:25:33,432 --> 00:25:36,914
right? So if the module doesn't control access to its

409
00:25:36,952 --> 00:25:39,586
data, we will run into a bunch of problems.

410
00:25:39,768 --> 00:25:42,930
First, it will be really tough to make change to the module

411
00:25:43,010 --> 00:25:46,534
because we could easily break other modules in the system,

412
00:25:46,732 --> 00:25:49,874
then changing internal data structures of the module.

413
00:25:50,002 --> 00:25:53,454
Secondly, it's not really obvious dependency, then a module

414
00:25:53,522 --> 00:25:56,874
depends on data from another module. It's more

415
00:25:56,912 --> 00:26:00,570
like a global side effect, and change to the data

416
00:26:00,640 --> 00:26:04,374
can implicitly change the behavior of other modules.

417
00:26:04,502 --> 00:26:07,878
On top of that, then we are developing a new module.

418
00:26:07,974 --> 00:26:11,466
It will be challenging to use data from existing modules

419
00:26:11,578 --> 00:26:15,294
because we would have to dig through the entire code base of the system

420
00:26:15,412 --> 00:26:18,734
to figure out what data is available to use.

421
00:26:18,852 --> 00:26:22,654
And to give you some examples, these two cases on the slide

422
00:26:22,702 --> 00:26:26,126
are both incorrect. In the first case, we have one global

423
00:26:26,158 --> 00:26:29,954
storage with all the data, allowing every module to have full

424
00:26:29,992 --> 00:26:33,182
access to the data of the system. In the second case,

425
00:26:33,256 --> 00:26:36,630
the data storage is inside each module, which is correct.

426
00:26:36,780 --> 00:26:40,006
But the public API of the modules isn't strict enough,

427
00:26:40,108 --> 00:26:43,746
so other modules have full access to the data storage.

428
00:26:43,858 --> 00:26:47,660
And that's a problem. And to avoid these kind of problems,

429
00:26:48,110 --> 00:26:52,150
we just need to follow a few simple rules. First, each module

430
00:26:52,230 --> 00:26:56,038
should have its own data storage, and we don't want

431
00:26:56,224 --> 00:26:59,934
one single global storage for every module. And if one

432
00:26:59,972 --> 00:27:03,290
module needs some data from another module,

433
00:27:03,450 --> 00:27:07,194
it should only obtain it through a public API.

434
00:27:07,322 --> 00:27:10,914
The CQRS pattern is perfect for creating this kind of

435
00:27:10,952 --> 00:27:14,894
API. It lets us provide some separate

436
00:27:14,942 --> 00:27:18,754
operations for reading and mutating the data without

437
00:27:18,872 --> 00:27:21,618
exposing the entire storage. Also,

438
00:27:21,704 --> 00:27:25,794
when it comes to building user interfaces, it's important to respond

439
00:27:25,842 --> 00:27:29,254
quickly to data changes. So the public API should

440
00:27:29,292 --> 00:27:32,514
let us to subscribe to this change, not just receive

441
00:27:32,562 --> 00:27:36,682
the data once. Another thing to consider is protecting our data

442
00:27:36,736 --> 00:27:39,702
from accidental or intentional mutations.

443
00:27:39,846 --> 00:27:43,094
We can do this by simply exporting a readonly

444
00:27:43,142 --> 00:27:45,942
version of the data in the public API.

445
00:27:46,086 --> 00:27:50,174
In typescript based projects we can simply use the only type

446
00:27:50,212 --> 00:27:54,046
for this, or we can freeze the objects using object

447
00:27:54,148 --> 00:27:58,218
freeze, but it will add some runtime overhead.

448
00:27:58,314 --> 00:28:01,950
It's worth mentioning that all these rules and restrictions

449
00:28:02,030 --> 00:28:05,630
can be applied with almost any state management library,

450
00:28:05,710 --> 00:28:08,946
no matter the framework. The important thing is

451
00:28:09,128 --> 00:28:12,610
controlling which data is accessible for other modules

452
00:28:12,690 --> 00:28:16,102
and limiting how the data can be modified. Alright,

453
00:28:16,236 --> 00:28:19,986
so now we've got these well isolated modules,

454
00:28:20,098 --> 00:28:23,782
which means we can safely modify the code within them and

455
00:28:23,836 --> 00:28:27,014
control the coupling using the public API.

456
00:28:27,142 --> 00:28:30,826
The next thing we need to do is to introduce a

457
00:28:30,848 --> 00:28:33,660
runtime for these modules. But what is that?

458
00:28:34,350 --> 00:28:37,694
When they are creating a new module, it's crucial to understand

459
00:28:37,812 --> 00:28:41,710
how it will fit into the application. For example,

460
00:28:41,780 --> 00:28:45,134
we need to know what features of a bundler are available,

461
00:28:45,332 --> 00:28:48,734
what environment variables we can use, how to

462
00:28:48,772 --> 00:28:52,290
import images, styles and so on. It's also important

463
00:28:52,360 --> 00:28:56,238
to know which version of browsers and node js

464
00:28:56,334 --> 00:29:00,014
the code will run on, and also which library

465
00:29:00,062 --> 00:29:04,002
to use, for example, to provide data access in the public API.

466
00:29:04,146 --> 00:29:07,654
So we need some common rules and libraries for

467
00:29:07,692 --> 00:29:11,334
all the modules to make module development easier. And for

468
00:29:11,372 --> 00:29:15,926
this reason we introduce this thing called runtime for modules.

469
00:29:16,038 --> 00:29:19,418
For example, this is runtime from Yandex Direct.

470
00:29:19,584 --> 00:29:23,034
It consists of versions of the most important libraries like

471
00:29:23,072 --> 00:29:26,650
typescript, react and redux. It's important to share

472
00:29:26,720 --> 00:29:30,414
these kind of libraries across every module because they have

473
00:29:30,452 --> 00:29:33,914
a huge impact on what we can do in the public API.

474
00:29:34,042 --> 00:29:37,402
In fact, communication between modules heavily

475
00:29:37,466 --> 00:29:41,170
relies on these libraries. There are also some another

476
00:29:41,240 --> 00:29:44,782
libraries that don't affect the public API,

477
00:29:44,926 --> 00:29:48,302
but it's handy to have them as a part of runtime,

478
00:29:48,446 --> 00:29:51,342
for example, HTTP client router, library,

479
00:29:51,406 --> 00:29:55,314
components library, and so on. All of these libraries

480
00:29:55,442 --> 00:29:59,014
help us with common development tasks when we are working with

481
00:29:59,052 --> 00:30:02,198
modules. Although it's possible to remove almost everything

482
00:30:02,284 --> 00:30:06,326
from this list to create highly minimal runtime,

483
00:30:06,518 --> 00:30:09,946
there will be a downsides of doing so then designing a

484
00:30:09,968 --> 00:30:13,258
runtime for modules. It's important to find the balance between

485
00:30:13,344 --> 00:30:16,410
the size of a runtime and the convenience of

486
00:30:16,480 --> 00:30:19,534
developing modules. Making runtime bigger will

487
00:30:19,572 --> 00:30:23,134
make it more difficult to maintain it. In fact, making change

488
00:30:23,172 --> 00:30:26,410
to runtime is always risky because it affects

489
00:30:26,490 --> 00:30:30,394
all the modules at once. On the other hand, making the runtime

490
00:30:30,442 --> 00:30:33,950
smaller will make model development more challenging.

491
00:30:34,110 --> 00:30:37,954
There might be a lack of functionality requiring us to

492
00:30:37,992 --> 00:30:41,682
repeatedly develop custom solutions for each module.

493
00:30:41,826 --> 00:30:45,858
Let's take react as an example. If we decide to include react

494
00:30:45,954 --> 00:30:50,150
in the runtime, we can export components from module's public

495
00:30:50,220 --> 00:30:53,762
API, and that can be easily integrated between

496
00:30:53,836 --> 00:30:57,334
modules. But if we decide not to include

497
00:30:57,382 --> 00:31:01,094
react in the runtime, on the one hand each module

498
00:31:01,142 --> 00:31:05,238
can use a different framework, but on the other hand connecting

499
00:31:05,334 --> 00:31:09,274
multiple modules will be more difficult. So now we have runtime

500
00:31:09,322 --> 00:31:12,906
for modules, which makes module development much easier.

501
00:31:13,018 --> 00:31:16,222
But we still need to figure out how to organize our code

502
00:31:16,276 --> 00:31:19,838
base into multiple modules. Like when

503
00:31:19,924 --> 00:31:23,374
should we create a new module? How do we locate existing

504
00:31:23,422 --> 00:31:27,106
code within modules. Those are the kind of questions

505
00:31:27,208 --> 00:31:30,954
we need to address. Well, there is no one size fits all solution

506
00:31:31,022 --> 00:31:35,122
here, but luckily the problem has been extensively

507
00:31:35,186 --> 00:31:38,982
researched and there are plenty of methodologies like

508
00:31:39,116 --> 00:31:42,594
domain driven design, clean architecture, feature slice

509
00:31:42,642 --> 00:31:46,154
design and others. All these methodologies suggest some

510
00:31:46,192 --> 00:31:49,930
common rules and for breaking code into modules.

511
00:31:50,350 --> 00:31:54,358
First and foremost, each module should have just one responsibility

512
00:31:54,534 --> 00:31:57,786
and most of the time it's connected to the product domain,

513
00:31:57,898 --> 00:32:02,282
meaning the module is responsible for a certain product functionality.

514
00:32:02,426 --> 00:32:05,786
For example, it could be a module for handling payments,

515
00:32:05,898 --> 00:32:09,854
user authentication or module for editing articles.

516
00:32:09,982 --> 00:32:13,202
Secondly, each module should have high cohesion inside

517
00:32:13,336 --> 00:32:16,546
and low coupling with other modules. High cohesion is

518
00:32:16,568 --> 00:32:20,558
a good sign that we have properly defined the module's responsibility

519
00:32:20,734 --> 00:32:24,414
and that the module contains all the related functionality.

520
00:32:24,542 --> 00:32:28,326
High cohesion also makes it easier to locate the necessary code and

521
00:32:28,348 --> 00:32:32,054
dive into the business logic of a specific part of the application.

522
00:32:32,252 --> 00:32:35,882
It also means that the module will have fewer reasons to

523
00:32:35,936 --> 00:32:39,706
interact with other modules, which greatly reduce the

524
00:32:39,728 --> 00:32:43,750
coupling and the overall complexity of the system. And besides,

525
00:32:43,830 --> 00:32:47,642
each methodology suggests dividing all modules into several

526
00:32:47,706 --> 00:32:51,166
meaningful groups and implementing strict rules on how these

527
00:32:51,188 --> 00:32:54,634
groups can depend on each other. These limitations

528
00:32:54,762 --> 00:32:58,634
help achieve a predictable system breakdown and facilitate

529
00:32:58,682 --> 00:33:01,806
faster discovery of existing code. Moreover,

530
00:33:01,918 --> 00:33:05,842
it simplifies the decision making process on there to place new code

531
00:33:05,896 --> 00:33:08,500
by reducing the number of options available.

532
00:33:08,950 --> 00:33:12,706
And if you don't want to create your own rules and constraints

533
00:33:12,738 --> 00:33:16,114
for modules layout, you can simply choose one of the premade

534
00:33:16,162 --> 00:33:20,134
options like a trendy feature slice design methodology this

535
00:33:20,172 --> 00:33:24,306
methodology basically outlines an architecture that's

536
00:33:24,338 --> 00:33:28,362
pretty similar to a modular monolith when it comes to dividing the code

537
00:33:28,416 --> 00:33:32,026
into modules. The main idea of the methodology is to

538
00:33:32,048 --> 00:33:35,930
split them into six layers. Each layer has a different

539
00:33:36,000 --> 00:33:39,950
level of understanding about the product domain and a different level

540
00:33:40,020 --> 00:33:43,598
of impact on the system. You can find more information in

541
00:33:43,604 --> 00:33:47,482
the official documentation on the website, which is really useful.

542
00:33:47,626 --> 00:33:51,806
But what is important now is that there are two main rules

543
00:33:51,838 --> 00:33:55,794
to follow. First, the layers are strictly ordered and

544
00:33:55,832 --> 00:33:59,566
imports between layers are unidirectional from the app layer

545
00:33:59,598 --> 00:34:03,426
to shared layer. For example, a module in the widgets

546
00:34:03,458 --> 00:34:06,242
layer can use modules from the features,

547
00:34:06,306 --> 00:34:09,782
entities and shared layers, but cannot use

548
00:34:09,836 --> 00:34:14,146
pages. And second rule is the modules

549
00:34:14,178 --> 00:34:16,922
on the same layer cannot import each other.

550
00:34:17,056 --> 00:34:21,066
For example, two modules in the features layer are aware of each

551
00:34:21,088 --> 00:34:24,154
other and cannot import anything from each other. These two

552
00:34:24,192 --> 00:34:27,562
rules require careful consideration than dividing code

553
00:34:27,616 --> 00:34:31,474
into modules, but they lead to a predictable decomposition

554
00:34:31,542 --> 00:34:35,706
of the system, which in turn simplifies navigation and understanding

555
00:34:35,738 --> 00:34:39,134
of a large code base. This methodology has been used

556
00:34:39,172 --> 00:34:42,626
in Yandex direct for over two years and has proven to be

557
00:34:42,648 --> 00:34:46,226
effective. The only drawback I can mention is that there is

558
00:34:46,248 --> 00:34:49,890
a quite high learning curve. It will be necessary to ensure that

559
00:34:49,960 --> 00:34:53,854
the team has a synchronized understanding of the different layers

560
00:34:53,982 --> 00:34:57,426
and ideally provide documentation with examples

561
00:34:57,458 --> 00:35:01,014
for each specific application. So this was the key

562
00:35:01,052 --> 00:35:04,922
principles for building a scalable monoliths. It's time to draw some

563
00:35:04,976 --> 00:35:08,714
conclusions. First, a good monolith is built on three key

564
00:35:08,752 --> 00:35:12,422
principles. That is, highly isolated modules,

565
00:35:12,566 --> 00:35:16,118
runtime for convenient module development, and rules for

566
00:35:16,144 --> 00:35:19,962
predictable decomposition of the system into modules. Secondly,

567
00:35:20,026 --> 00:35:23,342
a good monolith is scalable, maintainable and

568
00:35:23,396 --> 00:35:27,322
adaptable to future change. It does not become a bottleneck

569
00:35:27,386 --> 00:35:31,146
in product development. That is because isolated modules

570
00:35:31,178 --> 00:35:35,058
and lau coupling between them allow us to work with a small piece of

571
00:35:35,064 --> 00:35:38,974
the code base at a time which can be quickly read and understood.

572
00:35:39,102 --> 00:35:43,014
It also makes possible to safely make changes to modules and

573
00:35:43,052 --> 00:35:47,126
avoid unexpected bugs and side effects. Developing a

574
00:35:47,148 --> 00:35:51,014
monolith like this requires some additional effort, but it's still

575
00:35:51,052 --> 00:35:55,450
a lot less effort compared to adapting a microfrontend architecture.

576
00:35:55,950 --> 00:35:59,094
And last but not least, it's highly

577
00:35:59,142 --> 00:36:02,442
likely that you don't need microfrontend tent architecture because

578
00:36:02,496 --> 00:36:05,802
it brings significant expenses for both implementation and

579
00:36:05,856 --> 00:36:09,486
ongoing support. Objectively, there is only one reason to

580
00:36:09,508 --> 00:36:13,354
adapt it, and that is then you need to completely isolate

581
00:36:13,402 --> 00:36:17,054
multiple teams from each other, allows them to have the

582
00:36:17,092 --> 00:36:20,594
allen technologies, processes, releases and so

583
00:36:20,632 --> 00:36:24,146
on. All the other advantages of micro front ends can

584
00:36:24,168 --> 00:36:28,354
be effectively implemented in a monolithic application. In fact,

585
00:36:28,472 --> 00:36:32,006
a monolith is perfectly suitable for the vast majority of

586
00:36:32,028 --> 00:36:36,162
application, especially in the early stage of development.

587
00:36:36,306 --> 00:36:39,686
And to dive deeper into the topic you can explore the

588
00:36:39,708 --> 00:36:43,238
following subjects. The modular monolith there are a

589
00:36:43,244 --> 00:36:46,506
lot of articles and presentations available on this topic in

590
00:36:46,528 --> 00:36:49,914
the Internet. The clean architecture has an excellent book

591
00:36:49,952 --> 00:36:53,750
with the same name. Feature Slice Design has excellent documentation

592
00:36:53,830 --> 00:36:57,782
on their website and to start building a glorious monolith

593
00:36:57,846 --> 00:37:02,106
in your project, you can use the following tools. Typescript it

594
00:37:02,128 --> 00:37:05,274
is essential for building any large scale application.

595
00:37:05,472 --> 00:37:09,246
Eslint and Stylint are used to enforce architecture

596
00:37:09,278 --> 00:37:13,234
rules and constraints, and dependency cruiser helps in

597
00:37:13,272 --> 00:37:16,866
controlling imports within the system. These resources and

598
00:37:16,888 --> 00:37:20,034
tools will assist you in developing and maintaining a well

599
00:37:20,072 --> 00:37:23,634
structured and scalable monolith and that's all from

600
00:37:23,672 --> 00:37:26,754
me. Thank you for joining the presentation. I hope you really

601
00:37:26,792 --> 00:37:30,130
enjoyed it. Feel free to leave comments I'll be happy to answer

602
00:37:30,200 --> 00:37:32,400
any questions and have a nice day.

