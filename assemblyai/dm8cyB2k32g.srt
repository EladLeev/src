1
00:00:25,490 --> 00:00:29,014
Hello everyone, thank you very much for joining me. My name

2
00:00:29,052 --> 00:00:32,722
is Marco Nicola. I'm yet another software developer.

3
00:00:32,786 --> 00:00:36,726
I've been making software for more than 20 years. By now my main

4
00:00:36,748 --> 00:00:40,258
focus has mostly been on machine learning and specifically natural

5
00:00:40,274 --> 00:00:43,398
language processing applications. And in more

6
00:00:43,484 --> 00:00:47,494
recent years I've also tried to expand my skill set working on

7
00:00:47,532 --> 00:00:50,926
full stack web applications and also bit of software as

8
00:00:50,948 --> 00:00:54,398
a service and cloud applications as well. I'm currently

9
00:00:54,484 --> 00:00:58,270
employed at Exop, it's a german company and our main business

10
00:00:58,340 --> 00:01:01,598
is mobility risk management. If you want to

11
00:01:01,604 --> 00:01:04,942
be in touch with me, you can find me of course on GitHub

12
00:01:05,086 --> 00:01:08,750
or Twitter if you prefer, or LinkedIn. The references

13
00:01:08,830 --> 00:01:11,806
are there on screen. In this presentation,

14
00:01:11,918 --> 00:01:16,078
I'm going to show you how you can effectively deserializing Python objects

15
00:01:16,174 --> 00:01:20,154
with Gopickle with the help of a little library called Gopickle.

16
00:01:20,302 --> 00:01:24,614
As you can see, this is going to be a sort of cross languages talk.

17
00:01:24,812 --> 00:01:28,658
We will start by analyzing the Pythonista Pickle serialization

18
00:01:28,754 --> 00:01:32,106
module. We'll see exactly what it is. How does it work? Why is it

19
00:01:32,128 --> 00:01:36,070
interesting? We'll have a quick look at the Gopickle serialization

20
00:01:36,150 --> 00:01:39,702
format and finally we'll reach our beloved

21
00:01:39,766 --> 00:01:44,154
go programming language and we'll see how we can effectively

22
00:01:44,202 --> 00:01:48,334
and easily read Pickle formatted data from Go without even

23
00:01:48,372 --> 00:01:52,078
those need to run Python in the first place. First of all,

24
00:01:52,164 --> 00:01:55,378
Pythonista Gopickle is a Pythonista built in

25
00:01:55,464 --> 00:01:59,342
module. In Pythonista programming language modules

26
00:01:59,406 --> 00:02:03,214
are something just similar to Go packages. The Gopickle

27
00:02:03,262 --> 00:02:06,654
module in particular implements binary protocols

28
00:02:06,702 --> 00:02:10,610
for serializing deserializing Python objects. With Gopickle,

29
00:02:10,680 --> 00:02:14,562
here is all about data serialization and persistency.

30
00:02:14,706 --> 00:02:18,646
You can imagine to have your Python script which builds some

31
00:02:18,668 --> 00:02:22,326
data structures. Maybe you have an object and with the pickle

32
00:02:22,358 --> 00:02:25,706
module you can serialize it to a file. For example

33
00:02:25,808 --> 00:02:29,850
with the pickle dump function. This process is also called

34
00:02:29,920 --> 00:02:33,466
data pickling. You'll then have a binary representation

35
00:02:33,498 --> 00:02:36,782
of your original data, and later on you can read

36
00:02:36,836 --> 00:02:41,194
data back from this file with a function called gopickle load.

37
00:02:41,322 --> 00:02:44,450
And this deserialization process is also called

38
00:02:44,520 --> 00:02:47,966
data unpickling. In this context, I think it's

39
00:02:47,998 --> 00:02:51,038
interesting to talk about the pickle module,

40
00:02:51,214 --> 00:02:54,542
especially because at least according to my own Python

41
00:02:54,606 --> 00:02:57,846
programming experience, the pickle module seems to

42
00:02:57,868 --> 00:03:02,466
be a very popular choice for data serialization in Python,

43
00:03:02,658 --> 00:03:05,990
and it seems to be very popular, especially when

44
00:03:06,140 --> 00:03:10,170
those aspect or format of the actual deserialized data

45
00:03:10,320 --> 00:03:13,766
is not particularly a big concern. The popularity

46
00:03:13,798 --> 00:03:17,354
of this choice also seems to be reflected by a high

47
00:03:17,392 --> 00:03:20,694
number of particularly prominent Pythonista

48
00:03:20,742 --> 00:03:24,046
projects and libraries that you can find around just

49
00:03:24,068 --> 00:03:28,394
to name a bunch of them. Perhaps you've already heard about numpy Python library

50
00:03:28,442 --> 00:03:31,742
for scientific computation. Maybe you've heard about

51
00:03:31,796 --> 00:03:35,538
Pytorch, a machine learning framework for Pythonista or

52
00:03:35,624 --> 00:03:39,234
pandas, a library for data analysis and

53
00:03:39,272 --> 00:03:43,300
statistics. These libraries and many others as well,

54
00:03:43,750 --> 00:03:47,318
provide high level functions for saving and loading your custom

55
00:03:47,404 --> 00:03:50,930
data and behind the hood, either by default

56
00:03:51,010 --> 00:03:54,326
or you can choose that with some option. They seems to

57
00:03:54,348 --> 00:03:58,186
make use of the Python pickle module to actually

58
00:03:58,288 --> 00:04:01,878
achieve data persistency. Now you might be wondering

59
00:04:01,974 --> 00:04:05,734
why in the first place is it interesting for Pythonista programmers

60
00:04:05,782 --> 00:04:09,334
to use this weird and exotic pickle

61
00:04:09,382 --> 00:04:13,562
module over more popular and traditional data representation

62
00:04:13,626 --> 00:04:17,306
formats such as JSON or YamL or XML?

63
00:04:17,418 --> 00:04:20,042
Let's see this with a couple of simple examples.

64
00:04:20,186 --> 00:04:24,454
Let's start with a very straightforward Python data structure.

65
00:04:24,522 --> 00:04:27,954
In this case, we have a dict. Dicts in Python are

66
00:04:27,992 --> 00:04:31,426
similar to go maps. There are a bunch of keys and

67
00:04:31,448 --> 00:04:35,074
values. Values have many different data types. There are

68
00:04:35,112 --> 00:04:38,710
strings, there are numbers. There is an array which

69
00:04:38,780 --> 00:04:42,230
also contains mix of data types, number and a string.

70
00:04:42,570 --> 00:04:46,022
And it turns out to be straightforward and it works

71
00:04:46,076 --> 00:04:49,686
out of the box to deserialized this data to JSON

72
00:04:49,718 --> 00:04:53,878
format. The JSON representation even looks almost identical

73
00:04:53,974 --> 00:04:57,626
to the original Python code. But then

74
00:04:57,728 --> 00:05:01,194
let's see what happens if instead of using built in and

75
00:05:01,232 --> 00:05:05,054
simple data types, we define our own types and

76
00:05:05,092 --> 00:05:08,286
classes. Let's take a little moment to familiarize a

77
00:05:08,308 --> 00:05:12,014
little bit with these greeter class, since it will appear again

78
00:05:12,052 --> 00:05:15,598
in later examples. Let's define in Pythonista

79
00:05:15,694 --> 00:05:19,470
this class called greeter. It has a constructor,

80
00:05:19,550 --> 00:05:23,218
this devinit function which accepts name

81
00:05:23,304 --> 00:05:26,614
string argument and this name value is

82
00:05:26,732 --> 00:05:30,130
saved by the constructor in an internal instance

83
00:05:30,210 --> 00:05:34,054
variable underscore name. And then let's add

84
00:05:34,172 --> 00:05:38,154
a simple greet method to this class. And all it

85
00:05:38,192 --> 00:05:41,750
does is to print to standard, output the string

86
00:05:41,830 --> 00:05:45,100
high and then interpolating those name

87
00:05:45,470 --> 00:05:48,874
from the underscore name instance variable. That should be

88
00:05:48,912 --> 00:05:52,554
simple enough even for non experienced Python programmers,

89
00:05:52,602 --> 00:05:56,142
I hope. And of course you can instantiate an object.

90
00:05:56,276 --> 00:06:00,634
You can create a new instance with greeter parentheses,

91
00:06:00,682 --> 00:06:03,726
and then we can pass our name, let's say gopher.

92
00:06:03,838 --> 00:06:07,262
And sure enough, if you call object greet,

93
00:06:07,406 --> 00:06:11,294
you will get on your console the message hi gopher.

94
00:06:11,422 --> 00:06:15,394
So far everything is still fairly simple. But now if

95
00:06:15,432 --> 00:06:19,362
we want to try to represent to a format like JSON

96
00:06:19,506 --> 00:06:23,026
our little greeter object instance, we don't

97
00:06:23,058 --> 00:06:26,454
get this feature for free anymore. You might try that

98
00:06:26,492 --> 00:06:29,626
and you might get an error just like this one. This might be a very

99
00:06:29,648 --> 00:06:33,226
well expected behavior. You might think yourself about

100
00:06:33,328 --> 00:06:36,502
super easy solutions for representing the humble

101
00:06:36,566 --> 00:06:39,930
greeter object to JSoN, and then to load it back again.

102
00:06:40,080 --> 00:06:44,282
But the whole point here is that in real world applications,

103
00:06:44,426 --> 00:06:48,174
the complexity might escalate very quickly. For example,

104
00:06:48,292 --> 00:06:52,350
when we talk about custom objects, we should think as well about

105
00:06:52,420 --> 00:06:56,286
external libraries. Maybe your project is using third party

106
00:06:56,318 --> 00:06:59,698
libraries which don't provide out of the box the ability to

107
00:06:59,784 --> 00:07:03,614
export to your preferred data representation format,

108
00:07:03,742 --> 00:07:06,934
and in that case you might have to implement that by yourself.

109
00:07:07,132 --> 00:07:10,690
Also, think about object identity and shared objects.

110
00:07:10,850 --> 00:07:14,658
Maybe you have an object instance which is referred

111
00:07:14,754 --> 00:07:18,410
twice from an array when you serialize and later

112
00:07:18,480 --> 00:07:22,314
deserialized this array, you might expect as well to

113
00:07:22,352 --> 00:07:26,170
have a single object instance which is again

114
00:07:26,240 --> 00:07:29,740
referred twice from the array and not, for example,

115
00:07:30,050 --> 00:07:33,630
two different copies of the original object. Also,

116
00:07:33,700 --> 00:07:37,214
think about recursive objects. Consider having a

117
00:07:37,252 --> 00:07:40,814
list an array, and then you append the very

118
00:07:40,852 --> 00:07:44,434
same array to the array itself. And this might be very

119
00:07:44,472 --> 00:07:48,610
hard to represent in formats like JSon or YaMl. In order

120
00:07:48,680 --> 00:07:52,718
to elegantly solve this and other interesting situations,

121
00:07:52,814 --> 00:07:56,006
the pickle module adopts a fairly interesting and

122
00:07:56,028 --> 00:07:59,414
original approach. In fact, instead of more

123
00:07:59,452 --> 00:08:03,334
traditionally mapping your original data almost one

124
00:08:03,372 --> 00:08:06,946
to one to a certain data representation format,

125
00:08:07,058 --> 00:08:11,302
and also later on requiring a parsing step for reading

126
00:08:11,366 --> 00:08:14,982
the format and rebuilding your objects,

127
00:08:15,126 --> 00:08:18,390
the Gopickle module instead implements a fully qualified

128
00:08:18,470 --> 00:08:21,846
virtual machine. So when you are serializing

129
00:08:21,878 --> 00:08:25,694
data with the pickle module, it will create for you a

130
00:08:25,732 --> 00:08:28,682
binary pickle program that you can store somewhere,

131
00:08:28,746 --> 00:08:32,494
perhaps to a file. And later on this program can be given to

132
00:08:32,532 --> 00:08:36,482
a so called unpickling machine, which is in charge of

133
00:08:36,536 --> 00:08:39,934
running the pickle program and rebuilding those original

134
00:08:39,982 --> 00:08:43,854
objects. This approach is highly flexible.

135
00:08:43,982 --> 00:08:47,702
Pickle programs can instruct the unpickling machine in order

136
00:08:47,756 --> 00:08:51,682
to reconstruct arbitrarily complex data structures.

137
00:08:51,826 --> 00:08:55,702
Moreover, the virtual machine itself doesn't need to know

138
00:08:55,756 --> 00:08:58,758
anything really specific about custom classes,

139
00:08:58,934 --> 00:09:02,458
so custom classes and data types just work out of

140
00:09:02,464 --> 00:09:06,198
the box without farter intervention. The only downside

141
00:09:06,294 --> 00:09:09,702
is that the implementation of this virtual machine

142
00:09:09,846 --> 00:09:13,562
is highly tied to python specific functions,

143
00:09:13,626 --> 00:09:17,182
methods, and types. We can also have a quick,

144
00:09:17,236 --> 00:09:21,198
high level look at the virtual machine implementation. We saw

145
00:09:21,284 --> 00:09:25,230
that serializing data with Gopickle produces Gopickle programs,

146
00:09:25,310 --> 00:09:29,262
and a Gopickle program is really just a sequence of instructions

147
00:09:29,406 --> 00:09:32,962
where each instruction is identified by a one

148
00:09:33,016 --> 00:09:36,454
byte opcode. Certain opcodes might be

149
00:09:36,492 --> 00:09:39,874
followed by one or more additional bytes values,

150
00:09:40,002 --> 00:09:44,290
and these values correspond to instruction specific operands.

151
00:09:44,450 --> 00:09:47,746
They are just like instruction arguments.

152
00:09:47,938 --> 00:09:52,390
The Gopickle module actually implements a stack based virtual machine,

153
00:09:52,550 --> 00:09:55,510
so there is a traditional stack structure,

154
00:09:55,590 --> 00:09:59,462
and the virtual machine can push and pop elements against the stack.

155
00:09:59,606 --> 00:10:03,006
Additionally, there's also an additional data area which is

156
00:10:03,028 --> 00:10:06,494
called the memo, which is just something that makes the

157
00:10:06,532 --> 00:10:10,478
virtual machine implementation fairly simple. At the end

158
00:10:10,564 --> 00:10:13,822
of the program interpretation, the stack

159
00:10:13,886 --> 00:10:17,246
will contain just a single object, which will be those fully

160
00:10:17,278 --> 00:10:21,486
deserialized object. Also, the virtual machine instructions

161
00:10:21,598 --> 00:10:25,358
are not too many and not particularly complex as well.

162
00:10:25,544 --> 00:10:29,062
In no way you can perform any sort of looping or

163
00:10:29,116 --> 00:10:33,522
testing. There are no conditionals, there are no arithmetic instructions,

164
00:10:33,586 --> 00:10:37,454
and no function calls. The structure of pickle programs

165
00:10:37,522 --> 00:10:41,194
is really simple, and the virtual machine just

166
00:10:41,232 --> 00:10:44,886
read one time from start to the end. The pickle

167
00:10:44,918 --> 00:10:48,394
programs to deserialized data let's now see a

168
00:10:48,432 --> 00:10:51,958
practical use case and example. Here we are

169
00:10:51,984 --> 00:10:55,550
in Pythonista. We are defining again the greeter class.

170
00:10:55,620 --> 00:10:58,462
We already saw it, nothing has changed. Here.

171
00:10:58,596 --> 00:11:01,966
We can instantiate an object, and then let's say that we

172
00:11:01,988 --> 00:11:05,614
want to serialize it. So let's import the pickle

173
00:11:05,662 --> 00:11:09,502
module. Let's open a file object pickle

174
00:11:09,566 --> 00:11:13,022
in writing mode, and finally, let's simply invoke

175
00:11:13,086 --> 00:11:16,902
pickle dump, passing to it the object and

176
00:11:16,956 --> 00:11:20,406
the file. This code will effectively write some

177
00:11:20,428 --> 00:11:23,878
content to the object pickle file, and in fact,

178
00:11:23,964 --> 00:11:27,270
this file is now supposed to contain the Gopickle program,

179
00:11:27,420 --> 00:11:31,514
which can later be used to deserialize our object. We can

180
00:11:31,552 --> 00:11:35,434
try to have a look at the content of the file, for example, with an

181
00:11:35,472 --> 00:11:38,746
hexadecimal editor, and all we see is just a

182
00:11:38,768 --> 00:11:41,930
bunch of bytes. Here and there you can see some

183
00:11:42,000 --> 00:11:46,106
human readable sequences, but still it's hard to get a good idea about what's

184
00:11:46,138 --> 00:11:49,486
going on. However, if you are curious enough, you might go

185
00:11:49,508 --> 00:11:53,006
on with your exploration, perhaps making use

186
00:11:53,108 --> 00:11:57,406
of another built in Python module called Gopickle tools.

187
00:11:57,598 --> 00:12:01,074
For example, from the command line you might want

188
00:12:01,112 --> 00:12:04,546
to run a command just like those one that allows you

189
00:12:04,568 --> 00:12:08,114
to get the annotated representation of your pickle

190
00:12:08,162 --> 00:12:11,606
program of the content of your file. It's very

191
00:12:11,628 --> 00:12:15,398
likely that you'll get a highly dense output just like this one.

192
00:12:15,484 --> 00:12:19,498
Don't worry, we are not going to explore every detail about those screen,

193
00:12:19,664 --> 00:12:23,242
just to name a few things. On the very left you can see

194
00:12:23,296 --> 00:12:26,490
the bytes positions. Then in yellow color,

195
00:12:26,560 --> 00:12:30,122
I highlighted for you the opcodes. They're just single

196
00:12:30,176 --> 00:12:33,898
bytes. They are followed by the name of the instructions,

197
00:12:34,074 --> 00:12:37,422
and they are in turn, sometimes followed by

198
00:12:37,476 --> 00:12:40,990
the values of certain operands and then on the right

199
00:12:41,060 --> 00:12:44,802
you can see short annotations describing what

200
00:12:44,856 --> 00:12:48,046
each instruction is supposed to do. But now let's

201
00:12:48,078 --> 00:12:50,850
go back to some simpler Pythonista code,

202
00:12:51,000 --> 00:12:55,630
especially to see how to deserialize our data and objects.

203
00:12:55,790 --> 00:12:59,442
First, let's make sure that our custom classes and functions

204
00:12:59,506 --> 00:13:03,154
and data types are defined in our current scope.

205
00:13:03,282 --> 00:13:06,178
Here's again those greeter class just as a reference.

206
00:13:06,274 --> 00:13:10,114
And after that, let's simply import again the pickle module.

207
00:13:10,242 --> 00:13:13,690
Let's open our object pickle file for

208
00:13:13,760 --> 00:13:17,094
reading, and let's give those file to the Gopickle load

209
00:13:17,142 --> 00:13:20,546
function. This will actually run the unpickling

210
00:13:20,598 --> 00:13:24,634
machine, which will execute our pickle program, and we'll

211
00:13:24,682 --> 00:13:28,634
get back our object, which is almost identical to the original

212
00:13:28,682 --> 00:13:31,886
greeter instance object. And of course we

213
00:13:31,908 --> 00:13:35,042
can try to invoke the greet method on this

214
00:13:35,096 --> 00:13:38,834
object, and we get, as expected, our high

215
00:13:38,872 --> 00:13:42,370
Gohper message. Yet another important

216
00:13:42,440 --> 00:13:45,894
thing to say, but the pickle module is that it comes with

217
00:13:45,932 --> 00:13:49,334
different protocol versions. At present, there are six

218
00:13:49,372 --> 00:13:53,542
different versions, number from zero to five. And simply put,

219
00:13:53,676 --> 00:13:57,822
each protocol version identifies a set of instructions

220
00:13:57,906 --> 00:14:00,918
that the underlying virtual machine can handle.

221
00:14:01,094 --> 00:14:05,194
So from time to time, new protocol versions were introduced for

222
00:14:05,232 --> 00:14:09,386
reasons such as providing better efficiency in the

223
00:14:09,488 --> 00:14:13,262
virtual machine implementation. Perhaps new instructions were

224
00:14:13,316 --> 00:14:17,002
added for better handling specific Python types

225
00:14:17,066 --> 00:14:20,606
coming with newer Python releases. And important things

226
00:14:20,628 --> 00:14:25,038
to know in general is that each protocol version is back compatible

227
00:14:25,134 --> 00:14:28,962
with all previous versions. So that's enough

228
00:14:29,016 --> 00:14:32,306
Python stuff for now. If you are curious about

229
00:14:32,408 --> 00:14:36,326
further details, you can visit the official Python documentation for the

230
00:14:36,348 --> 00:14:40,130
Gopickle module, and also have a look at the Gopickle tools module,

231
00:14:40,210 --> 00:14:43,826
which provides even more extended documentation and details

232
00:14:43,938 --> 00:14:47,394
about the implementation of the unpickling virtual machine,

233
00:14:47,522 --> 00:14:50,522
as well as analysis tools. Okay,

234
00:14:50,576 --> 00:14:54,614
so everything was particularly cool and simple enough in the world of Pythonista.

235
00:14:54,742 --> 00:14:58,170
But what if I'm a go developer and maybe I have around

236
00:14:58,240 --> 00:15:02,294
some files containing data serialized with Python Gopickle

237
00:15:02,342 --> 00:15:05,934
module, and I might want to load that data from the Go

238
00:15:05,972 --> 00:15:10,414
language. Just some time ago I found myself in that exact situation.

239
00:15:10,612 --> 00:15:14,382
I was working on a machine learning library for the Go language.

240
00:15:14,446 --> 00:15:18,274
It's called spago. I recommend to check that out. And we

241
00:15:18,312 --> 00:15:22,078
wanted to load from go pretrained neural

242
00:15:22,094 --> 00:15:26,050
network models, which are exported from Pythonista

243
00:15:26,130 --> 00:15:29,634
from the popular machine learning framework Pytorch.

244
00:15:29,762 --> 00:15:33,478
And for doing that, we discovered that apart from

245
00:15:33,564 --> 00:15:37,662
other technicalities behind the hood, the Pytorch

246
00:15:37,746 --> 00:15:41,222
serialization process involves heavily the pickle

247
00:15:41,286 --> 00:15:44,906
module. And so the problem was, how do

248
00:15:44,928 --> 00:15:48,918
we load pickle data from Go a possible solution

249
00:15:49,014 --> 00:15:52,382
might have been to simply write a Pythonista script that

250
00:15:52,436 --> 00:15:56,462
would read the initial data and then transform it to a data

251
00:15:56,516 --> 00:15:59,982
representation format more suitable for being read from

252
00:16:00,036 --> 00:16:03,422
go. But instead of doing that, I decided to write

253
00:16:03,476 --> 00:16:06,946
a little wish list, and with this I was wishing for

254
00:16:06,968 --> 00:16:10,574
the existence of an easy to use go library

255
00:16:10,702 --> 00:16:14,034
that would allow me to unpickle data in go,

256
00:16:14,152 --> 00:16:17,574
possibly supporting all Gopickle protocols. It should

257
00:16:17,692 --> 00:16:21,622
handle out of the box basic simple data types such as

258
00:16:21,756 --> 00:16:25,014
numbers, integers and floating points, or strings and

259
00:16:25,052 --> 00:16:29,006
booleans, et cetera. It should be yet easy to be expanded

260
00:16:29,058 --> 00:16:33,062
with custom data types or types coming from external libraries,

261
00:16:33,206 --> 00:16:36,602
and it will be cool to do that without having to run

262
00:16:36,656 --> 00:16:40,250
Pythonista at any step for the deserialization process.

263
00:16:40,400 --> 00:16:43,550
And it will be also cool if such a library would have

264
00:16:43,620 --> 00:16:47,114
minimal, if maybe no dependencies at all, and possibly

265
00:16:47,162 --> 00:16:51,882
also not making use of unsafe data types or the Spago extension.

266
00:16:52,026 --> 00:16:55,406
I tried to look around a little bit for existing projects,

267
00:16:55,518 --> 00:16:59,122
but I couldn't really find exactly what I was looking

268
00:16:59,176 --> 00:17:02,946
for, and so I just decided to try to do that by myself.

269
00:17:03,128 --> 00:17:07,138
And here finally, I introduce you to the Gopickle library,

270
00:17:07,234 --> 00:17:11,218
a library for loading pythonista data serialized with the Pico module.

271
00:17:11,314 --> 00:17:15,250
Here's the link to the project. This library

272
00:17:15,330 --> 00:17:19,274
is focused on deserializing only, at least for now,

273
00:17:19,392 --> 00:17:22,934
and it's actually a part of the Pythonista

274
00:17:22,982 --> 00:17:26,106
Gopickle class that you can find on

275
00:17:26,208 --> 00:17:29,578
the cpython reference implementation source code.

276
00:17:29,744 --> 00:17:33,262
It turned out that mapping those basic data

277
00:17:33,316 --> 00:17:36,782
types from Python to go was a fairly easy

278
00:17:36,836 --> 00:17:40,554
process. I'm talking again about boolean values

279
00:17:40,602 --> 00:17:44,650
and numbers, floating points and integers and strings.

280
00:17:44,730 --> 00:17:48,654
And even the Python none type was easily mapped

281
00:17:48,702 --> 00:17:52,274
to the go nil value, and everything else that

282
00:17:52,312 --> 00:17:56,546
was otherwise especially tied to the Pythonista programming

283
00:17:56,578 --> 00:17:59,974
language has been in this library emulated by

284
00:18:00,012 --> 00:18:03,798
using structures and interfaces. Also,

285
00:18:03,884 --> 00:18:07,538
when I was starting this little project, I was especially reassured by

286
00:18:07,564 --> 00:18:10,682
those fact that the pickle library itself is not

287
00:18:10,736 --> 00:18:14,422
particularly big. For example, in cpython version

288
00:18:14,486 --> 00:18:18,646
three nine, you can find the lib Gopickle py file,

289
00:18:18,758 --> 00:18:22,810
which includes both the serialization and the deserialization

290
00:18:22,890 --> 00:18:26,698
code, and in total it's less than 2000 lines

291
00:18:26,714 --> 00:18:29,550
of code. So that was especially reassuring.

292
00:18:30,050 --> 00:18:33,394
But without further ado, let's jump right in with

293
00:18:33,432 --> 00:18:36,754
a basic usage example. It all starts once

294
00:18:36,792 --> 00:18:40,798
again with some Python code. Let's start by defining

295
00:18:40,894 --> 00:18:45,134
an object just using simple built in data types.

296
00:18:45,262 --> 00:18:48,562
We already saw previously this very data structure.

297
00:18:48,626 --> 00:18:52,182
It's a dict containing a bunch of keys and values and different

298
00:18:52,236 --> 00:18:55,622
data types, some strings and numbers. We also

299
00:18:55,676 --> 00:18:59,494
already know by now how to serialize data with the pickle

300
00:18:59,542 --> 00:19:03,638
module. So again, nothing new. Once this code is executed,

301
00:19:03,734 --> 00:19:07,654
we'll get can object pickle file containing our pickle

302
00:19:07,702 --> 00:19:11,094
program. So now of course we can deserialize

303
00:19:11,142 --> 00:19:15,006
our data back from this file. We already know how

304
00:19:15,028 --> 00:19:18,880
to do that in Python by using the pickle module itself.

305
00:19:19,330 --> 00:19:22,942
But here's something new we can try to do that from go

306
00:19:23,076 --> 00:19:26,830
by first installing the Gopickle package library.

307
00:19:26,990 --> 00:19:30,654
Here's the typical goget command to install the library,

308
00:19:30,782 --> 00:19:35,290
and then you can import the gopickle Gopickle package

309
00:19:35,470 --> 00:19:39,206
and make use of the Gopickle load function,

310
00:19:39,388 --> 00:19:42,914
which simply accepts the name of the file

311
00:19:42,962 --> 00:19:46,246
containing the Gopickle program and gives back to you

312
00:19:46,348 --> 00:19:49,494
the deserialized object. And also an error

313
00:19:49,542 --> 00:19:52,358
which in positive case will be simply nil.

314
00:19:52,534 --> 00:19:56,714
If everything goes as expected, the object variable will

315
00:19:56,752 --> 00:20:00,926
eventually contain something just like these here on

316
00:20:00,948 --> 00:20:04,302
the left. I reported the original Python data

317
00:20:04,356 --> 00:20:08,174
structure just for reference and comparison, and you can see very

318
00:20:08,212 --> 00:20:11,694
well here how the Gopico library transformed some of

319
00:20:11,732 --> 00:20:15,570
the original Python data types in specific

320
00:20:15,720 --> 00:20:18,974
Go types. For example, the original

321
00:20:19,022 --> 00:20:22,210
Pythonista dict is transformed to a Go type,

322
00:20:22,280 --> 00:20:26,130
which is also called dict, of course, and it's implemented

323
00:20:26,210 --> 00:20:30,422
provides a series of Dict entry elements being

324
00:20:30,476 --> 00:20:34,450
each dict entry, just a simple key value pair,

325
00:20:34,610 --> 00:20:38,154
and you can see how the various Dict keys and values are

326
00:20:38,192 --> 00:20:41,542
mapped in go. There's also the nested

327
00:20:41,606 --> 00:20:44,886
dict here, and you can also see the additional

328
00:20:44,998 --> 00:20:49,446
list value which contains both the number and the string.

329
00:20:49,638 --> 00:20:53,334
These custom types come from the Gopickle

330
00:20:53,382 --> 00:20:56,462
types subpackage. You can have a look at it,

331
00:20:56,516 --> 00:20:59,998
and it just provides a limited amount of

332
00:21:00,084 --> 00:21:03,374
structs and interfaces to represent

333
00:21:03,422 --> 00:21:07,650
and handle a limited set of python structures and

334
00:21:07,720 --> 00:21:11,502
data types, which are particularly useful for the implementation

335
00:21:11,566 --> 00:21:15,694
of the amplitude machine. So, for example, you have ways to represent

336
00:21:15,742 --> 00:21:18,934
and handle lists or dicts or tuples and

337
00:21:18,972 --> 00:21:22,934
so on and so forth. Please keep in mind that the implementation of

338
00:21:22,972 --> 00:21:26,758
some of these types is not particularly clever, and especially

339
00:21:26,844 --> 00:21:30,362
is not particularly optimized when those

340
00:21:30,416 --> 00:21:33,738
types were created. The main goal was to

341
00:21:33,824 --> 00:21:37,734
quickly have a working implementation of the whole unpickling machine,

342
00:21:37,862 --> 00:21:41,538
and some of these types still have a pretty unpolished

343
00:21:41,574 --> 00:21:44,974
aspect. And now that the whole unpickling machine seems

344
00:21:45,012 --> 00:21:48,842
to work fairly well, there's plenty of room for further

345
00:21:48,906 --> 00:21:52,534
improvements here. Let's now do something a little bit more advanced,

346
00:21:52,602 --> 00:21:56,226
and let's see how the Gopickle library behaves with

347
00:21:56,328 --> 00:22:00,418
foreign custom classes. So here from Pythonista we

348
00:22:00,504 --> 00:22:03,966
have once again the greeter class. We instantiate

349
00:22:03,998 --> 00:22:07,346
can object, and we deserializing Python objects with

350
00:22:07,368 --> 00:22:10,930
gopickle pickle modules to our object pickle file.

351
00:22:11,090 --> 00:22:15,078
If we now try to deserialize our object from go

352
00:22:15,164 --> 00:22:18,706
just like we did before, alas, this time we'll

353
00:22:18,738 --> 00:22:21,500
get an error back from the gopickle load function.

354
00:22:21,950 --> 00:22:25,254
The message of this error might not be particularly

355
00:22:25,302 --> 00:22:28,506
easy to understand. In fact, you might be

356
00:22:28,608 --> 00:22:32,314
required to have a little bit more familiarity with the gopickle

357
00:22:32,362 --> 00:22:36,558
project, and perhaps the Python pickle module as well.

358
00:22:36,724 --> 00:22:40,174
So for this time, let me clarify what's going on here.

359
00:22:40,292 --> 00:22:44,654
The first thing you have to know is that when the gopickle unpickling

360
00:22:44,702 --> 00:22:48,366
machine encounters unknown data types or classes,

361
00:22:48,478 --> 00:22:52,194
for example, the greeter class. In this case, it makes

362
00:22:52,232 --> 00:22:56,106
use of a couple of structures available from the Gopickle

363
00:22:56,158 --> 00:22:59,878
types subpackage, which are the generic object

364
00:22:59,964 --> 00:23:03,430
type and the generic class type. And of course,

365
00:23:03,500 --> 00:23:07,502
go is not, strictly speaking, can object oriented language.

366
00:23:07,666 --> 00:23:10,934
That's why we have this clear distinction between objects

367
00:23:10,982 --> 00:23:14,618
and classes. Sometimes letting go people

368
00:23:14,704 --> 00:23:17,978
creating those generic objects and classes is absolutely

369
00:23:18,064 --> 00:23:21,474
enough in order to deserialize certain data structures.

370
00:23:21,622 --> 00:23:25,114
However, here you can clearly see how even the humble

371
00:23:25,162 --> 00:23:29,038
greeter class apparently already has something too much

372
00:23:29,124 --> 00:23:32,790
in order to be handled out of the box by the Gopickle

373
00:23:32,810 --> 00:23:36,530
library so we can give to our library a little

374
00:23:36,600 --> 00:23:41,518
help. In order to better understand the data that is going to deserialize,

375
00:23:41,694 --> 00:23:45,186
even the Python pickle module would need to

376
00:23:45,208 --> 00:23:49,218
have the greeter class defined in the context in order to properly

377
00:23:49,314 --> 00:23:54,066
deserialize it. And so here the plan is to somehow emulate

378
00:23:54,178 --> 00:23:57,718
the greeter class and objects here in go.

379
00:23:57,884 --> 00:24:01,014
A fairly natural way to port in

380
00:24:01,052 --> 00:24:04,266
go the original Pythonista Greeter class is to

381
00:24:04,288 --> 00:24:08,074
define a greeter struct, also giving to

382
00:24:08,112 --> 00:24:12,078
it the name string field, which is a parallel to the

383
00:24:12,164 --> 00:24:15,870
original Python class underscore name instance variable.

384
00:24:16,370 --> 00:24:20,154
Later on, we can expect the unpickling

385
00:24:20,202 --> 00:24:23,278
machine to handle greater struct values,

386
00:24:23,374 --> 00:24:27,138
and it will eventually require it to satisfy those

387
00:24:27,224 --> 00:24:30,846
pydict settable interface. This interface

388
00:24:30,878 --> 00:24:34,842
is there in order to emulate the Pythonista specific behavior

389
00:24:35,006 --> 00:24:39,366
of setting a key value pair on a particular property

390
00:24:39,468 --> 00:24:42,886
that almost every Python object has, which is

391
00:24:42,908 --> 00:24:46,338
called underscore underscore dict underscore underscore

392
00:24:46,514 --> 00:24:49,978
with those assignment in Python, assuming that the

393
00:24:50,064 --> 00:24:54,010
object is actually an instance of a certain class,

394
00:24:54,160 --> 00:24:57,594
you are effectively assigning a value to

395
00:24:57,632 --> 00:25:01,614
a specific instance variable inside that object,

396
00:25:01,812 --> 00:25:05,054
and the name of the instance variable is

397
00:25:05,092 --> 00:25:08,334
identified by the value of those key. We can

398
00:25:08,372 --> 00:25:11,742
easily emulate this behavior in go as well.

399
00:25:11,876 --> 00:25:15,730
Let's then define this pydict set

400
00:25:15,800 --> 00:25:19,134
function for the greeter struct. It will be automatically

401
00:25:19,182 --> 00:25:22,546
invoked by the unpickling machine, which will provide

402
00:25:22,648 --> 00:25:26,310
a key and a value. They can be both of almost

403
00:25:26,380 --> 00:25:29,602
any type, so they are just both generic

404
00:25:29,666 --> 00:25:33,394
empty interfaces. We know that the original Python

405
00:25:33,442 --> 00:25:37,186
class had can instance variable called underscore

406
00:25:37,218 --> 00:25:40,906
name, so we might expect that this method will be invoked with

407
00:25:40,928 --> 00:25:44,586
a key equal to underscore name. And when

408
00:25:44,608 --> 00:25:47,882
we encounter this, we can just expect the value

409
00:25:47,936 --> 00:25:51,814
to be a string, so we can stringify the value and assign

410
00:25:51,862 --> 00:25:55,454
it to the name field of destruct. And of course we

411
00:25:55,492 --> 00:25:59,710
can also provide a little bit of error handling here and there. Of course,

412
00:25:59,780 --> 00:26:04,054
in go we don't even have the object oriented concept

413
00:26:04,122 --> 00:26:07,378
of classes and being able to create object

414
00:26:07,464 --> 00:26:11,346
instances from them yet. This is an important feature in

415
00:26:11,368 --> 00:26:15,302
the context of the unpickling machine, so we somehow had to emulate that

416
00:26:15,356 --> 00:26:18,886
as well. In go, the greeter struct that

417
00:26:18,908 --> 00:26:23,442
we just defined seems to be already well suitable for representing

418
00:26:23,506 --> 00:26:27,126
Pythonista Greeter object instances. But in

419
00:26:27,148 --> 00:26:31,002
go we have to do another step and define also

420
00:26:31,056 --> 00:26:34,982
a higher level greeter class. The original Greeter

421
00:26:35,046 --> 00:26:39,050
Python class was fairly simple. There were no class level

422
00:26:39,120 --> 00:26:43,102
variables or methods, and so we can keep it simple here

423
00:26:43,156 --> 00:26:46,334
as well. We can define a greeter class

424
00:26:46,452 --> 00:26:50,266
implemented as an empty struct with no fields.

425
00:26:50,458 --> 00:26:53,834
Again, sooner or later the unpickling machine

426
00:26:53,962 --> 00:26:56,962
will have to handle a greeter class value,

427
00:26:57,096 --> 00:27:00,862
and it will require it to satisfy the interface

428
00:27:00,926 --> 00:27:04,414
called pynouvable. This time this interface

429
00:27:04,542 --> 00:27:07,814
is there to simulate the creation of

430
00:27:07,852 --> 00:27:11,622
new object instances. In particular, it represents the

431
00:27:11,676 --> 00:27:15,634
Pythonista specific invocation of a special method

432
00:27:15,762 --> 00:27:19,002
which almost any class has, which is called again

433
00:27:19,056 --> 00:27:22,326
underscore underscore new underscore underscore.

434
00:27:22,438 --> 00:27:26,426
In go we can define a PI new function for

435
00:27:26,448 --> 00:27:30,086
the Greeter class struct. It should accept a variable amount

436
00:27:30,128 --> 00:27:33,754
of arguments and return a value representing

437
00:27:33,882 --> 00:27:37,454
an object instance generated from this kind of

438
00:27:37,492 --> 00:27:41,102
class, and also an error if something goes wrong. In our

439
00:27:41,156 --> 00:27:44,610
case, emulating the creation of a greeter object

440
00:27:44,680 --> 00:27:47,806
instance is as simple as returning

441
00:27:47,918 --> 00:27:51,634
a new greeter struct value. Having done

442
00:27:51,672 --> 00:27:55,382
this preparation, we are now almost ready to deserialize our

443
00:27:55,436 --> 00:27:59,058
data. We can import again the pickle package,

444
00:27:59,154 --> 00:28:02,374
and this time, instead of using the high

445
00:28:02,412 --> 00:28:06,278
level function gopickle load, we can open

446
00:28:06,444 --> 00:28:10,198
by ourselves a file for reading from it our object

447
00:28:10,284 --> 00:28:13,754
pickle file containing those pickle program, and we can give

448
00:28:13,792 --> 00:28:17,514
this program to the pickle new gopickle function.

449
00:28:17,712 --> 00:28:21,354
With this we'll get a customizable gopickle

450
00:28:21,402 --> 00:28:24,782
object, and after having provided our

451
00:28:24,836 --> 00:28:28,030
desired customization, we can eventually call

452
00:28:28,100 --> 00:28:31,850
unpickler load and this will try to load

453
00:28:31,930 --> 00:28:35,958
the gopickle program. In our case, we can customize the gopickle

454
00:28:35,994 --> 00:28:40,094
object by providing a find class callback

455
00:28:40,142 --> 00:28:44,206
function. With this function, we can finally tell to the virtual

456
00:28:44,238 --> 00:28:48,370
machine what it is in the first place, this foreign

457
00:28:48,450 --> 00:28:52,706
greeter type. So this function will be invoked

458
00:28:52,818 --> 00:28:56,614
with the module value equal to main and the name equal to

459
00:28:56,652 --> 00:29:00,310
greeter, which is the location of the original pythonista

460
00:29:00,390 --> 00:29:04,058
data type. And we can finally provide our

461
00:29:04,144 --> 00:29:07,530
implementation, our go implementation of the Greeter class,

462
00:29:07,680 --> 00:29:11,242
which happens to be just a greeter class struct

463
00:29:11,306 --> 00:29:15,034
value. Without this function, the unpickling

464
00:29:15,082 --> 00:29:18,954
machine will still fall back to the generic object and generic

465
00:29:19,002 --> 00:29:22,762
class types that we saw earlier, and we are finally

466
00:29:22,836 --> 00:29:26,594
ready to deserialize our object for doing that.

467
00:29:26,632 --> 00:29:30,290
Let's call those unpickler load function. Let's see

468
00:29:30,360 --> 00:29:33,678
if there is an error, maybe otherwise, let's just print

469
00:29:33,774 --> 00:29:37,734
to the console the representation of this object and

470
00:29:37,852 --> 00:29:41,622
lo and behold, there are no errors those time and

471
00:29:41,676 --> 00:29:45,398
we get as a result a greeter structures value.

472
00:29:45,564 --> 00:29:49,542
Those name field was populated with the value gopher,

473
00:29:49,686 --> 00:29:53,382
which is exactly the value that we were passing to the constructor

474
00:29:53,446 --> 00:29:56,666
from Python. Having reached this point,

475
00:29:56,768 --> 00:30:00,154
there's really just one more missing thing, and for

476
00:30:00,192 --> 00:30:04,106
that you might want to run the extra mile and implement

477
00:30:04,218 --> 00:30:07,258
the greet method on the greeter struct.

478
00:30:07,434 --> 00:30:11,054
Everything should be already in place, so the implementation itself is

479
00:30:11,092 --> 00:30:14,834
super simple. And once you have your deserialized object,

480
00:30:14,952 --> 00:30:18,894
you can cast it to a pointer to the greeter struct.

481
00:30:19,022 --> 00:30:23,262
And finally you can call the function greeter greet.

482
00:30:23,406 --> 00:30:26,710
And there you go, you have your message. Hi gopher.

483
00:30:27,210 --> 00:30:31,474
As a final reference, here is the full list of interface

484
00:30:31,522 --> 00:30:35,478
types from the Gopickle types package, which are

485
00:30:35,644 --> 00:30:39,414
replacing or emulating Python specific behaviors

486
00:30:39,462 --> 00:30:42,586
or functions. They are especially vital for the

487
00:30:42,608 --> 00:30:46,710
correct functioning of the whole unpickling machine. If you are curious,

488
00:30:46,790 --> 00:30:50,838
you can have a look at the Gopickle types documentation, and also

489
00:30:50,944 --> 00:30:54,318
at the corresponding Python functions documentation as well.

490
00:30:54,404 --> 00:30:58,234
Here's also a quick overview of those unpickler objects

491
00:30:58,282 --> 00:31:01,514
callbacks that you might want or need to customizable

492
00:31:01,642 --> 00:31:05,778
in order to provide a certain guidance for the unpickling process.

493
00:31:05,944 --> 00:31:09,646
We already saw the find class callback in action.

494
00:31:09,758 --> 00:31:14,222
There are other callbacks you can define as well, for example for resolving

495
00:31:14,286 --> 00:31:17,394
objects by a persistent id or handling

496
00:31:17,442 --> 00:31:21,254
custom pickle extensions, or handling particular

497
00:31:21,372 --> 00:31:24,226
data types or specific instructions.

498
00:31:24,418 --> 00:31:28,406
Also, keep in mind that some of these topics might be considered

499
00:31:28,438 --> 00:31:32,310
particularly advanced and might require some learning curve

500
00:31:32,390 --> 00:31:37,078
and time to get used to that. And sometimes a certain intimate

501
00:31:37,174 --> 00:31:40,922
level of knowledge about the those Gopickle model might be required

502
00:31:40,986 --> 00:31:44,702
as well. However, don't worry too much. Most of the times,

503
00:31:44,836 --> 00:31:48,202
even in real world and more complex scenarios,

504
00:31:48,346 --> 00:31:51,626
the required level of customization doesn't

505
00:31:51,658 --> 00:31:55,298
differ much from what we just saw before with our simple

506
00:31:55,384 --> 00:31:58,222
greeter class. As a bonus,

507
00:31:58,366 --> 00:32:01,250
once the whole unpickling machine was there in place,

508
00:32:01,320 --> 00:32:04,858
implemented in Go, it turned out that the original intent

509
00:32:04,974 --> 00:32:08,530
of deserializing neural network models

510
00:32:08,610 --> 00:32:12,742
exported from the Python Pytorch machine learning framework was

511
00:32:12,796 --> 00:32:15,942
a fairly simple job. The very go

512
00:32:15,996 --> 00:32:19,302
code for doing that turned out to be particularly

513
00:32:19,366 --> 00:32:22,874
compact in size, and for that reason we decided to

514
00:32:22,912 --> 00:32:26,246
release it directly in the Go Pico library.

515
00:32:26,358 --> 00:32:30,618
So there is a Pytorch subpackage which exposes types

516
00:32:30,714 --> 00:32:34,510
mapped from the original Pytorch Python implementation,

517
00:32:34,850 --> 00:32:38,526
and there's also a high level pytorch load function

518
00:32:38,628 --> 00:32:42,646
to effectively load at least a subset of Pytorch

519
00:32:42,698 --> 00:32:46,562
models. Also called modules, this package is

520
00:32:46,616 --> 00:32:50,770
effectively used by the Spago project, which I already mentioned

521
00:32:50,840 --> 00:32:54,050
before. Spago is a machine learning framework for go.

522
00:32:54,120 --> 00:32:58,146
Here is the link to the project, especially if you're not a machine

523
00:32:58,178 --> 00:33:01,666
learning expert. Spago comes with built in tools

524
00:33:01,698 --> 00:33:05,618
and configurations to help you solve traditional machine

525
00:33:05,634 --> 00:33:09,462
learning problems. In particular, in the field of natural language

526
00:33:09,526 --> 00:33:12,762
processing, you can easily make use of state

527
00:33:12,816 --> 00:33:15,866
of the art techniques to perform, for example,

528
00:33:15,968 --> 00:33:20,242
text classification, question answering, automatic machine translation,

529
00:33:20,326 --> 00:33:23,742
named entities, recognition, and a lot of other cool

530
00:33:23,796 --> 00:33:27,134
things. Spago implements all the

531
00:33:27,172 --> 00:33:30,682
functionalities, and then you can also easily obtain

532
00:33:30,826 --> 00:33:33,946
ready to use pre trained neural network models,

533
00:33:34,058 --> 00:33:37,006
for examples from the Huggingface website.

534
00:33:37,188 --> 00:33:40,590
Huggingface is a fantastic company, which most prominently

535
00:33:40,670 --> 00:33:44,530
started creating this sort of community where people can

536
00:33:44,600 --> 00:33:48,214
freely share their own pre trained model, and many of these

537
00:33:48,252 --> 00:33:52,050
models are actually generated by using Pytorch.

538
00:33:52,210 --> 00:33:56,214
Indeed, a subset of these models is compatible with

539
00:33:56,252 --> 00:33:59,846
Spago, which provides high level functions and also command

540
00:33:59,878 --> 00:34:03,414
line tools that can automatically download compatible

541
00:34:03,462 --> 00:34:07,302
models, load them thanks to the Gopickle library,

542
00:34:07,446 --> 00:34:10,822
convert them to a spaghespecific format,

543
00:34:10,966 --> 00:34:14,602
and finally, your application can perform a lot of wonderful

544
00:34:14,666 --> 00:34:18,346
things, and you don't even have to leave those terminal.

545
00:34:18,458 --> 00:34:22,286
Gopickle is still a very young project, there's plenty of room

546
00:34:22,308 --> 00:34:25,522
for improvements, and a lot of tasks are still left

547
00:34:25,576 --> 00:34:28,946
to do. Among those others, it's definitely desirable to

548
00:34:28,968 --> 00:34:32,626
have more tests and better test coverage, more and

549
00:34:32,648 --> 00:34:36,438
better documentation. Maybe it will be cool to implement better

550
00:34:36,524 --> 00:34:40,226
error messages and more clear ways to inspect

551
00:34:40,338 --> 00:34:43,654
what's going on in the PICL programs. We should try

552
00:34:43,692 --> 00:34:46,854
to support more and more Python standard classes as

553
00:34:46,892 --> 00:34:51,062
well as Pytorch specific classes, and also performance

554
00:34:51,126 --> 00:34:54,630
might be an interesting point to work on. In conclusion,

555
00:34:54,710 --> 00:34:57,974
here is my call to action for you. Please go visit

556
00:34:58,022 --> 00:35:01,494
the Gopickle GitHub repository page. The easiest

557
00:35:01,542 --> 00:35:05,022
way to contribute is to simply share the link and

558
00:35:05,076 --> 00:35:08,446
if you like, also give us a star. If you use the

559
00:35:08,468 --> 00:35:11,934
Gopickle library in your own projects and experiments, let us

560
00:35:11,972 --> 00:35:15,934
know how it goes. Feel free to come up with suggestions for

561
00:35:15,972 --> 00:35:19,534
fixes or improvements. And also please go on with

562
00:35:19,572 --> 00:35:22,574
your own pool requests. They are very, very welcome.

563
00:35:22,772 --> 00:35:26,342
Get in touch with us for any in prison that you want,

564
00:35:26,396 --> 00:35:30,310
even just for saying hi. And finally, you can also support us

565
00:35:30,380 --> 00:35:34,646
via our fiscal sponsor@opencollective.com,

566
00:35:34,828 --> 00:35:38,326
Nlpodice so that's it. It has been

567
00:35:38,348 --> 00:35:41,846
a long journey, but I hope you enjoyed it. Thank you very much for your

568
00:35:41,868 --> 00:35:44,518
attention, and until next time,

