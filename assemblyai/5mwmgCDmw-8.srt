1
00:01:42,590 --> 00:01:46,274
You. Hi everyone, Alex Livier here. And today

2
00:01:46,312 --> 00:01:50,834
we're going to be looking at solving the never ending requirements of authorization so

3
00:01:50,872 --> 00:01:54,334
quickly. By way of introduction, I'm Max Livier. I'm a software

4
00:01:54,382 --> 00:01:57,998
developer at heart, but now in the world of product. I started my career

5
00:01:58,014 --> 00:02:01,586
at Microsoft working on big enterprise customers, mainly on

6
00:02:01,608 --> 00:02:05,154
back end infrastructure and data side of things, and then really spent the last ten

7
00:02:05,192 --> 00:02:08,314
years working in various SaaS startups ranging from

8
00:02:08,352 --> 00:02:11,930
e commerce to finance to connected fitness to supply chain.

9
00:02:12,510 --> 00:02:16,038
And really my focus has always been on data and infrastructure components.

10
00:02:16,134 --> 00:02:18,806
And one of the pains and one of the issues and one of the areas

11
00:02:18,838 --> 00:02:22,502
I had to work on a lot was around authorization roles and permissions,

12
00:02:22,566 --> 00:02:26,186
RBAC, ABAC, those kind of concepts. And through my journey

13
00:02:26,218 --> 00:02:29,262
at these various different companies, I kind of got annoyed that there wasn't a better

14
00:02:29,316 --> 00:02:32,426
way of scalably defining and managing authorization.

15
00:02:32,618 --> 00:02:36,282
And so have begun working on the open source project Cerbos,

16
00:02:36,346 --> 00:02:39,346
which is now a company as well. And really this talk is going to be

17
00:02:39,368 --> 00:02:41,700
covering sort of what authorization is,

18
00:02:42,070 --> 00:02:45,298
why you may think you have a simple solution today, but some of

19
00:02:45,304 --> 00:02:48,806
the challenges that kind of come as you evolve and implement and

20
00:02:48,828 --> 00:02:51,880
scale your platform and your application.

21
00:02:53,050 --> 00:02:55,638
So just to make sure we are all on the same page, today we're going

22
00:02:55,644 --> 00:02:59,542
to be talking about authorization with a z or a z rather

23
00:02:59,596 --> 00:03:02,922
than authentication. So just to kind of clarify those two things,

24
00:03:03,056 --> 00:03:06,886
authentication is what you do when you go and challenge

25
00:03:06,918 --> 00:03:10,438
a user to provide a credential. So log in with Google, GitHub, username,

26
00:03:10,454 --> 00:03:13,830
password, those sort of things, and you get back some sort of verified identity.

27
00:03:13,910 --> 00:03:17,326
So now your application knows. Great. This person is who they say they are.

28
00:03:17,508 --> 00:03:20,686
Authorization, on the other hand, is the next level down. Okay, so now

29
00:03:20,708 --> 00:03:23,838
you know who the user is, their identity, their roles, those sort of things.

30
00:03:23,924 --> 00:03:27,122
What can they actually do inside of my application? What are they authorized to access?

31
00:03:27,176 --> 00:03:30,402
What are they permitted? What actions can they perform? And this is

32
00:03:30,456 --> 00:03:33,822
the space we're going to be talking about today. So authentication,

33
00:03:33,886 --> 00:03:36,820
users, identity, authorization, what can they actually do?

34
00:03:37,910 --> 00:03:41,014
So I think many of you will know this quote, in this world, nothing is

35
00:03:41,052 --> 00:03:44,710
certain but death, as in taxes. But from my own experience and

36
00:03:44,780 --> 00:03:48,186
many, many other people I've spoken to, I'd like to add

37
00:03:48,208 --> 00:03:52,710
on to this also the never ending authorization

38
00:03:52,790 --> 00:03:55,962
requirements changing. So what do you mean by this?

39
00:03:56,096 --> 00:03:59,814
You might start off with a very simple application with simple admin

40
00:03:59,862 --> 00:04:03,306
and users, but those requirements and those needs and those logic will

41
00:04:03,328 --> 00:04:07,006
have to change and evolve over time. So through this

42
00:04:07,028 --> 00:04:09,406
talk, we're going to actually going to scale a company. We're going to start out

43
00:04:09,428 --> 00:04:13,166
from day one, see what the authorization logic needs to be and how

44
00:04:13,188 --> 00:04:17,330
roles that kind of evolve as your application and your business scales.

45
00:04:17,830 --> 00:04:21,218
So we'll start off in day one, stage one, very simple,

46
00:04:21,304 --> 00:04:24,850
blissful days of roles, I call it, where you might have in your code base

47
00:04:24,920 --> 00:04:29,098
a check here that says, hey, if the user's authentication includes

48
00:04:29,134 --> 00:04:32,918
an email and that email contains our company's domain, then hey, they're an

49
00:04:32,924 --> 00:04:36,726
admin, they should be able to do everything. Great. Pretty simple. You can put that

50
00:04:36,748 --> 00:04:40,822
code in across your code base, probably in the request handler without

51
00:04:40,876 --> 00:04:44,138
any sort of issue. Very simple, all good. And if you want to get a

52
00:04:44,144 --> 00:04:47,254
bit fancy, maybe you can actually use maybe a scope inside of an Oauth token

53
00:04:47,302 --> 00:04:51,098
or a jot. But ultimately you're just checking a boolean. Is this person

54
00:04:51,184 --> 00:04:54,366
an employee or not? If they are an employee, they should be able to

55
00:04:54,388 --> 00:04:57,870
do stuff, if not, they shouldn't. Pretty simple. Great.

56
00:04:57,940 --> 00:05:01,818
Amazing. So now imagine whatever software

57
00:05:01,834 --> 00:05:05,486
you're building has been successful. You maybe got a sales team and that application

58
00:05:05,588 --> 00:05:08,754
has multiple different feature capabilities. And what

59
00:05:08,792 --> 00:05:12,434
kind of inevitably will happen at some point is you want to actually go and

60
00:05:12,552 --> 00:05:15,666
slice and dice how you maybe sell or package the application

61
00:05:15,768 --> 00:05:19,170
feature set to different users, to different companies,

62
00:05:19,240 --> 00:05:22,806
and sort of different positioning and packaging those sort of things. And this

63
00:05:22,828 --> 00:05:25,398
is something that might come down from a sales or a commercial team that want

64
00:05:25,404 --> 00:05:29,066
to kind of slice and dice applications. So now you go into your application

65
00:05:29,168 --> 00:05:32,826
code and now you need to now differentiate between your admins. So the

66
00:05:32,848 --> 00:05:36,634
people with the company's email address or looking

67
00:05:36,672 --> 00:05:40,314
at what package the particular user's company has. So here

68
00:05:40,352 --> 00:05:44,346
we've now evolved this logic check to first we're checking whether a user is an

69
00:05:44,368 --> 00:05:47,614
admin. Thus they should be able to do the action, or the

70
00:05:47,732 --> 00:05:50,942
package that that user currently has is the premium package, in which case,

71
00:05:50,996 --> 00:05:54,766
yay, they should be able to do the particular action. Either they're an admin or

72
00:05:54,788 --> 00:05:57,617
they have the premium package. And this is kind of your first step of,

73
00:05:58,117 --> 00:06:01,954
of sort differentiating and evolving your authorization logic to different user roles. And maybe

74
00:06:01,992 --> 00:06:06,114
you can use like a feature flagging system for this. That is certainly

75
00:06:06,152 --> 00:06:09,278
one way of doing it. Great. Now that's

76
00:06:09,294 --> 00:06:12,726
going to scale up, say amazingly successful. The new packages you've

77
00:06:12,748 --> 00:06:16,198
built, your sales is really happy and now you actually want

78
00:06:16,204 --> 00:06:18,738
to expand the business and you maybe want to start selling to another region.

79
00:06:18,834 --> 00:06:22,106
So I'm in the UK, we've sold in Europe, maybe we want to go out

80
00:06:22,128 --> 00:06:26,182
to the US. Well, here comes a level of complexity.

81
00:06:26,246 --> 00:06:29,866
So we're in the world now of GDPR, CCPA, and various other

82
00:06:29,888 --> 00:06:33,162
kind of data locality and data security regulations. And so

83
00:06:33,216 --> 00:06:36,350
now you need to actually add permissioning and logic checks in your application code

84
00:06:36,420 --> 00:06:39,882
to make sure that users are in the right region or accessing data storage

85
00:06:39,946 --> 00:06:43,438
in the right different regions. So now you need to go

86
00:06:43,444 --> 00:06:46,638
back into your code base, figure out where data fetching is occurring. You want to

87
00:06:46,644 --> 00:06:49,246
check whether someone's an admin, you want to check, make sure they have the premium

88
00:06:49,278 --> 00:06:52,782
package to maybe access some feature. And now you need to add another authorization

89
00:06:52,846 --> 00:06:55,794
check to work out whether the user is in the correct region or not,

90
00:06:55,832 --> 00:06:59,106
because you don't want someone in Europe accessing us data or vice versa.

91
00:06:59,218 --> 00:07:03,334
And many parts of the world have similar regulations. So now you have this

92
00:07:03,372 --> 00:07:06,886
further authorization. Can this person access this data or view

93
00:07:06,908 --> 00:07:10,714
this data, or store this data across your code base? And here maybe

94
00:07:10,752 --> 00:07:13,770
you can maybe use a scope. Again from your token,

95
00:07:14,110 --> 00:07:17,946
there's now quite a large number of libraries that you can embed into

96
00:07:18,048 --> 00:07:20,826
various specific languages. So Castle, Kankang,

97
00:07:20,858 --> 00:07:24,270
Caspin are in kind of the JavaScript ruby ecosystem.

98
00:07:24,850 --> 00:07:29,550
There's pundit and other different libraries out there which

99
00:07:29,620 --> 00:07:31,600
maybe help you abstract this logic app.

100
00:07:33,170 --> 00:07:35,898
Next challenge. Okay, cool. So we're now in multiple regions,

101
00:07:35,994 --> 00:07:39,330
we're selling, we've got different packages, but now you actually want to go and start

102
00:07:39,480 --> 00:07:42,674
selling to quote unquote, enterprise customers. And what's a

103
00:07:42,712 --> 00:07:46,334
common characteristics for enterprise businesses? They have large employee, large employee

104
00:07:46,382 --> 00:07:50,542
bases, and they have very clear denierations between groups and regions,

105
00:07:50,606 --> 00:07:54,038
and they need to access controls that can basically mirror that. What you

106
00:07:54,044 --> 00:07:56,006
don't want to do, and what I've done in the past is where you go

107
00:07:56,028 --> 00:07:59,814
and sign a company with 70,000 employees and you're trying to shoehorn them into

108
00:07:59,852 --> 00:08:03,606
maybe a couple of roles. That's just not going to work. These businesses

109
00:08:03,638 --> 00:08:07,814
are global businesses, multinational businesses. They will need to have abilities

110
00:08:07,862 --> 00:08:11,782
and controls in place to lock users down to certain regions or certain capabilities

111
00:08:11,846 --> 00:08:15,462
based on their team, their group, their, their geographical office location,

112
00:08:15,526 --> 00:08:18,762
all these sort of things. So now you

113
00:08:18,816 --> 00:08:22,306
start dealing with like directory type information. So groups and membership and those sort

114
00:08:22,328 --> 00:08:25,806
of things. And the most basic example is maybe you create a group of users

115
00:08:25,838 --> 00:08:28,878
called managers. So now in your code base, you're checking the admin, you're checking,

116
00:08:28,894 --> 00:08:31,938
they got the premium package, you're checking whether now they have access to

117
00:08:31,944 --> 00:08:34,930
the data in the right region you're also now checking whether someone belongs to this

118
00:08:35,000 --> 00:08:38,562
managers user group. And maybe you actually use a directory system.

119
00:08:38,616 --> 00:08:42,226
So active directory, LDAP, these one type of systems

120
00:08:42,258 --> 00:08:45,526
that will give you that membership and give you that assignment. But really now

121
00:08:45,548 --> 00:08:48,374
in your code base and every request handler, you're going to have to go and

122
00:08:48,412 --> 00:08:53,034
check whether someone belongs to that particular group. And such as

123
00:08:53,072 --> 00:08:57,450
you probably guessed, this logic is getting a bit kind of complicated. Now say

124
00:08:57,520 --> 00:09:00,986
you've mastered that and you want to go a bit further. Okay, so we've

125
00:09:01,018 --> 00:09:04,826
maybe got a new CISO hired or you want to go for your certifications.

126
00:09:04,858 --> 00:09:08,320
So ISO 27,001 sock two these kind of

127
00:09:10,290 --> 00:09:14,080
compliance certs. And with that comes a lot of

128
00:09:14,450 --> 00:09:17,902
controls that need to be put in place. One of those is around logging.

129
00:09:17,966 --> 00:09:21,698
So audit log access controls, those sort of things. So now in your code base,

130
00:09:21,784 --> 00:09:25,582
anytime you make an authorization decision, you need to capture the result of that decision.

131
00:09:25,646 --> 00:09:29,234
So capture the decision, capture the inputs to that

132
00:09:29,272 --> 00:09:32,694
decision, capture the output of that decision, and you want to create an order

133
00:09:32,732 --> 00:09:36,118
log of exactly who has access to what, where and when. So now back in

134
00:09:36,124 --> 00:09:39,474
your code base, you're checking whether someone is an admin, you're checking their package,

135
00:09:39,522 --> 00:09:42,794
checking their group, checking their region. And now whenever you have

136
00:09:42,912 --> 00:09:46,170
a decision, you want to actually create an order log, or exactly that.

137
00:09:46,240 --> 00:09:49,994
So here we have an order log that says great access denied or

138
00:09:50,112 --> 00:09:53,342
which region the data was fetched from. And you can

139
00:09:53,396 --> 00:09:57,946
maybe just use some logging library, which is great, but that's

140
00:09:57,978 --> 00:10:01,374
kind of logging. For application logging, this is something a bit

141
00:10:01,412 --> 00:10:05,034
more concrete, which is your access logs, your audit logs,

142
00:10:05,082 --> 00:10:08,306
which you're going to have to be able to demonstrate when you get audited and

143
00:10:08,328 --> 00:10:11,554
such. So you want something that

144
00:10:11,592 --> 00:10:15,182
will kind of scale with you and give you a very strict and standardized

145
00:10:15,246 --> 00:10:18,566
output for it. So at some point on this

146
00:10:18,588 --> 00:10:22,102
journey, it could have happened earlier, it could happen later, you might have

147
00:10:22,156 --> 00:10:25,494
come to the point where microservice discussion comes

148
00:10:25,532 --> 00:10:29,242
along. You can get quite far with monoliths these days, but there are just some

149
00:10:29,296 --> 00:10:33,206
components that make sense as standalone services. So let's

150
00:10:33,238 --> 00:10:36,826
say your main application is in node typescript, but you want to

151
00:10:36,848 --> 00:10:40,710
have some data modeling work, or ML

152
00:10:40,870 --> 00:10:44,390
or dare I say AI LLM type functionality in

153
00:10:44,400 --> 00:10:47,920
your application. Well, that's obviously going to be running more as a Python type experience,

154
00:10:48,370 --> 00:10:51,950
Python type of service. So now you're in this world of, okay, we now have

155
00:10:52,020 --> 00:10:55,278
our application which needs to have authorization in it,

156
00:10:55,364 --> 00:10:59,026
but we now have microservices that are going to be in different languages. You might

157
00:10:59,048 --> 00:11:02,142
have your node, your python, you might have some legacy net component,

158
00:11:02,206 --> 00:11:05,650
you might have x number of services running inside of your application

159
00:11:05,720 --> 00:11:09,046
architecture. What that now means is all that business logic that's been

160
00:11:09,068 --> 00:11:11,954
written for authorizing access. So checking groups, roles,

161
00:11:12,002 --> 00:11:14,866
assignments, emails, regions, audit, logging,

162
00:11:14,978 --> 00:11:18,914
all that logic is going to have to be replicated into n number of languages

163
00:11:18,962 --> 00:11:20,710
that you're running inside of your stack,

164
00:11:21,690 --> 00:11:24,954
which maybe if you use one other language is not too bad.

165
00:11:24,992 --> 00:11:27,658
But maybe if you got a plethora of languages, this is going to get a

166
00:11:27,664 --> 00:11:31,046
bit more manageable, unmanageable, and particularly

167
00:11:31,078 --> 00:11:34,478
when these requirements change, which as we've seen, they inevitably will, you're going to have

168
00:11:34,484 --> 00:11:38,366
to go and rewrite that business logic into code in n number of

169
00:11:38,388 --> 00:11:41,582
languages that you have and have sufficient tests and such

170
00:11:41,636 --> 00:11:45,234
around it to make sure that every service in every language is coming

171
00:11:45,272 --> 00:11:48,802
up with a correct authorization decision in every scenario. This gets

172
00:11:48,856 --> 00:11:52,386
a bit scary and hairy. And can you

173
00:11:52,408 --> 00:11:55,640
confidently say that every service in every language is behaving as it should?

174
00:11:56,250 --> 00:12:00,338
It's tricky. So there's

175
00:12:00,354 --> 00:12:04,466
a proposal of a new approach which is decoupled

176
00:12:04,498 --> 00:12:07,750
authorization. So we're in a world now of

177
00:12:07,900 --> 00:12:11,850
amazing services and software, many of them for free, many of them open source

178
00:12:12,510 --> 00:12:15,850
of this kind of build versus buy versus using some sort of SaaS system.

179
00:12:16,000 --> 00:12:19,530
And if we look at the authentication space, for example,

180
00:12:19,680 --> 00:12:23,078
there are many ways to do authentication in your application, but there's

181
00:12:23,094 --> 00:12:26,254
kind of a clear leader when it comes to can enterprise ready

182
00:12:26,292 --> 00:12:29,626
scalable offering. And that's kind of auth zero acquired

183
00:12:29,658 --> 00:12:32,990
by octave for billions of dollars not that long ago. And each

184
00:12:33,060 --> 00:12:36,398
part of your application stack you can really make a decision of is this core

185
00:12:36,414 --> 00:12:39,506
to my business or is this just

186
00:12:39,528 --> 00:12:42,706
something we need? Is this an infrastructure component? Is this just a common

187
00:12:42,808 --> 00:12:47,054
functionality their application needs, which is basically sort of undifferentiated.

188
00:12:47,182 --> 00:12:50,806
And authentication has gone through that maturity curve. Authorization is

189
00:12:50,828 --> 00:12:54,086
kind of going through at the moment like you as a business. Should you

190
00:12:54,108 --> 00:12:57,634
be building an authorization layer or should you just be pulling one off the shelf

191
00:12:57,762 --> 00:13:00,920
like an opensource project and putting it in?

192
00:13:01,470 --> 00:13:04,746
Really when you're thinking about building your applications, you really want to focus on the

193
00:13:04,768 --> 00:13:08,154
end user business value. What really are you giving your

194
00:13:08,192 --> 00:13:11,446
users, your customers that really differentiates? Kind of your solution

195
00:13:11,478 --> 00:13:14,926
to everyone else. That's going to be your value. That's going to be the thing

196
00:13:14,948 --> 00:13:17,520
you're selling everything else underneath it.

197
00:13:18,130 --> 00:13:21,038
You really take a hard look at is this core to our business or is

198
00:13:21,044 --> 00:13:24,000
this something that we should kind of slot in.

199
00:13:24,770 --> 00:13:28,046
So if we were to imagine authorization as a service or as

200
00:13:28,068 --> 00:13:30,786
a component running in a stack that you put off the shelf, what's it look

201
00:13:30,808 --> 00:13:34,146
like? Well, it's kind of an input. You have a user, they're trying

202
00:13:34,168 --> 00:13:36,210
to do some action on some resource.

203
00:13:37,270 --> 00:13:40,006
You don't want to hard code all that logic. So you send a request over

204
00:13:40,028 --> 00:13:43,478
to this authorization service. This authorization service needs to

205
00:13:43,484 --> 00:13:46,566
know how to answer the question of can this user do this action on this

206
00:13:46,588 --> 00:13:50,406
resource so that authorization service will have into it policy. And these

207
00:13:50,428 --> 00:13:53,814
policies basically need to define the different resource type, the different actions,

208
00:13:53,862 --> 00:13:57,206
and under which condition those actions should be either allowed or denied.

209
00:13:57,398 --> 00:14:01,014
So that authorization service takes that input, user resource action,

210
00:14:01,142 --> 00:14:04,394
evaluates those policies, roles up with a decision, either allow

211
00:14:04,432 --> 00:14:07,646
or deny. And that's basically what the output of that service needs to be back

212
00:14:07,668 --> 00:14:11,326
into your application code base. So if we were to go and look

213
00:14:11,348 --> 00:14:14,446
at kind of how we take maybe this code and convert it into

214
00:14:14,468 --> 00:14:17,860
something that's more policy based. Here's an example of a Cerbos policy

215
00:14:18,230 --> 00:14:21,826
where you kind of take that complex authorization logic, which is a massive if

216
00:14:21,848 --> 00:14:25,058
else case switch style statement that we saw earlier, and put in something a

217
00:14:25,064 --> 00:14:28,174
bit more structured. This is an example of a YAML

218
00:14:28,222 --> 00:14:31,766
authorization policy from Cerbos where you have a different

219
00:14:31,948 --> 00:14:35,126
policy for each resource. In this case, we're looking at a contact resource and

220
00:14:35,148 --> 00:14:38,194
we have a load of rules. So a very simple one here is a wildcard

221
00:14:38,242 --> 00:14:41,638
rule that says if the user has the admin role, they should be able to

222
00:14:41,644 --> 00:14:45,158
do everything. So it goes back to our kind of the user's email contains

223
00:14:45,174 --> 00:14:48,378
the company domain example. But then as you get more granular, you want to be

224
00:14:48,384 --> 00:14:51,766
able to define logic for both role based access control and attribute

225
00:14:51,798 --> 00:14:55,470
based access control, the difference being RBAC or role based access

226
00:14:55,540 --> 00:14:58,846
control. You simply allow an action based on whether someone has a role or not,

227
00:14:58,948 --> 00:15:02,382
or attribute based access control ABAC, which is where the

228
00:15:02,436 --> 00:15:05,598
decision is based not just on whether someone has a role, but actually look at

229
00:15:05,684 --> 00:15:09,326
the values and the conditions and the attributes of the actual resource they're accessing.

230
00:15:09,438 --> 00:15:12,642
And the best example of this is you can never have an owner role because

231
00:15:12,696 --> 00:15:15,986
owner of a resource is contextual based on who the user is and a

232
00:15:16,008 --> 00:15:19,554
specific instance of a resource you're accessing. So you want to be able to check

233
00:15:19,592 --> 00:15:22,686
the logic and check the attributes of the principal and the resource,

234
00:15:22,718 --> 00:15:25,502
or the user and the resource making the request to come up with the authorization

235
00:15:25,566 --> 00:15:28,922
decision. So you want to be able to write kind of expressions and rules as

236
00:15:28,976 --> 00:15:32,218
policy, as we have here as an example, where we're actually looking at

237
00:15:32,224 --> 00:15:35,514
the values about the resource and the principle to

238
00:15:35,632 --> 00:15:39,226
ultimately make can authorization decision. But the key

239
00:15:39,248 --> 00:15:43,078
thing with extracting this business logic out is it's now independent

240
00:15:43,094 --> 00:15:45,998
of your code base, and this is ultimately a service that you run inside of

241
00:15:46,004 --> 00:15:49,594
your stack. We're in the world of kubernetes now. We're in the world of microservices,

242
00:15:49,642 --> 00:15:53,838
et cetera. The rise of the sidecars through

243
00:15:53,924 --> 00:15:56,514
all the drama, I'd say it's going through at the moment you could say,

244
00:15:56,632 --> 00:16:00,226
but really it gives you this nice kind of decoupled component that

245
00:16:00,248 --> 00:16:03,874
runs inside of your stack. So you can see sidecars being used with like

246
00:16:03,912 --> 00:16:07,486
authentication, logging metrics, et cetera at the moment. And one of the nice characteristics

247
00:16:07,518 --> 00:16:11,606
of these is it's colocated with your application services. So authorization is

248
00:16:11,628 --> 00:16:15,046
not something that you can cache. Authorization checks need to be done

249
00:16:15,068 --> 00:16:18,710
on every single call, and it's in the blocking path of every request.

250
00:16:19,370 --> 00:16:23,114
Unlike authentication, which you can do once and get a token for say

251
00:16:23,152 --> 00:16:26,426
30 minutes, that's valid. Authorization you need to do on every

252
00:16:26,448 --> 00:16:29,226
single check. So you want to make sure that this is performant, you want to

253
00:16:29,248 --> 00:16:31,578
make sure it's local. You don't want to be going out over the Internet to

254
00:16:31,584 --> 00:16:35,982
make authorization checks. That's just a terrible design decision. You want to make sure that

255
00:16:36,116 --> 00:16:39,038
the checks are as fast as possible. And the best way of doing it is

256
00:16:39,044 --> 00:16:42,320
actually colocating your authorization service with your application.

257
00:16:43,090 --> 00:16:47,214
And this colocated approach is what enables you to decouple

258
00:16:47,262 --> 00:16:51,374
the authorization logic from your code base, but scalably

259
00:16:51,422 --> 00:16:55,026
manage it in a way that is performant. So we were to look at what

260
00:16:55,048 --> 00:16:58,194
this kind of authorization service would look like in practice. And this is

261
00:16:58,232 --> 00:17:01,298
a bit of reference, but obviously a servos is an open source

262
00:17:01,314 --> 00:17:05,554
project that fills the authorization service box here. But you have your end users

263
00:17:05,682 --> 00:17:08,886
on a client, be it a website, mobile app, those kind of things.

264
00:17:08,988 --> 00:17:12,314
They're making requests to your application. And this application block here is

265
00:17:12,352 --> 00:17:15,766
representing your app. It could be a microservice architecture,

266
00:17:15,798 --> 00:17:18,698
it could be a monolith, could be a load of lambda functions. It kind of

267
00:17:18,704 --> 00:17:21,546
doesn't really matter. But a request comes in and when that request comes in,

268
00:17:21,568 --> 00:17:24,762
you really know two things. Firstly, you know the user's identity,

269
00:17:24,826 --> 00:17:28,046
so they're authenticated. You got a JWT token, you got

270
00:17:28,068 --> 00:17:31,406
something along those lines where you know this person's been

271
00:17:31,428 --> 00:17:34,270
challenged, they provided a credential, we've got an identity.

272
00:17:34,690 --> 00:17:37,554
With that identity you might have some metadata about it.

273
00:17:37,592 --> 00:17:41,186
So what team, what groups, what location they're in, those sort of things. You can

274
00:17:41,208 --> 00:17:44,926
go out to a directory service, go and get memberships and organizational

275
00:17:44,958 --> 00:17:48,290
hierarchy information, but basically you have the user's identity and roles.

276
00:17:48,870 --> 00:17:51,766
The second thing you know is based on your API, is what resource they're trying

277
00:17:51,788 --> 00:17:55,318
to access. So you can go out to your database, you know they're trying to

278
00:17:55,324 --> 00:17:58,502
access the contact resource, you've got the id, you can go and fetch that record

279
00:17:58,556 --> 00:18:01,498
from your application database or some other backend service.

280
00:18:01,664 --> 00:18:05,162
And now in your code base, this is when you would have had that if

281
00:18:05,296 --> 00:18:08,806
else style block we were going through earlier based on the input

282
00:18:08,838 --> 00:18:12,700
of identity and resource, can this user do an action or not?

283
00:18:13,310 --> 00:18:17,322
Now in a decoupled approach, you extract all that business logic out into an authorization

284
00:18:17,386 --> 00:18:20,878
service that's running alongside your app. And now in your code base, you're making a

285
00:18:20,884 --> 00:18:24,954
simple API call out to that service and you're basically providing

286
00:18:25,082 --> 00:18:28,562
the user's identity. So the principal, as we call it, it's id.

287
00:18:28,616 --> 00:18:32,146
Their attribute memberships, teams, that sort of thing. The actual resource they're trying to

288
00:18:32,168 --> 00:18:35,982
access. So they're trying to access the contact resource id, one, two, three with attributes

289
00:18:36,046 --> 00:18:40,082
of owner, XYZ, et cetera. Again, it's kind of open ended based

290
00:18:40,136 --> 00:18:43,522
on your application. And then what action they're trying to do, create, read, update,

291
00:18:43,586 --> 00:18:47,126
delete are the common ones, but you want something that's very flexible and much more

292
00:18:47,148 --> 00:18:50,598
business use case specific. So approve, deny, comment, flag,

293
00:18:50,694 --> 00:18:54,682
forward, export. Whatever the actions inside of your system are,

294
00:18:54,736 --> 00:18:58,246
you would provide that along. So authorization service has loaded

295
00:18:58,278 --> 00:19:01,382
it into its policies and those policies are something that's hopefully versionable,

296
00:19:01,446 --> 00:19:04,618
testable, store, no, get, repo in a cloud storage bracket,

297
00:19:04,634 --> 00:19:08,126
even a database. Make sure you're selecting a tool that gives you

298
00:19:08,148 --> 00:19:11,806
the ability to do testing. So unit testing is your policy. This is something the

299
00:19:11,828 --> 00:19:15,150
Cerbos open source project does and ultimately

300
00:19:15,230 --> 00:19:18,674
inside your authorization service. It then evaluates your policies against

301
00:19:18,712 --> 00:19:21,906
those input of principal resource and action, comes up with a

302
00:19:21,928 --> 00:19:25,106
decision, creates an audit log of that decision, and then

303
00:19:25,128 --> 00:19:29,126
returns back to your application whether it should be an allow or deny. So now

304
00:19:29,148 --> 00:19:32,898
in your code base, it's a very simple if statement. If the authorization server

305
00:19:32,914 --> 00:19:37,494
says allow, do the action. If not, return some sort of error and

306
00:19:37,532 --> 00:19:41,002
you kind of get on with your life. So this model really

307
00:19:41,136 --> 00:19:44,582
has two main advantages. Firstly, all the authorization

308
00:19:44,646 --> 00:19:48,410
logic is an abstracted out into policy which are external to

309
00:19:48,480 --> 00:19:52,342
your application code. So when you want to evolve or change your authorization

310
00:19:52,406 --> 00:19:56,414
logic, you evolve it in one place. You can run tests against

311
00:19:56,452 --> 00:19:59,646
those policies standalone. You can have full version control if

312
00:19:59,668 --> 00:20:02,526
you use like a git repo to store your policy files in. And then when

313
00:20:02,548 --> 00:20:05,940
the authorization requirements change, there's one place to update it.

314
00:20:06,310 --> 00:20:10,078
And then all the application services that are checking permissions

315
00:20:10,254 --> 00:20:13,330
are calling an authorization service which has the updated policies in.

316
00:20:13,400 --> 00:20:17,502
Thus you can iterate and change all your authorization logic independently

317
00:20:17,566 --> 00:20:21,138
of where your authorization checks are being done. Front end, back ends. Amazing job.

318
00:20:21,224 --> 00:20:23,778
Everything's always going to be up to date without you having to touch your application

319
00:20:23,864 --> 00:20:27,178
code or redeploy your app in any way. The second benefit is

320
00:20:27,224 --> 00:20:30,970
because this authorization service is the point making the decisions. It's also the very clean

321
00:20:31,040 --> 00:20:34,598
place where the audit log can be created at this time. This principal tries

322
00:20:34,614 --> 00:20:37,514
to do this action and this resource and is either allowed or denied, and those

323
00:20:37,552 --> 00:20:40,966
logs then be picked up and sent off to some log capture system or cold

324
00:20:40,998 --> 00:20:44,394
storage as such for use in your monitoring.

325
00:20:44,442 --> 00:20:48,106
And also when it comes to audit time for your compliance, you can actually demonstrate

326
00:20:48,138 --> 00:20:51,838
a clean audit log of exactly what's going on. So in the

327
00:20:51,844 --> 00:20:55,482
application code, you've gone from this before where we had the big fl style statement,

328
00:20:55,546 --> 00:20:59,266
to the after where it's a single call out, an API call out.

329
00:20:59,448 --> 00:21:03,026
In this case we're using the servos SDK, but it can be basically to

330
00:21:03,048 --> 00:21:06,666
any server that's doing these checks, and you simply provide the user the resource

331
00:21:06,718 --> 00:21:10,326
and the action. And what comes back is either an allow or deny and it

332
00:21:10,348 --> 00:21:13,606
massively shrinks, simplifies the application code, but gives you

333
00:21:13,628 --> 00:21:16,040
the power of flexibility of policy.

334
00:21:16,970 --> 00:21:20,998
So if we look at the kind of advantages disadvantages of this model of decoupling

335
00:21:21,014 --> 00:21:24,774
authorization logic, first massive advantage is your authorization

336
00:21:24,822 --> 00:21:29,046
logic is now defined centrally. This one place where everything is defined,

337
00:21:29,078 --> 00:21:32,406
everything's set. You don't need to look across various different repos or application roles

338
00:21:32,438 --> 00:21:36,026
or languages to understand what's going on. It's one place your policies

339
00:21:36,058 --> 00:21:39,326
can evolve independently of your application code. And because it is just

340
00:21:39,348 --> 00:21:42,894
another service, a microservice running in your stack, it's completely agnostic to

341
00:21:42,932 --> 00:21:45,760
any language or framework or architectural choice you've made.

342
00:21:46,530 --> 00:21:49,282
You want to drop in a new service one day, that's maybe in a say

343
00:21:49,336 --> 00:21:52,866
go. Great. You just make an API call out from your go code and

344
00:21:52,888 --> 00:21:56,210
you get the same authorization decisions without having to re implement any logic.

345
00:21:56,790 --> 00:22:00,006
By having your authorization logos as policy rather than code.

346
00:22:00,108 --> 00:22:04,098
You can actually go to a GitHub style workflow, so you can run tests

347
00:22:04,114 --> 00:22:07,654
against your policies, you can do branch based deployment, all those sort of things.

348
00:22:07,772 --> 00:22:11,594
And then you have your policy authorization points

349
00:22:11,712 --> 00:22:15,174
like cerbos actually pull the policy directly from that repo.

350
00:22:15,222 --> 00:22:18,822
So once your tests pass, you merge domain and then your production pdps,

351
00:22:18,886 --> 00:22:22,474
your policy decision points will pull in those changes and

352
00:22:22,512 --> 00:22:25,786
start serving based on the new decision and the consistent audit trail,

353
00:22:25,898 --> 00:22:29,054
being able to actually truly demonstrate to your auditors or

354
00:22:29,092 --> 00:22:32,318
just your internal teams exactly what's happened inside of your system in a

355
00:22:32,324 --> 00:22:36,330
clean and consistent format without having to worry about implementing authorization audit

356
00:22:36,410 --> 00:22:39,858
logging across your application code base. Because all the decisions are

357
00:22:39,864 --> 00:22:43,138
being done in one place, there's a single place that generates the logs. They're going

358
00:22:43,144 --> 00:22:45,506
to always be in the same format, they're always going to be structured, they're always

359
00:22:45,528 --> 00:22:49,286
going to be captured. Obviously it's not all upsides. There's a couple of challenges here.

360
00:22:49,308 --> 00:22:52,690
You do have another service to run and deploy and worry about scale.

361
00:22:52,850 --> 00:22:56,674
Making sure you choose an authorization service that is predominantly stateless,

362
00:22:56,722 --> 00:23:00,506
so you have essentially infinite scale with authorization is key. That's something that

363
00:23:00,528 --> 00:23:03,946
servos does, lots of different approaches to do it, but really you

364
00:23:03,968 --> 00:23:08,042
want to make sure that whatever service

365
00:23:08,096 --> 00:23:11,686
you pick to do authorization is very light touch and doesn't put massive

366
00:23:11,718 --> 00:23:15,086
resource strain on your system and can actually scale up and down

367
00:23:15,108 --> 00:23:18,542
with your application without sweat. There is

368
00:23:18,596 --> 00:23:22,266
going to be a new domain specific language to learn in some cases.

369
00:23:22,378 --> 00:23:26,366
With Cerbos project, we decided to go with YaMl, love it or hate it.

370
00:23:26,548 --> 00:23:29,634
There's a lot of tooling and there's a great ecosystem around it in terms of

371
00:23:29,672 --> 00:23:33,026
autocompletion schema and those sort of things. But there

372
00:23:33,048 --> 00:23:35,214
is going to be a bit of a learning curve to take your business logic

373
00:23:35,262 --> 00:23:38,486
and write it as policy files. And then finally there is a new

374
00:23:38,508 --> 00:23:42,166
component in your critical path. Every request is now going to have to hit

375
00:23:42,348 --> 00:23:45,430
the authorization service before it can be handled

376
00:23:45,770 --> 00:23:49,014
again. It's kind of an architectural point with whatever service you go with

377
00:23:49,052 --> 00:23:51,830
to make sure that it is scalable, preferably stateless.

378
00:23:51,910 --> 00:23:55,626
Everything's done in memory. In the case of servos, every decision is

379
00:23:55,728 --> 00:23:59,494
evaluated in sub millisecond. Anything beyond that is really kind of network.

380
00:23:59,622 --> 00:24:03,490
So making smart decisions around how you deploy in a way that's

381
00:24:03,510 --> 00:24:07,194
the shortest number of hops possible. Hence sidecars are great if you can kubernetes

382
00:24:07,242 --> 00:24:11,326
because it's inside the same pod on the same node, but there

383
00:24:11,348 --> 00:24:14,630
is naturally going to be another component in place. So being sensible with health checks

384
00:24:14,650 --> 00:24:15,620
and those sort of things.

385
00:24:17,590 --> 00:24:21,362
So I've mentioned a few times, Servos is an open source project that does exactly

386
00:24:21,496 --> 00:24:24,946
what I've explained this authorization service needs to do. It's been going

387
00:24:24,968 --> 00:24:28,338
for a couple of years now, over 2000 stars

388
00:24:28,354 --> 00:24:31,734
on GitHub. We have users from around the world

389
00:24:31,772 --> 00:24:35,430
using servos completely free open source to patch two license off you go.

390
00:24:35,580 --> 00:24:38,918
We've also just launched Cerbos Hub, which is a managed control plane and gives you

391
00:24:38,924 --> 00:24:42,570
a UI for managing policies as well. But if you're happy to run everything yourself,

392
00:24:42,640 --> 00:24:46,394
you can just use the open source project. Go and hit us up on

393
00:24:46,432 --> 00:24:49,978
servers. Dev is our website, hit us up on GitHub as well.

394
00:24:50,064 --> 00:24:52,954
Have a look at the repo and we have a slack community as well,

395
00:24:52,992 --> 00:24:56,486
which if you join, we have plenty of t shirts and stickers

396
00:24:56,518 --> 00:24:59,706
to send out. So drop us a message and we will get something sent out

397
00:24:59,728 --> 00:25:03,106
to you. So that's it for me. Thank you very much for

398
00:25:03,128 --> 00:25:06,878
your time. I hope you found this interesting. And please, please do not reinvent

399
00:25:06,894 --> 00:25:10,786
the wheel of authorization. It's going to be never ending headache and

400
00:25:10,808 --> 00:25:14,386
there's projects out there now that can do it all for you. So you can

401
00:25:14,568 --> 00:25:17,586
forget about it and move on with your life and really focus on building that

402
00:25:17,608 --> 00:25:18,500
business value.

