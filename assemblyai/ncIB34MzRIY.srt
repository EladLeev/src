1
00:00:39,010 --> 00:00:42,454
Hello, everyone. My name is Adam Fulmanigan. Thank you for coming to this

2
00:00:42,492 --> 00:00:46,306
talk in which we are going to talk a little bit about effective

3
00:00:46,418 --> 00:00:50,366
database observability. No matter what SQL database you

4
00:00:50,388 --> 00:00:53,934
use, whether it's postgres, MySQL, Microsoft SQL, or maybe even

5
00:00:53,972 --> 00:00:57,982
ibmDb. Two, that doesn't matter. We are going to talk how

6
00:00:58,036 --> 00:01:01,770
to effectively observe what's going on in databases,

7
00:01:01,850 --> 00:01:05,982
how to debug our problems, and how to get some understanding

8
00:01:06,046 --> 00:01:10,082
of all the issues that happen in our database management system.

9
00:01:10,216 --> 00:01:13,666
My name is Adam Furmanek, and I will be your guide for the

10
00:01:13,688 --> 00:01:16,854
next 40 minutes. So let's jump straight to

11
00:01:16,892 --> 00:01:20,934
it. So the very first thing I'd like to start with is the

12
00:01:20,972 --> 00:01:24,726
world has changed significantly in the last years.

13
00:01:24,908 --> 00:01:28,582
So previously, 20 years ago, all we had was

14
00:01:28,636 --> 00:01:32,326
very simple two tier architecture. We had like a database.

15
00:01:32,438 --> 00:01:36,054
We had maybe a couple of nodes talking to the same database.

16
00:01:36,102 --> 00:01:39,786
Typically it was just one node, but sometimes we had like two or three of

17
00:01:39,808 --> 00:01:43,470
them. And obviously we had a user that was using our application.

18
00:01:43,620 --> 00:01:46,830
Nothing special here. If we wanted to have

19
00:01:46,900 --> 00:01:50,126
another application, if we wanted to do something else,

20
00:01:50,228 --> 00:01:53,306
typically we started building another monolith,

21
00:01:53,418 --> 00:01:57,154
right? We had monolithical applications that were all talking to

22
00:01:57,192 --> 00:02:00,542
one data store, and they were completely independent,

23
00:02:00,606 --> 00:02:03,970
not talking much to each other. So if there was a need

24
00:02:04,040 --> 00:02:07,874
to build something else, it was completely independent

25
00:02:08,002 --> 00:02:11,110
from the previous monolith. The problem was that,

26
00:02:11,180 --> 00:02:13,954
hey, those things were not necessarily scalable.

27
00:02:14,082 --> 00:02:17,746
We didn't know, or we didn't have any means to deploy

28
00:02:17,778 --> 00:02:21,878
them efficiently, to deploy them quickly, and to iterate

29
00:02:21,974 --> 00:02:25,194
many times a day with our changes. Whenever we wanted

30
00:02:25,232 --> 00:02:28,982
to release a change, we basically had to go through a big script

31
00:02:29,046 --> 00:02:32,334
of the deployment, deploying like whole application,

32
00:02:32,452 --> 00:02:36,174
then making sure everything works. And obviously it was

33
00:02:36,212 --> 00:02:39,950
time consuming, it was very slow. And the worst part was

34
00:02:40,020 --> 00:02:43,458
everything was tightly coupled with Chada. So then

35
00:02:43,544 --> 00:02:46,434
we started introducing DevOps. We realized that,

36
00:02:46,472 --> 00:02:50,222
hey, the plan in which we deploy applications,

37
00:02:50,286 --> 00:02:54,274
or the people that deploy applications are completely independent from

38
00:02:54,312 --> 00:02:57,662
the people that develop those applications. This is not necessarily

39
00:02:57,726 --> 00:03:00,998
the efficient way. So we wanted to bring them together.

40
00:03:01,084 --> 00:03:04,582
So DevOps emerged, and what we wanted to do is we wanted to put

41
00:03:04,636 --> 00:03:08,614
both teams side by side so they could closely cooperate

42
00:03:08,662 --> 00:03:12,202
and deploy things faster and participate in both

43
00:03:12,256 --> 00:03:16,086
development and deployment. And then we realized

44
00:03:16,198 --> 00:03:19,782
we can bridge this gap even more. We can actually

45
00:03:19,936 --> 00:03:23,722
come up with DevOps engineers that are both capable

46
00:03:23,786 --> 00:03:26,954
of writing the application code and deploying

47
00:03:27,002 --> 00:03:30,986
it. And at the same time, the world complexity

48
00:03:31,098 --> 00:03:34,530
increased significantly. So what we have now

49
00:03:34,600 --> 00:03:38,034
is our applications, our microservices, they are

50
00:03:38,072 --> 00:03:41,442
much more complex, because they talk to many data

51
00:03:41,496 --> 00:03:45,482
sources, many incompatible databases or data stores.

52
00:03:45,566 --> 00:03:49,410
They use very many different computation

53
00:03:49,490 --> 00:03:53,394
platforms. We have serverless, we have full blown bare metal,

54
00:03:53,442 --> 00:03:57,302
we have on the edge computing, we have many other things. And most

55
00:03:57,356 --> 00:04:00,234
importantly, everything talks to each other.

56
00:04:00,352 --> 00:04:04,058
So that's the biggest issue. That's the biggest challenge we face.

57
00:04:04,224 --> 00:04:08,342
Now, in order to deploy the changes, we don't need to deploy

58
00:04:08,406 --> 00:04:11,486
everything. We can just deploy a small piece of

59
00:04:11,508 --> 00:04:15,130
our modifications, like one microservice, one serverless

60
00:04:15,210 --> 00:04:18,622
lambda, or function, and off we go. The problem though,

61
00:04:18,676 --> 00:04:23,326
is that now everything talks to each other. The increased complexity,

62
00:04:23,438 --> 00:04:26,946
we didn't get rid of it. We only moved it

63
00:04:26,968 --> 00:04:30,222
in some different, into different part of the ecosystem.

64
00:04:30,366 --> 00:04:34,034
And so we pushed the complexity from the

65
00:04:34,072 --> 00:04:37,590
deployment to maintenance and operations.

66
00:04:37,930 --> 00:04:41,526
Now everything talks to each other. And whenever there is

67
00:04:41,548 --> 00:04:45,462
an issue, no matter whether it's like an issue with

68
00:04:45,516 --> 00:04:48,662
database, with queuing system, with service bus,

69
00:04:48,796 --> 00:04:51,882
we kind of don't know how to fix it,

70
00:04:51,936 --> 00:04:55,366
how to deal with that, because we need to deal with logs

71
00:04:55,398 --> 00:04:59,954
that are scattered throughout the system. We need to deal with pieces

72
00:05:00,022 --> 00:05:03,822
of information scattered here and there, and not even being

73
00:05:03,876 --> 00:05:07,290
able to tell what was the order of operations,

74
00:05:07,450 --> 00:05:09,658
because everything is now distributed,

75
00:05:09,754 --> 00:05:13,422
globalized, so we can't easily tell how the things

76
00:05:13,476 --> 00:05:17,186
executed. And when there was an issue, then, was it just a

77
00:05:17,208 --> 00:05:20,978
manifestation of some bug in this part of the system?

78
00:05:21,144 --> 00:05:25,210
Or was it a coincidence? Because everything is now distributed

79
00:05:25,390 --> 00:05:28,486
and moving forward, there is this thing that we know

80
00:05:28,508 --> 00:05:32,470
as Conway's law. Conway's law basically tells us

81
00:05:32,540 --> 00:05:36,150
that the architecture of our applications will

82
00:05:36,220 --> 00:05:40,538
mimic the organization that we live in. Meaning that

83
00:05:40,624 --> 00:05:44,246
if we want to deal with microservices

84
00:05:44,438 --> 00:05:47,958
that all have their independent data stores,

85
00:05:48,054 --> 00:05:51,150
that all have their independent, like code

86
00:05:51,220 --> 00:05:54,298
base, are deployed completely independently,

87
00:05:54,474 --> 00:05:58,190
then it means that we basically need to build

88
00:05:58,260 --> 00:06:01,434
teams that have the same architecture,

89
00:06:01,562 --> 00:06:05,166
same structure. Conway's law is not something

90
00:06:05,268 --> 00:06:09,170
that we impose as an axiom, is not something that

91
00:06:09,240 --> 00:06:13,102
tells us we need to do it this way, because otherwise,

92
00:06:13,166 --> 00:06:17,522
like, we are doing something wrong. No, Conway's law is an observation,

93
00:06:17,666 --> 00:06:21,190
telling us that if we stop fighting really,

94
00:06:21,260 --> 00:06:25,318
really hard, then our applications will

95
00:06:25,404 --> 00:06:28,406
resemble the structure of our organization.

96
00:06:28,598 --> 00:06:31,994
This basically means that if we want to impose some

97
00:06:32,032 --> 00:06:35,402
architecture, we should start with imposing the

98
00:06:35,456 --> 00:06:39,286
right teams structure in our organization.

99
00:06:39,478 --> 00:06:43,694
Meaning that if we take pictures from teams topology. Very nice book.

100
00:06:43,812 --> 00:06:47,754
If we want to have microservices that are completely separate,

101
00:06:47,802 --> 00:06:51,962
completely independent, and they deal with different independent databases

102
00:06:52,026 --> 00:06:55,762
and code bases, then what we need to do is we need to take this

103
00:06:55,816 --> 00:06:59,326
picture and basically turn it 90 degrees

104
00:06:59,438 --> 00:07:03,570
so we get exactly the same team structure. Notice that those

105
00:07:03,640 --> 00:07:07,206
images are exactly the same. They are just rotated by

106
00:07:07,228 --> 00:07:10,166
90 degrees, but they show exactly the same.

107
00:07:10,268 --> 00:07:14,530
If you want to. If we want to have an efficient

108
00:07:14,690 --> 00:07:17,874
independence and decoupled applications,

109
00:07:18,002 --> 00:07:21,926
what we need to do is we need to have decoupled and independent

110
00:07:21,958 --> 00:07:26,262
teams. And taking into account what happened with the increased

111
00:07:26,326 --> 00:07:29,674
complexity of our world, this means that

112
00:07:29,712 --> 00:07:33,182
we can't rely on the solutions that we used to have

113
00:07:33,236 --> 00:07:37,070
for observability, monitoring and maintenance that

114
00:07:37,140 --> 00:07:41,242
were like, we used them when we were dealing with monolithical

115
00:07:41,306 --> 00:07:44,786
applications, because it just doesn't work the

116
00:07:44,808 --> 00:07:48,094
same way we change the way we develop and deploy

117
00:07:48,142 --> 00:07:51,442
our applications, the same way we need to change the way

118
00:07:51,496 --> 00:07:55,570
we maintain them and the way we structure our

119
00:07:55,640 --> 00:07:59,318
ops teams. This effectively means that because of the

120
00:07:59,324 --> 00:08:02,898
increased complexity, we can't rely on dbas anymore.

121
00:08:02,994 --> 00:08:06,498
We need to change the way how we structure our organization.

122
00:08:06,674 --> 00:08:10,102
And we need to do it with help of platform engineers,

123
00:08:10,166 --> 00:08:14,426
DevOps engineers and developers all working together to

124
00:08:14,448 --> 00:08:18,074
reshape the world. Let's see how to reshape the world.

125
00:08:18,272 --> 00:08:21,390
The important part that we all know

126
00:08:21,460 --> 00:08:24,494
about is that communication is the

127
00:08:24,532 --> 00:08:28,538
main factor in reducing efficiency and performance.

128
00:08:28,714 --> 00:08:32,190
The things that we can automate, things that can be done

129
00:08:32,260 --> 00:08:35,810
by tools, they are fast, because computers are fast

130
00:08:35,880 --> 00:08:39,166
in general. But the things that we need to do manually,

131
00:08:39,278 --> 00:08:43,154
or the things that we need to do by cooperating with other

132
00:08:43,192 --> 00:08:45,874
teams, those things are slow.

133
00:08:46,002 --> 00:08:49,670
This means that the highest bandwidth we'll have inside

134
00:08:49,820 --> 00:08:53,800
our teams, where we can communicate easily and quickly,

135
00:08:54,170 --> 00:08:57,966
if we need to go cross teams, then the communication

136
00:08:58,098 --> 00:09:01,194
is going to be way slower, which will lead to

137
00:09:01,232 --> 00:09:05,190
far slower, like troubleshooting and issue resolution.

138
00:09:05,350 --> 00:09:08,822
This increases mean time to recovery,

139
00:09:08,886 --> 00:09:12,350
time to fixing an issue, basically time to do

140
00:09:12,420 --> 00:09:15,866
anything. Just because we spend time on communication,

141
00:09:15,978 --> 00:09:19,854
then we cannot speed up. This is also another

142
00:09:20,052 --> 00:09:23,586
outcome of Conway's law. So what we need to do is

143
00:09:23,608 --> 00:09:27,646
we need to understand that in order to have efficient observability,

144
00:09:27,758 --> 00:09:31,854
monitoring and efficient DevOps infrastructure or DevOps

145
00:09:31,902 --> 00:09:36,002
culture, what we need to do is we need to minimize communication.

146
00:09:36,146 --> 00:09:39,494
That's the very important part. And in order to

147
00:09:39,532 --> 00:09:43,234
minimize communication, we need to basically minimize

148
00:09:43,282 --> 00:09:47,010
the reasons to communicate. And those reasons are typically

149
00:09:47,170 --> 00:09:50,438
that we understand or realize there is a bug,

150
00:09:50,534 --> 00:09:54,006
but we figure it out very late in our pipeline.

151
00:09:54,118 --> 00:09:57,738
So what we want to do is we want to shift left

152
00:09:57,904 --> 00:10:01,914
all the checks. In order to have efficient communication,

153
00:10:02,042 --> 00:10:05,722
we need to not communicate. The less we communicate,

154
00:10:05,786 --> 00:10:09,406
the better. So we need to avoid communication at all.

155
00:10:09,508 --> 00:10:12,814
And how can we avoid communication? We can

156
00:10:12,852 --> 00:10:16,594
do it by shifting all the things to the left and

157
00:10:16,632 --> 00:10:19,870
building teams that don't need to communicate

158
00:10:19,950 --> 00:10:23,934
with other teams. We need to build small and highly efficient

159
00:10:23,982 --> 00:10:27,830
teams with well defined scope so they can deal with

160
00:10:27,900 --> 00:10:31,270
everything they need without the need

161
00:10:31,340 --> 00:10:34,166
to go to some other teams and ask for help.

162
00:10:34,268 --> 00:10:37,538
So this is why we need to have the shift left. And the

163
00:10:37,564 --> 00:10:41,562
important part, talking about databases. Now the problem

164
00:10:41,616 --> 00:10:45,382
with databases is we can't shift

165
00:10:45,446 --> 00:10:49,318
left our testing and our maintenance,

166
00:10:49,494 --> 00:10:53,354
because many times developers are very relentless

167
00:10:53,402 --> 00:10:57,022
to test their solutions. They don't have

168
00:10:57,076 --> 00:11:00,622
tools, they don't have means to do so, and most

169
00:11:00,676 --> 00:11:04,706
importantly, they lack working knowledge how to do that.

170
00:11:04,808 --> 00:11:08,580
So our ultimate goal is always self service.

171
00:11:09,030 --> 00:11:12,194
We always want our teams to be small,

172
00:11:12,392 --> 00:11:15,830
to be independent from other teams and

173
00:11:15,900 --> 00:11:19,382
teams that can do everything they need on their

174
00:11:19,436 --> 00:11:23,222
own, meaning that if they need to get some

175
00:11:23,356 --> 00:11:26,658
data, some locks, access to some systems,

176
00:11:26,754 --> 00:11:29,260
they need to do it in a self serve way.

177
00:11:30,030 --> 00:11:33,734
They shouldn't ask for permissions, they shouldn't communicate

178
00:11:33,782 --> 00:11:37,338
with others, they should do this in a self service

179
00:11:37,504 --> 00:11:41,614
way. So this is the goal, this is how we need to

180
00:11:41,732 --> 00:11:45,514
turn our organizations to have efficient DevOps

181
00:11:45,562 --> 00:11:49,102
culture. And this affects everything we work on

182
00:11:49,156 --> 00:11:53,086
like web services, desktop applications, and most importantly

183
00:11:53,118 --> 00:11:56,222
for the purpose of this talk is databases.

184
00:11:56,366 --> 00:11:59,966
We need to reshape our organizations,

185
00:12:00,078 --> 00:12:03,906
to have new team structures that really

186
00:12:04,008 --> 00:12:08,450
embrace the complexity that increased and make it straightforward

187
00:12:08,530 --> 00:12:12,690
to maintain, deploy and troubleshoot databases.

188
00:12:12,850 --> 00:12:16,614
Let's see how we can do all of that and let's see

189
00:12:16,652 --> 00:12:21,302
what we can build now to shift left the ownership.

190
00:12:21,446 --> 00:12:25,510
Make developers own their databases, make developers

191
00:12:25,590 --> 00:12:29,542
self serve their issues, and most importantly,

192
00:12:29,686 --> 00:12:33,454
finally fix all the problems as early as

193
00:12:33,492 --> 00:12:37,694
possible. And this is a must, no matter whether we are a small company or

194
00:12:37,732 --> 00:12:40,990
big Fortune 500 enterprise, we need this

195
00:12:41,060 --> 00:12:44,866
shift in the organization because basically

196
00:12:44,968 --> 00:12:48,354
that's a must have for us to move faster, to have

197
00:12:48,392 --> 00:12:52,094
highly efficient DevOps culture that maximizes

198
00:12:52,142 --> 00:12:55,762
Dora metrics so we cant move fast and in a reliable,

199
00:12:55,826 --> 00:12:59,094
robust way. So the very first thing when

200
00:12:59,132 --> 00:13:02,438
we talk about observability in general,

201
00:13:02,604 --> 00:13:06,230
we said that we would like to do it around

202
00:13:06,300 --> 00:13:10,106
databases, but what we have now around databases is we

203
00:13:10,128 --> 00:13:13,686
typically have dashboards. This applies to the whole observability

204
00:13:13,798 --> 00:13:17,446
in general. We have dashboards that present lots

205
00:13:17,478 --> 00:13:22,110
of data, but they lack any information that

206
00:13:22,180 --> 00:13:25,374
they should convey. We have charts, we have

207
00:13:25,412 --> 00:13:28,650
like we are swamped with raw data, with signals,

208
00:13:28,730 --> 00:13:32,254
with metrics, with everything around, but we do not get

209
00:13:32,292 --> 00:13:35,634
the information. What's going wrong. We have lots of

210
00:13:35,672 --> 00:13:38,622
signals. This includes like deployment signals,

211
00:13:38,766 --> 00:13:42,894
metrics, traffic maybe sometimes like very detailed

212
00:13:42,942 --> 00:13:46,594
metrics from particular regions or dimensions. But we don't

213
00:13:46,642 --> 00:13:49,922
understand the big picture and we don't understand the coherent

214
00:13:49,986 --> 00:13:53,894
story of what is going on. So we cant do the

215
00:13:53,932 --> 00:13:58,242
efficient observability if we don't have better tools,

216
00:13:58,306 --> 00:14:01,354
with current tools, just like the one we see on the screen,

217
00:14:01,472 --> 00:14:05,334
we just can't do the efficient observability. So let's

218
00:14:05,382 --> 00:14:09,126
see how to build this efficient, effective observability

219
00:14:09,238 --> 00:14:13,534
for databases. But in order to do that, we need to understand what

220
00:14:13,572 --> 00:14:17,530
can go wrong. So let's see a couple of things that break in databases

221
00:14:17,610 --> 00:14:21,134
and then let's see how we can actually build the stuff

222
00:14:21,252 --> 00:14:25,122
better. So the problems in databases, they typically fall

223
00:14:25,176 --> 00:14:29,362
into one of three areas. So first area is code changes.

224
00:14:29,496 --> 00:14:33,454
So we change the code, we basically execute stuff. We execute

225
00:14:33,502 --> 00:14:37,346
different queries because we modified our application and this obviously leads

226
00:14:37,378 --> 00:14:41,238
to performance degradations and problems, right? So this is code changes.

227
00:14:41,324 --> 00:14:44,566
The second area is schema changes. Whenever we

228
00:14:44,588 --> 00:14:47,502
change schema of our applications, we change databases,

229
00:14:47,586 --> 00:14:50,326
columns, data types,

230
00:14:50,518 --> 00:14:54,074
everything can always affect the way our

231
00:14:54,112 --> 00:14:57,734
applications execute and can break our applications.

232
00:14:57,862 --> 00:15:01,710
But last but not least, there is yet another area which

233
00:15:01,780 --> 00:15:06,218
we typically miss when it comes to building observability.

234
00:15:06,394 --> 00:15:10,174
Building resilient testing suits and building all

235
00:15:10,212 --> 00:15:14,302
the processes around CI CD for that. And this is how queries are

236
00:15:14,356 --> 00:15:17,962
executed. And I'm not talking about what query change,

237
00:15:18,036 --> 00:15:21,262
meaning that we added new columns, started joining another table.

238
00:15:21,326 --> 00:15:24,770
No, what I mean here is that we have a query

239
00:15:25,210 --> 00:15:29,126
that is now like over days, changes the

240
00:15:29,148 --> 00:15:32,198
way it is being executed by the database engine,

241
00:15:32,364 --> 00:15:35,810
changes the execution plan, because statistics

242
00:15:35,890 --> 00:15:39,958
changed, because indexes changed, because configuration

243
00:15:40,054 --> 00:15:43,210
around changed. So all those things may

244
00:15:43,280 --> 00:15:47,146
affect how the query is executed. And we

245
00:15:47,168 --> 00:15:50,602
won't notice that in our CI CD and our old

246
00:15:50,656 --> 00:15:53,786
DevOps culture cannot see that now easily.

247
00:15:53,898 --> 00:15:57,854
So let's see a couple of examples. Obviously we

248
00:15:57,892 --> 00:16:01,166
have queries, for instance like query like here on the left.

249
00:16:01,268 --> 00:16:04,954
So we get user, we want to extract some details for this user.

250
00:16:05,002 --> 00:16:08,958
So we basically join many tables and this query effectively

251
00:16:09,054 --> 00:16:12,642
joins multiple tables. And in turn

252
00:16:12,776 --> 00:16:16,198
this is from one of my production systems, in turn

253
00:16:16,284 --> 00:16:20,230
extracts nearly 300,000 rows. Even though

254
00:16:20,300 --> 00:16:23,266
we extract data just for one user,

255
00:16:23,458 --> 00:16:27,382
effectively this query was running for around 25

256
00:16:27,436 --> 00:16:31,526
seconds. Why? The problem here is that we join

257
00:16:31,638 --> 00:16:35,910
many tables and because we join many tables we effectively

258
00:16:35,990 --> 00:16:39,306
explode the number of rows we extract from

259
00:16:39,328 --> 00:16:42,862
the database, most of the rows being duplicates. So because

260
00:16:42,916 --> 00:16:47,050
we join those we join data from multiple tables.

261
00:16:47,130 --> 00:16:50,890
We effectively have exponential increase in the number of rows

262
00:16:50,970 --> 00:16:54,702
which are then later translated by our orm library,

263
00:16:54,846 --> 00:16:58,766
mostly discarded, to build just one entity

264
00:16:58,878 --> 00:17:02,402
representing this particular user. And now can

265
00:17:02,456 --> 00:17:05,934
we avoid having an issue like this? Can we somehow

266
00:17:05,982 --> 00:17:09,590
realize that hey, we have a query that is going to be super

267
00:17:09,660 --> 00:17:13,634
smooth in production? The problem with our current approach for DevOps,

268
00:17:13,682 --> 00:17:17,474
for CI CD, for automated testing is that we focus

269
00:17:17,612 --> 00:17:21,578
on correctness of the data. We always

270
00:17:21,664 --> 00:17:25,146
focus on whether the data that we extracted from

271
00:17:25,168 --> 00:17:29,970
the database is correct or not. We do assertions

272
00:17:30,150 --> 00:17:33,818
on the content that we extracted from the database,

273
00:17:33,914 --> 00:17:37,934
but we do not assert the way the data was

274
00:17:37,972 --> 00:17:41,998
extracted. Sometimes even worse. Sometimes we may say that hey,

275
00:17:42,084 --> 00:17:45,374
this is an implementation detail that we shouldn't

276
00:17:45,422 --> 00:17:49,294
care about. We don't care how things are executed by the database

277
00:17:49,342 --> 00:17:52,674
engine as long as the data is correct and this is wrong.

278
00:17:52,792 --> 00:17:56,486
Because yes, we shouldn't care how it's done,

279
00:17:56,588 --> 00:18:00,054
but we need to care whether it's done fast enough.

280
00:18:00,252 --> 00:18:03,862
And for that we need to have ways to

281
00:18:03,916 --> 00:18:06,982
assess that those queries are executed fast

282
00:18:07,036 --> 00:18:10,826
enough and that nothing we changed in our application code is

283
00:18:10,848 --> 00:18:14,346
going to degrade the performance and basically kill it.

284
00:18:14,448 --> 00:18:18,074
So in order to do that, we need to come up with new ways

285
00:18:18,192 --> 00:18:21,546
of testing applications. And I'll speak later how to

286
00:18:21,568 --> 00:18:25,294
achieve that. But apart from just testing the content, we need

287
00:18:25,332 --> 00:18:28,974
to also test the performance of our applications. In this

288
00:18:29,012 --> 00:18:32,634
case, the example, the solution to this problem was rather straightforward.

289
00:18:32,762 --> 00:18:36,734
Instead of just joining all the tables, we basically run multiple

290
00:18:36,782 --> 00:18:40,242
queries that execute multiple SQL statements against

291
00:18:40,296 --> 00:18:43,474
the database. And you may think, okay, this is going

292
00:18:43,512 --> 00:18:46,998
to be way slower because we run eight queries instead of one.

293
00:18:47,084 --> 00:18:51,122
But the reality is it's completely the opposite because we extract

294
00:18:51,186 --> 00:18:54,774
queries that get very small amount of data from

295
00:18:54,812 --> 00:18:58,378
each of these tables and then we join this data

296
00:18:58,464 --> 00:19:02,618
in our application code. This thing actually executes in like

297
00:19:02,784 --> 00:19:05,622
a fraction of seconds in a couple of milliseconds,

298
00:19:05,686 --> 00:19:09,530
so way faster than it executed

299
00:19:09,890 --> 00:19:13,530
when we were running just one single query.

300
00:19:13,690 --> 00:19:17,534
Another example when we may not necessarily see

301
00:19:17,572 --> 00:19:21,294
the performance drops is when we try rewriting our

302
00:19:21,332 --> 00:19:24,366
queries so they are more readable. So we have a thing that is

303
00:19:24,388 --> 00:19:28,414
called CTE, common table expression. Let's say that we have boarding passes

304
00:19:28,542 --> 00:19:32,306
table which contains something like 8 million rows. And what

305
00:19:32,328 --> 00:19:35,862
we would like to get is we would like to get those

306
00:19:35,916 --> 00:19:39,858
boarding passes and calculate the checksum

307
00:19:39,954 --> 00:19:43,398
of the ticket number. Do it twice using MD five

308
00:19:43,484 --> 00:19:46,902
algorithm, just for the sake of showing the performance issues.

309
00:19:47,036 --> 00:19:50,582
So we create a CTE which is kind of like temporary,

310
00:19:50,646 --> 00:19:54,234
named table here called CTE performance, that we

311
00:19:54,272 --> 00:19:57,690
then join three times on the same ticket number,

312
00:19:57,760 --> 00:20:01,934
flight id and boarding number and we get the data for a particular

313
00:20:02,052 --> 00:20:05,882
checksum, right. So this is one of the query

314
00:20:05,946 --> 00:20:10,042
that we cant write this way, but we can also write the same query

315
00:20:10,186 --> 00:20:14,494
without using this CTE. We can basically join boarding passes

316
00:20:14,542 --> 00:20:18,222
three times and then calculate MD five checksum.

317
00:20:18,286 --> 00:20:22,814
In the work condition, those two queries are equivalent.

318
00:20:22,942 --> 00:20:27,058
The difference in performance though is tremendous.

319
00:20:27,234 --> 00:20:31,346
In this case, when we don't use CTE, the query runs

320
00:20:31,378 --> 00:20:35,490
in 8 seconds. When we do use CTE, that's 13

321
00:20:35,570 --> 00:20:38,998
seconds. So this is nearly twice as long

322
00:20:39,164 --> 00:20:42,762
as the previous query. So if we now step into

323
00:20:42,816 --> 00:20:46,170
our system and take query here that we see at the bottom

324
00:20:46,320 --> 00:20:50,266
and decide to rewrite it to the query at the top because it's

325
00:20:50,298 --> 00:20:54,094
more readable, then yes, all our unit tests are

326
00:20:54,132 --> 00:20:57,310
going to still be green because the data

327
00:20:57,380 --> 00:21:01,502
is exactly the same. Those queries extract exactly the same

328
00:21:01,556 --> 00:21:04,606
data. The problem is, again with the performance.

329
00:21:04,718 --> 00:21:08,162
We extract data differently and so we break

330
00:21:08,216 --> 00:21:11,886
the performance of our system. The biggest issue is we won't

331
00:21:11,918 --> 00:21:15,498
learn about that until we go to production.

332
00:21:15,614 --> 00:21:19,110
Why is that? That is because in our local environment

333
00:21:19,530 --> 00:21:22,722
we typically have very few rows,

334
00:21:22,866 --> 00:21:26,006
so we won't see any performance issues. But when

335
00:21:26,028 --> 00:21:29,370
we go to production and we move from like a couple

336
00:21:29,440 --> 00:21:32,902
hundred rows to millions of rows, then we'll

337
00:21:32,966 --> 00:21:36,138
immediately see things are not working well.

338
00:21:36,224 --> 00:21:39,834
But it's going to be very late in our pipeline when we

339
00:21:39,872 --> 00:21:43,310
realize those things are slow moving

340
00:21:43,380 --> 00:21:46,766
on. Another issues that may pop up when we are

341
00:21:46,788 --> 00:21:50,746
dealing with databases is around schema migrations.

342
00:21:50,858 --> 00:21:54,154
So all those issues, whenever we add a column,

343
00:21:54,202 --> 00:21:57,154
we drop a column, we change the column data type.

344
00:21:57,272 --> 00:22:00,898
Whenever we do those things, we risk that we will need to

345
00:22:00,984 --> 00:22:04,466
rewrite the table, meaning that we will need to take the data,

346
00:22:04,568 --> 00:22:08,626
copy it on the site, drop the table, recreate it with proper schema,

347
00:22:08,658 --> 00:22:11,858
take the data back and put it in the table.

348
00:22:11,954 --> 00:22:15,654
And when we are doing that, when the database engine is doing that,

349
00:22:15,772 --> 00:22:18,934
we effectively need to take the database offline.

350
00:22:19,062 --> 00:22:22,810
This table needs to be taken offline and this will lead

351
00:22:22,880 --> 00:22:26,218
to the outage of our system. The problem

352
00:22:26,384 --> 00:22:30,194
with this is we will take our databases

353
00:22:30,342 --> 00:22:33,130
offline when going to production.

354
00:22:33,290 --> 00:22:36,430
Even worse, it's not easy to

355
00:22:36,500 --> 00:22:39,934
stop such a migration when we realize something is wrong,

356
00:22:40,052 --> 00:22:43,178
because we can't just easily roll things back in

357
00:22:43,204 --> 00:22:46,834
case of schema migrations. And the worst part, if we

358
00:22:46,872 --> 00:22:50,482
wanted to avoid issues like this one, is that our

359
00:22:50,536 --> 00:22:53,950
unit tests don't even check schema migrations.

360
00:22:54,030 --> 00:22:57,494
Why is that? That is because all they do is

361
00:22:57,532 --> 00:23:01,574
they verify the content of the database when the database is

362
00:23:01,612 --> 00:23:04,806
already back online. They run against

363
00:23:04,908 --> 00:23:09,010
the living database, so they don't verify stuff

364
00:23:09,100 --> 00:23:12,634
when the schema migration is going through, meaning that

365
00:23:12,672 --> 00:23:16,230
they will always just work either with the old schema

366
00:23:16,310 --> 00:23:19,782
or with the new one, so they won't capture any performance

367
00:23:19,846 --> 00:23:23,598
issues. Not to mention that those performance issues.

368
00:23:23,684 --> 00:23:27,786
Again, if we try figuring finding them in our local environments,

369
00:23:27,898 --> 00:23:31,834
then we probably have a couple of rows which is going to be migrated

370
00:23:31,882 --> 00:23:35,426
very, very fast. Until we go to

371
00:23:35,448 --> 00:23:39,460
bigger databases, we won't see any of those issues.

372
00:23:40,230 --> 00:23:44,546
Yet another problem we may have around the databases is

373
00:23:44,648 --> 00:23:47,826
indexes. Obviously when we finally spot

374
00:23:47,858 --> 00:23:51,750
a problem that something is slow, what we can do is

375
00:23:51,820 --> 00:23:55,542
we can add indexes. We obviously need to answer questions like what

376
00:23:55,596 --> 00:23:59,346
index to add, when to apply it, which columns

377
00:23:59,378 --> 00:24:03,382
to include, et cetera, et cetera. And then we can run our select statements

378
00:24:03,446 --> 00:24:06,918
and verify that yes, they now work much faster.

379
00:24:07,014 --> 00:24:10,414
This is great. The problem with indexes though is that

380
00:24:10,452 --> 00:24:14,654
indexes affect not only the

381
00:24:14,692 --> 00:24:18,206
query that read the data, but also the

382
00:24:18,228 --> 00:24:22,254
queries that modify the data. Meaning that if

383
00:24:22,292 --> 00:24:26,302
we add an index, then yes, we improve the performance

384
00:24:26,366 --> 00:24:30,034
of reading the data, but at the same time we decrease the

385
00:24:30,072 --> 00:24:33,746
performance of modifying the data. And if we tell one

386
00:24:33,768 --> 00:24:38,194
of junior developers, hey, if you have slow query at index,

387
00:24:38,322 --> 00:24:41,926
then we end up with this. We have many, many indexes in

388
00:24:41,948 --> 00:24:45,894
our database that are now competing and slowing us

389
00:24:45,932 --> 00:24:50,042
down. Because yes, it may be that they speed things up

390
00:24:50,096 --> 00:24:53,434
when it comes to select statements, but when it comes to

391
00:24:53,472 --> 00:24:57,178
inserts, updates or deletes, they make it way

392
00:24:57,264 --> 00:25:01,594
slower. Not to mention there is yet another problem with indexes.

393
00:25:01,722 --> 00:25:05,322
When we add an index, we verify that our query

394
00:25:05,386 --> 00:25:08,942
uses the index because we see the performance improvement. That is

395
00:25:08,996 --> 00:25:13,070
cool. But what happens six months later when we change

396
00:25:13,140 --> 00:25:16,410
the query and we do not notice

397
00:25:16,490 --> 00:25:19,874
that the performance dropped? The query may stop using an

398
00:25:19,912 --> 00:25:23,710
index. Maybe the index is not used anymore, not usable

399
00:25:23,790 --> 00:25:26,954
anymore. Maybe we have too many rows and databases.

400
00:25:27,022 --> 00:25:30,946
Engine decides not to use such an index. Maybe we have many indexes,

401
00:25:30,978 --> 00:25:35,378
and generally using an index is inefficient. How do we verify

402
00:25:35,474 --> 00:25:39,270
that during our CI CD pipeline? How do we notice that?

403
00:25:39,340 --> 00:25:42,166
With our unit tests. Again, impossible,

404
00:25:42,278 --> 00:25:45,786
because our unit tests, they focus on the content that we extracted from the

405
00:25:45,808 --> 00:25:49,260
database, not on the way that we extracted the data.

406
00:25:49,710 --> 00:25:53,326
Moving on, orms they include increase the

407
00:25:53,348 --> 00:25:56,942
complexity even more because for instance, we may have n

408
00:25:56,996 --> 00:26:00,526
plus one problem with RmS n plus one means that let's say

409
00:26:00,548 --> 00:26:04,638
that we have aircraft stable that is connected one too many with

410
00:26:04,724 --> 00:26:08,754
seat stable and we would like to get all the aircraft, iterate over

411
00:26:08,792 --> 00:26:12,114
those aircrafts and basically calculate the seats count.

412
00:26:12,232 --> 00:26:16,050
Okay. The problem with this approach is that if our

413
00:26:16,120 --> 00:26:19,526
orm works in so called lazy mode, then we

414
00:26:19,548 --> 00:26:22,726
will have n plus one queries. We will have one query to

415
00:26:22,748 --> 00:26:26,006
load all the aircraft from the database and

416
00:26:26,028 --> 00:26:29,530
then we will have n additional queries for

417
00:26:29,600 --> 00:26:32,586
each of the aircraft to get the number of.

418
00:26:32,608 --> 00:26:36,266
Lets obviously this is going to lead to n plus one

419
00:26:36,288 --> 00:26:39,882
queries, which is inefficient. We could

420
00:26:40,016 --> 00:26:44,282
change that and deal with this whole data using just one query

421
00:26:44,426 --> 00:26:47,754
select with join. The problem is we won't notice

422
00:26:47,802 --> 00:26:51,130
the problems when we are talking, when we are dealing

423
00:26:51,210 --> 00:26:55,042
with unit tests or integration tests, because once

424
00:26:55,096 --> 00:26:58,354
again they just focus on the correctness of the data,

425
00:26:58,472 --> 00:27:02,574
not the performance. But you might say, okay, let's switch

426
00:27:02,622 --> 00:27:06,306
all the queries to always be eager, to always join the data,

427
00:27:06,408 --> 00:27:10,434
to run fast, and then we end up with the query that we already noticed,

428
00:27:10,482 --> 00:27:14,022
we already saw in our slides. That is not working fast because

429
00:27:14,076 --> 00:27:17,314
we join many tables and then we kill the performance.

430
00:27:17,362 --> 00:27:20,810
So it's not a silver bullet. We can't just fix this issue once

431
00:27:20,880 --> 00:27:24,854
and for all and make it work all the time. This just doesn't

432
00:27:24,902 --> 00:27:28,442
work like that. Another problems we have

433
00:27:28,496 --> 00:27:31,754
around Orms is they hide tons of

434
00:27:31,792 --> 00:27:35,674
complexity. They hide what transaction levels we use, what transaction

435
00:27:35,722 --> 00:27:39,214
scope we have when we start a transaction, when we commit it,

436
00:27:39,252 --> 00:27:42,682
when we roll it back, who is in charge of committing

437
00:27:42,746 --> 00:27:46,382
or rolling back the transaction? Can we have nested transactions?

438
00:27:46,446 --> 00:27:49,966
How do we cache data? Can we cache data across nodes?

439
00:27:49,998 --> 00:27:53,314
Do we have connection pooling? Do we use query hints? Do we use many,

440
00:27:53,352 --> 00:27:57,050
many other things? Not to mention migrations.

441
00:27:57,150 --> 00:28:01,314
Is our orm in charge of migrations? What if we have like heterogeneous

442
00:28:01,362 --> 00:28:05,126
applications, many applications, talking to the same data source, who is

443
00:28:05,148 --> 00:28:09,314
in charge of migrations? What happens if the ORm realizes

444
00:28:09,362 --> 00:28:13,370
that the schema is different from expected? Is it going to just

445
00:28:13,440 --> 00:28:16,806
deal with it or is it going to drop the table and recreate

446
00:28:16,838 --> 00:28:21,194
it? So many companies, so many companies actually

447
00:28:21,312 --> 00:28:25,070
face this issue that Orms decided to

448
00:28:25,140 --> 00:28:28,586
drop the table just because it couldn't

449
00:28:28,698 --> 00:28:32,330
reconcile the schema in production. When going to production,

450
00:28:32,410 --> 00:28:35,746
this is something we really should be aware of. How do we test

451
00:28:35,848 --> 00:28:39,230
all of that? How do we deal with migration during testing?

452
00:28:39,310 --> 00:28:43,794
How do we fix errors when we spot those issues? How do we keep

453
00:28:43,832 --> 00:28:47,718
that, maintain that and keep it all those things in place.

454
00:28:47,884 --> 00:28:51,314
Orms are great, but they really increase

455
00:28:51,362 --> 00:28:54,886
the complexity by hiding the complexity. And we

456
00:28:54,908 --> 00:28:58,150
need to be aware of that. And now we come to question,

457
00:28:58,300 --> 00:29:01,466
are tests working? Do they work like we have

458
00:29:01,488 --> 00:29:04,906
the pyramid of tests, we have unit tests, integration, lets end

459
00:29:04,928 --> 00:29:08,602
to end. Lets. And obviously, as I stated many times,

460
00:29:08,736 --> 00:29:12,146
none of them is going to work because those tests,

461
00:29:12,198 --> 00:29:15,838
they focus on the correctness of the data, not on

462
00:29:16,004 --> 00:29:19,914
what data or how we extract the data, not on the performance,

463
00:29:20,042 --> 00:29:23,914
not on whether the indexes were used or whether the query plans

464
00:29:23,962 --> 00:29:27,266
are performant. No, they just focus on the correctness of the

465
00:29:27,288 --> 00:29:30,626
data. So we won't see any of the issues here.

466
00:29:30,728 --> 00:29:34,354
But you may say that hey, we have load tests, so we could

467
00:29:34,392 --> 00:29:38,294
go with load tests and we could really verify the

468
00:29:38,332 --> 00:29:41,826
performance. That is true. There is a problem with load

469
00:29:41,858 --> 00:29:45,366
tests though, or many problems. Let's see a couple of them. First, they are

470
00:29:45,388 --> 00:29:49,094
slow and expensive. They are slow because

471
00:29:49,132 --> 00:29:53,082
to do a successful load test we need to basically run it for

472
00:29:53,136 --> 00:29:56,538
hours, right? They are expensive because we need to

473
00:29:56,544 --> 00:29:59,786
build a separate fleet for those load tests. Not to

474
00:29:59,808 --> 00:30:03,286
mention that we really want to hammer our

475
00:30:03,328 --> 00:30:07,166
machines to verify if they can keep up with high load that we

476
00:30:07,188 --> 00:30:11,182
expect to see in production. So we really need to pay for those

477
00:30:11,236 --> 00:30:15,166
machines, for the traffic, for the cpu and resources for hours.

478
00:30:15,348 --> 00:30:19,170
That is the first thing. Second, it's not easy to even run

479
00:30:19,240 --> 00:30:23,122
proper load tests to get the data, anonymize it,

480
00:30:23,176 --> 00:30:27,078
use it outside of production environment. It is

481
00:30:27,164 --> 00:30:32,642
tricky, especially in phase of GDPR and other confidentiality

482
00:30:32,706 --> 00:30:36,038
policies. So generally doing load tests is

483
00:30:36,124 --> 00:30:41,174
also a pretty demanding

484
00:30:41,222 --> 00:30:44,682
and expensive and hard task. But last but

485
00:30:44,816 --> 00:30:48,346
not least, load lets happen at the very end

486
00:30:48,368 --> 00:30:52,490
of our pipelines just before we go to production.

487
00:30:52,650 --> 00:30:55,934
If they find an issue, this is great,

488
00:30:56,052 --> 00:30:59,630
but it's way too late to fix that issue.

489
00:30:59,780 --> 00:31:02,282
We really need to go back to whiteboard,

490
00:31:02,426 --> 00:31:05,986
fix the design reimplement, the changes,

491
00:31:06,088 --> 00:31:10,158
go through code reviews again, push to pre production environments,

492
00:31:10,254 --> 00:31:13,598
run automated test suits and then repeat load tests.

493
00:31:13,694 --> 00:31:16,934
This is going to take time. We just cant deal with

494
00:31:16,972 --> 00:31:20,246
that. We can't let that happen so late in

495
00:31:20,268 --> 00:31:23,718
the pipeline. We need to change that. Yet another

496
00:31:23,804 --> 00:31:27,842
thingy that we can't deal with during observability

497
00:31:27,986 --> 00:31:31,546
is nonoximal configuration. We need to answer a couple of

498
00:31:31,568 --> 00:31:35,946
questions first, do we have the right solutions in

499
00:31:35,968 --> 00:31:39,034
our databases? Do we use proper indexes like

500
00:31:39,072 --> 00:31:42,766
trigram indexes, JSON B indexes, or indexes that

501
00:31:42,788 --> 00:31:46,606
are tuned to our workload? Do we use

502
00:31:46,708 --> 00:31:50,314
proper databases? Should we use separate

503
00:31:50,362 --> 00:31:54,046
vector database or should we use Pgvector? Should we

504
00:31:54,068 --> 00:31:57,454
have document database or should we just use JSON in

505
00:31:57,492 --> 00:32:01,534
postgres SQL? Should we deal with object oriented

506
00:32:01,582 --> 00:32:05,578
programming? Or maybe should we move the code to the database as stored

507
00:32:05,614 --> 00:32:09,320
procedures? Those are the things that we need to understand,

508
00:32:09,850 --> 00:32:13,606
and not only from the perspective of the correctness of the code,

509
00:32:13,708 --> 00:32:16,210
but also from the performance perspective.

510
00:32:16,370 --> 00:32:19,990
Second thing is, okay, we know we have the right solutions,

511
00:32:20,070 --> 00:32:23,194
but do we have the solutions done right?

512
00:32:23,392 --> 00:32:27,894
How do we deal with maintenance windows, with vacuuming, with the fragmentation,

513
00:32:28,022 --> 00:32:31,914
with inefficient indexes, with configuration that is nonoptimal,

514
00:32:31,962 --> 00:32:35,866
with like misconfigured extensions or connection

515
00:32:35,898 --> 00:32:39,838
pools or whatever else or buffers? Generally those are the things

516
00:32:39,924 --> 00:32:43,950
that can severely affect the performance. And it's

517
00:32:44,030 --> 00:32:47,374
generally even though we use good tools,

518
00:32:47,502 --> 00:32:50,850
we don't get good results. Finally,

519
00:32:51,000 --> 00:32:54,734
load handling, how do we know that we handle

520
00:32:54,782 --> 00:32:59,090
the load properly? How do we know whether we are using efficient hardware,

521
00:32:59,170 --> 00:33:03,154
good hardware configuration, whether we have all those places configured

522
00:33:03,202 --> 00:33:06,098
well? What about differences between regions?

523
00:33:06,194 --> 00:33:10,318
What about differences between continents or locales or countries?

524
00:33:10,434 --> 00:33:14,186
What to do if we need to deal with multitenancy, meaning that

525
00:33:14,208 --> 00:33:18,486
we have two tenants, one of them consumes like very little of resources,

526
00:33:18,598 --> 00:33:22,126
the other one is basically hogging everyone else,

527
00:33:22,308 --> 00:33:25,646
right? How do we deal with that? What to do

528
00:33:25,748 --> 00:33:30,510
if we can't use proper additions or we use databases?

529
00:33:32,210 --> 00:33:36,066
We use non optimal solutions. Just because we have old version of

530
00:33:36,088 --> 00:33:40,242
databases, or old version or lower version, lower editions of

531
00:33:40,376 --> 00:33:44,434
the licensing model, cant we even change the database with

532
00:33:44,472 --> 00:33:48,198
our model? The way we work, those are the things

533
00:33:48,364 --> 00:33:52,198
that even though we do consider them,

534
00:33:52,284 --> 00:33:56,182
like theoretically, we very rarely deal

535
00:33:56,236 --> 00:34:00,170
with them in practice and we very rarely get proper

536
00:34:00,320 --> 00:34:03,722
tooling that supports us in answering those

537
00:34:03,776 --> 00:34:07,546
questions. And here comes the solution. All I

538
00:34:07,568 --> 00:34:11,534
told you, all those inefficiencies, dashboards that do not show

539
00:34:11,572 --> 00:34:14,618
the story, configuration that is unclear,

540
00:34:14,714 --> 00:34:17,854
all of that can really be fixed. We just

541
00:34:17,892 --> 00:34:20,890
need to have proper databases, guardrails.

542
00:34:20,970 --> 00:34:24,450
So let's see how to do that. The very first thing

543
00:34:24,600 --> 00:34:28,146
to build the modern age observability in

544
00:34:28,168 --> 00:34:31,422
DevOps culture is to understand the context.

545
00:34:31,566 --> 00:34:35,734
We need to understand the context. We need to see

546
00:34:35,852 --> 00:34:40,118
what's going on in our systems in order to be able to

547
00:34:40,204 --> 00:34:44,134
efficiently monitor those solutions. The very

548
00:34:44,172 --> 00:34:48,838
first thing to understand is there are many levels of observability

549
00:34:48,934 --> 00:34:52,346
or monitoring or other stuff, and we need to understand the

550
00:34:52,368 --> 00:34:56,294
differences. We start with telemetry. Telemetry is just the ability

551
00:34:56,422 --> 00:34:58,966
to collect signals, logs, traces,

552
00:34:59,078 --> 00:35:03,258
metrics, whatever else. If we have telemetry

553
00:35:03,354 --> 00:35:07,502
in all the places, then we have visibility because

554
00:35:07,556 --> 00:35:11,310
we really can go to any part of the system, use open

555
00:35:11,380 --> 00:35:14,722
telemetry or telemetry in general that is there,

556
00:35:14,856 --> 00:35:17,346
and see what's inside the system.

557
00:35:17,528 --> 00:35:21,710
Then if we start capturing those signals automatically

558
00:35:21,790 --> 00:35:25,506
and constantly and monitor them and introduce

559
00:35:25,538 --> 00:35:29,874
alerting and other stuff, we turn into application performance

560
00:35:29,922 --> 00:35:33,254
management, APM, then we can finally have

561
00:35:33,292 --> 00:35:37,158
dashboards that can show us hey, fire is there

562
00:35:37,244 --> 00:35:40,630
or everything is green. But those dashboards

563
00:35:40,710 --> 00:35:43,830
the way we have them now, they are completely inefficient

564
00:35:43,910 --> 00:35:47,674
because they just swamp us with raw data instead of

565
00:35:47,712 --> 00:35:51,174
showing us the proper understanding. The story that

566
00:35:51,232 --> 00:35:54,954
hey, you changed this code deployed on last Wednesday.

567
00:35:55,082 --> 00:35:59,258
This in turn made the application not use the index anymore

568
00:35:59,354 --> 00:36:03,154
and now we have peak traffic on Saturday evening which led into

569
00:36:03,192 --> 00:36:06,750
different traffic distribution. And that's why your database is slow.

570
00:36:06,830 --> 00:36:10,194
And this is what we call observability. Observability is

571
00:36:10,232 --> 00:36:13,282
the ability to tell what and why,

572
00:36:13,416 --> 00:36:16,914
not only what. Monitoring is just alerting

573
00:36:16,962 --> 00:36:21,154
about errors, swamping with raw data. We need to tune thresholds,

574
00:36:21,202 --> 00:36:23,842
set metrics, set alarms manually.

575
00:36:23,986 --> 00:36:27,342
Observability connects all those dots

576
00:36:27,506 --> 00:36:31,338
and shows it the way we can finally

577
00:36:31,424 --> 00:36:34,922
tell what's the story. We can finally do

578
00:36:34,976 --> 00:36:38,598
all of that. Now if we have proper observability

579
00:36:38,694 --> 00:36:42,046
in place, then we do not need to

580
00:36:42,148 --> 00:36:45,214
have multiple teams dealing with our

581
00:36:45,252 --> 00:36:48,554
databases because if we have proper tooling

582
00:36:48,682 --> 00:36:52,462
then we can just use these tools. We can fix issues on self

583
00:36:52,516 --> 00:36:56,354
serve way because we have tools that tell us what's going on

584
00:36:56,472 --> 00:37:00,274
and those tools can minimize communication, can finally

585
00:37:00,392 --> 00:37:04,146
free and unleash the power of our teams and

586
00:37:04,328 --> 00:37:07,894
can finally make it possible for us to

587
00:37:07,932 --> 00:37:11,462
reshape our organization so we finally have true

588
00:37:11,516 --> 00:37:15,062
DevOps culture. So let's see what

589
00:37:15,116 --> 00:37:18,558
to observe and to understand what we need to observe,

590
00:37:18,594 --> 00:37:22,554
we need to understand how databases work. Databases whenever we

591
00:37:22,592 --> 00:37:26,678
send a query to database, such a query goes through multiple stages,

592
00:37:26,774 --> 00:37:30,090
one of which is planner. Planner is basically

593
00:37:30,160 --> 00:37:34,026
a stage that data when databases engine plans

594
00:37:34,138 --> 00:37:37,742
how to execute the query and it comes up with many

595
00:37:37,796 --> 00:37:41,226
plans and then picks the cheapest one to execute

596
00:37:41,258 --> 00:37:45,026
the query in the fastest possible way. So if we take a

597
00:37:45,048 --> 00:37:48,754
query like this, select star from many tables, we can

598
00:37:48,792 --> 00:37:52,690
always prepend this query with the keyword explain this.

599
00:37:52,760 --> 00:37:56,466
Explain basically tells the database hey,

600
00:37:56,568 --> 00:38:00,374
tell me how you are going to execute this query and it

601
00:38:00,412 --> 00:38:04,022
gives us the query plan. If we now take a look at

602
00:38:04,076 --> 00:38:07,366
what this query plan shows is we see that it

603
00:38:07,388 --> 00:38:10,906
represents many operations. Basically each row in the plan

604
00:38:11,008 --> 00:38:14,730
is an operation. Operation just like scanning the table using

605
00:38:14,800 --> 00:38:18,314
an index, sorting rows, joining two

606
00:38:18,352 --> 00:38:22,122
tables, filtering, et cetera, et cetera. Each operation

607
00:38:22,266 --> 00:38:26,126
also has cost associated with it.

608
00:38:26,228 --> 00:38:29,902
Cost is basically an arbitrary number showing us how

609
00:38:29,956 --> 00:38:33,774
hard it is to execute the operation.

610
00:38:33,902 --> 00:38:37,842
It's not a number of cycles, memory used or nothing

611
00:38:37,896 --> 00:38:41,166
like that. It's just an arbitrary number telling

612
00:38:41,198 --> 00:38:44,894
us how hard this is. The big part is

613
00:38:45,032 --> 00:38:48,642
we can take many plans and pick the cheapest

614
00:38:48,706 --> 00:38:52,514
one in this way to decide

615
00:38:52,562 --> 00:38:56,738
onto using plan that will lead to the fastest

616
00:38:56,834 --> 00:39:00,454
query execution. This is how databases work,

617
00:39:00,572 --> 00:39:03,834
so we can ask the database hey, how are you

618
00:39:03,872 --> 00:39:07,386
going to execute this query? And then based on the execution plan we

619
00:39:07,408 --> 00:39:10,730
get, we can tell whether it's going to use an index or not.

620
00:39:10,880 --> 00:39:15,506
How do we observe this data? Well, we can use opentelemetry.

621
00:39:15,638 --> 00:39:19,422
Open telemetry is basically an open standard that

622
00:39:19,476 --> 00:39:23,086
gives us sdks that we can integrate with our applications

623
00:39:23,118 --> 00:39:26,366
to collect signals like locks, traces, metrics, et cetera,

624
00:39:26,398 --> 00:39:30,450
et cetera. The idea here is that it's standardized, meaning that

625
00:39:30,520 --> 00:39:34,446
most likely your applications already use Opentelemetry

626
00:39:34,558 --> 00:39:38,078
because opentelemetry works with so many languages,

627
00:39:38,174 --> 00:39:41,586
JavaScript, C plus plus Java or JVM

628
00:39:41,618 --> 00:39:45,254
in general net in general Python and others.

629
00:39:45,372 --> 00:39:49,154
Right? What's more, we can enable open telemetry

630
00:39:49,202 --> 00:39:51,842
even without changing our applications.

631
00:39:51,986 --> 00:39:55,754
We can enable open telemetry by dropping the

632
00:39:55,792 --> 00:39:59,366
libraries next to our application in the deployment

633
00:39:59,558 --> 00:40:02,894
and then setting a couple of environment variables that

634
00:40:02,932 --> 00:40:06,302
hey, just enable instrumentation for your

635
00:40:06,356 --> 00:40:10,062
orms, for your web servers and whatnot. You can take open

636
00:40:10,116 --> 00:40:13,938
telemetry and enable telemetry without

637
00:40:14,024 --> 00:40:17,154
modifying a single line of code in your application.

638
00:40:17,352 --> 00:40:20,674
That is really great feature. So we can use

639
00:40:20,712 --> 00:40:24,274
Opentelemetry and we can capture things

640
00:40:24,392 --> 00:40:27,894
that happen in the database. So how do we do that?

641
00:40:28,092 --> 00:40:32,194
The idea is that we have a process software development

642
00:40:32,242 --> 00:40:35,670
lifecycle that works in like many many

643
00:40:35,740 --> 00:40:39,578
steps. So we have our developer writing some code.

644
00:40:39,744 --> 00:40:42,742
They use their local environment, local laptop.

645
00:40:42,806 --> 00:40:46,106
They modify the application code and basically

646
00:40:46,208 --> 00:40:49,706
change the way the application works. They next run the

647
00:40:49,728 --> 00:40:53,690
application locally and the application talks to a local

648
00:40:53,760 --> 00:40:57,470
database. Local databases, which has like a couple

649
00:40:57,540 --> 00:41:00,954
hundreds of rows, runs locally, whether natively

650
00:41:01,002 --> 00:41:04,434
or in Docker, doesn't matter. The application gets the data

651
00:41:04,552 --> 00:41:08,318
and answers to APIs. But then we enable

652
00:41:08,414 --> 00:41:12,354
the application to use open telemetry to send the

653
00:41:12,392 --> 00:41:15,894
trace of what the application did. We send it to

654
00:41:15,932 --> 00:41:19,654
telemetry collector. Telemetry collector can then go

655
00:41:19,692 --> 00:41:23,302
to databases and ask the database hey,

656
00:41:23,436 --> 00:41:27,522
I heard that application was running select star from table

657
00:41:27,666 --> 00:41:31,318
I would like you to tell me how you executed this query,

658
00:41:31,414 --> 00:41:34,874
how would you execute such a select statement? So we

659
00:41:34,912 --> 00:41:38,874
get the execution plan and we can deliver this execution plan

660
00:41:38,992 --> 00:41:42,430
to some centralized platform. What we can do next

661
00:41:42,500 --> 00:41:46,254
is developer can consult this platform or

662
00:41:46,292 --> 00:41:49,614
be notified by this platform or get insights from

663
00:41:49,652 --> 00:41:53,446
this platform telling hey, you have inefficient query

664
00:41:53,498 --> 00:41:57,602
in here or your databases is not going to work well,

665
00:41:57,736 --> 00:42:00,994
right? So you need to change that. We don't need

666
00:42:01,032 --> 00:42:04,910
to run slow and expensive load tests to get

667
00:42:05,000 --> 00:42:08,486
that. We can just get those things without

668
00:42:08,588 --> 00:42:12,726
modifying a single line of our application inside the

669
00:42:12,748 --> 00:42:15,446
developer environment. What we do next?

670
00:42:15,548 --> 00:42:19,190
Next step is finally we decide on the application code,

671
00:42:19,260 --> 00:42:23,142
how it works and we just commit our changes to the repository

672
00:42:23,286 --> 00:42:26,854
or create a pull request or feature branch and our continuous

673
00:42:26,902 --> 00:42:30,206
integration pipeline is going to run tests. We cant

674
00:42:30,228 --> 00:42:34,490
again let the application go talk to the database

675
00:42:34,650 --> 00:42:39,050
answer or execute all the lets. We can again capture

676
00:42:39,210 --> 00:42:43,042
the telemetry and send it to the platform again to

677
00:42:43,096 --> 00:42:47,186
confirm that everything worked the same way and nothing

678
00:42:47,288 --> 00:42:51,422
changed. And what's more, we can also analyze

679
00:42:51,486 --> 00:42:54,954
schema migrations in here because we can integrate

680
00:42:55,022 --> 00:42:58,742
with CI CD pipeline to understand how things

681
00:42:58,796 --> 00:43:02,466
were executed and understand what the schema

682
00:43:02,498 --> 00:43:05,862
migration was supposed to do and how it did

683
00:43:05,916 --> 00:43:09,798
that. So we can analyze those schema migrations.

684
00:43:09,894 --> 00:43:13,354
And again we can notify the developer like

685
00:43:13,392 --> 00:43:17,180
during pull request that hey, you're doing something

686
00:43:17,550 --> 00:43:21,390
risky, something wrong, think twice before doing

687
00:43:21,460 --> 00:43:25,566
that. Finally when we realize all is good, we can

688
00:43:25,668 --> 00:43:29,562
push this code to like main branch and start the deployment

689
00:43:29,626 --> 00:43:33,778
with our CD pipeline, like continuous deployment, our application

690
00:43:33,944 --> 00:43:37,634
is now deployed, it talks to the databases and

691
00:43:37,672 --> 00:43:41,010
we can have yet another tool that

692
00:43:41,080 --> 00:43:44,894
talks to the production databases, extracts the

693
00:43:44,952 --> 00:43:46,790
metrics configuration,

694
00:43:47,930 --> 00:43:51,282
all the things around extensions, around schemas,

695
00:43:51,346 --> 00:43:54,882
around shape of data, around the execution plans,

696
00:43:54,946 --> 00:43:58,970
and deliver that to the platform again to see

697
00:43:59,120 --> 00:44:02,458
what happened. And now the best

698
00:44:02,544 --> 00:44:06,694
part of that, because we capture the data from the production

699
00:44:06,742 --> 00:44:10,134
database, what we can do is

700
00:44:10,272 --> 00:44:13,534
in this part, what we can do is we can tell

701
00:44:13,572 --> 00:44:17,966
the developer, hey, your query was working

702
00:44:18,068 --> 00:44:21,230
fine in your local database,

703
00:44:21,570 --> 00:44:25,246
but in production database you have this many rows

704
00:44:25,358 --> 00:44:29,282
and this is just not going to fly well. So now

705
00:44:29,416 --> 00:44:33,182
we can tell the developer immediately that the query

706
00:44:33,246 --> 00:44:36,726
they run, this is how it executed locally, this is how it

707
00:44:36,748 --> 00:44:40,422
would execute in production. And this finally

708
00:44:40,556 --> 00:44:44,566
closes the loop and shifts left everything

709
00:44:44,668 --> 00:44:48,594
that we need, we now shift left the ownership, we shift

710
00:44:48,642 --> 00:44:52,106
left the maintenance, we avoid issues and we

711
00:44:52,128 --> 00:44:55,610
let developers own their databases. So now

712
00:44:55,760 --> 00:44:59,434
the thingy is platform engineers. They need

713
00:44:59,472 --> 00:45:02,846
to take tools like these, introduce them in

714
00:45:02,868 --> 00:45:06,778
their organizations, and basically let developers

715
00:45:06,874 --> 00:45:10,666
start using them. Software managers can take tools

716
00:45:10,698 --> 00:45:14,782
like these and make sure that their roadmaps are not derailed

717
00:45:14,926 --> 00:45:18,770
because developers will be able to use those

718
00:45:18,840 --> 00:45:22,542
tools and avoid issues. And this is how modern,

719
00:45:22,686 --> 00:45:26,418
efficient observability works with whatever

720
00:45:26,504 --> 00:45:31,218
database you have. Notice there is nothing specific to SQL databases.

721
00:45:31,394 --> 00:45:35,174
We just want to ask the database hey, how you executed such

722
00:45:35,212 --> 00:45:38,502
a query. But this will work with whatever thing you have,

723
00:45:38,556 --> 00:45:42,522
with whatever system you have, as long as the system can self report how

724
00:45:42,576 --> 00:45:45,974
it performs and what's going on. So database

725
00:45:46,022 --> 00:45:49,462
guardrails, they prevent bad code from reaching production

726
00:45:49,606 --> 00:45:53,326
because they let us understand what's happening inside the application and

727
00:45:53,348 --> 00:45:57,194
how things are going to work in production without leaving our local developer

728
00:45:57,242 --> 00:46:00,942
environments. They monitor the system end to end because

729
00:46:00,996 --> 00:46:04,862
they get all the insights from local environments, from continuous integration

730
00:46:04,926 --> 00:46:08,210
pipeline, from continuous deployment, from the

731
00:46:08,280 --> 00:46:12,286
actual production databases. And finally they can troubleshoot

732
00:46:12,318 --> 00:46:15,586
things automatically because they have all the dots and

733
00:46:15,608 --> 00:46:19,138
can connect all of them together and answer this is what's

734
00:46:19,154 --> 00:46:23,026
going on, this is how things behave and this is what changed.

735
00:46:23,138 --> 00:46:26,434
So this is how we can build successful databases,

736
00:46:26,482 --> 00:46:29,990
guardrails and in turn effective observability.

737
00:46:30,330 --> 00:46:33,754
In order to do that, we really need to be proactive and we really

738
00:46:33,792 --> 00:46:37,722
need to push to the left. We need to lets developers own their

739
00:46:37,776 --> 00:46:41,146
databases, but we can't just swamp them with raw

740
00:46:41,178 --> 00:46:45,706
data and metrics that we have now. We need to build and introduce tools

741
00:46:45,818 --> 00:46:49,658
that can do that and cant turn monitoring

742
00:46:49,754 --> 00:46:52,922
into observability, can turn seeing

743
00:46:53,076 --> 00:46:56,706
into understanding. And this is exactly what Matis does.

744
00:46:56,808 --> 00:47:00,722
Let me really quickly walk you through the

745
00:47:00,776 --> 00:47:04,402
system that we have at Matis and what it is capable of.

746
00:47:04,536 --> 00:47:08,114
So when you integrate with Matis, when you register with Matis,

747
00:47:08,162 --> 00:47:11,446
you create a project that captures all the interactions with

748
00:47:11,468 --> 00:47:14,390
your database. So for instance, we can see that, hey,

749
00:47:14,460 --> 00:47:18,742
your application exposes this API. If you run

750
00:47:18,796 --> 00:47:22,806
this API, this is the SQL statement that has been executed.

751
00:47:22,918 --> 00:47:26,282
This is the visualization of the query and what happened.

752
00:47:26,416 --> 00:47:30,090
Couple of statistics. But most importantly we tell you, hey,

753
00:47:30,160 --> 00:47:33,966
you are using table scans here and there and this is basically going to

754
00:47:33,988 --> 00:47:38,074
be slow. And we tell you what's the impact and how to remediate

755
00:47:38,122 --> 00:47:41,914
that. We show you how many rows were read, how many rows were returned,

756
00:47:41,962 --> 00:47:45,298
how the query was executed, and in the best way

757
00:47:45,384 --> 00:47:48,834
we just tell you how to fix that. We integrate with

758
00:47:48,872 --> 00:47:51,870
CI CD. So apart from analyzing performance,

759
00:47:51,950 --> 00:47:55,294
we can for instance look for like schema migration

760
00:47:55,422 --> 00:47:58,754
and we can show you that hey, you would like to drop an index,

761
00:47:58,802 --> 00:48:03,110
but notice this index was used in production over

762
00:48:03,180 --> 00:48:06,914
6000 times in last seven days. So this index

763
00:48:06,962 --> 00:48:10,330
is probably something you shouldn't drop because it is being

764
00:48:10,400 --> 00:48:13,610
used. Figure out whether it uses

765
00:48:14,430 --> 00:48:17,786
how the index is used instead of just dropping that.

766
00:48:17,888 --> 00:48:21,390
But we can do even more. We can see the

767
00:48:21,460 --> 00:48:24,494
monitor, the database, and for instance, we can show you,

768
00:48:24,532 --> 00:48:28,282
obviously infrastructure metrics, just like cpu memory,

769
00:48:28,346 --> 00:48:32,282
throughput, et cetera, et cetera. But we can also analyze database

770
00:48:32,346 --> 00:48:34,970
oriented metrics. We can show number of transactions,

771
00:48:35,050 --> 00:48:38,702
rows, cache hits, et cetera, et cetera. We can analyze

772
00:48:38,766 --> 00:48:41,906
schema, we can analyze indexes, for instance. We can show you,

773
00:48:41,928 --> 00:48:45,790
hey, those are the indexes and they haven't been used quite recently,

774
00:48:45,870 --> 00:48:49,686
right? Maybe consider dropping those indexes, right? But we

775
00:48:49,708 --> 00:48:53,014
can also show you like top queries. Those are the queries that

776
00:48:53,052 --> 00:48:56,246
have been executed quite recently, right? This is

777
00:48:56,268 --> 00:48:59,650
like the anomaly that we can detect with queries.

778
00:48:59,730 --> 00:49:03,018
And we can show you other stuff. We can show you like insights around the

779
00:49:03,024 --> 00:49:06,166
queries. We can show you execution plan and visualization.

780
00:49:06,358 --> 00:49:09,626
All we do, we can show you all of that,

781
00:49:09,728 --> 00:49:13,258
capture that and build this true observability

782
00:49:13,434 --> 00:49:16,734
and understanding. So this is what we need.

783
00:49:16,932 --> 00:49:20,686
We need a solution that integrates with the source code,

784
00:49:20,788 --> 00:49:24,990
with CI CD, with our activity

785
00:49:25,070 --> 00:49:28,414
that we run locally or in pipelines or in production.

786
00:49:28,542 --> 00:49:32,734
We need to have proper observability that analyzes

787
00:49:32,782 --> 00:49:35,954
the metrics and figures out anomalies, and can do that

788
00:49:35,992 --> 00:49:38,934
like automatically or on demand or whatever else.

789
00:49:39,052 --> 00:49:42,918
And this is modern observability in

790
00:49:43,004 --> 00:49:46,614
databases. This is how we would like to do that. This is how we can

791
00:49:46,652 --> 00:49:50,790
do that using the solutions we saw during this presentation.

792
00:49:50,950 --> 00:49:54,602
In summary, databases may break for so many

793
00:49:54,656 --> 00:49:57,110
reasons. And our unit tests,

794
00:49:57,270 --> 00:50:01,326
integration tests, or generally automated tests do not capture those issues

795
00:50:01,428 --> 00:50:05,054
because they focus on correctness, not on how

796
00:50:05,092 --> 00:50:08,282
the data was extracted. And even load tests,

797
00:50:08,346 --> 00:50:11,774
they happen way too late. They are

798
00:50:11,812 --> 00:50:15,442
very expensive, and if they found issues, then we need to start

799
00:50:15,496 --> 00:50:19,314
from scratch. So we waste much time. In order

800
00:50:19,352 --> 00:50:22,866
to build a proper DevOps culture, we need

801
00:50:22,888 --> 00:50:26,238
to minimize communication. We need to build teams

802
00:50:26,334 --> 00:50:29,862
that can deal with all the issues without the need

803
00:50:29,916 --> 00:50:33,750
to go to other teams to ask for permissions or access

804
00:50:33,820 --> 00:50:36,802
to something. But in order to build these teams,

805
00:50:36,946 --> 00:50:41,114
we need to have tools that will let them see everything,

806
00:50:41,312 --> 00:50:44,774
reason about the system, and finally self serve

807
00:50:44,822 --> 00:50:48,458
all the issues. And I showed you how to build those things,

808
00:50:48,544 --> 00:50:52,394
and Matthews obviously covers all of that. So this is how we build effective

809
00:50:52,442 --> 00:50:55,774
observability for databases, no matter whether

810
00:50:55,812 --> 00:50:59,278
it's postgres, MySql or anything else. And being all of

811
00:50:59,284 --> 00:51:03,214
that said, I'd like to thank you for attending this talk. I hope you

812
00:51:03,252 --> 00:51:06,538
enjoyed it. Hope you learned something useful.

813
00:51:06,634 --> 00:51:10,494
I encourage you to take a look at Matisdata IO, join our

814
00:51:10,532 --> 00:51:14,430
discord channel, ask questions and let's stay in touch. Thank you

815
00:51:14,500 --> 00:51:16,980
and enjoy the rest of your conference. Thank you.

