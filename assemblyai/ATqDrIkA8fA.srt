1
00:00:25,410 --> 00:00:28,786
You. Today I'm going to be discussing adding

2
00:00:28,818 --> 00:00:32,326
JavaScript to HTML forms to give them superpowers. Before we get

3
00:00:32,348 --> 00:00:35,282
too far, I want to explain what I consider to be superpowers.

4
00:00:35,346 --> 00:00:39,554
Those are going to be user experience improvements that do not negatively impact

5
00:00:39,682 --> 00:00:42,242
functionality, native functionality,

6
00:00:42,386 --> 00:00:45,320
accessibility, semantics, performance or security.

7
00:00:46,090 --> 00:00:49,750
This is also commonly referred to as progressive enhancement.

8
00:00:50,610 --> 00:00:54,126
So, getting to JavaScript the first rule of JavaScript is knowing when

9
00:00:54,148 --> 00:00:57,040
to use it, and therefore knowing when not to use it.

10
00:00:57,410 --> 00:01:00,474
JavaScript itself has some inherent costs when we decide

11
00:01:00,522 --> 00:01:04,446
whether or not to add it to a page. So HTML and CSS are generally

12
00:01:04,478 --> 00:01:08,466
going to be faster, except for special occasions. And at

13
00:01:08,488 --> 00:01:12,434
the point that we decide to start adding JavaScript, we may start incurring things

14
00:01:12,472 --> 00:01:16,502
like extra HTTP requests, more data

15
00:01:16,556 --> 00:01:20,226
to download. We might have JavaScript that blocks some rendering

16
00:01:20,258 --> 00:01:24,354
performance or rendering time, JavaScript that has runtime

17
00:01:24,402 --> 00:01:28,066
performance issues. We may have JavaScript that has unexpected

18
00:01:28,098 --> 00:01:31,706
errors or exceptions that prevent the rest of the script from running,

19
00:01:31,888 --> 00:01:35,366
and it's possible that JavaScript may be disabled or blocked

20
00:01:35,398 --> 00:01:38,582
by a user. Now, HTML,

21
00:01:38,646 --> 00:01:41,958
on the other hand, natively gives us a lot we

22
00:01:41,984 --> 00:01:45,706
have some concept of state management in the inputs

23
00:01:45,738 --> 00:01:49,214
values. We have clickable labels without needing to add any

24
00:01:49,252 --> 00:01:53,186
sort of JavaScript to click something and make a label focused we

25
00:01:53,208 --> 00:01:57,118
have accessibility built in for keyboard navigation,

26
00:01:57,214 --> 00:02:00,100
focus states, screen reader support.

27
00:02:01,590 --> 00:02:05,022
We have consistent experience across browsers and devices.

28
00:02:05,086 --> 00:02:08,950
If a user uses a radio or checkbox in one browser and

29
00:02:09,100 --> 00:02:13,522
should behave the same in another. Those is also great for users that prefer

30
00:02:13,666 --> 00:02:17,626
using the keyboard to fill out forms. And we have

31
00:02:17,648 --> 00:02:21,420
benefits for things like implicit submission, which we can discuss later.

32
00:02:22,030 --> 00:02:25,766
Lastly, that's going to be a recurring theme is validation.

33
00:02:25,878 --> 00:02:29,420
Now, validation built into HTML costs us zero,

34
00:02:29,870 --> 00:02:33,774
and it has quite a good number of resources available to

35
00:02:33,812 --> 00:02:38,138
us. Another benefit of the built in validation attributes

36
00:02:38,234 --> 00:02:42,106
is they could hint to assistive technology, things like whether an input

37
00:02:42,138 --> 00:02:45,810
is required now between or

38
00:02:45,880 --> 00:02:49,042
when we're building HTML forms, we're really looking at two different things,

39
00:02:49,096 --> 00:02:52,162
the inputs or the controls, and those form itself.

40
00:02:52,296 --> 00:02:56,114
We'll start by looking at the individual inputs built

41
00:02:56,152 --> 00:02:59,494
into the browser. We have 24 different options if you account for

42
00:02:59,532 --> 00:03:02,914
all of the input types, text areas, selects,

43
00:03:03,042 --> 00:03:06,226
et cetera. So when I browse the Internet,

44
00:03:06,258 --> 00:03:10,226
I still wonder why I see things like this. A div that's designed

45
00:03:10,258 --> 00:03:13,962
to look like a checkbox and has some Javascript event listener, it says

46
00:03:14,016 --> 00:03:17,318
I'm a checkbox. One of the reasons

47
00:03:17,334 --> 00:03:20,886
we still see this probably has to do with styling. In 2019,

48
00:03:20,998 --> 00:03:25,040
Greg Whitworth did a survey he asked. He got

49
00:03:25,490 --> 00:03:29,566
1400 respondents and of them the

50
00:03:29,588 --> 00:03:33,098
most common reason people create their own native controls

51
00:03:33,194 --> 00:03:36,818
or recreate native controls is for styling with the

52
00:03:36,824 --> 00:03:39,780
number one control that they recreate being the select.

53
00:03:40,150 --> 00:03:44,100
You can see more at this URL. The slides will be available.

54
00:03:45,750 --> 00:03:49,014
In that discussion he points out that the amount of work it takes

55
00:03:49,052 --> 00:03:53,350
to implement an accessible alternative with complete feature parity is massive.

56
00:03:53,850 --> 00:03:57,446
And here's an example of that. If we want to take that previous checkbox and

57
00:03:57,468 --> 00:04:00,978
make it a little bit more on par with

58
00:04:01,004 --> 00:04:04,234
what we get built in, we can see that we have

59
00:04:04,352 --> 00:04:08,022
a class to add, some styling to make it look like a checkbox, some ARIa

60
00:04:08,086 --> 00:04:11,626
attributes for assistive technology, we have some tab

61
00:04:11,658 --> 00:04:14,570
index for keyboard navigation,

62
00:04:14,730 --> 00:04:18,078
and we have two event listeners, one for clicks with a

63
00:04:18,084 --> 00:04:20,750
mouse, one for key downs.

64
00:04:22,050 --> 00:04:25,454
Compare that to the native solution

65
00:04:25,582 --> 00:04:28,130
which is an input with a label.

66
00:04:29,350 --> 00:04:33,166
Looks like more work to me, and this isn't even considering the Javascript

67
00:04:33,198 --> 00:04:36,950
that goes into those event bundles. And it's not the most complex

68
00:04:37,610 --> 00:04:41,190
form component to recreate like radios or

69
00:04:41,260 --> 00:04:44,598
selects. So the good news is, when it

70
00:04:44,604 --> 00:04:47,558
comes to styling, it's better than it used to be.

71
00:04:47,724 --> 00:04:51,690
CSS gives us a lot of pseudo classes to work with based on the

72
00:04:51,760 --> 00:04:55,526
state of the input. We also have features

73
00:04:55,558 --> 00:04:58,986
like appearance none and pseudo elements that

74
00:04:59,008 --> 00:05:02,320
let us create custom checkboxes and radios. For example,

75
00:05:02,850 --> 00:05:06,302
we can use tricks like a visually hidden input and then

76
00:05:06,356 --> 00:05:10,382
target a sibling selector to make something look cool

77
00:05:10,436 --> 00:05:13,906
based on what that input is doing. And there's more information at

78
00:05:13,928 --> 00:05:17,186
my blog. Again, the links will be available in

79
00:05:17,208 --> 00:05:20,910
the slides if you need. Here are a couple examples

80
00:05:20,990 --> 00:05:25,806
of some totally custom looking UI

81
00:05:25,918 --> 00:05:29,830
form components. All of these can be accomplished with just

82
00:05:29,900 --> 00:05:33,560
HTML and CSS. No need for Javascript for things like this.

83
00:05:34,730 --> 00:05:37,110
The other good news is that the future is bright.

84
00:05:37,470 --> 00:05:40,890
There's people discussing potentially bringing things like

85
00:05:40,960 --> 00:05:44,566
new pseudo selectors and parts so that we can style

86
00:05:44,678 --> 00:05:47,930
things like the select drop down which is a complex component

87
00:05:49,230 --> 00:05:51,290
more specifically,

88
00:05:52,290 --> 00:05:55,534
and potentially things like name slots. So if we

89
00:05:55,572 --> 00:05:59,402
want, we could take those selects and be able to customize

90
00:05:59,466 --> 00:06:02,670
the individual aspects of it by providing our own markup.

91
00:06:03,090 --> 00:06:06,226
This is just an example, which I guess you can do with emojis, but you

92
00:06:06,248 --> 00:06:09,774
get the idea. There's more details

93
00:06:09,822 --> 00:06:14,222
about those things that may be coming down the line if you go to openui.org.

94
00:06:14,286 --> 00:06:16,360
A lot of discussion going on there as well.

95
00:06:17,530 --> 00:06:20,822
There's some editorial proposals, forms, select checkbox and

96
00:06:20,876 --> 00:06:24,326
file as of today. There's other editorial proposals, but these are

97
00:06:24,348 --> 00:06:26,790
the ones that relate to forms.

98
00:06:27,690 --> 00:06:31,702
Now you may be wondering yourself, I thought this was a Javascript conference.

99
00:06:31,766 --> 00:06:35,786
What's the deal? And the good news is that Javascript is

100
00:06:35,808 --> 00:06:39,382
actually really good for taking what we have natively and improving

101
00:06:39,446 --> 00:06:42,974
upon it without breaking something. We can take that

102
00:06:43,012 --> 00:06:47,214
native form validation that we were discussing, and we can customize the

103
00:06:47,332 --> 00:06:50,618
message or manually

104
00:06:50,714 --> 00:06:54,798
trigger it. We can also do things that HTML

105
00:06:54,814 --> 00:06:59,006
alone cannot do, such as toggling aria well, for accessibility

106
00:06:59,118 --> 00:07:03,010
toggling aria invalid or aria disabled attributes,

107
00:07:03,910 --> 00:07:08,214
we can provide improved user experiences by

108
00:07:08,412 --> 00:07:12,306
doing things like an input that's a password input

109
00:07:12,338 --> 00:07:16,086
that you can toggle, whether the visibility of the password or a

110
00:07:16,108 --> 00:07:20,310
text area that automatically expands and shrinks based on how much content

111
00:07:20,380 --> 00:07:23,894
is in there, or a phone input

112
00:07:23,942 --> 00:07:27,946
that does the masking and formatting to show that it's a phone number.

113
00:07:28,128 --> 00:07:32,078
Of course you want to do all this in a way that doesn't detract from

114
00:07:32,084 --> 00:07:36,074
the user experience. And lastly, getting back to the conversation

115
00:07:36,122 --> 00:07:40,474
of validation, we may want to provide our own custom UI for validation

116
00:07:40,522 --> 00:07:43,854
messages. So looking into that,

117
00:07:44,052 --> 00:07:47,826
the browser has built into it without anything else that

118
00:07:47,848 --> 00:07:50,850
we need to reach out for a third party library.

119
00:07:51,430 --> 00:07:55,106
The validity state web API, which is one of my favorites. If you

120
00:07:55,128 --> 00:07:59,254
have an input dom node, it's right on the validity property

121
00:07:59,372 --> 00:08:02,886
and it gives you an object with all of

122
00:08:02,908 --> 00:08:06,514
these different properties that are true or false

123
00:08:06,562 --> 00:08:10,470
based on whether the corresponding HTML attributes

124
00:08:10,550 --> 00:08:14,570
are valid or not. We can use this

125
00:08:14,720 --> 00:08:18,342
API to do things like toggle the Aria

126
00:08:18,406 --> 00:08:21,626
Invalid state, or we can add

127
00:08:21,808 --> 00:08:25,946
maybe like a Div or a list of error messages and associate

128
00:08:25,978 --> 00:08:29,594
that to the input with Aria described by and give it a live region

129
00:08:29,642 --> 00:08:33,730
so that assistive technology users are updated.

130
00:08:35,030 --> 00:08:38,882
So with the inputs kind of covered now we can transition over

131
00:08:38,936 --> 00:08:42,834
to forms. Now forms are going to be a little bit

132
00:08:42,872 --> 00:08:46,494
different because forms don't have a built in

133
00:08:46,552 --> 00:08:50,294
UI that you have to deal with. And so some

134
00:08:50,332 --> 00:08:54,534
people omit them all together and will do something like an

135
00:08:54,572 --> 00:08:58,154
input that you just press the enter key on and it

136
00:08:58,272 --> 00:09:02,086
does something. Now I would argue that almost every input

137
00:09:02,118 --> 00:09:06,422
would actually benefit from having a form HTML tag wrapped

138
00:09:06,486 --> 00:09:10,662
around it, because it can give us some additional features

139
00:09:10,726 --> 00:09:13,280
without with actually doing less work,

140
00:09:13,810 --> 00:09:16,926
things like that native validation that we just talked about,

141
00:09:17,108 --> 00:09:20,270
that only works if we have an input inside of a form

142
00:09:20,420 --> 00:09:24,686
element, the implicit return, which is when

143
00:09:24,708 --> 00:09:28,034
we compared to a JavaScript event listener that looks

144
00:09:28,072 --> 00:09:31,346
for the key down event and checks if it's the enter key and

145
00:09:31,368 --> 00:09:34,866
then does a fetch request. We can get all that built in by

146
00:09:34,888 --> 00:09:38,246
just putting a text input and a form. When you hit

147
00:09:38,268 --> 00:09:40,600
the enter key, it's going to submit the form.

148
00:09:42,170 --> 00:09:46,550
We can simplify the JavaScript

149
00:09:47,210 --> 00:09:50,694
API request by using a form tag.

150
00:09:50,742 --> 00:09:54,778
So if we want to send Ajax requests, we can actually

151
00:09:54,944 --> 00:09:58,666
make it easier on ourselves by using an HTML form. We also

152
00:09:58,688 --> 00:10:02,122
get resiliency, again, going back to that idea that Javascript

153
00:10:02,186 --> 00:10:05,454
may experience an error and you probably want to fall back

154
00:10:05,492 --> 00:10:09,146
to HTML to submit forms if your Ajax

155
00:10:09,178 --> 00:10:11,360
request is not available, right?

156
00:10:12,690 --> 00:10:16,610
So assuming that we're using forms,

157
00:10:17,590 --> 00:10:20,226
we can do the same thing that we did with inputs where we can take

158
00:10:20,248 --> 00:10:23,826
JavaScript and enhance upon the native experience. Because some

159
00:10:23,848 --> 00:10:27,650
people don't want to submit all of their forms with the native

160
00:10:27,810 --> 00:10:30,390
experience, which is a page refresh.

161
00:10:31,450 --> 00:10:35,494
So some things that we can do that are in addition to the

162
00:10:35,532 --> 00:10:39,590
native experience might be keyboard shortcuts like control

163
00:10:39,660 --> 00:10:43,034
enter to submit the form. When you're focused on a text area, which is not

164
00:10:43,072 --> 00:10:46,854
possible with just HTML, we can have repeater input

165
00:10:46,902 --> 00:10:51,258
fields. So think of a collection of a few inputs that you can make

166
00:10:51,344 --> 00:10:54,446
multiple copies of. Thinking if you have like an

167
00:10:54,468 --> 00:10:58,382
ecommerce site and you want to have a product name, price and

168
00:10:58,436 --> 00:11:01,280
picture, and you want to add many of them at the same time,

169
00:11:02,450 --> 00:11:05,666
drag and drop is a common thing that we can do with JavaScript that we

170
00:11:05,688 --> 00:11:09,234
can't do with HTML, and maybe that lives within a form

171
00:11:09,352 --> 00:11:13,106
somewhere, I don't know. Then we

172
00:11:13,128 --> 00:11:17,106
can have again the custom validation user experience if

173
00:11:17,128 --> 00:11:20,070
you don't want to rely on the native validation,

174
00:11:21,290 --> 00:11:25,414
because looking at the native validation, this is what it looks like, we might

175
00:11:25,612 --> 00:11:28,566
try and submit this form. It's a required field, and we get a pop up

176
00:11:28,588 --> 00:11:31,814
that says please fill out this field. And native validation

177
00:11:31,862 --> 00:11:35,446
is actually quite useful in terms of the features that it provides.

178
00:11:35,638 --> 00:11:38,746
One thing is when we submit an invalid form, it focuses on

179
00:11:38,768 --> 00:11:42,446
the first invalid input, which brings our

180
00:11:42,468 --> 00:11:46,270
focus there. As an added benefit of the focus going

181
00:11:46,340 --> 00:11:50,314
there, we will actually also scroll there, the browser

182
00:11:50,362 --> 00:11:54,002
will scroll to that input. So if the form is long enough to take up

183
00:11:54,056 --> 00:11:57,394
greater than the screen of the browser, and you hit that

184
00:11:57,432 --> 00:12:01,134
submit button, you want to scroll to the input

185
00:12:01,182 --> 00:12:04,622
that is invalid. And naturally,

186
00:12:04,686 --> 00:12:08,278
or obviously it explains to the user what

187
00:12:08,364 --> 00:12:12,070
the error is with the form or with the input.

188
00:12:12,810 --> 00:12:16,306
Now there's just one problem with the native UI, and that is that there's

189
00:12:16,338 --> 00:12:20,166
not really a good way to customize it. So if we care about branding,

190
00:12:20,198 --> 00:12:22,634
we may want to be able to do that.

191
00:12:22,832 --> 00:12:26,630
And I think about this as why not supporting

192
00:12:26,710 --> 00:12:31,738
both? Why not take the native HTML validation

193
00:12:31,834 --> 00:12:35,278
constraints and tap into those

194
00:12:35,364 --> 00:12:38,080
using JavaScript to enhance upon it.

195
00:12:39,170 --> 00:12:43,202
This way, if JavaScript does get disabled, our form

196
00:12:43,336 --> 00:12:46,754
validation logic will still work because it falls back to the

197
00:12:46,792 --> 00:12:50,722
native HTML one. There's also less to

198
00:12:50,776 --> 00:12:54,622
learn because compared to a third party library

199
00:12:54,686 --> 00:12:58,306
for validation, we don't have to learn what their API is,

200
00:12:58,328 --> 00:13:02,006
we just learn what's native to the browser and there's no need

201
00:13:02,108 --> 00:13:05,446
know. If you learn one library and then decide to move on to the next

202
00:13:05,468 --> 00:13:08,780
one, they have a completely different API right,

203
00:13:09,470 --> 00:13:13,114
compared to libraries. Again, we probably will have

204
00:13:13,152 --> 00:13:16,694
less to download as well, which would improve performance.

205
00:13:16,822 --> 00:13:20,650
Also make maintenance easier because we don't have some third party dependency

206
00:13:20,730 --> 00:13:23,040
that we have to keep up to date,

207
00:13:24,370 --> 00:13:28,174
and it could potentially improve security by

208
00:13:28,372 --> 00:13:32,726
not having to deal with NPM vulnerabilities that intentional

209
00:13:32,778 --> 00:13:34,130
or unintentional.

210
00:13:35,990 --> 00:13:40,210
Now the last point is that validation logic really

211
00:13:40,280 --> 00:13:44,020
doesn't belong entirely on the front end.

212
00:13:44,890 --> 00:13:49,026
You don't want the business logic of your application relying on clientside validation

213
00:13:49,138 --> 00:13:52,578
because it's possible to make form submissions

214
00:13:52,674 --> 00:13:55,720
outside of the front end anyway,

215
00:13:56,810 --> 00:14:00,034
and so you're going to be doing validation on the back end.

216
00:14:00,092 --> 00:14:03,334
So there's really not a need to have a whole robust solution

217
00:14:03,382 --> 00:14:07,094
on the front end, just something that improves those user

218
00:14:07,142 --> 00:14:10,730
experience but doesn't necessarily need to be super robust.

219
00:14:11,950 --> 00:14:14,986
There are occasions when you might still consider a third party library.

220
00:14:15,018 --> 00:14:18,654
I'm not saying you shouldn't use them, but I like

221
00:14:18,692 --> 00:14:22,126
to start with the native things and enhance on it a little

222
00:14:22,148 --> 00:14:25,874
bit before I need to reach for a third party. Now,

223
00:14:25,912 --> 00:14:29,860
looking at rolling our own sort of custom validation experience,

224
00:14:30,310 --> 00:14:34,494
the first thing we want to do is prevent the default native validation

225
00:14:34,542 --> 00:14:38,086
UI from occurring. The way we can do that is by

226
00:14:38,268 --> 00:14:41,926
adding those no validate property onto our form so that

227
00:14:41,948 --> 00:14:45,622
it tells the Browser hey, don't bother validating this

228
00:14:45,756 --> 00:14:48,954
now. We want to do that with JavaScript because that means JavaScript is

229
00:14:48,992 --> 00:14:49,930
enabled.

230
00:14:51,470 --> 00:14:54,906
Next we want

231
00:14:54,928 --> 00:14:58,486
to listen to a submit event and we want to scroll

232
00:14:58,518 --> 00:15:01,966
to that first input, the first invalid input. So we can do

233
00:15:01,988 --> 00:15:06,766
that by on submit checking if

234
00:15:06,788 --> 00:15:10,602
the form is valid or invalid. We can do that with the check validity method

235
00:15:10,666 --> 00:15:14,622
on the form DoM node it returns a boolean

236
00:15:14,766 --> 00:15:18,482
and if the form is not valid then we

237
00:15:18,536 --> 00:15:22,366
can do a query selector for the first invalid input

238
00:15:22,398 --> 00:15:26,194
and focus on it. That's also going to maintain parity with

239
00:15:26,232 --> 00:15:29,986
the native HTML experience where it focuses

240
00:15:30,018 --> 00:15:33,346
on it, and because it's focused it will scroll to it as well. If it's

241
00:15:33,378 --> 00:15:37,014
invalid, we can return early if it's not invalid, we can

242
00:15:37,052 --> 00:15:40,506
go ahead and do the submission or the

243
00:15:40,528 --> 00:15:44,342
logic to submit our form, maybe with a fetch request.

244
00:15:44,486 --> 00:15:47,866
We also want to prevent the default behavior, which would be the

245
00:15:47,888 --> 00:15:50,810
browser refreshing and sending that request.

246
00:15:53,330 --> 00:15:57,306
Next we can look at what does that API

247
00:15:57,338 --> 00:16:00,718
request look like? Or sending that fetch request. Now I want to look at

248
00:16:00,724 --> 00:16:04,034
this in a way that maintains feature parity, and we can actually

249
00:16:04,072 --> 00:16:07,490
use this on whatever form we want.

250
00:16:07,560 --> 00:16:11,586
We don't need to have a specific fetch event

251
00:16:11,688 --> 00:16:15,182
for the login form versus the register forms versus

252
00:16:15,246 --> 00:16:17,880
whatever form. We can use the same thing on all of them.

253
00:16:18,490 --> 00:16:21,846
So this function might look like this. We'll start by

254
00:16:21,948 --> 00:16:25,346
listening to a form submission event. We'll grab

255
00:16:25,378 --> 00:16:29,082
the form Dom node out of the event target. We'll start building

256
00:16:29,136 --> 00:16:32,410
out our fetch parameters based on the form

257
00:16:32,480 --> 00:16:35,914
attributes. So we'll get the URL from the action. We'll get those form

258
00:16:35,952 --> 00:16:38,250
method from the form method.

259
00:16:38,990 --> 00:16:42,254
Then we'll capture the data from our

260
00:16:42,292 --> 00:16:46,910
inputs in that forms using the form data web API.

261
00:16:47,250 --> 00:16:50,846
We don't need to do anything more to capture the information as long as our

262
00:16:50,868 --> 00:16:55,060
inputs are semantically written and have a name and everything.

263
00:16:56,470 --> 00:17:00,318
We can also capture data in the form of a URL search params,

264
00:17:00,414 --> 00:17:04,258
which will make more sense in a moment. We want to

265
00:17:04,264 --> 00:17:08,150
do a check whether this form's encoding type is multi part

266
00:17:08,220 --> 00:17:12,086
form data. If that doesn't make sense to you, it basically kind

267
00:17:12,108 --> 00:17:14,840
of comes down to whether we're sending a file or not,

268
00:17:15,770 --> 00:17:18,390
but it's not the default encoding type,

269
00:17:18,460 --> 00:17:21,260
so we'll get to that in a moment as well.

270
00:17:21,870 --> 00:17:25,082
Next, the forms can have

271
00:17:25,136 --> 00:17:28,186
a get request, can send a get request or a post request. So we

272
00:17:28,208 --> 00:17:31,486
want to check whether it's a get request. If it's a get request, we want

273
00:17:31,508 --> 00:17:35,082
to send our data by means of URL

274
00:17:35,146 --> 00:17:39,246
search string parameters. So we'll take the URL that we had and

275
00:17:39,268 --> 00:17:43,200
we'll append onto it the query string parameters for

276
00:17:43,810 --> 00:17:47,102
that payload. I think I actually missed the little question mark

277
00:17:47,156 --> 00:17:50,658
there, but that's all right. If it's not a get request, we know

278
00:17:50,664 --> 00:17:53,906
it's supposed to be a post request, which means we'll put our payload in those

279
00:17:53,928 --> 00:17:57,966
body of the request and we can check whether it's a multipart

280
00:17:57,998 --> 00:18:01,958
form data. If it is, we can send it with the forms data object.

281
00:18:02,044 --> 00:18:05,474
If it's not, we can send it with the URL search parameters

282
00:18:05,522 --> 00:18:08,694
object at the very end. We want to prevent the default

283
00:18:08,742 --> 00:18:11,834
behavior because we want to make sure

284
00:18:11,872 --> 00:18:16,486
that everything before this line has completed successfully

285
00:18:16,598 --> 00:18:21,158
before. We prevent the form from submitting using the

286
00:18:21,184 --> 00:18:24,894
native HTML submission, and at this point we know

287
00:18:24,932 --> 00:18:28,826
that everything's all good, so we can send that fetch request

288
00:18:28,858 --> 00:18:32,894
with the URL and the methods that we want or the

289
00:18:33,012 --> 00:18:36,466
options that we defined. There are a

290
00:18:36,488 --> 00:18:39,314
couple of caveats to sending form submissions this way.

291
00:18:39,352 --> 00:18:42,766
One is if we're pulling the methods

292
00:18:42,798 --> 00:18:46,086
from the HTML form, we really only have the get and

293
00:18:46,108 --> 00:18:50,402
the post method available, which if you don't control your API endpoints,

294
00:18:50,466 --> 00:18:53,910
that might be an issue. This also probably

295
00:18:54,060 --> 00:18:58,150
means you want to detect whether the form or whether the data

296
00:18:58,220 --> 00:19:01,546
is being sent to your backend through JavaScript or through a

297
00:19:01,568 --> 00:19:05,114
native form submission. The reason being, if you

298
00:19:05,152 --> 00:19:09,590
send it through JavaScript, it might be safe to expect a JSON payload

299
00:19:09,670 --> 00:19:13,578
as the response. However, if you send it with HTML because it's

300
00:19:13,594 --> 00:19:16,974
going to reload the page, you probably don't want to reload the page

301
00:19:17,012 --> 00:19:20,400
with a JSON response. You probably want to,

302
00:19:21,170 --> 00:19:24,558
I don't know, maybe redirect the user back to the page that

303
00:19:24,564 --> 00:19:28,094
they came from so that essentially the page refreshes and they're

304
00:19:28,142 --> 00:19:31,394
none the wiser. This also doesn't work

305
00:19:31,432 --> 00:19:34,946
if you're dealing with complex data types. So if you're dealing with nested objects or

306
00:19:34,968 --> 00:19:38,726
an array of objects or things like that, you just can't do that with

307
00:19:38,828 --> 00:19:42,706
HTML forms. You also can't send graphQl

308
00:19:42,898 --> 00:19:46,390
requests because that needs a special sort of formatting.

309
00:19:48,570 --> 00:19:52,374
Now, moving on from using JavaScript

310
00:19:52,422 --> 00:19:56,390
to achieve feature parity in terms of validation and form submissions

311
00:19:56,470 --> 00:20:01,162
for better user experience, we can add

312
00:20:01,216 --> 00:20:04,478
additional features such as preventing data loss. So if a

313
00:20:04,484 --> 00:20:07,806
user is filling out a long form, it might be really annoying for them to

314
00:20:07,828 --> 00:20:12,142
accidentally navigate away or refresh. And we

315
00:20:12,196 --> 00:20:15,646
can help them by having a little pop up that checks hey,

316
00:20:15,748 --> 00:20:19,058
are you sure you want to leave the page right now? The way we can

317
00:20:19,064 --> 00:20:22,402
do that is by tapping into the before unload event on

318
00:20:22,456 --> 00:20:25,746
the page. So we can do that with

319
00:20:25,848 --> 00:20:29,334
the window add event listener to before unload and

320
00:20:29,372 --> 00:20:32,614
then do a check whether the user has made any

321
00:20:32,652 --> 00:20:36,438
changes or not. If they have not messed with the form at all,

322
00:20:36,524 --> 00:20:39,882
it's probably okay for them to refresh the page. So we can just return early

323
00:20:39,936 --> 00:20:43,082
and we don't even need to show them this

324
00:20:43,136 --> 00:20:46,346
little message. If they have made changes to the

325
00:20:46,368 --> 00:20:50,326
form, we can trigger those message. We can't customize

326
00:20:50,358 --> 00:20:54,458
it, but we can trigger it by doing the preventing

327
00:20:54,474 --> 00:20:57,774
the default behavior on that before unload event. We also need

328
00:20:57,812 --> 00:21:01,006
another line for Chrome for whatever reason, but this

329
00:21:01,028 --> 00:21:04,350
is a nice little user experience improvement to make

330
00:21:04,420 --> 00:21:07,586
your user's life better, because then they don't lose the data that

331
00:21:07,608 --> 00:21:09,620
they've spent so much time working on.

332
00:21:10,790 --> 00:21:14,242
There's more information on how to do this on my blog as well, if you

333
00:21:14,296 --> 00:21:18,018
want to get the slide presentations

334
00:21:18,114 --> 00:21:22,226
and check that out. In addition to preventing

335
00:21:22,258 --> 00:21:25,702
data loss, we can do things like keeping backups of the data

336
00:21:25,756 --> 00:21:29,098
that they have. Now, of course you don't want to do this for

337
00:21:29,264 --> 00:21:33,178
very sensitive data, but let's say we're not dealing with sensitive data.

338
00:21:33,264 --> 00:21:36,986
That's okay to share. What we can

339
00:21:37,008 --> 00:21:40,794
do is check whether the user has made any change to

340
00:21:40,832 --> 00:21:44,382
any of the inputs on the page. And every time that they make a change,

341
00:21:44,516 --> 00:21:48,302
we can capture the data from the form.

342
00:21:48,436 --> 00:21:51,662
So the inputs and their values as like key value

343
00:21:51,716 --> 00:21:55,982
pairs, we can put that into a JSON object and then stringify

344
00:21:56,046 --> 00:22:00,370
it and store that in local storage. And then

345
00:22:00,520 --> 00:22:04,526
later on if they leave and come back when the browser loads,

346
00:22:04,558 --> 00:22:08,470
or when that form lands on the page, we can

347
00:22:08,540 --> 00:22:12,386
check local storage, see if that data exists in local storage.

348
00:22:12,418 --> 00:22:16,434
If it is, and we have an object, we can loop through the properties

349
00:22:16,482 --> 00:22:20,102
and values of that object and assign those values

350
00:22:20,166 --> 00:22:23,658
to their corresponding inputs within the form. That logic is a

351
00:22:23,664 --> 00:22:27,402
little bit too long for me to put here, so just imagine it was

352
00:22:27,456 --> 00:22:29,500
really awesome looking code.

353
00:22:30,750 --> 00:22:33,882
Finally, when that form is submitted,

354
00:22:33,946 --> 00:22:37,678
we want to clear out local storage so that when they come back, they're not

355
00:22:37,764 --> 00:22:41,326
looking at data that they've already submitted. Just an

356
00:22:41,348 --> 00:22:44,994
example. So those are things that we could

357
00:22:45,032 --> 00:22:48,542
do to take native HTML

358
00:22:48,606 --> 00:22:51,986
and use JavaScript to build on top of it and give it sort

359
00:22:52,008 --> 00:22:56,120
of these super cool improvements without

360
00:22:56,490 --> 00:23:00,310
sacrificing accessibility or resiliency.

361
00:23:00,810 --> 00:23:03,986
Now I want to take a moment to look at component frameworks,

362
00:23:04,018 --> 00:23:07,670
because I think this is where the real superpowers get unlocked.

363
00:23:08,510 --> 00:23:12,060
The benefit of using component frameworks such as react or view

364
00:23:12,670 --> 00:23:16,214
means that it simplifies. Or we can simplify

365
00:23:16,262 --> 00:23:19,386
the form creation process. We'll look at that.

366
00:23:19,568 --> 00:23:23,834
I'll explain what that means in a minute. But essentially, as a developer consuming

367
00:23:23,882 --> 00:23:27,390
some of our components, it's not as much work to do.

368
00:23:27,460 --> 00:23:31,118
All of the markup and ids and labels and aria attributes and

369
00:23:31,204 --> 00:23:34,370
event listeners and all this stuff. It's just much simpler.

370
00:23:34,950 --> 00:23:39,042
Next, we get repeatable quality. So when we

371
00:23:39,096 --> 00:23:42,434
spend so much time working on forms, we want to make sure that they're well

372
00:23:42,472 --> 00:23:46,474
built and they work for everyone and they work across devices

373
00:23:46,542 --> 00:23:50,546
and browsers and all that. So by having component frameworks,

374
00:23:50,578 --> 00:23:53,906
we can actually implement that same component in multiple

375
00:23:53,938 --> 00:23:56,680
places and we get the same quality over and over.

376
00:23:57,370 --> 00:24:00,554
It also makes maintenance easier. As we've implemented that

377
00:24:00,592 --> 00:24:04,266
component over and over and over, we may discover that there is actually a

378
00:24:04,288 --> 00:24:07,674
bug in that component. And rather than

379
00:24:07,712 --> 00:24:11,182
having to go throughout a site and fix every instance that there ever

380
00:24:11,236 --> 00:24:15,054
was of an input or a form, we can make that fix in one place

381
00:24:15,172 --> 00:24:18,720
and have that fix permeate throughout our application

382
00:24:19,250 --> 00:24:23,578
so that every input suddenly is fixed

383
00:24:23,754 --> 00:24:26,946
or every form. We can also do

384
00:24:26,968 --> 00:24:30,866
things like enforcing best practices so react and view I can

385
00:24:30,888 --> 00:24:34,626
speak to, I have experience with, and they provide methods for

386
00:24:34,648 --> 00:24:38,562
you to require certain things when you implement things like an input.

387
00:24:38,626 --> 00:24:42,086
So saying that every input requires a label or a name or things like

388
00:24:42,108 --> 00:24:45,734
that you can enforce. There's also things that

389
00:24:45,772 --> 00:24:48,934
we know are required for every input, such as ids,

390
00:24:49,062 --> 00:24:52,666
but we don't have to be as strict with we

391
00:24:52,688 --> 00:24:56,026
can generate those and have kind of a

392
00:24:56,048 --> 00:24:59,686
fallback for developers. So let's

393
00:24:59,718 --> 00:25:03,162
look in a view example of what that might

394
00:25:03,216 --> 00:25:06,942
look like is I have a component here where I've defined here

395
00:25:06,996 --> 00:25:10,126
just the props, and with these props I can say that

396
00:25:10,148 --> 00:25:13,866
we have a label and we have a name prop that this component expects.

397
00:25:13,898 --> 00:25:17,694
And I can say that both of those are required as the developer

398
00:25:17,742 --> 00:25:21,058
creating the component. I have no idea how this input is going

399
00:25:21,064 --> 00:25:24,782
to be used, but as the developer consuming it, you're going to be required

400
00:25:24,846 --> 00:25:28,886
to give me those fields, because for

401
00:25:28,908 --> 00:25:31,720
a fully accessible and quality input I need them.

402
00:25:32,490 --> 00:25:35,878
I also need the id of an input in order to

403
00:25:36,044 --> 00:25:39,206
maintain those aria attributes. But I

404
00:25:39,228 --> 00:25:42,362
don't necessarily need you to give me an id. You can,

405
00:25:42,416 --> 00:25:46,074
you may if you want, and I'll take it. Otherwise I can fall

406
00:25:46,112 --> 00:25:48,940
back to generating a randomly created one.

407
00:25:49,870 --> 00:25:53,434
Now this input we may want to add validation logic

408
00:25:53,482 --> 00:25:56,880
to anytime that it experiences a blur event.

409
00:25:58,370 --> 00:26:01,454
And then that validation logic we want to show some errors for.

410
00:26:01,572 --> 00:26:05,998
So we can start with some reactive properties

411
00:26:06,094 --> 00:26:09,730
of tracking an array of errors.

412
00:26:10,150 --> 00:26:14,066
And then on that blur event we can tap into the

413
00:26:14,088 --> 00:26:17,986
validity state of that input and check whether it's invalid or

414
00:26:18,008 --> 00:26:21,686
not. For each of those properties that we saw before, we can

415
00:26:21,708 --> 00:26:25,494
loop over them, see what the property, check what the property is, check whether

416
00:26:25,532 --> 00:26:29,306
it's valid or invalid. If it's valid, we can

417
00:26:29,408 --> 00:26:32,810
move on to the next property. If it's invalid.

418
00:26:33,310 --> 00:26:37,206
In this example we're looking at the range underflow

419
00:26:37,238 --> 00:26:41,166
property which corresponds to the min attribute. So if

420
00:26:41,188 --> 00:26:44,958
the min attribute is invalid, we can push to our error object

421
00:26:45,124 --> 00:26:48,800
hey, this input must be greater than

422
00:26:49,330 --> 00:26:52,638
whatever the minimum attribute is, and we

423
00:26:52,644 --> 00:26:55,982
can push that error to our reactive error array

424
00:26:56,126 --> 00:26:59,874
and then present that in the UI. So looking

425
00:26:59,912 --> 00:27:03,106
at the UI for this component, it might look something like

426
00:27:03,128 --> 00:27:06,430
this. We might have the label that's associated to the input

427
00:27:06,510 --> 00:27:11,206
through that id. We might check whether this is a

428
00:27:11,228 --> 00:27:14,454
required input or not based on the attributes, and if so maybe put a little

429
00:27:14,492 --> 00:27:16,710
red asterisk next to the label.

430
00:27:17,390 --> 00:27:21,046
We'll have our input of course that has our validation

431
00:27:21,158 --> 00:27:24,858
event handler and the id

432
00:27:24,944 --> 00:27:28,214
and everything else an aria described

433
00:27:28,262 --> 00:27:32,000
by. And then we might have our

434
00:27:32,690 --> 00:27:36,286
UI for showing those error messages. And that

435
00:27:36,308 --> 00:27:40,126
can be associated with the input through the

436
00:27:40,228 --> 00:27:43,694
aria described by attribute. It's generated with the

437
00:27:43,732 --> 00:27:47,346
ID or based off of the ID, and it has

438
00:27:47,368 --> 00:27:51,650
a role of alert. There's a little bit more. This example

439
00:27:51,720 --> 00:27:55,754
is inspired from an input component in the view tensors library,

440
00:27:55,822 --> 00:27:59,394
which you can check out later. Now, besides the input,

441
00:27:59,442 --> 00:28:02,982
we can also create a component for our form. And our form

442
00:28:03,116 --> 00:28:07,330
component might have a submit event handler that

443
00:28:07,500 --> 00:28:11,354
checks the validity of the form, kind of like we saw before using the check

444
00:28:11,392 --> 00:28:15,274
validity method. And if

445
00:28:15,312 --> 00:28:19,290
the form is invalid we can automatically

446
00:28:19,710 --> 00:28:23,070
focus and scroll to the first invalid input.

447
00:28:24,050 --> 00:28:27,514
But then in addition to the same features that we've

448
00:28:27,562 --> 00:28:31,246
discussed and kind of adding those to a component, we have new

449
00:28:31,348 --> 00:28:34,690
features available which are custom event

450
00:28:34,840 --> 00:28:38,642
emitters, and this will make more sense in a moment,

451
00:28:38,776 --> 00:28:42,354
but we can basically create custom events for when the

452
00:28:42,392 --> 00:28:45,690
form is invalidly submitted and when the form is validly

453
00:28:45,710 --> 00:28:49,446
submitted. This component's markup is

454
00:28:49,468 --> 00:28:52,950
a lot simpler. It's just a form. It falls back to

455
00:28:53,020 --> 00:28:56,886
a post method for security reasons, which I don't have time

456
00:28:56,908 --> 00:29:01,062
to get into now. It implements a slot in react.

457
00:29:01,126 --> 00:29:04,380
This corresponds to the component children

458
00:29:06,270 --> 00:29:09,158
to make life easier for all of the developers.

459
00:29:09,254 --> 00:29:11,760
Maybe it includes a submit button,

460
00:29:12,850 --> 00:29:16,750
which is not customizable in this case, but you can imagine.

461
00:29:17,570 --> 00:29:21,674
And so putting all of this together, once we have this component logic,

462
00:29:21,722 --> 00:29:25,370
we have a couple of components that make life a lot easier,

463
00:29:25,450 --> 00:29:28,926
have robust functionality and user

464
00:29:28,958 --> 00:29:32,446
experience improvements, and the implementation details

465
00:29:32,478 --> 00:29:36,366
are actually very simple. So as the developer now that's

466
00:29:36,398 --> 00:29:39,940
implementing these, I might create an

467
00:29:40,390 --> 00:29:43,586
on valid submit handler and an on invalid

468
00:29:43,618 --> 00:29:46,886
submit handler, and the on valid submit, I want to send that

469
00:29:46,908 --> 00:29:50,890
information using the JavaScript fetch function

470
00:29:50,960 --> 00:29:55,706
that we defined earlier. On an invalid submit I

471
00:29:55,728 --> 00:29:59,434
don't do things right, so I'm just using console log because

472
00:29:59,472 --> 00:30:03,482
whatever. And then when we actually implement

473
00:30:03,546 --> 00:30:07,246
our form, we define the action where we want the form to

474
00:30:07,268 --> 00:30:10,906
submit things to on a valid submission

475
00:30:11,018 --> 00:30:15,326
we use the JavaScript submit handler. On an invalid submission

476
00:30:15,358 --> 00:30:18,786
we just console log it. Within that

477
00:30:18,808 --> 00:30:22,558
form we have two inputs, one for those email, one for the password,

478
00:30:22,654 --> 00:30:26,434
and you can see that this markup really simplifies what

479
00:30:26,472 --> 00:30:30,678
our forms could actually look like. So it's a very nice user experience

480
00:30:30,764 --> 00:30:34,406
or a developer experience for me, and it's a very good user experience for

481
00:30:34,428 --> 00:30:38,618
the end user because they get all of the quality that I've put into

482
00:30:38,784 --> 00:30:43,946
the input components at

483
00:30:43,968 --> 00:30:47,034
the end of everything. JavaScript is really awesome

484
00:30:47,152 --> 00:30:49,818
for forms because, well,

485
00:30:49,984 --> 00:30:54,190
in my opinion, when we use progressive enhancement because one is

486
00:30:54,260 --> 00:30:58,234
by relying on the native UI or the native elements, we get a consistent

487
00:30:58,282 --> 00:31:01,726
experience across all browsers and all devices. When you see

488
00:31:01,748 --> 00:31:05,282
a checkbox in one place and you see the same checkbox in the other place,

489
00:31:05,336 --> 00:31:08,114
you know how to use it. Number two,

490
00:31:08,232 --> 00:31:12,126
it's accessible for everyone. So able bodied users,

491
00:31:12,158 --> 00:31:16,322
visual users, people that prefer keyboards, people that are reliant

492
00:31:16,386 --> 00:31:20,566
on assistive technology, everyone can use your application,

493
00:31:20,668 --> 00:31:24,086
which is great. We have

494
00:31:24,188 --> 00:31:27,878
minimal performance impact when compared to either

495
00:31:28,044 --> 00:31:31,978
only using JavaScript to build out those custom

496
00:31:32,144 --> 00:31:36,234
form controls that we discussed earlier, and having to add all of the sort

497
00:31:36,272 --> 00:31:39,980
of logic in order to have feature parity and accessibility and everything.

498
00:31:41,250 --> 00:31:45,118
And when you enhance it with JavaScript, it works

499
00:31:45,284 --> 00:31:49,006
with JavaScript, but when you build it in a way

500
00:31:49,108 --> 00:31:53,514
to fall back to HTML, it also works in case JavaScript

501
00:31:53,562 --> 00:31:56,530
is disabled. There's an ad blocker somewhere,

502
00:31:57,270 --> 00:32:00,180
your script has an error in it for whatever reason.

503
00:32:00,790 --> 00:32:04,514
I know that I experienced one time that I actually tried to sign up for

504
00:32:04,632 --> 00:32:08,222
an application and they relied on JavaScript

505
00:32:08,286 --> 00:32:12,194
to sign users up. And because I had an ad blocker

506
00:32:12,242 --> 00:32:15,654
or a tracking blocker or something like that, the application didn't work.

507
00:32:15,692 --> 00:32:18,220
So as a result I couldn't even use the application.

508
00:32:18,750 --> 00:32:22,122
And I don't personally want to lose out on

509
00:32:22,176 --> 00:32:25,654
users that experience something like that. If it falls back to HTML,

510
00:32:25,782 --> 00:32:29,142
it's great, it still works. And lastly,

511
00:32:29,286 --> 00:32:33,390
when we use component frameworks,

512
00:32:33,730 --> 00:32:37,406
we really get the benefit of being able to compartmentalize all

513
00:32:37,428 --> 00:32:42,406
of the logic, all of the quality, all of the user

514
00:32:42,458 --> 00:32:45,874
experience improvements into one place that we can

515
00:32:46,072 --> 00:32:48,260
use over and over throughout our application,

516
00:32:49,430 --> 00:32:53,038
put that quality over and over throughout our application, and also simplify

517
00:32:53,134 --> 00:32:57,202
the maintenance. That's the end of my talk

518
00:32:57,256 --> 00:33:00,760
today. I hope you enjoyed it. If you want more.

519
00:33:01,770 --> 00:33:04,646
I spent like a year writing a series on all of the things that I

520
00:33:04,668 --> 00:33:08,534
think make building HTML forms good. I also

521
00:33:08,572 --> 00:33:11,942
maintain the view tensol View JS library that includes

522
00:33:12,006 --> 00:33:15,686
the custom input and form controls

523
00:33:15,718 --> 00:33:19,990
as well as a whole bunch of other things. I write a newsletter

524
00:33:20,150 --> 00:33:23,726
and a blog if you want more content like this. Or you can follow me

525
00:33:23,748 --> 00:33:27,662
on Twitter. And probably the main reason to

526
00:33:27,716 --> 00:33:31,082
be here today is that I have a really cute dog. His name is Nugget.

527
00:33:31,226 --> 00:33:34,346
He's a chewini. He's eleven pounds, loves chasing squirrels

528
00:33:34,378 --> 00:33:38,270
and food and you should give him a follow.

529
00:33:38,420 --> 00:33:42,378
So thank you very much for your time and paying attention

530
00:33:42,474 --> 00:33:45,300
and I hope that this talk worth it.

