1
00:00:20,490 --> 00:00:24,818
Hello, this is an intro to FastapI. So fast API

2
00:00:24,954 --> 00:00:28,950
highperformance, easy to learn, fast to code, ready for production.

3
00:00:29,610 --> 00:00:33,254
First I am Sebastin Ramrez. I'm a

4
00:00:33,292 --> 00:00:36,258
developer at explosion in Kotlin,

5
00:00:36,274 --> 00:00:39,926
Germany. I'm actually from Colombia, in South America. That's why

6
00:00:39,948 --> 00:00:43,254
the accent. You can find me on GitHub, LinkedIn,

7
00:00:43,302 --> 00:00:46,406
Twitter. I work for explosion.

8
00:00:46,438 --> 00:00:50,354
Explosion are the creators of Spacey, the natural language processing

9
00:00:50,422 --> 00:00:53,806
toolkit for doing things like machine learning

10
00:00:53,908 --> 00:00:57,166
over text. Also the creators of

11
00:00:57,188 --> 00:01:00,862
prodigy, the data set annotation tool

12
00:01:00,916 --> 00:01:04,398
using active learning so you can annotate data sets

13
00:01:04,414 --> 00:01:09,006
for machine learning with the model being live retrained

14
00:01:09,118 --> 00:01:12,942
live with the annotations you create and sync

15
00:01:13,006 --> 00:01:17,026
the deep learning framework based on standard Python

16
00:01:17,058 --> 00:01:20,578
type annotations. I created Fast API and Typer.

17
00:01:20,594 --> 00:01:23,894
We are going to talk about Fast API, so a little

18
00:01:23,932 --> 00:01:27,350
bit about Fast API. It has currently 15,000

19
00:01:27,420 --> 00:01:31,034
GitHub stars have been growing about 1000 stars per month. So people

20
00:01:31,072 --> 00:01:34,794
have been liking it. It's currently being used by

21
00:01:34,832 --> 00:01:38,710
Microsoft, Uber, Netflix and a bunch of other organizations

22
00:01:38,790 --> 00:01:42,350
and application systems. The highperformance is in the top

23
00:01:42,420 --> 00:01:46,058
rank for Python, and Fast API

24
00:01:46,074 --> 00:01:49,226
is based on standards like open API, JSOn,

25
00:01:49,258 --> 00:01:53,130
schema of two os. Two is what is used by Facebook,

26
00:01:53,210 --> 00:01:57,402
Google, GitHub, Twitter. Whenever you do a login

27
00:01:57,466 --> 00:02:00,794
with application x, all that is using Oauth

28
00:02:00,842 --> 00:02:04,642
two and FastAPI lets you build these all two things very

29
00:02:04,696 --> 00:02:08,374
easily or integrate with them. And because it's based on all these

30
00:02:08,412 --> 00:02:13,090
open standards, it's very easy to have things like automatic API

31
00:02:13,170 --> 00:02:16,594
documentation. This automatic API documentation

32
00:02:16,642 --> 00:02:20,554
user interface that you can see on the right. This comes by default with

33
00:02:20,592 --> 00:02:24,154
Fast API for free when you create an application using

34
00:02:24,192 --> 00:02:28,074
FastAPI. So when you

35
00:02:28,112 --> 00:02:31,790
create an application using FastAPI, it's based on standards for

36
00:02:31,860 --> 00:02:35,114
free. You don't have to do anything to get standards

37
00:02:35,162 --> 00:02:39,006
based application just because you wrote it with

38
00:02:39,028 --> 00:02:42,874
fast API. Now, fast API is based on Python

39
00:02:42,922 --> 00:02:46,594
type hints or type annotations. This is the

40
00:02:46,632 --> 00:02:50,514
standard way you declare types in modern Python. For example, here we're saying

41
00:02:50,552 --> 00:02:53,950
that name is a string or that price is a float.

42
00:02:54,110 --> 00:02:57,890
This is a standard python. This is not a custom syntax, this is just

43
00:02:57,960 --> 00:03:01,478
standard Python. And because this is the standard way to

44
00:03:01,484 --> 00:03:04,726
declare type annotations, we get autocompletion everywhere in the

45
00:03:04,748 --> 00:03:08,714
editor and type checks and type errors. We are going to see more examples of

46
00:03:08,752 --> 00:03:12,442
this later. The point

47
00:03:12,496 --> 00:03:16,854
is, these standard type annotations are what provides autocompletion

48
00:03:16,902 --> 00:03:20,146
in your editor. So when you write code with fast API,

49
00:03:20,198 --> 00:03:24,160
you get autocompletion everywhere in your code.

50
00:03:25,650 --> 00:03:29,742
Fast API is easy and short. So this code

51
00:03:29,796 --> 00:03:33,034
that you see here is a complete valid fast API

52
00:03:33,082 --> 00:03:36,246
application. We import from Fastapi, the class Fastapi.

53
00:03:36,298 --> 00:03:40,238
We create an object of this class fast API

54
00:03:40,334 --> 00:03:43,554
and then we use this decorator here. A decorator is

55
00:03:43,592 --> 00:03:47,142
something that uses this add symbol and what it does

56
00:03:47,196 --> 00:03:50,614
is it's using in some way the

57
00:03:50,652 --> 00:03:54,402
function that is below. That's what a decorator does with this add symbol.

58
00:03:54,466 --> 00:03:57,958
What we are doing is we're saying in our application,

59
00:03:58,044 --> 00:04:01,850
in our past API application, we want to handle the path.

60
00:04:03,390 --> 00:04:07,306
Whenever we get a request that has a

61
00:04:07,328 --> 00:04:10,734
URL with just the path and

62
00:04:10,772 --> 00:04:14,526
is using HTTP get operation or

63
00:04:14,548 --> 00:04:17,818
an HTTP get method,

64
00:04:17,994 --> 00:04:21,486
we want this function to handle that. And what

65
00:04:21,508 --> 00:04:25,202
we are doing is just returning a dictionary that has a message hello

66
00:04:25,256 --> 00:04:28,850
world. You can see that we don't have to return

67
00:04:28,920 --> 00:04:32,706
like some type of request or some type

68
00:04:32,808 --> 00:04:35,942
of class or anything like that.

69
00:04:35,996 --> 00:04:40,150
We just return a simple dictionary. Fast API will take care of converting this to

70
00:04:40,220 --> 00:04:41,110
JsON.

71
00:04:42,810 --> 00:04:46,390
So the more fast API code you write, the less

72
00:04:46,460 --> 00:04:50,394
API code you actually write because fast API gets but

73
00:04:50,432 --> 00:04:54,570
of the way. And then you can just focus on your business

74
00:04:54,640 --> 00:04:56,540
logic for your application.

75
00:04:57,950 --> 00:05:00,700
Now let's see a basic fastapi application.

76
00:05:02,030 --> 00:05:05,278
This is more or less the same we just saw before we had

77
00:05:05,364 --> 00:05:08,766
async def for this function. Now we have this

78
00:05:08,868 --> 00:05:12,798
normal def function. If you don't know how async and wait

79
00:05:12,964 --> 00:05:17,022
works or you don't feel comfortable with them, you can just use normal

80
00:05:17,086 --> 00:05:20,274
functions and fast API will do the right thing for you.

81
00:05:20,392 --> 00:05:23,554
So this is just the normal thing we were seeing before.

82
00:05:23,752 --> 00:05:27,606
Now let's add another path here.

83
00:05:27,708 --> 00:05:31,158
This is item and we are going to take this

84
00:05:31,324 --> 00:05:35,122
item id as a oauth parameter. We put it in curly

85
00:05:35,186 --> 00:05:38,834
braces as if it was a python form f string,

86
00:05:38,882 --> 00:05:42,266
like a formatted string. We just don't add the f here,

87
00:05:42,448 --> 00:05:46,454
but it's more or less the same syntax. And we declare

88
00:05:46,502 --> 00:05:50,026
this item Id as a path parameter here. And we also declare it here to

89
00:05:50,048 --> 00:05:53,742
receive it in our function. And we are saying that this item Id is an

90
00:05:53,796 --> 00:05:57,662
integer. We are also declaring this

91
00:05:57,716 --> 00:06:00,474
queue which is a string that by default is none.

92
00:06:00,602 --> 00:06:04,240
Because this queue is not in the path here,

93
00:06:04,770 --> 00:06:07,806
fast API will take it from the query parameters.

94
00:06:07,998 --> 00:06:12,818
So if our application lives at this domain sundomain.com,

95
00:06:12,984 --> 00:06:16,642
then when we send a request

96
00:06:16,706 --> 00:06:20,194
with items five, this will be handled

97
00:06:20,242 --> 00:06:23,654
by this function. This slash items is

98
00:06:23,692 --> 00:06:27,126
the same items and this five here will be the

99
00:06:27,148 --> 00:06:31,098
item id that we declare here that we are going to receive here

100
00:06:31,264 --> 00:06:34,874
as a path parameter and then we can declare the

101
00:06:34,912 --> 00:06:38,902
query parameter after the question mark here. So this queue equals

102
00:06:38,966 --> 00:06:42,730
some query. Whenever our code executes,

103
00:06:43,630 --> 00:06:47,194
this queue will have the value sum query. If we send the URL

104
00:06:47,242 --> 00:06:50,958
like this, and if we check

105
00:06:51,124 --> 00:06:53,418
the URL,

106
00:06:53,594 --> 00:06:57,694
docsfacity eight automatically generates this documentation interface

107
00:06:57,742 --> 00:07:01,346
for us. And we can see we have the slash items item id. We have

108
00:07:01,368 --> 00:07:05,518
this item Id here which is the same here, that is our required

109
00:07:05,694 --> 00:07:09,590
path parameter and it has to be an integer. We also have the

110
00:07:09,660 --> 00:07:13,126
q query parameter which is a string and has to be

111
00:07:13,148 --> 00:07:16,566
on the query. And this documentation interface is

112
00:07:16,588 --> 00:07:20,154
generated automatically by fast API for

113
00:07:20,192 --> 00:07:23,606
us because it's based on all these standards

114
00:07:23,638 --> 00:07:27,946
that we were talking about. So whenever you write an

115
00:07:27,968 --> 00:07:31,246
application with fast API, you just write some basic code.

116
00:07:31,348 --> 00:07:35,130
And good guy, fast API makes a docs

117
00:07:35,210 --> 00:07:38,110
user interface for your API.

118
00:07:39,330 --> 00:07:43,140
Now let's check a basic Fastapi app with a body.

119
00:07:43,590 --> 00:07:47,620
We are declaring here that we have a

120
00:07:48,070 --> 00:07:52,434
food class and we are using this

121
00:07:52,632 --> 00:07:56,410
base code thing. This is imported from pydantic. So fast API

122
00:07:56,430 --> 00:08:00,050
is actually based uses internally

123
00:08:00,130 --> 00:08:03,398
this library called pydantic that helps us do a

124
00:08:03,404 --> 00:08:07,266
lot of all the data handling in fastapI.

125
00:08:07,458 --> 00:08:11,034
And pydantic uses the standard type

126
00:08:11,072 --> 00:08:14,826
annotations for Python. So we are declaring that we want a name to be

127
00:08:14,848 --> 00:08:18,682
a string and we want ingredients to be this thing list. This list

128
00:08:18,736 --> 00:08:22,394
is imported from typing, which is standard Python.

129
00:08:22,442 --> 00:08:26,080
This typing comes from Python and this list

130
00:08:26,690 --> 00:08:30,046
is the standard way to declare something as a

131
00:08:30,068 --> 00:08:33,610
list in the type annotations.

132
00:08:33,690 --> 00:08:37,214
So we are saying that this ingredients is a list that should contain strings

133
00:08:37,262 --> 00:08:40,100
and by default it's just an empty list.

134
00:08:40,550 --> 00:08:43,970
Then in the code that we have here below

135
00:08:44,040 --> 00:08:46,938
we are saying that this goes to put slash.

136
00:08:47,134 --> 00:08:51,750
Now this is not a get request but a post HTTP

137
00:08:52,090 --> 00:08:56,054
operation and we are going to handle post

138
00:08:56,172 --> 00:09:00,300
requests and we declare this parameter food

139
00:09:00,910 --> 00:09:04,170
to be an instance of this

140
00:09:04,240 --> 00:09:07,500
type food class that we declared before.

141
00:09:08,430 --> 00:09:12,506
This is also standard Python type annotations. We have lowercase

142
00:09:12,538 --> 00:09:16,174
food, this is a parameter, and this title case food is the same

143
00:09:16,212 --> 00:09:20,206
class we declared here. And by doing this

144
00:09:20,308 --> 00:09:23,602
we are telling Python that this food is an

145
00:09:23,656 --> 00:09:27,634
instance of this class. This is just like standard Python and fast

146
00:09:27,672 --> 00:09:32,094
API will use it to document

147
00:09:32,222 --> 00:09:35,890
our web API as

148
00:09:36,040 --> 00:09:39,286
following. So we can see that if we go to

149
00:09:39,308 --> 00:09:42,934
the documentation user interface, we can see the example value

150
00:09:43,052 --> 00:09:46,438
that we expect to receive in the value of

151
00:09:46,444 --> 00:09:49,626
the request. And we are going to receive a name that should be a

152
00:09:49,648 --> 00:09:53,706
string and we are going to receive ingredients that should be a list with

153
00:09:53,808 --> 00:09:57,340
strings and this is done

154
00:09:57,870 --> 00:10:02,000
automatically by fast API for us because we are using

155
00:10:03,090 --> 00:10:07,034
this standard let's go back. This is standard type annotations

156
00:10:07,162 --> 00:10:10,718
and this class created using

157
00:10:10,804 --> 00:10:14,180
pydantic. Now let's go forward.

158
00:10:16,070 --> 00:10:19,090
We can actually execute queries,

159
00:10:20,310 --> 00:10:23,922
execute requests to our API. If we go

160
00:10:23,976 --> 00:10:27,542
back to the quantation as we were seeing it before, we click

161
00:10:27,596 --> 00:10:30,966
here and try it out and we will see that this converts to an

162
00:10:30,988 --> 00:10:34,614
interactive system that we can execute and

163
00:10:34,652 --> 00:10:38,690
send data to our live application. We are sending

164
00:10:38,770 --> 00:10:42,430
some food that has a name of taco ingredients is frigules,

165
00:10:42,450 --> 00:10:46,266
carnet, taco Shell, Savasura. So this is all valid data. We are

166
00:10:46,288 --> 00:10:49,974
sending that and then we receive the message preparing taco.

167
00:10:50,022 --> 00:10:54,030
This is the same code that we were returning. We are just

168
00:10:54,180 --> 00:10:57,326
receiving the right response from our application.

169
00:10:57,428 --> 00:11:01,066
If we go back to the code we can see that we are sending

170
00:11:01,098 --> 00:11:04,574
this message that is preparing food

171
00:11:04,692 --> 00:11:08,814
name and because we are actually receiving an instance we are not receiving a dictionary,

172
00:11:08,862 --> 00:11:12,706
we are receiving an instance of this class food. We can use food

173
00:11:12,808 --> 00:11:16,194
name to get the name that we received there. And this

174
00:11:16,232 --> 00:11:19,938
is in query braces because this is an f string which is the modern

175
00:11:20,034 --> 00:11:23,750
way in python to write formatted strings.

176
00:11:24,410 --> 00:11:27,834
So let's go forward. We are receiving the messages that

177
00:11:27,872 --> 00:11:31,146
we were expecting to receive when we

178
00:11:31,168 --> 00:11:35,434
interact with the user interface for the

179
00:11:35,472 --> 00:11:39,354
documentation of our API. So well,

180
00:11:39,392 --> 00:11:43,054
this is how a request body full of tacos might look

181
00:11:43,092 --> 00:11:46,766
like. Now let's say that we

182
00:11:46,788 --> 00:11:50,522
want to declare a fast cb application that takes a body and a query

183
00:11:50,586 --> 00:11:54,586
parameter. So we declare the pydantic model

184
00:11:54,628 --> 00:11:58,690
as we were doing before, and now we

185
00:11:58,760 --> 00:12:02,402
declare it here. This is all the same code, but we are also declaring this

186
00:12:02,456 --> 00:12:05,874
delivery which is a boolean by default false because

187
00:12:05,912 --> 00:12:09,746
this delivery is not part of the path, so it's

188
00:12:09,778 --> 00:12:12,758
not a path parameter and because this is a simple value,

189
00:12:12,844 --> 00:12:16,354
a boolean, a simple value like a string, a float.

190
00:12:16,402 --> 00:12:19,946
A boolean is not a complex class like this food that

191
00:12:19,968 --> 00:12:24,170
we created here. Then fast API will read it from the query parameters

192
00:12:25,070 --> 00:12:29,370
also fast API we are declaring this as being a boolean.

193
00:12:30,030 --> 00:12:33,610
Fast API will take care of giving us a boolean, not a string

194
00:12:33,690 --> 00:12:36,798
with the word false or something like that. We will receive a boolean and

195
00:12:36,804 --> 00:12:40,714
if we see it in the interactive documentation

196
00:12:40,842 --> 00:12:44,942
user interface, we can see that fast API will read

197
00:12:44,996 --> 00:12:48,754
that delivery query parameter that we created and we'll put

198
00:12:48,792 --> 00:12:52,098
it here. We'll say that this is a boolean and it should go in the

199
00:12:52,104 --> 00:12:55,586
query parameter because we declare it as a boolean. Then the user interface is

200
00:12:55,608 --> 00:12:59,094
going to be able to show us the valid values which are just true or

201
00:12:59,132 --> 00:13:03,062
false. And this is how we will call it if we were using

202
00:13:03,116 --> 00:13:07,286
it, if we were sending a request to that. So we will declare after the

203
00:13:07,308 --> 00:13:11,466
question mark we say delivery equals true. Now notice that this

204
00:13:11,568 --> 00:13:15,578
URL is just a long string and this

205
00:13:15,664 --> 00:13:19,302
true would actually descend as if it was a string

206
00:13:19,366 --> 00:13:22,926
containing the text true. But because we

207
00:13:22,948 --> 00:13:26,382
declare it in our code, let's go back. We declare it in our code

208
00:13:26,436 --> 00:13:29,834
as being a boolean. Then fast API using pydantic

209
00:13:29,882 --> 00:13:33,662
will take care of converting this

210
00:13:33,716 --> 00:13:37,886
boolean that came as a string to an actual boolean.

211
00:13:37,998 --> 00:13:41,298
So we are going to receive a boolean in our code. This is going to

212
00:13:41,304 --> 00:13:44,910
be false like this one, or true if we send it

213
00:13:45,000 --> 00:13:48,886
to be true. So by using

214
00:13:49,068 --> 00:13:52,358
standard Python type annotations like this or this

215
00:13:52,444 --> 00:13:56,370
fast API is one side doing documentation

216
00:13:56,450 --> 00:14:00,458
for application automatically, and on the other side data

217
00:14:00,544 --> 00:14:03,882
serialization or data conversion, we are receiving the boolean instead

218
00:14:03,936 --> 00:14:07,194
of a string saying true or something

219
00:14:07,232 --> 00:14:10,438
like that. And you don't have to

220
00:14:10,464 --> 00:14:13,902
put everything in the body. You can use query parameters if you need to.

221
00:14:13,956 --> 00:14:17,466
And there's also similar ways to declare

222
00:14:17,578 --> 00:14:20,640
headers, cookies and so on.

223
00:14:21,730 --> 00:14:25,410
Now let's say that we want to receive a very complex data

224
00:14:25,480 --> 00:14:28,542
shape. We want to receive a JSON array

225
00:14:28,606 --> 00:14:32,386
of objects in our body. So adjacent array is the equivalent of

226
00:14:32,408 --> 00:14:35,806
a python list, adjacent object is the equivalent

227
00:14:35,838 --> 00:14:39,574
of a python dictionary. So we are declaring here

228
00:14:39,692 --> 00:14:43,046
the same way we're using this list before, we are also going to

229
00:14:43,068 --> 00:14:46,946
use it here. And this list comes from the standards Python typing

230
00:14:47,058 --> 00:14:50,918
module. And we are saying that we are going to receive others,

231
00:14:51,014 --> 00:14:55,034
which is a list of food. And food is this pyramidic class we

232
00:14:55,072 --> 00:14:58,198
created here that has name and has ingredients.

233
00:14:58,374 --> 00:15:01,434
And now the code that we are doing here is very simple. It's just like

234
00:15:01,472 --> 00:15:05,006
some sample small application that is collecting all the ingredients and

235
00:15:05,028 --> 00:15:08,126
putting them together. So we create a list of ingredients and for each one of

236
00:15:08,148 --> 00:15:12,286
the food in orders. Orders is this thing we declared here.

237
00:15:12,388 --> 00:15:17,058
We are iterating for each one of the ingredients in the food

238
00:15:17,224 --> 00:15:21,026
ingredients. So the ingredients for this specific food,

239
00:15:21,128 --> 00:15:24,546
and we are adding that ingredient in lowercase to all

240
00:15:24,568 --> 00:15:27,366
the ingredients that we have and we just return those ingredients. So we are just

241
00:15:27,388 --> 00:15:30,934
collecting all the ingredients for the food orders that

242
00:15:30,972 --> 00:15:35,474
we received. Now if we go to the documentation

243
00:15:35,522 --> 00:15:39,026
user interface, we can see that it detects

244
00:15:39,058 --> 00:15:43,354
that we declare that this should be a list of

245
00:15:43,392 --> 00:15:46,074
this data shape. And we can see this is a list because we have the

246
00:15:46,112 --> 00:15:49,466
square braces here. This is like

247
00:15:49,488 --> 00:15:52,110
the example value that we will be sending.

248
00:15:53,730 --> 00:15:56,926
So if we want to send JSON and we want to send it

249
00:15:56,948 --> 00:16:00,880
inside of JSON, some JSON objects inside of JSON objects or

250
00:16:01,570 --> 00:16:05,234
lists or wherever, we can do anything that we want.

251
00:16:05,352 --> 00:16:08,814
We can declare very deeply complex,

252
00:16:08,942 --> 00:16:12,546
deeply nested data structures and fast API will be able to

253
00:16:12,568 --> 00:16:15,910
handle it all based on standard python type annotations.

254
00:16:17,450 --> 00:16:21,446
But up to now we have seen that the

255
00:16:21,468 --> 00:16:25,222
whole thing is doing documentation and serialization or data conversion for

256
00:16:25,276 --> 00:16:28,294
us. But what happens if we send invalid data?

257
00:16:28,492 --> 00:16:30,460
So let's see this one.

258
00:16:32,110 --> 00:16:35,418
These are square brackets. So this is a list and we declared that

259
00:16:35,424 --> 00:16:39,466
we're going to receive a list that's valid. The first item is

260
00:16:39,648 --> 00:16:42,954
this JSON object and

261
00:16:42,992 --> 00:16:47,018
these are all JSON objects. So that's up to now. That's valid.

262
00:16:47,114 --> 00:16:50,298
The first item has a name which is a string. That's valid

263
00:16:50,314 --> 00:16:54,122
because that's what we declared. And we have ingredients, which is a list of strings.

264
00:16:54,186 --> 00:16:57,398
In this case click holes, cardinal, taco Shell and Sabrosura.

265
00:16:57,514 --> 00:17:00,706
So this is valid. Then we have the

266
00:17:00,728 --> 00:17:04,002
next one which has a name, which is pizza and

267
00:17:04,056 --> 00:17:07,654
this is a string. So this is valid. We don't have ingredients here,

268
00:17:07,772 --> 00:17:10,950
but if you remember the ingredients was

269
00:17:11,100 --> 00:17:14,578
by default an empty list because it had a default

270
00:17:14,674 --> 00:17:18,102
value then it is not required. So this is actually

271
00:17:18,156 --> 00:17:20,970
a valid food item.

272
00:17:21,630 --> 00:17:24,890
Now we have the next one. This has a name,

273
00:17:24,960 --> 00:17:28,314
Trojan Food. This sounds weird, but up to now

274
00:17:28,352 --> 00:17:31,146
this is valid because this has a name and this is a string. Now we

275
00:17:31,168 --> 00:17:35,178
check the ingredients and the first item is salt. The salt

276
00:17:35,194 --> 00:17:38,446
is a string inside of the list. So this is valid up to

277
00:17:38,468 --> 00:17:42,222
now, but the next one is actually a JSON object

278
00:17:42,356 --> 00:17:45,866
that has a name and it says that it's a sneaky

279
00:17:45,898 --> 00:17:49,822
object. We declare that we are going to receive strings, not objects.

280
00:17:49,966 --> 00:17:53,954
So this is weird here. And the next one has

281
00:17:53,992 --> 00:17:57,062
this food name which is an old

282
00:17:57,116 --> 00:18:00,738
breath. But if we check what we declare

283
00:18:00,834 --> 00:18:04,198
that we are receiving is name not food name.

284
00:18:04,284 --> 00:18:08,166
A name was required and because we are not sending a

285
00:18:08,188 --> 00:18:11,738
name here then we are not sending a required value. And if

286
00:18:11,744 --> 00:18:15,782
we try to execute this then we're going to receive an error

287
00:18:15,846 --> 00:18:19,494
automatically and the error is going to tell us that we have invalid

288
00:18:19,542 --> 00:18:23,046
data. So fast API is going to validate all the data based

289
00:18:23,088 --> 00:18:27,278
on those type annotations automatically for us and

290
00:18:27,364 --> 00:18:31,790
not just will give us an error saying like, hey, the data is invalid.

291
00:18:32,290 --> 00:18:35,670
It will tell us exactly where the data is invalid.

292
00:18:35,770 --> 00:18:39,346
So here we have the details. This is a list of errors and

293
00:18:39,368 --> 00:18:42,626
we have two errors. The first one says that in

294
00:18:42,648 --> 00:18:46,194
the body, in others the index two. So let's go back.

295
00:18:46,392 --> 00:18:49,746
This is the index one, sorry, this is the index zero. This is the index

296
00:18:49,778 --> 00:18:52,886
one, and this is the index two. So somewhere in here we have

297
00:18:52,908 --> 00:18:54,760
an error. Let's go forward.

298
00:18:56,330 --> 00:18:59,542
Inside of that index two, inside of ingredients.

299
00:18:59,606 --> 00:19:02,774
In index one, a string

300
00:19:02,822 --> 00:19:06,506
type has expected. So let's go back. So we

301
00:19:06,528 --> 00:19:10,166
were in this object, inside of ingredients,

302
00:19:10,278 --> 00:19:13,806
this is index zero. In index one, which is

303
00:19:13,828 --> 00:19:16,942
this one, a string type was expected and we sent

304
00:19:16,996 --> 00:19:20,874
an object. So we have a very clear specification

305
00:19:20,922 --> 00:19:24,402
of where the problem is. Let's check the next

306
00:19:24,456 --> 00:19:27,794
error. This says that it's in index three.

307
00:19:27,912 --> 00:19:31,314
At name, the field was required and we didn't send

308
00:19:31,352 --> 00:19:35,566
it. Let's go back. This is the index three

309
00:19:35,688 --> 00:19:42,242
and we have a full name, but we don't have a name and the required

310
00:19:42,306 --> 00:19:45,986
key that we were expecting was name. So fat

311
00:19:46,018 --> 00:19:49,750
API is giving us this validation error

312
00:19:49,830 --> 00:19:53,050
automatically and is doing all that for us.

313
00:19:53,120 --> 00:19:57,162
Let's go back to our code. It's way

314
00:19:57,216 --> 00:20:00,794
back here. That means that by using

315
00:20:00,912 --> 00:20:04,530
these standard Python type annotations, fast API

316
00:20:04,550 --> 00:20:08,570
is doing documentation serialization or data conversion

317
00:20:08,730 --> 00:20:12,094
and validation. This is saving us like,

318
00:20:12,132 --> 00:20:15,426
I don't know, 50 lines of code in here, something like

319
00:20:15,448 --> 00:20:19,186
that. So whenever this code is executed, this code that we

320
00:20:19,208 --> 00:20:23,090
see all here, it's because the data

321
00:20:23,160 --> 00:20:26,546
is already valid. Facilities already made sure that

322
00:20:26,568 --> 00:20:30,146
we have valid data and we can just focus on the business logic

323
00:20:30,178 --> 00:20:33,218
of your application, not on handling specific errors

324
00:20:33,234 --> 00:20:36,866
of the data shapes that you received. Now let's

325
00:20:36,898 --> 00:20:39,900
go forward to where we were.

326
00:20:41,070 --> 00:20:44,774
So we received this nice validation

327
00:20:44,822 --> 00:20:48,378
error when we sent invalid data. So if we

328
00:20:48,384 --> 00:20:52,126
send invalid data fast API or application

329
00:20:52,228 --> 00:20:56,590
fast API will make that face and say, no, that's not allowed.

330
00:20:58,290 --> 00:21:02,090
Now, because we are doing all this based on type annotations,

331
00:21:02,170 --> 00:21:06,126
on standard Python type annotations or type hints,

332
00:21:06,318 --> 00:21:09,380
we get autocompletion everywhere. Now check this.

333
00:21:09,910 --> 00:21:13,646
These orders is a list of instances

334
00:21:13,678 --> 00:21:17,138
of this class food. So we can iterate for each one of

335
00:21:17,144 --> 00:21:20,514
the food in orders, and when we can iterate for each ingredient

336
00:21:20,562 --> 00:21:23,718
in food ingredients. So you can see we are

337
00:21:23,804 --> 00:21:27,426
in two for tools inside. So we are two for loops

338
00:21:27,458 --> 00:21:30,694
deep. And still we get autocompletion for this

339
00:21:30,732 --> 00:21:34,266
ingredient. So the editor will know that this ingredient is a string and

340
00:21:34,288 --> 00:21:38,026
we will be able to have completion for this all

341
00:21:38,048 --> 00:21:41,370
this because it's based on standard Python types.

342
00:21:41,870 --> 00:21:46,062
This will be very difficult to achieve with other

343
00:21:46,116 --> 00:21:49,806
tools and even other languages without using the standard

344
00:21:49,908 --> 00:21:53,422
Python type definitions or the standard type

345
00:21:53,476 --> 00:21:56,882
definitions for each specific language. So we are getting all this

346
00:21:56,936 --> 00:22:00,162
for free and we are also getting type

347
00:22:00,216 --> 00:22:03,698
checks. So the code, the editor is going

348
00:22:03,704 --> 00:22:07,214
to know that this ingredient is a string. And if we try to sum

349
00:22:07,262 --> 00:22:10,950
a string with some integer it's going to give us a nice error saying

350
00:22:11,020 --> 00:22:14,934
like hey, this is not a valid operation here

351
00:22:15,052 --> 00:22:19,206
and we're going to see this error early while we are developing our

352
00:22:19,228 --> 00:22:22,486
application before having to wait to run the application to see

353
00:22:22,508 --> 00:22:26,022
the error. Like we're going to get it right away in our editor.

354
00:22:26,166 --> 00:22:29,770
All because it's all based on standard Python types.

355
00:22:31,790 --> 00:22:35,566
Well yeah, this is all based on Python types. So we

356
00:22:35,588 --> 00:22:39,546
get all these things for free. Now let's

357
00:22:39,578 --> 00:22:43,162
say that we want to add some extra metadata. So we have this delivery query

358
00:22:43,226 --> 00:22:47,134
parameter here. There is a boolean. We want to add a description.

359
00:22:47,262 --> 00:22:50,946
We want to say this is pack for delivery. So from fast API we

360
00:22:50,968 --> 00:22:54,180
import this query thing and then we use it here.

361
00:22:54,790 --> 00:22:58,434
And before we had that the default value of delivery

362
00:22:58,482 --> 00:23:02,182
was false. But now we are using, instead of putting false we are using

363
00:23:02,236 --> 00:23:06,278
this query thing here. And because

364
00:23:06,364 --> 00:23:10,330
we are using this space to use this query here,

365
00:23:10,400 --> 00:23:14,058
we no longer have the default value here.

366
00:23:14,144 --> 00:23:17,658
So this query will take as the first parameter what

367
00:23:17,824 --> 00:23:21,934
that default value has before. So we are going to take this

368
00:23:21,972 --> 00:23:25,790
false here. This false means that this delivery will have a default value of

369
00:23:25,860 --> 00:23:29,354
false and we'd also have this additional metadata,

370
00:23:29,402 --> 00:23:32,926
this description park for delivery. And then if

371
00:23:32,948 --> 00:23:36,046
we check the documentation user interface we can see that

372
00:23:36,068 --> 00:23:39,950
we have the park for delivery description here for this delivery

373
00:23:40,030 --> 00:23:43,666
query parameter that should be a boolean and that by

374
00:23:43,688 --> 00:23:47,154
default is false. So now let's go back. We now

375
00:23:47,192 --> 00:23:50,742
take the false instead of having just false here, instead having

376
00:23:50,796 --> 00:23:54,982
just a simple false here we have this query thing with the description and

377
00:23:55,036 --> 00:23:58,874
the default value for this query parameter is going to be the first parameter of

378
00:23:58,912 --> 00:24:02,570
query forward

379
00:24:02,640 --> 00:24:05,580
to the documentation. Nice. We get that.

380
00:24:06,030 --> 00:24:10,438
So you now don't have to write documentation

381
00:24:10,614 --> 00:24:13,850
outside of your code. You don't have to keep updating

382
00:24:13,930 --> 00:24:17,242
some wiki somewhere with what is the API

383
00:24:17,306 --> 00:24:20,606
expecting to do. And the front end team that

384
00:24:20,628 --> 00:24:24,226
is using your API is not going to come complaining that the API is no

385
00:24:24,248 --> 00:24:27,486
longer working because you updated it and forgot to update the wiki

386
00:24:27,518 --> 00:24:31,380
because everything will live right there in the code

387
00:24:32,310 --> 00:24:36,370
right where it belongs describing what it should be describing.

388
00:24:37,190 --> 00:24:40,418
Now let's say that we want to have our required query parameters,

389
00:24:40,514 --> 00:24:44,422
so we have the delivery which is not required because

390
00:24:44,476 --> 00:24:48,010
it has a default value of false and we now add another

391
00:24:48,080 --> 00:24:51,290
one that is quantity because it doesn't have any default value

392
00:24:51,360 --> 00:24:54,762
here it's going to be required and

393
00:24:54,816 --> 00:24:59,562
it's going to expect an integer. So this

394
00:24:59,616 --> 00:25:03,390
has to be an integer and it's a required query parameter.

395
00:25:04,210 --> 00:25:08,062
If we check the documentation we can see that we have quantity here.

396
00:25:08,116 --> 00:25:12,074
It's a required query parameter that has to be an integer.

397
00:25:12,122 --> 00:25:15,390
If we try to execute this request here

398
00:25:15,460 --> 00:25:19,026
without sending a quantity, we're going to receive this error. And if

399
00:25:19,048 --> 00:25:22,546
we send it through code or from the

400
00:25:22,568 --> 00:25:25,766
command line, we will also get like one of those validation errors that we were

401
00:25:25,788 --> 00:25:29,158
seeing before. So this is

402
00:25:29,164 --> 00:25:33,186
the has that the API will make when we omit required

403
00:25:33,298 --> 00:25:33,960
data.

404
00:25:36,010 --> 00:25:40,102
Now let's say that we send valid data, so we are going to

405
00:25:40,236 --> 00:25:44,138
but slash and we're saying after the question mark we say the quantity is going

406
00:25:44,144 --> 00:25:47,578
to be equal to two. We declare that this had to be an integer and

407
00:25:47,584 --> 00:25:50,794
we are sending two. If we execute this request,

408
00:25:50,922 --> 00:25:55,162
then we are going to see the response that we were expecting.

409
00:25:55,306 --> 00:25:59,040
So it will work nicely as we want

410
00:26:00,530 --> 00:26:04,174
something to have in mind. One does not simply make all query

411
00:26:04,222 --> 00:26:07,506
parameters required because it's not

412
00:26:07,528 --> 00:26:11,342
very common for query parameters to be required and clients

413
00:26:11,406 --> 00:26:15,218
and or developers won't probably expect the query parameters to

414
00:26:15,224 --> 00:26:18,346
be required. So if you have a query parameter that is required,

415
00:26:18,398 --> 00:26:22,246
then just try to limit the amount of them. But if

416
00:26:22,268 --> 00:26:25,400
you need to make them required, you can do it as well.

417
00:26:26,090 --> 00:26:29,414
Now let's say that we want to add some extra validation for this

418
00:26:29,532 --> 00:26:32,714
quantity query parameter. We can use the same

419
00:26:32,752 --> 00:26:36,282
query thing that we were using before. We are going to use it here

420
00:26:36,336 --> 00:26:39,750
as well. And we say that this quantity,

421
00:26:39,830 --> 00:26:43,838
which is an integer has to be greater than zero and it has to

422
00:26:43,844 --> 00:26:47,006
be less than or equal to ten. So this

423
00:26:47,028 --> 00:26:51,150
has to be a value between zero and ten. And now notice that

424
00:26:51,220 --> 00:26:55,634
we now are using this equals something. So this

425
00:26:55,832 --> 00:26:59,390
function parameter has like quote unquote, a default

426
00:26:59,470 --> 00:27:03,202
value of whatever this query thing

427
00:27:03,256 --> 00:27:06,806
is here. But we wanted this quantity to be

428
00:27:06,828 --> 00:27:10,678
a required query parameter. So the same way that

429
00:27:10,844 --> 00:27:14,502
the one before we were using the same way that the first

430
00:27:14,556 --> 00:27:18,246
parameter is the actual default value. In the case of

431
00:27:18,268 --> 00:27:21,466
delivery, this was false. In the case of quantity we

432
00:27:21,488 --> 00:27:25,146
also pass as the first parameter we pass

433
00:27:25,248 --> 00:27:28,870
the default value. And in this case we are using three dots.

434
00:27:28,950 --> 00:27:33,018
These three dots is a valid python syntax.

435
00:27:33,114 --> 00:27:36,350
This is a valid python symbol called ellipsis.

436
00:27:36,690 --> 00:27:39,966
And this symbol is what we are using here to tell

437
00:27:39,988 --> 00:27:43,614
fast API hey, I want to use these extra

438
00:27:43,732 --> 00:27:47,586
things, these nice features from this query thing, but I want

439
00:27:47,688 --> 00:27:51,250
this quantity to not have a default value and still be

440
00:27:51,320 --> 00:27:54,914
required. So this is how we do it. This is actually also used

441
00:27:55,032 --> 00:27:59,022
by pydantic and it's actually underneath it's used using pydantic.

442
00:27:59,086 --> 00:28:02,482
But this is the way that we are saying that this quantity must be required.

443
00:28:02,546 --> 00:28:06,562
And now if we go to the documentation, we can see that the quantity

444
00:28:06,626 --> 00:28:10,130
is required. It's an integer. And if we send invalid data,

445
00:28:10,220 --> 00:28:13,834
we are going to receive one of these nice messages saying hey,

446
00:28:13,952 --> 00:28:17,834
ensure this value is greater than zero because we declared that it

447
00:28:17,872 --> 00:28:20,060
had to be greater than zero.

448
00:28:21,390 --> 00:28:24,842
So when we say invalid data, fast API

449
00:28:24,906 --> 00:28:29,360
will complain to the client and won't let the data and the code pass,

450
00:28:29,730 --> 00:28:33,694
won't let the data pass and won't let the code even be executed

451
00:28:33,742 --> 00:28:37,300
because it will just show the invalid data

452
00:28:38,150 --> 00:28:41,506
like the invalid data errors. But if we send

453
00:28:41,608 --> 00:28:45,610
valid data, then it will be all happy and work nicely

454
00:28:45,790 --> 00:28:49,190
as we expected. So it's protecting us from invalid data,

455
00:28:49,260 --> 00:28:52,754
from having to do all that handling in our internal

456
00:28:52,802 --> 00:28:56,290
code. Now, about performance.

457
00:28:56,370 --> 00:29:00,326
Fast API is in the top rank for python frameworks

458
00:29:00,358 --> 00:29:04,454
in performance. The blue ones here, this is a third party

459
00:29:04,502 --> 00:29:07,734
benchmark created by Tekkenpower.

460
00:29:07,862 --> 00:29:11,374
And the blue ones here are Python. The green ones

461
00:29:11,492 --> 00:29:15,166
are go or go lang. Go is a

462
00:29:15,188 --> 00:29:18,922
compiled language, so this is not a fair comparison

463
00:29:18,986 --> 00:29:22,658
at all because Python is interpreted, go is compiled and

464
00:29:22,664 --> 00:29:25,406
it should be way faster than any integrated language.

465
00:29:25,518 --> 00:29:29,150
But fast API

466
00:29:29,230 --> 00:29:33,010
and some others here are able of being even faster than

467
00:29:33,080 --> 00:29:36,790
some goal frameworks for APIs.

468
00:29:37,130 --> 00:29:40,374
So this is quite nice. Which one

469
00:29:40,412 --> 00:29:44,450
of these is exactly the fastest is not necessarily

470
00:29:44,530 --> 00:29:47,778
that relevant. You can see that they are on the same ballpark.

471
00:29:47,954 --> 00:29:51,118
And in fact, fast API here appears

472
00:29:51,154 --> 00:29:54,854
on top of ubicorn. But Ubicorn is actually the bare bones server

473
00:29:54,902 --> 00:29:58,826
that is running fast API. So ubiquitous, should be faster than any of

474
00:29:58,848 --> 00:30:02,510
these guys, and fast API is actually built on top of starlet.

475
00:30:02,850 --> 00:30:06,366
The key point is that you get some of the

476
00:30:06,388 --> 00:30:10,382
best performance available

477
00:30:10,516 --> 00:30:13,940
for Python frameworks, and you can see that we have

478
00:30:14,310 --> 00:30:19,490
here in this benchmark. It is handling 15,000

479
00:30:19,640 --> 00:30:22,862
something requests per second, so it's handling

480
00:30:22,926 --> 00:30:24,930
over 9000 requests.

481
00:30:26,890 --> 00:30:30,502
Cool. Some other features. Fast API has a dependency injection system

482
00:30:30,556 --> 00:30:33,830
which is very simple to use, but allows you to do

483
00:30:33,900 --> 00:30:36,978
very fancy stuff like authentication,

484
00:30:37,074 --> 00:30:41,210
authorization, or even database session management.

485
00:30:41,950 --> 00:30:45,814
A bunch of things that you can do using the dependency

486
00:30:45,862 --> 00:30:49,642
injection system, and the dependency injection system is also

487
00:30:49,696 --> 00:30:53,454
integrated with all these standards things, so you

488
00:30:53,492 --> 00:30:56,334
also get documentation automatically with it.

489
00:30:56,532 --> 00:31:00,442
It's very simple to use and very intuitive

490
00:31:00,586 --> 00:31:03,902
and powerful at the same time. There are also several

491
00:31:03,966 --> 00:31:07,234
security utilities integrated and integrated with

492
00:31:07,272 --> 00:31:11,918
OAuth two, which is also integrated with the documentation interface.

493
00:31:12,094 --> 00:31:15,354
You will have support for websockets, for files,

494
00:31:15,422 --> 00:31:19,298
background tasks, easy graphql integrated templates,

495
00:31:19,394 --> 00:31:23,334
like a bunch of other things. What you will expect from most

496
00:31:23,372 --> 00:31:27,414
of the frameworks now when is not

497
00:31:27,452 --> 00:31:31,334
a good idea to use fast API let's say that you have a stable Django

498
00:31:31,382 --> 00:31:34,810
application or some other framework, and it's stable

499
00:31:35,230 --> 00:31:39,222
if it's stable, if you don't need to add new features, it's working perfectly

500
00:31:39,286 --> 00:31:42,446
and it's not even an API, then you don't need

501
00:31:42,468 --> 00:31:46,266
to order and don't let your compulsion to refactor to rewrite

502
00:31:46,298 --> 00:31:50,222
it using fast API. But something that

503
00:31:50,276 --> 00:31:53,890
can be done if you want to use fast API is for example,

504
00:31:53,960 --> 00:31:57,406
adding a layer of fast API on top of your existing

505
00:31:57,598 --> 00:32:01,250
application to handle the new features or new

506
00:32:01,400 --> 00:32:05,406
requests for some additional paths

507
00:32:05,438 --> 00:32:07,320
that you declare or something like that.

508
00:32:09,210 --> 00:32:12,946
That will be like a nice way to integrated it, or to slowly

509
00:32:12,978 --> 00:32:15,640
migrate to fast API if you want to,

510
00:32:16,090 --> 00:32:20,106
just to avoid trying to rewrite everything from scratch and

511
00:32:20,288 --> 00:32:24,166
delaying your projects development. Nevertheless, there are teams

512
00:32:24,198 --> 00:32:27,242
that have just integrated entirely to fast API and

513
00:32:27,296 --> 00:32:31,166
have been very happy with it. But yeah, just make

514
00:32:31,188 --> 00:32:35,534
sure that it actually makes sense before just going on

515
00:32:35,732 --> 00:32:39,578
with fast API. Now some other tools typer

516
00:32:39,674 --> 00:32:43,578
typer is like the fast API of command lined interfaces.

517
00:32:43,674 --> 00:32:47,070
So this is to create command bind applications

518
00:32:47,150 --> 00:32:50,994
that are running terminal. It's also based on

519
00:32:51,112 --> 00:32:55,090
Python type annotations. The way you write code, it is almost

520
00:32:55,240 --> 00:32:59,046
the same as with fast API. So you get completion type checks and

521
00:32:59,068 --> 00:33:02,290
everything. And the nice thing is that your users,

522
00:33:02,450 --> 00:33:06,550
your clients are going to get shell autocompletion in their

523
00:33:06,700 --> 00:33:09,958
terminal. For bash fish Seashell

524
00:33:10,054 --> 00:33:13,740
Powershell think

525
00:33:14,270 --> 00:33:17,734
is the functional deep learning framework

526
00:33:17,862 --> 00:33:21,434
with python type annotations that is compatible with your favorite

527
00:33:21,482 --> 00:33:25,454
libraries like Tensorflow or Pytorch. This is built by

528
00:33:25,492 --> 00:33:29,354
explosion, the company I work for. And if you like these Python

529
00:33:29,402 --> 00:33:33,534
type annotations and you are into deep learning, you might

530
00:33:33,652 --> 00:33:36,320
want to check think as well.

531
00:33:37,570 --> 00:33:40,510
Thank you very much. That's what I have for you.

532
00:33:40,660 --> 00:33:43,818
If you want to check, the documentation is here. Fast API

533
00:33:43,994 --> 00:33:47,126
here's the documentation for FastapI. If you have any

534
00:33:47,148 --> 00:33:50,854
questions, you can ask them on the issues in the

535
00:33:50,972 --> 00:33:55,190
GitHub repository or you can also contact

536
00:33:55,260 --> 00:33:58,950
me in these links.

537
00:33:59,530 --> 00:34:00,260
Thank you very much.

