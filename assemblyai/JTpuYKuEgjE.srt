1
00:00:23,450 --> 00:00:27,314
Welcome to this talk about Kubernetes manifests

2
00:00:27,362 --> 00:00:30,598
and everything you can do with them that you weren't aware of. Going to

3
00:00:30,604 --> 00:00:33,926
walk you through a bunch of things that are important to understand and know when

4
00:00:33,948 --> 00:00:37,142
you're working with kubernetes and manifests when you're just getting

5
00:00:37,196 --> 00:00:39,320
started, really a lot of things to know.

6
00:00:40,730 --> 00:00:44,022
I'm going to be showing do a little bit of a demo as well.

7
00:00:44,076 --> 00:00:47,590
But first of all, just going through 101, what is a manifests?

8
00:00:47,930 --> 00:00:52,062
Talk about the manifest lifecycle, talk about how to create

9
00:00:52,196 --> 00:00:56,490
manifests and validate them. Talk about templating tools

10
00:00:56,570 --> 00:01:00,366
and just tooling in general and some best practices at

11
00:01:00,388 --> 00:01:04,066
the end to round things off. Hope that will be valuable to

12
00:01:04,088 --> 00:01:07,294
you. I have with me the ever lovable

13
00:01:07,422 --> 00:01:10,914
Kubernetes mascots here to the right. Say hello

14
00:01:10,952 --> 00:01:13,794
to them and let's jump on straight in.

15
00:01:13,832 --> 00:01:17,526
So first of all, what are Kubernetes manifests? And if you've worked

16
00:01:17,548 --> 00:01:21,720
with kubernetes, I'm sure you know what they are. If you haven't, now you know

17
00:01:22,650 --> 00:01:27,318
basically kubernetes. Any object that you want to create in

18
00:01:27,324 --> 00:01:30,714
your Kubernetes clusters, you have to specify a manifest that

19
00:01:30,752 --> 00:01:34,406
defines the state of that object. These manifests are either in JsON or YAml

20
00:01:34,438 --> 00:01:37,770
format. A file can contain multiple

21
00:01:38,670 --> 00:01:42,534
objects defined, and once you've defined the object, you apply

22
00:01:42,592 --> 00:01:46,206
it to your Kubernetes cluster and then kubernetes will do all its magic and

23
00:01:46,228 --> 00:01:50,202
create those corresponding objects for you. So straightforward,

24
00:01:50,266 --> 00:01:53,578
a manifest is a YAml or JSON file. Can work with

25
00:01:53,604 --> 00:01:57,170
any editors of course that can work with those kind of files.

26
00:01:58,150 --> 00:02:01,140
Basic structure of a manifest as you can see here,

27
00:02:01,990 --> 00:02:05,662
very straightforward. This is a YAmL example. And generally people

28
00:02:05,736 --> 00:02:08,550
mostly use Yaml. Although JSON is valid,

29
00:02:08,970 --> 00:02:12,566
every manifest has to have a kind. So telling what kind of

30
00:02:12,588 --> 00:02:15,974
object we're creating, the version of the

31
00:02:16,012 --> 00:02:19,606
kind. So this is a v one service that I'm

32
00:02:19,638 --> 00:02:22,794
creating in this manifest, and then

33
00:02:22,832 --> 00:02:26,486
some metadata and the name of the object is required

34
00:02:26,678 --> 00:02:30,586
and the namespace is optional. And the name and namespace have to

35
00:02:30,608 --> 00:02:34,720
be unique in combination. So you can only create one

36
00:02:35,250 --> 00:02:39,146
service with the name pet store. For example, in the default namespace

37
00:02:39,338 --> 00:02:42,526
you could have a pet store service in another namespace, but you

38
00:02:42,548 --> 00:02:45,040
won't be able to have two pet stores in the same.

39
00:02:46,150 --> 00:02:49,246
So good to be aware of. And then you can also add other metadata.

40
00:02:49,278 --> 00:02:53,006
You don't see them in here like labels and annotations commonly added

41
00:02:53,038 --> 00:02:56,318
by tooling like helm or other tools

42
00:02:56,334 --> 00:03:00,322
that you might use can also be helpful, just for your own sake, to organize

43
00:03:00,386 --> 00:03:04,054
your objects when they're in your cluster. And once

44
00:03:04,092 --> 00:03:07,670
you've kind of passed that initial block of Yaml,

45
00:03:08,090 --> 00:03:12,086
coming to the actual meat of the Yaml file or the manifest

46
00:03:12,198 --> 00:03:15,930
is what's called the spec or the specification, it could be also data

47
00:03:16,000 --> 00:03:19,734
in some objects. This specifies the actual properties

48
00:03:19,782 --> 00:03:22,286
for the objects that I want to create. So here you can see this is

49
00:03:22,308 --> 00:03:26,414
a service listening on port 80 and

50
00:03:26,452 --> 00:03:30,446
targeting port 80 80 using the name of the port

51
00:03:30,548 --> 00:03:34,678
is HTTP and then it's a selector telling

52
00:03:34,714 --> 00:03:38,386
to which other objects this service is applied. So obviously the

53
00:03:38,408 --> 00:03:42,066
content in the spec can be varies a lot between different kinds of

54
00:03:42,088 --> 00:03:45,378
services and somewhat between versions, and can be really

55
00:03:45,464 --> 00:03:48,630
short like you can see here, but it can also be super super long and

56
00:03:48,700 --> 00:03:52,518
elaborate and complicated, depending totally on the kind of object

57
00:03:52,604 --> 00:03:54,950
that your manifest is describing.

58
00:03:57,790 --> 00:04:01,340
Important to understand, API version and kind,

59
00:04:02,190 --> 00:04:05,978
and since those are used to kind of define the schema or the content of

60
00:04:05,984 --> 00:04:09,914
the manifests, as we already mentioned. So based

61
00:04:09,952 --> 00:04:13,754
on the kind and version, that's where you know kind of which properties and maps

62
00:04:13,802 --> 00:04:17,454
and arrays and enumerations, all things you can use to define the state of your

63
00:04:17,492 --> 00:04:20,634
resource. And the actual schema

64
00:04:20,682 --> 00:04:23,970
languages used underneath to define and validate

65
00:04:24,310 --> 00:04:27,486
those properties or specs is derived

66
00:04:27,518 --> 00:04:31,134
from OpenapI 30. So it's JSON schema with some limitations.

67
00:04:31,262 --> 00:04:34,914
You can read about this on Kubernetes IO. Obviously one

68
00:04:34,952 --> 00:04:38,840
thing to be really aware of here is that this shouldn't be confused with

69
00:04:39,930 --> 00:04:43,682
the version of Kubernetes itself, right? So currently I think Kubernetes

70
00:04:43,746 --> 00:04:46,886
is at version 125, or could it be 124?

71
00:04:46,908 --> 00:04:51,062
I don't remember. That version supports

72
00:04:51,126 --> 00:04:54,966
multiple versions of the actual object. So for example the crone

73
00:04:54,998 --> 00:04:59,050
job kind, you can run either API version, version one,

74
00:04:59,120 --> 00:05:02,378
or version one beta one, which is an older version, but you

75
00:05:02,384 --> 00:05:05,534
need to keep track of this. Of course if you're using V one beta one

76
00:05:05,572 --> 00:05:10,240
for your chrome jobs and you're about to update to Kubernetes 125

77
00:05:10,850 --> 00:05:14,046
that no longer supports that version. So you needed to be on top of these

78
00:05:14,068 --> 00:05:17,746
versions and obviously always try to use the latest version. But of

79
00:05:17,768 --> 00:05:21,006
course if you're targeting for example a cloud provider,

80
00:05:21,118 --> 00:05:24,642
make sure that they support the Kubernetes version that

81
00:05:24,696 --> 00:05:28,406
you're using with the objects that you're creating. So always good to

82
00:05:28,428 --> 00:05:32,230
be on the safe side and make sure you've got that yourself. That's all covered.

83
00:05:34,810 --> 00:05:38,518
Obviously many of these objects in

84
00:05:38,524 --> 00:05:42,278
Kubernetes don't live by themselves, right. They refer cto other objects.

85
00:05:42,374 --> 00:05:45,142
It's very common with kind of references between objects.

86
00:05:45,206 --> 00:05:48,826
So three most common types of references are

87
00:05:48,848 --> 00:05:53,050
just by name. So for example here you can see a config map

88
00:05:53,210 --> 00:05:56,480
ref. So this is referring to a config map with this name.

89
00:05:57,330 --> 00:06:01,322
Another more complex reference

90
00:06:01,386 --> 00:06:05,146
is what's called an object reference. So this not only

91
00:06:05,188 --> 00:06:07,970
by name but also by kind and API group.

92
00:06:08,040 --> 00:06:11,934
So this role ref here could be referring to other kinds of objects

93
00:06:11,982 --> 00:06:15,714
in other API groups, whereas this ref up here is always locked

94
00:06:15,762 --> 00:06:18,630
to a config map with the current version.

95
00:06:19,610 --> 00:06:23,506
Selectors are also very common. We saw a service previously,

96
00:06:23,538 --> 00:06:27,410
here's another one. This service applies to any object

97
00:06:27,500 --> 00:06:31,062
whats has this label defined. So Kubernetes

98
00:06:31,126 --> 00:06:35,034
IO name with this value. So this is a way

99
00:06:35,072 --> 00:06:38,314
of applying or creating references of

100
00:06:38,352 --> 00:06:42,138
one to many, right? So this service would apply to any object having these labels.

101
00:06:42,234 --> 00:06:45,726
So it's a powerful way of kind of referencing more than one

102
00:06:45,748 --> 00:06:48,910
object and creating more complex dependencies between

103
00:06:48,980 --> 00:06:54,866
objects. Also good to be aware of, obviously the

104
00:06:54,888 --> 00:06:58,210
status of your object.

105
00:06:58,280 --> 00:07:01,278
So when you're working with your object locally,

106
00:07:01,454 --> 00:07:05,026
it doesn't have a status because it's not deployed in Kubernetes. And as soon as

107
00:07:05,048 --> 00:07:08,626
you deploy your manifests to Kubernetes, Kubernetes itself is going

108
00:07:08,648 --> 00:07:11,970
to add a status property to your yamls or to the manifest.

109
00:07:12,050 --> 00:07:15,586
And I'm going to show this in a little while, kind of showing

110
00:07:15,618 --> 00:07:19,238
you the current state of the object and any events kind of related to

111
00:07:19,244 --> 00:07:22,794
the object in your clusters. So good

112
00:07:22,832 --> 00:07:26,666
to know that if you kind of look at the manifest that you

113
00:07:26,688 --> 00:07:30,042
have locally, maybe that you created and then the manifests that's actually running

114
00:07:30,096 --> 00:07:33,706
inside your cluster, you're going to see some differences there just because Kubernetes

115
00:07:33,898 --> 00:07:37,290
could apply some transformations and add some additional metadata,

116
00:07:37,370 --> 00:07:41,022
but it'll also add status metadata that

117
00:07:41,076 --> 00:07:44,126
kind of lets you know, kind of keep track of the projects. If you were

118
00:07:44,148 --> 00:07:47,934
to look at the manifest itself and this is not added for all object types,

119
00:07:47,982 --> 00:07:51,794
once again you have to play around or read the documentation just to figure

120
00:07:51,832 --> 00:07:55,910
out kind of what values and properties are added for which types of objects.

121
00:07:57,130 --> 00:08:00,514
So trying to kind of drill this into a lifecycle,

122
00:08:00,562 --> 00:08:05,222
because we all love lifecycles, is usually

123
00:08:05,276 --> 00:08:08,566
you start by creating your manifests using some tools or get

124
00:08:08,588 --> 00:08:11,702
back to tooling. Later. You edit them, you do validation.

125
00:08:11,766 --> 00:08:14,758
I'll get back to that soon. And once you're kind of happy with what you've

126
00:08:14,774 --> 00:08:18,426
created, you apply the manifest files to

127
00:08:18,448 --> 00:08:22,926
your Kubernetes cluster. And then what Kubernetes does is it takes the manifest and

128
00:08:22,948 --> 00:08:26,926
then it tries to, using its internal objects and

129
00:08:26,948 --> 00:08:30,286
logic, which I'm not going to go into, create the corresponding object in your

130
00:08:30,308 --> 00:08:34,206
cluster and then, in line with how you've defined it, and then

131
00:08:34,228 --> 00:08:37,774
there's a loop that can happen in cluster.

132
00:08:37,822 --> 00:08:41,218
So let's say the object isn't working as you desired, or you want

133
00:08:41,224 --> 00:08:44,706
to make some changes. You can do that straight directly by modifying the

134
00:08:44,728 --> 00:08:48,438
manifests in the cluster, and then Kubernetes will kind of update the state of the

135
00:08:48,444 --> 00:08:52,190
object accordingly. You can also, if you're a little

136
00:08:52,200 --> 00:08:55,954
bit more structured, let's say you made a mistake, whatever mistake

137
00:08:56,002 --> 00:08:59,370
you might make, that change out here to the left, and then reapply

138
00:09:01,310 --> 00:09:03,210
the manifest to your cluster,

139
00:09:04,190 --> 00:09:08,518
which makes for a little bit more of an auditable workflow

140
00:09:08,614 --> 00:09:12,154
lifecycle. But usually hot fixing is something that you'll end up doing,

141
00:09:12,192 --> 00:09:15,834
at least initially while you're getting to grips with Kubernetes. And at the end you'll

142
00:09:15,882 --> 00:09:19,566
delete the object from, you might

143
00:09:19,588 --> 00:09:23,474
at least delete it from kubernetes, and then of course the manifest will be

144
00:09:23,512 --> 00:09:26,626
removed as well. Not a

145
00:09:26,728 --> 00:09:30,674
super complex lifecycle, but good to understand the relationship between

146
00:09:30,712 --> 00:09:34,274
your local files containing the Yaml Json and

147
00:09:34,312 --> 00:09:37,686
then the actual object generated and created inside the

148
00:09:37,708 --> 00:09:40,390
cluster when you apply those files to Kubernetes.

149
00:09:41,690 --> 00:09:45,014
So creating can editing manifest is a

150
00:09:45,052 --> 00:09:49,126
straightforward thing, right? You can use any editors, obviously you

151
00:09:49,148 --> 00:09:52,854
can copy paste from other manifests, which of course is maybe not the best

152
00:09:52,892 --> 00:09:55,802
way to do it well, but it's a very productive way of getting things started,

153
00:09:55,856 --> 00:09:58,874
and there's a lot of examples out there, so it's a good way to get

154
00:09:58,912 --> 00:10:02,446
started. And there's a lot of plugins and code snippets and generators and

155
00:10:02,468 --> 00:10:05,898
wizards and stuff online and as plugins to your ides

156
00:10:05,994 --> 00:10:08,986
to help you getting started with your manifest.

157
00:10:09,098 --> 00:10:12,474
The easiest way maybe is to use Kubectl,

158
00:10:12,602 --> 00:10:15,954
which I'm guessing or hoping you're aware of. Kubectl is the

159
00:10:16,072 --> 00:10:19,506
command line tool for kubernetes, and there's a simple command that you can

160
00:10:19,528 --> 00:10:23,406
use to generate basic manifests

161
00:10:23,438 --> 00:10:26,146
for different types of objects. I'm going to show you this in just a little

162
00:10:26,168 --> 00:10:28,966
while and walk you through kind of the whole thing just to see how that

163
00:10:28,988 --> 00:10:32,870
works. Finally. Not finally,

164
00:10:32,940 --> 00:10:36,246
but let's talk a little bit about validating. Super important to

165
00:10:36,268 --> 00:10:39,574
validate your manifests, obviously syntax

166
00:10:39,622 --> 00:10:43,082
validation. You want to make sure that your

167
00:10:43,136 --> 00:10:46,822
manifests are valid YamL or JSON schema validation.

168
00:10:46,886 --> 00:10:49,718
You want to make sure that you've defined the right properties,

169
00:10:49,814 --> 00:10:53,534
and the properties have values that are in line with the type of

170
00:10:53,572 --> 00:10:57,354
properties that they are, and otherwise, obviously Kubernetes

171
00:10:57,402 --> 00:11:01,246
is not going to be able to handle the

172
00:11:01,268 --> 00:11:04,386
manifest when you apply it. Even though it might be a valid yaml, it might

173
00:11:04,408 --> 00:11:07,666
not be a valid schema. Another step of

174
00:11:07,768 --> 00:11:11,570
validation is around links. So as you saw as we talked about earlier,

175
00:11:11,990 --> 00:11:16,370
super important that if you're referring between objects,

176
00:11:16,790 --> 00:11:20,278
that those links are all lined up, that you're referring to the right name.

177
00:11:20,364 --> 00:11:24,006
Sometimes you might be referring to objects in other namespaces. You need to make sure

178
00:11:24,028 --> 00:11:27,878
that those objects are also there. And this can be tricky because

179
00:11:28,044 --> 00:11:32,038
just like I said here, the objects that you're referring

180
00:11:32,054 --> 00:11:35,706
to might not actually exist locally in your files. They might already be running in

181
00:11:35,728 --> 00:11:39,162
your cluster, so it might be hard to validate these

182
00:11:39,216 --> 00:11:42,586
kind of references. Also,

183
00:11:42,768 --> 00:11:47,018
some references, as you can see here, can be optional. This is depending

184
00:11:47,034 --> 00:11:50,990
on the schema of your object. So for example, there's a secret reference here which

185
00:11:51,060 --> 00:11:54,346
is not optional, so this actually has to exist.

186
00:11:54,458 --> 00:11:58,366
Others references can be optional so you won't see any errors.

187
00:11:58,478 --> 00:12:02,002
You might get a warning, at least depending on the tooling you're using,

188
00:12:02,056 --> 00:12:05,542
if that reference is not satisfied. But once again,

189
00:12:05,676 --> 00:12:10,680
definitely something to check. And this is a common

190
00:12:11,130 --> 00:12:14,454
cause of spending a lot of time figuring out why

191
00:12:14,492 --> 00:12:17,990
things didn't work. And just because you might have misspelled some

192
00:12:18,140 --> 00:12:21,730
link reference to some config map and it can take a while to

193
00:12:21,740 --> 00:12:25,702
figure whats out. The error messages you get from kubernetes

194
00:12:25,846 --> 00:12:28,714
are not always super helpful and it can take a while to figure out why

195
00:12:28,752 --> 00:12:32,314
these things didn't work. So if you can use some tool initially to validate these

196
00:12:32,352 --> 00:12:35,486
references, that can help you save a lot of time.

197
00:12:35,668 --> 00:12:39,422
Then finally policy validation policies are another

198
00:12:39,476 --> 00:12:43,054
kind of rule set on top of the first three

199
00:12:43,092 --> 00:12:47,614
here, and this can be policies related to performance, to resource

200
00:12:47,662 --> 00:12:50,690
allocation, to security, networking, et cetera.

201
00:12:51,110 --> 00:12:54,722
Or like just local. You might have policies defined by your teams around

202
00:12:54,776 --> 00:12:59,382
naming, around labeling, around things that are

203
00:12:59,436 --> 00:13:03,442
applicable more to your project than at a kubernetes

204
00:13:03,506 --> 00:13:07,222
level or general level. And a common

205
00:13:07,276 --> 00:13:10,698
technology used to validate manifest is called OPA open policy

206
00:13:10,784 --> 00:13:14,506
agent. It's used by a lot of open source projects out

207
00:13:14,528 --> 00:13:17,286
there to validate kubernetes configurations,

208
00:13:17,478 --> 00:13:20,922
and these policies can be applied either before

209
00:13:20,976 --> 00:13:24,206
you deploy. Right? So in your editor, which is the best place to do it,

210
00:13:24,228 --> 00:13:27,598
because that'll save you most of the time fixing those issues.

211
00:13:27,764 --> 00:13:31,134
But it's also pretty common to have some kind of

212
00:13:31,332 --> 00:13:34,974
gate or validation in kubernetes that just

213
00:13:35,012 --> 00:13:38,894
makes sure that you're not deploying things that don't align with your policies,

214
00:13:39,022 --> 00:13:42,354
which is still super helpful. Right. But it's a little bit

215
00:13:42,392 --> 00:13:45,554
late in the process because then you'll have to kind of go back and make

216
00:13:45,592 --> 00:13:49,346
changes and redeploy, et cetera, et cetera. OPA uses a language

217
00:13:49,378 --> 00:13:52,678
called rego, which is straightforward. It's not a

218
00:13:52,684 --> 00:13:55,938
super complex. Oops, sorry about that construct.

219
00:13:56,034 --> 00:13:59,574
And as I said, this could be used to validate anything related to

220
00:13:59,612 --> 00:14:03,302
resource, right? Name networking, resource allocation, best practices,

221
00:14:03,366 --> 00:14:06,234
et cetera. I'm going to show you in just a little while how what these

222
00:14:06,272 --> 00:14:10,058
policies can kind of look like, and there's a lot of them available online

223
00:14:10,144 --> 00:14:13,654
on GitHub. And there's also a nice vs code plugin

224
00:14:13,702 --> 00:14:17,166
available if you want to create your own and debug your own policies so

225
00:14:17,268 --> 00:14:20,590
you can really piggyback off what a lot of the

226
00:14:20,660 --> 00:14:24,974
existing open source tools have done, but then adapt those policies

227
00:14:25,022 --> 00:14:27,220
to your needs that you might have in your teams.

228
00:14:28,310 --> 00:14:32,174
Okay, finally you've created your manifest,

229
00:14:32,222 --> 00:14:36,126
you've validated them, and now you're ready to deploy. And usually deploying

230
00:14:36,158 --> 00:14:39,426
is something you might initially do manually. Right. You're using Kubectl or helm

231
00:14:39,458 --> 00:14:43,254
or customize. Eventually you're going to look into maybe automating that

232
00:14:43,292 --> 00:14:47,106
using CI CD or even a Gitops approach. Gitops meaning

233
00:14:47,138 --> 00:14:50,806
that you manage all your manifests in git, and then you have a tool like

234
00:14:50,908 --> 00:14:54,538
Argo CD or flux that constantly makes sure that the state that

235
00:14:54,544 --> 00:14:58,090
you've defined in git is actually the state that your cluster has,

236
00:14:58,240 --> 00:15:02,598
which is a super nice approach, but it's

237
00:15:02,614 --> 00:15:05,966
a bit of a maturity curve to get there. It requires that everyone's on board,

238
00:15:06,068 --> 00:15:10,010
so maybe that's not where you should start, but it's definitely a great endpoint

239
00:15:10,090 --> 00:15:13,134
to aim at. Okay, enough talk. Let's have a quick look.

240
00:15:13,172 --> 00:15:16,434
I'm going to use a couple of tools just to demo a little bit here.

241
00:15:16,472 --> 00:15:20,526
So I'm going to start by just using a Kubectl

242
00:15:20,558 --> 00:15:23,790
command to create a very simple NgInx

243
00:15:23,870 --> 00:15:27,026
deployment. And I'm going to use a tool called demonical, which is

244
00:15:27,048 --> 00:15:30,486
a free open source tool to have a look at that.

245
00:15:30,508 --> 00:15:34,146
So you can see here created this conf 42 yaml.

246
00:15:34,258 --> 00:15:37,778
It contains one deployment. Let's hide the file explorer.

247
00:15:37,874 --> 00:15:41,046
This whats the yaml that was created. You can immediately see here that there

248
00:15:41,068 --> 00:15:44,774
are some errors by the generated in the generated yaml.

249
00:15:44,822 --> 00:15:48,086
So let's just remove those because null

250
00:15:48,118 --> 00:15:51,722
is not a valid value by the schema. So this was the schema validation

251
00:15:51,786 --> 00:15:55,614
kicking in. And you can see here there's a reference to an

252
00:15:55,652 --> 00:15:59,694
image in Nginx image. You can also see that by

253
00:15:59,732 --> 00:16:03,166
default Kubectl adds an

254
00:16:03,188 --> 00:16:06,730
empty status property which will then be populated

255
00:16:06,810 --> 00:16:10,290
by kubernetes when we deploy, which we're going to do in just a little while.

256
00:16:10,360 --> 00:16:13,662
But I did want to show you a little bit around OPA validation.

257
00:16:13,726 --> 00:16:17,762
So let's go over here and let's just start enabling

258
00:16:17,826 --> 00:16:21,814
some OPA policies. So for example here a

259
00:16:21,852 --> 00:16:25,270
process can elevate its own privileges. I've enabled that

260
00:16:25,340 --> 00:16:28,486
OPA policy and you can see immediately here that we

261
00:16:28,508 --> 00:16:31,770
got an error. Let's hide this because it's a little bit crowded.

262
00:16:34,030 --> 00:16:37,722
So you can see the error message saying that this process

263
00:16:37,776 --> 00:16:41,486
can elevate its own privileges. And there's actually a recommendation that we

264
00:16:41,508 --> 00:16:45,418
should set security context, allow privilege escalation to false

265
00:16:45,514 --> 00:16:48,702
in our containers. So let's see if we can do

266
00:16:48,756 --> 00:16:51,040
that. Sorry,

267
00:16:53,830 --> 00:16:57,506
was that security? Sorry,

268
00:16:57,528 --> 00:17:00,766
I don't remember continuous

269
00:17:00,798 --> 00:17:02,050
security concepts.

270
00:17:11,440 --> 00:17:14,944
Let's set that to false. And now you can see that

271
00:17:15,062 --> 00:17:19,296
the error went away and now I can. Let's see if there's more.

272
00:17:19,478 --> 00:17:22,588
Let's try. Default capability is not dropped.

273
00:17:22,604 --> 00:17:25,904
Oops, we got another error. So we can kind of use this kind of tooling

274
00:17:25,952 --> 00:17:30,036
to interactively find

275
00:17:30,218 --> 00:17:33,508
those OPA policy validations that

276
00:17:33,514 --> 00:17:37,176
we're interested in and fix those before we

277
00:17:37,198 --> 00:17:38,920
deploy anything to our cluster.

278
00:17:39,980 --> 00:17:43,752
But I am going to. Oops, let's just turn that validation off again

279
00:17:43,806 --> 00:17:47,588
so we don't turn them all off to avoid any errors.

280
00:17:47,684 --> 00:17:51,372
And let's deploy this. I have a local mini cube cluster running

281
00:17:51,426 --> 00:17:55,464
on my machine, just going to press here, deploy. Let's put this in the default

282
00:17:55,512 --> 00:17:59,404
namespace and press. Ok so

283
00:17:59,442 --> 00:18:02,576
it's been applied to my cluster and so let's have a look

284
00:18:02,598 --> 00:18:06,144
at the cluster itself. So you can

285
00:18:06,182 --> 00:18:09,532
see here is the actual object, the NgINX

286
00:18:09,596 --> 00:18:13,164
deployment. Let's just filter on the default namespace.

287
00:18:13,292 --> 00:18:17,276
So this was the object that was applied

288
00:18:17,468 --> 00:18:20,596
to Kubernetes, my local mini cube cluster. And as you can

289
00:18:20,618 --> 00:18:24,740
see there's a lot more in here now than the initial

290
00:18:25,400 --> 00:18:27,050
manifest that you saw.

291
00:18:28,860 --> 00:18:32,520
Kubernetes has added a lot of different things. You can see that this property

292
00:18:32,590 --> 00:18:35,800
that we set to false is here, but it's also added the status

293
00:18:37,260 --> 00:18:40,764
property that I mentioned earlier on. So this is kind of what our object now

294
00:18:40,802 --> 00:18:44,604
looks like when it's running in Kubernetes. While obviously very

295
00:18:44,642 --> 00:18:48,136
different from the yaml that we had defined

296
00:18:48,168 --> 00:18:51,324
outside Kubernetes that we can see here. Okay, great.

297
00:18:51,362 --> 00:18:55,180
So we were able to create the manifest, we did some validations,

298
00:18:55,260 --> 00:18:58,492
fixed some OPA validation errors, deployed it to Kubernetes,

299
00:18:58,556 --> 00:19:02,156
and then connected to our cluster and saw that everything seemed

300
00:19:02,188 --> 00:19:05,590
to be up and running. All good. Let's get back here.

301
00:19:06,520 --> 00:19:09,220
Next step is to talk a little bit about templates.

302
00:19:10,360 --> 00:19:14,150
Templating is a very common need that you'll run into

303
00:19:14,520 --> 00:19:18,076
when you start working with multiple clusters or target environments.

304
00:19:18,128 --> 00:19:21,764
So let's say you have a dev environment, a staging environment, production environment,

305
00:19:21,812 --> 00:19:25,256
and when you deploy your different applications, you'll want

306
00:19:25,278 --> 00:19:28,900
to configure them somewhat differently, right? You might want to have different scalability

307
00:19:28,980 --> 00:19:33,116
settings, different security settings, different network settings for

308
00:19:33,138 --> 00:19:36,204
the same kind of source of manifests. And there's a lot of tools to help

309
00:19:36,242 --> 00:19:40,028
you do that. So have one source of manifests and

310
00:19:40,034 --> 00:19:44,032
then either kind of parameterize those or

311
00:19:44,166 --> 00:19:47,376
kustomize them or whatever to make sure

312
00:19:47,398 --> 00:19:50,556
whats, when you actually deploy to different environments, you have the values

313
00:19:50,588 --> 00:19:54,544
that are applicable to that environment. So yaml,

314
00:19:54,592 --> 00:19:57,716
there's the yaml native approach which is customized. I'm going to show that in a

315
00:19:57,738 --> 00:20:01,888
while it's

316
00:20:01,904 --> 00:20:05,060
built into Kubectl, so it's a very native way of doing things.

317
00:20:05,210 --> 00:20:08,484
Helm and JSON at helm is super popular,

318
00:20:08,612 --> 00:20:12,180
which uses a more custom templates language based on go templates.

319
00:20:12,340 --> 00:20:15,956
There's a couple of frameworks to actually instead of writing Yaml,

320
00:20:15,988 --> 00:20:21,852
you write code and then that code generates your

321
00:20:21,906 --> 00:20:25,756
yamls for you. Similar to like terraform would generate infrastructure. You can

322
00:20:25,778 --> 00:20:29,740
use things like cdks or decorate to write code to generate

323
00:20:30,080 --> 00:20:33,644
manifests. And then of course you can use all code related

324
00:20:33,692 --> 00:20:37,136
constructs that you might be happy to use when

325
00:20:37,158 --> 00:20:40,336
you're writing code. And there's also abstraction layers like Acorn and

326
00:20:40,358 --> 00:20:44,076
others to help you to kind of provide a higher level of abstraction

327
00:20:44,188 --> 00:20:47,620
that would then get converted of course to manifests before

328
00:20:47,770 --> 00:20:51,620
they are applied to kubernetes. So ultimately all of these result

329
00:20:51,690 --> 00:20:54,752
in a YAML or JSON manifest that is applied to kubernetes.

330
00:20:54,816 --> 00:20:58,952
They just help you do those in different ways. And whatever

331
00:20:59,006 --> 00:21:03,288
works for you and your team and what you think is best

332
00:21:03,454 --> 00:21:06,872
is always a good start. Talk a little bit about

333
00:21:06,926 --> 00:21:12,140
kustomize. Kustomize basically works

334
00:21:12,210 --> 00:21:15,836
by asking you to define the set of

335
00:21:15,858 --> 00:21:19,896
base manifests like the one that we looked at and then defining overlays

336
00:21:19,928 --> 00:21:23,536
or patches specific for a target environment. So I

337
00:21:23,558 --> 00:21:27,984
might have a base set up a deployment for base

338
00:21:28,022 --> 00:21:31,676
setup, and then I might have overlays for dev and production

339
00:21:31,708 --> 00:21:35,728
environments where I might have different replica accounts or different security settings

340
00:21:35,744 --> 00:21:39,476
or namespaces or whatever. And then kustomize when

341
00:21:39,498 --> 00:21:43,076
you apply to your cluster customize, you'll tell customize, okay, I want

342
00:21:43,098 --> 00:21:46,676
to use the production overlay. So it'll overlay the configuration in

343
00:21:46,698 --> 00:21:49,976
production over your base configuration and then take the

344
00:21:49,998 --> 00:21:53,380
result and apply that to your clusters. This is a very nice approach.

345
00:21:53,460 --> 00:21:57,450
It's Yaml native, so any Yaml tooling will work with it

346
00:21:58,640 --> 00:22:00,830
and it scales fairly well.

347
00:22:01,440 --> 00:22:05,016
Depends on your needs. Helm I'll

348
00:22:05,048 --> 00:22:08,680
mention that as well because it's so widely used and popular

349
00:22:08,760 --> 00:22:12,960
for good reasons. Helm uses a more custom

350
00:22:13,030 --> 00:22:16,732
templating language based on go templates

351
00:22:16,796 --> 00:22:19,868
and then packages those into what's called a helm chart.

352
00:22:19,964 --> 00:22:23,484
And these helm charts can contain not just templates,

353
00:22:23,532 --> 00:22:27,124
but also tests and a bunch of things that kind of turn

354
00:22:27,162 --> 00:22:30,196
into a package for an application. So helm is a really nice way of kind

355
00:22:30,218 --> 00:22:34,820
of packaging your entire application and then helping others install

356
00:22:34,890 --> 00:22:38,276
that application and then using what's

357
00:22:38,308 --> 00:22:41,704
called a values file, which once again is a yaml file as

358
00:22:41,742 --> 00:22:45,416
input, you can parameterize those helm templates. So a

359
00:22:45,438 --> 00:22:49,096
user would generally use your helm chart, create their own values

360
00:22:49,128 --> 00:22:53,160
file where they might specify custom ports or custom namespaces

361
00:22:53,240 --> 00:22:56,684
or whatever other ways you might allow your helm chart to be

362
00:22:56,722 --> 00:23:00,172
configuration, and then they apply those value

363
00:23:00,226 --> 00:23:04,176
files to your helm chart. And then helm can do its magic and take the

364
00:23:04,198 --> 00:23:07,712
output and apply that to kubernetes. And these

365
00:23:07,766 --> 00:23:11,324
helm charts are distributed through helm repositories,

366
00:23:11,372 --> 00:23:14,164
and there's a bunch of them out there. So if you look at artifactory or

367
00:23:14,202 --> 00:23:17,348
just search for helm repositories, you'll find

368
00:23:17,434 --> 00:23:22,436
a lot and you'll find that there are helm charts for many

369
00:23:22,538 --> 00:23:26,616
common infrastructure tools like databases and

370
00:23:26,718 --> 00:23:30,520
web gateways and game. Even Minecraft has its own

371
00:23:30,590 --> 00:23:33,850
helm chart. I'd like to mention

372
00:23:34,300 --> 00:23:37,464
a really neat practice that's been coming

373
00:23:37,502 --> 00:23:40,990
up lately and is about using helm and kustomize together.

374
00:23:44,080 --> 00:23:47,756
The workflow here is that you would use helm to package your

375
00:23:47,778 --> 00:23:51,024
application and then use customize to

376
00:23:51,062 --> 00:23:53,900
overlay any runtime configurations,

377
00:23:53,980 --> 00:23:57,292
right, because specific CTO your environment,

378
00:23:57,356 --> 00:24:01,628
because the creators of the helm chart

379
00:24:01,724 --> 00:24:05,408
obviously are not always aware of how you're going to deploy that helm

380
00:24:05,424 --> 00:24:08,644
chart. And you might have very specific needs around once again,

381
00:24:08,682 --> 00:24:14,164
security, networking, et cetera, which those

382
00:24:14,202 --> 00:24:17,336
might not be configurable in the helm chart itself. So what you

383
00:24:17,358 --> 00:24:20,644
would do is use helm as an initial phase

384
00:24:20,692 --> 00:24:25,400
and then use customize to overlay any runtime specific projects

385
00:24:25,900 --> 00:24:29,272
over the output of helm. Sounds complicated and

386
00:24:29,326 --> 00:24:32,828
it is complicated, I'll grant you that. But it's a

387
00:24:32,834 --> 00:24:36,408
very powerful concept because it really makes the most of both the tools what they're

388
00:24:36,424 --> 00:24:40,930
really good at. So definitely something exploring as you kind of venture deeper into

389
00:24:41,380 --> 00:24:45,600
the depths of kubernetes, deployments and applications.

390
00:24:48,580 --> 00:24:52,124
How do these tools fit into the lifecycle that we managed

391
00:24:52,172 --> 00:24:55,410
earlier? Let's just look at that here.

392
00:24:55,800 --> 00:24:59,376
Now, instead of jumping straight from edit

393
00:24:59,408 --> 00:25:02,980
to validate, there's a phase where you will want to preview,

394
00:25:03,560 --> 00:25:07,620
meaning that if you're using

395
00:25:07,690 --> 00:25:10,856
helm or customize or any of the other tools, you'll want to

396
00:25:10,958 --> 00:25:14,376
run those tools and get the output of them, which is what would

397
00:25:14,398 --> 00:25:17,576
be applied to your cluster and then run your validations on that.

398
00:25:17,678 --> 00:25:21,288
So you would want to validate the output of customizer helm

399
00:25:21,304 --> 00:25:24,892
and make sure that all the OPA policies and anything else are

400
00:25:24,946 --> 00:25:28,716
in place. You might also want to validate pre preview of course,

401
00:25:28,818 --> 00:25:32,396
but really important to validate what's actually going to be applied to your cluster and

402
00:25:32,418 --> 00:25:36,336
not what's kind of input to another tool, whats does something before it

403
00:25:36,358 --> 00:25:40,128
applies to your cluster. And I wanted to show that quickly

404
00:25:40,294 --> 00:25:44,744
what that looks like. Let's jump back to Monaco.

405
00:25:44,812 --> 00:25:48,500
I'm going to go to a Kubernetes example repository

406
00:25:50,600 --> 00:25:55,484
which has a customized

407
00:25:55,552 --> 00:26:00,152
example. This is just filter on that and

408
00:26:00,206 --> 00:26:04,324
have a look here. So here we can see, we start with the file

409
00:26:04,372 --> 00:26:07,816
Explorer. You can see there's a

410
00:26:07,838 --> 00:26:11,260
base folder here with a deployment,

411
00:26:11,760 --> 00:26:14,588
an Nginx deployment and an NgInx service.

412
00:26:14,674 --> 00:26:18,856
As you can see here, you can see also links between them marked

413
00:26:18,888 --> 00:26:22,864
out in here. And then there are overlays for dev and

414
00:26:22,902 --> 00:26:26,384
prod. And if we look at the overlays themselves, you can see

415
00:26:26,422 --> 00:26:29,824
here that the dev overlay sets the replicas to

416
00:26:29,862 --> 00:26:33,444
one, the production overlay sets it to five,

417
00:26:33,562 --> 00:26:36,960
and the excitement,

418
00:26:37,120 --> 00:26:41,044
the staging overlay sets it to three. So what this basically means

419
00:26:41,082 --> 00:26:45,044
that if I take the dev customization and

420
00:26:45,082 --> 00:26:48,788
preview that, so what that means is now we're

421
00:26:48,804 --> 00:26:52,132
looking at the output of customize

422
00:26:52,196 --> 00:26:55,544
for that customization. You can see that replicas here is set

423
00:26:55,582 --> 00:26:58,796
to one. Let's exit and let's have a look at

424
00:26:58,818 --> 00:27:02,712
the staging customization and preview

425
00:27:02,776 --> 00:27:06,396
that. And then as you can see here, replicas is

426
00:27:06,418 --> 00:27:10,572
now set to three. Right. And just

427
00:27:10,626 --> 00:27:14,048
for sake of getting it all going through everything,

428
00:27:14,134 --> 00:27:18,016
now I'm going to preview the prod customization, and we

429
00:27:18,038 --> 00:27:21,612
will hopefully see that replicas is set to five. Right. Ultimately,

430
00:27:21,676 --> 00:27:25,584
though, the deployment itself by default actually

431
00:27:25,622 --> 00:27:28,916
had replicas set to two. So if I wouldn't have used any of

432
00:27:28,938 --> 00:27:32,868
these, I would have gotten replicas of two. But this is a very

433
00:27:32,954 --> 00:27:36,472
basic example of showing how you can use customize to

434
00:27:36,606 --> 00:27:40,120
set different property values for different target environments.

435
00:27:40,700 --> 00:27:44,276
In this case, replicas for my deployment.

436
00:27:44,468 --> 00:27:47,736
Okay, that was a really quick demo because we are really a little bit

437
00:27:47,758 --> 00:27:51,020
short on time, just quick on tooling.

438
00:27:53,200 --> 00:27:56,316
There's a lot of tools out there. Just to kind of break this down a

439
00:27:56,338 --> 00:28:00,030
little bit. Here's the manifest lifecycle. We talked about these

440
00:28:00,480 --> 00:28:03,804
different phases and then the object lifecycle in your clusters.

441
00:28:03,852 --> 00:28:07,328
Kubectl is great for creating manifests and for deploying them.

442
00:28:07,414 --> 00:28:10,640
It doesn't really have any support for editing, previewing, validating.

443
00:28:12,100 --> 00:28:15,844
Of course, then it's great for updating and deleting projects running

444
00:28:15,882 --> 00:28:18,500
in your cluster. So that's where it really shines.

445
00:28:20,040 --> 00:28:23,908
Next step here would be ides and plugins. So if

446
00:28:23,914 --> 00:28:27,888
you're using visual studio code or intellij, et cetera, the core

447
00:28:27,984 --> 00:28:31,416
ide doesn't do much. Right. You're very reliant on plugins, and that's where

448
00:28:31,438 --> 00:28:35,236
I've put parentheses. So if you kind of cobble

449
00:28:35,268 --> 00:28:38,824
together a bunch of plugins, ids can do most of these things

450
00:28:38,862 --> 00:28:41,884
for you, right? They can create, obviously edit. That's what they're good at.

451
00:28:41,922 --> 00:28:45,464
Validation plugins. There's plugins for deploying, there's plugins

452
00:28:45,512 --> 00:28:48,764
for doing all these different things. The challenge here is that the plugins will

453
00:28:48,802 --> 00:28:52,144
maybe not always be very compatible with each other or up to date,

454
00:28:52,182 --> 00:28:56,364
et cetera, et cetera. And we're having some transition

455
00:28:56,412 --> 00:29:00,640
problems here. Not an issue. Validation tools obviously are great at validating.

456
00:29:02,680 --> 00:29:06,240
Templating tools like helm and Kustomize

457
00:29:06,320 --> 00:29:10,132
can help you create. They obviously do have support for

458
00:29:10,186 --> 00:29:13,744
previewing and applying to your cluster,

459
00:29:13,792 --> 00:29:17,400
and creating and updating and deleting what's already running in your cluster.

460
00:29:19,020 --> 00:29:22,824
You might be familiar with tools like lens or k nine s or other

461
00:29:22,862 --> 00:29:26,484
cluster management tools, great tools. They're very focused

462
00:29:26,532 --> 00:29:30,350
on working with Kubernetes itself. So if

463
00:29:32,000 --> 00:29:35,368
you're connecting to a clusters, you want to see what's running inside that cluster.

464
00:29:35,464 --> 00:29:38,572
They're not really geared at creating manifests, editing them,

465
00:29:38,626 --> 00:29:42,640
previewing or validating them. They have some support, maybe for

466
00:29:42,710 --> 00:29:46,464
applying helm charts, for example. But a big

467
00:29:46,502 --> 00:29:50,416
gap if you're the person that's authoring the pre

468
00:29:50,438 --> 00:29:54,348
deployment phase of your applications. And then there's a more niche

469
00:29:54,444 --> 00:29:57,380
set of tools, Monaco, which I was showing earlier.

470
00:29:58,120 --> 00:30:01,904
You can call them Kubernetes ides or configuration management

471
00:30:01,952 --> 00:30:05,460
tools or whatever, but I think the

472
00:30:05,530 --> 00:30:08,936
pros of these tools is that they try to support the entire lifecycle in a

473
00:30:08,958 --> 00:30:12,536
very productive and integrated way, right? So instead of

474
00:30:12,558 --> 00:30:15,896
having to cobble together all these things using more manual tools and

475
00:30:15,918 --> 00:30:19,676
Clis, you can just use a tool like Monocle, which is basically a wrapper for

476
00:30:19,698 --> 00:30:22,984
all these common tools that you're already using with a nice UI.

477
00:30:23,032 --> 00:30:26,830
But once again, do what works best for you

478
00:30:27,200 --> 00:30:30,476
and what feels most productive. Not trying

479
00:30:30,498 --> 00:30:33,920
CTO say anyone is better worse than another. It's all

480
00:30:33,990 --> 00:30:37,760
up to you and the team. Finally, some best practices.

481
00:30:38,580 --> 00:30:42,144
First thing, understand manifests I hope this talk helped you do

482
00:30:42,182 --> 00:30:46,096
exactly that. Always try to use the latest stable API

483
00:30:46,128 --> 00:30:49,284
version for your manifest, obviously in sync with

484
00:30:49,322 --> 00:30:52,112
the cluster that you're working with targeting.

485
00:30:52,256 --> 00:30:55,584
Keep them simple. Don't add a bunch of default values

486
00:30:55,632 --> 00:31:00,056
unnecessarily. It's just going to be confusing for people to

487
00:31:00,078 --> 00:31:03,624
work with them. Policies talked

488
00:31:03,662 --> 00:31:07,444
about that. Try to use policies. You might not even use a tool to validate

489
00:31:07,492 --> 00:31:10,564
policies, just agreeing and discussing. Having a meeting

490
00:31:10,612 --> 00:31:13,916
about howto work manifests and

491
00:31:13,938 --> 00:31:17,836
some policies around naming is super helpful and creating a

492
00:31:17,858 --> 00:31:21,324
shared common knowledge around how

493
00:31:21,362 --> 00:31:24,940
people are going to work with manifests. Use templating tools,

494
00:31:25,020 --> 00:31:28,688
customize helm, whatever else, whatever works. Don't use them if

495
00:31:28,694 --> 00:31:31,680
you don't need them because they do add a level of complexity.

496
00:31:32,900 --> 00:31:36,336
Validate manifests before you deploy I know there are great tools for

497
00:31:36,358 --> 00:31:40,416
doing in cluster validation, and many CI CD tools can validate

498
00:31:40,448 --> 00:31:43,376
for you. From my point of view, that's a little bit too late. You shouldn't

499
00:31:43,408 --> 00:31:47,510
be deploying things that have errors, trying to deploy things that have errors in them.

500
00:31:48,280 --> 00:31:51,930
Try to deploy as early on in your process, similar to

501
00:31:52,460 --> 00:31:55,800
if you're using linting for your source code. That's something you do in your ide,

502
00:31:55,870 --> 00:31:59,690
and preferably not only as part of

503
00:32:01,340 --> 00:32:05,224
CI process. That being said, you should automate validation

504
00:32:05,272 --> 00:32:08,824
as well, right? So you want to have the automated as more as a safety

505
00:32:08,872 --> 00:32:11,356
check, but try to do it early on because it'll save you a lot of

506
00:32:11,378 --> 00:32:15,168
time. Then finally, I really didn't talk a

507
00:32:15,174 --> 00:32:19,932
lot about Gitops, something I urge you CTO adopt

508
00:32:19,996 --> 00:32:23,184
when you've come for a new journey. If you've come through all these first seven

509
00:32:23,222 --> 00:32:26,404
bullets and you're happy with that, then it's probably a good time to look at.

510
00:32:26,442 --> 00:32:29,956
Start using Gitops. Gitops is similar to

511
00:32:30,058 --> 00:32:33,764
maybe like adopting agile. It's not something that just one person does.

512
00:32:33,802 --> 00:32:36,936
The entire team has to do it, and it does impose some constraints on your

513
00:32:36,958 --> 00:32:40,328
workflows, so be aware of those talk within your

514
00:32:40,334 --> 00:32:43,656
team so everyone's on board and go for it because

515
00:32:43,678 --> 00:32:46,984
it's really awesome. And that's it.

516
00:32:47,182 --> 00:32:50,580
All done here. Thank you so much for listening. Hopefully this was helpful.

517
00:32:50,660 --> 00:32:54,296
Please reach out to me at this email address or on

518
00:32:54,318 --> 00:32:57,796
discord or you can obviously find me in any monocle

519
00:32:57,828 --> 00:33:01,004
related assets online. Thank you so much for listening.

