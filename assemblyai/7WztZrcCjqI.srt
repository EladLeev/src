1
00:00:00,410 --> 00:00:06,174
Jamaica real

2
00:00:06,212 --> 00:00:09,934
time feedback into the behavior of your distributed systems and

3
00:00:09,972 --> 00:00:14,094
observing changes exceptions. Errors in real time

4
00:00:14,212 --> 00:00:17,914
allows you to not only experiment with confidence, but respond

5
00:00:18,042 --> 00:00:20,480
instantly to get things working again.

6
00:00:24,610 --> 00:00:47,130
Close hello,

7
00:00:47,200 --> 00:00:50,750
my fellow javascript. My name's James,

8
00:00:51,090 --> 00:00:54,766
I'm a programmer, I work with my family,

9
00:00:54,948 --> 00:00:57,950
we make apps for horse riders.

10
00:00:58,610 --> 00:01:02,074
My sister's the designer, my dad's the Sysadmin,

11
00:01:02,202 --> 00:01:05,250
I'm the programmer and my mum's the boss.

12
00:01:05,590 --> 00:01:09,182
Now, I'm going to be talking today about the feedback loops

13
00:01:09,326 --> 00:01:12,130
that we experience as programmers.

14
00:01:13,190 --> 00:01:16,354
So I reckon this is a pretty typical

15
00:01:16,402 --> 00:01:19,526
feedback loop for a web developer today. So you

16
00:01:19,548 --> 00:01:23,026
might start off changing some code, then you save the file

17
00:01:23,058 --> 00:01:27,160
you're working on, rebuild your application.

18
00:01:27,530 --> 00:01:31,514
If you're lucky, only the part of the application you've been working on will get

19
00:01:31,552 --> 00:01:35,786
rebuilt because that'll be faster. Reload the page

20
00:01:35,968 --> 00:01:39,754
because you need to be working on the latest code, right?

21
00:01:39,872 --> 00:01:44,086
And again, you might be lucky, it might only reload

22
00:01:44,118 --> 00:01:47,454
the portion of the page that you've been working on. And then

23
00:01:47,492 --> 00:01:50,174
you need to have a test, have a poke around, see if what you did

24
00:01:50,212 --> 00:01:53,200
worked. You might run some automated tests as well.

25
00:01:53,970 --> 00:01:58,020
And then you have to figure out if things didn't go well,

26
00:01:58,710 --> 00:02:02,094
what mistake did you make? And there'll be a period of debugging

27
00:02:02,142 --> 00:02:05,700
and that will usually lead you back to changing more code.

28
00:02:06,070 --> 00:02:10,194
Now the steps here can pretty easily be divided into doing steps

29
00:02:10,322 --> 00:02:14,310
on the left and waiting steps on the right. So the build

30
00:02:14,380 --> 00:02:17,754
and the reload are waiting steps. And when you start

31
00:02:17,792 --> 00:02:21,046
a brand new project, you don't even notice the waiting steps.

32
00:02:21,078 --> 00:02:24,646
They finish so fast, right? But that doesn't

33
00:02:24,678 --> 00:02:28,010
last because as your application grows,

34
00:02:28,590 --> 00:02:31,450
as you add more work to the build chain,

35
00:02:32,030 --> 00:02:35,650
you do start seeing delays. At first they're just subsecut

36
00:02:35,670 --> 00:02:39,534
delays, but they can get longer and longer. And in

37
00:02:39,572 --> 00:02:43,262
worst case scenario, you can end up spending more time waiting than

38
00:02:43,316 --> 00:02:43,920
doing.

39
00:02:49,420 --> 00:02:53,112
So why is slow feedback a problem? Isn't it nice to have a break,

40
00:02:53,246 --> 00:02:56,712
relax our mind while we work? Well, I don't think so.

41
00:02:56,766 --> 00:03:00,728
I think feedback should be fast for three reasons.

42
00:03:00,904 --> 00:03:04,332
One, programmers are creative people,

43
00:03:04,466 --> 00:03:08,392
and like artists, we respond really badly to tedium

44
00:03:08,536 --> 00:03:11,580
and boredom, right? So a slow testing loop,

45
00:03:12,000 --> 00:03:16,012
a slow testing step, a slow build step, breaks our concentration

46
00:03:16,076 --> 00:03:18,848
and takes us out of the zone. And the zone is where we want to

47
00:03:18,854 --> 00:03:22,130
be, right? That's where we do our best work. Two,

48
00:03:22,820 --> 00:03:26,852
it can be really difficult to predict the consequences of

49
00:03:26,986 --> 00:03:30,176
changing a piece of code. And that's

50
00:03:30,208 --> 00:03:33,376
why it's safer to make our changes in small increments and get feedback

51
00:03:33,408 --> 00:03:36,720
each time. A slow feedback loop encourages

52
00:03:36,800 --> 00:03:40,536
us to make a lot of changes all at once and

53
00:03:40,558 --> 00:03:43,944
then see if what we did worked. And what that

54
00:03:43,982 --> 00:03:47,288
does is obscures our mistakes because we've touched a whole lot of

55
00:03:47,294 --> 00:03:50,772
the code base and it's no longer obvious where we've made our mistakes anymore.

56
00:03:50,916 --> 00:03:54,796
And that just leads to more time debugging. And it's really the worst kind

57
00:03:54,818 --> 00:03:58,216
of debugging because no one's going to thank you for fixing a bug

58
00:03:58,328 --> 00:04:01,150
that you created 15 minutes ago, are they?

59
00:04:01,760 --> 00:04:05,360
Lastly, we want to finish our day with a sense of accomplishment,

60
00:04:05,860 --> 00:04:09,264
and it's hard to feel like that if you spent a lot of your day

61
00:04:09,302 --> 00:04:12,508
just waiting around. Now I'm

62
00:04:12,524 --> 00:04:16,180
going to show you a way to get really fast feedback in Javascript,

63
00:04:16,840 --> 00:04:19,940
but first I'm going to tell you a tale.

64
00:04:22,600 --> 00:04:26,440
Before the 80s, before the microcomputer revolution,

65
00:04:26,860 --> 00:04:29,800
before everyone had personal computers,

66
00:04:30,220 --> 00:04:34,036
computers were big, sometimes taking up a whole floor

67
00:04:34,068 --> 00:04:37,716
of an office. They were slow, maybe thousands,

68
00:04:37,748 --> 00:04:40,670
million times slower than computers today.

69
00:04:41,040 --> 00:04:45,672
They could only really do one thing at a time. And they were astronomically

70
00:04:45,816 --> 00:04:49,208
expensive. Because they were so expensive,

71
00:04:49,384 --> 00:04:53,392
the organizations that ran these computers and paid

72
00:04:53,446 --> 00:04:57,068
for them were very reluctant to let them sit idle

73
00:04:57,244 --> 00:05:01,212
ever right. So the name of the game was keeping

74
00:05:01,356 --> 00:05:04,720
utilization at 100% as much as possible.

75
00:05:04,790 --> 00:05:08,564
Like keep those computers burning 24 hours a day, seven days a week

76
00:05:08,602 --> 00:05:12,724
to try and get your money's worth. And the way that they achieved this

77
00:05:12,842 --> 00:05:16,436
was through this thing called batch processing, where you would

78
00:05:16,458 --> 00:05:19,752
create a batch job out of several different programs instead

79
00:05:19,806 --> 00:05:23,236
of running them separately. So you might get, say ten programs

80
00:05:23,348 --> 00:05:26,680
and stitch them together like first program,

81
00:05:26,750 --> 00:05:30,404
second program, third program, fourth program, and feed

82
00:05:30,452 --> 00:05:33,944
that batch job into the computer. The computer would churn

83
00:05:33,992 --> 00:05:37,884
away work at the first job, spit out the output, move on to the next

84
00:05:37,922 --> 00:05:41,756
one, burn away at that. And when all of the batch job was

85
00:05:41,778 --> 00:05:44,850
finished, a human operator would come in and they would

86
00:05:45,220 --> 00:05:48,636
put in the next batch. And this cut down on handler

87
00:05:48,668 --> 00:05:51,708
time. Operator Handler time was very efficient.

88
00:05:51,804 --> 00:05:55,296
The people that paid for the computers loved

89
00:05:55,328 --> 00:05:59,268
batch processing because they really felt like they were getting their best

90
00:05:59,354 --> 00:06:02,896
bang for their buck. But guess who didn't

91
00:06:02,928 --> 00:06:04,340
love batch processing?

92
00:06:06,780 --> 00:06:08,890
The programmers. Us.

93
00:06:09,900 --> 00:06:13,096
The reason it sucked for programmers is that you had

94
00:06:13,118 --> 00:06:16,152
to compete for computer time

95
00:06:16,286 --> 00:06:19,848
with all of these other jobs. So like there might be a

96
00:06:19,854 --> 00:06:23,036
payroll job that calculated everyone's pay for

97
00:06:23,058 --> 00:06:26,476
the company, they might be crunching some numbers, and you just

98
00:06:26,498 --> 00:06:29,404
want to debug your program, you just want to run it to test it,

99
00:06:29,522 --> 00:06:33,456
and you have to submit it along with this batch job,

100
00:06:33,558 --> 00:06:36,928
wait hours, possibly days. It wasn't unusual to have

101
00:06:36,934 --> 00:06:39,964
a 48 hours turnaround for batch jobs,

102
00:06:40,012 --> 00:06:44,324
so made it a real pain to test

103
00:06:44,522 --> 00:06:48,016
your code. Now we're not doing batch processing

104
00:06:48,048 --> 00:06:51,270
much anymore, or barely at all. So what happened?

105
00:06:51,720 --> 00:06:55,140
Well, pretty early on, there was a synergy forming between

106
00:06:55,210 --> 00:06:59,108
computing and telegraphy. So telegraphy

107
00:06:59,284 --> 00:07:03,352
is the long distance transmission of textual messages by

108
00:07:03,406 --> 00:07:06,952
electronic means, right? So nothing

109
00:07:07,006 --> 00:07:10,396
fancy, just text messaging, like we do all day, every day now.

110
00:07:10,498 --> 00:07:14,536
And the way telegraphy used to work is you would stroll into your telegraph

111
00:07:14,568 --> 00:07:17,740
office, and you would pay some money to

112
00:07:17,810 --> 00:07:21,196
send a short text message, and they would

113
00:07:21,218 --> 00:07:25,436
take your text message and hand it to an operator sitting

114
00:07:25,468 --> 00:07:28,556
at a teleprinter. A teleprinter,

115
00:07:28,668 --> 00:07:32,096
as you can see in this photo, is sort of. It is what it

116
00:07:32,118 --> 00:07:35,348
looks like. It's an electric typewriter hooked up to a

117
00:07:35,354 --> 00:07:38,676
phone line, and the operator would dial up some

118
00:07:38,698 --> 00:07:42,736
other operator somewhere in the world who also had a teleprinter.

119
00:07:42,848 --> 00:07:46,612
And when they connected, your operator would type out your message,

120
00:07:46,746 --> 00:07:50,276
which would be printed but in front of the other operator,

121
00:07:50,388 --> 00:07:53,784
and they would slice off your message, and it would be hand delivered to

122
00:07:53,822 --> 00:07:57,208
the recipient. Now, these machines were used

123
00:07:57,374 --> 00:08:00,750
for a long time for human to human communication like this,

124
00:08:02,320 --> 00:08:05,788
way before computers. But in 1955,

125
00:08:05,954 --> 00:08:09,724
someone had the bright idea to hook one of these computers up,

126
00:08:09,922 --> 00:08:13,296
to hook one of these teleprinters up

127
00:08:13,318 --> 00:08:17,440
to a computer. And that's where we got the first command line interface.

128
00:08:19,220 --> 00:08:23,032
Now, one programmer who saw the potential of this interface

129
00:08:23,196 --> 00:08:26,516
was John McCarthy, and he had this

130
00:08:26,698 --> 00:08:31,510
incredibly visionary thing to say in 1959.

131
00:08:32,760 --> 00:08:36,410
Suppose that the programmers has a keyboard at the computer.

132
00:08:36,860 --> 00:08:40,308
So the programmer, not the computer operator,

133
00:08:40,404 --> 00:08:44,072
the programmer. Then they can try their

134
00:08:44,126 --> 00:08:47,956
program, interrogate individual pieces of data or

135
00:08:47,998 --> 00:08:51,772
code, to find an error, make a change, and try

136
00:08:51,826 --> 00:08:54,956
again. So what he's describing here is

137
00:08:54,978 --> 00:08:58,904
basically interactive programming. So programming

138
00:08:58,952 --> 00:09:02,216
with a fast feedback loop where you can just

139
00:09:02,258 --> 00:09:04,690
really delve into what your code's doing.

140
00:09:05,860 --> 00:09:09,056
The only problem with this vision was that at the

141
00:09:09,078 --> 00:09:12,428
time, 1959, no one could afford to use computers

142
00:09:12,444 --> 00:09:16,368
like this, because recall that computers

143
00:09:16,464 --> 00:09:20,036
were very, very expensive, and they could only do one thing at a

144
00:09:20,058 --> 00:09:23,984
time. And if that one thing was interactively

145
00:09:24,032 --> 00:09:27,124
programming, that was a huge waste of that computer's time.

146
00:09:27,162 --> 00:09:30,488
Because if you think about it, when you program, you spend most of the

147
00:09:30,494 --> 00:09:34,548
time thinking. You spend a bit of time typing,

148
00:09:34,724 --> 00:09:37,940
and you spend barely any time at all actually running your program.

149
00:09:38,030 --> 00:09:41,164
So, in effect, that mainframe would have just been

150
00:09:41,202 --> 00:09:43,870
sitting there idle the whole time.

151
00:09:44,800 --> 00:09:48,590
John McCarthy's genius idea

152
00:09:50,640 --> 00:09:54,304
was that if you had enough programmers all working

153
00:09:54,342 --> 00:09:58,384
on a computer at the same time, then that time you spent thinking or

154
00:09:58,422 --> 00:10:02,064
typing would cancel that with someone else running their code,

155
00:10:02,102 --> 00:10:05,924
and you could end up having a reasonably high utilization of

156
00:10:05,962 --> 00:10:10,288
your computer. And John McCarthy called this idea timesharing.

157
00:10:10,464 --> 00:10:13,828
And his team developed the first timesharing system.

158
00:10:13,914 --> 00:10:17,610
So essentially the first computer that could do loops of things at the same time.

159
00:10:18,060 --> 00:10:21,544
And he did that in 1962, and it was big hit with

160
00:10:21,582 --> 00:10:24,744
universities and stuff. But since then, the idea

161
00:10:24,782 --> 00:10:28,912
of timesharing has exploded. The Internet is timesharing.

162
00:10:28,996 --> 00:10:32,584
The idea of having a server that talks to multiple clients

163
00:10:32,712 --> 00:10:36,792
at the same time is a form of timesharing. If you've heard of AWS

164
00:10:36,856 --> 00:10:40,484
Lambda functions, that's just timesharing.

165
00:10:40,632 --> 00:10:43,650
Amazon's just trying to get the most out of their hardware there.

166
00:10:45,860 --> 00:10:50,364
So another great invention that John McCarthy had was the Lisp

167
00:10:50,492 --> 00:10:53,890
programming language. John McCarthy was

168
00:10:54,920 --> 00:10:58,068
an artificial intelligence pioneer. He was one of

169
00:10:58,074 --> 00:11:01,396
the first people working on AI, and that means he has in the

170
00:11:01,418 --> 00:11:05,076
business of writing smart programs. And they

171
00:11:05,098 --> 00:11:08,664
were having trouble doing that with the languages they had at the time, right?

172
00:11:08,702 --> 00:11:12,184
So they had Fortran, which was basically for

173
00:11:12,222 --> 00:11:15,540
scientific number crunching. They has COBOL,

174
00:11:15,620 --> 00:11:19,272
which was a sort of business money oriented language

175
00:11:19,336 --> 00:11:22,670
that is good at producing reports and stuff,

176
00:11:23,440 --> 00:11:27,196
but they were struggling to model intelligence in these sort

177
00:11:27,218 --> 00:11:31,152
of clunky old languages. So John

178
00:11:31,206 --> 00:11:35,072
McCarthy came up with Lisp, which is a much higher

179
00:11:35,126 --> 00:11:37,490
level language than those other ones,

180
00:11:38,020 --> 00:11:42,476
and it has a whole bunch of features that we totally

181
00:11:42,508 --> 00:11:46,176
take for granted. A language missing any of these features

182
00:11:46,288 --> 00:11:52,836
is pretty handicapped these days. And so the

183
00:11:52,858 --> 00:11:56,472
features that appeared in Lisp for the first time

184
00:11:56,606 --> 00:12:00,472
in a high level language were conditionals. So like

185
00:12:00,526 --> 00:12:03,768
if else also in JavaScript we had

186
00:12:03,774 --> 00:12:07,348
the ternary operator. That's a kind of conditional. You don't

187
00:12:07,364 --> 00:12:13,768
even want to know what they were doing before conditionals recursion.

188
00:12:13,864 --> 00:12:17,564
So a function can call itself by name first

189
00:12:17,602 --> 00:12:20,732
class functions. So functions can receive other

190
00:12:20,786 --> 00:12:24,528
functions as arguments, and we use that all the time in

191
00:12:24,534 --> 00:12:28,780
JavaScript. When you register a callback or register an event listener,

192
00:12:28,940 --> 00:12:32,256
the fact that you're passing a function in has an argument that makes it

193
00:12:32,278 --> 00:12:35,848
a first class function, a listpad garbage collection,

194
00:12:35,884 --> 00:12:39,812
which was really cool, really neat idea. Instead of the programmer having

195
00:12:39,866 --> 00:12:43,904
to manually manage their memory and remember to release memory

196
00:12:43,952 --> 00:12:47,704
here and there, when they were no longer using it, the computer just looked

197
00:12:47,742 --> 00:12:50,964
after that. And that freed up these Lisp

198
00:12:51,012 --> 00:12:54,024
programmers to focus on what they were actually trying to do,

199
00:12:54,062 --> 00:12:57,044
which is model intelligence. And lastly,

200
00:12:57,092 --> 00:13:00,684
Lisp had the repl, and I'm going to talk a bit more about

201
00:13:00,722 --> 00:13:04,936
the repl, but I just want to point out that JavaScript

202
00:13:05,048 --> 00:13:08,328
has all five of these features, so anything that's

203
00:13:08,344 --> 00:13:12,160
true for Lisp is essentially true for JavaScript.

204
00:13:14,500 --> 00:13:18,112
So the repl is named after

205
00:13:18,166 --> 00:13:22,050
the functions in this very short lisp program.

206
00:13:22,740 --> 00:13:26,704
So if you're not familiar with Lisp, each matching

207
00:13:26,752 --> 00:13:29,748
pair of parentheses is a function call,

208
00:13:29,834 --> 00:13:32,710
and I've color coded them here to make it a bit easy to read.

209
00:13:33,560 --> 00:13:37,328
So let's walk through what this program does. The first

210
00:13:37,354 --> 00:13:40,824
thing that happens is the read function is called with no

211
00:13:40,862 --> 00:13:45,508
arguments, and that sends a prompt to the user's teleprinter

212
00:13:45,684 --> 00:13:49,900
and waits for them to type in some source code. When the user's done,

213
00:13:50,050 --> 00:13:53,916
they press return and read returns that source code

214
00:13:54,018 --> 00:13:58,264
to eval. Now, eval evaluates

215
00:13:58,312 --> 00:14:01,504
the source code, it runs the source code, and it returns the

216
00:14:01,542 --> 00:14:05,036
resulting value. That value is passed

217
00:14:05,068 --> 00:14:08,988
to print, which prints that value out textually

218
00:14:09,164 --> 00:14:12,610
to the teleprinter. And when print is done,

219
00:14:13,240 --> 00:14:15,910
loop sends us back to read,

220
00:14:16,440 --> 00:14:20,096
read eval, print loop

221
00:14:20,288 --> 00:14:23,940
repl the best way to understand how the repl works

222
00:14:24,010 --> 00:14:28,176
is to see it in action. And as Javascripters we are blessed

223
00:14:28,208 --> 00:14:31,210
with a proliference of repls. In fact,

224
00:14:31,580 --> 00:14:35,048
every modern browser has a repl in it, and it's super easy to

225
00:14:35,054 --> 00:14:38,284
bring it up. I'll just do it right here. I'm just going to right

226
00:14:38,322 --> 00:14:39,870
click anywhere on the page,

227
00:14:41,840 --> 00:14:45,630
press inspect, and we get

228
00:14:46,080 --> 00:14:49,688
the devtools. Now I'm in chrome here, but it's

229
00:14:49,704 --> 00:14:53,420
a very similar way if you're on Firefox or Safari,

230
00:14:53,580 --> 00:14:57,650
and we want the console tab. That's where your logs and errors get spat out.

231
00:14:58,820 --> 00:15:01,996
And down the bottom, beneath all your logs and errors,

232
00:15:02,108 --> 00:15:05,296
there's a prompt, and that's where you can type in your source

233
00:15:05,328 --> 00:15:07,220
code to be evaluated.

234
00:15:08,440 --> 00:15:12,660
Here we go. We can also evaluate functions,

235
00:15:14,760 --> 00:15:18,184
and we can evaluate functions that have side

236
00:15:18,222 --> 00:15:22,010
effects as well. So we'll do a little

237
00:15:22,940 --> 00:15:26,596
hello world. Notice we got two results

238
00:15:26,628 --> 00:15:30,892
here. We had the hello world being printed. That was the first thing,

239
00:15:31,026 --> 00:15:34,744
but then we get undefined, and the reason we get undefined

240
00:15:34,792 --> 00:15:39,224
is that hello world was the side effect. But console

241
00:15:39,272 --> 00:15:42,896
log returns undefined. The thing about the repl is you

242
00:15:42,918 --> 00:15:46,560
always get some value back, even if it's just undefined.

243
00:15:47,700 --> 00:15:51,728
And we're hooked up to the page here so we can access

244
00:15:51,894 --> 00:15:55,750
the Dom. So I'm going to use the repl

245
00:15:57,960 --> 00:16:01,396
to give this slide a little

246
00:16:01,418 --> 00:16:03,380
bit of historical accuracy,

247
00:16:05,580 --> 00:16:09,770
because after all, we didn't get lowercase until the late 60s.

248
00:16:11,500 --> 00:16:15,512
Because we're interacting with a living running page, we can also

249
00:16:15,646 --> 00:16:18,360
schedule tasks for future execution.

250
00:16:19,840 --> 00:16:22,590
So if I pass set timeout, a function,

251
00:16:23,440 --> 00:16:26,190
in this case the log function,

252
00:16:27,280 --> 00:16:30,764
we're going to ask for log to be called with

253
00:16:30,962 --> 00:16:34,380
a string in 5 seconds.

254
00:16:34,980 --> 00:16:38,256
Set timeout returns a timer id, which we

255
00:16:38,278 --> 00:16:42,000
can use to cancel the job, and then it prints out our string.

256
00:16:42,740 --> 00:16:46,100
So the great thing about the oracle, great thing about the repl

257
00:16:46,170 --> 00:16:49,588
sorry, is it's a form of oracle, so we ask it questions

258
00:16:49,674 --> 00:16:53,104
and it gives us answers. And that's really handy for a language

259
00:16:53,152 --> 00:16:56,490
like JavaScript, because, well, I mean,

260
00:16:57,580 --> 00:17:02,324
it's no secret that Javascript was designed

261
00:17:02,372 --> 00:17:06,330
in ten days, didn't get everything right, actually got a lot of things wrong,

262
00:17:06,780 --> 00:17:10,396
and it's vital having a way to sort of check out

263
00:17:10,418 --> 00:17:13,852
language features before you go and put them in your program, where they might cause

264
00:17:13,986 --> 00:17:17,592
horrible, hard to debug problems. For instance,

265
00:17:17,656 --> 00:17:22,204
JavaScript has this y two k, but I'll

266
00:17:22,252 --> 00:17:26,210
show you it. So we're going to ask the current date

267
00:17:28,180 --> 00:17:29,650
what its year is,

268
00:17:31,220 --> 00:17:35,552
and we get back just a completely nonsensical

269
00:17:35,616 --> 00:17:38,788
answer. So what this method was intended to do

270
00:17:38,954 --> 00:17:42,596
was give us a two digit year, but what it does in

271
00:17:42,618 --> 00:17:46,132
reality, and this is what the JavaScript specification

272
00:17:46,196 --> 00:17:49,976
says it does, is it returns the number of years since

273
00:17:50,158 --> 00:17:53,220
1900, which is insane.

274
00:17:53,380 --> 00:17:56,090
JavaScript was designed in 1995,

275
00:17:56,460 --> 00:17:59,804
so that meant the date function was going to work for

276
00:17:59,842 --> 00:18:03,816
five years. Interestingly, it's not actually JavaScript's

277
00:18:03,848 --> 00:18:07,672
fault as such. If you look at Java,

278
00:18:07,816 --> 00:18:11,436
Java has a date object, which has a get year method,

279
00:18:11,628 --> 00:18:15,712
which does exactly this. And the only reason this is in JavaScript is because

280
00:18:15,766 --> 00:18:19,276
Java did it first, and JavaScript had to copy some superficial

281
00:18:19,308 --> 00:18:23,184
things from Java. Right now,

282
00:18:23,222 --> 00:18:26,710
everything, all the code I've typed in so far has been very low level,

283
00:18:27,720 --> 00:18:31,044
and that's because all we've really got to work with here are features of the

284
00:18:31,082 --> 00:18:34,720
language, like numbers, math,

285
00:18:34,800 --> 00:18:38,104
random, and features of the runtime, like the

286
00:18:38,142 --> 00:18:41,556
document object and anything that we've

287
00:18:41,588 --> 00:18:44,948
declared via the prompt. So I could declare a variable or define

288
00:18:44,964 --> 00:18:47,930
a function and then call that later on.

289
00:18:49,420 --> 00:18:51,756
And that might have been all right. It might have been all right to just

290
00:18:51,778 --> 00:18:55,116
have this low level kind of repl in the 60s

291
00:18:55,138 --> 00:18:58,568
when people were still writing their programs on paper, but it's

292
00:18:58,584 --> 00:19:01,650
not really compatible with how we write applications today.

293
00:19:02,020 --> 00:19:05,504
So these days we split up our application

294
00:19:05,622 --> 00:19:09,388
into modules, and we store these modules

295
00:19:09,484 --> 00:19:13,064
in files and we edit them with a graphical

296
00:19:13,132 --> 00:19:17,216
text editor we're not using teleprinters anymore

297
00:19:17,408 --> 00:19:20,996
and it's not entirely obvious how we're supposed to sort

298
00:19:21,018 --> 00:19:24,132
of get our own code, our own modules or our third

299
00:19:24,186 --> 00:19:27,910
party modules into the repl so that we can play around with them.

300
00:19:29,080 --> 00:19:33,028
One thing you might think of doing is copying and pasting stuff into the prompt,

301
00:19:33,124 --> 00:19:36,856
and that will sometimes work. It might work for small things, but if you

302
00:19:36,878 --> 00:19:39,468
try to paste a whole module in there,

303
00:19:39,634 --> 00:19:43,276
it's going to blow up. You should not allowed to have an

304
00:19:43,298 --> 00:19:46,716
import statement or an export statement in the

305
00:19:46,738 --> 00:19:48,750
repl in this repl anyway.

306
00:19:50,420 --> 00:19:53,904
I was quite surprised to learn a couple of years ago that this

307
00:19:53,942 --> 00:19:58,050
problem has been solved for almost 50 years,

308
00:19:58,500 --> 00:20:02,096
right? So when Lisp programmers first

309
00:20:02,278 --> 00:20:04,820
got computers with screens,

310
00:20:05,880 --> 00:20:10,260
they realized that they weren't doing this teleprinter thing anymore and they adapted.

311
00:20:10,920 --> 00:20:14,976
And I want to show you what their solution looks like when applied

312
00:20:15,008 --> 00:20:19,130
to JavaScript. So this is

313
00:20:19,580 --> 00:20:22,890
a garden variety text editor vs. Code.

314
00:20:24,140 --> 00:20:28,156
And I've got a plugin installed so

315
00:20:28,178 --> 00:20:31,260
that when I press in keyboard shortcuts,

316
00:20:32,720 --> 00:20:36,904
source code gets sent to a repl in the background and returns

317
00:20:36,952 --> 00:20:40,324
back here. So don't worry.

318
00:20:40,392 --> 00:20:42,450
But that webull lost for now,

319
00:20:45,780 --> 00:20:49,184
so we can do all the old favorites, we can log,

320
00:20:49,302 --> 00:20:52,496
we can even blow up if we want. There we

321
00:20:52,518 --> 00:20:56,096
go, error, boom. And because we're still hooked

322
00:20:56,128 --> 00:21:00,150
up to a browser, we still have access to the document object.

323
00:21:01,240 --> 00:21:04,676
Let's run that. So we just modified the

324
00:21:04,698 --> 00:21:08,628
document there so we

325
00:21:08,634 --> 00:21:12,532
can do everything the other repl could do, but with more convenience

326
00:21:12,596 --> 00:21:16,296
because we're in our text editor where we actually write our code,

327
00:21:16,478 --> 00:21:19,240
but we can actually go one step further.

328
00:21:19,900 --> 00:21:23,000
This repl supports modules,

329
00:21:24,700 --> 00:21:28,248
so I'm going to report view, which is the Javascript

330
00:21:28,424 --> 00:21:31,020
library for doing user interfaces.

331
00:21:31,520 --> 00:21:35,184
There we go, we'll import that now, we'll see

332
00:21:35,222 --> 00:21:38,850
what we got, we'll see what that version member holds. There we go,

333
00:21:39,460 --> 00:21:43,184
we're working with view 3.2.30

334
00:21:43,222 --> 00:21:46,524
been. So this is pretty epic.

335
00:21:46,572 --> 00:21:50,084
All of a sudden we can just start importing modules and playing with them

336
00:21:50,122 --> 00:21:54,150
as if they're low level features of the language, which is awesome.

337
00:21:55,480 --> 00:21:58,776
One thing that we can do with this new fanpower is use the

338
00:21:58,798 --> 00:22:01,640
repl to write a module.

339
00:22:02,060 --> 00:22:06,056
So I'm going to write a component using the repl.

340
00:22:06,158 --> 00:22:08,680
This is called RePL driven development.

341
00:22:09,680 --> 00:22:13,720
First thing I write when I start writing a module is a specification

342
00:22:13,880 --> 00:22:16,140
just in, just in plain English.

343
00:22:32,860 --> 00:22:36,376
So in view, a prop is like a parameter for the

344
00:22:36,398 --> 00:22:37,160
component,

345
00:22:42,320 --> 00:22:47,256
right? So now I've got a specification it's

346
00:22:47,288 --> 00:22:50,604
good to write some kind of test. It's good to write the test before

347
00:22:50,642 --> 00:22:53,570
the implementation because then you get to actually test the test.

348
00:22:55,540 --> 00:22:59,680
Now there's two ways of testing

349
00:23:00,420 --> 00:23:04,112
UI components. You can either test automatically or

350
00:23:04,166 --> 00:23:08,148
you can test manually. When you test automatically, you have

351
00:23:08,154 --> 00:23:11,376
to simulate a human, which I think is really hard. So what I'm

352
00:23:11,408 --> 00:23:15,204
doing instead of automated UI testing these days is just

353
00:23:15,242 --> 00:23:18,564
for every component I write, I write a demo. And that

354
00:23:18,602 --> 00:23:22,544
makes it super easy to play around with the component,

355
00:23:22,672 --> 00:23:27,316
debug it, see how it works. So this

356
00:23:27,338 --> 00:23:29,580
is how I'd write a demo for view component.

357
00:23:41,860 --> 00:23:45,532
Now, we haven't ridden our polite component yet, so that's

358
00:23:45,676 --> 00:23:57,010
obviously going to fail when I evaluate it.

359
00:24:02,380 --> 00:24:06,100
And just going to mount this single component

360
00:24:06,180 --> 00:24:09,556
app to the body element. All right. Now to

361
00:24:09,598 --> 00:24:13,772
run this demo, all I do is select

362
00:24:13,826 --> 00:24:17,432
the entire module and evaluate it. That fails

363
00:24:17,496 --> 00:24:21,176
with a reference error because polite component is not defined.

364
00:24:21,288 --> 00:24:24,080
But we can fix that by implementing the component.

365
00:24:26,260 --> 00:24:30,000
So a view component consists of a props property.

366
00:24:30,150 --> 00:24:35,424
That's where we list loops and

367
00:24:35,462 --> 00:24:39,028
a setup function. Now the setup function

368
00:24:39,114 --> 00:24:43,712
is called whenever a new instance of the component is instantiated.

369
00:24:43,776 --> 00:24:47,316
And this is where we can do all our one time setup work, but we

370
00:24:47,338 --> 00:24:49,880
don't actually have any to do right now. So we're just going to go ahead

371
00:24:49,950 --> 00:24:52,810
and return a render function.

372
00:24:54,300 --> 00:24:57,832
So the render function is essentially called

373
00:24:57,886 --> 00:25:02,072
every time the props change. And it's responsible for returning

374
00:25:02,216 --> 00:25:05,550
a tree of dom elements to be rendered on the page.

375
00:25:06,640 --> 00:25:09,864
And the function we use to make a Dom

376
00:25:09,912 --> 00:25:12,430
element is the h function.

377
00:25:13,860 --> 00:25:19,344
And we're just going to create a button element and

378
00:25:19,462 --> 00:25:23,200
we're going to put the pleasantry text inside the element.

379
00:25:23,620 --> 00:25:27,030
All right, so let's run the demo.

380
00:25:27,880 --> 00:25:29,590
There we go. We've got a button,

381
00:25:30,840 --> 00:25:34,084
but it doesn't do anything. And our specification says

382
00:25:34,122 --> 00:25:37,816
that it's supposed to respond to pleasantries, not just invite them.

383
00:25:37,998 --> 00:25:40,090
So we need to do a bit of work still.

384
00:25:52,850 --> 00:25:56,814
We're just going to add an event handler to our

385
00:25:56,852 --> 00:26:03,214
button it.

386
00:26:03,332 --> 00:26:07,140
All right, so let's run that again. There we go.

387
00:26:08,470 --> 00:26:11,714
There we go. Polite little

388
00:26:11,752 --> 00:26:15,474
component there. All we got

389
00:26:15,512 --> 00:26:18,790
left to do is export the component.

390
00:26:22,410 --> 00:26:25,720
And I'm also going to comment out this demo,

391
00:26:26,730 --> 00:26:29,762
but I'm not going to get rid of it because it's going to be useful

392
00:26:29,906 --> 00:26:32,858
the next time I come back to work on this module. So I'm going to

393
00:26:32,864 --> 00:26:33,820
keep it around.

394
00:26:35,790 --> 00:26:39,466
Now, what we end up with here is something that I

395
00:26:39,488 --> 00:26:43,630
like to call a whole module because this module contains its

396
00:26:43,700 --> 00:26:47,626
specification it contains its best and it contains

397
00:26:47,658 --> 00:26:51,150
its implementation. And this is actually a very powerful idea.

398
00:26:51,220 --> 00:26:55,122
It gives you better portability. You can pass your modules around

399
00:26:55,176 --> 00:26:57,380
to different projects, they don't lose anything.

400
00:26:59,190 --> 00:27:02,610
It gives you better maintainability. Like how often

401
00:27:02,680 --> 00:27:06,514
have you found your way to a source file in an unfamiliar code

402
00:27:06,552 --> 00:27:09,954
base and you don't know where that file's tests

403
00:27:10,002 --> 00:27:13,894
are, you don't know where its specification is. This is

404
00:27:13,932 --> 00:27:17,266
good, because when you end up at that buggy line of source

405
00:27:17,298 --> 00:27:20,906
code, then you've got your specification and your best right there. You can just

406
00:27:20,928 --> 00:27:23,100
immediately start fixing things.

407
00:27:26,430 --> 00:27:30,438
Another thing that's neat about using this whole module

408
00:27:30,614 --> 00:27:34,042
repl approach is that you get a better feedback loops.

409
00:27:34,106 --> 00:27:37,518
So this is what our feedback loop looks like. Now notice that the

410
00:27:37,604 --> 00:27:41,486
build and reload steps are gone, and instead of saving the

411
00:27:41,508 --> 00:27:44,080
file, we evaluate code.

412
00:27:46,070 --> 00:27:50,900
The test step is going to take less time because

413
00:27:51,750 --> 00:27:55,426
we're not running tests for anything else

414
00:27:55,528 --> 00:27:59,640
except this particular module. So we've just got less code to run there.

415
00:28:01,530 --> 00:28:06,342
Debugging is going to take less time because

416
00:28:06,396 --> 00:28:09,954
we're not running the whole application, we're only running our module,

417
00:28:10,002 --> 00:28:13,702
which means that we're not going to have to worry about bugs that exist

418
00:28:13,766 --> 00:28:17,930
elsewhere. So it's going to make it easier to track down our mistakes.

419
00:28:20,350 --> 00:28:24,250
The repl I've just been using is called replete

420
00:28:24,670 --> 00:28:28,174
and I wrote replete because I'd heard about people using

421
00:28:28,212 --> 00:28:31,774
the repl like this in other languages, but I'd never

422
00:28:31,812 --> 00:28:35,162
heard of someone doing it in Javascript. I wanted to know if it was possible

423
00:28:35,316 --> 00:28:38,100
and I wanted to know what it was like.

424
00:28:39,270 --> 00:28:42,882
Now I can report back. I really

425
00:28:42,936 --> 00:28:46,414
love it. I think it's really great having this super fast feedback.

426
00:28:46,462 --> 00:28:50,120
I use replete for front end code, backend code,

427
00:28:50,810 --> 00:28:54,210
crazy experiments, stuff I'm putting in production.

428
00:28:54,370 --> 00:28:58,550
And you can use it too. It's fully open source, it's on GitHub.

429
00:28:59,630 --> 00:29:03,142
You just have to get that source and then install a plugin.

430
00:29:03,286 --> 00:29:07,018
There's plugins for sublime vs code,

431
00:29:07,184 --> 00:29:11,014
neo vim and emacs. The plugin

432
00:29:11,062 --> 00:29:14,906
actually doesn't do much. All it does is listen for keyboard shortcuts

433
00:29:14,938 --> 00:29:18,394
and send messages to replete. So like the plugin

434
00:29:18,442 --> 00:29:22,366
for vs code is like 60 lines of javascript. So you

435
00:29:22,388 --> 00:29:24,030
could write that in an afternoon.

436
00:29:25,730 --> 00:29:29,666
Once you got your plugin installed, you can start evaluating your

437
00:29:29,688 --> 00:29:33,038
code in any browser, to any modern browser,

438
00:29:33,134 --> 00:29:37,062
even a browser running on your phone or something. You can evaluate code

439
00:29:37,116 --> 00:29:40,390
in node and you can evaluate it in Dino,

440
00:29:41,130 --> 00:29:45,110
which I feel is the spiritual successor to node.

441
00:29:47,290 --> 00:29:49,270
So just to go back to this comic,

442
00:29:50,170 --> 00:29:53,366
like I love XkCD, but this

443
00:29:53,388 --> 00:29:56,666
comic kind of depresses me because it reminds me of how

444
00:29:56,688 --> 00:29:59,482
I feel when I'm waiting for a test step or a build step,

445
00:29:59,536 --> 00:30:03,494
and I'm not having sword fights. Like, I feel restless,

446
00:30:03,542 --> 00:30:07,214
I feel trapped because I want to continue on with

447
00:30:07,252 --> 00:30:10,734
what I'm doing. I don't want to move my focus onto something else.

448
00:30:10,772 --> 00:30:14,558
But I can't progress until I get that feedback, and it drives

449
00:30:14,574 --> 00:30:18,226
me nuts. And it's a

450
00:30:18,248 --> 00:30:21,938
waste of time, right? So programmer time

451
00:30:22,104 --> 00:30:25,422
is now the most precious resource in any software

452
00:30:25,486 --> 00:30:28,626
project, so we just can't afford to waste it.

453
00:30:28,808 --> 00:30:32,546
Good news is the computers are really fast now. They can do loops

454
00:30:32,578 --> 00:30:36,230
of things at the same time, and if we make it a priority,

455
00:30:36,650 --> 00:30:39,738
we can devise feedback loops that have no

456
00:30:39,824 --> 00:30:43,866
noticeable delay, right? So feedback loops that feel like

457
00:30:43,888 --> 00:30:47,722
that brand new project, but they keep

458
00:30:47,776 --> 00:30:50,540
feeling like that no matter how big the project gets.

459
00:30:51,310 --> 00:30:54,746
And I think that's in the spirit of what John McCarthy

460
00:30:54,778 --> 00:30:58,206
was talking about in the we

461
00:30:58,228 --> 00:31:01,550
can have that now, especially with Javascript.

462
00:31:04,390 --> 00:31:07,620
Thanks everybody. Thanks. If you made it through that,

463
00:31:08,550 --> 00:31:12,146
I found these two things really cool. What makes Repl is a

464
00:31:12,168 --> 00:31:16,386
podcast episode that just really explains how

465
00:31:16,408 --> 00:31:20,610
to do repl driven development. The difference between poking around

466
00:31:20,680 --> 00:31:24,002
on the node repl and really getting it integrated into your text

467
00:31:24,056 --> 00:31:27,906
editor. The second thing is a video that

468
00:31:27,928 --> 00:31:31,466
goes a bit more in depth. I love talking about

469
00:31:31,488 --> 00:31:34,810
this stuff, so feel free to email me.

470
00:31:34,880 --> 00:31:38,826
I'll talk about repls all day. I've got a blog, I've got

471
00:31:38,848 --> 00:31:42,234
a GitHub. Have a great 42.

472
00:31:42,432 --> 00:31:44,920
Thanks so much everybody. See you later.

