1
00:00:41,010 --> 00:00:44,438
Welcome everybody, and thank you for joining me on Conf 42, Cloud native. I hope

2
00:00:44,444 --> 00:00:47,638
you're enjoying all the great talks from all these awesome speakers. Today we're going to

3
00:00:47,644 --> 00:00:51,114
be looking at two revolutionary technologies we're using to learn about Gitops

4
00:00:51,162 --> 00:00:54,782
and see how Gitops is done using flux, and we'll apply Gitops patterns across

5
00:00:54,836 --> 00:00:58,446
multi cloud resources by using crossplane. I think there's no better way to learn than

6
00:00:58,468 --> 00:01:01,886
hands on. So most of this talk is gonna be a live demonstration to see

7
00:01:01,908 --> 00:01:05,246
these cool technologies in action. But before we do that, let's take a quick look

8
00:01:05,268 --> 00:01:08,754
at the theory behind Gitops and the tools we're gonna be using. Before we get

9
00:01:08,792 --> 00:01:11,826
started, I want to tell you a little bit about who I am. My name

10
00:01:11,848 --> 00:01:15,646
is Leonardo Murillo. I'm founder of Cloud Native Architects, a consulting

11
00:01:15,678 --> 00:01:18,734
firm specializing in continuous and progressive delivery slides,

12
00:01:18,792 --> 00:01:21,986
reliability and continuous security. I'm CNCF

13
00:01:22,018 --> 00:01:25,442
community organizer for the Costa Rica chapter, CNCF speaker

14
00:01:25,506 --> 00:01:29,074
and co chair of the CNCF Githubs Working Group. I'm also DevOps Institute

15
00:01:29,122 --> 00:01:32,886
ambassador. I love to connect. I love to network and share ideas

16
00:01:32,918 --> 00:01:36,314
around these projects that I'm so passionate about. So please do

17
00:01:36,352 --> 00:01:39,770
connect with me. Find me on LinkedIn, Twitter, or look me up on my personal

18
00:01:39,840 --> 00:01:43,210
blog. Youll can see the details now to reach me on the screen. Right now

19
00:01:43,280 --> 00:01:47,194
we're going to be looking at some technologies and patterns today that are very revolutionary,

20
00:01:47,242 --> 00:01:51,706
so let's briefly talk about them. My focus today is to actually demonstrate

21
00:01:51,738 --> 00:01:55,018
how these work, but let's get a good idea of what we're

22
00:01:55,034 --> 00:01:58,338
going to be going into. The first subject that we're going

23
00:01:58,344 --> 00:02:02,350
to be looking at. The first concept that we need to grasp is Gitops.

24
00:02:02,430 --> 00:02:06,482
Gitops is an operating model for the continuous delivery of cloud native

25
00:02:06,546 --> 00:02:09,926
applications. What makes it unique is the fact that it's driven by

26
00:02:09,948 --> 00:02:13,126
four principles that to me, wrap its power

27
00:02:13,228 --> 00:02:16,630
in four fundamental tenets. The first one

28
00:02:16,700 --> 00:02:20,266
is the principle of declarative desired state. There's a

29
00:02:20,288 --> 00:02:23,786
fundamental difference between declarative a declarative system and an

30
00:02:23,808 --> 00:02:27,094
imperative system. Imperative means you're given instructions.

31
00:02:27,222 --> 00:02:31,114
You're telling a system what to do to reach an

32
00:02:31,152 --> 00:02:35,274
expected desired state. Githubs is not about imperative. It's but declarative

33
00:02:35,402 --> 00:02:38,926
where you're just describing in code how you want that

34
00:02:38,948 --> 00:02:42,026
system to look like. But you're not specifying which steps

35
00:02:42,058 --> 00:02:45,698
to take to get there. Your state, the desired state of your system,

36
00:02:45,784 --> 00:02:49,214
now, going into principle two should be immutable and versioned,

37
00:02:49,262 --> 00:02:52,814
which means once a desired state hands been pushed

38
00:02:52,862 --> 00:02:56,694
and committed to your fork, to your trunk, to your main

39
00:02:56,732 --> 00:03:00,934
branch, then it should never change. It represents a

40
00:03:00,972 --> 00:03:04,322
static, immutable point in time, and the only way to modify

41
00:03:04,386 --> 00:03:08,134
that to progress your system to a newer desired state

42
00:03:08,252 --> 00:03:11,506
is by committing a new version

43
00:03:11,618 --> 00:03:14,506
so it's versioned can immutable desired state.

44
00:03:14,688 --> 00:03:18,566
Once new versions of state are committed,

45
00:03:18,678 --> 00:03:22,394
there should be a continuous process of state reconciliation,

46
00:03:22,522 --> 00:03:26,510
which means agents, this is automated, not human agents,

47
00:03:26,660 --> 00:03:30,462
are continuously validating that what you have

48
00:03:30,516 --> 00:03:34,114
declared in your state store what you have declared in your

49
00:03:34,152 --> 00:03:37,934
repository where you're storing your declarations of desired

50
00:03:37,982 --> 00:03:41,246
state, is matching that which you're

51
00:03:41,278 --> 00:03:44,690
running on your target system. There's this continuous process

52
00:03:44,760 --> 00:03:48,194
of reconciliation of state, and the fourth principles

53
00:03:48,322 --> 00:03:51,926
means that there should be no other mechanism to interact to

54
00:03:51,948 --> 00:03:54,790
manipulate this target system. Everything that you do,

55
00:03:54,860 --> 00:03:58,886
every operation that you perform should be through code

56
00:03:58,988 --> 00:04:02,666
and through a declaration. The only way for anybody to be able to manipulate the

57
00:04:02,688 --> 00:04:06,394
state of a system is by submitting committing a new

58
00:04:06,432 --> 00:04:09,626
version of desired state. But we're going to be

59
00:04:09,648 --> 00:04:13,310
looking today at Githubs applied CTO, a very specific

60
00:04:13,460 --> 00:04:17,326
area. Multi cloud resources multi cloud resources could be

61
00:04:17,348 --> 00:04:21,754
anything from a SQL managed SQL instance to another Kubernetes

62
00:04:21,802 --> 00:04:24,666
cluster. So how do we declare those in code?

63
00:04:24,788 --> 00:04:28,274
Well, we're going to be using crossplane. Crossplane is a tool that

64
00:04:28,312 --> 00:04:31,486
was created by upbound and eventually handed

65
00:04:31,518 --> 00:04:35,234
over CTO. The CNCF granting sandbox state and crossplane allows us

66
00:04:35,272 --> 00:04:39,262
to declare in code using Kubernetes natives,

67
00:04:39,326 --> 00:04:43,282
for instance, custom resource definitions. Crossplane gives us a whole variety

68
00:04:43,346 --> 00:04:47,454
of crds to create any imaginable resource

69
00:04:47,602 --> 00:04:50,794
across most relevant public clouds that we work

70
00:04:50,832 --> 00:04:54,570
with nowadays has support for Alibaba, Google Cloud,

71
00:04:54,640 --> 00:04:58,614
Azure, AWS, even private cloud providers

72
00:04:58,662 --> 00:05:02,378
gives us a CRD for pretty much any resource that you want

73
00:05:02,384 --> 00:05:06,778
to create. So this allows us to declare code with Kubernetes

74
00:05:06,954 --> 00:05:10,078
declarations. Kubernetes manifests what we want to click create in the

75
00:05:10,084 --> 00:05:13,294
cloud. But how do we make it so that those declarations in some

76
00:05:13,332 --> 00:05:16,958
state store in some repository continuously get reconciled

77
00:05:17,134 --> 00:05:20,542
with our actual runtime state? That's where flux

78
00:05:20,606 --> 00:05:24,306
comes in. Flux is a tool created by Weaveworks, also handed over

79
00:05:24,328 --> 00:05:28,114
to the CNCF that has recently reached incubation status. And Flux

80
00:05:28,162 --> 00:05:31,730
is a tool for doing Githubs on top of kubernetes.

81
00:05:31,810 --> 00:05:35,234
It tracks a repository or a path within a repository,

82
00:05:35,362 --> 00:05:38,950
and makes sure through operators and controllers

83
00:05:39,030 --> 00:05:42,634
that the state of your cluster is consistent with

84
00:05:42,672 --> 00:05:46,006
that declared in the repository. And it's

85
00:05:46,038 --> 00:05:49,366
not just by chance that it satisfies the principles

86
00:05:49,398 --> 00:05:53,374
of Githubs. After all. We'veworkworks, the creators of Flux was

87
00:05:53,412 --> 00:05:56,446
the company that coined the term Gitops. So we're going to be

88
00:05:56,468 --> 00:06:00,126
using this to reconcile crossplane objects on

89
00:06:00,148 --> 00:06:03,534
our Kubernetes cluster to make sure that these site state of our

90
00:06:03,572 --> 00:06:07,054
clouds is always consistent. And now is the time

91
00:06:07,092 --> 00:06:09,826
that we've been expecting. This is what we came here for. We came here to

92
00:06:09,848 --> 00:06:13,602
see how this actually operates. So now I'm going to show you how

93
00:06:13,656 --> 00:06:17,570
this looks in action. Okay, let's get to code. Let me

94
00:06:17,640 --> 00:06:20,790
show you a little bit as to what our setup is going to look like.

95
00:06:20,940 --> 00:06:24,006
Since we're going to be doing Githubs, of course we need a

96
00:06:24,028 --> 00:06:27,846
repository. So I've created a blank, brand new repository that you

97
00:06:27,868 --> 00:06:31,430
can actually access. It's in my personal GitHub,

98
00:06:31,510 --> 00:06:35,034
Marillo Digital, and it's called Conf 42 multicloud. There's nothing

99
00:06:35,072 --> 00:06:38,922
in here other than a readme. You'll also be able to see these two

100
00:06:38,976 --> 00:06:42,506
terminals on this terminal. I'm going to be applying changes to

101
00:06:42,528 --> 00:06:45,038
this repository, and the first thing, of course that I'm going to do is I'm

102
00:06:45,044 --> 00:06:49,374
going to clone this repo. And on this screen you are seeing

103
00:06:49,492 --> 00:06:52,942
canines, which is this really awesome tool, in case you

104
00:06:52,996 --> 00:06:56,834
haven't used it. Look it up, canines, basically showing us what is

105
00:06:56,872 --> 00:07:00,642
currently happening in the repo, in the cluster. So here

106
00:07:00,776 --> 00:07:04,766
we're currently seeing all pods across all namespaces. That's our setup.

107
00:07:04,798 --> 00:07:07,958
This is what we're going to be working with. Step number one that we want

108
00:07:07,964 --> 00:07:11,510
to do is we need to clone this repository.

109
00:07:11,930 --> 00:07:18,620
I'm just going to go ahead and clone it

110
00:07:20,590 --> 00:07:23,850
onto my development workstation.

111
00:07:25,470 --> 00:07:29,530
And here it is. Got an empty repo and an empty cluster.

112
00:07:29,870 --> 00:07:33,370
So we need to bootstrap this cluster

113
00:07:33,450 --> 00:07:37,182
using flux. That's the first step that we have to perform,

114
00:07:37,316 --> 00:07:40,970
so that from that point forward, we will no longer directly

115
00:07:41,050 --> 00:07:45,090
interact with the cluster, rather only through

116
00:07:45,240 --> 00:07:49,042
changes to the repository. Luckily, flux gives

117
00:07:49,096 --> 00:07:52,722
us very simple idea, a very clear idea as to how to

118
00:07:52,776 --> 00:07:56,574
get this done. Since our repo is in GitHub,

119
00:07:56,702 --> 00:08:00,774
we are going to be using the flux Cli that you can actually see

120
00:08:00,812 --> 00:08:03,938
here how to install on the flux documentation

121
00:08:04,034 --> 00:08:07,286
to bootstrap our cluster. For that to work, we need

122
00:08:07,308 --> 00:08:10,646
to export our token, a username so that GitHub,

123
00:08:10,758 --> 00:08:14,266
that flux Cli knows how to authenticate aws us to be able

124
00:08:14,288 --> 00:08:17,322
to work with this repo. Okay, this I've already done.

125
00:08:17,376 --> 00:08:20,926
So if we look at my terminals, I have

126
00:08:21,028 --> 00:08:24,094
already created a GitHub environment, and this

127
00:08:24,132 --> 00:08:27,694
effectively allows flux to know who we

128
00:08:27,732 --> 00:08:31,914
are. We're actually just going to use these variables in the flux cli command

129
00:08:31,962 --> 00:08:35,218
line to trigger our bootstrapping of our

130
00:08:35,224 --> 00:08:38,962
cluster. I've already installed the flux Cli, so if

131
00:08:39,096 --> 00:08:42,900
I run flux here and I run this command right here,

132
00:08:44,710 --> 00:08:48,290
I can actually validate that. I'm ready to use flux.

133
00:08:48,450 --> 00:08:52,034
The versions of Kubernetes hands kubectl

134
00:08:52,162 --> 00:08:55,766
that are required pass. Okay, so now I need to

135
00:08:55,788 --> 00:09:00,046
run a command that is going to allow us to bootstrap

136
00:09:00,178 --> 00:09:03,526
this cluster against our repository.

137
00:09:03,638 --> 00:09:07,002
I'm using to show you that command real quick because I have it here pretty

138
00:09:07,056 --> 00:09:10,990
handy. And I'll tell you what this is. So I'm going to modify it

139
00:09:11,060 --> 00:09:13,040
to match what we have.

140
00:09:14,290 --> 00:09:17,870
The name of our repo is Const 42

141
00:09:18,020 --> 00:09:21,406
multicloud. And we're saying, hey, Flux, I want you to bootstrap using

142
00:09:21,428 --> 00:09:25,302
a GitHub repository, me using the owner. This is a personal repository.

143
00:09:25,386 --> 00:09:28,610
These is the name of the repo, the name of the branch, and this

144
00:09:28,680 --> 00:09:32,402
path is what is going to tell Flux where

145
00:09:32,456 --> 00:09:35,858
to store the manifests that it will create

146
00:09:36,024 --> 00:09:39,762
to match the runtime that it will run against the cluster

147
00:09:39,826 --> 00:09:43,346
and store in the repo. So there is a starting point of consistency

148
00:09:43,458 --> 00:09:47,062
in what's in the repo and what's running on these cluster. So once

149
00:09:47,116 --> 00:09:50,954
we run this, just going to copy this over and

150
00:09:50,992 --> 00:09:54,442
paste these right here. Flux is going to connect

151
00:09:54,496 --> 00:09:58,186
to GitHub. It's going CTO clone the repository that we had

152
00:09:58,208 --> 00:10:01,322
already created, and it's going to generate all sorts of manifests and

153
00:10:01,376 --> 00:10:05,514
apply them. And here you can see on the right side how Flux

154
00:10:05,562 --> 00:10:09,338
has already created multiple control, a helm controller, a customized controller,

155
00:10:09,354 --> 00:10:12,982
hands others as it's bootstrapping the cluster

156
00:10:13,146 --> 00:10:16,946
so that it will actually be able to maintain consistency of

157
00:10:16,968 --> 00:10:20,930
the repo that we're tracking and what it

158
00:10:21,080 --> 00:10:24,546
is running on the cluster itself. Now if

159
00:10:24,568 --> 00:10:26,390
we go back to the repository,

160
00:10:30,810 --> 00:10:34,694
you'll see how new content is

161
00:10:34,732 --> 00:10:39,030
being added here. These manifests

162
00:10:39,110 --> 00:10:43,242
that have been created are the declarations that match

163
00:10:43,376 --> 00:10:47,306
what Flux just did on the system. So once the cluster has

164
00:10:47,328 --> 00:10:51,102
been bootstrapped, now we have a consistent state of

165
00:10:51,156 --> 00:10:54,494
what Flux hands pushed to my repo and what

166
00:10:54,532 --> 00:10:58,094
is running on the cluster. Okay,

167
00:10:58,212 --> 00:11:02,090
now we have our cluster being tracked by Flux, and Flux

168
00:11:02,170 --> 00:11:05,906
having pushed all the manifests that represent that

169
00:11:05,928 --> 00:11:09,234
desired state and is consistent with the runtime, pushed our

170
00:11:09,272 --> 00:11:12,046
repo. Now it's time for us to install crossplane.

171
00:11:12,158 --> 00:11:15,442
The fourth principle that we looked at mentioned that

172
00:11:15,496 --> 00:11:18,550
there should be no direct manipulation of a target system,

173
00:11:18,700 --> 00:11:22,978
which means at this point we will not be doing anything that directly

174
00:11:23,074 --> 00:11:26,386
talks CTO. The Kubernetes API if you look at the crossplane

175
00:11:26,418 --> 00:11:29,766
documentation, the recommended way to install is using helm. So we

176
00:11:29,788 --> 00:11:33,242
are going to be using helm as well, but not by running a helm install.

177
00:11:33,376 --> 00:11:36,986
We're going to be using declarations. Luckily, Flux allows us to

178
00:11:37,008 --> 00:11:40,182
use two different types of technologies to deploy applications.

179
00:11:40,246 --> 00:11:43,934
We can either use helm or we can use customize. Following the

180
00:11:44,052 --> 00:11:47,278
recommended approach by the crossplane documentation, we are going

181
00:11:47,284 --> 00:11:51,262
to be using helm. But before we can install crossplane, we want to create

182
00:11:51,316 --> 00:11:54,926
a namespace for it. Remember, we're not doing anything directly against the

183
00:11:54,948 --> 00:11:57,406
cluster. So the first thing that we need to do is we need to push

184
00:11:57,438 --> 00:12:00,834
a declaration that created that namespace for us.

185
00:12:00,952 --> 00:12:04,510
When the state is reconciled, I've changed canines

186
00:12:04,590 --> 00:12:07,766
to track our different namespaces. So here we're seeing all

187
00:12:07,788 --> 00:12:11,494
namespaces, and I have already pulled the

188
00:12:11,532 --> 00:12:14,902
changes that flux added the code

189
00:12:14,956 --> 00:12:18,466
that flux added to my repo in the cluster,

190
00:12:18,578 --> 00:12:22,762
my cluster path. There is a very valuable observation to make

191
00:12:22,896 --> 00:12:26,602
around this. When I bootstrapped flux, I specified which

192
00:12:26,656 --> 00:12:30,186
path I wanted flux to use to store the manifest, which means you

193
00:12:30,208 --> 00:12:33,266
can do multiple things. You can, in the same repo,

194
00:12:33,318 --> 00:12:37,242
in a single repo, store the state for multiple clusters

195
00:12:37,306 --> 00:12:40,746
as long as they live in different paths. And you can also point multiple

196
00:12:40,778 --> 00:12:44,298
clusters to the same path. So you can effectively control

197
00:12:44,484 --> 00:12:48,126
the state across a fleet of clusters by modifying files

198
00:12:48,158 --> 00:12:51,874
in a single location. Now the other important observation is

199
00:12:51,912 --> 00:12:55,154
that you will want to have some logic behind how you

200
00:12:55,192 --> 00:12:58,786
structure your files within your repository. Here we have already a basis

201
00:12:58,818 --> 00:13:02,082
for that. We have a specific path that matches one or more clusters.

202
00:13:02,146 --> 00:13:05,526
We'll want to create within that path a directory structure that

203
00:13:05,548 --> 00:13:08,806
is also meaningful, that means something to you when

204
00:13:08,828 --> 00:13:12,566
you look at it. The default setup that flux bootstrap

205
00:13:12,598 --> 00:13:16,266
creates is a flux system subdirectory, which is actually consistent with

206
00:13:16,288 --> 00:13:19,702
the flux system namespace that it creates. So I'm going to follow the same pattern,

207
00:13:19,766 --> 00:13:23,178
and I'm going to create a crossplane system subdirectory where I'm going

208
00:13:23,184 --> 00:13:26,398
to be adding all the resources, all the manifests that

209
00:13:26,404 --> 00:13:29,678
I want to be synchronized against my crossplane system

210
00:13:29,764 --> 00:13:33,406
namespace. First thing I'm going to do is I'm going to create a directory crossplane

211
00:13:33,438 --> 00:13:36,946
system, and here

212
00:13:37,048 --> 00:13:40,946
I'm going CTO add a manifest now these

213
00:13:40,968 --> 00:13:45,278
are good old Kubernetes manifests to create our

214
00:13:45,464 --> 00:13:46,630
namespace.

215
00:13:49,530 --> 00:13:53,586
Okay, nothing out of the ordinary, just a namespace

216
00:13:53,618 --> 00:14:00,706
manifest. What's going to happen now is I'm going to commit this adding

217
00:14:00,738 --> 00:14:03,270
namespace for crossplane.

218
00:14:04,810 --> 00:14:10,666
I'm going to, oh wait, I got to add it and

219
00:14:10,688 --> 00:14:14,514
I'm going to push it to the repo. As soon as it's pushed

220
00:14:14,582 --> 00:14:17,886
we're going to see it here. Now we have crossplane system. And now this is

221
00:14:17,908 --> 00:14:21,854
where the magic starts to happen. Pay attention that I haven't done anything other

222
00:14:21,892 --> 00:14:26,046
than pushing this file to the repository. Soon you'll

223
00:14:26,078 --> 00:14:29,762
see here a new namespace show up the crossplane system

224
00:14:29,816 --> 00:14:34,014
namespace that flux is creating

225
00:14:34,062 --> 00:14:37,694
for us as it looks to reconcile the state.

226
00:14:37,832 --> 00:14:41,346
Right now the desired state of my system is different from my runtime

227
00:14:41,378 --> 00:14:45,414
state. It's inconsistent. Flux will make sure that it ends up being

228
00:14:45,452 --> 00:14:49,354
consistent by creating those resources for us. Now this

229
00:14:49,392 --> 00:14:53,382
might take a few seconds because of the cycle

230
00:14:53,446 --> 00:14:57,418
at which flux validates what's running,

231
00:14:57,504 --> 00:15:00,970
what's available in your state store. So let's continue

232
00:15:01,120 --> 00:15:04,490
moving on up. There it is. Crossplane system now exists.

233
00:15:04,570 --> 00:15:07,994
Okay, so we have a namespace for crossplane.

234
00:15:08,042 --> 00:15:11,898
Now let's install crossplane. So we need helm to install crossplane.

235
00:15:11,914 --> 00:15:16,306
Or actually we're going to use helm to install crossplane. Flux comes with

236
00:15:16,488 --> 00:15:19,586
custom resource definitions for helm applications and

237
00:15:19,608 --> 00:15:23,282
customized applications that we're going to use for that you can look at the

238
00:15:23,416 --> 00:15:27,410
documentation in the crossplane website to

239
00:15:27,480 --> 00:15:31,046
get the parameters that we will need as far as helm is

240
00:15:31,068 --> 00:15:34,678
concerned to install this application. Now again, we're just going to

241
00:15:34,684 --> 00:15:37,686
create manifests. So I'm going to create a new manifest here that's going to be

242
00:15:37,708 --> 00:15:41,258
called these helm release. I'm going

243
00:15:41,264 --> 00:15:44,394
to copy over helm release that I already have

244
00:15:44,432 --> 00:15:47,418
available and we'll walk through it real quick.

245
00:15:47,584 --> 00:15:48,540
1 second.

246
00:15:51,410 --> 00:15:55,258
Okay, so in this helm Yaml file we're

247
00:15:55,274 --> 00:15:58,510
using to be adding two different objects,

248
00:15:58,850 --> 00:16:02,662
both coming from the flux

249
00:16:02,826 --> 00:16:05,982
application. One is the helm repository.

250
00:16:06,126 --> 00:16:10,066
Helm repository is basically a type of resource that

251
00:16:10,168 --> 00:16:13,486
specifies helm repo. The URL on the helm

252
00:16:13,518 --> 00:16:16,946
repo is the same URL that you would use if you do helm

253
00:16:16,978 --> 00:16:21,074
repo add. For instance this I got from these crossplane

254
00:16:21,122 --> 00:16:25,058
documentation. Then we're going to create a helm release.

255
00:16:25,154 --> 00:16:29,286
Helm release specifies a helm repository from which

256
00:16:29,308 --> 00:16:32,810
we want to get a helm application and which

257
00:16:32,880 --> 00:16:36,026
name we want to install, which application we want

258
00:16:36,048 --> 00:16:39,386
to install. So here we're saying I want to install the crossplane chart on this

259
00:16:39,408 --> 00:16:43,194
specific versioned and I'm going to get it from this helm repo

260
00:16:43,242 --> 00:16:46,654
called crossplane stable. Crossplane stable is the same name

261
00:16:46,692 --> 00:16:49,934
that we used here in the helm repository. And I'm actually telling it in which

262
00:16:49,972 --> 00:16:52,926
system this repository has been created.

263
00:16:52,958 --> 00:16:56,786
This helm repository object exists. Again, we don't do anything other

264
00:16:56,808 --> 00:17:05,622
than committing this while adding this and

265
00:17:05,676 --> 00:17:09,734
pushing it. Now I'm going to take

266
00:17:09,772 --> 00:17:13,026
a look here as to what we get in term

267
00:17:13,058 --> 00:17:16,546
of pods. Right now we only have flux

268
00:17:16,578 --> 00:17:20,010
system and Kube system. There's nothing running in crossplane system, but we just asked

269
00:17:20,080 --> 00:17:23,302
it to create a new helm release.

270
00:17:23,446 --> 00:17:27,226
Matter of fact, we can even look for helm release here. Oh, there it

271
00:17:27,248 --> 00:17:31,210
is. We have an in progress reconciliation for a crossplane system

272
00:17:31,280 --> 00:17:35,146
helm release. This is actually installing crossplane

273
00:17:35,178 --> 00:17:38,938
for us. This is the equivalent of doing a helm install. Except that crossplane

274
00:17:38,954 --> 00:17:42,426
is doing for us because we added a helm release

275
00:17:42,458 --> 00:17:45,966
in the helm repo manifest. And here you can see that now it says it's

276
00:17:45,998 --> 00:17:49,374
true to reconcile. If we look at pods.

277
00:17:49,502 --> 00:17:53,426
Now we have crossplane running in the crossplane system.

278
00:17:53,528 --> 00:17:56,646
All we did was push a manifest of

279
00:17:56,668 --> 00:18:00,566
a helm release that included a helm release in the helm repo and

280
00:18:00,588 --> 00:18:04,406
we have a helm install of our crossplane system.

281
00:18:04,588 --> 00:18:07,974
Just pretty much awesome, right? But now we have

282
00:18:08,012 --> 00:18:12,122
crossplane unable to talk to anything. We're going to look at two

283
00:18:12,176 --> 00:18:15,594
different types of projects. Now we're going to look at providers and

284
00:18:15,632 --> 00:18:19,286
provider configurations. A provider is what crossplane

285
00:18:19,318 --> 00:18:23,066
uses to talk to any one specific cloud. There's providers for GCP, for AWS,

286
00:18:23,098 --> 00:18:27,434
and for other clouds. And a provider configuration configures that provider

287
00:18:27,562 --> 00:18:31,614
given a set of credentials that it will use to authenticate against that

288
00:18:31,652 --> 00:18:34,714
specific cloud and some additional properties. For instance,

289
00:18:34,762 --> 00:18:38,114
if we're looking at the GCP provider, we need to configure which project

290
00:18:38,232 --> 00:18:42,046
we want that provider to use. So next we're going to push

291
00:18:42,158 --> 00:18:45,298
providers and provider configs. Remember one thing though,

292
00:18:45,384 --> 00:18:48,898
that we'll see soon. Provider configs also need secrets.

293
00:18:48,994 --> 00:18:52,086
Those secrets are actually holding the credentials that

294
00:18:52,108 --> 00:18:55,778
the provider is going to use to talk to those clouds

295
00:18:55,874 --> 00:18:59,606
with some identity. We're also going to look at those. Okay, so we're ready.

296
00:18:59,628 --> 00:19:03,286
CTO install our providers. We're going to go through the same process AWS we've

297
00:19:03,318 --> 00:19:06,458
done already. We're going to declare those in code and push them to

298
00:19:06,464 --> 00:19:09,978
the repo. We need to create one provider for AWS and one provider for

299
00:19:09,984 --> 00:19:13,506
GCP. On this demo, we're going to be creating a SQL database,

300
00:19:13,558 --> 00:19:16,586
a managed SQL database in GCP and in AWS,

301
00:19:16,698 --> 00:19:20,394
since we're going to be talking to two separate clouds, we need CTO define

302
00:19:20,442 --> 00:19:23,922
two separate providers. We're going to do that by

303
00:19:24,056 --> 00:19:27,490
adding a provider manifest to our repository.

304
00:19:27,910 --> 00:19:31,502
First, let's add the AWS provider manifest,

305
00:19:31,646 --> 00:19:35,018
which is a very simple manifest that we're going to just copy

306
00:19:35,054 --> 00:19:39,606
over and

307
00:19:39,628 --> 00:19:44,806
we're going to do the same for our GCP manifest for

308
00:19:44,828 --> 00:19:48,202
our GCP provider. I mean, create another

309
00:19:48,256 --> 00:19:48,970
file.

310
00:19:52,350 --> 00:19:55,754
We're going to paste this provider. Now,

311
00:19:55,792 --> 00:19:59,446
both providers are basically the same. The difference is these package that we're

312
00:19:59,478 --> 00:20:03,082
installing for AWS. We installed the provider AWS package

313
00:20:03,146 --> 00:20:06,974
for GCP. We're installing the provider GCP package. These are not

314
00:20:07,012 --> 00:20:10,574
namespaced resources. They're cluster wide resources and

315
00:20:10,612 --> 00:20:14,094
they were now available in our cluster thanks to Crossplane's

316
00:20:14,142 --> 00:20:17,762
helm install. These crds now are available for us to

317
00:20:17,816 --> 00:20:21,186
leverage. We're going to create two providers, one for

318
00:20:21,208 --> 00:20:25,258
GCP and one for AWS.

319
00:20:25,454 --> 00:20:31,526
We're going to add these two files and

320
00:20:31,548 --> 00:20:33,190
we're going to push this to the repo,

321
00:20:40,190 --> 00:20:43,482
change this here so that we

322
00:20:43,616 --> 00:20:47,930
actually see these resources getting created.

323
00:20:49,070 --> 00:20:51,390
So we need package crossplane,

324
00:20:52,930 --> 00:20:57,120
package crossplane version one

325
00:20:58,850 --> 00:21:05,330
provider providers,

326
00:21:08,790 --> 00:21:13,166
crossplane, version one providers.

327
00:21:13,358 --> 00:21:17,170
Okay, here you can see how we have now two providers,

328
00:21:17,250 --> 00:21:21,282
AWS and GCP. And now they're both healthy

329
00:21:21,346 --> 00:21:25,030
and installed. This means that now we are able to communicate or

330
00:21:25,180 --> 00:21:29,202
we have all these necessary components that we would need for crossplane to communicate

331
00:21:29,266 --> 00:21:32,618
with AWS and GCP. With two notable exceptions. We need

332
00:21:32,624 --> 00:21:36,486
to configure these providers and as part of that configuration we need secrets.

333
00:21:36,598 --> 00:21:40,218
Those secrets are going to include the credentials that we're going to be passing to

334
00:21:40,224 --> 00:21:44,350
the provider so that they can authenticate as us with these specific

335
00:21:44,420 --> 00:21:47,630
cloud that we're going to be engaging. So let's do that.

336
00:21:47,780 --> 00:21:51,082
First, we're going to add those secrets. Secrets.

337
00:21:51,146 --> 00:21:54,034
And of course, by these time you see this, these tokens are going to be

338
00:21:54,072 --> 00:21:57,746
already invalid. So there's no risk here. But I'm going to show you what a

339
00:21:57,768 --> 00:22:01,166
GCP secret looks like and an AWS

340
00:22:01,198 --> 00:22:01,890
secret.

341
00:22:04,310 --> 00:22:06,760
These secrets basically have,

342
00:22:07,850 --> 00:22:11,830
in the case of GCP, the full

343
00:22:11,980 --> 00:22:15,974
JSON key as you would create for an

344
00:22:16,012 --> 00:22:18,860
identity. So let me show you a little bit what that looks like.

345
00:22:20,590 --> 00:22:24,330
This is our GCP secret. It's basically our

346
00:22:24,400 --> 00:22:28,218
encoded JSON key. And I'm going to

347
00:22:28,224 --> 00:22:30,010
do the same for AWS,

348
00:22:37,730 --> 00:22:41,774
which includes our AWS secret key

349
00:22:41,812 --> 00:22:45,300
and secret access key id and secret access key.

350
00:22:47,110 --> 00:22:50,830
If you want CTO understand how these keys were created,

351
00:22:50,910 --> 00:22:54,100
you can look at the crossplane documentation, which is very

352
00:22:54,550 --> 00:22:57,766
thorough. And when you go to install and

353
00:22:57,788 --> 00:23:01,142
configure, scroll the way down. You'll see

354
00:23:01,196 --> 00:23:04,914
here how to create the AWS

355
00:23:04,962 --> 00:23:08,886
credentials or the GCP credentials. And for the GCP

356
00:23:08,918 --> 00:23:12,170
credentials you will need to create a service account.

357
00:23:12,320 --> 00:23:16,262
For AWS you need an identity with AWS

358
00:23:16,406 --> 00:23:20,022
key id and key secret. So please

359
00:23:20,096 --> 00:23:23,374
refer to this URL to understand how to create

360
00:23:23,492 --> 00:23:27,546
these secrets. Once we have the secrets created

361
00:23:27,658 --> 00:23:31,870
which we have here, going to add these secrets

362
00:23:39,250 --> 00:23:42,578
for cloud connection, we're going to

363
00:23:42,584 --> 00:23:47,110
push them to the repo. We also need another resource

364
00:23:47,610 --> 00:23:51,400
that's called a provider configuration and we're also using to need one

365
00:23:51,930 --> 00:23:56,018
for each one of our cloud providers.

366
00:23:56,034 --> 00:23:59,580
So I'm going to show here secrets. Hold on a second.

367
00:24:05,150 --> 00:24:08,618
Oh, here you can see that we have our AWS and GCP provider ready available.

368
00:24:08,704 --> 00:24:11,470
Now we're going to create our provider configurations.

369
00:24:11,970 --> 00:24:15,722
We need one for each cloud and I'll

370
00:24:15,786 --> 00:24:19,950
walk youll through what those look like. So first

371
00:24:20,020 --> 00:24:22,430
let's start with the GCP provider configuration.

372
00:24:28,690 --> 00:24:31,540
Space it over from here and I'll show you what that looks like.

373
00:24:34,950 --> 00:24:38,094
The provider config kind of object is also

374
00:24:38,152 --> 00:24:41,746
made available by crossplane. There is a namespace for GCP

375
00:24:41,778 --> 00:24:45,334
and there's a namespace for AWS and a namespace for the other clouds here.

376
00:24:45,372 --> 00:24:49,154
We're basically configuring how we're going to talk to this cloud

377
00:24:49,212 --> 00:24:52,954
provider. We're specifying which secret we're going to be using to

378
00:24:52,992 --> 00:24:56,762
talk to the cloud. In the case of GCP, which project we

379
00:24:56,816 --> 00:24:59,562
want to create our resources in,

380
00:24:59,696 --> 00:25:03,454
and that's about that. So let's also create the

381
00:25:03,652 --> 00:25:05,470
AWS provider config,

382
00:25:08,930 --> 00:25:12,710
which is going to be very similar. In the case of the AWS provider config.

383
00:25:12,810 --> 00:25:16,034
We don't really need anything other

384
00:25:16,072 --> 00:25:19,426
than just these secret that we're going to be using

385
00:25:19,528 --> 00:25:23,038
to talk CTo the cloud secret,

386
00:25:23,134 --> 00:25:26,286
which name of the secret, what the key within that secret

387
00:25:26,318 --> 00:25:29,494
is. And as you can see, the only difference here is these fact that

388
00:25:29,532 --> 00:25:32,754
the API where this is coming from is not GCP,

389
00:25:32,802 --> 00:25:36,310
rather AWS. We're going to add these two files,

390
00:25:39,310 --> 00:25:43,306
configure providers hands.

391
00:25:43,328 --> 00:25:47,226
We're going to push that to a repository. So now

392
00:25:47,248 --> 00:25:50,686
we have a secret that we're going to need to talk CTo

393
00:25:50,708 --> 00:25:54,330
the clouds. We have our providers installed and configured.

394
00:25:54,410 --> 00:25:58,266
We are now ready to deploy some cloud resources

395
00:25:58,298 --> 00:26:01,882
intro AWS and GCP using crossplane crds.

396
00:26:01,946 --> 00:26:04,782
Awesome. So let's do a little bit of recap of where we are. We started

397
00:26:04,836 --> 00:26:08,206
off with an MTK three s cluster and an empty repo. We used the flux

398
00:26:08,238 --> 00:26:11,714
CLI to bootstrap flux into our cluster, which effectively put

399
00:26:11,752 --> 00:26:15,106
in place all the different manifests in our repo to

400
00:26:15,128 --> 00:26:18,966
be consistent with what's running in the cluster. Then we used flux with its

401
00:26:18,988 --> 00:26:22,518
helm repository hands helm release crds to install

402
00:26:22,604 --> 00:26:26,534
crossplane into our cluster. We added providers and

403
00:26:26,572 --> 00:26:29,766
provider configs for crossplane to be able to talk to our cloud,

404
00:26:29,868 --> 00:26:33,306
including the necessary secrets for those provider configs to be

405
00:26:33,328 --> 00:26:37,558
able to communicate with these cloud. And now it's just a matter of adding

406
00:26:37,654 --> 00:26:41,422
resources hands for practical purposes we're using to install, we're going to create,

407
00:26:41,476 --> 00:26:44,938
we're going to provision an RDS instance in AWS

408
00:26:45,034 --> 00:26:48,734
and a cloud SQL instance in GCP. So I've switched one

409
00:26:48,772 --> 00:26:52,910
of the screens on our setup just now and

410
00:26:52,980 --> 00:26:57,230
now we're looking here on these right side to a AWS console

411
00:26:57,310 --> 00:27:00,686
and a GCP console, specifically the RDS

412
00:27:00,798 --> 00:27:04,114
service hands cloud SQL service. So now we want to

413
00:27:04,152 --> 00:27:07,366
create our databases. I'm going to copy over because I have this

414
00:27:07,388 --> 00:27:10,882
manifest already ready, the GCP database

415
00:27:10,946 --> 00:27:15,170
manifest which we're going to look at real quick. This is Crossplane.

416
00:27:15,330 --> 00:27:19,110
And Crossplane gives us different APIs for the different

417
00:27:19,180 --> 00:27:22,986
types of services that are for every cloud provider. So in this case, we're looking

418
00:27:23,008 --> 00:27:26,266
at the database GCP crossplane IO API and we're looking at

419
00:27:26,288 --> 00:27:29,718
cloud SQL instance. There's some important values that you're

420
00:27:29,734 --> 00:27:33,438
using to want to pay attention to here. One is the provider config ref.

421
00:27:33,524 --> 00:27:37,134
This tells Crossplane which provider config to use for

422
00:27:37,172 --> 00:27:41,086
spinning up this resource, for provisioning this resources. This is valuable because you

423
00:27:41,108 --> 00:27:44,490
can have a single provider, say GCP with multiple provider configs

424
00:27:44,570 --> 00:27:48,242
so that you can use different billing accounts or you can identify as different

425
00:27:48,296 --> 00:27:52,270
users or service accounts or identities within GCP, for instance,

426
00:27:52,350 --> 00:27:55,842
and use access controls to limit who can use which

427
00:27:55,976 --> 00:27:59,314
single cloud provider, multiple provider configs. Here you can specify

428
00:27:59,362 --> 00:28:03,222
which provider config to use as well as pass specific

429
00:28:03,356 --> 00:28:06,918
attributes for the provider to configure your resource. So in

430
00:28:06,924 --> 00:28:10,454
this case, we're telling it which database version we want to use,

431
00:28:10,492 --> 00:28:13,866
which engine we want to use, in which region, et cetera. Now there is a

432
00:28:13,888 --> 00:28:17,142
very valuable feature of crossplane, very powerful,

433
00:28:17,206 --> 00:28:21,142
which is this write connection secret to ref configuration attribute in these manifest.

434
00:28:21,206 --> 00:28:25,194
This allows you to specify the name of a secret in which crossplane

435
00:28:25,242 --> 00:28:28,650
is going to insert the endpoint and credentials

436
00:28:28,730 --> 00:28:32,206
for this specific resource. It's going to pull the data from your cloud provider and

437
00:28:32,228 --> 00:28:35,834
make it available as a secret within your Kubernetes cluster,

438
00:28:35,882 --> 00:28:39,970
which is of course super efficient whenever you create resources and want

439
00:28:40,040 --> 00:28:43,758
applications to connect to those resources without having to do any manual effort. So I'm

440
00:28:43,774 --> 00:28:47,458
going to just do what I've done with all the other manifests that

441
00:28:47,464 --> 00:28:50,450
we've looked at today, add in a commitment,

442
00:28:51,050 --> 00:28:54,840
adding GCP database and push it.

443
00:28:55,530 --> 00:28:59,266
I'm going to show you here on the right side the cloud SQL

444
00:28:59,458 --> 00:29:02,698
console for GCP. Now this is not instantaneous. It's going to

445
00:29:02,704 --> 00:29:06,138
take a few seconds. So while we do that, I'm going to also copy over

446
00:29:06,224 --> 00:29:09,926
the AWS database manifest to my repo.

447
00:29:10,038 --> 00:29:14,186
Let's look at it real quick while this is refreshing,

448
00:29:14,378 --> 00:29:18,366
which we're going to see the database come up soon. And this

449
00:29:18,388 --> 00:29:22,394
is basically a very similar configuration to what we saw. The kind of resource

450
00:29:22,442 --> 00:29:26,554
is different. Now we're looking at an RDS instance database. The API

451
00:29:26,602 --> 00:29:30,046
is different. This is no longer in GCP, this is AWS. But you'll

452
00:29:30,078 --> 00:29:34,034
see a lot of commonality as to how you configure this resource. You're specifying which

453
00:29:34,072 --> 00:29:36,806
provider config to use, which is the same thing that we talked about. You can

454
00:29:36,828 --> 00:29:40,326
have multi configuration for say AWS and

455
00:29:40,348 --> 00:29:44,098
you're passing to your provider parameters as to how to configure

456
00:29:44,194 --> 00:29:47,786
this specific resource as well as which secret to

457
00:29:47,808 --> 00:29:58,234
write the connection details into. Going to add this file and

458
00:29:58,352 --> 00:30:02,698
I'm going to refresh here real quick to see if we're seeing the database already.

459
00:30:02,864 --> 00:30:06,046
Okay, so we waited a minute or two and now let's take

460
00:30:06,068 --> 00:30:09,322
a look at our consoles. We have our RDS instance already created

461
00:30:09,386 --> 00:30:12,746
matching the spec that we defined in our CRD. And we have our cloud SQL

462
00:30:12,778 --> 00:30:15,662
instance created also matching what we had in our CRD.

463
00:30:15,726 --> 00:30:19,266
Just phenomenal. All it took was adding to manifesto repo and

464
00:30:19,288 --> 00:30:22,594
we're actually creating resources in our cloud. Now. There was

465
00:30:22,632 --> 00:30:26,306
one specific attribute to crossplane that I highlighted while

466
00:30:26,328 --> 00:30:30,694
we were looking at the database manifests. The fact that it stores the

467
00:30:30,812 --> 00:30:34,086
connection string credentials and other details that you need to be able

468
00:30:34,108 --> 00:30:37,366
to connect CTO the database as secrets within your cluster. So let's take

469
00:30:37,388 --> 00:30:40,794
a look at that real quick. This is our previous console and let's get

470
00:30:40,832 --> 00:30:44,394
secrets in the crossplane system and

471
00:30:44,432 --> 00:30:47,898
namespace where we asked it to store them. Here you

472
00:30:47,904 --> 00:30:52,186
can see that we have this AWS RDS PostgreSQl connection and clouds postgresql

473
00:30:52,218 --> 00:30:55,422
connection secrets. These are the names that we

474
00:30:55,476 --> 00:30:59,038
specified in our CRD where we wanted the connection secrets to

475
00:30:59,044 --> 00:31:01,760
be stored. Let's look at one of them real quick.

476
00:31:03,990 --> 00:31:09,774
We're going to look at this AWS connection

477
00:31:09,822 --> 00:31:10,530
secret.

478
00:31:13,430 --> 00:31:16,946
And here you can see that we're not going to decrypt it, but we have

479
00:31:16,968 --> 00:31:20,566
our endpoint, we have a password, we have a port and a username. These are

480
00:31:20,588 --> 00:31:23,778
the details that have been provided CTO crossplane

481
00:31:23,794 --> 00:31:27,810
that have been pulled from, in this case AWS by crossplane

482
00:31:27,890 --> 00:31:31,542
and been used to populate the secret, which now you can use anywhere

483
00:31:31,606 --> 00:31:34,678
to connect to this database. It's super powerful.

484
00:31:34,774 --> 00:31:38,346
Cool. So we created our resources. Now we don't want to have

485
00:31:38,368 --> 00:31:41,726
any lingering stuff there, so let's just get rid of these. How do you

486
00:31:41,748 --> 00:31:44,670
get rid of them? Well, you just remove them from your repo.

487
00:31:46,050 --> 00:31:50,234
Let's remove GCP database and AWS database

488
00:31:50,282 --> 00:31:51,840
because we want CTO clean up.

489
00:32:00,550 --> 00:32:05,074
We're going to get rid of our databases and

490
00:32:05,112 --> 00:32:08,846
we push, since we're looking at Githubs,

491
00:32:08,878 --> 00:32:12,178
this is also going CTO reconcile and these is going to destroy our databases.

492
00:32:12,274 --> 00:32:16,098
This is also going to take a few seconds, a minute or two, but we'll

493
00:32:16,114 --> 00:32:19,866
see these databases be destroyed. So that is

494
00:32:19,888 --> 00:32:23,094
the power of crossplane using the Kubernetes

495
00:32:23,142 --> 00:32:27,574
API to manage your cloud resources and fully

496
00:32:27,622 --> 00:32:31,334
managed using a Gitops operating model where I did not interact

497
00:32:31,382 --> 00:32:34,734
with the Kubernetes API directly at all. And everything that I

498
00:32:34,772 --> 00:32:38,814
did is now tracked in git and represents different

499
00:32:38,852 --> 00:32:42,478
points in time of the evolution of my platform. So that is what I

500
00:32:42,484 --> 00:32:46,506
wanted to show you. Crossplane and flux demonstrating the power of Gitops

501
00:32:46,538 --> 00:32:49,998
for multi cloud resource management. I honestly think this is the future, how we're

502
00:32:50,014 --> 00:32:53,442
going to operate clusters. I did not interact with the cluster directly at all.

503
00:32:53,496 --> 00:32:57,314
And there's auditability, there's versioning, and there's these very powerful

504
00:32:57,362 --> 00:33:01,506
mechanism to control and collaborate in managing our platforms,

505
00:33:01,538 --> 00:33:05,718
in managing our cluster hands, our cluster fleets. So I hope you found this

506
00:33:05,804 --> 00:33:09,110
valuable and exciting. You can always reach me,

507
00:33:09,180 --> 00:33:12,406
find me on LinkedIn, you can find me on Twitter. I'd love to show you

508
00:33:12,428 --> 00:33:15,494
more. The repo is available for you to look at the code that we worked

509
00:33:15,532 --> 00:33:19,366
with today. And I'd like to say big thanks to conf 42 for

510
00:33:19,388 --> 00:33:23,290
giving me the trinity to show you how githubs and Crossplane

511
00:33:23,370 --> 00:33:26,846
and Flux can work together to really revolutionize how

512
00:33:26,868 --> 00:33:29,966
we manage multicloud resources. Thank you, and till the

513
00:33:29,988 --> 00:33:30,300
next time.

