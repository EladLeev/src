1
00:02:14,690 --> 00:02:18,366
Hi everyone, thanks for joining us today. Today we are going

2
00:02:18,388 --> 00:02:22,410
to be talking about how you and your organizations can build the evolution evolution

3
00:02:22,490 --> 00:02:26,494
of composable architecture. Graphql Graphql but

4
00:02:26,532 --> 00:02:30,026
before that my name is Priya Singh and I am a senior senior

5
00:02:30,058 --> 00:02:33,514
solutions engineer Mulesoft. I live in Raleigh, North Carolina.

6
00:02:33,642 --> 00:02:37,538
I am a Dei advocate as well as sustainability champion.

7
00:02:37,714 --> 00:02:41,554
I am also a home gardener. I grow flowers and vegetables

8
00:02:41,602 --> 00:02:45,094
in my backyard container garden. I also call

9
00:02:45,132 --> 00:02:48,738
myself a world traveler. And lastly,

10
00:02:48,834 --> 00:02:52,730
talking about the future, I would like to be a professional chef and

11
00:02:52,800 --> 00:02:55,450
at some point get my private flying license.

12
00:02:55,950 --> 00:02:58,710
Enough about me, let's get into the session.

13
00:02:58,870 --> 00:03:01,650
So we are talking about composable architectures,

14
00:03:01,830 --> 00:03:06,042
which means we are talking about APIs. Every organization

15
00:03:06,186 --> 00:03:09,802
is either building APIs or consuming APIs

16
00:03:09,866 --> 00:03:13,626
in one form or another, which means that developers

17
00:03:13,738 --> 00:03:17,234
need to consume data from multiple APIs all at

18
00:03:17,272 --> 00:03:20,994
once. To do that in the past to get data from

19
00:03:21,032 --> 00:03:25,586
multiple sources in the past, we were writing custom code to

20
00:03:25,608 --> 00:03:29,922
be able to collect the data and write it into a presentable format.

21
00:03:30,066 --> 00:03:33,320
Every single step was a custom code project.

22
00:03:33,850 --> 00:03:38,102
It would start from scratch and in the end whatever the deliverable was

23
00:03:38,236 --> 00:03:40,700
was restricted to that particular project.

24
00:03:41,310 --> 00:03:45,846
But today we are not doing that. At least I hope most organizations

25
00:03:45,878 --> 00:03:49,882
are not doing that. Today we are talking about reusability. We are building

26
00:03:49,936 --> 00:03:54,090
APIs for one project and reusing them in different projects.

27
00:03:54,250 --> 00:03:57,774
We are using multiple APIs to get

28
00:03:57,812 --> 00:04:01,342
data from multiple backend systems and then writing maybe

29
00:04:01,396 --> 00:04:05,262
more APIs to collect them and present them in a required

30
00:04:05,326 --> 00:04:08,754
format. But still we are reusing one

31
00:04:08,792 --> 00:04:12,366
API at a time and to extract data from the multiple

32
00:04:12,398 --> 00:04:16,802
APIs. We are writing more APIs on top of it to massage

33
00:04:16,866 --> 00:04:20,646
and transform and orchestrate that data. So that's the

34
00:04:20,668 --> 00:04:24,662
present state. Looking at the future, we would

35
00:04:24,716 --> 00:04:28,518
like for these consumption of multiple APIs to happen

36
00:04:28,604 --> 00:04:32,598
all at once. We have passed these custom code.

37
00:04:32,684 --> 00:04:36,422
That's a non starter. We have moved into the world of rest APIs,

38
00:04:36,486 --> 00:04:39,942
which is a great start. But we can only reuse

39
00:04:40,006 --> 00:04:44,170
one API at a time and this translates to multiple requests

40
00:04:44,250 --> 00:04:47,646
and custom logic to extract the data we need for

41
00:04:47,668 --> 00:04:50,734
our projects. Our aspirational goal then

42
00:04:50,772 --> 00:04:54,738
is to reuse these multiple APIs at once. Like I said, get data

43
00:04:54,824 --> 00:04:58,974
across these APIs at one time with just one request

44
00:04:59,102 --> 00:05:03,506
and no additional custom work to get what we need or need

45
00:05:03,608 --> 00:05:06,920
to write more APIs to create what we need.

46
00:05:07,690 --> 00:05:11,560
And that is exactly why we are talking about GraphQL today.

47
00:05:11,930 --> 00:05:15,270
So what is GraphQL? It is in the simplest form

48
00:05:15,340 --> 00:05:18,994
a query language for APIs where you can query data

49
00:05:19,052 --> 00:05:21,894
from different sources in one single API.

50
00:05:21,942 --> 00:05:25,574
Call if you are familiar with SQL,

51
00:05:25,702 --> 00:05:29,158
it is very similar to writing a join or a query

52
00:05:29,254 --> 00:05:32,646
which fetches data from multiple tables only. In this case

53
00:05:32,688 --> 00:05:36,894
we are fetching data from multiple APIs and

54
00:05:36,932 --> 00:05:40,042
because it is a very low code, no code implementation,

55
00:05:40,186 --> 00:05:43,274
we are talking about clicks and not code. And that's

56
00:05:43,402 --> 00:05:46,814
the reason for its popularity. Another benefit

57
00:05:46,862 --> 00:05:50,562
with GraphQL implementations is that it solves the problem of over

58
00:05:50,616 --> 00:05:53,854
and under fetching. So for example, when you are collecting

59
00:05:53,902 --> 00:05:57,454
data from multiple APIs, you have to parse

60
00:05:57,502 --> 00:06:01,446
through every API one at a time and then extract the

61
00:06:01,468 --> 00:06:05,414
data, read the data taken, write an API to be able to

62
00:06:05,452 --> 00:06:09,382
filter what you need and taken present it to the front end. So that

63
00:06:09,436 --> 00:06:13,638
problem is also solved by GraphQL. You don't need to write that logic

64
00:06:13,734 --> 00:06:17,340
which will remove what you don't need and only pick what you need.

65
00:06:18,030 --> 00:06:21,518
So let's go one level deeper to explain what it means

66
00:06:21,604 --> 00:06:25,642
to query these APIs. A graph of APIs

67
00:06:25,786 --> 00:06:29,006
which will unlock new efficiencies. So if you

68
00:06:29,028 --> 00:06:33,622
look at the picture, this may look similar to your organization's implementation.

69
00:06:33,786 --> 00:06:37,710
You have ERP information, customer information in either your ERP

70
00:06:37,790 --> 00:06:41,090
or another backend, maybe a CRM or another

71
00:06:41,160 --> 00:06:44,674
system, you may have shipment information, maybe in a

72
00:06:44,792 --> 00:06:47,990
database. You may have your product information,

73
00:06:48,140 --> 00:06:51,106
maybe in SQL server.

74
00:06:51,218 --> 00:06:55,382
So data is coming from different sources and

75
00:06:55,436 --> 00:06:59,302
all of these data models or data objects are

76
00:06:59,356 --> 00:07:02,602
its own thing. Now of course,

77
00:07:02,656 --> 00:07:06,614
nobody is just using for product information. Nobody is just asking for shipment

78
00:07:06,662 --> 00:07:09,994
information. We are asked to combine the information and

79
00:07:10,032 --> 00:07:14,062
then present it, for example, order. So an order information will

80
00:07:14,116 --> 00:07:17,966
of course contain shipment id, the customer's information,

81
00:07:18,148 --> 00:07:21,950
the product details of what is part of the order, and all of that.

82
00:07:22,100 --> 00:07:26,050
So that is then another API which pulls data from the customer

83
00:07:26,120 --> 00:07:29,890
API, from the shipment API and then creates that order

84
00:07:29,960 --> 00:07:33,220
API that our developers might use.

85
00:07:33,910 --> 00:07:37,910
So if you looked at this carefully, we can see

86
00:07:37,980 --> 00:07:41,266
that these individual APIs often have relationships

87
00:07:41,298 --> 00:07:45,206
with one another. For example, in these picture, the order API is

88
00:07:45,228 --> 00:07:48,498
related to the customer API through a customer id.

89
00:07:48,684 --> 00:07:52,506
An invoice API is related to the product API through a

90
00:07:52,528 --> 00:07:56,214
product id. And that is interesting because these relationships,

91
00:07:56,262 --> 00:07:59,722
we can conceptually stitch them together and

92
00:07:59,776 --> 00:08:03,982
form a graph to build all the capabilities within

93
00:08:04,036 --> 00:08:07,546
these APIs in one shot. And that's

94
00:08:07,578 --> 00:08:10,960
graphql, the graphql of stitching these APIs together.

95
00:08:11,410 --> 00:08:15,838
Now this big graph will unlock many new possibilities.

96
00:08:16,014 --> 00:08:19,246
We can use this graph more efficiently

97
00:08:19,358 --> 00:08:23,650
to reuse what is already existing in our organizations.

98
00:08:23,990 --> 00:08:27,798
What does that mean? It means that tomorrow, if a project

99
00:08:27,884 --> 00:08:31,494
is asking to show orders, the order status and

100
00:08:31,532 --> 00:08:35,650
the expected delivery date, we will not write another API

101
00:08:35,730 --> 00:08:38,986
to get the data from the product API, from the

102
00:08:39,008 --> 00:08:42,106
customer API, from the shipment API, and the

103
00:08:42,128 --> 00:08:46,202
order API, and the invoice API. To give that view, we will

104
00:08:46,256 --> 00:08:49,210
actually write queries instead of APIs.

105
00:08:50,590 --> 00:08:53,594
That's what we are talking about. The graphql

106
00:08:53,722 --> 00:08:57,294
is actually the next evolution of consumption of

107
00:08:57,332 --> 00:09:00,650
a composable architecture. Using graphQl,

108
00:09:00,730 --> 00:09:04,414
you can easily unify a massive number of APIs

109
00:09:04,542 --> 00:09:07,870
into one single endpoint, which is governed

110
00:09:07,950 --> 00:09:11,934
by a unified schema. This unified schema

111
00:09:12,062 --> 00:09:15,902
is basically the definition, the combined definition of all

112
00:09:15,976 --> 00:09:19,542
the APIs that you are connecting together. In the slide here,

113
00:09:19,596 --> 00:09:23,030
you are seeing that we are connecting product, order, customer,

114
00:09:23,180 --> 00:09:26,070
shipment API into one graphql.

115
00:09:26,650 --> 00:09:29,994
Imagine how many data points can now be

116
00:09:30,032 --> 00:09:34,326
gathered at the click of buttons. This unified

117
00:09:34,358 --> 00:09:37,818
schema allows consumers to request data from any

118
00:09:37,904 --> 00:09:41,838
field, any field that exists within

119
00:09:41,924 --> 00:09:46,218
any of these APIs that are associated or connected

120
00:09:46,314 --> 00:09:50,042
into the GraphQL endpoint. This means actions

121
00:09:50,106 --> 00:09:54,240
that would normally take 510 1520 weeks

122
00:09:55,750 --> 00:09:59,666
will now be done in probably or possibly a day.

123
00:09:59,848 --> 00:10:03,886
So if you look again on the slide, the store API, the marketing

124
00:10:03,918 --> 00:10:07,442
item API, the customer API, all of that is part

125
00:10:07,496 --> 00:10:10,690
of one big graph. And just like any graphql,

126
00:10:10,770 --> 00:10:14,854
you're just going to write a query and pick what you need. So now

127
00:10:14,892 --> 00:10:18,006
I hope you understand GraphQl and what we are trying

128
00:10:18,028 --> 00:10:21,274
to solve with this. Now I will talk about

129
00:10:21,312 --> 00:10:24,582
anypoint data graph. Endpoint data Graph

130
00:10:24,646 --> 00:10:27,830
is Mulesoft's implementation of the GraphQL

131
00:10:27,910 --> 00:10:31,974
technology. In short, it is a no code SaaS

132
00:10:32,022 --> 00:10:35,966
solution with an easy to use GUI to federate your

133
00:10:35,988 --> 00:10:39,418
rest APIs into one graphql endpoint.

134
00:10:39,594 --> 00:10:43,882
You don't have to write multiple API URLs and endpoint

135
00:10:43,946 --> 00:10:48,170
to get the information you need. It will all become one endpoint,

136
00:10:48,250 --> 00:10:51,842
which is a GraphQL endpoint. It also offers very

137
00:10:51,896 --> 00:10:55,986
easy to use GUI and I'll be showing that to you as part of this

138
00:10:56,008 --> 00:10:59,986
session. And you can define very easily relationships

139
00:11:00,018 --> 00:11:03,670
between these multiple data sources, customer, shipment, product order,

140
00:11:03,740 --> 00:11:07,250
whatever you want. So anypoint data graph, I want to clarify,

141
00:11:07,330 --> 00:11:10,186
is not a replacement of GraphQL. Instead,

142
00:11:10,288 --> 00:11:14,470
it is meant to enhance what GraphQL is incorporated

143
00:11:14,630 --> 00:11:18,374
or how GraphQL is actually incorporated into the software development

144
00:11:18,422 --> 00:11:22,510
lifecycle by tightly integrating user experience

145
00:11:22,660 --> 00:11:26,394
into that. More specifically, data graph

146
00:11:26,442 --> 00:11:29,786
is meant to be an easy to use GUI for defining

147
00:11:29,818 --> 00:11:33,434
relationships between multiple data sources and multiple

148
00:11:33,482 --> 00:11:37,390
APIs. So with that said, with that explanation

149
00:11:37,470 --> 00:11:41,682
done and clear, let's see what we are going to see as

150
00:11:41,736 --> 00:11:45,406
part of the demo today. So in today's session,

151
00:11:45,438 --> 00:11:49,222
I'm going to be showing you three core concepts. The apifirst one is

152
00:11:49,276 --> 00:11:53,490
how you can automate the unification of multiple APIs

153
00:11:53,650 --> 00:11:57,126
into one graphQL endpoint. And then I'm going to show

154
00:11:57,148 --> 00:12:00,726
you how you can easily retrieve data through that GraphQL

155
00:12:00,758 --> 00:12:04,458
endpoint. And lastly, I'm going to show you some but of

156
00:12:04,464 --> 00:12:08,298
the box performance that you can get by implementing a

157
00:12:08,304 --> 00:12:12,106
graphQl solution. So let's

158
00:12:12,138 --> 00:12:13,280
get into it.

159
00:12:15,410 --> 00:12:19,290
The first part is automating the unification

160
00:12:19,370 --> 00:12:23,674
of multiple APIs from your backend into one graphQL endpoint.

161
00:12:23,802 --> 00:12:27,474
We will start off with that, it will be quick and easy and we'll show

162
00:12:27,512 --> 00:12:31,426
how it's done. To make this a little more interesting, I'm going

163
00:12:31,448 --> 00:12:35,342
to be following the story of Sana. So Sana is a mobile

164
00:12:35,406 --> 00:12:39,314
application developer and she works at your favorite

165
00:12:39,362 --> 00:12:42,242
retail organization. Could be Macy's, Lowe's,

166
00:12:42,306 --> 00:12:44,230
Walmart, Publix,

167
00:12:45,850 --> 00:12:48,498
Zara, whatever your favorite retailer is.

168
00:12:48,604 --> 00:12:52,234
She's a mobile application developer there. And as part of their

169
00:12:52,272 --> 00:12:55,846
digital initiative, Sana has been tasked to expose

170
00:12:55,878 --> 00:12:59,350
the order status and the expected delivery dates

171
00:12:59,430 --> 00:13:03,078
to your customers on their mobile application. So what

172
00:13:03,104 --> 00:13:07,514
she needs to do, as you're seeing on the screen, is this is the interface

173
00:13:07,562 --> 00:13:11,694
of the mobile application and within these customer's my order page

174
00:13:11,812 --> 00:13:15,646
she has to display the order status and the expected

175
00:13:15,678 --> 00:13:19,266
delivery date. So let's see how Sana would have done this

176
00:13:19,288 --> 00:13:22,866
in the past. So traditionally to accomplish this,

177
00:13:22,968 --> 00:13:26,210
Sana would have to first identify

178
00:13:26,710 --> 00:13:30,246
what APIs she needs to access. So she needs the

179
00:13:30,268 --> 00:13:33,874
expected delivery date, which means probably needs a shipment API

180
00:13:34,002 --> 00:13:38,578
and she needs the status, which means probably the order API.

181
00:13:38,754 --> 00:13:42,490
So she will have to identify what APIs she needs access

182
00:13:42,560 --> 00:13:45,946
to. And hopefully those APIs are already implemented by

183
00:13:45,968 --> 00:13:48,330
the IT teams and the development teams.

184
00:13:48,990 --> 00:13:52,990
Once she has identified, she needs to request access to those APIs

185
00:13:53,410 --> 00:13:56,830
and make sure that she can get the data out using

186
00:13:56,900 --> 00:14:00,366
those APIs and the

187
00:14:00,388 --> 00:14:04,798
APIs to be available to her for consumption. And lastly,

188
00:14:04,974 --> 00:14:08,494
once she has gotten access to those backend APIs,

189
00:14:08,622 --> 00:14:12,402
she will write new code or new logic to filter out

190
00:14:12,456 --> 00:14:16,494
only the information that she needs. For example, order API

191
00:14:16,542 --> 00:14:19,934
will not just have order status, it will have order number,

192
00:14:20,072 --> 00:14:23,298
it may have customer details, it will have product details,

193
00:14:23,394 --> 00:14:26,726
it will have a lot of other extra information that is irrelevant to

194
00:14:26,748 --> 00:14:30,170
Sana. So she will have to write the logic to just pick out order

195
00:14:30,240 --> 00:14:34,326
status from it. Similarly with shipment API that will have delivery

196
00:14:34,358 --> 00:14:37,542
information, the partner or the carrier,

197
00:14:37,686 --> 00:14:41,514
and then the carrier's details and the order details and

198
00:14:41,712 --> 00:14:45,086
could be many other information that is there. But she will have

199
00:14:45,108 --> 00:14:48,718
to write the logic to just pick out the expected delivery date

200
00:14:48,884 --> 00:14:51,840
for her order or for the customer's order.

201
00:14:52,610 --> 00:14:56,206
So think about all this. I mean, I come from a development

202
00:14:56,238 --> 00:15:00,066
background and I know we are talking months. We are

203
00:15:00,088 --> 00:15:03,294
talking months to identify the right APIs,

204
00:15:03,422 --> 00:15:06,674
to get access to those APIs, to make sure I can get

205
00:15:06,712 --> 00:15:10,498
data using those APIs. They are still working and consumable

206
00:15:10,674 --> 00:15:15,302
and to write the logic on top of it to exactly build

207
00:15:15,356 --> 00:15:19,082
the view that I need on my mobile application. Yeah,

208
00:15:19,136 --> 00:15:22,954
we are talking months. But the good

209
00:15:22,992 --> 00:15:26,406
news is Sana's organization

210
00:15:26,518 --> 00:15:30,614
or your favorite retailers have started using anypoint

211
00:15:30,662 --> 00:15:33,786
data graphQL using endpoint

212
00:15:33,818 --> 00:15:38,314
data graph. What these backend teams have done is they have already created

213
00:15:38,442 --> 00:15:42,426
that unified schema for the combination

214
00:15:42,458 --> 00:15:46,274
of order API, sales API, shipment API and

215
00:15:46,312 --> 00:15:49,422
now they are sitting as one graphQl endpoint.

216
00:15:49,566 --> 00:15:52,994
So all the order information, sales and shipment information

217
00:15:53,112 --> 00:15:56,210
is already collected into one graph.

218
00:15:57,290 --> 00:16:01,382
This will make Sana's life so much easier. She is not

219
00:16:01,436 --> 00:16:05,062
just saving months and weeks of effort, she is

220
00:16:05,116 --> 00:16:08,562
saving so much work that she needs to do

221
00:16:08,636 --> 00:16:11,546
from scratch. So this is great.

222
00:16:11,728 --> 00:16:15,482
And this is where my product

223
00:16:15,536 --> 00:16:19,338
will come into the picture. I'm going to show you how quickly

224
00:16:19,424 --> 00:16:23,034
the backend teams can easily combine those APIs for

225
00:16:23,072 --> 00:16:26,814
Sana and present her with these unified view and how she can

226
00:16:26,852 --> 00:16:30,910
then easily query to get the information that she needs for her project

227
00:16:30,980 --> 00:16:34,510
on the mobile application. So we are looking at unifying order,

228
00:16:34,580 --> 00:16:38,610
sales and shipment API and then create that unified schema.

229
00:16:39,990 --> 00:16:43,554
So let's get into the demo and if I look

230
00:16:43,672 --> 00:16:47,314
on the other side of the camera, I'm just going to my browser so

231
00:16:47,352 --> 00:16:50,962
that you can see the right window. So this is

232
00:16:51,016 --> 00:16:55,254
any endpoint data graphql once

233
00:16:55,292 --> 00:16:58,986
you land on this page, this is the view that is presented because

234
00:16:59,088 --> 00:17:02,762
Sana's organization has started using endpoint data

235
00:17:02,816 --> 00:17:06,230
graph. So here in the overview

236
00:17:06,310 --> 00:17:09,914
you can see that it is already deployed in production and the

237
00:17:09,952 --> 00:17:14,014
endpoint is already here. This endpoint is

238
00:17:14,212 --> 00:17:18,174
that one URL using which you can access all

239
00:17:18,212 --> 00:17:21,242
those APIs, the shipment API, the order API,

240
00:17:21,386 --> 00:17:25,042
the sales API and whatever other

241
00:17:25,096 --> 00:17:28,654
APIs is linked into this one graphQL

242
00:17:28,702 --> 00:17:32,466
endpoint. You have one URL to access

243
00:17:32,568 --> 00:17:36,446
all of that. So now you can see the endpoint

244
00:17:36,478 --> 00:17:40,678
here. You can actually use these endpoint in your favorite tool,

245
00:17:40,764 --> 00:17:44,438
like any tool that you use for testing your URLs using a

246
00:17:44,444 --> 00:17:46,950
curl command or any other method,

247
00:17:48,010 --> 00:17:51,670
she can also go and look at the unified schema that was created.

248
00:17:52,170 --> 00:17:54,922
And the good news is that the status is up to date.

249
00:17:55,056 --> 00:17:58,342
This means this is relevant and it is already in production.

250
00:17:58,406 --> 00:18:01,674
So this is how Sana will log in here and see that the

251
00:18:01,712 --> 00:18:05,294
data graph is already created. Now let's see what that

252
00:18:05,332 --> 00:18:09,182
unified schema looks like. So for Sana, she wants

253
00:18:09,236 --> 00:18:13,214
to have the order status and the expected delivery date. So she will

254
00:18:13,252 --> 00:18:17,186
start querying what data types and fields are

255
00:18:17,208 --> 00:18:20,306
part of the unified schema. So if I click on these

256
00:18:20,328 --> 00:18:23,662
unified schema, I see that I have the query operation

257
00:18:23,726 --> 00:18:27,494
available, which means that I can get information, but of

258
00:18:27,532 --> 00:18:30,946
these back end APIs using the endpoint

259
00:18:30,978 --> 00:18:34,626
that was given, if I look here, these are the methods

260
00:18:34,658 --> 00:18:38,666
that are available to me, which means these are the

261
00:18:38,688 --> 00:18:42,394
operations that I can perform on the endpoint. So I can

262
00:18:42,432 --> 00:18:45,658
get customers address by using the iD.

263
00:18:45,744 --> 00:18:49,180
I can get customer details by id, order information,

264
00:18:49,630 --> 00:18:52,974
shipments, address, customer and order. So these

265
00:18:53,012 --> 00:18:56,186
are the main high level operations that are provided

266
00:18:56,218 --> 00:19:00,410
to me to get data, but using the GraphQL endpoint.

267
00:19:00,570 --> 00:19:03,886
So these are the operations available to me and these are the

268
00:19:03,908 --> 00:19:07,042
data types. So if you see here, there is a level one type

269
00:19:07,096 --> 00:19:10,146
and there is nested type. Level one types are

270
00:19:10,168 --> 00:19:14,302
basically the high level data objects that you can directly

271
00:19:14,366 --> 00:19:17,898
get from the query operation. And nested

272
00:19:17,934 --> 00:19:21,686
types are the data fields that are part of the

273
00:19:21,708 --> 00:19:25,638
level one types. So it is kind of like one level below.

274
00:19:25,804 --> 00:19:29,642
So for example, if I wanted the delivery address of where

275
00:19:29,696 --> 00:19:33,530
the product is being shipped to, I cannot just query

276
00:19:34,430 --> 00:19:38,218
address by id and get the delivery address. The delivery address

277
00:19:38,304 --> 00:19:42,166
will be part of the address object and by queries address by

278
00:19:42,208 --> 00:19:45,150
id I can get the delivery address.

279
00:19:45,300 --> 00:19:49,066
Similarly, if I click on order, order will have many fields

280
00:19:49,098 --> 00:19:52,042
below and it may have some nested types.

281
00:19:52,106 --> 00:19:56,370
So these nested types you can get the data using the level one types.

282
00:19:57,430 --> 00:20:01,470
Let's go to order. So she needs order information. So she's going to inspect

283
00:20:01,550 --> 00:20:04,882
whether the fields that she needs are part of the order

284
00:20:04,936 --> 00:20:08,406
data type or not. So if I click on order, I see that

285
00:20:08,428 --> 00:20:11,814
it is a merged type, a merged type,

286
00:20:11,932 --> 00:20:15,570
like the name says, it's very self explanatory. It's a merged

287
00:20:15,650 --> 00:20:19,734
object or a merged data type combining the data from

288
00:20:19,772 --> 00:20:22,886
two APIs, two or more APIs. It doesn't

289
00:20:22,918 --> 00:20:26,410
have to be two. So in this case we are creating an order

290
00:20:26,480 --> 00:20:30,250
data object by combining the information from the sales

291
00:20:30,320 --> 00:20:34,110
API and the order API. Let's see what that means.

292
00:20:34,180 --> 00:20:38,142
So if I scroll below, these are all the fields that are part of

293
00:20:38,196 --> 00:20:41,434
the order object in the unified schema.

294
00:20:41,562 --> 00:20:44,926
So if you see here the order id, customer, email,

295
00:20:45,028 --> 00:20:48,402
delivery, all of these cannot be part of the sales

296
00:20:48,456 --> 00:20:51,634
API or the order API. So some fields here are coming

297
00:20:51,672 --> 00:20:55,166
from sales API, some fields here are coming from the order API,

298
00:20:55,278 --> 00:20:58,766
but we have created a high level order object to get

299
00:20:58,808 --> 00:21:01,160
that all data into one object.

300
00:21:01,850 --> 00:21:05,094
So along with all the fields, she also sees that she can get

301
00:21:05,132 --> 00:21:08,546
the orders by Id or you can also get all the

302
00:21:08,588 --> 00:21:10,940
orders of that particular customer.

303
00:21:11,710 --> 00:21:15,354
So these are the methods available in the order

304
00:21:15,392 --> 00:21:18,940
data type and these are the fields. So now

305
00:21:19,550 --> 00:21:22,438
she needs status and expected delivery.

306
00:21:22,534 --> 00:21:25,742
So she scrolls below and she sees that order status is

307
00:21:25,796 --> 00:21:29,194
here in the part of order data object. And delivery

308
00:21:29,242 --> 00:21:33,022
information is also available to her as part of this

309
00:21:33,076 --> 00:21:36,930
order object. So let's make sure that the delivery object

310
00:21:37,080 --> 00:21:40,338
has the shipment details. So shipment are part of it.

311
00:21:40,424 --> 00:21:44,018
Let's make sure that she has expected delivery date.

312
00:21:44,104 --> 00:21:48,066
So there you go. Address, order status and expected

313
00:21:48,098 --> 00:21:52,246
delivery date are now combined into one order object exactly

314
00:21:52,348 --> 00:21:56,642
as she needs. So let's recap

315
00:21:56,706 --> 00:22:00,202
all the things we saw. So we went to unified schema and we

316
00:22:00,256 --> 00:22:03,386
saw that. Let me go

317
00:22:03,408 --> 00:22:08,282
back. Yeah, so shipment type and then these were all the data

318
00:22:08,336 --> 00:22:12,234
types that were available to Sana. She looked at the order type and made

319
00:22:12,272 --> 00:22:15,694
sure that the two fields she needs are available to her.

320
00:22:15,892 --> 00:22:19,486
Now she's just curious, where are these two fields coming from? So she

321
00:22:19,508 --> 00:22:23,230
can click on list of APIs that are added and it will show her

322
00:22:23,300 --> 00:22:26,558
all the APIs that are part of these unified schema.

323
00:22:26,654 --> 00:22:29,620
So now she knows that shipment address,

324
00:22:29,990 --> 00:22:33,938
sales, customer and order, they are all part of

325
00:22:34,024 --> 00:22:37,494
the unified schema. She can retrieve not just

326
00:22:37,532 --> 00:22:40,966
the order status or the expected delivery date, but she

327
00:22:40,988 --> 00:22:44,582
can extract means more data objects using that same

328
00:22:44,636 --> 00:22:48,502
URL, the same endpoint. She doesn't have to write

329
00:22:48,556 --> 00:22:52,398
different methods or different queries. So let's investigate

330
00:22:52,434 --> 00:22:55,974
a little bit about the order API. So if she clicks on the order API,

331
00:22:56,102 --> 00:22:59,690
it will show all the data types that are part of the order

332
00:22:59,760 --> 00:23:03,674
query API. She can query by order by id, and here

333
00:23:03,712 --> 00:23:07,550
are all the part, again, the fields that are available

334
00:23:07,620 --> 00:23:11,562
to her. So we saw the order merged

335
00:23:11,626 --> 00:23:15,454
object. Now let's see what else is happening with the order

336
00:23:15,572 --> 00:23:19,218
object here. So this is the order. We discussed that it's a

337
00:23:19,224 --> 00:23:22,660
merge type, but we see that it's also a linked type.

338
00:23:23,030 --> 00:23:26,882
Let me show you what that means. So collaboration is enabled because

339
00:23:26,936 --> 00:23:30,770
you want this data type to be added to other schema queries.

340
00:23:30,850 --> 00:23:34,326
That's why we have enabled collaboration. And then these are all

341
00:23:34,348 --> 00:23:37,510
the fields we already saw, these are the fields that are part of the order

342
00:23:37,580 --> 00:23:41,274
merged object. And then here is the

343
00:23:41,312 --> 00:23:44,794
link that is created, the link to another type. So if I click on

344
00:23:44,832 --> 00:23:48,810
here, it will show me that this order

345
00:23:48,880 --> 00:23:52,366
object is actually not just part of

346
00:23:52,388 --> 00:23:55,902
the order API or the sales API, but it is also part

347
00:23:55,956 --> 00:24:00,606
of the customer API and customer Id

348
00:24:00,788 --> 00:24:04,194
is the foreign key. So if you understand SQL, this is

349
00:24:04,232 --> 00:24:08,178
basically connecting your one API to the

350
00:24:08,184 --> 00:24:11,490
other using a common parameter. Like we discussed earlier,

351
00:24:12,470 --> 00:24:16,174
an order API and a product API can be connected with an order

352
00:24:16,232 --> 00:24:19,926
id. Similarly, the order object is

353
00:24:19,948 --> 00:24:23,490
connected to the order API and the customer API

354
00:24:23,570 --> 00:24:27,538
using the customer id. So that's what we call the linked types.

355
00:24:27,714 --> 00:24:31,322
If you again scroll below, it will show you how it is merged into

356
00:24:31,376 --> 00:24:35,082
one and how the overall order object looks

357
00:24:35,136 --> 00:24:38,714
like. So she's sure that she is getting all the information that

358
00:24:38,752 --> 00:24:42,766
she needs, she's happy with it and she's satisfied that she should

359
00:24:42,788 --> 00:24:46,922
be able to write a query and get the data without having to write additional

360
00:24:46,986 --> 00:24:49,120
logic in her mobile application.

361
00:24:50,290 --> 00:24:53,646
So let's go back to the slide and recap what

362
00:24:53,668 --> 00:24:57,234
we just saw. So the takeaway from this part

363
00:24:57,272 --> 00:25:00,930
of what I showed you about endpoint data graph is how

364
00:25:01,000 --> 00:25:04,562
easily backend APIs can be added to one

365
00:25:04,616 --> 00:25:08,386
bigger data graph or one bigger unified schema

366
00:25:08,418 --> 00:25:12,054
or a graphql of those APIs combined together and

367
00:25:12,092 --> 00:25:15,542
how you can do it with clicks and not code. I also

368
00:25:15,596 --> 00:25:19,734
showed you how easily you can decouple all the back end access

369
00:25:19,852 --> 00:25:23,594
issues and these security and all of that from the front end

370
00:25:23,632 --> 00:25:28,198
developers so that they can save a lot of time and easily

371
00:25:28,374 --> 00:25:31,686
get the information that is needed for their projects.

372
00:25:31,798 --> 00:25:35,214
In this case, we are completely decoupling the

373
00:25:35,252 --> 00:25:39,166
backend data source and the data access issues from Sana, who is

374
00:25:39,188 --> 00:25:42,846
the mobile front end developer. And ideally she shouldn't need to be

375
00:25:42,868 --> 00:25:46,260
worrying about those backend things. We will, of course.

376
00:25:47,030 --> 00:25:51,780
So one thing you may wonder about the security is how

377
00:25:53,030 --> 00:25:56,578
we have decoupled the access, but how do we make sure that it

378
00:25:56,584 --> 00:25:59,878
is secure? So the graphql endpoint that I showed you,

379
00:25:59,964 --> 00:26:03,682
you can actually manage that endpoint like any other API.

380
00:26:03,746 --> 00:26:06,886
You can put a lot of security and governance on top of

381
00:26:06,908 --> 00:26:10,506
those APIs so that it is only accessible to the

382
00:26:10,528 --> 00:26:14,586
right teams and to the right people. So that was the first part.

383
00:26:14,768 --> 00:26:18,934
Moving on, let's see how Sana can easily retrieve

384
00:26:18,982 --> 00:26:22,414
data using that graphql endpoint. So we have seen how

385
00:26:22,452 --> 00:26:26,110
backend teams can easily integrate APIs into a graphql.

386
00:26:27,010 --> 00:26:31,070
Now let's look at how front end developers like

387
00:26:31,140 --> 00:26:34,542
Sana can use this. So for this part of the demo,

388
00:26:34,596 --> 00:26:38,514
I'm going to show you how Sana will log into data GraphQL and

389
00:26:38,552 --> 00:26:41,998
build that query and get the data that she needs. So let's

390
00:26:42,014 --> 00:26:45,298
get into it again, I'm moving my face because I'm looking to

391
00:26:45,304 --> 00:26:47,970
the browser, so don't think that I'm going anywhere.

392
00:26:48,390 --> 00:26:52,166
So again, let's go back to data graph. So this

393
00:26:52,188 --> 00:26:55,334
is where we are going to see how Sana will

394
00:26:55,452 --> 00:26:58,886
run the query and get the data. So for that I have to go back

395
00:26:58,908 --> 00:27:00,550
to my unified schema.

396
00:27:03,760 --> 00:27:07,484
And at the top, if you see there is on the right a run operation.

397
00:27:07,612 --> 00:27:10,992
So I will run that operation. Basically run operation in this case

398
00:27:11,046 --> 00:27:15,190
means running that query which will pull the data that Sana needs.

399
00:27:15,640 --> 00:27:19,396
So in the interest of time, I've already saved the query here,

400
00:27:19,578 --> 00:27:23,396
but you can use that graphQl endpoint on

401
00:27:23,418 --> 00:27:27,104
your postman or arc or any other API

402
00:27:27,152 --> 00:27:30,456
testing tool that you have and it will work the same

403
00:27:30,478 --> 00:27:34,372
way. All you have to do is put that URL in the URL

404
00:27:34,436 --> 00:27:37,816
bar and create a query like this. This is

405
00:27:37,838 --> 00:27:41,276
a very simple JSON query that you can run and this should give you

406
00:27:41,378 --> 00:27:44,604
the output that you need. So for example, I have saved this

407
00:27:44,642 --> 00:27:48,684
query and it gives me all the fields that I'm asking for.

408
00:27:48,882 --> 00:27:52,464
So Sana needs order status and these delivery date

409
00:27:52,582 --> 00:27:56,352
so she doesn't need tax amount. So let me remove that

410
00:27:56,486 --> 00:28:00,656
and let me show you another great feature about GraphQl. So right now I

411
00:28:00,678 --> 00:28:03,764
don't know what is the field name

412
00:28:03,882 --> 00:28:06,630
or what other fields are available for me to access.

413
00:28:08,280 --> 00:28:11,636
Now I'll have to

414
00:28:11,658 --> 00:28:15,248
pause. Just think about it. So I have connected order API,

415
00:28:15,344 --> 00:28:18,916
shipment API sales API, customer API.

416
00:28:18,948 --> 00:28:22,504
There were like five, six I showed you, right? They are all connected into one

417
00:28:22,542 --> 00:28:26,552
endpoint. So now I can just simply type a

418
00:28:26,686 --> 00:28:30,344
and it will show me all the APIs

419
00:28:30,472 --> 00:28:34,104
that are available for. I mean I can type any Alphabet

420
00:28:34,152 --> 00:28:38,056
if you think I need delivery

421
00:28:38,088 --> 00:28:41,650
info. So I just write road delivery and it will

422
00:28:42,260 --> 00:28:45,808
autocomplete the right field name for me.

423
00:28:45,974 --> 00:28:49,152
And I don't need to know which

424
00:28:49,206 --> 00:28:52,704
API is this field coming from because now all the

425
00:28:52,742 --> 00:28:56,532
fields that are part of those APIs are combined as one.

426
00:28:56,666 --> 00:29:00,560
So I can click delivery info and it's

427
00:29:00,720 --> 00:29:04,768
giving me the red which means that it's an object. So I can

428
00:29:04,954 --> 00:29:07,450
start writing delivery address.

429
00:29:10,140 --> 00:29:12,250
Actually instead of delivery address,

430
00:29:14,300 --> 00:29:20,280
let's do tracking,

431
00:29:22,460 --> 00:29:29,706
maybe shipment expected

432
00:29:29,738 --> 00:29:33,270
delivery date. There you go. So now if I run this query,

433
00:29:44,200 --> 00:29:46,820
ooh, I think I'm,

434
00:29:47,500 --> 00:29:50,360
I think I'll have to avoid having an array.

435
00:29:51,260 --> 00:29:52,730
So let's try.

436
00:29:59,600 --> 00:30:03,976
Would avoid having can array because I've

437
00:30:04,008 --> 00:30:07,596
ran queries too many times. So let's see what else I

438
00:30:07,618 --> 00:30:10,510
can use. Let's go back to tax amount.

439
00:30:11,520 --> 00:30:14,896
So this is how easily Sana can write

440
00:30:14,918 --> 00:30:19,036
a query and she can add as many or has less fields

441
00:30:19,068 --> 00:30:23,244
she needs. She doesn't need to write more APIs

442
00:30:23,372 --> 00:30:27,330
or custom logic in her mobile application to see

443
00:30:27,780 --> 00:30:30,964
the fields that she needs. She can just abstract all of that

444
00:30:31,002 --> 00:30:34,244
information, unnecessary information out of the query and just

445
00:30:34,282 --> 00:30:37,690
write the fields that she needs. So this is how easy it has.

446
00:30:38,540 --> 00:30:42,488
Now I'll show one more thing. So for example, let's take the example,

447
00:30:42,654 --> 00:30:46,120
let's say Sana is working for a very business

448
00:30:46,190 --> 00:30:51,192
critical application which is sending order

449
00:30:51,246 --> 00:30:54,664
consumption to the customers. As soon as they place the order, they should immediately

450
00:30:54,712 --> 00:30:58,812
get an order confirmation. And we all expect these days like

451
00:30:58,866 --> 00:31:02,124
very quick responses to our retail experience,

452
00:31:02,242 --> 00:31:05,452
right? So in that case, I am

453
00:31:05,506 --> 00:31:08,864
sure the application that Sana would be writing will be very

454
00:31:08,902 --> 00:31:12,864
closely monitored by the business. So she has

455
00:31:12,902 --> 00:31:16,544
to make sure that these query she's writing is responding very

456
00:31:16,582 --> 00:31:20,596
quickly within the SLA that the customers expects. So to make sure that

457
00:31:20,618 --> 00:31:24,084
it is working the way that we expect it to, she can

458
00:31:24,122 --> 00:31:27,784
go here and do a trace query. So now if I run

459
00:31:27,822 --> 00:31:30,330
this again, there you go.

460
00:31:32,060 --> 00:31:35,400
Not just it's giving you the response time

461
00:31:35,470 --> 00:31:39,560
or the throughput time of not just the API call, but every

462
00:31:39,630 --> 00:31:43,372
field. It is showing me how much time every

463
00:31:43,426 --> 00:31:46,732
field is taking to respond back. Why?

464
00:31:46,866 --> 00:31:50,024
Because every field might be coming from a different API.

465
00:31:50,152 --> 00:31:54,236
So now you see that the second record is

466
00:31:54,258 --> 00:31:57,392
taking a lot of time or tax amount is taking the most time.

467
00:31:57,526 --> 00:32:00,752
So you can then find which API tax is coming from and

468
00:32:00,806 --> 00:32:03,692
you can conclude that I need to optimize that API.

469
00:32:03,836 --> 00:32:05,890
So using simple like,

470
00:32:06,740 --> 00:32:10,276
there are so many metrics that are available here that you

471
00:32:10,298 --> 00:32:13,876
can quickly troubleshoot if you are out of SLA or you want

472
00:32:13,898 --> 00:32:17,168
to optimize your queries even further, you can do

473
00:32:17,194 --> 00:32:20,170
that very easily using a lot of metrics available here.

474
00:32:21,020 --> 00:32:24,490
So let's go back and recap what we just saw.

475
00:32:26,940 --> 00:32:30,264
So this is what the takeaways were. We saw that

476
00:32:30,302 --> 00:32:34,024
how Sana and other developers, front end developers,

477
00:32:34,152 --> 00:32:37,912
can streamline data access from a single graphQL endpoint.

478
00:32:37,976 --> 00:32:41,196
They don't have to use multiple URLs or APIs and

479
00:32:41,218 --> 00:32:44,380
they are completely abstracted from the backend APIs.

480
00:32:44,540 --> 00:32:48,364
These can easily update data. They can also improve the performance

481
00:32:48,412 --> 00:32:52,416
and optimize their API calls or their queries to make

482
00:32:52,438 --> 00:32:55,670
sure that they are within slas. So a lot of that

483
00:32:56,520 --> 00:33:01,028
time that would have been spent in writing custom code and

484
00:33:01,194 --> 00:33:04,672
finding out the right thing that we need to grab

485
00:33:04,736 --> 00:33:08,520
and how to grab it, she can spend time on innovating.

486
00:33:09,260 --> 00:33:11,912
So now let's look at the mobile app,

487
00:33:11,966 --> 00:33:15,444
what SAna has used for the query.

488
00:33:15,572 --> 00:33:18,996
These it is. So if you return the right, you have the shipment

489
00:33:19,028 --> 00:33:22,910
tracking information, you have the order details, the status and everything

490
00:33:23,360 --> 00:33:26,796
with clicks of buttons. So now, instead of

491
00:33:26,818 --> 00:33:30,392
focusing on building logic to parse the data across APIs,

492
00:33:30,536 --> 00:33:33,596
developers like Sana can focus on actual innovation.

493
00:33:33,708 --> 00:33:37,340
They can discover and reuse the same single endpoint

494
00:33:37,420 --> 00:33:40,940
to surface the information on the web or in the mobile apps,

495
00:33:41,020 --> 00:33:44,050
saving them hours and hours of work.

496
00:33:45,160 --> 00:33:49,264
So final takeaways we saw the automate unification

497
00:33:49,312 --> 00:33:53,024
of APIs into graphQl and how backend

498
00:33:53,072 --> 00:33:56,324
teams can quickly implement a graphQl solution, how front

499
00:33:56,362 --> 00:34:00,516
end teams can leverage the unified endpoint to access the backend systems,

500
00:34:00,628 --> 00:34:04,264
and we also saw how customers can easily receive the performance they

501
00:34:04,302 --> 00:34:08,296
expect with out of the box functionality. I hope you

502
00:34:08,318 --> 00:34:11,464
enjoyed the session and if you would like to learn more, I have

503
00:34:11,502 --> 00:34:15,036
but some sources here. If you scan the QR codes, they will go

504
00:34:15,058 --> 00:34:18,044
to a URL and you can find the right sources there.

505
00:34:18,242 --> 00:34:21,932
Data graphql is free to try. So you can scan the code

506
00:34:21,986 --> 00:34:25,580
and it will take you to I think a trial account registration.

507
00:34:25,740 --> 00:34:29,436
So you can do that. If you want to get into some details about datagraph,

508
00:34:29,548 --> 00:34:34,016
there is also a tutorial I have linked here that you can use

509
00:34:34,118 --> 00:34:37,556
to maybe build your first project. Just get a little hands on on

510
00:34:37,578 --> 00:34:41,200
how it works and then if you want to learn more about GraphQL

511
00:34:41,280 --> 00:34:45,396
and its documentation, the third QR code will

512
00:34:45,418 --> 00:34:48,804
taken you to the GraphQl documentation. And the last one is

513
00:34:48,842 --> 00:34:52,344
a little bit of product overview, more about endpoint, data graph and

514
00:34:52,382 --> 00:34:55,636
graphql and what it means and why businesses

515
00:34:55,748 --> 00:34:59,210
should know about this and make the best of it.

516
00:34:59,580 --> 00:35:02,920
I mean these days every popular company

517
00:35:02,990 --> 00:35:04,760
that you know of, Pinterest,

518
00:35:06,140 --> 00:35:09,930
Twitter, all of them are using GraphQl in one way or another.

519
00:35:11,580 --> 00:35:14,928
It can find its use in many, many ways. So I

520
00:35:14,934 --> 00:35:18,624
hope you enjoyed the session and I hope you learned something interesting and

521
00:35:18,662 --> 00:35:22,016
something new. Looking forward to interacting with

522
00:35:22,038 --> 00:35:24,608
you. Thank you and have a really great day.

