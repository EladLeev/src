{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/dcb99738-9bf1-4009-af1a-f206ed016ccc", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["akshay bhat", "can", "conf fourty two", "developer advocate", "empowering", "graphql", "hasura", "kubernetes", "lets", "uncovering", "unleashing", "workloads"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "id": "cdb897b7-f139-406e-9345-c11a7e110592", "status": "completed", "error": null, "text": "Good day ladies and gentlemen. I extend my heartfelt gratitude for joining me today. My name is Akshay Bhat. I am genuinely thrilled to be your guide on a fascinating journey where we explore the profound fusion of GraphQl and Kubernetes under the theme empowering Kubernetes workloads with GraphQl while unleashing efficiency and flexibility. So let's embark on this expedition. Before we embark on this journey, let me just give you a brief background of my own past. I'm Akshay Bhat. I wear many hats in the technology world. I'm a developer advocate at Hasura, a regular speaker at tech conferences. I'm a developer by heart and I've been a serial tech entrepreneur and I'm a staunch advocate for open source software. I've had the privilege of being immersed in the world of technology for a number of years and I've witnessed firsthand the remarkable evolution of Kubernetes and graphQl. My journey in the tech industry has been a thrilling adventure, rooted in a deep passion for coding and a strong commitment to fostering community driven innovation. Beyond my work with Hasura and public speaking, I have ventured into the realm of entrepreneurship. I've founded and co founded several tech startups, each with a mission to solve unique challenges using technology. And as an open source champion, I actively contribute to and promote the use of open source technologies, fostering a sense of community and collaboration wherever I can. Please connect with me on either LinkedIn or email to discuss more. Now let's move on to our agenda. So today I'll be talking about, firstly, sort of seeing the outline of graphQl, demystifying graphQl, elucidating its pivotal importance and illustrating its primary facets. Then we'll make the transition into scrutinizing the challenges that typically besiege Kubernetes developers. Crucially, we'll dissect how graphql emerges as the veritable solution to these conundrums. Then we'll spend some time talking about the efficiency of Kubernetes clusters and containers, and then we'll discuss why GraphQL is a great complement with its flexibility. I'll showcase some real world use cases and examples where this combination works best. Finally, we'll explore a bit about Hasura and how it can be an ideal tool when you're running GraphQL and kubernetes. So let's look at the power of GraphQL, right? So at its essence, GraphQL represents a query language for APIs. However, it's unequally. More than that, GraphQL is can emblem of flexibility, efficiency and real time capabilities. This section aims to unveil the bedrock of GraphQL, its core tenants and its critical attributes. So GraphQL is a specification for how to talk to an API. It's typically used over HTTP, where the key idea is to post a query to an HTTP endpoint instead of hitting different HTTP endpoints for different resources. GraphQL is designed for developers of web or mobile applications, essentially HTTP clients, to be able to make API calls to fetch exactly the data they need from their backend APIs. Before going further in understanding GraphQL, it's useful to get a sense of how GraphQL is actually used in an HTTP client. When we talk about GraphQL versus rest APIs, let's say we are fetching a user's profile and their address. In a typical rest scenario, you would essentially be querying or requesting various endpoints for different resources, different endpoints for different resources. So the core of rest API involves around resources. Resources are identified by URLs and request type, it may be get, post, et cetera. However, if your API server was a GraphQL server instead, this is what your API call would look like. As you can see, you're querying for a user and you're querying the iD, the name, the address and the street, or even let's say the name of the hotel or the city. And you get the response in a very similar JSON kind of format as your request is right. And also we are changing the way we think about API calls. So instead of making different APIs calls to different URLs to fetch data, what we're doing is instead of getting a resource, you post a query that describes what data you want. You think of the data your API returns as a graph. This allows you to make ad hoc queries to a single URL endpoint that returns data based on the query. And in the example above you can see that we fetched for a particular user and their id, all that. So the query you send as a data in the post request has a structure and syntax. And in GraphQl we have mutations and subscriptions. I'll tell you how it looks like GraphQl queries look very neat as you can see, and they are easy to read because the shape of the query is very similar to the data that we actually end up getting with. So now let's look at some of the benefits of graphql. Number one, we avoid overfetching, so we avoid overfetching more data than we need because we can specify the exact fields we need, we can prevent multiple API calls in case you need more data. You can also avoid making multiple calls to your API. In the case above, you don't need to make two API calls to fetch user and address separately. Lesser communication with API developers. So sometimes to fetch the exact data you need, especially if you need to fetch more data and want to avoid multiple API calls, you will need to ask your API developers to build a new API. With GraphQL. Your work is independent of the API team. This allows you to work much faster and focus on building your product instead of worrying about all the backend stuff. And every GraphQL API conforms to a schema which is graph data model and what kinds of queries a client can make. This allows the community to build lets of cool tools to explore and visualize your API, or create ide plugins that autocorrect your graphQl queries and even do code Gen. We'll understand this in more detail. So essentially it's a very self documenting kind of system. So here is a small chart showing how GraphQL and rest API would look like. So in rest API you have get for the same you have queries in graphQL for writing data, you have post in rest, you have mutations for writing and updating data in GraphQL and you have subscriptions for watching or subscribing to data which does not have a very clear analogy or parallel in rest APIs. Now let's look at unleashing the efficiency of kubernetes. Now that we have the foundation of GraphQL laid, let's transition to kubernetes. So Kubernetes is an open source container management tool that automates container deployment, container scaling, descaling and container load balancing. Also called as orchestration. Along with automated deployment and scaling of containers, it provides healing by automatically restarting failed containers and rescheduling them when their hosts die. This capability improves the application's availability. Kubernetes follows the client server architecture as you can see in this architecture diagram where we have the master installed on one machine and the node on separate Linux machines. It follows the master slave model which uses a master to manage docker containers across multiple Kubernetes nodes. A master and its control nodes constitute a Kubernetes cluster. A developer can deploy an application in the docker containers with the assistance of the Kubernetes master. Kubernetes, while being a marvelous tool for container orchestration confronts its fair share of challenges in terms of API complexity and data retrieval. These are big challenges and as the scale of the cluster grows, the complexity of data retrieval grows more than linearly. Right. But GraphQL, as I found, was a solution and I've seen multiple use cases where GraphQL was used to address these challenges. So let's understand how GraphQL solves these problems. So first of all, GraphQL solves the data retrieval problem. So it's very flexible. That sets apart graphql from the rest APIs is its finesse in data retrieval. Rest APIs often lead to the pitfalls of overfetching or underfetching data, causing unnecessary data transfer and inefficiency. So however, with GraphQL, we'll see how it empowering people to wield data in a much more effective way. The other thing is efficient resource manipulation. It's not just confined to data retrieval, but also if you want to do manipulation or updation of data mutations are in. GraphQL are our trusted companions in this simplifying the intricate tasks of modifying data within Kubernetes so you can essentially update, create, delete resources all within a single well orchestrated, well constructed query. The other thing is real time insights with GraphQL subscriptions, which is a very core feature of GraphQL. It's a game changer in Kubernetes scenarios. So real time updates can completely revolutionize monitoring and management within Kubernetes. And we'll see how this subscriptions can manifest and how we can use them. Exactly. Now let's come to Hasura and see how in a graphql and Kubernetes environment, it shines. So Hasura is a powerful and versatile technology that serves as a graphQL engine and data platform. It has gained immense popularity in the world of application development for several compelling reasons, and it's an excellent fit for Kubernetes and graphql environments. Some of the reasons are that it's built on GraphQL. Number one, it's a GraphQL score. So it's a modern query language which is modern query language for APIs. With Hasura, you can create a GraphQL API for your data with minimal effort. This aligns perfectly with the principles of Kubernetes, which emphasizes container orchestration and scalability, and graphQl, which optimizes data fetching and manipulation. So it's a very good combination. The other thing is real time capabilities. Hasura excels in providing this for GraphQL subscriptions and this means that you can easily implement features like live updates, notifications and interactive user experiences, and in a Kubernetes environment where you might have a dynamic scaling and a distributed architecture. Hasura's real time functionality seamlessly integrates, ensuring that your applications remain responsive and up to date. Hasura also simplifies data access and authorization. It connects to your data sources such as databases and rest APIs, and generates a graphQL schema automatically. This means you don't have to write complex boilerplate code for data fetching, filtering and pagination. With Kubernetes managing your containers, you can ensure that the data layer is scalable and highly available. In Kubernetes and GraphQL setups. Security is very important, so Hasura also offers robust authentication and authorization mechanisms out of the box. You can easily define fine grained access controls and permissions for your GraphQL schema, ensuring that only authorized users can access specific data and perform certain actions. Also the other thing is it reduces the time and effort required to set up a robust GraphQL API, enabling faster development cycles and easier maintenance. This is particularly valuable in Kubernetes environment where agility and scalability are essential. The other thing is it provides built in monitoring and observability tools that help you keep an eye on your API's performance, GraphQL API's performance and usage and in a Kubernetes cluster with a big size where monitoring and debugging can be complex, these observability features simplify the process and enable you to productively address issues. So in summary, Hasura is a great fit for kubernetes and graphql environments because it simplifies data access and enhances developer productivity and offers real time capabilities. So let's take a small demo and see how things look like. So this is a documentation regarding how you can run Hasura GraphQL engine on Kubernetes. So this is how it looks like. Essentially these are the many different attributes and data that exists and you can query them with GraphQL. And getting the data is very simple. You just connect the database whether it's postgres, in this case it's postgres and you can just track those tables and the data is available. For example here the orders and assignment table is available directly here to query and you can just run the query and fetch the data. So this is some of the documentation for the talk that I used here. There is introduction to GraphQL, there is deployment guide and also do check out the blogs that I've written on this topic. I've written some on Kubernetes and how you can deploy GraphQl APIs very fast for very scalable application. So thank you for joining this talk. As we near the conclusion, let's sort of recap what we talked about. So GraphQL isn't a merely a technological innovation, it's a paradigm shift that can reinvigorate your Kubernetes workloads, elevate user experiences, and kindle innovation. I urge each of you to embrace this opportunity to experiment and discover how GraphQL and Kubernetes can transform your projects. So while we looked at both GraphQL and Kubernetes, we also saw how Hasura, as a powerful graphql engine, plays a pivotal role in empowering Kubernetes workloads. It simplifies the creation and management of GraphQL APIs within Kubernetes, making it accessible and efficient. I implore you to take a closer look and see the benefits of Hasura firsthand. With that, I hope you're eager to take a plunge. Feel free to seek out any clarification you need on these and reach out to me to discuss more on these topics. See you.", "words": [], "utterances": null, "confidence": 0.945207363028954, "audio_duration": 1066.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Akshay Bhat will discuss the profound fusion of GraphQl and Kubernetes. He'll showcase some real world use cases and examples where this combination works best. Bhat is a serial tech entrepreneur and a staunch advocate for open source software.\n- GraphQL is a specification for how to talk to an API. The key idea is to post a query to an HTTP endpoint instead of hitting different HTTP endpoints for different resources. This allows you to make ad hoc queries to a single URL endpoint that returns data based on the query.\n-  GraphQL solves the data retrieval problem. Real time updates can completely revolutionize monitoring and management within Kubernetes. With GraphQL, we'll see how it empowering people to wield data in a much more effective way.\n- Hasura is a powerful and versatile technology that serves as a graphQL engine and data platform. It's an excellent fit for Kubernetes and graphql environments. It simplifies data access and enhances developer productivity and offers real time capabilities.\n-  GraphQL isn't merely a technological innovation, it's a paradigm shift. Hasura plays a pivotal role in empowering Kubernetes workloads. I urge each of you to embrace this opportunity to experiment.", "auto_highlights_result": {"status": "success", "results": [{"count": 3, "rank": 0.08, "text": "GraphQL APIs", "timestamps": [{"start": 887652, "end": 888436}, {"start": 995640, "end": 996888}, {"start": 1044878, "end": 1045604}]}, {"count": 1, "rank": 0.08, "text": "Hasura GraphQL engine", "timestamps": [{"start": 925850, "end": 927700}]}, {"count": 2, "rank": 0.07, "text": "GraphQL subscriptions", "timestamps": [{"start": 712218, "end": 713632}, {"start": 793506, "end": 795096}]}, {"count": 3, "rank": 0.07, "text": "more data", "timestamps": [{"start": 416390, "end": 417042}, {"start": 426584, "end": 427110}, {"start": 445462, "end": 445962}]}, {"count": 5, "rank": 0.07, "text": "data retrieval", "timestamps": [{"start": 610148, "end": 611370}, {"start": 616488, "end": 617518}, {"start": 648500, "end": 649436}, {"start": 656934, "end": 657888}, {"start": 681474, "end": 682168}]}, {"count": 1, "rank": 0.07, "text": "GraphQL setups", "timestamps": [{"start": 843598, "end": 844356}]}, {"count": 1, "rank": 0.07, "text": "Kubernetes developers", "timestamps": [{"start": 162538, "end": 164130}]}, {"count": 1, "rank": 0.07, "text": "data mutations", "timestamps": [{"start": 687202, "end": 688552}]}, {"count": 1, "rank": 0.07, "text": "specific data", "timestamps": [{"start": 860246, "end": 861200}]}, {"count": 1, "rank": 0.07, "text": "modifying data", "timestamps": [{"start": 694182, "end": 694912}]}, {"count": 3, "rank": 0.07, "text": "Kubernetes environment", "timestamps": [{"start": 745538, "end": 746664}, {"start": 803058, "end": 804004}, {"start": 875578, "end": 876464}]}, {"count": 1, "rank": 0.06, "text": "multiple Kubernetes nodes", "timestamps": [{"start": 587644, "end": 589462}]}, {"count": 1, "rank": 0.06, "text": "Kubernetes clusters", "timestamps": [{"start": 175208, "end": 176538}]}, {"count": 1, "rank": 0.06, "text": "unnecessary data transfer", "timestamps": [{"start": 663248, "end": 664452}]}, {"count": 1, "rank": 0.06, "text": "Kubernetes scenarios", "timestamps": [{"start": 718558, "end": 720004}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}