1
00:00:19,930 --> 00:00:23,882
Hello, everybody, and welcome. I hope you're all enjoying the conference,

2
00:00:23,946 --> 00:00:27,126
and welcome to my talk. Today I'm going to be

3
00:00:27,148 --> 00:00:30,662
focusing on memory management in go, and I've namely called it the good,

4
00:00:30,716 --> 00:00:33,846
the bad, and the ugly. And that's because we're going to be covering a whole

5
00:00:33,868 --> 00:00:37,906
bunch of topics around memory management. So a quick agenda.

6
00:00:38,018 --> 00:00:40,658
What is this session going to be about? I'm going to tell you a little

7
00:00:40,684 --> 00:00:43,530
bit about me, who I am, what I do, and where I came from.

8
00:00:43,680 --> 00:00:46,220
The introduction to memory management itself,

9
00:00:46,590 --> 00:00:50,266
how go's memory model works, and how you manage memory in

10
00:00:50,288 --> 00:00:54,222
go. Going to look at a few code examples, some good and some bad,

11
00:00:54,276 --> 00:00:57,054
and help explain them. And then we're going to look at some memory management in

12
00:00:57,092 --> 00:00:59,722
some other languages, namely Java,

13
00:00:59,786 --> 00:01:03,326
Python, and some rust. Also going to look

14
00:01:03,348 --> 00:01:06,626
at some top tips, and I might even throw in a live demo at the

15
00:01:06,648 --> 00:01:10,318
end as well. So who am I? Well, my name's

16
00:01:10,334 --> 00:01:13,214
Liam Hampton and I'm a Microsoft senior cloud advocate.

17
00:01:13,342 --> 00:01:16,674
I'm an all ser ambassador because security is something I always think

18
00:01:16,712 --> 00:01:20,294
about, and I feel whenever I speak to developers, it's not always top of their

19
00:01:20,332 --> 00:01:23,718
list. I'm a dev network advisory board member and I like

20
00:01:23,724 --> 00:01:27,222
to write a lot of go code. That's my background. I also like to travel

21
00:01:27,276 --> 00:01:30,790
the world, as you can see, with a few pictures here on the slide.

22
00:01:31,450 --> 00:01:34,790
So with everything I do, I like to have some learning goals.

23
00:01:34,950 --> 00:01:38,298
If there's anything that I would like you to take away from my talk today,

24
00:01:38,384 --> 00:01:41,902
it is to understand the gomemory model and understand how to manage

25
00:01:41,956 --> 00:01:45,226
memory in go. Let's talk a little bit about memory

26
00:01:45,258 --> 00:01:47,822
management holistically. What is it?

27
00:01:47,956 --> 00:01:51,694
Well, memory management is a way of keeping track of

28
00:01:51,732 --> 00:01:55,794
memory locations in your program and on your system, regardless of

29
00:01:55,832 --> 00:01:59,266
whether they are allocated or referenced, shall we

30
00:01:59,288 --> 00:02:02,546
say, or unreferenced. Memory management is

31
00:02:02,568 --> 00:02:05,922
a holistic view of what's going on and how your program can

32
00:02:05,976 --> 00:02:09,542
run perfectly without falling over, without failing, and without

33
00:02:09,596 --> 00:02:12,502
running out of memory on your system. Well,

34
00:02:12,556 --> 00:02:16,166
why is that important? We ask for a number of reasons, but namely to

35
00:02:16,188 --> 00:02:20,546
prevent memory leaks, stop security vulnerabilities appearing,

36
00:02:20,738 --> 00:02:24,730
and to stop the slowdown of your system and programs from running.

37
00:02:24,880 --> 00:02:28,746
You need to understand how to work efficiently on your system, and you

38
00:02:28,768 --> 00:02:32,414
want to be the most cost effective you can be. Therefore, understanding how

39
00:02:32,452 --> 00:02:35,646
to manage memory is really important, not just with

40
00:02:35,668 --> 00:02:39,246
it programmatically, but typically how you understand the way

41
00:02:39,268 --> 00:02:42,634
the system works. So let's take a step

42
00:02:42,692 --> 00:02:46,654
back and look at the generics of memory management,

43
00:02:46,782 --> 00:02:51,170
everything that we know and love already. Stacks and heaps,

44
00:02:51,830 --> 00:02:55,582
what are they? Well, a stack stores local variables

45
00:02:55,646 --> 00:02:58,706
and function call frames. So whenever you kick off a new function,

46
00:02:58,808 --> 00:03:02,722
whenever you call it, it creates a callframe and that is popped on a stack

47
00:03:02,786 --> 00:03:05,906
or pushed to a stack, should I say. Now that namely

48
00:03:05,938 --> 00:03:08,886
brings me to the second point of it being last in first.

49
00:03:08,988 --> 00:03:12,486
But. So let's look at this as if you're stacking

50
00:03:12,518 --> 00:03:15,866
some books on the diagram. We have got one and

51
00:03:15,888 --> 00:03:19,034
you're pushing number two, pushing number three, four, five and six.

52
00:03:19,072 --> 00:03:23,066
And it creates a lovely stack, quite aptly named, if I say so myself.

53
00:03:23,248 --> 00:03:26,250
And then let's say you want to get the first book from the stack.

54
00:03:26,330 --> 00:03:29,694
You need to take each one from the top off at one

55
00:03:29,732 --> 00:03:34,020
at a time. So it would go 65432 and one.

56
00:03:34,870 --> 00:03:38,626
That's pretty typical for a stack because it's supposed to be quick,

57
00:03:38,728 --> 00:03:41,620
it's supposed to be agile and it's supposed to be fast.

58
00:03:42,150 --> 00:03:44,914
That's pretty typical. However,

59
00:03:45,112 --> 00:03:48,946
if we're going to be looking at the sizes of it, they're typically fixed sizes.

60
00:03:49,058 --> 00:03:52,610
If we look at a standard typical Linux distribution,

61
00:03:52,770 --> 00:03:55,430
the default size is about eight megabytes.

62
00:03:56,090 --> 00:03:59,686
That's how big a stack frame is supposed to be. However, if we

63
00:03:59,708 --> 00:04:02,730
look at how go manages that, and we'll talk a little bit about this later

64
00:04:02,800 --> 00:04:06,790
on, but we use something called go routines,

65
00:04:06,950 --> 00:04:10,106
as you may or may not be aware of. So these are

66
00:04:10,128 --> 00:04:13,546
another layer of abstraction away from the odd operating system, which typically deals

67
00:04:13,578 --> 00:04:17,150
with threads. But this is something inside the language already.

68
00:04:17,300 --> 00:04:21,354
Now this actually helps us with memory location or stack

69
00:04:21,402 --> 00:04:24,994
allocation at this point. And it starts at about 2

70
00:04:25,032 --> 00:04:28,482
memory, quite small. So that's really good, really fast and really

71
00:04:28,536 --> 00:04:31,970
efficient. Now let's look at a heap.

72
00:04:32,470 --> 00:04:35,698
What does a heap look like? Well, imagine it's like a cloud as we can

73
00:04:35,704 --> 00:04:39,670
see here on the diagram. And next to it we have got two stacks.

74
00:04:40,010 --> 00:04:43,462
These store dynamically allocated memory. It is

75
00:04:43,516 --> 00:04:47,650
not for quick allocation, and it's definitely not for grabbing quick bits of memory

76
00:04:47,730 --> 00:04:51,638
or quick bits of data out of memory. It is there for longevity.

77
00:04:51,814 --> 00:04:55,974
These grow and shrink during the execution of a program, which makes it dynamic,

78
00:04:56,102 --> 00:04:59,930
but that also makes it really slow and really less efficient.

79
00:05:00,350 --> 00:05:03,806
So anything that cannot be stored in a stack is typically put onto the,

80
00:05:03,828 --> 00:05:06,958
or into the heap, which is good, but that can become a

81
00:05:06,964 --> 00:05:10,558
problem later down the line. So as we said,

82
00:05:10,644 --> 00:05:14,026
stacks are for short lived data and heaps are for

83
00:05:14,068 --> 00:05:17,314
long lived data. So longevity, how does

84
00:05:17,352 --> 00:05:20,994
Go manage all of this? So I've kind of already alluded to it already,

85
00:05:21,112 --> 00:05:23,940
but what does Go's memory model look like?

86
00:05:24,310 --> 00:05:28,006
Well, it has a garbage collector. It is pretty famous for its

87
00:05:28,028 --> 00:05:31,922
garbage collector. It's one of the key features of the language,

88
00:05:32,066 --> 00:05:35,734
and it is where it automatically goes around after you,

89
00:05:35,772 --> 00:05:39,862
after your program to reclaim memory, which was allocated.

90
00:05:40,006 --> 00:05:43,626
So it does it automatically for you, gives you a hands up

91
00:05:43,648 --> 00:05:47,050
approach to memory management, unlike some other languages,

92
00:05:47,870 --> 00:05:51,242
like I said, not manual, it reduces security

93
00:05:51,376 --> 00:05:54,846
and leak risk. Now, this is really important. One of the

94
00:05:54,868 --> 00:05:58,398
key problems that we have with memory management as it stands is security

95
00:05:58,484 --> 00:06:02,154
vulnerabilities. Understanding how to close connections,

96
00:06:02,202 --> 00:06:04,260
how to close sockets, is important.

97
00:06:04,790 --> 00:06:08,846
Understanding what happens to your memory when you're allocating global

98
00:06:08,958 --> 00:06:12,050
versus locally scoped variables is also really important.

99
00:06:12,200 --> 00:06:15,314
This helps to prevent the leaks and security risks that you may

100
00:06:15,352 --> 00:06:19,266
see. The garbage collector, like I said, runs around after you and helps

101
00:06:19,298 --> 00:06:22,070
to free up the dereference memory for you.

102
00:06:22,220 --> 00:06:25,640
Pretty cool, and it's really, really important.

103
00:06:26,010 --> 00:06:28,706
Next we have Go outlines and channels.

104
00:06:28,818 --> 00:06:31,962
Well, what is a Go routine? I've kind of already spoke about a little bit,

105
00:06:32,016 --> 00:06:35,254
but it is a lightweight execution thread. It's a layer

106
00:06:35,302 --> 00:06:39,290
abstracted away from the operating system, which typically deals with your threads,

107
00:06:39,970 --> 00:06:43,438
but it's a function that executes concurrently with the rest of the program.

108
00:06:43,524 --> 00:06:47,534
It helps to create parallelism, and it

109
00:06:47,572 --> 00:06:52,382
helps have asynchronous running

110
00:06:52,436 --> 00:06:55,762
of your code, and that in turn is very

111
00:06:55,816 --> 00:06:59,886
cheap. It helps you have a lightweight program that runs

112
00:06:59,918 --> 00:07:03,586
asynchronously. It's brilliant. And that means less overheads, which is

113
00:07:03,608 --> 00:07:07,890
even better. So when you actually go to

114
00:07:07,960 --> 00:07:10,966
write a go routine, or when you want to dictate or sort of have it

115
00:07:10,988 --> 00:07:14,662
in your language or in your program, you would just put the word

116
00:07:14,716 --> 00:07:18,182
go and then the function signature. And I'll show you an example

117
00:07:18,236 --> 00:07:21,882
of this afterwards. What's a channel? Well, a channel

118
00:07:21,936 --> 00:07:25,354
is the transportation between the two go

119
00:07:25,392 --> 00:07:29,514
routines that you, or more go routines that you may have. It's a communication means,

120
00:07:29,632 --> 00:07:32,826
it actually allows you to take data or send data to a channel

121
00:07:32,928 --> 00:07:36,366
from a go routine and then pull it off again so it talks to one

122
00:07:36,388 --> 00:07:39,546
another. Because what's the point in having a go routine that's processing

123
00:07:39,578 --> 00:07:43,006
some data and another go routine processing some more data and them

124
00:07:43,028 --> 00:07:46,306
not being able to communicate? Well, this is exactly what a channel is

125
00:07:46,328 --> 00:07:50,162
for, and it helps to prevent race conditions, locks and other synchronization problems

126
00:07:50,216 --> 00:07:53,198
that you may face. And again with the syntax,

127
00:07:53,294 --> 00:07:56,562
you dictate it with the chan keyword, which, I mean, I think go

128
00:07:56,616 --> 00:08:00,018
has about 25 keywords. It's a really awesome language like that.

129
00:08:00,184 --> 00:08:03,190
But when you want to write to it, let's say we have c.

130
00:08:03,260 --> 00:08:06,486
C is the channel and we want to take x and we want to put

131
00:08:06,508 --> 00:08:10,214
the value of x onto the channel. Well, you'd use that with a notation of

132
00:08:10,252 --> 00:08:13,466
an arrow. And likewise when you want to read from the channel, you would take

133
00:08:13,488 --> 00:08:16,540
that arrow and put it the other side to take it off. Again,

134
00:08:17,070 --> 00:08:21,046
quite simple. So in essence, what does memory

135
00:08:21,078 --> 00:08:24,698
model look like and what does it do? Well, it ensures the program doesn't

136
00:08:24,714 --> 00:08:28,026
run but of memory by using the garbage collector. And it really helps

137
00:08:28,058 --> 00:08:31,562
you a lot. It allows go routines to communicate safely

138
00:08:31,626 --> 00:08:36,240
and keep good state. Therefore it is perfect to run your parallel code.

139
00:08:36,770 --> 00:08:40,018
Brilliant. Now that's a whistle stop tool. There's obviously a lot more to it,

140
00:08:40,104 --> 00:08:42,500
but we're going to keep it at that high level just for now.

141
00:08:43,590 --> 00:08:47,006
How do you manage that memory? So, once you have looked at the garbage

142
00:08:47,038 --> 00:08:50,406
collector, we have looked at go outlines and channels. How do you manage

143
00:08:50,508 --> 00:08:53,862
memory in go? Well, there's two ways

144
00:08:53,916 --> 00:08:57,462
that we can help you do that. There's one called the new function.

145
00:08:57,596 --> 00:09:01,578
Now this is allocating memory of a variable for a given type,

146
00:09:01,744 --> 00:09:04,854
and it is typically zero valued at this point. So let's

147
00:09:04,902 --> 00:09:09,002
take an example. We've got pointer at the bottom and

148
00:09:09,056 --> 00:09:12,570
we are going to be calling the function new and we're going to give it

149
00:09:12,720 --> 00:09:16,078
the type of an integer. Therefore, if we want to get the

150
00:09:16,084 --> 00:09:19,102
value of pointer, well then it's just going to be zero,

151
00:09:19,236 --> 00:09:22,846
zero value from beginning. And the second way is to use

152
00:09:22,868 --> 00:09:27,134
the make function. Now this is allocating memory for data structures.

153
00:09:27,262 --> 00:09:30,622
So if you want arrays or slices, maps,

154
00:09:30,686 --> 00:09:34,514
channels, and you then want to use them straight away with a

155
00:09:34,552 --> 00:09:37,762
default value, this is when you'd use the make function.

156
00:09:37,896 --> 00:09:41,362
Again, let's look at an example. We want to make slice.

157
00:09:41,506 --> 00:09:45,158
So we say we want to declare slice and we want to

158
00:09:45,164 --> 00:09:48,982
give it a default value of an integer slice with the values three

159
00:09:49,036 --> 00:09:52,506
and five. Now this is how you would do that. And this

160
00:09:52,528 --> 00:09:55,946
is where you'd use make. So you'd use new when you want

161
00:09:55,968 --> 00:09:59,334
to initialize a variable and then use it later on your program, which is totally

162
00:09:59,382 --> 00:10:03,226
fine. And then you can use make when you want to create a data structure

163
00:10:03,258 --> 00:10:06,720
and use it straight away also fine.

164
00:10:07,570 --> 00:10:10,880
Two really good ways to help with memory management in go.

165
00:10:11,250 --> 00:10:14,766
So what about memory leaks? I've said it a few times and

166
00:10:14,788 --> 00:10:17,842
I'm going to say it again, memory leaks are bad now

167
00:10:17,896 --> 00:10:21,362
how can we avoid them? What is it? Well,

168
00:10:21,416 --> 00:10:25,454
a memory leak is typically when you have a memory allocation

169
00:10:25,582 --> 00:10:29,026
that is referenced but it's no longer needed and it's not freed

170
00:10:29,058 --> 00:10:32,742
up. So this can eventually cause your program to crash or

171
00:10:32,796 --> 00:10:36,774
slow down your system significantly. This is

172
00:10:36,892 --> 00:10:40,006
really bad and we don't want to come into any of these and there's ways

173
00:10:40,028 --> 00:10:43,322
to avoid them. But let's look at some typical scenarios of when you'd come across

174
00:10:43,376 --> 00:10:47,274
this. So if you're not terminating a go routine completely

175
00:10:47,392 --> 00:10:50,586
or properly, rather this can continue to hold on

176
00:10:50,608 --> 00:10:53,674
to allocated memory and it just holds it. It doesn't do anything

177
00:10:53,712 --> 00:10:57,630
with it, it's just there. But that memory block is now stuck.

178
00:10:57,970 --> 00:11:00,906
You're not freeing it up. Now imagine if you had a number of go routines

179
00:11:00,938 --> 00:11:04,718
doing the same thing. Well then you'd have a memory, you'd have

180
00:11:04,724 --> 00:11:08,514
a memory allocation of this much and it would eventually fill up bit by,

181
00:11:08,552 --> 00:11:11,618
but causing a problem late down the line.

182
00:11:11,704 --> 00:11:15,666
So if somebody else or another outlines wanted to use a piece

183
00:11:15,688 --> 00:11:18,854
of memory, well then it can't because it's already taken up.

184
00:11:18,972 --> 00:11:21,560
What do you do? Well, it's just going to fall over.

185
00:11:22,090 --> 00:11:25,234
Secondly, another really common mistake

186
00:11:25,282 --> 00:11:28,614
that I see is assigning global variables and never using them again.

187
00:11:28,652 --> 00:11:31,866
And I'm going to show you an example in a moment. But you never want

188
00:11:31,888 --> 00:11:35,066
to assign a global variable and do nothing with it.

189
00:11:35,168 --> 00:11:38,682
You always want to clean up after yourself and it doesn't always

190
00:11:38,736 --> 00:11:42,762
happen again. A scenario of a memory leak and

191
00:11:42,816 --> 00:11:46,762
of course the famous infinite loop. You're going to be taking memory

192
00:11:46,826 --> 00:11:50,014
upon memory upon memory and you're not going to be doing anything with it.

193
00:11:50,052 --> 00:11:53,434
It's just going to be dormant. That is a classic

194
00:11:53,482 --> 00:11:57,106
example of causing memory leaks. What tools can we

195
00:11:57,128 --> 00:12:00,274
use then? Well, there's a few that we can use and the go

196
00:12:00,312 --> 00:12:02,690
toolchain has a really powerful one,

197
00:12:02,840 --> 00:12:06,466
pprof. And this is basically a built in package that can be

198
00:12:06,488 --> 00:12:10,082
used to analyze and understand the go language

199
00:12:10,146 --> 00:12:13,350
and your functions. And I'm going to show you an example,

200
00:12:13,420 --> 00:12:16,614
hopefully at the end. How can you personally help

201
00:12:16,652 --> 00:12:20,234
as a developer? Well, there's a few things now. Number one, it's pretty

202
00:12:20,272 --> 00:12:23,994
obvious. Be vigilant, don't use global variables if you're not

203
00:12:24,032 --> 00:12:27,702
going to allocate them and deallocate them efficiently and properly.

204
00:12:27,846 --> 00:12:30,922
You want to understand the code that you're writing and you need to understand

205
00:12:30,976 --> 00:12:34,458
it properly. And secondly, the defer keyword.

206
00:12:34,634 --> 00:12:38,202
Now this will help to reduce leaks with files, sockets, database connections,

207
00:12:38,266 --> 00:12:41,200
anything that you do not want to leave open.

208
00:12:41,570 --> 00:12:44,718
If you are opening, I don't know, say a file, and I'm going to show

209
00:12:44,724 --> 00:12:47,138
you this in a moment, you're going to want to close that file regardless of

210
00:12:47,144 --> 00:12:51,060
whether the function is going to pass or not or whether it's going to complete.

211
00:12:51,750 --> 00:12:55,060
So let's have a little look at some code.

212
00:12:56,550 --> 00:13:00,726
Here's a good example of the default keyword in

213
00:13:00,748 --> 00:13:03,910
this bit of code. We're opening file txt.

214
00:13:04,410 --> 00:13:07,670
We're then going to check for an error, which is pretty typical,

215
00:13:08,350 --> 00:13:12,394
and then we're going to defer the closure. Now this

216
00:13:12,432 --> 00:13:16,230
is the really important part. This file

217
00:13:16,310 --> 00:13:19,494
close will execute after the surrounding

218
00:13:19,542 --> 00:13:23,562
function, which means that even if it fails, even if that function fails

219
00:13:23,626 --> 00:13:26,590
or doesn't complete processing properly,

220
00:13:26,930 --> 00:13:30,766
the file is still closed. Really important because

221
00:13:30,788 --> 00:13:34,182
we don't want to leave that open. That's when we use deferred

222
00:13:34,186 --> 00:13:37,998
keyword, network connections, database sockets files,

223
00:13:38,094 --> 00:13:41,934
things that you don't want to leave open that can also create security vulnerabilities

224
00:13:41,982 --> 00:13:44,580
at that point. Again, not something we want to do.

225
00:13:45,370 --> 00:13:49,062
The next one, garbage collector. What are we doing here?

226
00:13:49,196 --> 00:13:52,294
Well, we're creating a struct called mystruct of type

227
00:13:52,332 --> 00:13:55,686
struct. And inside there we

228
00:13:55,708 --> 00:13:59,430
have got data, and that is of type byte.

229
00:13:59,510 --> 00:14:03,814
So it's a byte slice in the main function. We are declaring

230
00:14:03,862 --> 00:14:07,162
it as a variable. We are then going to allocate it

231
00:14:07,216 --> 00:14:11,034
with about 100 megabytes. Really, really good

232
00:14:11,072 --> 00:14:14,586
example of the garbage collector because once this is completed,

233
00:14:14,698 --> 00:14:18,270
once this function ends, it's then going to clear up after itself.

234
00:14:18,340 --> 00:14:22,206
The garbage collector can reclaim that memory that my struct has

235
00:14:22,228 --> 00:14:26,370
been allocated at this point here. So once it's completed,

236
00:14:26,870 --> 00:14:31,326
done, and it will clear it off. Perfect. Now let's

237
00:14:31,358 --> 00:14:35,206
look at some bad examples. In here. We are declaring a

238
00:14:35,228 --> 00:14:38,818
global variable of data and it's of byte,

239
00:14:38,834 --> 00:14:42,550
it's of type byte inside the main function.

240
00:14:42,620 --> 00:14:45,026
We are giving it again 100 megabytes.

241
00:14:45,138 --> 00:14:48,786
However, once it's completed, and once it's finished,

242
00:14:48,978 --> 00:14:52,522
we have still got a problem because that global variable is

243
00:14:52,576 --> 00:14:56,042
still there. So how do you fix it? Well, you move that

244
00:14:56,096 --> 00:14:59,258
data allocation into the function,

245
00:14:59,344 --> 00:15:02,858
you give it a local scope. At this point,

246
00:15:02,944 --> 00:15:05,418
we don't want it to be global. We don't want it to exist outside of

247
00:15:05,424 --> 00:15:09,246
this function because it's never going to get cleared up. The garbage collector is just

248
00:15:09,268 --> 00:15:11,774
going to look at it and think, you know what, it's still there, it's still

249
00:15:11,812 --> 00:15:14,750
referenced, it's still being used, but it's completely dormant.

250
00:15:15,250 --> 00:15:19,266
So you make it locally scoped so that when it does complete that function,

251
00:15:19,448 --> 00:15:22,962
it is then cleared up. All of that data is freed up for the next

252
00:15:23,016 --> 00:15:26,440
one. Let's look at another bad example.

253
00:15:26,970 --> 00:15:31,206
Recursive functions, everyone's favorite. Right in

254
00:15:31,228 --> 00:15:34,706
here we are calling recursion and we're

255
00:15:34,738 --> 00:15:38,166
giving it a big number that is then going to

256
00:15:38,188 --> 00:15:41,142
call the recursion function a number of times.

257
00:15:41,276 --> 00:15:44,874
Inside here we have an if statement. If n is not equal zero,

258
00:15:44,992 --> 00:15:48,106
then return and do the same thing again and the same thing again and

259
00:15:48,128 --> 00:15:52,062
the same thing again. That is really bad because you are continuously taking

260
00:15:52,116 --> 00:15:55,406
up memory and you're continuously iterating over this loop and you

261
00:15:55,428 --> 00:15:59,098
don't want to be there. So it's

262
00:15:59,114 --> 00:16:02,670
eventually going to run out of memory at some point. Okay.

263
00:16:02,820 --> 00:16:06,014
Or it might not run out of memory. It might slow down significantly

264
00:16:06,062 --> 00:16:09,874
during its execution. Admittedly, you're going to need a much bigger number

265
00:16:09,912 --> 00:16:13,474
than this to really bring something down on like modern day

266
00:16:13,512 --> 00:16:17,138
systems, but this is still very valid use case.

267
00:16:17,304 --> 00:16:21,302
How do you fix it? Well, we reduce the recursive call

268
00:16:21,356 --> 00:16:25,138
number. That's a pretty obvious one. Okay. There is no golden nugget

269
00:16:25,154 --> 00:16:28,674
for this one. However, reducing the call number or using a controlled

270
00:16:28,722 --> 00:16:32,038
iterative solution such as a range or

271
00:16:32,124 --> 00:16:36,438
a duo loop, something that we can control specifically

272
00:16:36,614 --> 00:16:40,502
as a developer. Okay. You don't want to just leave it to its own devices

273
00:16:40,566 --> 00:16:42,960
and continue doing it time after time after time.

274
00:16:44,050 --> 00:16:47,134
So now let's look at some go routines, let's look at some code and how

275
00:16:47,172 --> 00:16:51,342
it really works. So what

276
00:16:51,396 --> 00:16:55,166
do we have? Let's go over to the browser,

277
00:16:55,198 --> 00:16:58,100
into the go playground and let's have a look, shall we?

278
00:17:00,070 --> 00:17:03,634
All righty. So over here we have

279
00:17:03,672 --> 00:17:06,500
got a go routines function.

280
00:17:07,350 --> 00:17:11,110
We have got go task number one and go task number

281
00:17:11,180 --> 00:17:13,974
two. And then we're going to wait for a little bit. We're going to wait

282
00:17:14,012 --> 00:17:17,270
for those tasks to finish in here. All we're doing

283
00:17:17,340 --> 00:17:20,550
is printing

284
00:17:20,890 --> 00:17:23,800
task number one and task number two.

285
00:17:24,570 --> 00:17:27,562
That's all we're doing. Nothing too complicated. However,

286
00:17:27,696 --> 00:17:31,322
when we're running task number one and task number two in go routines, there is

287
00:17:31,376 --> 00:17:35,334
absolutely no guarantee that task one will finish before

288
00:17:35,392 --> 00:17:38,318
task two. And we're going to see if we can get it to do it

289
00:17:38,324 --> 00:17:41,774
today. So let's run this function a couple of times

290
00:17:41,812 --> 00:17:45,438
and see what we get. No guarantee it'll even work this time,

291
00:17:45,524 --> 00:17:47,620
but we're going to see if we can try and find out.

292
00:17:48,950 --> 00:17:52,610
So we have one and two, we've got two and one. Straight away,

293
00:17:52,760 --> 00:17:56,162
two has finished before number one. Perfect example

294
00:17:56,216 --> 00:17:58,870
of a go routine and parallel execution.

295
00:18:00,570 --> 00:18:04,358
Let's have a look at channels. I briefly spoke about them.

296
00:18:04,444 --> 00:18:08,066
Let's have a look at them in action. So first of all we are creating

297
00:18:08,098 --> 00:18:11,318
a new channel and we're doing that. We're calling it c and we're

298
00:18:11,334 --> 00:18:14,966
saying make chan of type Int. So integers.

299
00:18:14,998 --> 00:18:18,586
We just want to be working with numbers here. Then we're going to send a

300
00:18:18,608 --> 00:18:21,958
value to that channel. We're going to say go. So we're

301
00:18:21,974 --> 00:18:25,086
going to dictate another go routine and we're going to say in there we got

302
00:18:25,108 --> 00:18:28,766
a channel and we're going to pass 42 onto the

303
00:18:28,788 --> 00:18:31,854
channel. Then what we're going to do is we want to read

304
00:18:31,892 --> 00:18:35,118
from that channel. So we want to take the data off of it

305
00:18:35,284 --> 00:18:38,660
at this point. We want to pull the data out of that channel.

306
00:18:39,270 --> 00:18:43,106
So once this executes we would expect to see 42.

307
00:18:43,208 --> 00:18:44,900
So let's go ahead and run it.

308
00:18:46,790 --> 00:18:50,662
And of course we do. Now the next one

309
00:18:50,716 --> 00:18:53,858
is where we're taking it down just a little bit deeper. And we're

310
00:18:53,874 --> 00:18:57,454
going to look at pointers and referencing with memory addresses.

311
00:18:57,602 --> 00:19:01,514
We are saying Liam's number is equal to 27

312
00:19:01,632 --> 00:19:05,626
as an integer. We are then saying the

313
00:19:05,648 --> 00:19:09,014
variable of pointer is equal to the memory

314
00:19:09,062 --> 00:19:11,660
location of Liam's number.

315
00:19:12,350 --> 00:19:15,258
And then we want to print them out. We want to print out the pointer

316
00:19:15,354 --> 00:19:18,686
which is going to be the memory reference or the memory location. And then we

317
00:19:18,708 --> 00:19:22,286
want to print out the pointer of that. So then we actually

318
00:19:22,308 --> 00:19:26,018
want to print out the value. Then we're

319
00:19:26,024 --> 00:19:29,326
going to look at a little bit of arithmetic. We're going to do the reference

320
00:19:29,358 --> 00:19:33,006
of pointer is equal to pointer or the reference of pointer

321
00:19:33,038 --> 00:19:37,102
plus two. And we would expect to get a numerical

322
00:19:37,166 --> 00:19:40,440
value. So let's print that out and see what we get.

323
00:19:41,610 --> 00:19:45,078
So we go ahead and run it. And down here we can straightaway say

324
00:19:45,164 --> 00:19:48,140
that the value of pointer. So this line here,

325
00:19:48,590 --> 00:19:51,770
line number 16 is the memory address location.

326
00:19:52,750 --> 00:19:55,990
And then we have another one. Line number 17

327
00:19:56,070 --> 00:19:59,734
is 27. The actual data at that memory

328
00:19:59,782 --> 00:20:03,422
location. And then we're just going to do a bit of arithmetic. So we're basically

329
00:20:03,476 --> 00:20:07,342
saying substituting the values in 27 is equal to

330
00:20:07,396 --> 00:20:11,440
27 plus two, which equals 29.

331
00:20:12,130 --> 00:20:15,614
That is how we're going to be working with memory locations and pointers

332
00:20:15,662 --> 00:20:19,810
and references. And you do that with ampersands and little stars.

333
00:20:20,710 --> 00:20:23,810
So that's a really good way to look at how you can dictate and manage

334
00:20:23,880 --> 00:20:27,558
memory in your program. Okay, you don't want to be overwriting the

335
00:20:27,564 --> 00:20:30,726
wrong values. You also want to keep a true value at some point, and this

336
00:20:30,748 --> 00:20:39,998
is how you work with them. So let's go back to the slideshow.

337
00:20:40,114 --> 00:20:43,514
Okay, so what are we doing next? Let's have a look

338
00:20:43,552 --> 00:20:46,518
at some memory management in some other languages.

339
00:20:46,694 --> 00:20:49,210
Let's go and have a look at Rust.

340
00:20:50,290 --> 00:20:54,480
How does rust manage memory? Well, it's a little bit different to go,

341
00:20:54,930 --> 00:20:58,862
rust uses ownership and borrowing, a completely

342
00:20:58,916 --> 00:21:02,190
different approach to how go works with hits memory.

343
00:21:02,630 --> 00:21:05,666
So ownership is where a piece of data basically has a

344
00:21:05,688 --> 00:21:09,982
single owner that is responsible for managing its lifespan.

345
00:21:10,126 --> 00:21:14,500
So it's deallocated by the rust compiler automatically. Completely different.

346
00:21:15,030 --> 00:21:18,246
And borrowing is the idea that a piece of

347
00:21:18,268 --> 00:21:21,494
data can temporarily be borrowed by another piece of

348
00:21:21,532 --> 00:21:24,774
code, but it must be done in a way that guarantees its

349
00:21:24,812 --> 00:21:29,494
safety and integrity. So again, it's got a real tight security

350
00:21:29,692 --> 00:21:33,580
on its data of how it's passed around and where it's passed around.

351
00:21:34,110 --> 00:21:37,706
But it's a really different concept of what we're used to

352
00:21:37,728 --> 00:21:41,846
in go. So let's have a look at an example on

353
00:21:41,888 --> 00:21:45,262
the slide. I've got a main function, and we have got a

354
00:21:45,316 --> 00:21:48,874
string. So let's say we're giving s the value of string,

355
00:21:49,002 --> 00:21:50,720
and it's going to be hello.

356
00:21:52,130 --> 00:21:55,954
Then we're saying we want to calculate the length, but we're going to pass

357
00:21:56,072 --> 00:21:59,634
string into that function, but we're only going to give it a

358
00:21:59,672 --> 00:22:03,106
reference of string. Now we're borrowing the

359
00:22:03,128 --> 00:22:07,006
initial value of s with the ampersand. We're passing

360
00:22:07,038 --> 00:22:09,830
in a reference to calculate length.

361
00:22:10,250 --> 00:22:14,114
From there, we're going to take it in. We're still using it. It's still locally

362
00:22:14,162 --> 00:22:18,150
scoped, and it's still only a reference. We're just borrowing that

363
00:22:18,220 --> 00:22:21,798
version of s, and then we want to give it an output

364
00:22:21,894 --> 00:22:26,310
so it passes it back into the main function, which is still accessible

365
00:22:26,470 --> 00:22:29,626
because it's owned by the main function, and then we're going to print out the

366
00:22:29,648 --> 00:22:32,640
value. So it says hello is five,

367
00:22:33,010 --> 00:22:36,734
so five characters. That is how rust is

368
00:22:36,772 --> 00:22:39,962
working with its memory allocation. It passes

369
00:22:40,026 --> 00:22:43,646
by borrowing and ownership. Completely different to

370
00:22:43,748 --> 00:22:47,554
go. Then we're going to have a little look at Python. Now,

371
00:22:47,592 --> 00:22:50,978
Python's somewhat similar. It uses a garbage collector, and it

372
00:22:50,984 --> 00:22:53,838
uses a technique called reference counting.

373
00:22:54,014 --> 00:22:57,298
So a reference is a way for a program to access

374
00:22:57,464 --> 00:23:01,494
an object in memory. Okay? So when a variable is assigned to an object,

375
00:23:01,612 --> 00:23:04,726
a reference of that object is created. This is

376
00:23:04,748 --> 00:23:08,342
how Python works. It also has a cyclic garbage collector,

377
00:23:08,486 --> 00:23:12,406
which basically periodically checks upon unreachable

378
00:23:12,438 --> 00:23:16,454
objects or unreachable unreferenced objects in memory,

379
00:23:16,582 --> 00:23:19,818
and then that's how it then frees it up. So if it can't call it,

380
00:23:19,824 --> 00:23:23,146
if it can't reach it, it will free it. And it also

381
00:23:23,168 --> 00:23:26,874
has a built in memory. Managing this cyclic

382
00:23:26,922 --> 00:23:30,590
garget garbage collector is sometimes a bit of a pain

383
00:23:30,660 --> 00:23:34,250
in Python because it runs in the background, and when it

384
00:23:34,340 --> 00:23:38,066
executes or tries to free up memory, it typically pauses the

385
00:23:38,088 --> 00:23:41,346
execution of your code, at least. So how I understand it to

386
00:23:41,368 --> 00:23:45,246
be that can then cause security vulnerabilities

387
00:23:45,358 --> 00:23:49,014
and memory leaks. So it's maybe not the most efficient way,

388
00:23:49,052 --> 00:23:52,642
but it certainly works well in Python and everyone's old trusty

389
00:23:52,706 --> 00:23:56,038
Java. It's actually really similar to go in a

390
00:23:56,044 --> 00:23:59,266
lot more ways than people may think. It uses

391
00:23:59,298 --> 00:24:02,806
a stack and a heap in a very similar way. It has a garbage

392
00:24:02,838 --> 00:24:06,506
collector which manages the memory on the stack and with the

393
00:24:06,528 --> 00:24:10,038
heap, and it uses a technique called mark and sweep,

394
00:24:10,134 --> 00:24:13,594
very similar to what I just said. It will go around and try and find

395
00:24:13,632 --> 00:24:16,954
all the referenced and all the allocated memory, and it makes a notation

396
00:24:17,002 --> 00:24:20,446
of it. Everything that it finds that is not referenced, it will

397
00:24:20,468 --> 00:24:23,934
then sweep away and get rid of. Little bit different

398
00:24:23,972 --> 00:24:27,666
to how go works, because go actually uses a stop the world technique. But that

399
00:24:27,688 --> 00:24:30,180
is a conversation for another day.

400
00:24:31,350 --> 00:24:34,770
So what are my top tips for effective memory management?

401
00:24:35,750 --> 00:24:39,126
Use the defer keyword. It schedules a function to

402
00:24:39,148 --> 00:24:42,642
execute later, typically when the surrounding function returns.

403
00:24:42,786 --> 00:24:46,818
So always use it. This will help clean up your files, close connections,

404
00:24:46,914 --> 00:24:50,380
and release any locks that are still there.

405
00:24:51,230 --> 00:24:54,998
Number two, use the garbage collector wisely.

406
00:24:55,174 --> 00:24:58,506
It's important to understand you have it. It's important to

407
00:24:58,528 --> 00:25:01,726
know it's there and it works in your favor. But if

408
00:25:01,748 --> 00:25:04,906
you are consistently creating and discharging lots

409
00:25:04,938 --> 00:25:08,400
of short lived objects, it's going to

410
00:25:08,770 --> 00:25:12,222
make your program slower. Something or too much of something

411
00:25:12,276 --> 00:25:15,906
good can sometimes lead to something bad, and in this case you can

412
00:25:15,928 --> 00:25:20,834
run into that problem with go. So be

413
00:25:20,872 --> 00:25:24,386
very selective of how and be very pragmatic when you

414
00:25:24,408 --> 00:25:28,100
are making decisions with your code. And number three,

415
00:25:28,710 --> 00:25:32,118
monitor memory utilization on your system.

416
00:25:32,284 --> 00:25:36,370
Use the tools that are available to you as a developer, such as utilities

417
00:25:36,530 --> 00:25:40,166
on a Mac, such as what I use. Use Pprof,

418
00:25:40,278 --> 00:25:43,946
use the built in tools, use the go toolchain to help you create a

419
00:25:43,968 --> 00:25:47,658
more dynamic program. Just understand it

420
00:25:47,744 --> 00:25:51,630
from a lower level and it will help you write good

421
00:25:51,700 --> 00:25:55,214
code. In conclusion, there are a

422
00:25:55,252 --> 00:25:58,794
few things that I want to say. Memory management

423
00:25:58,842 --> 00:26:01,902
is complicated. It is by no means easy, and this talk

424
00:26:01,956 --> 00:26:05,238
very much scratches the surface, but hopefully opens the doors

425
00:26:05,354 --> 00:26:08,626
and ignites some inspiration for you to want to dig a little bit

426
00:26:08,648 --> 00:26:11,620
deeper into the management of memory. In Go.

427
00:26:11,990 --> 00:26:15,218
The garbage collector handles most of it for you.

428
00:26:15,304 --> 00:26:18,246
Like I said, it's important to know it's there. It's important to know it works

429
00:26:18,268 --> 00:26:20,870
in your favor. Just understand it properly.

430
00:26:22,090 --> 00:26:25,714
Thirdly, memory management is different across languages. You may be comfortable

431
00:26:25,762 --> 00:26:29,442
in one language and it can be completely different in another, which ultimately

432
00:26:29,506 --> 00:26:33,146
leads to a different style of coding and understanding. So there's more

433
00:26:33,168 --> 00:26:35,674
to it than just knowing how to create a hello world.

434
00:26:35,872 --> 00:26:40,578
Understanding how to manage it once you create more complex programs

435
00:26:40,614 --> 00:26:44,560
is super important. And of course leaks are really bad.

436
00:26:45,090 --> 00:26:48,366
So with that, before I close off, let's go see

437
00:26:48,388 --> 00:26:51,946
if we can create and see Pprof in action.

438
00:26:52,138 --> 00:26:56,850
So I am going to come out of my slides and

439
00:26:56,920 --> 00:27:00,274
open up vs. Code. In vs code, I have got a little

440
00:27:00,312 --> 00:27:03,634
program that is running. We've got a

441
00:27:03,672 --> 00:27:08,050
couple of imports, pretty standard. We've got Pprof

442
00:27:08,130 --> 00:27:12,022
also imported, but we're ignoring it. We have the little underscore which

443
00:27:12,076 --> 00:27:16,070
if you write go, you'll know you're ignoring anything

444
00:27:16,140 --> 00:27:19,730
with an underscore. We have a main function which is spinning up a

445
00:27:19,740 --> 00:27:23,242
go routine and it's going to create a server for me

446
00:27:23,376 --> 00:27:26,714
and it's on port 60 60. Now that's really

447
00:27:26,752 --> 00:27:30,490
interesting because port 60 60 is actually where Pprof runs.

448
00:27:30,990 --> 00:27:34,150
We're going to print out hello world and we're going to have a weight group.

449
00:27:34,240 --> 00:27:37,758
Now this basically blocks and allows go routines to complete at

450
00:27:37,764 --> 00:27:41,018
this point. Then we're going to add number one into a weight

451
00:27:41,034 --> 00:27:44,238
group. We're going to add to it and we're just going to call leaky function.

452
00:27:44,324 --> 00:27:47,826
Now, leaky function is a function I've got written at the bottom, which is

453
00:27:47,848 --> 00:27:51,106
going to do some fun stuff for us. It's just going to

454
00:27:51,288 --> 00:27:54,260
go around a for loop a lot of times.

455
00:27:55,610 --> 00:27:58,600
So let's spin this up and see what we get.

456
00:28:00,170 --> 00:28:04,038
So let's start the main function with gorun. Main go.

457
00:28:04,204 --> 00:28:07,720
Now hopefully we should see an output here.

458
00:28:08,830 --> 00:28:12,886
Cool. So we got hello world. Now let's go and check out Pprof.

459
00:28:13,078 --> 00:28:18,090
Let's go go tool pprof.

460
00:28:18,750 --> 00:28:22,880
And we're going to give it the heap. Although localhost 60 60.

461
00:28:23,970 --> 00:28:27,742
Right, we're in now just like you would do in

462
00:28:27,796 --> 00:28:31,246
your terminal if you want to follow some log or something. We're going

463
00:28:31,268 --> 00:28:35,794
to do use the word or use the command top this

464
00:28:35,832 --> 00:28:39,854
is going to help show us where our memory is being utilized.

465
00:28:39,982 --> 00:28:43,554
And straight away we can see leaky function right

466
00:28:43,592 --> 00:28:47,202
at the top with a use rate of 91%.

467
00:28:47,336 --> 00:28:50,438
So it's using a lot of memory and

468
00:28:50,524 --> 00:28:53,974
the longer I leave it, the more it's going to fill up. And of course

469
00:28:54,012 --> 00:28:58,038
we could see a lot more of it. Now, there is also another way that

470
00:28:58,044 --> 00:29:01,318
we can see this. We can go into a browser and we can go and

471
00:29:01,324 --> 00:29:04,886
get like a full stack heat print, but as well. But that's

472
00:29:04,998 --> 00:29:08,730
a completely separate kettle of fish. But this is just a really quick way

473
00:29:08,800 --> 00:29:12,566
in your terminal to see how much memory you're using and where it's being

474
00:29:12,608 --> 00:29:16,874
used in your functions. So let's head back to the slides

475
00:29:17,002 --> 00:29:20,526
and we will just finish off with that. I would

476
00:29:20,548 --> 00:29:23,694
like to say a massive thank you to everybody for joining my talk today.

477
00:29:23,812 --> 00:29:27,134
And if you have any questions, please do reach out to me on social media.

478
00:29:27,252 --> 00:29:30,398
I would love to answer your questions. I'd love to have conversations around this.

479
00:29:30,484 --> 00:29:34,462
I'm learning just like you. So please do connect

480
00:29:34,596 --> 00:29:36,690
and thank you very much and goodbye.

