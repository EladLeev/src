{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/fba2e5cb-c8c6-4f28-9822-3ee4bf7107b6", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["app", "backend", "be", "being", "best", "breaking", "build", "by", "can", "code", "combination", "conf fourty two", "frontend", "haskell", "jvm", "kulkul technology", "lang", "mappuji abdurrachman", "refactor", "refactoring", "scared", "software", "things", "type", "typesafe", "typesafe web development", "using", "youll"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "id": "67705504-68db-4e85-8c6a-bb12e9c59660", "status": "completed", "error": null, "text": "Thank you for coming to my talk with the title of enjoy typesafe web development with Ada. Well it is not actually about Ada, but I want to take Ada as a way to basically that there is a lot of opportunity in using functional programming in the JVM world, right. So I'm Mapuji, I'm from Kulkul Tech and in this conf 42 series I wanted this us about FP. Why is it very important and then how it benefits you like Java programmer, right? And the good news is I'm from Java island so let me work to you about FP and the Java ecosystem, right? Okay so I want to discuss about a lot of things, but this is the outline, right? So one is I want to discuss about what is functional programming really is and what are the benefits of using functional programming, what type of FP languages and if it's really awesome, what is the success I ever had in the past. And I'll discuss about Elm and how I really loved it. And I want to explore further about using FPL language in the JVM world. And it leads me to the Ada, how I use Ada as one of the example of pure FP language in the JVM world. Right, okay so that's a lot of jargon, but let me take you to a story, right? So if you take a look to FP programming or fastline programming, it is actually a very old concept. It is created in 1978 by a bunch of people and it is really old, right? And the good thing is, although it is really old, the concept still holds true till today. And this is very fascinating for me because it is such an old concept, but it keep repeating and then there is a lot of value in learning about it. It gets you become a better programmer by learning it, right? And it will not be like frontend development where they invented a lot of concept last night. It is just like good old concept, right? And there is a story when I playing with Elm in the front end world because Elm is like pure FP languages, people think that the number of updates that met in the past few days is really matters. And then the problem with Elm is Elm is updated two years ago and there is no update since then. But it is very stable. But people things that if it's not up there is stable or it is like unmaintained. But the thing is for Elmer is really stable, but for some other programming language, I don't know, but sometimes in FT world it becomes very very stable. Right? Okay, let's continue. So there is a nice meme about code written in Haskell is guaranteed to have no side effect because no one will ever run it. Right? Okay, so what is actually FP? So let me introduce you to John. John is a software engineer and he would like to create a new web app. So he's writing a web app and he grabbed his favorite language and hint is it's Java. And he start writing, right? And he's using a new tech stock, it is using a new this, new that, anything and whatnot. And it will take a while for him. And few moments later, Tada. Now he's having a working app and he scared to create a pull request, right? So he made that pull request and now the code will go through a series of code review, right? But like in any other code review, your spaghetti code will not pass, right? And he got things, he got recommendation to refactor the code from the senior guy. And like any other code review, ten lines of code, ten issue. But if it's 500 lines of code, it looks fine. And the problem is John is come to the former batch, which is ten lines of code, ten issues. Tada. Okay. Then he can reflect up the code. So he's tap tap, tap tap tap tap tap tap tap tap tap tap, tada. All the sweat. And he said, I finished refactoring the entire code. Cool. Is the bug fixed now? Is the app is still working? Turns out it's not. That's a problem. What we can learn from here, the thing is developing software is hard, right? The other problem is building reliable software needs a lot of effort. There is code review, there is unit testing, there is refactoring. And sometimes software is just, there is too much detail in it. There is too much details, right. And take a look in the refactoring. Refactoring is good, I support it. But sometimes it can be very complex. So I asking can it be more simple? And next part is, is it possible to make like refactoring? And all the effort we have in the making of software engineering, more reliable, more enjoyable maybe. And my suggestion is so welcome to the functional programming. I cannot guarantee you much, but it's been fun for me. Welcome to the FP. And then I'll introduce you to what FP is. So FP is like old concept. It's already there since 1978. And turns out like I said earlier, it can help you code better. So one, it helps make your mind to a see things differently. So when you code in functional programming, it's very far, far different. So youll used to work with objects or imperative programming, you prepare some variable, you do things, but in the FP it's the same, but it's a little bit different. So now you see things differently and it is affecting you when you do code now you be more creative with composing functions. Now when you write the code, youll model the code with different construct, you model the code with a lot of function, you're composing it together and hopefully it can help you to write better code by making the code more readable. You can use a lot of concept in phasma programming querying. You can do something like pipe operator and things like that and it becomes very expressive. And the good thing is if you are using a very strict FP language, it can make your code easy to change, easy to refactor, easy to maintain. This is very, very integral part, and very important part that I really love about FP is if you choose the right FP languages, it can make your code easy to change and it's very enjoyable. So you can create like the code looks like something right now, but in the future if you learn new things, you can refactor it and then make the code to be something else. You can refactor, the interface is the same, but you can refactor, but you can feel safe because if it's compiled it might be working. So it scared better because now your code is composed by function. Hopefully it is like pure function. So you can take an advantage of concurrency of you don't need to think about state anymore. And yeah, this is it. So let's take a look. The quote from Uncle Bob from the clean architecture all risk condition deadlock condition. Concurrent problems are due to mutable variables. See mutable variables and let's take a look to the Eric Eliot quotes. FP is the process of building software by compassing pure function, avoiding set state mutable data side effects and functional programming is declarative rather than imperative. And application that flows through pure function flows through pure function. Okay, so let's continue. So what is the benefit of using it, right? It seems awesome. If you are using FP, you can get the following advantage. Your code can be achieving the holy grail of bugs free code because youll have no side effect. If your code is compiled, 90% is working usually. And you can take advantage of efficient parallel programming because you are using immutable data. You don't need to think about memory anymore, and you can take advantage of concurrent programming. You can use nested function, you can use lazy evaluation, things like that. It's very awesome. It can make you more readable and more performance this way, but if you're doing it right. Okay, so there is a couple of types of FP languages. So there is the first part which is more into pure functional programming language like Haskell, L. Mercury clean and so on and so forth. There is another part of language which is impure functional programming language like Scala, closure, f, sub okaman and so on and so forth. There is also a lot of op languages or multi paradigm languages like JavaScript, Ruby that's now trying to adopt a lot of FP idea into the language. And it's cool. It's very awesome I think. And they should do more, right, okay, so what functional programming success I ever encountered. So let's take a look to my experience in building application using FP functional programming. It is elm. So if you take a look to the Elm website, you can see that they claim that it is a delightful language for reliable web application. And there's a lot of testimonials. It is like a scam, I told youll it's like a scam. So some people said it is the most productive programming language I have used. Some other people said my favorite thing is the feeling of joy and relaxation when writing elm code. Others said using Elm I can deploy and go to sleep. And some other people said just follow the compiler errors and come out the other end with the working app. So if you break things, you refactor like John and then now you break things. Initially your code is like having a compiler errors, but once you finish all the compiler errors, 99% it is fully working app, right? It's very amazing, right? Yeah. And the other feature it's provided is something that's really rare in web UI or web development or friend development is runtime exception. So if you take a look to the Javascript error in the browser, you can open Google now and then go to the web tools devtools, you can see that there is a lot of console log error. Sometimes you open Facebook, it's the same. You open Twitter, it's the same. There is usually some runtime error happening there, but by using what is it? Elm, you can basically minimize the error to almost zero. So it is happening on NoRAD ink where they have almost zero runtime error. They get it one, only one. It is because bug in the compiler, but it is already fixed by now. So the other good thing is if you see here, the compiler gives you some very meaningful errors. So in here it said this to in call projects may be in, but drop needs the first argument to be in. And there is a hint there, right. It's very interesting and like I said before, fearless refactoring, where the compiler guides you safely through your changes and sharing confidence even through the most wide breaking refactoring in unfamiliar code base. It's very awesome because whether you're renaming a function or you make drastic changes in a code data type, you just fold the compiler and by the end of the day you can get a working app. And the other good thing is this is something that really specific to Elm, but they have some model on building reliable app, but this is specific to them. Right. Let's just keep it. So the last part is about fast and friendly feedback. People now really interested in immediate feedback. They need things now and then. Having a compiler that's really helping youll to get that fast feedback is pretty awesome and I think most compilers done that, but elm make it to the next level by having a very easy to read and friendly kind of frustration friendly. What is it? Nice compiler errors and you are talking to compilers rather than you blame the compiler, right? It's very empowering. And now I know I want to explore more about Ada. So Ada is one of the pure FP language in the JVM world and it is awesome. And it is basically Haskell for the JVM. So let's take a look at it. So why people are using Ada? So EDA is there because it has a very robust interrupt. So ETA has a strongly type FFI or foreign function invocation or interface that allows you to safely interrupt with Java. And it has another properties which is ultra type safety which it has a global type inference giving you a dynamic language experience, but with a strong type hidden underneath. Sometimes you don't need to put all the type annotation, but youll still get all the advantage of very very strong type system. And because the next part is ETA offers wide range of strategy for handling and currency. Like there is STM, there is mfas, there is fibers. So it's very flexible. And let's take a look to the demo. So let's go to the demo now. Hopefully it is working. Okay, so ETA is updated now I can now run Ada atlas run and it will run through the app, it resolving all the dependency and all that stuff and then downloading from source. And then after that we can run it. But while it's compiling the app, let's take a look to the code. So this code is. You can take a look at it in GitHub. It is very simple. I create two applications. One is the Fibonacci application, the other is the simple hello world. We'll basically walk through it like one by one. And the idea is, it is mostly Haskell, right. It is Haskell code. The code is HHS, which stands for Haskell. Right. And if you take a look at it. So while my code is still compiling, let's take a look at programming languages. If you see here, in here, they want to create, what is it? They want to create a very simple hello word application API. And then what they can do is basically they create a type API and then they can decide that I want to create hello. There is a query params and then basically it's returning a JSON value, right. And then after that you can create some similar to controller here, like controller. And then after that you can basically returning an error there if they didn't tell your name, otherwise it will basically returning hello something. There is maybe, and there is the other one, right. And it is running on the port 9000. Okay, so let's take a look at the actual code here. I hope it is already running. So in here it's still processing just fine. Yeah. So the problem with Ada is, well, I'm doing it. The problem with Ada is Ada is running, having a lot of problem lately. So the maintainer is not very active anymore. So the downside is Ada is not really actively maintained, but it's pretty much stable. It's pretty much stable. And you can use a lot of Haskell packages here and then you can still doing a lot of productive development in Ada. But I think it is interesting idea to have Haskell with the interact of Java. But the really good thing is what I recommend using Ada is not for production application, but more like youll are learning things, you can see things differently by learning how to write things in Haskell, especially if you are from Java world, you don't want to learn all the Java build tool, but now using Ada you can use something like gradle to basically running Haskell application. Pretty interesting, right? Yeah. So while waiting you can go through all this and then get a cheat sheet and then get a feel of how Ada looks like. And then after that in here. Once we finish everything, we can basically run the app. So I'm waiting here. Okay, so let's check again on the docker we have on the atlas. It is running now. And let's take a look on our Fibonacci API. So it is very simple. So we have application running on port 9000 and let's take a look at it. So let's open local host 9000 and we put Fibu. Okay, so let's try, I have Fibonacci endpoint here. If I call one it gives me the Fibonacci number. If I put two I hit two, if I have four it returns like five things like that. Very awesome. And it can keep like on and on and on as you wish. Right. And things is just a very basic simple API. And then I want to give you the one that exactly looks like this. I can go here and then I can change the surfer into surfer. Two, for simplicity I can go here and then I will restart the machine building executable compiling and then transit running. And then in here we can get the endpoint hello and then query param, right. So just hello and then we can go query parame equal my name and it should be able to tell me my name. That's really awesome, right? Yeah, so that's very basic example of Ada. I'll make it larger. So the idea is we have almost similar application like Haskell, but you can do some java interrupt if you want. I give some Java interrupt example here if you want to take a look further and yeah, so that's the very basic endpoint I can tell to you. So the idea is you can have very strong type languages. So in here. So the magic on the Haskell is it's basically giving you this type, like this type annotation and then basically everything should match with this type annotation. And then in here one of the interesting part is the jetty surfer here where it's basically interoperability with the surplus. Right. Very awesome. So the idea is we are using surf and surfer, but behind the scene there is some page that Eta giving to the Haskell compiler, the Atlas compiler to basically using some patch version of to instead of using the actual serpent from the Haskell. So it's very interesting. Yeah, I think that's it. I hope that you enjoyed the simple demo I had and the Ada don't side. So as I said earlier that the language is not that maintained anymore. I'm not very a fit user of Ada. So I'm not sure if it's like the language is not maintained or it is already stable enough, but I think that it is the later one because many packages is not hosted anymore, I cannot install it and things like that. I need to run the docker version to make it run on my machine and things like that. So please think about it when choosing Ada in your production and managing compatibility with Haskell ecosystem is hard. So for example, if I were to run one of the example from the app, I need to basically very careful in choosing Haskell dependency. I'm not sure if it's from the Haskell or from the Ada, but it is very hard to manage the dependency and make the dependency working together. But yeah, that's it guys, that's about Ada. So I hope you enjoy my presentation. I hope that you can be a better John by maybe learning more about FP languages in the future, or you can also explore or applying it to your day to day work environment. So if you are a tech lead or someone that can basically influence a tech statistician, you might as well take a look at some FP languages instead of only the popular one. And I can assure you that it's worth the effort because it helps you open your mind and see things differently. And thank you. That's my presentation today. I hope that you enjoy my presentation. Talk to you soon, bye.", "words": [], "utterances": null, "confidence": 0.935650805171905, "audio_duration": 1309.0, "webhook_status_code": null, "webhook_auth": false, "summary": "-  Mapuji: There is a lot of opportunity in using functional programming in the JVM world. He talks about what FP really is and what are the benefits of using it. And it leads him to the Ada, how I use Ada as one of the example of pure FP language.\n-  FP is like old concept. It's already there since 1978. It can help you code better. If you choose the right FP languages, it can make your code easy to change and it's very enjoyable. Building reliable software needs a lot of effort. Is it possible to make like refactoring?\n- The other feature it's provided is something that's really rare in web UI or web development or friend development is runtime exception. By using Elm, you can basically minimize the error to almost zero. People now really interested in immediate feedback.\n- Ada is basically Haskell for the JVM. EDA is there because it has a very robust interrupt. It offers wide range of strategy for handling and currency. The downside is Ada is not really actively maintained. But I think it is interesting idea to have Haskell with the interact of Java.\n- Ada is not that maintained anymore. Please think about it when choosing Ada in your production and managing compatibility with Haskell ecosystem is hard. I hope that you can be a better John by maybe learning more about FP languages.", "auto_highlights_result": {"status": "success", "results": [{"count": 1, "rank": 0.08, "text": "pure functional programming language", "timestamps": [{"start": 546896, "end": 548710}]}, {"count": 1, "rank": 0.08, "text": "Haskell code", "timestamps": [{"start": 899088, "end": 900060}]}, {"count": 1, "rank": 0.08, "text": "programming languages", "timestamps": [{"start": 911524, "end": 912830}]}, {"count": 1, "rank": 0.07, "text": "impure functional programming language", "timestamps": [{"start": 555236, "end": 557306}]}, {"count": 2, "rank": 0.07, "text": "pure FP language", "timestamps": [{"start": 95312, "end": 96550}, {"start": 790410, "end": 791874}]}, {"count": 6, "rank": 0.07, "text": "FP languages", "timestamps": [{"start": 76808, "end": 77854}, {"start": 149782, "end": 150890}, {"start": 426700, "end": 427794}, {"start": 541856, "end": 542886}, {"start": 1276296, "end": 1277278}, {"start": 1291900, "end": 1292722}]}, {"count": 1, "rank": 0.07, "text": "FP functional programming", "timestamps": [{"start": 585820, "end": 587666}]}, {"count": 4, "rank": 0.07, "text": "code review", "timestamps": [{"start": 235500, "end": 236342}, {"start": 240300, "end": 241142}, {"start": 253040, "end": 253774}, {"start": 297792, "end": 298410}]}, {"count": 1, "rank": 0.07, "text": "better code", "timestamps": [{"start": 396912, "end": 397866}]}, {"count": 1, "rank": 0.07, "text": "elm code", "timestamps": [{"start": 615066, "end": 615722}]}, {"count": 1, "rank": 0.07, "text": "FP programming", "timestamps": [{"start": 106004, "end": 107514}]}, {"count": 1, "rank": 0.06, "text": "bugs free code", "timestamps": [{"start": 512468, "end": 513422}]}, {"count": 1, "rank": 0.06, "text": "unfamiliar code base", "timestamps": [{"start": 716808, "end": 718018}]}, {"count": 10, "rank": 0.06, "text": "functional programming", "timestamps": [{"start": 41324, "end": 42306}, {"start": 71560, "end": 72494}, {"start": 75016, "end": 76062}, {"start": 334428, "end": 335906}, {"start": 361476, "end": 362730}, {"start": 492032, "end": 492934}, {"start": 547302, "end": 548166}, {"start": 555914, "end": 556986}, {"start": 578236, "end": 579154}, {"start": 586370, "end": 587666}]}, {"count": 1, "rank": 0.06, "text": "op languages", "timestamps": [{"start": 562484, "end": 563694}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}