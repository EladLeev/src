{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/59072a1a-59ac-4870-b794-19d61c332029", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["asked", "before", "conf fourty two", "creating", "decrypt", "gameplay", "games", "ieee branch of university of patras", "myron giannakis", "programming", "qiskit", "quantum computing sg coordinator", "skills", "thats", "users", "using", "utilizing"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "id": "ded49b59-a60e-40d8-a8f4-021398b3be54", "status": "completed", "error": null, "text": "Hello everyone, I am Myron Giannakis and I hope you are as excited as I am to join my talk on implementing quantum algorithms using Qiskit. First of all, let me introduce myself. I come from Greece where I am studying computer engineering and for the last two years I am the coordinator of the Quantum Computing Students group pertain of the IEEE brands of the University of Padres. There we try to introduce and get involved into quantum computing more of our university students, and what I'm going to talk about today is a game I developed in order to make this task more interesting and easier for the new members. I will be more than happy to get in touch with any of you via either LinkedIn or email so you can find both of them on this first slide. And please do not hesitate to send a message. My talk comprises two main parts. The first one is more theoretical, providing an abstract of quantum git distribution and the protocol BB 84 that I'm going to talk about. And the second part will be code oriented where I will present more practical concepts of the project, the main idea, the code and the game. First, I would like to briefly introduce some of the prerequisite theoretical aspects just to make sure that we're all starting on the same page. The subject I will focus on is, as I said, quantum gear distribution, or QKD for sort, and specifically the protocol BB 84, a scheme developed by Charles Bennett and Zilbrasard in their paper published in 1984. Being the first quantum cryptograph protocol, QKD aims at the creating of a secret key shared between authorized partners connected via both a quantum channel and a classical authenticated channel. The security of the key relies on two conditions. First, the existence of an authenticated public classical channel and second, and most more important, the no cloning theorem that states that unlike classical computing in quantum, it is impossible to copy a quantum state. It is a quantum property that information gain is only possible at the expense of disturbing the signal. Talking about security the uncertainty principle of quantum physics gives rise to new cryptographic phenomena unachievable with traditional transmission media. For example, the communication channel described in BB 84 protocol is impossible in principle to be eavesdropped without a high probability and really high probability of disturbing the transmission in such a way as to be detected, making it secure against any traditional kind of creating without putting any restriction on an eavedropper's power. So it is basically unbreakable, we would say. Now let's see what exactly is adjusted by the protocol. Here you can see the circuit as well as a demonstrative example, we consider two users called Alice and bob, a and b, and let Alice choose a random bit string and a random sequence of quantum games had the mart's or identity. She then creates a train of qubits. It's initialized to one bit of the string and passed through the respective gate. Bob on the other end of the channel, receives these qubits and decides at random whether to apply on each of them a hadamard gate or not, before measuring it and collapsing its state into a classical zero or one a classical bit. It is not hard to understand that in the case where Bob uses the same quantum gate as Alice, he will certainly get the bits he initially sent, while when they use different games he will get a random bit that doesn't contain any information thats Bob obtains meaningful data only from half the qubits on average that he receives those for which he guessed the correct gate exactly. These bits are the ones thats are going to form the key at the end of the protocol, but the users do not know yet which ones they are. Each one knows only the gates they used and the bits they sent or received, whether they're Alice or Bob. So they have to communicate through a classical channel to pass the needed information. Though since this channel will be susceptible to eavesdropping, they should not reveal the bits values, but communicate only the games they applied. In that way, any eavesdropper would know which bits have been transmitted correctly, but not their actual values. The security of the process during both the quantum and the classical communication is guaranteed in the quantum since an IFS dropper would disturb the quantum state and thus be detected. According to the no cloning theorem, he cannot replicate the state. So Bob would extract wrong data and understand that there would be a problem in the classical case. In the classical channel, the security is guaranteed because there's not using transmitted any information about the key, the data thats is transmitted the games. It is useless to someone that does not have access to either Alice's or Bob's bits. At the bottom here of the slide, I provide an example of application of the protocol where I demonstrated all the before mentioned steps. On the first row, there are the initial bits that Alice sent, then Alice's and Bob's gates, and the received bits, and at the bottom part is the communication through the classical channel. We're finally keeping only the correctly transmitted bits to form the secret key. Now that we have seen the theory of the protocol, let's try to think of a way to motivate students to get involved into learning it. My idea was to use Qiskit to implement the protocol and organize a competition, a competitive game where I would send a secret message to all the students and they would have to write their own code to decrypt it as fast as possible. Qiskit, for anyone that doesn't know, is an open source quantum software development kit provided by IBM. It is available as a Python library, which makes it really easy to implement, and it simulates the operations of a quantum computer while also allowing operations that would not even be possible on a real quantum machine, for example, peaking in a superposed state without disturbing it. I exploited this fact to make my game easier to implement and more interesting, and add more learning value to it. Let me now describe the structure, the main idea of the program. While it is based on the BB 84 protocol, it differs from it on two main points. First, Alice does not send a bit string, but a character string. Its character is represented by a quantum circuit of seven qubits instead of one qubit, and they correspond to the seven bits of its ascii code. And in order to not complicate things, all games that are applied to any circuit or qubit are applied to all seven qubits of it. The second difference is that the data transmitted through the whole process is not a key like in the BB 84 protocol, but it is the whole message. This requires retransmitting many times. Probably it has a complexity of log of x, since each time half of the characters are expected to be received correctly. So it should be a complexity of Big O of log x, where x is the length of the message, and each time the new message is games as the previous one, excluding the correctly received characters. We will see it in more detail in a few minutes. The initial program is composed of three main parts of code that are those that you can see in the image in the slide. The first is the crypto circuit class, which inherits Kiskid's quantum circuit. The characters that I talked about are encoded in instances of this class. Second is the class protocol BB 84. It contains the static methods that implement the sender, the receiver, and the classical channel of the protocol. And finally, there's also the main function which controls the whole program and processes the data that are sent and received transmitted in general. Let's get into the details of the program's code. Starting with the main function here, you can see the whole code of it, and the main part of the function is this while loop, which repeats the transmission until the whole message has been received correctly. Then the methods of the protocol BB 84 class get called, each one provided with the information that it should have access to, and only this information. So the receiver gets us input only the circuit because we're talking about the quantum channel. And then the classical channel method gets us inputs the games of Alice and Bob's that Alice and Bob have applied. Finally, at the end of the function, we get the part of the message that Bob received and calculate the message that Alice will have to resend in order to continue this process in the while loop loop. Now let's dive a bit deeper, looking at how the previous static methods are actually implemented. On the left you can see the sender method, whose input is only the message for its character of the message it creates. The quantum circuit initializes it to the correspondent ASCII code, applies at random the Hadamart or identity games, and returns an array of the circuits and one of the gates that were used. On the right. The receiver method gets as input the list of the circuits received by Bob, and for each one of them applies his random gate and measures the result, getting an ascii character. This method returns the received characters as well as the array of Bob supplied games. Finally, the method of classical channel receives as inputs the two lists of Alice's and Bob's games, and returns the indices of the correctly transmitted characters, the indices and not the actual characters. Of course, for the reasons that I mentioned before, these methods are not complicated and don't do anything more than implementing what was described in the theory. Finally, the class for the circuit, the class where r encoded all the characters that are to be sent is the cryptocurcuit class, I'm sorry. Which extends the kiskit's quantum circuit and adds the necessary methods for the program. For the game. The methods initialize, add, gate, and get measurements are asked to respectively set the circuit to an initial state, add or not Hadamard gate, and get measurements for the circuit's qubits. The interesting method here though is the visualize, which displays the multivector of the circuit. Here I have added a simple example of a circuit to make it easier to imagine how the circuits would look like this one comprises of only three qubits representing the bits zero, one and zero as it can be seen from them if we read the visualization. And on the right I have added a hadamard gate on the circuit so you can see the 90 degrees rotation of the three block vectors. This is the case that was mentioned before where Bob doesn't get any information about the characters, about the character since he thats the same probability to get any character. Each one has 50% probability to give measurement of zero or one. You can see under the block spheres that the result of the measurement is a random triplet of bits and not the initial 3010. Getting to the last part of my talk, how did I get from the program to the game? For that? Instead of calling the main function, I called directly the sender method and saved the results. The lists of circuits and games in two files representing the two channels respectively, quantum and classical for the circuits and gates in each one you can again see the code here. It is nothing too complicated. And then I shared these files with the students along with Jupiter notebook containing the basic codes, but leaving a big part of the protocol to be implemented by them. More specifically, the crypto circuit class was provided so they can properly use the circuits and the protocol BB 84 class is as it can be seen here in the image. It missed entirely the sender method since it wouldn't be of any need for them, and the receiver and classical channel methods were empty to be implemented by the participants. The participants also had to write some kind of a main function that would call the methods process. The outputs take the needed actions in order to get to a result. This whole thing was done in the form of a competitive game where winner would be the first person to manage to decrypt my initial message. So this was how I implemented a variant of the BB 84 protocol in a game, hopefully fun, that engaged many of my fellow undergraduate students in quantum computing. Thank you very much for listening. If you are interested to know more about this and other projects, please check out my team's GitHub repository and I am looking forward to connecting with you for further and deeper discussions. See you.", "words": [], "utterances": null, "confidence": 0.925300758401455, "audio_duration": 1265.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Myron Giannakis will present his talk on implementing quantum algorithms using Qiskit. The talk comprises two main parts. The first one is more theoretical, providing an abstract of quantum git distribution. The second part will be code oriented where I will present more practical concepts.\n- QKD aims at the creating of a secret key shared between authorized partners connected via both a quantum channel and a classical authenticated channel. No cloning theorem states that unlike classical computing in quantum, it is impossible to copy a quantum state. My idea was to use Qiskit to implement the protocol.\n- I implemented a variant of the BB 84 protocol in a game that engaged many of my fellow undergraduate students in quantum computing. This whole thing was done in the form of a competitive game where winner would be the first person to manage to decrypt my initial message. If you are interested in more about this and other projects, please check out my team's GitHub repository.", "auto_highlights_result": {"status": "success", "results": [{"count": 8, "rank": 0.07, "text": "classical channel", "timestamps": [{"start": 184924, "end": 186120}, {"start": 380348, "end": 381510}, {"start": 442128, "end": 443900}, {"start": 501252, "end": 502400}, {"start": 756932, "end": 757790}, {"start": 825692, "end": 826598}, {"start": 931692, "end": 932920}, {"start": 1187052, "end": 1188074}]}, {"count": 1, "rank": 0.07, "text": "quantum games", "timestamps": [{"start": 283948, "end": 285030}]}, {"count": 1, "rank": 0.07, "text": "Bob supplied games", "timestamps": [{"start": 923672, "end": 925170}]}, {"count": 1, "rank": 0.06, "text": "different games", "timestamps": [{"start": 332476, "end": 333394}]}, {"count": 7, "rank": 0.05, "text": "circuits", "timestamps": [{"start": 894224, "end": 894886}, {"start": 906148, "end": 906922}, {"start": 1009396, "end": 1009866}, {"start": 1029692, "end": 1030114}, {"start": 1116872, "end": 1117390}, {"start": 1126844, "end": 1127538}, {"start": 1167368, "end": 1168130}]}, {"count": 1, "rank": 0.05, "text": "classical computing", "timestamps": [{"start": 195846, "end": 197158}]}, {"count": 12, "rank": 0.05, "text": "bits", "timestamps": [{"start": 328732, "end": 328978}, {"start": 356356, "end": 357150}, {"start": 371512, "end": 371806}, {"start": 394272, "end": 394614}, {"start": 405140, "end": 405498}, {"start": 464830, "end": 465730}, {"start": 489550, "end": 490230}, {"start": 495222, "end": 496006}, {"start": 507258, "end": 508010}, {"start": 633180, "end": 633810}, {"start": 1038832, "end": 1039174}, {"start": 1094832, "end": 1095478}]}, {"count": 1, "rank": 0.05, "text": "classical channel method", "timestamps": [{"start": 825692, "end": 827490}]}, {"count": 3, "rank": 0.05, "text": "quantum computing", "timestamps": [{"start": 43856, "end": 44982}, {"start": 55492, "end": 56762}, {"start": 1241548, "end": 1242870}]}, {"count": 1, "rank": 0.05, "text": "quantum git distribution", "timestamps": [{"start": 100436, "end": 102110}]}, {"count": 1, "rank": 0.05, "text": "quantum gear distribution", "timestamps": [{"start": 140864, "end": 142198}]}, {"count": 9, "rank": 0.04, "text": "Alice", "timestamps": [{"start": 276828, "end": 277186}, {"start": 280252, "end": 280674}, {"start": 325852, "end": 326482}, {"start": 375006, "end": 375346}, {"start": 490656, "end": 491014}, {"start": 617510, "end": 618366}, {"start": 831164, "end": 831554}, {"start": 834508, "end": 834786}, {"start": 848320, "end": 848774}]}, {"count": 1, "rank": 0.04, "text": "quantum gear", "timestamps": [{"start": 140864, "end": 141558}]}, {"count": 1, "rank": 0.04, "text": "quantum physics", "timestamps": [{"start": 217096, "end": 218142}]}, {"count": 1, "rank": 0.04, "text": "quantum algorithms", "timestamps": [{"start": 29106, "end": 30162}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}