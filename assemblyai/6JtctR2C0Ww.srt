1
00:00:25,410 --> 00:00:29,106
Hello everyone, welcome to Conf 42 Golang.

2
00:00:29,218 --> 00:00:33,062
In this talk you will learn how to secure go APIs with

3
00:00:33,116 --> 00:00:36,754
decentralized identity tokens. My name is Mohammad Shahbaz

4
00:00:36,802 --> 00:00:40,210
Alam, a developer advocate at Magic, an authentication

5
00:00:40,290 --> 00:00:43,874
based company which will help you with all your authentication

6
00:00:43,922 --> 00:00:47,830
and authorization needs. So in this talk we will learn

7
00:00:47,980 --> 00:00:51,114
how the user trust model of the Internet is broken,

8
00:00:51,242 --> 00:00:54,814
what is decentralized identity token, and we will

9
00:00:54,852 --> 00:00:58,142
learn auth magic. We will also see what is

10
00:00:58,196 --> 00:01:02,174
authentication authorization and also see how

11
00:01:02,212 --> 00:01:05,746
to build a go API and then later on go on

12
00:01:05,768 --> 00:01:09,198
to secure that go API with magic.

13
00:01:09,374 --> 00:01:13,086
So let's get started. Users think of secrets

14
00:01:13,118 --> 00:01:16,370
or password very specific to them to verify

15
00:01:16,450 --> 00:01:20,182
identity and often hand them off to

16
00:01:20,236 --> 00:01:23,782
apps owned by various companies. 59% of all

17
00:01:23,836 --> 00:01:27,250
users reuse their passwords across apps.

18
00:01:27,330 --> 00:01:31,226
I'm pretty sure someone in the audience have used

19
00:01:31,328 --> 00:01:35,142
same password for multiple application users entrust

20
00:01:35,206 --> 00:01:38,602
companies to store their secrets securely and

21
00:01:38,656 --> 00:01:42,154
responsibly, but many companies roll

22
00:01:42,202 --> 00:01:45,454
their own authentication without the prior knowledge of

23
00:01:45,492 --> 00:01:49,422
security at all. Users access the company's services

24
00:01:49,556 --> 00:01:53,514
by sewing the secret again and again to the developer,

25
00:01:53,642 --> 00:01:56,846
and every time that secret is shown, there is a risk

26
00:01:56,878 --> 00:02:00,690
of exposing it to the hackers. Consider this step as similar

27
00:02:00,760 --> 00:02:04,146
to writing your secret in a piece of paper

28
00:02:04,248 --> 00:02:07,666
and giving it to the application developer.

29
00:02:07,778 --> 00:02:11,026
Companies might get hacked and lose secrets

30
00:02:11,058 --> 00:02:14,982
along with users trust. 48% of customers never

31
00:02:15,036 --> 00:02:18,874
come back after a breach. The equifax breach has

32
00:02:18,912 --> 00:02:23,478
cost them at least $1.4 billion users.

33
00:02:23,574 --> 00:02:27,430
The hackers users stolen secrets to impersonate

34
00:02:27,510 --> 00:02:31,214
users to access their vital online services. They use

35
00:02:31,252 --> 00:02:35,582
the same stolen password at multiple applications because

36
00:02:35,636 --> 00:02:39,614
of password reuse. And this problem compounds now

37
00:02:39,732 --> 00:02:43,954
that there are many companies acting on behalf of users to authenticate for

38
00:02:43,992 --> 00:02:47,490
them and the user's identity is no longer

39
00:02:47,560 --> 00:02:52,270
in their own hands, but controlled by a handful of large corporations.

40
00:02:52,430 --> 00:02:56,434
So what people tried before magic, they came up with zero knowledge

41
00:02:56,482 --> 00:02:59,238
authentication, a key based model.

42
00:02:59,404 --> 00:03:03,174
Instead of users thinking of secret themselves, they will use

43
00:03:03,212 --> 00:03:07,442
the blockchain based public private key pairs which are

44
00:03:07,516 --> 00:03:10,742
randomly generated to access applications.

45
00:03:10,886 --> 00:03:14,806
It has its pros and cons. The pros were users

46
00:03:14,838 --> 00:03:18,394
have complete control of their identity, which is good companies

47
00:03:18,512 --> 00:03:22,270
can't know user secret. Again, more secure and good

48
00:03:22,420 --> 00:03:26,062
users can use the same secret to access application,

49
00:03:26,196 --> 00:03:30,014
which is a cleaner trust model where there are no

50
00:03:30,132 --> 00:03:33,386
identity silos by companies, but it has its

51
00:03:33,428 --> 00:03:36,766
cons. Users are likely to lose their keys.

52
00:03:36,878 --> 00:03:40,226
I'm sure many of you have forget your

53
00:03:40,248 --> 00:03:43,970
password and we do too, which will lock them but of use

54
00:03:44,120 --> 00:03:47,090
good and lose their online identities or worse,

55
00:03:47,170 --> 00:03:51,090
get them stolen. So concept of using a key on the Internet

56
00:03:51,170 --> 00:03:54,934
is too unfamiliar for mainstream users because of

57
00:03:54,972 --> 00:03:58,490
bad UX and how magic improves the trust.

58
00:03:58,560 --> 00:04:02,278
So far magic uses a delegated key management

59
00:04:02,454 --> 00:04:06,026
model which leverages large infrastructure as

60
00:04:06,048 --> 00:04:09,782
a service and secure user keys

61
00:04:09,846 --> 00:04:14,346
with hardware security modules consider hardware security modules

62
00:04:14,458 --> 00:04:18,330
are similar to your UB keys which are a hardware device

63
00:04:18,410 --> 00:04:21,914
used as second factor authentication to store your private

64
00:04:21,962 --> 00:04:25,838
keys. Consider these hardware security modules

65
00:04:25,934 --> 00:04:29,614
on the cloud with technology. Magic leverages

66
00:04:29,662 --> 00:04:33,486
these with technology that hides and protects users private

67
00:04:33,518 --> 00:04:36,870
keys from companies and even from magic.

68
00:04:37,530 --> 00:04:41,282
It brought additional pros which are magic provides

69
00:04:41,346 --> 00:04:44,582
familiar passwordless auth UX like

70
00:04:44,636 --> 00:04:48,610
email, passwordless email, magic link, social logins,

71
00:04:48,690 --> 00:04:52,554
web authent to users for

72
00:04:52,592 --> 00:04:56,234
them to retrieve their keys which is a better UX and they

73
00:04:56,272 --> 00:04:59,574
can no longer lose their keys. Magic doesn't

74
00:04:59,622 --> 00:05:03,658
store passwords and cannot know users'keys or secret

75
00:05:03,754 --> 00:05:07,262
which is a more security and it provides more

76
00:05:07,316 --> 00:05:11,354
trust. Magic has native support for multiple blockchain

77
00:05:11,482 --> 00:05:14,754
and it has only one con which is that it is

78
00:05:14,792 --> 00:05:18,594
reliance on single infrastructure as a service. So the

79
00:05:18,632 --> 00:05:21,918
question is what is did token? Did tokens

80
00:05:22,014 --> 00:05:25,574
created by magic is adapted by prior text like

81
00:05:25,612 --> 00:05:28,854
JWT which is JSON web token and

82
00:05:28,892 --> 00:05:33,298
W three C's did protocol. It is encoded

83
00:05:33,314 --> 00:05:37,042
as a base 64 JSON string tuple representing proof

84
00:05:37,106 --> 00:05:41,334
and claim. It leverages the Ethereum blockchain and elliptic curve

85
00:05:41,382 --> 00:05:44,886
cryptography to generate verifiable proofs of identity

86
00:05:44,998 --> 00:05:48,426
and authorization. These proofs are encoded in a

87
00:05:48,448 --> 00:05:52,058
lightweight digital signature which is shared between client

88
00:05:52,154 --> 00:05:56,138
and server to manage permissions, protect routes

89
00:05:56,234 --> 00:05:59,690
and resources, or authenticate users.

90
00:05:59,850 --> 00:06:03,694
Decentralized identity token looks similar to

91
00:06:03,732 --> 00:06:07,330
this, which it has its proof and claim.

92
00:06:07,910 --> 00:06:11,202
The claims are the data representing the user's access.

93
00:06:11,336 --> 00:06:15,442
It has user's information and the proof is

94
00:06:15,496 --> 00:06:19,238
assigned data with Ethereum's personal sign method and we get

95
00:06:19,324 --> 00:06:22,822
proof but of the claim and then we encode this

96
00:06:22,876 --> 00:06:26,166
proof and claim and by that we get a

97
00:06:26,188 --> 00:06:29,290
did token and generating a did token.

98
00:06:29,630 --> 00:06:33,050
This is how a pseudo code look like. It has

99
00:06:33,120 --> 00:06:36,138
a claim representing the user's data.

100
00:06:36,304 --> 00:06:40,070
The issuer used here is the user's public

101
00:06:40,160 --> 00:06:44,426
address and again that claim is signed

102
00:06:44,458 --> 00:06:48,270
by Ethereum's personal sign method. The claim has

103
00:06:48,420 --> 00:06:52,046
issued at expiration subject not

104
00:06:52,148 --> 00:06:56,034
valid before time and bunch of other information

105
00:06:56,232 --> 00:06:59,390
and this again this encodes the did token.

106
00:06:59,470 --> 00:07:03,774
We encode the did token so it can be transported over HTTP.

107
00:07:03,902 --> 00:07:07,430
The decentralized Id token specification can be found on

108
00:07:07,500 --> 00:07:11,122
docs at magic docs and visit the decentralized

109
00:07:11,186 --> 00:07:15,110
Id section where you will get more understanding of what

110
00:07:15,180 --> 00:07:18,678
each key does. This is how you generate a did

111
00:07:18,764 --> 00:07:21,994
token with magic. This is a JS implementation of it.

112
00:07:22,032 --> 00:07:26,230
You can do it in Android, iOS and react

113
00:07:26,310 --> 00:07:29,986
native applications as well. And this is how you get a did token

114
00:07:30,038 --> 00:07:34,318
at client side. So first we import the

115
00:07:34,484 --> 00:07:37,662
magic SDK and then we instantiate that

116
00:07:37,716 --> 00:07:41,006
magic with API key. And this is an

117
00:07:41,028 --> 00:07:44,402
API key which you get on signing up to a magic account.

118
00:07:44,456 --> 00:07:47,314
We will see later in this talk.

119
00:07:47,512 --> 00:07:51,662
And then once you do with two line of code above.

120
00:07:51,806 --> 00:07:54,930
The third one is to users the auth

121
00:07:55,000 --> 00:07:59,106
module of magic SDK and call a function called login

122
00:07:59,138 --> 00:08:02,710
with magic link and pass on the user's email address.

123
00:08:02,860 --> 00:08:06,614
And once that is done the user will be able to

124
00:08:06,652 --> 00:08:10,210
log in with a magic email a magic

125
00:08:10,290 --> 00:08:14,042
link on their email by default. This function also

126
00:08:14,096 --> 00:08:17,930
gives you a did token. If you store it in a constant called did

127
00:08:18,000 --> 00:08:21,386
tokens, it will give you a by default did token with a

128
00:08:21,408 --> 00:08:25,166
lifespan of 15 minutes. But if you want to extend the lifespan of a

129
00:08:25,188 --> 00:08:28,862
did token, consider the lifespan as a validity of your

130
00:08:28,916 --> 00:08:31,962
token and you can use the users module

131
00:08:32,026 --> 00:08:35,970
of SDK and call the getid token and again

132
00:08:36,040 --> 00:08:39,726
pairs on the lifespan. And this lifespan is in seconds.

133
00:08:39,838 --> 00:08:44,226
If you want more than 15 minutes, pass on more than 902nd.

134
00:08:44,408 --> 00:08:48,706
And to learn more about it you can visit the decentralised magic

135
00:08:48,738 --> 00:08:52,706
doc to see how you can generate a did token with magic.

136
00:08:52,818 --> 00:08:56,246
So understand what is authentication and what

137
00:08:56,268 --> 00:08:59,514
is authorization, and then we will see how we do it,

138
00:08:59,632 --> 00:09:03,066
how we differentiate here at magic and how it works.

139
00:09:03,248 --> 00:09:06,634
So authentication is something are you the

140
00:09:06,672 --> 00:09:10,390
one who you say you are? And if your answer is yes,

141
00:09:10,560 --> 00:09:14,634
this is what authentication does and authorization

142
00:09:14,762 --> 00:09:18,218
is something like are you allowed to do this action?

143
00:09:18,314 --> 00:09:22,362
So if your answer is yes because you are allowed to do it,

144
00:09:22,516 --> 00:09:25,730
these are called authorization. Do you have the

145
00:09:25,880 --> 00:09:29,454
permissions to access that particular resource or route?

146
00:09:29,582 --> 00:09:32,660
And in this talk we will see both of it,

147
00:09:33,990 --> 00:09:37,574
how to authenticate and then authorization. So once

148
00:09:37,612 --> 00:09:41,414
you log into magic dashboard after

149
00:09:41,532 --> 00:09:44,854
signing up, you will see something like this, your first app,

150
00:09:44,972 --> 00:09:48,346
and we use the API key in the client side and

151
00:09:48,368 --> 00:09:52,234
we use the secret key at the server side. We will see

152
00:09:52,272 --> 00:09:56,150
in action how that happens in Go APIs.

153
00:09:56,310 --> 00:09:59,846
So authentication the login with magic

154
00:09:59,878 --> 00:10:03,526
link flow, how magic link get

155
00:10:03,568 --> 00:10:06,814
generated, how the authentication is handled here at

156
00:10:06,852 --> 00:10:10,234
magic. So consider a login request

157
00:10:10,282 --> 00:10:13,534
comes from your browser app which has a magic SDK

158
00:10:13,582 --> 00:10:17,214
loaded the magic iframe loaded

159
00:10:17,262 --> 00:10:21,074
onto your application, iframe is loaded into your application

160
00:10:21,272 --> 00:10:24,494
and a login request is made to magic

161
00:10:24,542 --> 00:10:28,102
service and once that is done there is

162
00:10:28,156 --> 00:10:31,974
a polar going on which checks every

163
00:10:32,012 --> 00:10:35,174
2 seconds whether the login has been done or

164
00:10:35,212 --> 00:10:38,860
not, and that has been passed to magic services. Magic services

165
00:10:39,870 --> 00:10:43,322
send a magic link email to

166
00:10:43,376 --> 00:10:46,442
user's inbox. User opens that email,

167
00:10:46,576 --> 00:10:50,038
click on the confirm link and the login is done.

168
00:10:50,144 --> 00:10:53,870
And at that time the polar gets

169
00:10:53,940 --> 00:10:57,374
resolved and it says that the login has been

170
00:10:57,412 --> 00:11:01,294
done and it resolves the SDK promise. Optionally, you can

171
00:11:01,332 --> 00:11:04,942
have a browser app, a different context, you can redirect

172
00:11:05,086 --> 00:11:09,858
to different URL and

173
00:11:10,024 --> 00:11:12,850
once you have the authentication, for example,

174
00:11:12,920 --> 00:11:16,158
user has the browser using the client application,

175
00:11:16,344 --> 00:11:19,782
theyre log in and they get a did token in return.

176
00:11:19,916 --> 00:11:23,494
In that did tokens there is a bunch of information,

177
00:11:23,612 --> 00:11:27,586
but users we pass that did tokens in the

178
00:11:27,628 --> 00:11:31,718
authorization header when we call the server

179
00:11:31,814 --> 00:11:35,722
at a protected route and when we want to protect

180
00:11:35,776 --> 00:11:39,034
a route, we would encapsulate that

181
00:11:39,072 --> 00:11:42,606
functions that route inside a protected method. We will see

182
00:11:42,628 --> 00:11:46,266
how that looks and then we try to access that API

183
00:11:46,298 --> 00:11:50,922
route by passing the did token in know authorization header

184
00:11:50,986 --> 00:11:54,870
at the server. We extract the did token from the header,

185
00:11:54,970 --> 00:11:58,722
we validate that token using magic SDK and once

186
00:11:58,776 --> 00:12:02,514
that is done the did token is valid token. We say that

187
00:12:02,552 --> 00:12:06,034
like yeah, go on and see. Because you have the permissions,

188
00:12:06,082 --> 00:12:09,686
you have a valid token to access the resources. So let

189
00:12:09,708 --> 00:12:13,734
us see how to build go API and how it

190
00:12:13,772 --> 00:12:17,230
looks. This is a simple go API

191
00:12:17,410 --> 00:12:21,274
main go file which has under normal stuff,

192
00:12:21,392 --> 00:12:24,554
but I have used gorilla mux over here to

193
00:12:24,592 --> 00:12:26,570
handle most of our routing.

194
00:12:27,950 --> 00:12:31,246
What it has we have bunch of imports and then

195
00:12:31,268 --> 00:12:35,450
we have handle request function which handles

196
00:12:35,610 --> 00:12:39,694
most of the things. And then we have home page

197
00:12:39,892 --> 00:12:42,874
which returns a response. Welcome to homepage.

198
00:12:42,922 --> 00:12:46,642
As you can see here and the server is running and then

199
00:12:46,696 --> 00:12:50,434
we have a protected page which says which is

200
00:12:50,472 --> 00:12:54,542
protect. Right now it's not protected but it's accessible

201
00:12:54,606 --> 00:12:58,310
without the token. But the ideal goal is to protect

202
00:12:58,380 --> 00:13:02,440
this particular route with a did token. And then

203
00:13:04,010 --> 00:13:07,874
we have something called myrouter handle

204
00:13:07,922 --> 00:13:11,910
function. And this is how we have main route,

205
00:13:11,990 --> 00:13:15,626
the home route and we call a function over here which

206
00:13:15,648 --> 00:13:19,322
is a home page and then we have a protected route calling

207
00:13:19,376 --> 00:13:23,280
the protect function. So if you try

208
00:13:23,810 --> 00:13:27,566
to run this you will see multiple things. And we

209
00:13:27,588 --> 00:13:31,770
are using port 9000. So this is how you listen and serve.

210
00:13:31,850 --> 00:13:35,650
So this is a very normal go API. The idea

211
00:13:35,720 --> 00:13:39,090
is to just simulate and see how we can protect

212
00:13:39,160 --> 00:13:41,938
a normal API of Go.

213
00:13:42,104 --> 00:13:45,806
So the server is running on localhost

214
00:13:45,918 --> 00:13:49,794
9000 and then when you try to see a protected route,

215
00:13:49,842 --> 00:13:53,730
it says that you are seeing a protected page without the token.

216
00:13:53,890 --> 00:13:57,694
So just so that we don't have to worry

217
00:13:57,762 --> 00:14:00,300
about how things happen here,

218
00:14:00,830 --> 00:14:04,234
I will go ahead and convert this particular

219
00:14:04,352 --> 00:14:07,674
application into a protected application and see how it

220
00:14:07,712 --> 00:14:11,806
looks. So this is what you will see what

221
00:14:11,828 --> 00:14:15,454
I have added multiple things and I'll explain one by

222
00:14:15,492 --> 00:14:20,080
one. So this is the same function,

223
00:14:21,090 --> 00:14:24,766
same API, which has like welcome to home page, but when

224
00:14:24,788 --> 00:14:28,126
you try to access the protected page, it says that the bearer token

225
00:14:28,158 --> 00:14:31,486
is required to access this rot. So this token

226
00:14:31,598 --> 00:14:35,018
is what we will be working on, how to get that token,

227
00:14:35,134 --> 00:14:38,946
how to verify that token and everything around that token.

228
00:14:39,058 --> 00:14:42,722
And here the token is the decentralized identity

229
00:14:42,786 --> 00:14:46,070
token, right? So we are using something

230
00:14:46,140 --> 00:14:50,234
called env to process and load the

231
00:14:50,272 --> 00:14:54,298
environment variable from env and we are using something

232
00:14:54,384 --> 00:14:58,426
called magic secret key. As I said, at the server side you

233
00:14:58,448 --> 00:15:01,694
users the magic secret key and at the client side

234
00:15:01,812 --> 00:15:05,102
you will use the magic API key, right?

235
00:15:05,236 --> 00:15:08,826
So apart from this, the gorilla max

236
00:15:08,858 --> 00:15:12,826
which is same, and I have just added env

237
00:15:12,948 --> 00:15:16,466
to access and load the env variable so that

238
00:15:16,488 --> 00:15:19,330
we can use the magic secret keys,

239
00:15:19,750 --> 00:15:23,694
right? And apart from that I have used a constant

240
00:15:23,742 --> 00:15:27,894
called authparer with bearer. And here we

241
00:15:27,932 --> 00:15:31,574
have imported this magic admin go from

242
00:15:31,612 --> 00:15:35,080
magic Labs. So we'll see how you could do that.

243
00:15:36,170 --> 00:15:39,640
And that's it. So after

244
00:15:40,170 --> 00:15:43,866
getting the magic secret key to a

245
00:15:43,888 --> 00:15:47,274
variable, we instantiate the

246
00:15:47,312 --> 00:15:50,778
magic SDK, calling client new and then passing

247
00:15:50,794 --> 00:15:55,130
on the secret. And this is how we instantiate a magic

248
00:15:55,290 --> 00:15:59,102
SDK. And then what we check is

249
00:15:59,156 --> 00:16:02,926
we check a bearer token. So we first define

250
00:16:02,958 --> 00:16:07,314
a function which will act

251
00:16:07,352 --> 00:16:10,706
as a middleware, right, middleware to

252
00:16:10,728 --> 00:16:14,514
a protected road protected route. So what

253
00:16:14,552 --> 00:16:17,874
it does is that it first checks whether

254
00:16:17,912 --> 00:16:21,206
the did exists in HTTP header or not. This is how

255
00:16:21,228 --> 00:16:24,854
we extract an authorization header and we compare that

256
00:16:24,892 --> 00:16:28,946
it has the prefix of bearer

257
00:16:29,058 --> 00:16:32,650
what we have defined here. And once the bearer token

258
00:16:33,070 --> 00:16:36,806
is present we pass on. If not, we say that bearer token is required

259
00:16:36,838 --> 00:16:40,366
to access this route and we will see everything in action when we'll do the

260
00:16:40,388 --> 00:16:44,094
demo. And then once

261
00:16:44,292 --> 00:16:48,026
we have a bearer token in the authorization header,

262
00:16:48,138 --> 00:16:51,646
we go on to extract that bearer token from the

263
00:16:51,668 --> 00:16:55,038
authorization header and that is what we have,

264
00:16:55,124 --> 00:16:58,766
which is a did token passed on from the client

265
00:16:58,798 --> 00:17:02,446
side. And then we create a token instance to interact

266
00:17:02,478 --> 00:17:05,622
with the did token. And this is how we do it. You can check

267
00:17:05,676 --> 00:17:09,414
more about this in the docs later on. And we check

268
00:17:09,452 --> 00:17:13,810
here is whether the did token is malformed

269
00:17:13,890 --> 00:17:17,126
or not. If there is an error it

270
00:17:17,148 --> 00:17:19,530
will throw out that particular error.

271
00:17:20,350 --> 00:17:23,722
At this stage leveraging is fine and

272
00:17:23,776 --> 00:17:26,140
this is what we do at server side.

273
00:17:26,750 --> 00:17:30,330
Every did token must be validated at server side.

274
00:17:30,400 --> 00:17:33,610
So you know you are working with a valid did token

275
00:17:33,770 --> 00:17:38,846
and this is how you do a

276
00:17:38,868 --> 00:17:41,850
token validate at go server.

277
00:17:42,010 --> 00:17:45,406
And if there is a token failed

278
00:17:45,438 --> 00:17:49,154
validation it will throw that error. And apart from

279
00:17:49,192 --> 00:17:51,620
that you can simply pass on.

280
00:17:52,950 --> 00:17:58,662
You can step ahead with next resolve with

281
00:17:58,716 --> 00:18:02,018
request and response,

282
00:18:02,114 --> 00:18:05,640
right? But this is what you can

283
00:18:06,490 --> 00:18:10,182
get more information about that did token, what it contains.

284
00:18:10,326 --> 00:18:14,060
So magic SDK is how we instantiate here

285
00:18:14,510 --> 00:18:17,990
the magic and then we call the user module

286
00:18:18,070 --> 00:18:21,466
of goads SDK and

287
00:18:21,488 --> 00:18:24,766
we call a function called get metadata by token. Here the

288
00:18:24,788 --> 00:18:28,714
token is did token. We pass on that and we get all those user

289
00:18:28,762 --> 00:18:32,702
info. So user info has email issuer and

290
00:18:32,756 --> 00:18:36,322
public address. We will see in action how it looks and

291
00:18:36,376 --> 00:18:40,034
once that is done the next function will go on

292
00:18:40,072 --> 00:18:43,326
to continue with the response and request.

293
00:18:43,518 --> 00:18:47,106
So this is how we define a checkbearer

294
00:18:47,138 --> 00:18:51,174
token middleware which checks the bearer token as

295
00:18:51,212 --> 00:18:55,090
well as validate the token and extract the user info

296
00:18:55,170 --> 00:18:58,738
from magic function called get metadata

297
00:18:58,754 --> 00:19:02,486
by token, right? And this is what the handle

298
00:19:02,518 --> 00:19:05,690
request is. It's similar to the previous one.

299
00:19:05,840 --> 00:19:09,114
As you can see this is same what we added here

300
00:19:09,152 --> 00:19:13,422
is under the we wrap the protected page function inside check

301
00:19:13,476 --> 00:19:17,040
bearer token middleware. So this is how

302
00:19:19,970 --> 00:19:23,806
you protect your route and nothing

303
00:19:23,908 --> 00:19:27,966
fancy over here. It's as simple as the previous one. And we

304
00:19:27,988 --> 00:19:32,074
have a home page function which just says welcome to homepage

305
00:19:32,202 --> 00:19:35,734
and a protected page which says

306
00:19:35,852 --> 00:19:39,046
you have access to c protected page. But when

307
00:19:39,068 --> 00:19:42,498
you try to see it inside a browser, it says bearer

308
00:19:42,514 --> 00:19:46,166
token is required. And to access this particular

309
00:19:46,268 --> 00:19:50,118
route you would need access to bearer token,

310
00:19:50,214 --> 00:19:54,170
right? Or specifically the did token.

311
00:19:54,670 --> 00:19:58,090
So how do you get a did token and how to use that?

312
00:19:58,240 --> 00:20:02,142
So this is a front end of the

313
00:20:02,276 --> 00:20:05,674
application. You can generate front end from multiple

314
00:20:05,722 --> 00:20:09,614
templates I have used. Next what you would do

315
00:20:09,652 --> 00:20:13,502
is just run NPX and make magic. We will see how

316
00:20:13,556 --> 00:20:17,326
it looks. And this is how you get a did token

317
00:20:17,518 --> 00:20:21,154
similar to this. So what has happened? Similar to what I was

318
00:20:21,192 --> 00:20:24,834
saying, how you do the auth login with

319
00:20:24,872 --> 00:20:28,594
magic link and pass on the email, right? And additionally

320
00:20:28,642 --> 00:20:31,874
you can create a did token calling the user

321
00:20:31,922 --> 00:20:35,106
module and calling the function getid token and passing

322
00:20:35,138 --> 00:20:38,466
on the lifespan here, the lifespan of the did token is

323
00:20:38,508 --> 00:20:42,570
8 hours. Consider this as a second, the second minutes and

324
00:20:42,640 --> 00:20:46,074
hours. So this is equivalent to 8 hours,

325
00:20:46,192 --> 00:20:50,074
right? And so we get a did token, you can see

326
00:20:50,112 --> 00:20:53,834
how it looks. The front end of the code is hosted

327
00:20:53,882 --> 00:20:57,182
on GitHub under a repo called

328
00:20:57,236 --> 00:21:00,766
frontend go API you can check out later on. So this

329
00:21:00,788 --> 00:21:04,270
is how you get a did token and simply you can clone.

330
00:21:04,350 --> 00:21:07,982
There will be steps to get functions, but when you clone

331
00:21:08,046 --> 00:21:11,362
this you just need to replace these

332
00:21:11,416 --> 00:21:15,066
variables, right. The publishable API key and the secret

333
00:21:15,118 --> 00:21:19,046
key. Secret key can also be used at

334
00:21:19,068 --> 00:21:22,278
the client side as well. But here it is used inside

335
00:21:22,364 --> 00:21:25,730
a next application which has something called API

336
00:21:25,810 --> 00:21:29,426
and you pass on and you protect multiple

337
00:21:29,458 --> 00:21:33,046
things. So let's not go into that which is beyond the scope

338
00:21:33,078 --> 00:21:37,034
of this video and talk. So let's grab this

339
00:21:37,072 --> 00:21:40,878
did token and once you do that you will be able to

340
00:21:41,044 --> 00:21:44,960
get a did token by logging into your application,

341
00:21:45,490 --> 00:21:48,702
providing your email address. Email will come to your

342
00:21:48,756 --> 00:21:52,126
email id. You just need to open that, click on

343
00:21:52,148 --> 00:21:56,130
that, you will be able to log in. If not you will see a multiple

344
00:21:56,550 --> 00:21:59,060
demo on Magic YouTube channel.

345
00:21:59,910 --> 00:22:04,194
So grab that, grab that did token which

346
00:22:04,232 --> 00:22:07,990
you get which has a lifespan of 8 hours. Copy this

347
00:22:08,140 --> 00:22:11,506
and try to access the protected route.

348
00:22:11,538 --> 00:22:15,080
Right. This is hosted on local host 9009.

349
00:22:15,450 --> 00:22:19,118
The other one is hosted on 9000 which is not protected.

350
00:22:19,154 --> 00:22:22,742
But let's see because we have added did token and verify

351
00:22:22,806 --> 00:22:26,298
functions in this go APIs. When you try to access

352
00:22:26,384 --> 00:22:30,346
normal one it's same like welcome to homepage. And when

353
00:22:30,368 --> 00:22:34,286
you try to access the protected route again it will

354
00:22:34,308 --> 00:22:37,770
have the same result like bearer token is required to access this route.

355
00:22:37,850 --> 00:22:41,838
So how do you access that? This is what I'm using. This is

356
00:22:41,844 --> 00:22:45,314
a postman. You can use insomnia and any other tool

357
00:22:45,432 --> 00:22:48,974
just to test and see, but usually you will do normal

358
00:22:49,022 --> 00:22:51,860
fetch from the front end of your applications.

359
00:22:52,550 --> 00:22:56,406
Or maybe you will use axios to access these kind of information

360
00:22:56,588 --> 00:23:00,374
and pass as an authorization header from

361
00:23:00,412 --> 00:23:04,502
there. So select

362
00:23:04,556 --> 00:23:07,750
the authorization here and from the drop down

363
00:23:07,820 --> 00:23:11,350
select the bearer token and pass on the did token

364
00:23:11,430 --> 00:23:15,100
which I have grabbed so I'm not going to use the previous one.

365
00:23:16,350 --> 00:23:20,394
Let's paste what I have copied from that application and try to

366
00:23:20,432 --> 00:23:24,334
access it. So when you try to access it it

367
00:23:24,372 --> 00:23:27,726
gives you bunch of information which is email.

368
00:23:27,908 --> 00:23:31,726
And when you decode that did token at the server side

369
00:23:31,828 --> 00:23:36,414
what we are calling is get users metadata

370
00:23:36,542 --> 00:23:39,774
and we are calling that function. We are getting the metadata

371
00:23:39,822 --> 00:23:43,426
which has its email issuer and public address. So it

372
00:23:43,448 --> 00:23:47,060
has these information apart from that because

373
00:23:48,090 --> 00:23:51,574
we have a protected page which has a message that you have

374
00:23:51,612 --> 00:23:55,382
access to c protected page. So let me show how it looks.

375
00:23:55,516 --> 00:23:59,270
This is what I'm referring. So this is the protected page

376
00:23:59,340 --> 00:24:03,038
part. And when you do the check bearer

377
00:24:03,074 --> 00:24:06,282
token and this is where we have

378
00:24:06,416 --> 00:24:09,926
used the user info and email issuer and

379
00:24:09,968 --> 00:24:13,322
public address to return that in the response,

380
00:24:13,386 --> 00:24:17,214
right? So that's really cool. And you

381
00:24:17,252 --> 00:24:20,894
have your application, your API protected by

382
00:24:21,012 --> 00:24:24,366
magic SDK and you are using the

383
00:24:24,388 --> 00:24:27,794
id token to fetch and access those of information.

384
00:24:27,992 --> 00:24:31,566
So what next and how do you get that? So visit

385
00:24:31,598 --> 00:24:34,734
magic link, try for free account by default,

386
00:24:34,782 --> 00:24:38,790
when you try to do it, there will be 10,000 free logins

387
00:24:39,290 --> 00:24:42,806
you will get. If you want more than that, there is a referral program going

388
00:24:42,828 --> 00:24:46,838
on. By doing that you can get more like 10,000

389
00:24:46,924 --> 00:24:50,246
plus 90,000 free logins if you share with your

390
00:24:50,268 --> 00:24:53,914
friends. Once you sign up, you will be able to create an application

391
00:24:54,032 --> 00:24:57,226
similar by going to this or maybe by default you will have

392
00:24:57,248 --> 00:25:01,420
your first application created, right? And then you can create your application

393
00:25:01,870 --> 00:25:05,054
and then you will have this publishable API key.

394
00:25:05,172 --> 00:25:09,486
Feel free to share this publishable API key which is not but

395
00:25:09,508 --> 00:25:13,130
not recommended, but you can share it, but no issue with that.

396
00:25:13,300 --> 00:25:16,386
One thing to note is that whichever combination you are

397
00:25:16,408 --> 00:25:20,174
using, the front end has this API.

398
00:25:20,302 --> 00:25:23,986
It should have the same secret key from the same application.

399
00:25:24,168 --> 00:25:27,478
Otherwise you will get multiple bunch of errors, right?

400
00:25:27,564 --> 00:25:31,478
And you can also enable multiple social logins if you want to have it.

401
00:25:31,644 --> 00:25:35,334
Right now it says just the email link you can create

402
00:25:35,452 --> 00:25:38,990
Google, GitHub, Facebook and so on, even discord.

403
00:25:39,090 --> 00:25:42,954
That's how you get the API key and the secret key and

404
00:25:42,992 --> 00:25:46,566
that's it. Right? So what next apart

405
00:25:46,598 --> 00:25:50,574
from this? I'm saying what next theyre you can do multiple things.

406
00:25:50,692 --> 00:25:54,970
You can build a full fledged rest API

407
00:25:55,130 --> 00:25:58,958
which has its cred application, everything around that.

408
00:25:59,044 --> 00:26:02,510
So theyre is a guide on magic website visit that.

409
00:26:02,580 --> 00:26:06,606
It's called securing a go back scrappy twitter API with magic

410
00:26:06,718 --> 00:26:10,962
and you'll be able to play around and see how it looks even

411
00:26:11,016 --> 00:26:14,546
run in Postman and see how a posting a

412
00:26:14,568 --> 00:26:18,150
tweet look, getting all information about the tweets. Get a single

413
00:26:18,220 --> 00:26:22,054
tweet and a bunch of information. And to get a did token and

414
00:26:22,092 --> 00:26:25,654
play with this particular demo, just visit this link

415
00:26:25,772 --> 00:26:28,970
and you'll be able to again similar application.

416
00:26:29,120 --> 00:26:32,618
You just need to sign in and you will get another did

417
00:26:32,704 --> 00:26:36,634
token like this, right? And I have also

418
00:26:36,832 --> 00:26:40,302
used this. This is what this crappy API looks

419
00:26:40,356 --> 00:26:43,854
like, which has the rest form of it API which

420
00:26:43,892 --> 00:26:47,582
has the crud application this is how you create

421
00:26:47,636 --> 00:26:50,986
an application. And before creating a tweet,

422
00:26:51,098 --> 00:26:54,478
let's see what we have in get all tweets.

423
00:26:54,574 --> 00:26:58,398
If you try to fetch this, you will see one tweet

424
00:26:58,494 --> 00:27:01,006
from Mary Chris, a colleague of mine,

425
00:27:01,118 --> 00:27:04,386
that this is our first default tweet. And if

426
00:27:04,408 --> 00:27:07,774
you want to create a tweet again, this is protected route,

427
00:27:07,822 --> 00:27:11,442
right? And if the body has like this is our second tweet.

428
00:27:11,506 --> 00:27:15,154
If we try to access it, it says that the did token

429
00:27:15,202 --> 00:27:18,454
is malformed because I think there is an authorization header

430
00:27:18,502 --> 00:27:22,234
or something is missing, right. So let's try and add that

431
00:27:22,352 --> 00:27:26,202
better token from the link what I have just

432
00:27:26,256 --> 00:27:29,914
copied. And you would need to sign in and

433
00:27:29,952 --> 00:27:33,658
do the same process. Try to access and have this.

434
00:27:33,744 --> 00:27:37,722
So it says that there is a success. We have, this is a second tweet.

435
00:27:37,786 --> 00:27:40,990
And as you can see, the author is my email Id,

436
00:27:41,060 --> 00:27:45,546
which is what I am logged into, right. I'm logged

437
00:27:45,578 --> 00:27:49,358
in with Shebaz at magic Link and it returns

438
00:27:49,454 --> 00:27:54,606
that thing. And you can also see and validate from fetching

439
00:27:54,718 --> 00:27:58,002
all the tweets. And similarly, if you for example,

440
00:27:58,136 --> 00:28:01,734
try to delete a tweet, for example, if you try to delete the

441
00:28:01,772 --> 00:28:05,398
tweet which is owned by Mary Chris in this case, and if you

442
00:28:05,404 --> 00:28:08,614
try to access this, it will say like something is

443
00:28:08,652 --> 00:28:12,726
malformed because it's missing. So let's try and again copy

444
00:28:12,758 --> 00:28:15,994
and paste the same did tokens try to access it. It says,

445
00:28:16,032 --> 00:28:19,786
oh, you cannot delete someone else's tweet because this

446
00:28:19,808 --> 00:28:23,526
tweet is created by makers and the second one is created

447
00:28:23,558 --> 00:28:27,434
by me. If I try to do this, it will delete my tweet.

448
00:28:27,482 --> 00:28:31,086
So there is multiple things you can see, get a single tweet and

449
00:28:31,108 --> 00:28:34,802
then save user info and multiple things you can learn

450
00:28:34,856 --> 00:28:38,386
about. So this is a good blog post if you want

451
00:28:38,408 --> 00:28:42,338
to build a restful API and secure those API using

452
00:28:42,424 --> 00:28:45,854
magic. So this is again a link which I'll

453
00:28:45,902 --> 00:28:49,714
share in the slides. I have used this particular section.

454
00:28:49,762 --> 00:28:54,114
Get started with magic. And if you want to do this, you alternatively

455
00:28:54,242 --> 00:28:58,774
need to either import similar to this or explicitly

456
00:28:58,822 --> 00:29:01,674
say go get pass on the GitHub magic link,

457
00:29:01,792 --> 00:29:05,626
magiclabs and then magic admin go. And this

458
00:29:05,648 --> 00:29:09,874
is how we created the instance. And we created a token instance.

459
00:29:10,022 --> 00:29:13,614
What we have used is get metadata by

460
00:29:13,652 --> 00:29:17,594
token which returns magic user info which has issuer,

461
00:29:17,642 --> 00:29:20,894
email and public address. Right. You can see

462
00:29:20,932 --> 00:29:23,966
the examples. It has similar examples similar to

463
00:29:23,988 --> 00:29:27,522
what I have used and you can use and learn more about it.

464
00:29:27,576 --> 00:29:31,214
So there are a bunch of resources, how you do that and how you validate,

465
00:29:31,262 --> 00:29:34,546
how to get the issuer public address and so on.

466
00:29:34,648 --> 00:29:38,502
If you want to do the front end side of it, we have used get

467
00:29:38,556 --> 00:29:41,686
metadata because you can use get metadata from the

468
00:29:41,708 --> 00:29:45,346
front end side of it. There are things called login with magic

469
00:29:45,378 --> 00:29:49,266
link which has multiple examples.

470
00:29:49,298 --> 00:29:52,586
It has auth modules, it has user modules to

471
00:29:52,608 --> 00:29:55,946
leaks anything around front end side. You would go to the

472
00:29:55,968 --> 00:29:59,402
magic docs and see the client SDK and if you want to work with

473
00:29:59,456 --> 00:30:02,954
admin SDK you will go to the admin SDK side of

474
00:30:02,992 --> 00:30:07,134
it. For example because we are working with Go, you will do that in go.

475
00:30:07,252 --> 00:30:10,910
So let's come back to the slides and see what we have done

476
00:30:11,060 --> 00:30:14,766
and recap what we did right. So we built in

477
00:30:14,788 --> 00:30:18,434
Go API and then we later on went on to secure that

478
00:30:18,472 --> 00:30:21,646
particular the basic routes and we also saw how a crud

479
00:30:21,678 --> 00:30:25,042
applications looks like how the restful API looks

480
00:30:25,096 --> 00:30:28,582
in Go API where you can learn more. But those things right

481
00:30:28,716 --> 00:30:32,486
to get started locally in seconds with magic you just need to

482
00:30:32,508 --> 00:30:35,960
run NPX make magic and select from that.

483
00:30:36,410 --> 00:30:40,618
Theyre is a bunch of templates to see at least

484
00:30:40,784 --> 00:30:44,058
right now it has more front end application but there is I

485
00:30:44,064 --> 00:30:47,574
think one server side application express

486
00:30:47,622 --> 00:30:51,034
APIs and go API. If you want go API to be

487
00:30:51,072 --> 00:30:54,746
here in NPX makemagic do let us know on our twitter

488
00:30:54,778 --> 00:30:58,330
handle or our community page. So we have used this template.

489
00:30:58,410 --> 00:31:01,262
This is how you define a template and get started very quickly.

490
00:31:01,316 --> 00:31:05,054
NPX make magic and pairs on the template with next but

491
00:31:05,092 --> 00:31:08,894
you feel free to explore other templates as well and share your feedback.

492
00:31:08,942 --> 00:31:12,146
If you have any questions do let me know on twitter handle this is my

493
00:31:12,168 --> 00:31:15,666
handle or tag magic labs and let

494
00:31:15,688 --> 00:31:18,962
us know that as well. So these are the resources

495
00:31:19,026 --> 00:31:22,626
about the talk. Like the front end of the application is hosted

496
00:31:22,658 --> 00:31:26,354
on GitHub under a repo called frontend Go API

497
00:31:26,482 --> 00:31:29,974
or Go server is magic Go API. You can see these

498
00:31:30,012 --> 00:31:33,626
things. I'll share the slide link with you as well

499
00:31:33,728 --> 00:31:36,822
so you can see and learn more about these resources.

500
00:31:36,886 --> 00:31:39,946
And there is magic Go admin SDK. If you want to learn more

501
00:31:39,968 --> 00:31:43,614
about decentralized identity specifically to

502
00:31:43,652 --> 00:31:47,374
magic, the first link would be the best place. But if you want to learn

503
00:31:47,412 --> 00:31:51,338
about what is did and learn more about the did proper

504
00:31:51,434 --> 00:31:55,262
what it is, you will go to w three c this

505
00:31:55,316 --> 00:31:58,466
page and then if you want to know what is a did token and what

506
00:31:58,488 --> 00:32:01,666
it does. And again bunch of things is on our docs visit our

507
00:32:01,688 --> 00:32:05,246
docs if you want to integrate to multiple applications and

508
00:32:05,288 --> 00:32:09,126
maybe use different front end visit our guides and see how

509
00:32:09,148 --> 00:32:11,480
that is happening. We have a community page.

510
00:32:12,810 --> 00:32:16,050
You are always welcome to join us the authentication

511
00:32:16,210 --> 00:32:19,994
community where we share and learn from each other. So join that

512
00:32:20,032 --> 00:32:23,434
community and share your experience and what you are building with

513
00:32:23,472 --> 00:32:28,218
magic. So I think that's it. If you have anything specific

514
00:32:28,304 --> 00:32:31,606
to me, these are the links you can connect with me or

515
00:32:31,648 --> 00:32:35,290
simply as if you have a terminal and if you have node installed

516
00:32:35,370 --> 00:32:39,390
just run npx mdxvz alam my username and

517
00:32:39,460 --> 00:32:43,822
you will see similar options like this and you will be able to follow me

518
00:32:43,956 --> 00:32:48,270
across social media. So again, once again thank you

519
00:32:48,420 --> 00:32:51,630
conf 42 golang for having me.

520
00:32:51,700 --> 00:32:56,578
So if you have any questions related to go APIs, magic authentication,

521
00:32:56,674 --> 00:33:00,390
serverless, passwordless, anything around authentication,

522
00:33:01,130 --> 00:33:04,406
you can reach out to magic labs or me. I would be

523
00:33:04,428 --> 00:33:08,182
happy to help and answer your queries. So once again

524
00:33:08,236 --> 00:33:11,734
thank you for having me and enjoy the rest

525
00:33:11,772 --> 00:33:12,370
of the conference.

