1
00:00:00,410 --> 00:00:06,174
Jamaica real

2
00:00:06,212 --> 00:00:09,934
time feedback into the behavior of your distributed systems and

3
00:00:09,972 --> 00:00:14,094
observing changes exceptions errors in real time

4
00:00:14,212 --> 00:00:17,914
allows you to not only experiment with confidence, but respond

5
00:00:18,042 --> 00:00:20,480
instantly to get things working again.

6
00:00:24,610 --> 00:00:47,850
Those you hello,

7
00:00:48,000 --> 00:00:51,774
thank you for joining my session. Today we will talk

8
00:00:51,812 --> 00:00:56,046
about machine learning and we will share with you the different strategies on

9
00:00:56,068 --> 00:00:59,806
how to build machine learning mlpowered applications with

10
00:00:59,908 --> 00:01:03,774
JavaScript. So before I start with these

11
00:01:03,812 --> 00:01:06,926
talk, let me quickly introduce myself. I am

12
00:01:06,948 --> 00:01:10,766
Joshua Arvin Lat. People call me arVs. So arVs,

13
00:01:10,798 --> 00:01:14,574
arVs. So from Arvin. So the shortcut

14
00:01:14,622 --> 00:01:18,338
is arBs. I am the chief technology officer

15
00:01:18,434 --> 00:01:22,434
of Newworks Interactive Labs and I'm also an AWS

16
00:01:22,482 --> 00:01:25,638
machine learning hero. So there are maybe

17
00:01:25,804 --> 00:01:29,274
20 to 30 something machine learning heroes all around

18
00:01:29,312 --> 00:01:32,986
the world, and we save the day one day at

19
00:01:33,008 --> 00:01:36,714
a time by sharing our knowledge in

20
00:01:36,752 --> 00:01:40,366
our domain expertise. I'm also the

21
00:01:40,388 --> 00:01:43,978
author of the books Machine Learning with Amazon Sagemaker

22
00:01:43,994 --> 00:01:47,950
Cookbook and machine learning Engineering on AWS.

23
00:01:48,290 --> 00:01:51,886
So if you are interested in learning more about machine learning

24
00:01:52,068 --> 00:01:55,374
experimentation and deployments in the cloud,

25
00:01:55,572 --> 00:01:59,138
then this book may be for you. So let's start by

26
00:01:59,224 --> 00:02:02,434
talking about how machine learning works and what

27
00:02:02,472 --> 00:02:06,610
its applications are. So machine learning is very powerful.

28
00:02:07,030 --> 00:02:10,354
So if we were to solve anomaly detection

29
00:02:10,402 --> 00:02:13,922
problems, if we were to work on product recommendation

30
00:02:14,066 --> 00:02:17,618
requirements and so on, then we may be able to

31
00:02:17,644 --> 00:02:21,226
utilize machine learning by using algorithms and

32
00:02:21,248 --> 00:02:23,770
data to solve our requirements.

33
00:02:24,590 --> 00:02:27,754
So if you are not yet familiar on how machine learning works,

34
00:02:27,872 --> 00:02:31,642
basically what it does is it helps us perform automated

35
00:02:31,706 --> 00:02:35,274
tasks which are usually performed by intelligent

36
00:02:35,322 --> 00:02:39,178
beings like humans. So for example, we have an image

37
00:02:39,194 --> 00:02:43,534
of a cat here. If this were to be processed

38
00:02:43,582 --> 00:02:47,314
by a human, a human would easily be able to

39
00:02:47,352 --> 00:02:50,722
identify if this image is a cat or

40
00:02:50,776 --> 00:02:54,274
not a cat. However, if this were

41
00:02:54,312 --> 00:02:58,502
to be processed by a machine, this may be somewhat hard

42
00:02:58,556 --> 00:03:02,470
to do, especially if you're going to hard code and

43
00:03:02,540 --> 00:03:05,606
you're not going to utilize data to process this,

44
00:03:05,708 --> 00:03:09,154
especially if there are an infinite

45
00:03:09,202 --> 00:03:13,134
number of possible variations for the cat images.

46
00:03:13,202 --> 00:03:16,586
For example, for this one, if you hard code the

47
00:03:16,608 --> 00:03:20,422
implementation of classification for the first image,

48
00:03:20,566 --> 00:03:23,850
how would you be able to process the following images?

49
00:03:25,010 --> 00:03:28,474
One of the possible solutions in order for us to properly

50
00:03:28,522 --> 00:03:32,158
classify if an image is a cat or not a cat is to

51
00:03:32,164 --> 00:03:35,582
utilize machine learning. So there are different strategies,

52
00:03:35,646 --> 00:03:38,418
there are different algorithms available in machine learning,

53
00:03:38,584 --> 00:03:42,546
but in order to solve this type of requirements, we may

54
00:03:42,568 --> 00:03:46,360
be able CTO use, let's say something like this, the machine learning process.

55
00:03:46,970 --> 00:03:50,040
The machine learning process involves utilizing data

56
00:03:50,490 --> 00:03:54,438
to build and train a machine learning model,

57
00:03:54,604 --> 00:03:58,598
which can be used to perform inference or predictions

58
00:03:58,774 --> 00:04:02,202
on new data. So getting

59
00:04:02,256 --> 00:04:04,860
back CTO the cat example,

60
00:04:05,550 --> 00:04:09,690
let's say that we have 100,000 images of cats.

61
00:04:10,110 --> 00:04:13,886
We use those 100,000 images to train a

62
00:04:13,908 --> 00:04:17,566
machine learning model and then that model will

63
00:04:17,588 --> 00:04:21,226
be evaluated and the performance would be checked.

64
00:04:21,258 --> 00:04:24,666
So let's say that it has 90% score.

65
00:04:24,858 --> 00:04:28,690
This would mean that maybe nine out of ten times it would get the answer

66
00:04:28,760 --> 00:04:31,940
correctly. So if you're happy with that model,

67
00:04:32,470 --> 00:04:36,098
then you would be able to deployed it. And then if you,

68
00:04:36,104 --> 00:04:40,200
let's say, have a mobile application, you took a picture of a cat.

69
00:04:41,290 --> 00:04:44,840
If you cases that image to that machine learning model,

70
00:04:45,210 --> 00:04:48,598
then that machine learning model would then give you either a one or a

71
00:04:48,604 --> 00:04:52,234
zero. Maybe zero would be cat and then one would be

72
00:04:52,272 --> 00:04:56,134
not cat. So it depends on how you implemented the inference

73
00:04:56,182 --> 00:04:59,180
part, but more or less that's how it works.

74
00:04:59,790 --> 00:05:03,546
One point that you should know is that this is a simplified

75
00:05:03,738 --> 00:05:07,054
version of the machine learning process. In real life.

76
00:05:07,252 --> 00:05:10,526
The machine learning process is circular and there are a lot of

77
00:05:10,548 --> 00:05:13,598
things we need to take into account, like model training.

78
00:05:13,764 --> 00:05:17,634
We need to make sure that we are able to

79
00:05:17,832 --> 00:05:21,026
refresh the model as well. Because once you have deployed the

80
00:05:21,048 --> 00:05:24,962
model after two weeks to one month, there might be

81
00:05:25,096 --> 00:05:29,154
a chance that your model has degraded already and you need to replace

82
00:05:29,202 --> 00:05:32,806
or refresh it. Now that we have a better idea

83
00:05:32,908 --> 00:05:36,662
on how machine learning works, we can now try

84
00:05:36,716 --> 00:05:40,346
to answer this question, why use

85
00:05:40,448 --> 00:05:44,362
JavaScript for machine learning? For those

86
00:05:44,416 --> 00:05:47,594
data scientists and machine learning practitioners listening to this

87
00:05:47,632 --> 00:05:51,166
talk, maybe you would also ask the

88
00:05:51,188 --> 00:05:55,370
same question, especially if you've used already something like Python

89
00:05:55,530 --> 00:05:59,230
to solve different machine learning experiments and requirements.

90
00:05:59,730 --> 00:06:03,170
So there are different advantages when using machine learning.

91
00:06:03,240 --> 00:06:06,498
But before we go straight into that one, let's answer

92
00:06:06,584 --> 00:06:10,738
this question first. The question that we need to answer

93
00:06:10,904 --> 00:06:14,802
is can we build a machine learning

94
00:06:14,856 --> 00:06:18,886
powered application using JavaScript? Is it

95
00:06:18,908 --> 00:06:22,054
a yes or is it a no? So the correct answer

96
00:06:22,092 --> 00:06:26,306
to this one is it's a yes. So we can build a machine learning mlpowered

97
00:06:26,338 --> 00:06:29,866
application using JavaScript because there are different

98
00:06:30,048 --> 00:06:33,354
libraries and tools available to support these

99
00:06:33,392 --> 00:06:36,634
types of application. So even if there

100
00:06:36,672 --> 00:06:40,554
are different tools and libraries

101
00:06:40,602 --> 00:06:44,202
available for other languages, and even if some languages,

102
00:06:44,266 --> 00:06:47,898
let's say Python and even r, have been customized

103
00:06:47,994 --> 00:06:51,982
more for machine learning, why should we consider using

104
00:06:52,036 --> 00:06:56,050
JavaScript for machine learning in certain use cases?

105
00:06:56,390 --> 00:07:00,606
So there are some scenarios where it might make sense to use JavaScript

106
00:07:00,638 --> 00:07:04,114
for machine learning, especially for a team which

107
00:07:04,152 --> 00:07:07,766
is already using JavaScript heavily. So let's say that you have a

108
00:07:07,788 --> 00:07:11,702
team of, let's say five developers, and they've been using

109
00:07:11,756 --> 00:07:15,238
JavaScript heavily for all of the projects. For a

110
00:07:15,244 --> 00:07:19,282
certain company, if they were to learn a new language, let's say Python,

111
00:07:19,426 --> 00:07:22,586
it might take them a while. And maybe the tools and

112
00:07:22,608 --> 00:07:26,694
the pipelines that the team has already is focusing more on the JavaScript

113
00:07:26,742 --> 00:07:30,102
side of things. So in order for a team to

114
00:07:30,176 --> 00:07:34,142
have to spend less time learning a new language and

115
00:07:34,276 --> 00:07:37,994
focusing on the implementation part using the same language,

116
00:07:38,042 --> 00:07:41,870
which is JavaScript, then types, if they were to implement

117
00:07:42,370 --> 00:07:46,610
and do some machine learning stuff, then they can do it with JavaScript.

118
00:07:47,110 --> 00:07:50,834
The second possible reason why people should

119
00:07:50,872 --> 00:07:54,638
use JavaScript for machine learning is that they can also perform

120
00:07:54,824 --> 00:07:57,986
machine learning references on the browser.

121
00:07:58,178 --> 00:08:01,446
So that's pretty cool because the browser, you can do

122
00:08:01,468 --> 00:08:05,634
some JavaScript stuff there, and instead of the inference

123
00:08:05,682 --> 00:08:09,258
call being made from the browser or the web app

124
00:08:09,344 --> 00:08:12,746
front end to the back end server, it will

125
00:08:12,768 --> 00:08:16,618
all happen in the browser. So we will dive deeper into that

126
00:08:16,784 --> 00:08:20,730
later. And here, as mentioned earlier,

127
00:08:21,390 --> 00:08:25,502
we can avoid the need to learn a new language, because for

128
00:08:25,556 --> 00:08:29,066
this one, maybe you are a front end developer and you're

129
00:08:29,098 --> 00:08:33,226
just starting out and you need to implement and utilize

130
00:08:33,258 --> 00:08:36,402
a machine learning model, then yes, you can

131
00:08:36,456 --> 00:08:39,506
do that using JavaScript. So you may be

132
00:08:39,528 --> 00:08:42,398
able to perform inference in the browser,

133
00:08:42,494 --> 00:08:45,826
and you may also be able to use JavaScript on

134
00:08:45,848 --> 00:08:49,606
the server side. And even if a lot of

135
00:08:49,788 --> 00:08:53,270
tools have already been prepared for, let's say, python,

136
00:08:53,610 --> 00:08:57,842
there are also corresponding set of tools in JavaScript which we will see later.

137
00:08:57,996 --> 00:09:01,914
So let's now dive a bit deeper into why and

138
00:09:01,952 --> 00:09:05,302
how we can perform machine learning experiments and deployed

139
00:09:05,366 --> 00:09:08,010
in the browser using JavaScript.

140
00:09:08,670 --> 00:09:12,570
On the left side we can see a simplified

141
00:09:12,650 --> 00:09:15,518
diagram on how server side inference work.

142
00:09:15,604 --> 00:09:19,146
So what do we mean by inference? When you have a machine

143
00:09:19,178 --> 00:09:23,070
learning model ready, you want to perform predictions,

144
00:09:24,790 --> 00:09:27,502
you want to use that model to perform inference,

145
00:09:27,566 --> 00:09:31,010
meaning you want to perform an intelligent

146
00:09:31,350 --> 00:09:33,950
decision or task.

147
00:09:34,110 --> 00:09:38,054
So in this case, let's say that the problem we're trying to solve is

148
00:09:38,092 --> 00:09:41,394
the identification or classification if the image

149
00:09:41,442 --> 00:09:44,662
is a cat or not a cat. So if you have an

150
00:09:44,716 --> 00:09:48,570
image in the browser, you will need to send

151
00:09:48,720 --> 00:09:52,410
that image to the services through a request.

152
00:09:53,550 --> 00:09:56,726
So that request, which includes the image, will be processed

153
00:09:56,758 --> 00:10:00,894
by the server and the server which has the model.

154
00:10:01,092 --> 00:10:04,890
The model would then be used to process the image

155
00:10:04,970 --> 00:10:08,654
and the output would be either one

156
00:10:08,692 --> 00:10:12,270
or zero. So 1 may represent, let's say not cat

157
00:10:12,340 --> 00:10:14,580
and these zero would represent cat.

158
00:10:15,030 --> 00:10:18,126
So the value, the output value would be returned

159
00:10:18,158 --> 00:10:21,998
back to the browser and then you can basically update

160
00:10:22,094 --> 00:10:25,382
the user interface using

161
00:10:25,436 --> 00:10:28,950
your favorite JavaScript library and you can display these

162
00:10:29,020 --> 00:10:31,910
cat. So if you upload an image of a dog,

163
00:10:32,060 --> 00:10:34,790
then the server would then respond,

164
00:10:35,530 --> 00:10:38,946
not cat. So that's basically how server

165
00:10:38,978 --> 00:10:42,890
side inference work. There's a server behind the scenes.

166
00:10:43,710 --> 00:10:48,506
On the right side we can see the alternative these

167
00:10:48,608 --> 00:10:52,250
we can perform references in the browser directly.

168
00:10:52,410 --> 00:10:55,600
So how would that work? When you load the page,

169
00:10:56,370 --> 00:10:59,614
the model would be loaded as well on

170
00:10:59,652 --> 00:11:03,042
the front end side and here in the second

171
00:11:03,096 --> 00:11:05,700
scenario, no servers are needed,

172
00:11:06,550 --> 00:11:09,380
at least on the processing side.

173
00:11:09,910 --> 00:11:13,342
So when the front end code receives

174
00:11:13,406 --> 00:11:17,250
some sort of event, instead of pushing

175
00:11:17,330 --> 00:11:20,642
the data to a request to a back end server,

176
00:11:20,786 --> 00:11:24,280
the inference will happen in the browser itself

177
00:11:24,970 --> 00:11:28,474
on the client side. So there are advantages CTO

178
00:11:28,512 --> 00:11:31,942
this because for example, if these are network

179
00:11:32,006 --> 00:11:36,374
issues, then the second scenario wouldn't be affected

180
00:11:36,422 --> 00:11:39,974
because it works offline. And if you don't

181
00:11:40,022 --> 00:11:43,806
want your users to pass their data to the

182
00:11:43,828 --> 00:11:47,418
server, then yes, you can do this as well because it helps

183
00:11:47,434 --> 00:11:51,342
with data privacy. So yes, so these are the advantages of

184
00:11:51,396 --> 00:11:55,090
performing machine learning references on the browser. So as mentioned,

185
00:11:55,160 --> 00:11:58,338
you can work offline. So let's say that after loading these page,

186
00:11:58,504 --> 00:12:01,874
you decided CTO disconnect your

187
00:12:01,912 --> 00:12:05,718
Internet connection. Your application

188
00:12:05,884 --> 00:12:09,954
will still be interactive and it will work just fine. So that's

189
00:12:10,002 --> 00:12:13,394
super helpful, especially if you have Internet connection

190
00:12:13,442 --> 00:12:17,910
problems or there's very limited or very slow

191
00:12:18,270 --> 00:12:22,470
Internet connectivity, which of course would affect latency.

192
00:12:22,630 --> 00:12:26,582
So here there's better latency, better performance from a network standpoint

193
00:12:26,726 --> 00:12:30,334
and there no servers are needed. So in some

194
00:12:30,372 --> 00:12:34,080
cases there are cases where you might need to

195
00:12:34,450 --> 00:12:38,234
have a server, but there may be cases, especially for smaller

196
00:12:38,282 --> 00:12:41,806
models where you can deploy it in

197
00:12:41,828 --> 00:12:45,474
the browser. And it also helps with data privacy because

198
00:12:45,672 --> 00:12:49,074
your customers or users data do

199
00:12:49,112 --> 00:12:53,294
not need CTO be sent to the server, to a centralized server

200
00:12:53,342 --> 00:12:57,658
which can be analyzed

201
00:12:57,694 --> 00:13:00,338
and processed by the team who built that server.

202
00:13:00,514 --> 00:13:04,006
So of course these are the advantages. So what may be

203
00:13:04,028 --> 00:13:07,442
some disadvantages to this one? So once you load that

204
00:13:07,516 --> 00:13:11,290
model in the browser, in terms of model

205
00:13:11,360 --> 00:13:14,666
security, that model can already be used

206
00:13:14,768 --> 00:13:18,006
or at least downloaded from these browser.

207
00:13:18,118 --> 00:13:20,942
So that's just the only thing you need to worry about.

208
00:13:20,996 --> 00:13:24,414
However, if you're not worried about model security, then this

209
00:13:24,452 --> 00:13:27,790
may be the solution for you. But again, these are amazing

210
00:13:27,860 --> 00:13:31,550
advantages. And browsers of course support javascript.

211
00:13:32,050 --> 00:13:35,746
Now that we know that we can do some machine learning stuff in the

212
00:13:35,768 --> 00:13:38,994
browser, would this mean that we would

213
00:13:39,032 --> 00:13:42,306
be able CTO use a machine learning library in

214
00:13:42,328 --> 00:13:46,450
JavaScript along with your favorite JavaScript

215
00:13:46,530 --> 00:13:50,070
front end, framework or library? The answer

216
00:13:50,140 --> 00:13:54,246
there is yes. So that's good news for us, because if

217
00:13:54,268 --> 00:13:57,458
you are already using libraries or

218
00:13:57,484 --> 00:14:00,570
frameworks like ReAPP, view and angular or other

219
00:14:00,640 --> 00:14:03,478
new frameworks and libraries,

220
00:14:03,654 --> 00:14:06,730
then it's all about doing some

221
00:14:06,800 --> 00:14:10,394
coding work to use your machine learning library and your

222
00:14:10,432 --> 00:14:13,850
model with it. So in some cases

223
00:14:13,930 --> 00:14:17,038
you will be able to train your machine learning model in

224
00:14:17,044 --> 00:14:20,478
the browser directly and in some cases as well,

225
00:14:20,564 --> 00:14:24,022
you'll be able to perform references in the browser

226
00:14:24,106 --> 00:14:27,362
also. So it really depends on your requirements. In most

227
00:14:27,416 --> 00:14:31,122
cases you may just need to focus on the inference part and

228
00:14:31,176 --> 00:14:35,206
do the training part in the server. So what

229
00:14:35,228 --> 00:14:38,594
are examples of libraries

230
00:14:38,642 --> 00:14:41,794
which can be used to perform machine learning experiments

231
00:14:41,842 --> 00:14:45,618
and inference deployments in the browser,

232
00:14:45,794 --> 00:14:49,146
the browser, the website front end. So here are

233
00:14:49,168 --> 00:14:53,078
some examples like Tensorflow, JS, even onx

234
00:14:53,174 --> 00:14:56,874
runtime for web. So those can be used. And this can

235
00:14:56,912 --> 00:15:00,646
easily be used with existing libraries and frameworks because they're

236
00:15:00,678 --> 00:15:04,446
basically just code. And these frameworks and libraries just help

237
00:15:04,628 --> 00:15:08,218
with processing the data and the different elements

238
00:15:08,314 --> 00:15:11,934
in your web application to make it more interactive and

239
00:15:11,972 --> 00:15:16,002
to help you manage the front end code better. So how about

240
00:15:16,056 --> 00:15:19,854
state management? So if you're not yet familiar

241
00:15:19,902 --> 00:15:22,914
with how state management works, feel free to

242
00:15:22,952 --> 00:15:26,502
watch my presentation from last year

243
00:15:26,636 --> 00:15:30,658
where I talked about how to do pragmatic state management in react,

244
00:15:30,754 --> 00:15:33,894
angular and ujs. So feel free to use

245
00:15:33,932 --> 00:15:39,146
the QR code here or just search in YouTube in

246
00:15:39,168 --> 00:15:42,826
order to watch this video. But you'll definitely learn a lot because

247
00:15:42,928 --> 00:15:46,646
state management is a topic

248
00:15:46,678 --> 00:15:50,418
on its own and it's better if we watch it separately.

249
00:15:50,534 --> 00:15:54,174
But again, if you have a data intensive application

250
00:15:54,372 --> 00:15:57,998
and you want to manage the machine learning stuff

251
00:15:58,084 --> 00:16:02,422
in the browser and do some interactions

252
00:16:02,506 --> 00:16:05,650
and make your applications interactive, these yes,

253
00:16:05,800 --> 00:16:09,582
you may need to learn about state management,

254
00:16:09,726 --> 00:16:12,580
especially when you're doing heavy Javascript work.

255
00:16:13,030 --> 00:16:16,978
All right, now that we have talked about web apps

256
00:16:16,994 --> 00:16:20,530
a bit, let's now talk about mobile apps.

257
00:16:20,690 --> 00:16:24,198
Wow. So we all thought that having

258
00:16:24,284 --> 00:16:27,240
machine learning models deployed in the browser is amazing.

259
00:16:27,710 --> 00:16:31,930
You should know that we can also deploy mobile apps,

260
00:16:32,430 --> 00:16:36,410
deploy machine learning models in the mobile apps

261
00:16:36,750 --> 00:16:39,820
itself. So how would that work?

262
00:16:40,670 --> 00:16:44,426
The more standard or the more common ways to perform machine

263
00:16:44,458 --> 00:16:48,126
learning deployments and even training is to perform all

264
00:16:48,148 --> 00:16:51,246
of these inside servers. So if you

265
00:16:51,268 --> 00:16:54,722
have a mobile application and you have data, these in order for

266
00:16:54,776 --> 00:16:57,906
training to happen, at least in the first scenario, we need

267
00:16:57,928 --> 00:17:02,558
to pass the data to the centralized

268
00:17:02,654 --> 00:17:06,226
system or server. These model gets trained

269
00:17:06,258 --> 00:17:08,920
there and the model will be used.

270
00:17:09,690 --> 00:17:12,242
Similar to an example earlier,

271
00:17:12,306 --> 00:17:15,654
where there's the client, the front end which can be web

272
00:17:15,692 --> 00:17:18,954
or mobile, and then there's the request and

273
00:17:18,992 --> 00:17:22,346
the server would be processing it because the model is in

274
00:17:22,368 --> 00:17:25,946
the services. However, there is a

275
00:17:25,968 --> 00:17:29,386
second option, an alternative where as you

276
00:17:29,408 --> 00:17:32,782
can see on the right side, similar to how

277
00:17:32,836 --> 00:17:36,570
we deploy nodejs in the browser or the client

278
00:17:36,650 --> 00:17:40,906
front end, we can also perform on device machine

279
00:17:40,938 --> 00:17:44,130
learning. This means that the data

280
00:17:44,200 --> 00:17:48,062
of the user which will be used during inference

281
00:17:48,206 --> 00:17:51,490
no longer needs to be sent to a server.

282
00:17:52,150 --> 00:17:55,670
So what happens here is that all the magic is happening inside

283
00:17:55,740 --> 00:17:59,906
the mobile app. So yes, so if the mobile

284
00:18:00,098 --> 00:18:03,958
app contains the model already, then yes, this is possible.

285
00:18:04,124 --> 00:18:08,290
And in terms of advantages, the advantages are the same.

286
00:18:08,460 --> 00:18:11,766
So it helps with data privacy, it works offline,

287
00:18:11,958 --> 00:18:15,706
no servers are needed, and it's faster. So why is

288
00:18:15,728 --> 00:18:19,526
it faster? It's faster because there's no more round trip

289
00:18:19,638 --> 00:18:22,222
from the mobile app to the server and back,

290
00:18:22,356 --> 00:18:25,934
especially when you need to perform inference, it can

291
00:18:25,972 --> 00:18:30,142
all happen in real time. So this is an example of

292
00:18:30,276 --> 00:18:33,874
how you can perform and do and use

293
00:18:33,912 --> 00:18:37,460
machine learning nodejs in your mobile app.

294
00:18:37,830 --> 00:18:41,394
So if you have, let's say something like react native and use

295
00:18:41,432 --> 00:18:44,500
Tensorflow JS, then you can do something like this.

296
00:18:45,450 --> 00:18:48,870
Now let's talk about machine learning in the cloud using

297
00:18:48,940 --> 00:18:52,280
JavaScript. So why use the cloud?

298
00:18:52,810 --> 00:18:55,826
So when using and utilizing

299
00:18:55,858 --> 00:18:59,366
the different cloud capabilities and resources, one of

300
00:18:59,388 --> 00:19:02,554
the advantages when you're using the cloud is that you have full

301
00:19:02,592 --> 00:19:06,294
control over the type and the size of resources

302
00:19:06,342 --> 00:19:10,226
that you're going to use to perform the needed operation.

303
00:19:10,358 --> 00:19:13,822
So in this case, machine learning training

304
00:19:13,956 --> 00:19:17,934
and deployment usually when

305
00:19:17,972 --> 00:19:21,774
you need to work on more complex machine learning models, there will

306
00:19:21,812 --> 00:19:25,614
be a big chance, especially for certain types

307
00:19:25,662 --> 00:19:29,522
of requirements where you will need to deal with bigger data

308
00:19:29,576 --> 00:19:33,250
sets and bigger models. So here

309
00:19:33,320 --> 00:19:36,260
we can see that if we need a stronger computer,

310
00:19:36,730 --> 00:19:40,514
which is significantly bigger and faster and stronger

311
00:19:40,562 --> 00:19:43,942
than what we have in our local machine, then types

312
00:19:43,996 --> 00:19:47,706
we can utilize the cloud for it. Let's say that we have a

313
00:19:47,728 --> 00:19:51,420
1gb data set and it needs to be processed by

314
00:19:51,790 --> 00:19:54,922
a server. The training job and

315
00:19:54,976 --> 00:19:58,026
script running inside that server would be

316
00:19:58,048 --> 00:20:01,758
able to do it properly. However, if you were to process

317
00:20:01,844 --> 00:20:05,614
that large data set and use an

318
00:20:05,652 --> 00:20:09,530
algorithm which is kind of resource intensive,

319
00:20:09,690 --> 00:20:13,666
resource hungry, then a smaller machine would struggle with

320
00:20:13,688 --> 00:20:17,006
it. That's why we can utilize the cloud for these types

321
00:20:17,038 --> 00:20:20,226
of requirements. In addition to

322
00:20:20,248 --> 00:20:24,078
that, if we were to perform automated

323
00:20:24,254 --> 00:20:29,138
hyperparameter optimization HPO,

324
00:20:29,314 --> 00:20:32,454
we can utilize multiple cloud servers all

325
00:20:32,492 --> 00:20:36,214
at the same time to do what we need to do. So in this

326
00:20:36,252 --> 00:20:39,674
case we will perform machine learning experiments and we will

327
00:20:39,712 --> 00:20:42,938
build a model. So in most of

328
00:20:42,944 --> 00:20:46,566
the examples that we know and most of the basic examples

329
00:20:46,598 --> 00:20:50,574
that we've tried and we're aware of, we usually deal

330
00:20:50,612 --> 00:20:54,234
with one machine learning experiment. So one machine learning experiment

331
00:20:54,282 --> 00:20:57,374
may produce one model. However,

332
00:20:57,492 --> 00:21:01,658
in real life we would need to produce multiple models.

333
00:21:01,754 --> 00:21:05,794
We would do a lot of iterations in order to get the

334
00:21:05,832 --> 00:21:09,282
best model possible. So instead of us trying to wait

335
00:21:09,336 --> 00:21:11,860
for, let's say one r for one model,

336
00:21:12,310 --> 00:21:16,370
and if we have 100 tries, 100 different configurations

337
00:21:16,790 --> 00:21:20,246
for different types of training jobs, we would

338
00:21:20,268 --> 00:21:23,606
have to wait a really long time, let's say 100 hours, if we

339
00:21:23,628 --> 00:21:27,786
were to do it one at a time. However, we can do this in

340
00:21:27,808 --> 00:21:31,274
parallel, meaning that if we need

341
00:21:31,312 --> 00:21:34,442
to produce 100 machine learning models and get the best

342
00:21:34,496 --> 00:21:38,806
model from the results of the experiments,

343
00:21:38,918 --> 00:21:44,462
we can do that all at the same time. So machine learning experiment 12345,

344
00:21:44,596 --> 00:21:48,446
all happening at the same time, and you would be able to complete everything in

345
00:21:48,468 --> 00:21:51,920
maybe one to 1.5 hours. So these is amazing.

346
00:21:52,290 --> 00:21:55,266
And these is one of the advantages of using the cloud,

347
00:21:55,448 --> 00:21:59,074
because you're able to spin up and delete resources as

348
00:21:59,112 --> 00:22:04,402
needed. In addition to that, there are a lot of services

349
00:22:04,536 --> 00:22:07,974
and platforms available to help us manage cloud

350
00:22:08,012 --> 00:22:11,458
resources better while performing machine learning experiments

351
00:22:11,474 --> 00:22:14,706
and deployed. So there's something called Sagemaker,

352
00:22:14,738 --> 00:22:18,694
I even wrote a book about it. Right? So Sagemaker is a mature

353
00:22:18,822 --> 00:22:22,186
machine learning platform and

354
00:22:22,208 --> 00:22:25,530
it's a service of AWS. So if you've been using AWS,

355
00:22:25,870 --> 00:22:29,018
then this is something that you can easily use because you have an

356
00:22:29,024 --> 00:22:32,406
account. There are of course alternatives in other cloud providers,

357
00:22:32,438 --> 00:22:36,398
let's say GCP and Azure. So feel free to take a look at it,

358
00:22:36,484 --> 00:22:40,254
especially if your team is already using that cloud platform.

359
00:22:40,452 --> 00:22:43,762
But what I would like to share these is that there

360
00:22:43,816 --> 00:22:47,346
is of course an SDK available

361
00:22:47,448 --> 00:22:51,106
for JavaScript. So you have an API. So the service has

362
00:22:51,128 --> 00:22:53,998
an API. If you need to talk to the API,

363
00:22:54,094 --> 00:22:57,762
maybe perform a machine learning experiment using this algorithm,

364
00:22:57,906 --> 00:23:01,366
you can do that with Python. So a lot of people

365
00:23:01,468 --> 00:23:05,174
know that Python can be used to work with

366
00:23:05,212 --> 00:23:08,794
this service. However, if you do a bit more research, you will

367
00:23:08,832 --> 00:23:13,114
realize that different sdks have been made available in

368
00:23:13,152 --> 00:23:16,762
different languages, and JavaScript is one of them.

369
00:23:16,896 --> 00:23:21,006
So the capabilities available in Python is of course available in

370
00:23:21,028 --> 00:23:24,814
JavaScript, because most of the magic has

371
00:23:24,852 --> 00:23:28,430
been implemented already inside the service itself.

372
00:23:28,580 --> 00:23:32,218
All we need to do is call the right API

373
00:23:32,314 --> 00:23:35,682
call and we'll be able to

374
00:23:35,736 --> 00:23:38,770
have the much needed capability or functionality.

375
00:23:39,750 --> 00:23:43,166
So this is one good example. So let's say that you have a machine

376
00:23:43,198 --> 00:23:47,062
learning model trained and we need to deploy it

377
00:23:47,196 --> 00:23:50,386
instead of us trying to build our references

378
00:23:50,418 --> 00:23:54,630
server from scratch. Let's say something using expressjs and

379
00:23:54,700 --> 00:23:57,910
all the needed libraries to read the model

380
00:23:57,980 --> 00:24:02,294
and use it for inference. Maybe we can do that faster.

381
00:24:02,422 --> 00:24:06,026
Maybe we can have a real time endpoint, or maybe we can have

382
00:24:06,048 --> 00:24:10,550
a serverless endpoint or use other types of inference solutions

383
00:24:10,710 --> 00:24:14,574
by just having these right configuration. Maybe we would need just maybe

384
00:24:14,612 --> 00:24:18,046
five lines to six lines of code just to do all of this.

385
00:24:18,148 --> 00:24:21,694
And this is easily doable in maybe 30 minutes to 1 hour,

386
00:24:21,812 --> 00:24:26,046
especially when you have the code snippets ready to perform machine

387
00:24:26,078 --> 00:24:29,602
learning deployment. So again, if we were to compare this

388
00:24:29,656 --> 00:24:33,506
with building your own inference server, building it yourself

389
00:24:33,608 --> 00:24:36,146
may take three days to five days.

390
00:24:36,328 --> 00:24:39,160
However, if you were to use a mature platform,

391
00:24:40,090 --> 00:24:44,054
then with 30 minutes to 1 hour you will be able to have something which

392
00:24:44,092 --> 00:24:47,442
you can present to your boss already for approval. So those

393
00:24:47,516 --> 00:24:51,286
are some of the things that you should know, because choosing

394
00:24:51,318 --> 00:24:54,970
the right solution starts first by knowing what's possible.

395
00:24:55,120 --> 00:24:59,340
Then you can select later on when to use what.

396
00:25:00,290 --> 00:25:03,390
Take note that some services also

397
00:25:03,460 --> 00:25:07,440
allow us to utilize docker containers. And even without

398
00:25:07,890 --> 00:25:11,754
the container image support, we can already use JavaScript

399
00:25:11,882 --> 00:25:15,438
inside a lambda function. So lambda,

400
00:25:15,534 --> 00:25:19,250
which is a function as a services, allows us

401
00:25:19,320 --> 00:25:22,500
to write code and focus on the code

402
00:25:23,190 --> 00:25:26,406
without worrying about the server. So what

403
00:25:26,428 --> 00:25:30,818
we can do inside a lambda function is that using JavaScript,

404
00:25:30,994 --> 00:25:35,234
we can load the trained model and use it for inference.

405
00:25:35,282 --> 00:25:39,226
So if you use lambda with a serverless API service

406
00:25:39,328 --> 00:25:43,098
like API gateway, then we can deploy the model

407
00:25:43,184 --> 00:25:47,206
in that HTTP API without worrying

408
00:25:47,238 --> 00:25:52,250
about the servers. If we were to use libraries

409
00:25:52,330 --> 00:25:55,918
in JavaScript and we want to build a custom

410
00:25:56,004 --> 00:25:59,754
container image, that's also possible because lambda

411
00:25:59,802 --> 00:26:04,110
has container image support as well. So for simpler JavaScript

412
00:26:04,190 --> 00:26:08,222
projects then yes, we can use lambda with JavaScript

413
00:26:08,286 --> 00:26:12,050
directly. However, if we would need more complex

414
00:26:13,030 --> 00:26:17,074
setups and environments for our JavaScript application utilizing

415
00:26:17,122 --> 00:26:20,274
machine learning models, then we can utilize

416
00:26:20,322 --> 00:26:23,926
container image support of lambda. And lambda can be

417
00:26:23,948 --> 00:26:27,046
used across a variety of services

418
00:26:27,148 --> 00:26:31,706
and architectures. For example, you have a streaming service,

419
00:26:31,888 --> 00:26:35,962
let's say there's one record passing through that service because that's how

420
00:26:36,016 --> 00:26:39,306
the architecture was implemented. So what you can

421
00:26:39,328 --> 00:26:43,534
do is whenever there's new data coming out of that streaming application

422
00:26:43,652 --> 00:26:47,150
or service, you can have a lambda function, process one record

423
00:26:47,220 --> 00:26:50,718
at a time, and perform references in real time. Also,

424
00:26:50,884 --> 00:26:55,006
it's also possible to create graphQL

425
00:26:55,118 --> 00:26:58,686
powered APIs and inside that GraphQL powered

426
00:26:58,718 --> 00:27:02,066
API we have a lambda function, processing the

427
00:27:02,088 --> 00:27:05,382
request and utilizing the machine learning model to

428
00:27:05,436 --> 00:27:09,510
perform inference and returning the response back to the user.

429
00:27:10,090 --> 00:27:14,210
So this is also another powerful implementation

430
00:27:14,370 --> 00:27:17,554
and you can definitely use JavaScript for these types of cloud

431
00:27:17,612 --> 00:27:20,922
applications. So before

432
00:27:20,976 --> 00:27:25,434
we end these talk, let's have a quick discussion on

433
00:27:25,632 --> 00:27:29,146
these best practices. It's about using the right tools for

434
00:27:29,168 --> 00:27:33,134
the job. So right now you are aware that there are different ways to

435
00:27:33,332 --> 00:27:36,894
solve the same thing. However, it is crucial that we

436
00:27:36,932 --> 00:27:39,630
always start first with the business requirements.

437
00:27:40,050 --> 00:27:44,178
And again, a lot of technical professionals always

438
00:27:44,264 --> 00:27:47,570
end up focusing on the technical solutions because wow,

439
00:27:47,640 --> 00:27:51,506
that's cool, right? We can use JavaScript in the browser and

440
00:27:51,608 --> 00:27:54,478
do some references there in the browser directly.

441
00:27:54,574 --> 00:27:58,482
However, you need to be aware that this business requirements

442
00:27:58,546 --> 00:28:02,342
may also include security requirements as well. Because what

443
00:28:02,396 --> 00:28:05,862
if it was possible? However it would affect the

444
00:28:05,916 --> 00:28:09,146
stability of your company, especially if the model has

445
00:28:09,168 --> 00:28:13,018
been obtained from the browser, right? So be

446
00:28:13,104 --> 00:28:16,730
very aware that this is the right process.

447
00:28:16,800 --> 00:28:20,494
CTO follow we start first with business requirements and

448
00:28:20,532 --> 00:28:24,526
then that's the time we focus on the technical solution and we

449
00:28:24,548 --> 00:28:27,946
use a variety of building blocks to solve

450
00:28:28,138 --> 00:28:31,920
our requirements. At the same time,

451
00:28:32,770 --> 00:28:36,498
even if you know the right process, even if you

452
00:28:36,504 --> 00:28:40,558
have a good understanding of the business requirements and the different tools

453
00:28:40,574 --> 00:28:44,402
and solutions possible, take note that everything

454
00:28:44,456 --> 00:28:47,638
that you do will always be a function of time,

455
00:28:47,804 --> 00:28:51,474
meaning that you will not have an infinite

456
00:28:51,522 --> 00:28:54,902
amount of time to do what you need to do.

457
00:28:55,036 --> 00:28:58,410
So, similar to our example earlier where

458
00:28:58,560 --> 00:29:01,690
you have a team of five developers all able

459
00:29:01,760 --> 00:29:05,194
to use JavaScript, then yes, if they

460
00:29:05,232 --> 00:29:08,938
need to utilize JavaScript for machine learning needs, then that's possible.

461
00:29:09,024 --> 00:29:12,782
However, if the team is using something like Python or R

462
00:29:12,836 --> 00:29:16,446
for machine learning already, if you were to use

463
00:29:16,628 --> 00:29:20,766
JavaScript for machine learning, you would have to assess, because the

464
00:29:20,788 --> 00:29:24,094
current team working on the machine learning task

465
00:29:24,142 --> 00:29:27,310
needs to learn how to use JavaScript,

466
00:29:27,390 --> 00:29:32,386
especially if they have no experience using the language in

467
00:29:32,408 --> 00:29:36,386
the screen. We can see the different steps when performing

468
00:29:36,418 --> 00:29:40,182
machine learning training. So here we can define the model,

469
00:29:40,316 --> 00:29:44,070
we compile the model, load the data, use the data to

470
00:29:44,220 --> 00:29:47,382
perform machine learning training so we fit

471
00:29:47,436 --> 00:29:51,034
the model and then once we have the model, we evaluate it and

472
00:29:51,072 --> 00:29:54,700
we save it somewhere. So this process,

473
00:29:55,150 --> 00:29:59,066
this training step can be performed in

474
00:29:59,088 --> 00:30:02,810
the server and it can also be performed maybe

475
00:30:02,880 --> 00:30:05,866
in the browser as well. And it can be performed,

476
00:30:05,898 --> 00:30:09,422
I guess in the mobile apps also. So there are different ways CTO

477
00:30:09,476 --> 00:30:13,620
do this. So the question is where should we train the model

478
00:30:15,190 --> 00:30:17,700
so we can train the model?

479
00:30:18,310 --> 00:30:22,354
Depending on the resources needed for training,

480
00:30:22,552 --> 00:30:27,750
and in a majority of the cases training

481
00:30:27,900 --> 00:30:31,334
may be performed in the server because at least

482
00:30:31,372 --> 00:30:34,866
in the server side it's more manageable, especially when you're

483
00:30:34,898 --> 00:30:38,794
doing it in the cloud. However, there are cases where training may

484
00:30:38,832 --> 00:30:42,666
be performed and it's recommended sometimes to do it in the

485
00:30:42,688 --> 00:30:46,106
browser closer to the user because if the

486
00:30:46,128 --> 00:30:49,414
user's data is stuck

487
00:30:49,462 --> 00:30:53,146
in the browser, meaning it cannot be sent to the centralized server,

488
00:30:53,178 --> 00:30:56,590
then yes, you can perform training in the browser itself

489
00:30:56,660 --> 00:30:59,822
because it helps with data privacy. So let's say that the data

490
00:30:59,876 --> 00:31:02,400
which will be used contains confidential information.

491
00:31:03,510 --> 00:31:06,686
Instead of passing that data to the server,

492
00:31:06,798 --> 00:31:10,894
you can perform training closer to the user in the browser

493
00:31:10,942 --> 00:31:14,354
or even in the mobile app. However, in this

494
00:31:14,392 --> 00:31:18,286
scenario we will focus on training our machine

495
00:31:18,318 --> 00:31:21,714
learning model in the server and we can also deployed

496
00:31:21,762 --> 00:31:25,606
the model in the server and we can do this with JavaScript. So as

497
00:31:25,628 --> 00:31:30,066
long as we use the right set of libraries and tools and frameworks,

498
00:31:30,178 --> 00:31:33,930
then we can do this similar to how we're doing it in let's say Python.

499
00:31:34,990 --> 00:31:38,730
And this is what we talked about earlier. We can train our machine learning model

500
00:31:38,800 --> 00:31:42,782
in the server and then when you load the web page

501
00:31:42,916 --> 00:31:46,890
the model gets downloaded as well in the browser.

502
00:31:47,050 --> 00:31:50,510
So there are maybe one or two steps needed to

503
00:31:50,580 --> 00:31:54,446
convert that model to be usable

504
00:31:54,638 --> 00:31:58,546
by the library or framework in the browser. At the same time,

505
00:31:58,648 --> 00:32:01,762
if you can make the model smaller then better.

506
00:32:01,816 --> 00:32:06,334
Also because this is recommended generally for nodejs

507
00:32:06,382 --> 00:32:09,794
which are of small size because if you were to load

508
00:32:09,842 --> 00:32:13,142
your web application it needs to load as fast as possible.

509
00:32:13,276 --> 00:32:16,662
So if your web app is going to load for five minutes because the model

510
00:32:16,716 --> 00:32:20,074
is too big, too big, then these

511
00:32:20,112 --> 00:32:24,154
model is better off in the services side because the request can

512
00:32:24,192 --> 00:32:27,946
be performed later on. And here this is

513
00:32:27,968 --> 00:32:31,402
also possible. We can train the machine learning model in the server

514
00:32:31,546 --> 00:32:35,070
and then in the mobile app, the model

515
00:32:35,140 --> 00:32:38,986
can be downloaded there directly. So the advantage of this setup

516
00:32:39,098 --> 00:32:43,146
is that there's going to be on device references and

517
00:32:43,188 --> 00:32:47,118
the data of the user which will be used for inference

518
00:32:47,214 --> 00:32:50,786
no longer needs to be passed in the

519
00:32:50,808 --> 00:32:54,450
request to the server. So it helps protect the data and

520
00:32:54,520 --> 00:32:58,710
you can do some cool and interactive offline

521
00:32:59,210 --> 00:33:02,550
inference when using this type of approach.

522
00:33:04,250 --> 00:33:08,034
So there, so if all you have is a hammer,

523
00:33:08,162 --> 00:33:11,654
everything becomes a nail. So in this talk we talked about

524
00:33:11,692 --> 00:33:15,698
the different strategies and solutions on how to use JavaScript

525
00:33:15,794 --> 00:33:18,726
for machine learning. And there are different options,

526
00:33:18,828 --> 00:33:22,414
but feel free to to do a bit more research before trying

527
00:33:22,452 --> 00:33:26,026
to use a solution because once you implement this in production,

528
00:33:26,138 --> 00:33:29,934
it's usually hard to fix or change. So make sure to be

529
00:33:29,972 --> 00:33:34,080
an architect and those the right solution and tool for the job.

530
00:33:34,930 --> 00:33:38,862
So thank you again for listening to my talk. We talked about

531
00:33:38,916 --> 00:33:42,720
a lot of strategies and hope you learned something new.

532
00:33:43,410 --> 00:33:43,786
Bye.

