1
00:00:00,410 --> 00:00:06,174
Jamaica real

2
00:00:06,212 --> 00:00:09,578
time feedback into the behavior of your distributed systems

3
00:00:09,674 --> 00:00:12,538
and observing changes, questions,

4
00:00:12,634 --> 00:00:16,014
errors in real time allows you to not only experiment with

5
00:00:16,052 --> 00:00:19,326
confidence, but respond instantly to get

6
00:00:19,348 --> 00:00:20,480
things working again.

7
00:00:24,610 --> 00:00:47,034
Code hi

8
00:00:47,072 --> 00:00:50,426
everyone, my name is Robert. I'm a senior

9
00:00:50,458 --> 00:00:53,934
solutions architect AWS, and today I

10
00:00:53,972 --> 00:00:58,234
want to show you an alternative way to manage your Kubernetes

11
00:00:58,282 --> 00:01:01,454
manifests. And that is, instead of being

12
00:01:01,492 --> 00:01:05,086
a YAML engineer, you can be a software engineer

13
00:01:05,198 --> 00:01:08,690
by writing real code with the help of the cloud

14
00:01:08,760 --> 00:01:12,610
development kit for Kubernetes called cdks.

15
00:01:13,350 --> 00:01:16,946
So what is the cdks? Let's jump

16
00:01:16,978 --> 00:01:21,266
into it. The CDK for Kubernetes,

17
00:01:21,458 --> 00:01:24,770
it's an open source software development framework

18
00:01:24,850 --> 00:01:28,182
where you can use multiple general purpose languages

19
00:01:28,326 --> 00:01:31,820
and the ones that are supported you can see at the bottom.

20
00:01:32,190 --> 00:01:35,382
And with those you will model your Kubernetes

21
00:01:35,446 --> 00:01:39,580
resources as reusable components with real code.

22
00:01:39,890 --> 00:01:42,234
And for that you can use Python,

23
00:01:42,362 --> 00:01:46,080
JavaScript, typeScript, Java and go

24
00:01:46,850 --> 00:01:50,606
now the benefit you gain here is of course that

25
00:01:50,788 --> 00:01:54,494
now that you're not writing YAmL or config files

26
00:01:54,542 --> 00:01:58,162
anymore, but instead real code, you can use

27
00:01:58,216 --> 00:02:01,570
familiar programming languages and techniques.

28
00:02:02,070 --> 00:02:05,554
One of the things you gain, of course, is that you can

29
00:02:05,592 --> 00:02:09,622
use software engineering best practices like do not repeat yourself

30
00:02:09,756 --> 00:02:13,126
and you can refactor stuff. And it also makes it

31
00:02:13,148 --> 00:02:16,722
easier for you to share things, because now your Kubernetes

32
00:02:16,786 --> 00:02:20,234
manifests are actually a package of

33
00:02:20,272 --> 00:02:23,526
your favorite language. It's not anymore just a bunch

34
00:02:23,558 --> 00:02:27,654
of YAML files, but it could be a Python package or a typescript

35
00:02:27,702 --> 00:02:31,086
module. Finally, you can use

36
00:02:31,108 --> 00:02:34,622
cdks everywhere, so it's not something that

37
00:02:34,676 --> 00:02:38,270
only works in the cloud. In the end, cdks is

38
00:02:38,340 --> 00:02:41,790
a kind of config generator, so it will

39
00:02:41,860 --> 00:02:46,260
put out some standard Kubernetes YAMl for

40
00:02:46,710 --> 00:02:50,466
your deployments, but you don't have to write it yourself.

41
00:02:50,648 --> 00:02:53,986
That's something that SDK does for you. And then

42
00:02:54,088 --> 00:02:57,794
you can take those YAML files and insert

43
00:02:57,842 --> 00:03:01,206
them into any existing process. You have to actually

44
00:03:01,308 --> 00:03:04,150
deploy your Kubernetes manifests.

45
00:03:05,290 --> 00:03:09,222
Now when talking about YAmL, you know it's a configuration

46
00:03:09,286 --> 00:03:12,742
language. And I know some engineers

47
00:03:12,886 --> 00:03:16,490
who swear that Yaml stands for yelling at my laptop.

48
00:03:17,070 --> 00:03:21,174
And there are some good reasons now to use

49
00:03:21,232 --> 00:03:24,906
something else instead of Yaml to configure or to define

50
00:03:24,938 --> 00:03:28,366
your deployments. And we will look at some of

51
00:03:28,388 --> 00:03:31,642
the reasons why it's hard to engineer in Yaml.

52
00:03:31,786 --> 00:03:35,346
So let's have a look. Let's engineer some

53
00:03:35,368 --> 00:03:38,674
yaml to get back into the

54
00:03:38,712 --> 00:03:41,854
experience of how it feels to be in Yaml.

55
00:03:41,902 --> 00:03:45,638
Engineer for this example, we're doing

56
00:03:45,724 --> 00:03:49,346
something very simple, which is just an HTTP

57
00:03:49,378 --> 00:03:53,266
echo server. So we want to go to our Kubernetes cluster

58
00:03:53,378 --> 00:03:57,154
and deploy a simple container that just echoes

59
00:03:57,202 --> 00:04:01,034
back what we sent to it. And we also want to

60
00:04:01,072 --> 00:04:04,774
expose that container to the world through an ingress.

61
00:04:04,902 --> 00:04:08,346
So just really standard stuff. So what do we

62
00:04:08,368 --> 00:04:11,566
have to do here? Well, first of all, we have

63
00:04:11,588 --> 00:04:15,530
to define a deployment, right? So that's the basic

64
00:04:15,610 --> 00:04:19,726
object that we know from Kubernetes that helps us to create

65
00:04:19,908 --> 00:04:23,726
something that is a highly available container

66
00:04:23,758 --> 00:04:27,630
application. And with that we have to define

67
00:04:27,790 --> 00:04:30,482
a lot of values, for example,

68
00:04:30,616 --> 00:04:33,540
labels, ports and so on.

69
00:04:34,310 --> 00:04:38,374
Now this only makes running the container on

70
00:04:38,412 --> 00:04:42,582
Kubernetes possible, nothing else. So what we also

71
00:04:42,636 --> 00:04:46,262
need is we need to define a service and the service makes

72
00:04:46,316 --> 00:04:50,034
it so that these containers actually have a single common

73
00:04:50,092 --> 00:04:53,770
ip address within the cluster where you can reach all of them.

74
00:04:53,840 --> 00:04:57,850
And the service is already kind of load balancing between

75
00:04:57,920 --> 00:05:01,294
those containers. So if one of them crashes, we can still reach the

76
00:05:01,332 --> 00:05:04,826
service. If we deployed multiple

77
00:05:04,858 --> 00:05:09,166
containers of that now it's still not available in

78
00:05:09,188 --> 00:05:12,810
the world, we still have to create an ingress

79
00:05:12,890 --> 00:05:16,802
for that. And the ingress in the end is pointing to the service saying

80
00:05:16,856 --> 00:05:20,066
okay, now I actually want to expose that. And we

81
00:05:20,088 --> 00:05:23,470
want to expose this under a HTTP path

82
00:05:23,550 --> 00:05:27,410
called hello. And these are the three ingredients

83
00:05:27,490 --> 00:05:29,560
we need for our little application.

84
00:05:30,650 --> 00:05:34,040
Now if we look at the various things we did here,

85
00:05:34,490 --> 00:05:37,814
we immediately spot that there's a lot of repetition going on,

86
00:05:37,852 --> 00:05:40,986
right? So a lot of the time when you're working with

87
00:05:41,008 --> 00:05:44,874
Kubernetes, you need to take care of labels and you

88
00:05:44,992 --> 00:05:49,370
have to make sure that the labels are the same between different

89
00:05:49,440 --> 00:05:53,002
objects because they reference each other through

90
00:05:53,056 --> 00:05:56,762
those labels. So here we can see that we have quite a lot of repetition

91
00:05:56,826 --> 00:06:00,574
with this app echo label because the deployment needs it to

92
00:06:00,612 --> 00:06:04,194
actually find the containers and the service needs it as well to

93
00:06:04,232 --> 00:06:07,682
find the containers. Besides that,

94
00:06:07,736 --> 00:06:10,946
we also have some repetition of values like the

95
00:06:10,968 --> 00:06:14,978
port. So we defined a port initially for the application

96
00:06:15,144 --> 00:06:18,406
in the deployment, but then we also have to tell the

97
00:06:18,428 --> 00:06:21,894
service that we need the same port so that

98
00:06:21,932 --> 00:06:25,398
it is actually reaching the application that is running in the

99
00:06:25,404 --> 00:06:29,980
container. And again we have another

100
00:06:30,510 --> 00:06:34,122
mentioning of the same port or a similar port

101
00:06:34,256 --> 00:06:37,882
where you need to tell the ingress that yes, this is the port number

102
00:06:37,936 --> 00:06:41,920
where actually the service is listening so that it then can forward

103
00:06:42,610 --> 00:06:46,350
the request to the container. So we already

104
00:06:46,420 --> 00:06:50,430
see that we have a lot of repetition here, this is definitely not

105
00:06:50,500 --> 00:06:54,034
dry. And the question is, is there a better way to

106
00:06:54,072 --> 00:06:57,842
do it. Finally, we also

107
00:06:57,896 --> 00:07:01,794
see that we have to do one of the hardest things in

108
00:07:01,832 --> 00:07:05,314
software engineering or any kind of engineering, which is

109
00:07:05,352 --> 00:07:08,966
naming things. So we have to think about the

110
00:07:08,988 --> 00:07:12,902
name for the service here. And again, we have to repeat the same

111
00:07:12,956 --> 00:07:16,854
name exactly for the ingress so that the ingress is actually pointing to

112
00:07:16,892 --> 00:07:19,930
that specific service. In total,

113
00:07:20,080 --> 00:07:23,274
we got 45 lines of Yaml here,

114
00:07:23,472 --> 00:07:26,540
and this is something we had to write on our own.

115
00:07:27,070 --> 00:07:30,854
So to sum it up, the downsides of Yaml

116
00:07:30,902 --> 00:07:34,778
are, well, it's a static configuration language.

117
00:07:34,874 --> 00:07:38,106
You don't have a lot of tools

118
00:07:38,138 --> 00:07:41,738
to do things like conditionals, variables and tools.

119
00:07:41,914 --> 00:07:46,018
It promotes a lot of copy paste. That's what we saw in our example.

120
00:07:46,184 --> 00:07:49,682
So that makes it very error prone and difficult to

121
00:07:49,736 --> 00:07:53,042
change. It's also hard to customize and share.

122
00:07:53,096 --> 00:07:57,394
So there's no native method to actually put in variables

123
00:07:57,442 --> 00:08:00,742
or inputs to change the template. And there's no

124
00:08:00,796 --> 00:08:04,726
Yaml package manager. So you need to find your own way to actually

125
00:08:04,908 --> 00:08:09,210
share those manifests, maybe in your company or publicly.

126
00:08:10,830 --> 00:08:14,534
In addition, as we've seen, it's not just about Yaml,

127
00:08:14,582 --> 00:08:17,702
it's also about Kubernetes having a lot of dials

128
00:08:17,766 --> 00:08:21,674
and knobs. So these manifests actually carry a fairly

129
00:08:21,722 --> 00:08:25,054
high cognitive load because you have to make

130
00:08:25,172 --> 00:08:28,782
so many settings for the properties and make sure that they

131
00:08:28,836 --> 00:08:32,654
match exactly, so that actually the whole thing

132
00:08:32,692 --> 00:08:36,722
works. Now how can CDKs help

133
00:08:36,776 --> 00:08:40,930
you there? The motivation of CDKs is

134
00:08:41,000 --> 00:08:44,626
that as we just saw, authoring Kubernetes manifests can

135
00:08:44,648 --> 00:08:48,526
be a rather complicated tasks. And CDKs

136
00:08:48,638 --> 00:08:52,194
makes this easier. And this is

137
00:08:52,232 --> 00:08:55,750
really what cdks wants to do at the core, making,

138
00:08:55,900 --> 00:08:59,526
creating those manifests, authoring those manifests simpler

139
00:08:59,638 --> 00:09:03,562
and more robust for you. And what does it

140
00:09:03,616 --> 00:09:07,690
leverage to do that? Well, it leverages general purpose languages,

141
00:09:09,070 --> 00:09:12,766
and by using general purpose languages you

142
00:09:12,788 --> 00:09:16,366
can actually employ best practices of

143
00:09:16,388 --> 00:09:20,222
software engineering. Now what are the benefits

144
00:09:20,356 --> 00:09:23,766
of general purpose programming languages in comparison

145
00:09:23,818 --> 00:09:27,230
to something like Yaml? Well, of course they're dynamic.

146
00:09:27,310 --> 00:09:30,542
So you have multiple ways to do control flows.

147
00:09:30,686 --> 00:09:34,322
You can iterate over stuff, you can apply things

148
00:09:34,376 --> 00:09:38,022
like do not repeat yourself because you can pull but common

149
00:09:38,076 --> 00:09:41,654
values that you reuse. You can refactor your

150
00:09:41,692 --> 00:09:45,190
code to take, but repetitive

151
00:09:46,090 --> 00:09:49,420
code that you use multiple times.

152
00:09:50,510 --> 00:09:53,574
And typically you also have a standard package manager.

153
00:09:53,622 --> 00:09:57,210
So you can have your Kubernetes manifests

154
00:09:57,790 --> 00:10:01,626
distributed as a Python package or as a node

155
00:10:01,658 --> 00:10:04,974
module. That's possible. And finally,

156
00:10:05,092 --> 00:10:08,526
because now we're actually using programming languages, we can

157
00:10:08,548 --> 00:10:12,362
build abstractions so we can remove some of that cognitive

158
00:10:12,426 --> 00:10:16,514
load that we saw, some of that repetition which is needed

159
00:10:16,632 --> 00:10:19,762
for kubernetes to work, but is actually not

160
00:10:19,816 --> 00:10:23,730
really important for you in your day to day work because

161
00:10:23,800 --> 00:10:27,718
they are just best practices and standard

162
00:10:27,884 --> 00:10:31,126
ways of wiring things up that you do not want to

163
00:10:31,148 --> 00:10:35,142
think about. Now let's jump into how

164
00:10:35,276 --> 00:10:37,590
you can actually work with cdks.

165
00:10:39,130 --> 00:10:42,534
First of all, you need the CDKs CLI,

166
00:10:42,662 --> 00:10:46,346
and there are multiple ways to install that CLi, but one

167
00:10:46,368 --> 00:10:50,234
of the easiest ones is just to do NPM install minus G

168
00:10:50,432 --> 00:10:53,550
and referencing the CDK's minus CLI.

169
00:10:53,890 --> 00:10:57,098
You also find other ways to do it, like with Brew,

170
00:10:57,194 --> 00:11:01,098
and you can read all about it on the project website, which is Cdkates

171
00:11:01,194 --> 00:11:04,418
IO. Now once you did that,

172
00:11:04,584 --> 00:11:07,746
the next step is to actually initialize your project.

173
00:11:07,848 --> 00:11:12,478
So there's a built in command that helps you to scaffold

174
00:11:12,574 --> 00:11:16,710
an application skeleton in the language of your choice.

175
00:11:17,210 --> 00:11:20,486
So if for example, you're like me,

176
00:11:20,588 --> 00:11:23,894
you would go with cdks in a typescript app. And that would

177
00:11:23,932 --> 00:11:27,666
give you the skeleton of a typescript app

178
00:11:27,788 --> 00:11:30,730
where you can define your manifests in typescript.

179
00:11:31,470 --> 00:11:34,854
And this is what you get when you execute

180
00:11:34,902 --> 00:11:38,506
that command. After that you need

181
00:11:38,528 --> 00:11:41,066
to import API objects.

182
00:11:41,178 --> 00:11:45,566
So this is an important step because as

183
00:11:45,588 --> 00:11:49,614
you know, Kubernetes has a lot of versions and each of

184
00:11:49,652 --> 00:11:53,426
those versions has different API objects. Some of

185
00:11:53,448 --> 00:11:57,410
them graduate between being beta to being

186
00:11:57,480 --> 00:12:00,850
stable. And you need to let your project

187
00:12:00,920 --> 00:12:04,626
know against which Kubernetes version you are actually working.

188
00:12:04,808 --> 00:12:08,562
That's not something that is specific to cdks.

189
00:12:08,706 --> 00:12:11,718
That's a challenge you basically have with any tool.

190
00:12:11,884 --> 00:12:15,718
And with the fact that Kubernetes gets new updates like

191
00:12:15,804 --> 00:12:19,286
every 3 hours, it feels like. So this

192
00:12:19,308 --> 00:12:22,474
is something you have to deal with anyway. The way you do this

193
00:12:22,512 --> 00:12:26,022
is you're using the import command so you can do CDK's

194
00:12:26,086 --> 00:12:30,194
import and then reference the version of Kubernetes

195
00:12:30,262 --> 00:12:34,334
that you want to work against. A very cool trick here is

196
00:12:34,372 --> 00:12:38,590
as you see, that you can also reference

197
00:12:39,810 --> 00:12:44,450
custom resource definitions. So another

198
00:12:44,520 --> 00:12:48,178
way to use CDKs is to not only

199
00:12:48,264 --> 00:12:51,870
work with the standard objects of kubernetes,

200
00:12:52,030 --> 00:12:55,590
but also if you have any operators that expose any

201
00:12:55,660 --> 00:12:58,870
custom resources to your cluster, which you

202
00:12:58,940 --> 00:13:03,046
certainly have, you can give CDKs the

203
00:13:03,068 --> 00:13:06,610
YAml file of those definitions and then CDKs

204
00:13:06,690 --> 00:13:10,054
will create classes out of that, and those classes

205
00:13:10,102 --> 00:13:13,542
will help you to actually instantiate those custom resources

206
00:13:13,606 --> 00:13:15,260
as well in your code.

207
00:13:16,670 --> 00:13:20,102
The next step you have to do after that is

208
00:13:20,176 --> 00:13:23,162
actually coding what you want to deploy.

209
00:13:23,306 --> 00:13:27,162
So this is where you're using the various classes

210
00:13:27,226 --> 00:13:30,720
that ckates gives you to create

211
00:13:31,250 --> 00:13:35,266
the manifests or the configurations you want to

212
00:13:35,288 --> 00:13:39,010
have in your cluster. And in a minute we will jump into

213
00:13:39,080 --> 00:13:42,782
how that feels like when you're actually using general purpose

214
00:13:42,846 --> 00:13:47,190
programming languages to define your Kubernetes objects.

215
00:13:48,410 --> 00:13:51,160
So getting started here,

216
00:13:51,930 --> 00:13:55,590
for me it's visual studio code, but it would work in basically

217
00:13:55,740 --> 00:13:58,460
any ide that you like.

218
00:13:59,070 --> 00:14:02,602
When I start writing my deployment, I can see

219
00:14:02,656 --> 00:14:05,942
that now for each of those Kubernetes

220
00:14:06,006 --> 00:14:09,382
objects, like the deployment object, I also have a corresponding

221
00:14:09,446 --> 00:14:13,322
class provided by cdks. And here it's the Kube

222
00:14:13,386 --> 00:14:17,166
deployment. And this is a one to

223
00:14:17,188 --> 00:14:21,310
one representation of the deployment

224
00:14:21,650 --> 00:14:26,690
specification from the standard Kubernetes API.

225
00:14:27,350 --> 00:14:30,974
But the benefit I get here already, as you can see, is as I'm

226
00:14:31,022 --> 00:14:34,942
writing the configuration for that deployment, I get

227
00:14:35,016 --> 00:14:38,278
a lot of autocompletion hints from my idE,

228
00:14:38,444 --> 00:14:41,606
and that's possible out of the box obviously,

229
00:14:41,708 --> 00:14:45,702
because now your Kubernetes API is just

230
00:14:45,756 --> 00:14:49,510
a code library. So your ide will look at that library

231
00:14:49,590 --> 00:14:53,386
and tell you what kind of properties are there. And if I

232
00:14:53,408 --> 00:14:57,318
go further and start writing out those properties,

233
00:14:57,414 --> 00:15:02,030
I can also see inline documentation here. So instead

234
00:15:02,100 --> 00:15:05,994
of going to another website and reading on the properties,

235
00:15:06,122 --> 00:15:09,342
I can read about what those properties are doing right

236
00:15:09,396 --> 00:15:12,994
in my ide. So that is already a

237
00:15:13,032 --> 00:15:16,686
pretty big boost to my productivity. Now let's

238
00:15:16,718 --> 00:15:20,434
see how the echo server actually looks like with

239
00:15:20,472 --> 00:15:24,830
cdks. And we're using typescript here because I'm a typescript guy.

240
00:15:25,000 --> 00:15:28,358
So the first thing is that we are

241
00:15:28,524 --> 00:15:31,842
writing that deployment class. We are configuring,

242
00:15:31,906 --> 00:15:34,966
instantiating that deployment class. And you

243
00:15:34,988 --> 00:15:38,454
see here, it looks rather similar to

244
00:15:38,492 --> 00:15:41,914
what we did before with yaml, but now it's in code.

245
00:15:42,112 --> 00:15:44,982
And again we need a deployment.

246
00:15:45,046 --> 00:15:48,874
Of course we need the service. We have seen that

247
00:15:48,912 --> 00:15:52,558
before as well because the service will then load balance between

248
00:15:52,724 --> 00:15:56,446
the containers of my deployment. And finally we

249
00:15:56,468 --> 00:16:00,618
need the ingress as well. So far no surprises,

250
00:16:00,794 --> 00:16:04,786
but we already benefit because we have written code and

251
00:16:04,968 --> 00:16:08,770
for writing all these properties we would have gotten

252
00:16:09,430 --> 00:16:12,450
autocompletion and also inline documentation.

253
00:16:13,030 --> 00:16:16,598
Now where we see some direct benefits is

254
00:16:16,764 --> 00:16:20,214
with that point of being dry. So instead of

255
00:16:20,252 --> 00:16:23,478
repeating the port number multiple times, we can

256
00:16:23,484 --> 00:16:27,854
now pull it out into a variable and then basically reference

257
00:16:27,922 --> 00:16:30,220
it anywhere in our application.

258
00:16:30,750 --> 00:16:34,810
And also for the labels that we had to repeat before now

259
00:16:34,880 --> 00:16:38,698
we can also just define them once and then basically

260
00:16:38,864 --> 00:16:42,986
have them here defined

261
00:16:43,098 --> 00:16:46,746
or repeated automatically differences anywhere

262
00:16:46,778 --> 00:16:50,170
we need them. So that already makes it easier.

263
00:16:50,250 --> 00:16:53,700
And we have removed a lot of repetition from before.

264
00:16:55,270 --> 00:16:59,106
Another thing that's cool is that

265
00:16:59,288 --> 00:17:03,010
there's already some built in convenience even into

266
00:17:03,080 --> 00:17:06,322
those basic classes that we have here. So here

267
00:17:06,376 --> 00:17:10,450
we can see that we actually don't have to think about the naming

268
00:17:10,530 --> 00:17:14,486
like we had to think about before when we were defining YAml on

269
00:17:14,508 --> 00:17:18,620
our own. So here we're just instantiating the service.

270
00:17:19,390 --> 00:17:23,270
And to reference the service in the ingress,

271
00:17:23,430 --> 00:17:27,034
we just have a handy property here service name

272
00:17:27,232 --> 00:17:30,714
which we can use for that name. And we don't have to think about how

273
00:17:30,752 --> 00:17:33,806
this is actually created. Cdks will

274
00:17:33,828 --> 00:17:37,166
do that for me. It will make sure that it's a

275
00:17:37,188 --> 00:17:41,102
unique name, so there's no collision. And I just have

276
00:17:41,156 --> 00:17:45,250
one less thing to think about when I'm making that configuration.

277
00:17:46,630 --> 00:17:49,902
Now that we've written our Kubernetes

278
00:17:49,966 --> 00:17:53,394
manifest in a programming language, the next

279
00:17:53,432 --> 00:17:57,274
thing we can do is actually synthesize it. And for that cdks

280
00:17:57,342 --> 00:18:01,206
has a command called Synth. And what this command will do is

281
00:18:01,308 --> 00:18:05,094
it will take that code, run it and create

282
00:18:05,292 --> 00:18:08,826
standard vanilla Kubernetes manifests in Yaml out

283
00:18:08,848 --> 00:18:12,074
of that. So the way this then looks like

284
00:18:12,112 --> 00:18:15,402
is that in the disk folder of your

285
00:18:15,456 --> 00:18:18,566
project you will find those manifests as YAML

286
00:18:18,598 --> 00:18:22,158
files. And to make it super easy,

287
00:18:22,244 --> 00:18:24,970
you can just take those YAMl files,

288
00:18:25,050 --> 00:18:28,670
give them to Kubectl apply and it will deploy that stuff

289
00:18:28,740 --> 00:18:32,426
in your cluster. At that point there's no dependency anymore

290
00:18:32,458 --> 00:18:35,794
on cdks. You just have a vanilla YAMl file, you can take

291
00:18:35,832 --> 00:18:39,778
it answers, you can check and lint it with standard

292
00:18:39,864 --> 00:18:43,214
tools you have for Kubernetes manifest files.

293
00:18:43,342 --> 00:18:46,982
There's nothing special about these files anymore. It doesn't matter that

294
00:18:47,036 --> 00:18:50,534
CDK's created. And of course

295
00:18:50,652 --> 00:18:53,782
if you have any other tools or processes where

296
00:18:53,836 --> 00:18:57,954
you basically drop in your YAMl files, you can reuse

297
00:18:58,002 --> 00:19:01,846
all those processes. So if you have some git ops process where the YAML

298
00:19:01,878 --> 00:19:05,734
file is taken and applied to your Kubernetes cluster

299
00:19:05,782 --> 00:19:09,514
with a kind of control loop to continuously make sure that

300
00:19:09,552 --> 00:19:13,082
this is the Yaml file that is applied, you can do all of that

301
00:19:13,136 --> 00:19:17,070
because CDK is not involved here anymore,

302
00:19:17,410 --> 00:19:20,430
you just have a standard Kubernetes manifest.

303
00:19:21,410 --> 00:19:24,666
Now once you did that, you might have the idea that

304
00:19:24,708 --> 00:19:28,514
what you build is pretty cool and it's actually something that could be

305
00:19:28,552 --> 00:19:32,002
reusable for the whole world or maybe just for your team

306
00:19:32,056 --> 00:19:35,154
or for your company. So you could

307
00:19:35,192 --> 00:19:38,646
publish this as a code package. And of

308
00:19:38,668 --> 00:19:42,022
course that depends on which language you chose. So for example

309
00:19:42,076 --> 00:19:45,826
for typescript you might have an internal or external

310
00:19:46,018 --> 00:19:49,802
node package manager registry. And you could now

311
00:19:49,856 --> 00:19:53,242
create a package out of what you just did, publish that

312
00:19:53,296 --> 00:19:56,886
package and make it available for others to use. So that's

313
00:19:56,918 --> 00:20:00,622
a great way to actually make

314
00:20:00,676 --> 00:20:04,302
your work reusable and share it with others

315
00:20:04,356 --> 00:20:07,662
so that they can benefit as well. And this is just

316
00:20:07,716 --> 00:20:11,514
some pseudo code, fake code. But you could imagine

317
00:20:11,562 --> 00:20:15,490
that you created a library called my team constructs

318
00:20:15,910 --> 00:20:19,486
and you would share this for example internally through your package

319
00:20:19,598 --> 00:20:23,154
registry. And then somebody else could use

320
00:20:23,192 --> 00:20:27,014
your echo server deployment that you have just built and they could

321
00:20:27,052 --> 00:20:30,418
just instantiate that and have this standard echo

322
00:20:30,434 --> 00:20:33,830
server maybe for debugging. Now we saw

323
00:20:33,900 --> 00:20:37,806
some benefits already by using a programming

324
00:20:37,858 --> 00:20:41,434
language, but we can go even further. So let me

325
00:20:41,472 --> 00:20:44,538
introduce you to Cdkates plus,

326
00:20:44,704 --> 00:20:49,050
which is an extension to the basic cdkates library.

327
00:20:50,290 --> 00:20:54,206
To explain what cdks does. We have to

328
00:20:54,388 --> 00:20:58,234
talk about construct levels. So constructs

329
00:20:58,282 --> 00:21:01,662
are what we are calling those classes. You have

330
00:21:01,716 --> 00:21:04,958
seen that you instantiate and that represent

331
00:21:05,054 --> 00:21:09,010
the real deployment objects or the real API objects.

332
00:21:09,830 --> 00:21:13,362
And we think about levels when talking about

333
00:21:13,416 --> 00:21:17,858
constructs. And the level defines the sophistication

334
00:21:18,034 --> 00:21:21,382
of those constructs. So basically how much

335
00:21:21,436 --> 00:21:24,200
they do for you or how smart they are.

336
00:21:24,970 --> 00:21:27,800
At the lowest level, level zero,

337
00:21:28,430 --> 00:21:31,862
we have the common functionality of the Kubernetes

338
00:21:31,926 --> 00:21:36,390
API objects. So this is a very bare bones representation

339
00:21:36,470 --> 00:21:39,450
of the normal API objects of Kubernetes.

340
00:21:40,050 --> 00:21:45,194
If we go one level up, we have those classes

341
00:21:45,242 --> 00:21:49,482
that we already use like Kube deployment, Kube service, Kube ingress.

342
00:21:49,626 --> 00:21:53,442
Those are automatically generated. They already give you some

343
00:21:53,496 --> 00:21:57,742
convenience, like the name generation I mentioned. But mostly

344
00:21:57,806 --> 00:22:02,782
they are still representing the base API

345
00:22:02,846 --> 00:22:06,630
from kubernetes. Now where it gets really

346
00:22:06,700 --> 00:22:10,790
interesting, and this is where cdkates plus

347
00:22:10,940 --> 00:22:14,054
comes into play, is with a level two.

348
00:22:14,172 --> 00:22:17,662
So cdks

349
00:22:17,746 --> 00:22:21,420
plus exposes a number of high level

350
00:22:21,950 --> 00:22:25,958
handcrafted APIs that make it even easier

351
00:22:26,134 --> 00:22:29,526
to create and wire up multiple

352
00:22:29,638 --> 00:22:33,454
Kubernetes objects that you need to actually get can application

353
00:22:33,572 --> 00:22:37,022
running. So to give you a real

354
00:22:37,076 --> 00:22:40,494
example of how that looks like, let's take the same

355
00:22:40,532 --> 00:22:44,402
Echo server we built with CDKs before and now

356
00:22:44,456 --> 00:22:46,980
build it with CDKS plus.

357
00:22:47,590 --> 00:22:51,774
What we can see here is that the whole example became

358
00:22:51,822 --> 00:22:55,406
much more concise. We are still defining

359
00:22:55,438 --> 00:22:58,600
the port. Of course we have to, that's up to our application.

360
00:22:59,130 --> 00:23:01,974
We create a deployment again,

361
00:23:02,172 --> 00:23:04,998
but this time it's a k plus.

362
00:23:05,084 --> 00:23:08,298
So a cdks plus deployment. So it's a different class,

363
00:23:08,384 --> 00:23:12,246
it's the high level variant of the deployment.

364
00:23:12,438 --> 00:23:16,646
And here we can already see that we have to define

365
00:23:16,838 --> 00:23:21,162
a lot less properties to make the deployment

366
00:23:21,226 --> 00:23:24,554
work. So actually we mostly

367
00:23:24,602 --> 00:23:28,526
just have to define the minimum needed

368
00:23:28,708 --> 00:23:32,282
information about the container we want to run in our deployment,

369
00:23:32,346 --> 00:23:35,246
which might be the image and the arguments,

370
00:23:35,358 --> 00:23:38,402
and the port that is exposed and nothing

371
00:23:38,456 --> 00:23:41,730
else. And then to actually expose it

372
00:23:41,800 --> 00:23:46,062
via an ingress, there's a nice helper function called expose

373
00:23:46,126 --> 00:23:50,226
via ingress. And there we just pass the path

374
00:23:50,338 --> 00:23:53,574
we want to use for that, and the

375
00:23:53,612 --> 00:23:57,398
type we want to use for that ingress, which is prefix in

376
00:23:57,404 --> 00:24:03,786
that case, meaning everything after hello is basically passed to

377
00:24:03,808 --> 00:24:07,130
the container. Now we see here that, for example,

378
00:24:07,280 --> 00:24:10,960
we do not have to create a service object,

379
00:24:11,810 --> 00:24:15,854
and we do not have to create the ingress object on our

380
00:24:15,892 --> 00:24:19,786
own. This is basically all done by this smart

381
00:24:19,818 --> 00:24:22,954
deployment object, by calling expose via ingress.

382
00:24:23,082 --> 00:24:26,754
So this is why this code is much more

383
00:24:26,792 --> 00:24:30,642
concise than what we did before. Actually, we have just

384
00:24:30,696 --> 00:24:35,102
13 lines of code here. And before we had something like 45

385
00:24:35,176 --> 00:24:38,786
lines of code. So already by a factor

386
00:24:38,818 --> 00:24:41,974
of three, we reduced the amount of code we

387
00:24:42,012 --> 00:24:45,926
had to write. And because we have less code

388
00:24:46,108 --> 00:24:49,420
and questions that speak to us,

389
00:24:49,870 --> 00:24:53,766
it's actually easier for us to declare our intent

390
00:24:53,958 --> 00:24:57,478
and to write code for humans and not machines.

391
00:24:57,654 --> 00:25:01,470
So if I look at that, it's much more clearer for me

392
00:25:01,540 --> 00:25:04,926
what the person, and that might be me. If I look at

393
00:25:04,948 --> 00:25:07,520
that maybe a year later,

394
00:25:08,610 --> 00:25:12,800
it's much more clear for me as a person what

395
00:25:13,490 --> 00:25:17,314
actually was the intent of that code and what that deployment should

396
00:25:17,352 --> 00:25:20,786
do. And if we stick to that for just a

397
00:25:20,808 --> 00:25:24,702
minute, I think this is a nice segue

398
00:25:24,766 --> 00:25:28,790
to clean code, where you can say

399
00:25:28,860 --> 00:25:32,102
that if you've read the book,

400
00:25:32,156 --> 00:25:35,734
or if you know that there's this clean code book from Robert C.

401
00:25:35,772 --> 00:25:39,898
Martin and other authors, where they basically say,

402
00:25:39,984 --> 00:25:43,466
well, ideally we want to write clean code

403
00:25:43,568 --> 00:25:47,114
and can important property of clean code is actually that

404
00:25:47,152 --> 00:25:50,394
it can be easily understood by everyone on the team.

405
00:25:50,512 --> 00:25:53,822
I find it's a really interesting aspect that

406
00:25:53,876 --> 00:25:58,010
we can try to achieve here with CDKs or CDKs

407
00:25:58,090 --> 00:26:01,402
plus. So by now having the ability

408
00:26:01,546 --> 00:26:05,314
to change the way we write

409
00:26:05,352 --> 00:26:08,786
our deployments, by using code, we can make the

410
00:26:08,808 --> 00:26:12,194
code more readable and write it in a way that

411
00:26:12,232 --> 00:26:15,602
it clarifies what we actually want to achieve,

412
00:26:15,666 --> 00:26:20,520
so that it's easy to understand by other team members and

413
00:26:21,210 --> 00:26:24,694
to really drive home. What I meant here is if we

414
00:26:24,732 --> 00:26:28,186
again look at that example of CDKS plus and what

415
00:26:28,208 --> 00:26:31,834
it does, we can see that now

416
00:26:31,872 --> 00:26:36,486
it's much easier to tell a story, right, because we created a deployment,

417
00:26:36,678 --> 00:26:40,262
and then we call deployment expose via ingress.

418
00:26:40,406 --> 00:26:44,270
So the story is much clearer. I want to create a deployment

419
00:26:44,610 --> 00:26:46,830
and I want to expose it via ingress.

420
00:26:48,130 --> 00:26:51,886
Now, what's actually happening in the background? Let's look

421
00:26:51,908 --> 00:26:55,700
a little bit at what cdkates is doing for us here.

422
00:26:56,630 --> 00:26:59,298
So taking that code,

423
00:26:59,464 --> 00:27:02,782
CDKates is creating the Kubernetes

424
00:27:02,926 --> 00:27:06,406
Yaml manifest. And what it of course does,

425
00:27:06,508 --> 00:27:10,214
it creates the deployment. In the deployment it has

426
00:27:10,252 --> 00:27:13,320
to reference that port value that we set.

427
00:27:14,410 --> 00:27:18,410
Then it also has to create labels

428
00:27:18,990 --> 00:27:22,742
so that those labels point to the ports and the deployment

429
00:27:22,806 --> 00:27:26,934
actually knows what ports belong

430
00:27:26,982 --> 00:27:30,266
to that deployment. And cdks does

431
00:27:30,288 --> 00:27:33,982
that for you. You don't see any labels here, right? This is happening

432
00:27:34,036 --> 00:27:38,942
in the background. So it's taking all that cognitive load of thinking

433
00:27:38,996 --> 00:27:43,082
about a label and making sure that you copy paste the right label

434
00:27:43,226 --> 00:27:46,898
between multiple objects. And then we

435
00:27:46,904 --> 00:27:50,862
have to create the ingress. Or we would have, but in this case cdks

436
00:27:50,926 --> 00:27:54,114
is also doing that for us, right? We don't see that

437
00:27:54,152 --> 00:27:57,282
here anywhere. And again this ingress

438
00:27:57,426 --> 00:28:00,486
has to reference a port. Typically it can be

439
00:28:00,508 --> 00:28:04,182
the same port and then

440
00:28:04,316 --> 00:28:08,118
you also have to create that service. Except again

441
00:28:08,204 --> 00:28:11,690
we don't have to do that. You don't see the service here anywhere.

442
00:28:12,430 --> 00:28:16,186
This nice helper function is doing that for you in

443
00:28:16,208 --> 00:28:19,738
the background. And here again you have

444
00:28:19,744 --> 00:28:23,246
to think about naming the ingress must reference the name of the

445
00:28:23,268 --> 00:28:26,510
service. This is all done for you behind the covers.

446
00:28:26,930 --> 00:28:31,086
Again the service has to reference the same port or

447
00:28:31,188 --> 00:28:32,910
another port potentially.

448
00:28:33,830 --> 00:28:37,330
And again the service needs labels because

449
00:28:37,480 --> 00:28:41,282
also the service uses labels to actually figure out which

450
00:28:41,336 --> 00:28:45,746
ports shall being to the service and shall get requests

451
00:28:45,778 --> 00:28:49,334
that are coming in. And there you

452
00:28:49,372 --> 00:28:53,398
see that this whole graph is already getting

453
00:28:53,484 --> 00:28:57,160
a little bit complicated for such a simple application.

454
00:28:57,530 --> 00:29:01,098
But you don't have to think about that. You wrote your story

455
00:29:01,184 --> 00:29:03,910
in CDK's plus and under the hood.

456
00:29:03,990 --> 00:29:08,294
CDK's created and wired all those resources

457
00:29:08,342 --> 00:29:12,022
for you and took care of boring technical

458
00:29:12,086 --> 00:29:15,886
details that you just have to get right, but actually do

459
00:29:15,908 --> 00:29:19,454
not really give you something new or cool. It just has

460
00:29:19,492 --> 00:29:22,914
to be done and you can stick to your much more

461
00:29:22,952 --> 00:29:25,890
concise story of what you wanted to achieve.

462
00:29:27,030 --> 00:29:30,194
Summing up here are some reasons why

463
00:29:30,232 --> 00:29:33,250
I think you should code your infrastructure.

464
00:29:33,830 --> 00:29:37,954
So what are you gaining by using cdks or similar frameworks?

465
00:29:38,002 --> 00:29:41,842
Well, instead of using YamL or some other configuration language,

466
00:29:41,906 --> 00:29:45,286
you are using a familiar programming language of your choice. And that

467
00:29:45,308 --> 00:29:48,382
could be Javascript, typescript, Python,

468
00:29:48,546 --> 00:29:52,060
Java or even Golang. That's up to you.

469
00:29:52,430 --> 00:29:56,346
With that you get great ide and tool support, because now your

470
00:29:56,368 --> 00:29:59,530
deployments are just code, there's nothing special about them.

471
00:29:59,600 --> 00:30:03,022
And all the cool features that you have in your ide for

472
00:30:03,076 --> 00:30:06,110
refactoring, autocompletion,

473
00:30:06,610 --> 00:30:09,440
inline documentation just work out of the box.

474
00:30:10,210 --> 00:30:14,082
Going further, we just saw that with cdks plus you

475
00:30:14,136 --> 00:30:18,318
also get powerful abstractions to have a more concise

476
00:30:18,494 --> 00:30:22,142
configuration and also have the ability

477
00:30:22,206 --> 00:30:25,410
to tell a story that's much clearer to your teammates.

478
00:30:26,090 --> 00:30:30,134
And of course all of that is wrapped in the opportunity to

479
00:30:30,172 --> 00:30:33,570
use software engineering best practices

480
00:30:33,730 --> 00:30:35,880
and exercising clean code.

481
00:30:37,370 --> 00:30:41,394
Now, are there reasons to not code your infrastructure

482
00:30:41,522 --> 00:30:45,274
to not use cdks? Well, yes, of course. So if

483
00:30:45,312 --> 00:30:49,690
you are feeling very comfortable with your current tools and your workflows,

484
00:30:50,110 --> 00:30:54,010
of course you don't have to change. The cool thing about cdks

485
00:30:54,090 --> 00:30:58,010
is that of course you can mix and match. You saw that cdks

486
00:30:58,090 --> 00:31:02,106
in the end just creates vanilla Kubernetes manifests.

487
00:31:02,218 --> 00:31:05,454
So you could have mixed workflows

488
00:31:05,582 --> 00:31:09,154
where you actually can use,

489
00:31:09,352 --> 00:31:13,074
for example, your existing tools, but also create part of the

490
00:31:13,112 --> 00:31:17,362
application with cdks and then just merge

491
00:31:17,426 --> 00:31:20,440
those YAML files together, deploy them together.

492
00:31:20,970 --> 00:31:24,694
If you don't like coding, that might also be

493
00:31:24,732 --> 00:31:28,938
a reason, and I think it's a fair reason because

494
00:31:29,104 --> 00:31:32,954
code means abstraction, and abstractions are nice when they work

495
00:31:33,072 --> 00:31:37,046
and you really hate them when they do not work. But that's

496
00:31:37,078 --> 00:31:40,890
kind of part of the course for using

497
00:31:40,960 --> 00:31:45,262
programming languages. So either

498
00:31:45,316 --> 00:31:47,840
you like it and you know how to deal with it,

499
00:31:48,290 --> 00:31:51,994
or you don't like it, and then of course you can stick to writing YamL

500
00:31:52,042 --> 00:31:54,190
or some other configuration language.

501
00:31:55,010 --> 00:31:58,866
Finally, if you are an author of an helm chart and you're wondering, can I

502
00:31:58,888 --> 00:32:02,542
use this to actually author the helm chart? So create the guts,

503
00:32:02,606 --> 00:32:06,550
the internals of the helm chart. This is not supported.

504
00:32:07,290 --> 00:32:10,866
You can deploy Helm charts, so you can interact with helm

505
00:32:10,898 --> 00:32:14,594
charts as an end user in your cluster, but you cannot

506
00:32:14,642 --> 00:32:18,534
author the helm charts. Finally, I want to

507
00:32:18,572 --> 00:32:22,650
leave you here with some resources on how you can get started

508
00:32:22,720 --> 00:32:26,474
with cdks if you want to. So for

509
00:32:26,512 --> 00:32:30,602
example, a good place to start is of course the project website

510
00:32:30,736 --> 00:32:34,538
cdks IO. There you find the documentation

511
00:32:34,634 --> 00:32:37,920
and also some instructions on how to install the stuff.

512
00:32:38,530 --> 00:32:42,106
A very cool resource is also the constructs

513
00:32:42,138 --> 00:32:45,300
hub that you can find under constructs dev.

514
00:32:45,750 --> 00:32:49,650
And this is basically a place where you can search for community

515
00:32:49,800 --> 00:32:52,974
created constructs. So basically libraries

516
00:32:53,022 --> 00:32:57,240
from other people where they already packaged up

517
00:32:57,610 --> 00:33:00,774
some cool constructs and

518
00:33:00,812 --> 00:33:03,446
classes that do certain things for you.

519
00:33:03,548 --> 00:33:06,998
So for example, you could find maybe something like the

520
00:33:07,004 --> 00:33:10,190
Echo server we just built there as a premade

521
00:33:10,210 --> 00:33:13,834
package and then you could import it to your own project and

522
00:33:13,872 --> 00:33:17,242
use it. And do not repeat the same work that other people

523
00:33:17,296 --> 00:33:20,794
did. Also, there are multiple

524
00:33:20,842 --> 00:33:24,666
ways to interact with the community. So CDks

525
00:33:24,778 --> 00:33:28,334
is a CNCF sandbox project and you can read

526
00:33:28,372 --> 00:33:30,800
all about that on the CNCF website.

527
00:33:31,410 --> 00:33:35,474
We also have a slack under CDK dev.

528
00:33:35,672 --> 00:33:39,586
And finally, there's also the CDK day,

529
00:33:39,688 --> 00:33:44,290
which is a community event. So that's not basically

530
00:33:44,360 --> 00:33:48,120
managed by AWS, but really from the open source community

531
00:33:48,570 --> 00:33:51,842
where you can learn all about the whole CDKs

532
00:33:51,906 --> 00:33:56,134
ecosystem. So CDks is not the only tool

533
00:33:56,332 --> 00:34:00,490
in the CDK ecosystem. There are cloud

534
00:34:00,560 --> 00:34:04,518
development kits for AWS and for terraform

535
00:34:04,614 --> 00:34:08,026
and some other cool tools that help you to actually build

536
00:34:08,128 --> 00:34:11,966
cloud infrastructure with real code. And on

537
00:34:11,988 --> 00:34:15,994
the CDK day the community is celebrating these advancements

538
00:34:16,122 --> 00:34:19,840
and you can learn about all the cool stuff you can do in that space.

539
00:34:20,610 --> 00:34:24,574
So with that, I hope you really liked the

540
00:34:24,612 --> 00:34:28,014
idea of using programming languages to

541
00:34:28,052 --> 00:34:30,750
define your Kubernetes deployments.

542
00:34:31,730 --> 00:34:35,640
Let me know if this is something that's interesting for you.

543
00:34:36,010 --> 00:34:39,766
Let me know what experience you

544
00:34:39,788 --> 00:34:43,494
had with that when you tried it out. You can reach me on Twitter and

545
00:34:43,532 --> 00:34:47,426
you can find me on LinkedIn and I would be super thrilled

546
00:34:47,538 --> 00:34:51,350
to learn about your experience there. Thanks a lot and

547
00:34:51,420 --> 00:34:52,100
have a great day.

