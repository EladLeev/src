1
00:00:25,650 --> 00:00:29,410
Hello everyone, I'm Amara from Pakistan. I have been working with Python

2
00:00:29,490 --> 00:00:33,046
for more than six years now, and in today's talk I

3
00:00:33,068 --> 00:00:36,710
will be discussing about some common Python idioms and why it is important

4
00:00:36,780 --> 00:00:40,342
to write pythonic code, how it relates to the quality

5
00:00:40,396 --> 00:00:44,440
of the code, and what tools are available to check for the quality,

6
00:00:44,890 --> 00:00:49,538
or to make sure that your code is following the language guidelines.

7
00:00:49,634 --> 00:00:52,830
Let's get started. First of all, a brief outline.

8
00:00:53,170 --> 00:00:56,910
I will be discussing that what is pythonic and why it is important

9
00:00:56,980 --> 00:01:00,782
to write pythonic code? What is code quality and why it is important

10
00:01:00,836 --> 00:01:04,574
to measure what tools are available for Python programmers to make sure

11
00:01:04,612 --> 00:01:07,854
that their code bases are following Python guidelines.

12
00:01:07,982 --> 00:01:11,522
What is idiomatic Python? And in the end, I will be sharing some common

13
00:01:11,576 --> 00:01:14,562
pythonic idioms which I have learned through over the years.

14
00:01:14,696 --> 00:01:18,914
So let's get started. First of all, what is pythonic?

15
00:01:19,042 --> 00:01:23,186
Any program, function or block of code that follows style guidelines

16
00:01:23,218 --> 00:01:27,046
and make use of Python's unique capabilities or language features is said

17
00:01:27,068 --> 00:01:30,602
to be pythonic code. Snippet writing pythonic code

18
00:01:30,736 --> 00:01:34,090
is important because that determines that your code is

19
00:01:34,160 --> 00:01:37,686
of certain quality and certain standard. It follows

20
00:01:37,718 --> 00:01:41,594
language features and you are adhering to the language standard and industry

21
00:01:41,642 --> 00:01:45,440
standards for that language. It also counts for these

22
00:01:45,970 --> 00:01:49,918
quality of the code. And code quality is getting

23
00:01:50,084 --> 00:01:53,278
important day by day due to scarcity of

24
00:01:53,284 --> 00:01:57,042
the trained resources. Now, when we talk about quality

25
00:01:57,096 --> 00:02:00,514
of the code, what do we mean by that? If you quickly

26
00:02:00,632 --> 00:02:04,654
search through the Google can get to know that what are the attributes

27
00:02:04,702 --> 00:02:08,674
of a good code? Quality good quality code. But we can summarize

28
00:02:08,722 --> 00:02:12,342
them in the following points that it does what it is supposed

29
00:02:12,396 --> 00:02:16,038
to do. A certain code snippet is supposed to perform a

30
00:02:16,044 --> 00:02:19,398
set of basic requirements. If it is not performing those requirements, then it is

31
00:02:19,404 --> 00:02:22,762
not even a bad quality code. So it should be performing what it is supposed

32
00:02:22,816 --> 00:02:26,186
to do. Then there are known defects and problems. For this,

33
00:02:26,208 --> 00:02:29,350
I will take an analogy of these detergent

34
00:02:29,510 --> 00:02:33,550
you use to wash your clothes. If your detergent is working fine

35
00:02:33,620 --> 00:02:36,894
with day to day clothes which are not having any

36
00:02:36,932 --> 00:02:40,766
hard stains, but whenever a hard stain gets

37
00:02:40,868 --> 00:02:44,522
onto your clothes, this detergent cannot perform in

38
00:02:44,596 --> 00:02:48,226
getting rid of that stain, then your detergent is not of

39
00:02:48,248 --> 00:02:51,982
good quality. And the third and most important attribute

40
00:02:52,046 --> 00:02:55,054
of a good quality code is that it is readable,

41
00:02:55,102 --> 00:02:58,950
maintainable and extendable. It should be maintainable and extendable because

42
00:02:59,020 --> 00:03:02,994
over the time, as the requirements change and businesses processes

43
00:03:03,042 --> 00:03:07,030
grow, you have to add new functionality. If you are not able to

44
00:03:07,180 --> 00:03:11,114
extend your existing code, then you will have to rewrite the whole

45
00:03:11,152 --> 00:03:14,746
software again. And it should be readable because it is not necessary that the

46
00:03:14,768 --> 00:03:18,726
person who wrote the software first will be available to maintain

47
00:03:18,758 --> 00:03:22,190
and extend the software forever. You will be hiring new

48
00:03:22,260 --> 00:03:25,834
engineers and it should be readable enough so that new engineers

49
00:03:25,882 --> 00:03:30,062
or new developers can easily understand your code. So why

50
00:03:30,116 --> 00:03:34,330
code quality is important? Code quality is important because of the following reasons.

51
00:03:34,410 --> 00:03:37,794
First of all, clarity. If your code is not of good

52
00:03:37,832 --> 00:03:41,106
quality, then these will not give the clarity to the people who

53
00:03:41,128 --> 00:03:44,226
are working on the code basis. And it will not

54
00:03:44,328 --> 00:03:48,114
give the clarity that how a certain requirement is being accomplished

55
00:03:48,162 --> 00:03:52,146
through the code written. Then the second reason is efficiency.

56
00:03:52,258 --> 00:03:55,430
If your code is of bad quality and it is not

57
00:03:55,500 --> 00:03:58,986
readable, or maintainable or extendable, then the cost of

58
00:03:59,088 --> 00:04:03,018
maintaining such project or extending such project will skyrocket and

59
00:04:03,024 --> 00:04:06,666
your budgets will be affected. And it will not be efficient in

60
00:04:06,688 --> 00:04:10,490
terms of finances and human resources as well.

61
00:04:10,640 --> 00:04:13,886
The third important reason is the credibility. If you are

62
00:04:13,908 --> 00:04:17,694
following certain quality standards while writing your code, then it will add

63
00:04:17,732 --> 00:04:20,906
to your credibility as a programmer. But if you are not following

64
00:04:20,938 --> 00:04:24,494
the standards and guidelines, then your credibility as

65
00:04:24,532 --> 00:04:28,206
a Python programmer will diminish and that will definitely harm

66
00:04:28,238 --> 00:04:31,598
you in the long run. So as Python programmers, what tools

67
00:04:31,614 --> 00:04:35,026
are available to make sure that the code we are writing follows a

68
00:04:35,048 --> 00:04:39,286
certain set of guidelines and is of certain standard quality?

69
00:04:39,388 --> 00:04:42,934
There are a lot of tools available, but I will be discussing the following three

70
00:04:43,052 --> 00:04:46,882
the Zen of Python, pep eight and lenters.

71
00:04:47,026 --> 00:04:50,294
Let's talk about them one by one. Zen of Python.

72
00:04:50,422 --> 00:04:54,374
Zen of Python are basically 20 amorphisms written

73
00:04:54,422 --> 00:04:58,022
by a python. These Tim Peters, he wrote

74
00:04:58,086 --> 00:05:01,782
these beautiful, actually 19 amorphisms and left 20th,

75
00:05:01,846 --> 00:05:05,274
the last one to fill in by the creator of the Python language,

76
00:05:05,322 --> 00:05:08,878
Guido and Rossam. But it's still not filled in. Also,

77
00:05:08,964 --> 00:05:12,566
another Pythonista who has also contributed the Python

78
00:05:12,618 --> 00:05:16,046
language, Barry Warsaw, sang these amorphisms

79
00:05:16,078 --> 00:05:19,266
as lyrics in May 2020. And you can

80
00:05:19,288 --> 00:05:22,594
easily find that song on YouTube by

81
00:05:22,632 --> 00:05:26,686
searching the Zen of Python. This set of guidelines

82
00:05:26,718 --> 00:05:30,786
or this set of amorphisms is also included, as can Easter egg

83
00:05:30,818 --> 00:05:34,438
in the Python distribution. If you go to the Python shell and write

84
00:05:34,524 --> 00:05:38,066
import this, the Zen of Python get printed.

85
00:05:38,178 --> 00:05:42,314
Now, if we look at these morphisms one by one, these are basically a

86
00:05:42,352 --> 00:05:46,022
code set of principles which are being followed while writing the language.

87
00:05:46,086 --> 00:05:49,226
And it is expected from all the programmers using the

88
00:05:49,248 --> 00:05:52,314
language that they follow these simple principles.

89
00:05:52,442 --> 00:05:55,354
Let's start with the beautiful is better than ugly,

90
00:05:55,482 --> 00:05:59,194
because if your code is written beautifully and it's not cluttered,

91
00:05:59,242 --> 00:06:02,334
then it will improve the readability of your code.

92
00:06:02,452 --> 00:06:05,794
Explicit is better than implicit. For this, I will take the use

93
00:06:05,832 --> 00:06:09,854
case of naming the variables used in your code. The variables

94
00:06:09,902 --> 00:06:13,474
used in your code should follow the naming conventions set by

95
00:06:13,512 --> 00:06:17,750
the language, and also the names you are assigning to the variables should

96
00:06:17,820 --> 00:06:21,270
contain the context for which these variables are being used, so that

97
00:06:21,340 --> 00:06:25,222
everybody reading your code can understand that what variable is

98
00:06:25,276 --> 00:06:28,626
holding data for what purposes? Simple is better than

99
00:06:28,668 --> 00:06:31,290
complex and complex is better than complicated.

100
00:06:31,630 --> 00:06:35,654
You should try to use simple language constructs to solve

101
00:06:35,782 --> 00:06:39,226
simple problems. But if you have a complex problem and

102
00:06:39,248 --> 00:06:42,926
you cannot solve it by simple language constructs, then you can

103
00:06:42,948 --> 00:06:47,562
use a complex solution, but it should not be overly complicated.

104
00:06:47,706 --> 00:06:51,326
Flat is better than nested. This means that if

105
00:06:51,348 --> 00:06:55,234
you can avoid the nesting of tools, or you can

106
00:06:55,272 --> 00:06:59,726
achieve something by a flatter piece of code, then you should avoid undue

107
00:06:59,758 --> 00:07:03,406
nesting. One example of this can be avoiding

108
00:07:03,518 --> 00:07:07,138
nested loops by using the product method in iter

109
00:07:07,154 --> 00:07:10,802
tools module. Maybe sparse is better than dense,

110
00:07:10,946 --> 00:07:14,946
so this is related to spaces and indentation

111
00:07:15,138 --> 00:07:18,902
levels. Indentation spaces in the code

112
00:07:18,956 --> 00:07:22,246
base you are dealing with. If it is sparse,

113
00:07:22,278 --> 00:07:25,878
it has more spaces, then it is better for readability because readability

114
00:07:25,974 --> 00:07:29,606
counts. Special cases aren't special enough to break the rules,

115
00:07:29,718 --> 00:07:32,510
although practicality beats purity. Yes,

116
00:07:32,580 --> 00:07:36,410
you should not break the rules of the language to handle

117
00:07:36,490 --> 00:07:40,522
special cases in your project. But if those special cases

118
00:07:40,586 --> 00:07:43,450
cannot be handled without breaking the rules,

119
00:07:43,530 --> 00:07:46,914
then of course you have to follow the practicality. Errors should never

120
00:07:46,952 --> 00:07:49,838
pass silently unless explicitly silenced.

121
00:07:50,014 --> 00:07:53,806
This explains that you should be aware that what errors

122
00:07:53,838 --> 00:07:57,586
are being thrown by your code, and you should explicitly

123
00:07:57,698 --> 00:08:01,206
catch them and determine that what to

124
00:08:01,228 --> 00:08:04,818
do if certain error occurs. But if you want errors

125
00:08:04,914 --> 00:08:08,646
go unnoticed, then it should be explicitly silenced. That means you

126
00:08:08,668 --> 00:08:12,566
should write the catch block for try accept

127
00:08:12,598 --> 00:08:16,566
block, and you can write the pass statement in the accept block to silence

128
00:08:16,598 --> 00:08:20,266
the error. So all these beautiful amorphisms are basically

129
00:08:20,368 --> 00:08:24,046
a code set of principles which you can use to

130
00:08:24,068 --> 00:08:27,562
make sure that your code is following the basic guidelines

131
00:08:27,706 --> 00:08:31,738
recommended by actual Python developers who have contributed

132
00:08:31,754 --> 00:08:35,754
to the language creation like this one. If the implementation

133
00:08:35,802 --> 00:08:39,026
is hard to explain, it's a bad idea. If the implementation is

134
00:08:39,048 --> 00:08:42,658
easy to explain, it may be a good idea, right? So next tool

135
00:08:42,744 --> 00:08:46,454
we can talk about is pep eight. Pep eight are

136
00:08:46,492 --> 00:08:49,666
basically what does pep stands for? PEp stands

137
00:08:49,698 --> 00:08:54,130
for performance enhancement proposals, and we can define these proposals

138
00:08:54,210 --> 00:08:57,834
as the documents to describe new features proposed and

139
00:08:57,872 --> 00:09:01,366
to document different aspects of Python

140
00:09:01,398 --> 00:09:05,114
like performance design and style for the community. These are

141
00:09:05,152 --> 00:09:08,346
basic set of guidelines which your code should

142
00:09:08,368 --> 00:09:12,182
be following. These include stylistic guidelines and naming conventions,

143
00:09:12,246 --> 00:09:15,950
how you should lay out your code, how you should format your code.

144
00:09:16,100 --> 00:09:20,138
We also have such kind of guidelines for the commenting

145
00:09:20,154 --> 00:09:23,806
and doc strings in our Python code as well. That is web two five seven.

146
00:09:23,908 --> 00:09:26,978
So let's look at some of the aspects of web eight.

147
00:09:27,064 --> 00:09:30,338
Let's talk about the code layout one statement per line

148
00:09:30,504 --> 00:09:33,694
you might know that we can write multiple statements

149
00:09:33,742 --> 00:09:37,486
in one line in Python, but we have to separate them by semicolon

150
00:09:37,598 --> 00:09:41,078
if we want multiple lines of code in one line. But it

151
00:09:41,084 --> 00:09:45,046
is strongly recommended that you use one statement per line, and that is the

152
00:09:45,068 --> 00:09:48,202
reason you can get rid of the semicolon at the end of each

153
00:09:48,256 --> 00:09:52,170
statement, which was really error prone in our college

154
00:09:52,240 --> 00:09:55,366
days of c plus plus projects and assignments.

155
00:09:55,558 --> 00:09:59,366
Single point of return while writting Python functions,

156
00:09:59,478 --> 00:10:03,230
you should consider to make sure that your function

157
00:10:03,300 --> 00:10:06,766
is returning from at the end of the function at the single point.

158
00:10:06,868 --> 00:10:11,258
Having multiple point of returns in a function will cause confusion,

159
00:10:11,354 --> 00:10:14,802
it will be more error prone, and for the future developers, it will

160
00:10:14,856 --> 00:10:18,226
difficult to understand that what you are returning from a function

161
00:10:18,328 --> 00:10:22,078
in every scenario indentation we know that Python

162
00:10:22,174 --> 00:10:26,606
syntax is strongly dependent upon the indentation.

163
00:10:26,798 --> 00:10:30,306
We can use two spaces per indentation level and four spaces

164
00:10:30,338 --> 00:10:33,746
per indentation level as well, but it is recommended

165
00:10:33,778 --> 00:10:37,526
that we should use four spaces per indentation level if you

166
00:10:37,548 --> 00:10:40,934
remember that sparse is better than dense from the Zen of Python.

167
00:10:40,982 --> 00:10:44,362
So if you are using four spaces then your code will be a little bit

168
00:10:44,416 --> 00:10:47,594
sparse and it will be more readable. Tabs or

169
00:10:47,632 --> 00:10:51,318
spaces for indentation you can use tabs or spaces.

170
00:10:51,414 --> 00:10:55,374
Tabs is of eight characters by default, but you can modify it

171
00:10:55,412 --> 00:10:59,946
to consist of only four characters. But by the Python creators

172
00:10:59,978 --> 00:11:03,662
it is recommended that spaces should be used for indentation instead

173
00:11:03,716 --> 00:11:07,490
of tabs maximum line length so this is

174
00:11:07,560 --> 00:11:11,374
kind of a strange requirement. But if you think about this requirement,

175
00:11:11,502 --> 00:11:14,914
then you get to know that these limit of 79

176
00:11:14,952 --> 00:11:18,962
characters for a single line of code in a Python editor

177
00:11:19,026 --> 00:11:23,174
is actually because that you don't have to scroll from left to right again

178
00:11:23,212 --> 00:11:26,406
and again to read only one line of code. So it

179
00:11:26,428 --> 00:11:29,974
is limited to 79 characters only, and for the

180
00:11:30,012 --> 00:11:33,194
comments and doc strings it is further limited to

181
00:11:33,232 --> 00:11:36,762
72 characters only. In web two five seven. You can find

182
00:11:36,816 --> 00:11:40,574
the guidelines for writing comments and doc strings in your Python code

183
00:11:40,612 --> 00:11:44,302
as well. Python has a rich libraries available

184
00:11:44,436 --> 00:11:49,130
to its programmers through which you can achieve various

185
00:11:49,290 --> 00:11:53,040
features and various tasks readily available.

186
00:11:53,490 --> 00:11:57,598
So to use these libraries you have to import those modules

187
00:11:57,614 --> 00:12:01,374
and libraries in your code. So it is recommended to include

188
00:12:01,422 --> 00:12:04,818
all the imports used in your code scripts at the top of

189
00:12:04,824 --> 00:12:08,182
the file and each import should be at a separate line.

190
00:12:08,236 --> 00:12:12,226
Multiple imports should not be included at single line. Wildcard imports

191
00:12:12,258 --> 00:12:16,274
are discouraged. Wildcard imports where you are importing everything from a module

192
00:12:16,322 --> 00:12:20,134
like import static is highly discouraged. There are further rules

193
00:12:20,182 --> 00:12:23,686
that you should include these modules

194
00:12:23,718 --> 00:12:27,658
from the standard library distribution at the top. Then you

195
00:12:27,664 --> 00:12:30,998
should include any third party libraries and at the end you

196
00:12:31,024 --> 00:12:34,160
should mention the imports which you are using from your own project.

197
00:12:34,850 --> 00:12:38,634
String quotes in Python you can define

198
00:12:38,682 --> 00:12:42,874
string rituals by single quote or double quote both. What is recommended

199
00:12:42,922 --> 00:12:46,402
whether we use single quote or double quote, you can use any of them single

200
00:12:46,456 --> 00:12:49,586
or double, but it is recommended that whatever you choose, you should

201
00:12:49,608 --> 00:12:53,490
be consistent throughout your code base. All your programmers should be

202
00:12:53,560 --> 00:12:56,966
aware that you should only use single quote or

203
00:12:56,988 --> 00:13:00,294
double quote to define string literals anywhere in your project.

204
00:13:00,412 --> 00:13:03,746
Another aspect of style guidelines

205
00:13:03,778 --> 00:13:07,126
I would like to cover here is naming conventions for

206
00:13:07,228 --> 00:13:10,918
different constructs of the language. First of all, packages and modules.

207
00:13:11,014 --> 00:13:14,378
These should be named all lowercase, and you should use

208
00:13:14,464 --> 00:13:17,190
short names. Underscore can be used for readability,

209
00:13:17,270 --> 00:13:20,554
but using the underscore is discouraged. Examples are

210
00:13:20,592 --> 00:13:24,106
like pandas models, iter tools, et cetera.

211
00:13:24,218 --> 00:13:27,946
Then we have classes. For classes we can use passport

212
00:13:27,978 --> 00:13:31,694
case which is in it caps as well. We should not

213
00:13:31,732 --> 00:13:35,438
include the world class while naming any class object.

214
00:13:35,524 --> 00:13:39,074
For example, if you want to define an employee class or

215
00:13:39,112 --> 00:13:42,434
student class, we should only name it as employee or

216
00:13:42,472 --> 00:13:45,966
student, not employee class and student class. The class keyword

217
00:13:46,078 --> 00:13:50,034
should not be included in the name of the class. Exception names exceptions

218
00:13:50,082 --> 00:13:53,750
are actually classes in Python, so the name is

219
00:13:53,820 --> 00:13:57,138
same. Naming rules applies, but using suffix error

220
00:13:57,154 --> 00:14:00,682
is recommended to make it explicit that this class is of

221
00:14:00,736 --> 00:14:04,234
exception like limit not expired error type error name

222
00:14:04,272 --> 00:14:07,478
error, et cetera. So error suffix readily tells

223
00:14:07,494 --> 00:14:10,342
you that this class is handling some kind of exception.

224
00:14:10,406 --> 00:14:14,202
It is not a regular class. Constants for this use all

225
00:14:14,256 --> 00:14:17,514
k apps snake case for example, database underscore URL,

226
00:14:17,562 --> 00:14:20,138
API key or base underscore URL.

227
00:14:20,234 --> 00:14:23,946
Like any other programming languages, constants are recommended

228
00:14:23,978 --> 00:14:27,870
to use all caps, nakes, functions, and variables.

229
00:14:27,950 --> 00:14:31,650
These can use standard snake case for example, all lower

230
00:14:31,720 --> 00:14:35,038
better, and you can use underscores to separate out the

231
00:14:35,064 --> 00:14:38,178
words in the names to make them more readable.

232
00:14:38,274 --> 00:14:41,430
For example, def final underscore score team

233
00:14:41,500 --> 00:14:44,854
underscore score like this function or

234
00:14:44,892 --> 00:14:48,086
method arguments. Now the arguments which are being passed to the

235
00:14:48,108 --> 00:14:51,562
functions or class methods. Those follow

236
00:14:51,616 --> 00:14:55,990
the same naming rules as the variables, but if you are writing

237
00:14:56,070 --> 00:14:59,386
an instance method, then its first argument should be self.

238
00:14:59,488 --> 00:15:03,674
If you are defining a class method, then its first argument should be CLS,

239
00:15:03,722 --> 00:15:07,610
that is class. And if you have clash

240
00:15:07,690 --> 00:15:11,658
with any of the keywords of the language, then you can use a trailing underscore

241
00:15:11,674 --> 00:15:14,978
to avoid this clash. For example, if you have a class in which

242
00:15:15,064 --> 00:15:18,562
you have an attribute which is named class, you should use

243
00:15:18,696 --> 00:15:22,674
it as class underscore instead of like misspelling it

244
00:15:22,712 --> 00:15:27,054
clss or clas. This is not recommended.

245
00:15:27,182 --> 00:15:31,314
Methods and instance variables for methods instance variables,

246
00:15:31,362 --> 00:15:35,874
same naming rules applies as of functions, but to segregate

247
00:15:35,922 --> 00:15:39,314
public and non public instance variables and methods,

248
00:15:39,362 --> 00:15:42,922
one leading underscore is used for non public and to avoid parent

249
00:15:42,976 --> 00:15:46,442
child clashes, we can use two leading underscore if we have same

250
00:15:46,496 --> 00:15:49,930
name variables and methods in parent and child both.

251
00:15:50,080 --> 00:15:53,994
The next rule I want to talk about is lenters. So before talking

252
00:15:54,032 --> 00:15:57,374
about lenders, I would like to take

253
00:15:57,492 --> 00:16:01,214
another analogy and describe about that.

254
00:16:01,252 --> 00:16:05,330
What is lint? Lint is actually the small particles

255
00:16:05,670 --> 00:16:09,374
which get stuck to our clothes when we wash them in washing

256
00:16:09,422 --> 00:16:13,554
machines. And that really is annoying that your

257
00:16:13,672 --> 00:16:17,830
clothes are instead of getting cleaned, they actually

258
00:16:17,900 --> 00:16:21,746
get dirty with those small particles stuck

259
00:16:21,778 --> 00:16:25,334
to them for their solution. For the solution of this problem,

260
00:16:25,452 --> 00:16:28,742
all the washing machines in our houses, we have lint filters

261
00:16:28,806 --> 00:16:32,186
installed which collect all these small particles, and your clothes come

262
00:16:32,208 --> 00:16:35,030
out neat and clean as required.

263
00:16:35,190 --> 00:16:38,714
So linter is basically a tool which

264
00:16:38,752 --> 00:16:42,430
collects the small particles or small defects or small

265
00:16:42,580 --> 00:16:46,526
unwanted things from your code base to make

266
00:16:46,548 --> 00:16:50,746
it more readable, more maintainable, and more extendable.

267
00:16:50,858 --> 00:16:54,318
In programming languages or in programming projects,

268
00:16:54,414 --> 00:16:57,630
we have two kinds of lint. One is logical lint.

269
00:16:57,710 --> 00:17:01,518
It includes code errors, dangerous code patterns,

270
00:17:01,614 --> 00:17:05,266
and code with potentially unintended results. Other type of

271
00:17:05,288 --> 00:17:08,502
lint is stylistic lint. This involves around code

272
00:17:08,556 --> 00:17:10,946
not conforming to conventions and style guides.

273
00:17:11,058 --> 00:17:14,470
So for making sure that these

274
00:17:14,540 --> 00:17:18,314
two kinds of lints are not present in your code basis, there are

275
00:17:18,352 --> 00:17:21,914
certain linters available in the Python ecosystem. Some are

276
00:17:21,952 --> 00:17:25,286
implicit and some are explicit. The linters

277
00:17:25,318 --> 00:17:28,886
of Python while writing or creating our projects,

278
00:17:28,918 --> 00:17:33,034
we all use certain ide for developing the Python projects. So ides

279
00:17:33,082 --> 00:17:36,890
are also a kind of linter which includes

280
00:17:36,970 --> 00:17:40,906
implicit filters or implicit linters to make sure that you are adhering

281
00:17:40,938 --> 00:17:44,830
to some basic set of guidelines adopted by the language.

282
00:17:44,990 --> 00:17:48,734
But these linters are basically mostly of stylistic

283
00:17:48,782 --> 00:17:52,738
type. Another example is pilot. This module is a

284
00:17:52,824 --> 00:17:55,982
linter which catches logical and stylistic errors.

285
00:17:56,126 --> 00:18:00,054
Then we have code style. This is purely stylistic, and it

286
00:18:00,092 --> 00:18:03,938
purely follows the pep eight guidelines. Then we have py doc style

287
00:18:04,034 --> 00:18:08,354
to make sure it is also stylistic and it follows the guidelines

288
00:18:08,402 --> 00:18:11,642
mentioned in pep two five seven and it purely checks only

289
00:18:11,696 --> 00:18:15,334
for the comments and doc strings in your code. Then we have PI

290
00:18:15,382 --> 00:18:18,794
flakes. This is purely logic. So how to use these

291
00:18:18,832 --> 00:18:22,194
linters? Ides have implicit id linters.

292
00:18:22,262 --> 00:18:25,870
You don't have to do anything, but all other linters you can

293
00:18:25,940 --> 00:18:29,806
quickly install them through pip install command and then

294
00:18:29,908 --> 00:18:33,534
you can write the command module name pylint and the file name.

295
00:18:33,652 --> 00:18:36,990
Press enter and you will have the list of errors and warnings

296
00:18:37,070 --> 00:18:41,074
which you should be looking at to make your python code more

297
00:18:41,112 --> 00:18:44,626
readable and more maintainable. The next question which

298
00:18:44,648 --> 00:18:48,178
comes to our mind that when to check or when to apply the linters to

299
00:18:48,184 --> 00:18:51,734
our code basis. So for first choices as you write it,

300
00:18:51,772 --> 00:18:55,602
you have written a small piece of code, a small function, a small code snippet.

301
00:18:55,666 --> 00:18:59,178
Just apply the linter, get the stuff done and

302
00:18:59,264 --> 00:19:02,458
you can get the errors corrected and you are done.

303
00:19:02,544 --> 00:19:06,054
The other option is when it's checked into the version

304
00:19:06,102 --> 00:19:10,086
control system. Usually developers check in their codes

305
00:19:10,118 --> 00:19:13,686
at the end of the day. So it is a nice idea to spare

306
00:19:13,798 --> 00:19:17,086
half an hour at the end of the day to apply the linters and make

307
00:19:17,108 --> 00:19:20,926
sure that the errors voted by the linter are resolved. And then you just check

308
00:19:20,948 --> 00:19:24,514
in the code to the version control system. The last option is when running

309
00:19:24,552 --> 00:19:28,206
your tests. This option is viable because you don't

310
00:19:28,238 --> 00:19:32,066
have to apply the linters every day or multiple times in

311
00:19:32,088 --> 00:19:36,326
a day. You will be just applying the linters by only

312
00:19:36,428 --> 00:19:39,714
twice or twice during the sprint cycles,

313
00:19:39,842 --> 00:19:43,186
but this will result in more effort

314
00:19:43,218 --> 00:19:46,834
in resolving the errors reported by these lenders. So in my opinion,

315
00:19:46,882 --> 00:19:50,234
the best choice is to use the option of when

316
00:19:50,272 --> 00:19:53,226
it's checked in. At the end of the day, when you are checking in your

317
00:19:53,248 --> 00:19:56,618
code, apply the linter, fix these errors, and get

318
00:19:56,704 --> 00:20:00,454
these desired code quality with minimum

319
00:20:00,502 --> 00:20:04,458
effort. Now I would like to talk about idiomatic Python.

320
00:20:04,634 --> 00:20:08,254
Before talking about idiomatic Python, let's see that.

321
00:20:08,292 --> 00:20:11,594
What do we mean by the idioms? An idiom is a phrase

322
00:20:11,642 --> 00:20:15,674
that doesn't make literal sense, but makes sense once you are acquainted

323
00:20:15,802 --> 00:20:19,006
with the culture in which it arose. So it doesn't have any literal meaning,

324
00:20:19,038 --> 00:20:22,402
it just acquires the meaning from its surroundings or the culture it is being used

325
00:20:22,456 --> 00:20:26,050
in. Similarly, for programming, an idiom is

326
00:20:26,120 --> 00:20:30,434
a thing you do daily for development in a particular language that are familiar

327
00:20:30,482 --> 00:20:33,654
and meaningful to those who work in these same language. So basically,

328
00:20:33,772 --> 00:20:37,154
idioms are certain language constructs, language features,

329
00:20:37,202 --> 00:20:40,586
or language rules which all the programmers working in

330
00:20:40,608 --> 00:20:44,266
that language follow to make sure that everyone is on

331
00:20:44,288 --> 00:20:47,894
the same page. Now let's look at some common Python

332
00:20:47,942 --> 00:20:52,090
idioms. First of all, swap variables without using temp variables

333
00:20:52,170 --> 00:20:56,014
if you remember your college days when we used to program in c plus

334
00:20:56,052 --> 00:20:59,150
plus to swap the values of two variables,

335
00:21:00,850 --> 00:21:04,346
we'll define a temp variable, assign the first variable to it, and assign

336
00:21:04,378 --> 00:21:07,954
the second variable to first variable, and then the temp variable to the second

337
00:21:07,992 --> 00:21:11,326
variable. So one, two, and three lines of code just to swap

338
00:21:11,358 --> 00:21:14,626
the values of the two variables. But in Python you can do

339
00:21:14,648 --> 00:21:18,386
it simple in one line of code just by swapping

340
00:21:18,418 --> 00:21:21,986
the order of the variables at both sides

341
00:21:22,018 --> 00:21:25,910
of the assignment operator. Do not compare directly to singletons like

342
00:21:25,980 --> 00:21:29,890
true, false, none, or zero. These are actually boolean literals,

343
00:21:29,970 --> 00:21:33,166
so you don't have to check them with the equality sign. The known

344
00:21:33,218 --> 00:21:36,646
idiomatic code will be checking these literals as if foo equal

345
00:21:36,678 --> 00:21:40,746
to equal to true, but the idiomatic python will be checking it like

346
00:21:40,928 --> 00:21:44,474
true or false as it is if foo is none.

347
00:21:44,602 --> 00:21:48,382
So this is the idiomatic way. Use is not instead of

348
00:21:48,436 --> 00:21:52,174
not is not is actually not intuitive and

349
00:21:52,292 --> 00:21:55,950
also confusing. If you are checking for negation,

350
00:21:56,030 --> 00:21:59,682
then you should be using is not operator instead of not

351
00:21:59,736 --> 00:22:03,234
is. The non idiomatic way is if not, foo is

352
00:22:03,272 --> 00:22:06,946
none. So this is not making sense. But the idiomatic way

353
00:22:06,968 --> 00:22:10,962
is if foo is not none. This is easy to understand. This is plain English

354
00:22:11,026 --> 00:22:14,886
and completely readable to anybody. Empty sequences are

355
00:22:14,908 --> 00:22:19,270
also false. This includes empty list, empty dictionary, or empty tuples.

356
00:22:19,350 --> 00:22:23,450
So these empty sequences also behave like just

357
00:22:23,600 --> 00:22:26,970
false Boolean literal, and you can check them in your code.

358
00:22:27,040 --> 00:22:30,646
As we treat the Boolean literals like if empty

359
00:22:30,678 --> 00:22:34,254
list, empty square brackets, repeating variable name and if

360
00:22:34,292 --> 00:22:38,154
statement. So let's take an example in non

361
00:22:38,202 --> 00:22:41,646
idiomatic way. We have a name Tom, and we want to check that

362
00:22:41,668 --> 00:22:45,102
if it is a generic name or not, or more commonly used name or not,

363
00:22:45,156 --> 00:22:48,446
then we will be checking if name equal to tom or name equal

364
00:22:48,478 --> 00:22:51,954
to dick or name equal to Harry. If it is one of them, then set

365
00:22:51,992 --> 00:22:55,774
these is generic name to be true. But what is the idiomatic

366
00:22:55,822 --> 00:22:59,830
way? Idiomatic way is to use the in operator.

367
00:23:00,330 --> 00:23:04,034
The name we want to check is Tom and we have a flag is generic

368
00:23:04,082 --> 00:23:07,926
name. We are checking it with the assignment operator. Name in

369
00:23:08,028 --> 00:23:11,494
true or false is returned through

370
00:23:11,532 --> 00:23:15,050
this in operator, and that is getting assigned to is generic name.

371
00:23:15,120 --> 00:23:18,778
So 1234 lines of code is collapsed two

372
00:23:18,864 --> 00:23:21,934
two lines of code only for loops in other

373
00:23:21,972 --> 00:23:26,826
programming languages, a typical way to write a for loop is define

374
00:23:26,858 --> 00:23:30,554
a variable, set it to zero, check for the container length

375
00:23:30,602 --> 00:23:33,854
and increment it in every iteration and in the curly brackets.

376
00:23:33,982 --> 00:23:37,262
Do whatever you want to do. In Python.

377
00:23:37,406 --> 00:23:41,422
You can achieve the same functionality by this code snippet

378
00:23:41,486 --> 00:23:45,470
for I in range length of my underscore list. Range function

379
00:23:45,640 --> 00:23:49,186
will be starting from zero to length and increment

380
00:23:49,378 --> 00:23:52,678
by one in every iteration. But what is

381
00:23:52,684 --> 00:23:56,274
the idiomatic way? The idiomatic way is to use the python

382
00:23:56,322 --> 00:23:59,926
in operator. That is for element in my underscore

383
00:23:59,958 --> 00:24:04,374
list and you are done. You don't have to worry about these maintaining

384
00:24:04,422 --> 00:24:07,606
the loop counter by yourself looping

385
00:24:07,638 --> 00:24:10,794
backwards again. In other programming languages, you will be

386
00:24:10,832 --> 00:24:14,986
starting the loop counter from the length and decrementing

387
00:24:15,018 --> 00:24:18,586
it in every iteration until you reach the zero. In Python,

388
00:24:18,698 --> 00:24:22,686
you can achieve this through this code snippet. Again, the range function.

389
00:24:22,788 --> 00:24:26,286
You will be starting with the length of list and writting

390
00:24:26,318 --> 00:24:29,666
the step to minus one for every iteration. What is

391
00:24:29,688 --> 00:24:33,310
the idiomatic way? The idiomatic way is to use reversed

392
00:24:33,390 --> 00:24:37,154
for element in reversed my underscore list. This is more efficient

393
00:24:37,202 --> 00:24:40,518
and more readable. Any layman can understand

394
00:24:40,604 --> 00:24:44,326
that we are traversing the list in the reverse order

395
00:24:44,508 --> 00:24:47,958
tracking index of for loop. What is the non idiomatic way?

396
00:24:48,044 --> 00:24:51,846
You will define a counter, set it to zero, and in each iteration

397
00:24:51,878 --> 00:24:56,102
you will be incrementing it one as you go through these list of elements.

398
00:24:56,246 --> 00:25:00,018
What is the idiomatic way? Use enumerate by enumerate

399
00:25:00,054 --> 00:25:03,454
you will get the index and element every time you

400
00:25:03,492 --> 00:25:07,838
read an element from the container list using

401
00:25:07,924 --> 00:25:11,914
for else syntax. This is actually a very interesting Python idiom

402
00:25:11,962 --> 00:25:14,878
and I got to know about it very late.

403
00:25:15,054 --> 00:25:18,754
But these it is. Let's take an example that

404
00:25:18,792 --> 00:25:22,450
we have certain users and we want to check that whether any

405
00:25:22,520 --> 00:25:26,260
user has entered his address or not. So we write

406
00:25:26,790 --> 00:25:29,958
this code snippet. We define a flag, traverse over the

407
00:25:29,964 --> 00:25:33,298
users, check if the user has entered the address. We set the flag

408
00:25:33,314 --> 00:25:36,854
to true and break the loop because we have found that at least

409
00:25:36,892 --> 00:25:40,198
one user has entered the address and at the end of

410
00:25:40,204 --> 00:25:43,626
the code we check for the flag to get to know that whether address was

411
00:25:43,648 --> 00:25:47,434
entered or not. So what is the idiomatic way? The idiomatic way

412
00:25:47,472 --> 00:25:50,714
is to use else clause for the for loop. Yes.

413
00:25:50,832 --> 00:25:54,318
Here is the code snippet. For each user we are checking that whether the

414
00:25:54,324 --> 00:25:58,058
user has entered the address if it has entered the address, we are printing

415
00:25:58,074 --> 00:26:01,806
our message and we are breaking out of the loop. But if the

416
00:26:01,828 --> 00:26:05,746
loop terminates by executing all its iterations and

417
00:26:05,768 --> 00:26:09,390
we have not found any address. Then we are coming to the else clause.

418
00:26:09,470 --> 00:26:13,394
So else clause is executed whenever the loop terminates by

419
00:26:13,432 --> 00:26:17,458
completing all its iterations. Otherwise we will be breaking in

420
00:26:17,544 --> 00:26:20,806
when we found the address using iter to

421
00:26:20,828 --> 00:26:24,086
check for sentinel value. So let's take an example. Over here we

422
00:26:24,108 --> 00:26:28,018
have a file which we want to read in chunks of 32 bytes.

423
00:26:28,114 --> 00:26:31,930
For that we are writing this code snippet. We have

424
00:26:32,080 --> 00:26:35,846
a list, and while we are not reaching

425
00:26:35,878 --> 00:26:38,982
the end of the file, we have not the empty chunk.

426
00:26:39,126 --> 00:26:42,338
We are reading 32 bytes in every iteration

427
00:26:42,374 --> 00:26:46,142
and appending it to list. What is the better way?

428
00:26:46,276 --> 00:26:49,582
The better way is to use the iter function.

429
00:26:49,716 --> 00:26:53,386
Again, we have defined a list in which we will be appending our chunks

430
00:26:53,418 --> 00:26:56,978
of 32 bytes, but we will be using the iter function

431
00:26:57,144 --> 00:27:00,606
in which we can give the sentinel value. Yes, the iter

432
00:27:00,638 --> 00:27:04,162
function can iterate over the list of elements and

433
00:27:04,216 --> 00:27:08,882
also can check for the sentinel value. Two break out of the iterations.

434
00:27:09,026 --> 00:27:13,160
It is better because it is more efficient. And yes,

435
00:27:13,610 --> 00:27:16,998
the first argument of the iter function is a function

436
00:27:17,164 --> 00:27:20,474
with no arguments for that. We are using the partial function which

437
00:27:20,512 --> 00:27:25,302
can reduce any function to zero. Arguments strings

438
00:27:25,446 --> 00:27:28,666
while using strings, we should use string method instead of the

439
00:27:28,688 --> 00:27:32,250
string module because they are fast and more efficient.

440
00:27:32,830 --> 00:27:36,302
We should use dot starts with and dot ends with

441
00:27:36,356 --> 00:27:39,994
instead of slicing for prefix or suffix checking.

442
00:27:40,122 --> 00:27:43,482
Why? Because slicing is more error prone

443
00:27:43,546 --> 00:27:47,502
and using starts with the ends with is less prone to errors.

444
00:27:47,646 --> 00:27:51,442
We should be using dot join while creating strings from list elements instead

445
00:27:51,496 --> 00:27:55,394
of using the plus operator. Yes, the non idiomatic way is to

446
00:27:55,432 --> 00:27:59,414
use for loop and a plus equal operator to

447
00:27:59,452 --> 00:28:03,158
every time concatenate the element two the string. But the

448
00:28:03,164 --> 00:28:06,534
idiomatic way is just to use the join method by

449
00:28:06,572 --> 00:28:10,214
passing the argument of the list to be concatenated

450
00:28:10,342 --> 00:28:13,862
context manager. These are the beautiful python language

451
00:28:13,926 --> 00:28:18,026
constructs. These are the objects to be used with the with statement, and these

452
00:28:18,128 --> 00:28:21,514
objects make resource management more explicit and safer.

453
00:28:21,642 --> 00:28:25,374
It separates business logic from administrative logic and

454
00:28:25,492 --> 00:28:29,246
make the writing business logic made more easy.

455
00:28:29,348 --> 00:28:32,846
Let's take an example. We want to read a file. For that we

456
00:28:32,868 --> 00:28:36,146
have to open the file. Then we'll read the file and these we have to

457
00:28:36,168 --> 00:28:39,598
explicitly close the file. But with the help of context managers

458
00:28:39,694 --> 00:28:43,314
you will not be bothering about closing the file explicitly use

459
00:28:43,352 --> 00:28:46,670
the with open context manager read the file

460
00:28:46,750 --> 00:28:50,706
and you are done. The with context manager automatically closes

461
00:28:50,738 --> 00:28:54,102
the file when you are done reading the file. Let's look at some of the

462
00:28:54,156 --> 00:28:57,606
other examples of context managers. Another example

463
00:28:57,708 --> 00:29:02,042
is, while we are using threading, for using

464
00:29:02,096 --> 00:29:05,590
threads we have to acquire log first log equal to threading

465
00:29:05,670 --> 00:29:08,934
log acquire, and then we execute a critical

466
00:29:08,982 --> 00:29:12,134
section. And in the finally block we have to explicitly

467
00:29:12,182 --> 00:29:15,998
release the lock. But with the context managers the better because

468
00:29:16,084 --> 00:29:19,626
you don't have to explicitly release the lock because if you forget

469
00:29:19,658 --> 00:29:23,834
to release the lock, you will be in a great mess. So with idiomatic Python

470
00:29:23,882 --> 00:29:27,482
or Python language constructs of context managers,

471
00:29:27,626 --> 00:29:31,822
you will just be acquiring the clock lock, and with lock context

472
00:29:31,886 --> 00:29:35,686
manager you will read the execute the recurring section and

473
00:29:35,708 --> 00:29:39,522
you are done. As you will be getting out of the context

474
00:29:39,586 --> 00:29:43,190
manager block, it will automatically release the log for you.

475
00:29:43,340 --> 00:29:46,534
Another example is you

476
00:29:46,572 --> 00:29:49,686
want to remove a certain file from your system,

477
00:29:49,868 --> 00:29:53,494
but what if that file doesn't exist? Your code will error

478
00:29:53,542 --> 00:29:57,546
out. So for that you will have to use the try accept block and

479
00:29:57,568 --> 00:30:00,714
cache the OS error. Whether you want to do something with it or not,

480
00:30:00,752 --> 00:30:03,566
it's up to you. But what is the better way? The better way is to

481
00:30:03,588 --> 00:30:07,130
use the ignored context manager with ignored

482
00:30:07,210 --> 00:30:10,606
and you specify the OS error and remove the

483
00:30:10,628 --> 00:30:14,462
file from your computer. Yes, we are not ignoring the errors,

484
00:30:14,526 --> 00:30:18,558
we are capturing the error with context manager with ignored

485
00:30:18,654 --> 00:30:22,980
and we are specifying that it is an OS error. Yes, we are

486
00:30:23,430 --> 00:30:27,010
passing it silently, implicitly silencing

487
00:30:27,090 --> 00:30:30,486
it. Other examples of context manager includes changing the

488
00:30:30,508 --> 00:30:34,086
standard output to a file instead of computer screens or

489
00:30:34,108 --> 00:30:38,754
monitors or lcds. For this you can use redirect

490
00:30:38,802 --> 00:30:42,122
sd out context manager. You will specify the file, and once

491
00:30:42,176 --> 00:30:45,514
you are done writing to the file, it will automatically shift back

492
00:30:45,552 --> 00:30:49,050
to the standard output of your computer. Another example

493
00:30:49,120 --> 00:30:52,686
is modifying some variable in temporary context. For that

494
00:30:52,788 --> 00:30:56,714
you will be using the local context context manager,

495
00:30:56,762 --> 00:31:00,682
and when you are done working in a temporary context, the context

496
00:31:00,746 --> 00:31:04,010
manager will shift back two the original context you

497
00:31:04,020 --> 00:31:07,694
were working in. Lists are an important data structure in Python

498
00:31:07,742 --> 00:31:11,266
language, so a lot of Python idioms are around

499
00:31:11,368 --> 00:31:15,378
these data structure. Let's talk about some of them. Creating a

500
00:31:15,384 --> 00:31:18,726
length and list of the same thing. How can you do this?

501
00:31:18,828 --> 00:31:22,994
One way to do this is by implementing a for loop.

502
00:31:23,122 --> 00:31:26,950
But in idiomatic python you can use the Python list

503
00:31:27,020 --> 00:31:30,678
static operator to create simple and nested lists

504
00:31:30,774 --> 00:31:34,182
of the same value. Let's look at the code snippet.

505
00:31:34,246 --> 00:31:37,402
Yes, you want to have a list of length five with

506
00:31:37,456 --> 00:31:41,518
every element set to hello. You can just write list equal to

507
00:31:41,604 --> 00:31:46,058
square brackets hello static five, and you can also create nested lists

508
00:31:46,154 --> 00:31:49,614
in the same fashion. List unpacking this is also a

509
00:31:49,652 --> 00:31:53,354
beautiful construct. You also use the static

510
00:31:53,402 --> 00:31:57,486
operator to represent the rest of the list instead of slicing because we have discussed

511
00:31:57,518 --> 00:32:01,298
earlier that slicing is more error prone. It is also a very

512
00:32:01,464 --> 00:32:04,110
nice and beautiful construct of the language,

513
00:32:04,190 --> 00:32:07,446
but in managing the indexes is really

514
00:32:07,548 --> 00:32:10,902
error prone and it is also less readable. The future

515
00:32:10,956 --> 00:32:14,246
programmers working on your code will not be

516
00:32:14,268 --> 00:32:17,542
able to understand that, why you are chunking out certain amount

517
00:32:17,596 --> 00:32:20,826
of data and what it is being used for. So what

518
00:32:20,848 --> 00:32:24,742
is the non edomatic way? You have a list abcde.

519
00:32:24,886 --> 00:32:28,486
You are only interested in first and second element and you're

520
00:32:28,518 --> 00:32:32,382
not interested in the rest of the list. So you'll assign some

521
00:32:32,436 --> 00:32:35,578
underscore list of zero index element to the first variable,

522
00:32:35,754 --> 00:32:39,102
second index variable element to the

523
00:32:39,156 --> 00:32:42,862
second variable, and the rest of the list two the rest variable through

524
00:32:42,996 --> 00:32:46,566
specifying the slicing index two columns. Similarly,

525
00:32:46,618 --> 00:32:49,826
you can be interested in the first and last only, and you

526
00:32:49,848 --> 00:32:53,266
are not interested in the middle of the list, and then you are interested

527
00:32:53,368 --> 00:32:57,378
in the middle element only and not in the head

528
00:32:57,464 --> 00:33:00,902
part or the last part. So this was a non idiomatic way.

529
00:33:00,956 --> 00:33:04,818
What is the idiomatic way? Idiomatic way is to use the static operator.

530
00:33:04,914 --> 00:33:08,486
Through static operator you will specify the variables which you want to

531
00:33:08,508 --> 00:33:12,142
extract and a garbage variable with static

532
00:33:12,226 --> 00:33:16,022
assigned to it. And on the right hand side of the assignment operator

533
00:33:16,086 --> 00:33:19,306
you will just write down the name of the list from which you want to

534
00:33:19,328 --> 00:33:23,502
extract these elements. So 1st 2nd static rest equals to

535
00:33:23,556 --> 00:33:27,566
some underscore list. The other two options can be

536
00:33:27,588 --> 00:33:32,026
followed out as above. Another option is using underscore

537
00:33:32,058 --> 00:33:36,162
as placeholder or throwaway variable. If you don't want to use

538
00:33:36,296 --> 00:33:40,114
any part of the list in the future, you can just replace the variable name

539
00:33:40,152 --> 00:33:43,970
with the underscore and that will not be accessible for future users.

540
00:33:44,310 --> 00:33:47,366
List comprehensions List comprehensions provides a

541
00:33:47,388 --> 00:33:50,754
concise and easy way to create transform and filter lists.

542
00:33:50,882 --> 00:33:54,950
These consist of brackets containing an expression followed by for

543
00:33:55,100 --> 00:33:58,806
and a conditional if clause. For and

544
00:33:58,828 --> 00:34:02,426
if clauses can change places. This means that you

545
00:34:02,448 --> 00:34:05,738
can write for first and then the condition, or you

546
00:34:05,744 --> 00:34:09,974
can write the condition first and then the iterator. It always returns

547
00:34:10,022 --> 00:34:13,470
result as a new list and the actual list is not modified.

548
00:34:14,050 --> 00:34:17,566
So the basic syntax according to these above rules is

549
00:34:17,668 --> 00:34:21,118
like expressions which we need to apply to every element of the list.

550
00:34:21,204 --> 00:34:25,002
Then we have an iterator, then we have a conditional. Another option

551
00:34:25,076 --> 00:34:29,154
is to switch these conditionals and iterator. Let's look

552
00:34:29,192 --> 00:34:32,850
at some of the examples. Double the value of each element in a list.

553
00:34:32,920 --> 00:34:36,286
What is the non idiomatic way you will write a for loop

554
00:34:36,318 --> 00:34:39,942
and for each item you will multiplying it by two. In this case

555
00:34:39,996 --> 00:34:43,782
you will be modifying the actual list and doubling the elements in the

556
00:34:43,836 --> 00:34:47,826
actual list. The idiomatic way is to use the list comprehension.

557
00:34:47,938 --> 00:34:51,798
We have a list. This is the expression x. Direct two is the impression

558
00:34:51,894 --> 00:34:55,274
for x. In ARR, this is the iterator and here

559
00:34:55,312 --> 00:34:58,666
we don't have any condition so this is more concise and beautiful way

560
00:34:58,688 --> 00:35:02,198
to create list. And a new list is being created and signed

561
00:35:02,214 --> 00:35:05,710
to ar. The actual list is not being changed.

562
00:35:06,050 --> 00:35:09,566
Another example, double the value for every even element in a

563
00:35:09,588 --> 00:35:13,018
list. So these non idiomatic way is again write a loop,

564
00:35:13,114 --> 00:35:16,546
check for every item that it is even or not and multiply the

565
00:35:16,568 --> 00:35:20,674
item by two if it is even. In this case we are again

566
00:35:20,872 --> 00:35:24,098
changing these actual list. We are dealing with

567
00:35:24,184 --> 00:35:28,154
what is the idiomatic way using the list comprehension x static

568
00:35:28,222 --> 00:35:31,414
two is the expression we need to apply to

569
00:35:31,452 --> 00:35:35,014
every element that is even. Then we have a conditional if x mod

570
00:35:35,052 --> 00:35:38,934
two equal to equal to zero, then multiply it by two else keep

571
00:35:38,972 --> 00:35:42,534
it as it is for every element in array and do this for every element

572
00:35:42,582 --> 00:35:46,758
in array. This is the iterator and a new list is being assigned to ARR

573
00:35:46,854 --> 00:35:50,498
generator expressions. All list comprehensions can be transformed

574
00:35:50,534 --> 00:35:53,118
into generator expressions, but how?

575
00:35:53,284 --> 00:35:56,954
Remove the square brackets, replace them with the parentheses,

576
00:35:57,002 --> 00:36:00,570
and you are done. Why we should be using generator expressions

577
00:36:00,650 --> 00:36:04,894
because these are more efficient in terms of performance

578
00:36:05,022 --> 00:36:08,482
compute and in terms of memory. Use the

579
00:36:08,536 --> 00:36:12,386
list comprehension creates the whole list from scratch. A new

580
00:36:12,408 --> 00:36:15,842
list is being created and assigned to the and is returned.

581
00:36:15,906 --> 00:36:19,254
But generator expression only evaluates the value which is

582
00:36:19,292 --> 00:36:23,286
required and it does not consume up the

583
00:36:23,388 --> 00:36:27,110
space for creating the new list. It is better and

584
00:36:27,180 --> 00:36:30,646
a lot more faster. Updating lists let's say

585
00:36:30,668 --> 00:36:34,326
you have a code base where you are using lists and you are mostly

586
00:36:34,358 --> 00:36:37,798
interested in the first elements of these list. So you will be deleting

587
00:36:37,814 --> 00:36:41,066
the first element, you will be popping out the first element and you

588
00:36:41,088 --> 00:36:44,250
will be inserting new elements at the start of the list only.

589
00:36:44,400 --> 00:36:48,298
If you are doing this with the list then your code will be damn slow.

590
00:36:48,394 --> 00:36:51,374
So what is the better way to do this? The better way to do this

591
00:36:51,412 --> 00:36:54,882
is to use the tech data structure DQ data

592
00:36:54,936 --> 00:36:58,990
structure. By this you will be deleting the first element

593
00:36:59,150 --> 00:37:02,946
by Dell command. Then you will be using the pop left to

594
00:37:02,968 --> 00:37:06,466
pop the first element and append left two append elements at the

595
00:37:06,488 --> 00:37:10,866
start of the list. But this will be a lot more faster. So wherever

596
00:37:10,898 --> 00:37:14,066
in your code bases. You have these kind of statements,

597
00:37:14,178 --> 00:37:17,946
go find them and replace them with the deck data structure and

598
00:37:17,968 --> 00:37:21,606
pop left independent commands. Dictionaries dictionaries

599
00:37:21,638 --> 00:37:25,034
are also an important data structures in Python, and for

600
00:37:25,072 --> 00:37:28,586
these we have some common idioms. First of

601
00:37:28,608 --> 00:37:32,666
all, we should use dict get method while retrieving values

602
00:37:32,698 --> 00:37:36,138
from the dictionary to specify a default parameter

603
00:37:36,314 --> 00:37:40,058
for default value if a value is not found. So let's

604
00:37:40,154 --> 00:37:44,234
look at the example, the non idiomatic way. We are checking for the debug

605
00:37:44,282 --> 00:37:47,618
levels in our code and what action is to be taken against a

606
00:37:47,624 --> 00:37:51,150
certain debug level. So we'll define the debug level equal to none,

607
00:37:51,230 --> 00:37:54,834
and we'll be finding out that if the critical level is found,

608
00:37:54,952 --> 00:37:58,706
then what action is to be taken. So if debug

609
00:37:58,738 --> 00:38:01,846
level is not found in the dictionary, then we'll be assigning the

610
00:38:01,868 --> 00:38:05,126
default value of info. What is the idiomatic way to

611
00:38:05,148 --> 00:38:08,902
do this? Idiomatic way to do this is using the get

612
00:38:08,956 --> 00:38:12,422
method. It's specifying the default value info

613
00:38:12,486 --> 00:38:15,946
if the required value is not found in the dictionary if

614
00:38:15,968 --> 00:38:19,020
the required key is not found in the dictionary. Actually,

615
00:38:19,390 --> 00:38:22,938
what are the use cases for this method?

616
00:38:23,034 --> 00:38:26,554
Counting with dictionaries let's say we have a dictionary.

617
00:38:26,682 --> 00:38:29,662
We have a list, colors in which we have red,

618
00:38:29,716 --> 00:38:33,422
green, blue, and we want to count the instances of each

619
00:38:33,476 --> 00:38:37,310
color name. We'll define a dictionary, traverse through the colors

620
00:38:37,470 --> 00:38:41,118
if a color is not in the dictionary, we'll be creating

621
00:38:41,134 --> 00:38:44,610
the key and assign a zero to it and increment it by one

622
00:38:44,680 --> 00:38:48,414
every time we find the same color. So the output will be blue two green

623
00:38:48,472 --> 00:38:52,134
two red three. So what is the idiomatic way? Idiomatic way

624
00:38:52,172 --> 00:38:55,766
is to define a dictionary and traverse over the colors for color and

625
00:38:55,788 --> 00:38:59,398
color, and use the get method by specifying the zero

626
00:38:59,484 --> 00:39:03,354
value if key is not found, and increment it if the

627
00:39:03,392 --> 00:39:06,746
key is found every time of the same color. Another way

628
00:39:06,768 --> 00:39:10,186
to do this is using the collections module. From collections we

629
00:39:10,208 --> 00:39:14,414
can use a default dict data structure. Through this data

630
00:39:14,452 --> 00:39:17,566
structure you can define a dictionary of certain type

631
00:39:17,668 --> 00:39:21,326
and it will assign value to all the defined keys to be

632
00:39:21,348 --> 00:39:24,830
an integer. If we are using integer, it will initialize it to

633
00:39:24,900 --> 00:39:28,578
zero. So you will be declaring the default dict of int type,

634
00:39:28,664 --> 00:39:33,150
and we'll be just traversing over the list for color and colors and incrementing

635
00:39:33,230 --> 00:39:36,262
the values if a certain key color is found.

636
00:39:36,396 --> 00:39:39,462
So for dictionaries like list,

637
00:39:39,516 --> 00:39:42,710
we also have dictionary comprehensions to build

638
00:39:42,780 --> 00:39:45,350
dictionaries more efficiently and beautifully.

639
00:39:46,010 --> 00:39:49,942
Examples are again, we have some users and

640
00:39:49,996 --> 00:39:53,994
some have added the address. Some have not added the address. We want

641
00:39:54,032 --> 00:39:57,910
to add users which have added the address to the dictionary.

642
00:39:57,990 --> 00:40:01,350
So we'll be writing the loop and checking for the address entered.

643
00:40:01,430 --> 00:40:05,054
If they have these, we will be creating a key with the username and

644
00:40:05,092 --> 00:40:08,266
assigning it the value of address. What is the idiomatic

645
00:40:08,298 --> 00:40:12,106
way? Idiomatic way is to use the Dict comprehension. For dict comprehension

646
00:40:12,138 --> 00:40:14,866
we use the curly brackets. User name is the key,

647
00:40:14,968 --> 00:40:18,626
users address is its value and this is these iterator for

648
00:40:18,648 --> 00:40:22,820
user and users and this is the condition if user address

649
00:40:23,350 --> 00:40:27,186
looping over dictionary keys how you can loop over the dictionary

650
00:40:27,218 --> 00:40:31,174
keys simple for k indent k. Another way

651
00:40:31,212 --> 00:40:35,174
to do this is for k inde keys print k and

652
00:40:35,212 --> 00:40:38,954
maybe delete some keys or some values. So which one is

653
00:40:38,992 --> 00:40:42,822
better and why? Yes, using the keys method

654
00:40:42,886 --> 00:40:47,046
is better because it is more efficient. It returns

655
00:40:47,158 --> 00:40:51,034
a whole new list of keys and if you perform some

656
00:40:51,072 --> 00:40:55,146
action on any key in these for loop, the original

657
00:40:55,178 --> 00:40:58,718
dictionary will not get affected. Looping over dictionary keys and

658
00:40:58,724 --> 00:41:02,750
values the simplest way to do this is okay d you have key

659
00:41:02,820 --> 00:41:06,866
and you can assign the value from with d of k. Another way to

660
00:41:06,888 --> 00:41:11,070
do is using the d dictionary items method.

661
00:41:11,150 --> 00:41:14,494
It will return all the key value pairs

662
00:41:14,622 --> 00:41:18,534
and you can use them as you want. The third way to do this

663
00:41:18,572 --> 00:41:22,182
is to use d iteritems. Yes, it will also

664
00:41:22,236 --> 00:41:25,750
return the key value pair and you can do whatever you want with this key

665
00:41:25,820 --> 00:41:28,902
value pair. Which one is the best and why?

666
00:41:29,036 --> 00:41:32,426
D items is better? Yes, it is better

667
00:41:32,528 --> 00:41:36,106
because you can change the keys and values and the original dictionary will

668
00:41:36,128 --> 00:41:40,162
not get affected. But is it best? No, the iteritems method

669
00:41:40,246 --> 00:41:43,806
is the best option because not only you can

670
00:41:43,828 --> 00:41:47,466
modify the dictionary without being original

671
00:41:47,498 --> 00:41:51,166
dictionary getting affected, but also it

672
00:41:51,188 --> 00:41:55,090
is an iterative method, it will not be consuming extra

673
00:41:55,160 --> 00:41:58,542
space. So that is all for Python

674
00:41:58,606 --> 00:42:01,918
common idioms. But these idioms and language

675
00:42:02,014 --> 00:42:05,846
features are there to increase the readability and maintainability of

676
00:42:05,868 --> 00:42:10,034
your code basis. These are not there to impress other developers

677
00:42:10,162 --> 00:42:13,398
or discourage or other developers that

678
00:42:13,404 --> 00:42:16,706
these are not writing pythonic or idiomatic Python.

679
00:42:16,818 --> 00:42:20,214
This is not to shame other developers and these

680
00:42:20,332 --> 00:42:23,686
language constructs and idioms should not be used for

681
00:42:23,708 --> 00:42:26,934
the sake of using them. Remember, if a

682
00:42:26,972 --> 00:42:30,602
problem can be solved through a simple solution,

683
00:42:30,666 --> 00:42:34,366
we should not opt for the complex or complicated solution. These are

684
00:42:34,388 --> 00:42:37,646
powerful constructs and these should be used wherever they are

685
00:42:37,668 --> 00:42:40,942
required only as Spiderman says that with power

686
00:42:40,996 --> 00:42:44,366
comes great responsibility. These are some of the

687
00:42:44,388 --> 00:42:48,394
references and further readings to more get familiar

688
00:42:48,522 --> 00:42:51,594
with the Python idioms happy idiomatic

689
00:42:51,642 --> 00:42:53,900
coding and thank you very much for listening to me.

