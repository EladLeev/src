1
00:01:54,090 --> 00:01:58,234
Hello, my name is Henrik Plate and I'm the security researcher

2
00:01:58,282 --> 00:02:01,514
working with Endolabs to secure the way developers

3
00:02:01,562 --> 00:02:05,398
and development organizations consume open source in. The way we want

4
00:02:05,404 --> 00:02:09,222
to do this is by considering and analyzing the program code

5
00:02:09,276 --> 00:02:13,222
of those open source components, all the single functions and methods getting

6
00:02:13,276 --> 00:02:16,946
executed, and not by looking at metadata

7
00:02:16,978 --> 00:02:20,390
that people attach to coarse grain projects or packages,

8
00:02:20,890 --> 00:02:24,502
and which often leads to drowning developers and false positives

9
00:02:24,646 --> 00:02:26,490
at endolabs. In a nutshell,

10
00:02:27,870 --> 00:02:31,050
we use such program analysis techniques to support

11
00:02:31,120 --> 00:02:34,414
open source risk and vulnerability management and

12
00:02:34,452 --> 00:02:38,094
to increase developer productivity. But I'm not going

13
00:02:38,132 --> 00:02:41,520
to talk about our own solution. You will need to look this up yourself.

14
00:02:41,890 --> 00:02:45,838
But about the general problem, the promises of program analysis,

15
00:02:46,014 --> 00:02:49,678
and one open source solution called Eclipse study that I've

16
00:02:49,694 --> 00:02:53,700
been developers with fellow researchers over the course of several years.

17
00:02:56,810 --> 00:03:00,262
This is how the agenda looks like. I will start with a quick motivation for

18
00:03:00,316 --> 00:03:03,906
program analysis. I will explain how eclipse

19
00:03:03,938 --> 00:03:07,198
study works, I will demo this solution,

20
00:03:07,394 --> 00:03:11,050
and then I will finish with a couple of takeaways and limitations.

21
00:03:12,110 --> 00:03:15,274
So we all know the software industry depends on

22
00:03:15,312 --> 00:03:18,490
open source. Open source is just everywhere.

23
00:03:19,310 --> 00:03:23,802
80% of typical application code bases come from opensource

24
00:03:23,866 --> 00:03:26,750
projects. In other words,

25
00:03:26,820 --> 00:03:30,666
20%, sometimes less, are specifically developed

26
00:03:30,698 --> 00:03:34,462
for a given application. For example, the business logic

27
00:03:34,526 --> 00:03:38,082
or some glue code. We speak of dozens to

28
00:03:38,136 --> 00:03:42,702
hundreds of dependencies, only a few of them being handpicked

29
00:03:42,766 --> 00:03:46,114
consciously by developers, but the majority

30
00:03:46,162 --> 00:03:49,606
of them being transitive dependencies, automatically pulled into a

31
00:03:49,628 --> 00:03:52,886
development project. And this is

32
00:03:52,988 --> 00:03:56,454
not even considering all the open source code that we download and

33
00:03:56,492 --> 00:04:01,142
execute in our CI CD pipelines on developer workstations

34
00:04:01,286 --> 00:04:04,650
and all the lower parts of the software stack.

35
00:04:06,030 --> 00:04:10,166
Another way to look at this is to not count components

36
00:04:10,198 --> 00:04:14,298
or dependencies, but count all the individuals

37
00:04:14,474 --> 00:04:18,606
who dedicate their time to develop

38
00:04:18,708 --> 00:04:22,222
those solutions. This is a screenshot I took

39
00:04:22,276 --> 00:04:26,162
two or three years back, showing that there are ten

40
00:04:26,216 --> 00:04:30,194
direct contributors to eclipse steady developing its

41
00:04:30,232 --> 00:04:33,940
functionality, compared to more than 23,000

42
00:04:34,390 --> 00:04:39,218
indirect contributors, people that contribute

43
00:04:39,314 --> 00:04:43,426
code to any of the open source components that eclipse

44
00:04:43,458 --> 00:04:47,030
daddy is built upon. And this is really amazing.

45
00:04:47,100 --> 00:04:51,020
It shows the beauty of this whole open source ecosystem and model.

46
00:04:54,910 --> 00:04:58,294
But this heavy dependencies on open source

47
00:04:58,342 --> 00:05:02,414
also comes with security risks, one being the

48
00:05:02,452 --> 00:05:06,202
use of components that have known vulnerabilities

49
00:05:06,346 --> 00:05:10,430
and which can be exploited in production environments by attackers,

50
00:05:11,090 --> 00:05:14,718
for example to create denial of service attacks

51
00:05:14,734 --> 00:05:18,754
or to exfiltrate information from those

52
00:05:18,792 --> 00:05:22,740
systems and applications. The first time I came across this,

53
00:05:23,270 --> 00:05:27,366
which made the problem really apparent back then, was a paper called the

54
00:05:27,388 --> 00:05:30,710
unfortunate reality of insecure libraries back in 2012,

55
00:05:30,780 --> 00:05:34,566
and the authors found that in

56
00:05:34,588 --> 00:05:39,190
average, a Java application comprises 30 open source libraries,

57
00:05:39,350 --> 00:05:42,010
typically at least one with a known vulnerability,

58
00:05:43,470 --> 00:05:47,514
and those 30 open source libraries represent up to 80%

59
00:05:47,552 --> 00:05:50,714
of the code base. So this is the first time, the first

60
00:05:50,752 --> 00:05:54,382
occurrence of this 80%, that you read every

61
00:05:54,436 --> 00:05:58,110
now and then on different blog posts and vendor reports.

62
00:05:59,410 --> 00:06:03,650
They came up with a second version of that report in 2014,

63
00:06:04,150 --> 00:06:07,966
where they found that the download

64
00:06:08,158 --> 00:06:11,390
number of Java components from maven Central

65
00:06:11,470 --> 00:06:15,854
doubled from 6 billion to 13 billion between 2012 and

66
00:06:15,992 --> 00:06:18,902
2014, and those numbers, of course,

67
00:06:18,956 --> 00:06:21,400
only ever increased since then.

68
00:06:22,330 --> 00:06:25,798
In 2013, the open web application Security

69
00:06:25,884 --> 00:06:29,366
project included the use of components with known

70
00:06:29,398 --> 00:06:33,114
vulnerabilities in their top ten security risks for web

71
00:06:33,152 --> 00:06:36,794
applications, and in 2021

72
00:06:36,832 --> 00:06:40,894
that has been promoted from the 9th to the 6th place and

73
00:06:40,932 --> 00:06:44,238
slightly renamed to also include the problem

74
00:06:44,324 --> 00:06:46,590
of using outdated components.

75
00:06:47,570 --> 00:06:52,122
The prevalence has been and is still widespread.

76
00:06:52,186 --> 00:06:56,754
Everybody's using open source, but the detectability got

77
00:06:56,792 --> 00:06:59,922
better over time with open

78
00:06:59,976 --> 00:07:03,822
source solutions and commercial vendors becoming active

79
00:07:03,966 --> 00:07:07,526
in this area. A study

80
00:07:07,628 --> 00:07:11,494
from 2017 found that twelve out

81
00:07:11,532 --> 00:07:15,222
of the top 50 data breaches in 2016 were

82
00:07:15,276 --> 00:07:18,902
due to the use of components with known vulnerabilities,

83
00:07:18,966 --> 00:07:21,930
including the Panama Papers breach.

84
00:07:22,510 --> 00:07:26,438
And all that was before Equifax happened and before lock

85
00:07:26,454 --> 00:07:27,290
for logshell.

86
00:07:30,210 --> 00:07:34,142
So by now, developers really entered this

87
00:07:34,196 --> 00:07:37,774
treadmill of activities they need to carry out

88
00:07:37,812 --> 00:07:41,450
over and over again. They need to detect

89
00:07:41,530 --> 00:07:45,374
whether any of their components is subject

90
00:07:45,422 --> 00:07:49,330
to a known vulnerability. They typically use certain

91
00:07:49,400 --> 00:07:52,686
tools which come with false positives and false

92
00:07:52,718 --> 00:07:55,940
negatives, so they need to figure out

93
00:07:56,410 --> 00:08:00,130
and do the triaging and for all the false positives.

94
00:08:00,210 --> 00:08:03,858
So there is indeed a known vulnerabilities

95
00:08:04,034 --> 00:08:08,042
in one of their components. They need to understand whether this vulnerabilities piece of code

96
00:08:08,096 --> 00:08:11,530
is really relevant in their specific application context.

97
00:08:12,030 --> 00:08:15,674
Can it be executed? Can it be exploited by

98
00:08:15,712 --> 00:08:18,170
attackers to take advantage of the vulnerabilities?

99
00:08:18,590 --> 00:08:22,110
If yes, if the conclusion of that assessment

100
00:08:22,450 --> 00:08:25,834
is positive, the developers has to mitigate

101
00:08:25,882 --> 00:08:29,680
the problem, which could be very easy,

102
00:08:30,210 --> 00:08:33,378
maybe just updating a minor version or a

103
00:08:33,384 --> 00:08:37,060
patch version, or it can be more complex in case

104
00:08:37,910 --> 00:08:41,838
the application is on a relatively old release and the migration

105
00:08:41,934 --> 00:08:45,286
path is not straightforward, or it's an

106
00:08:45,308 --> 00:08:48,710
unmaintained vulnerability, unmaintained project

107
00:08:48,780 --> 00:08:52,194
and there is no patch available at all, and so forth

108
00:08:52,322 --> 00:08:56,018
and so on. Once the patch is produced,

109
00:08:56,194 --> 00:08:59,410
that application patch has to be given and delivered to

110
00:08:59,420 --> 00:09:03,334
the customers, which again can be very easy. In case of cloud applications,

111
00:09:03,382 --> 00:09:07,126
you just deploy once and the fix becomes available and rolled

112
00:09:07,158 --> 00:09:10,606
out to just everybody. Or more complex in

113
00:09:10,628 --> 00:09:14,094
case of on premise applications where an

114
00:09:14,132 --> 00:09:17,806
application patch has to be given to all the

115
00:09:17,828 --> 00:09:21,354
customers who need to test it before releasing

116
00:09:21,402 --> 00:09:25,234
and deploying this in their respective production environment, which could

117
00:09:25,272 --> 00:09:28,740
be a lot of effort on the shoulders of

118
00:09:30,070 --> 00:09:31,060
these customers.

119
00:09:33,030 --> 00:09:37,026
This slide explains why vulnerability assessment

120
00:09:37,058 --> 00:09:40,710
or impact assessment is so difficult. You see on the right hand side

121
00:09:40,860 --> 00:09:44,710
the dependency graph of the graph maven plugin.

122
00:09:45,610 --> 00:09:50,138
The plugin itself is the gray box on the very top. It has eight

123
00:09:50,224 --> 00:09:54,300
direct dependencies and 34

124
00:09:54,910 --> 00:09:58,614
transitive dependencies. The depth of the dependency tree

125
00:09:58,662 --> 00:10:02,334
is seven, and so you see really

126
00:10:02,372 --> 00:10:06,526
the majority of the dependencies of this plugin is

127
00:10:06,628 --> 00:10:10,174
transitive, and so it is not necessarily known or

128
00:10:10,212 --> 00:10:13,794
understood by the application developer why a

129
00:10:13,832 --> 00:10:18,130
certain dependency is existing in this dependency graph.

130
00:10:19,030 --> 00:10:22,974
Why should he? It's kind of considered internals

131
00:10:23,102 --> 00:10:26,374
of the direct dependency that

132
00:10:26,412 --> 00:10:28,760
he chose at some point in time.

133
00:10:30,250 --> 00:10:34,034
Still, interestingly, the majority

134
00:10:34,082 --> 00:10:37,750
of the vulnerabilities are found in the transitive dependencies.

135
00:10:39,550 --> 00:10:43,210
And moreover, interestingly,

136
00:10:43,790 --> 00:10:47,802
not all of the code of those dependencies is

137
00:10:47,856 --> 00:10:51,306
used. Sometimes only certain functions and features of

138
00:10:51,328 --> 00:10:54,320
a dependency is used and sometimes,

139
00:10:54,690 --> 00:10:57,950
even though it is pulled into the project, no single

140
00:10:58,020 --> 00:11:01,646
line of code is ever executed or could be executed in

141
00:11:01,668 --> 00:11:05,218
the context of an application. It's just load ending up in

142
00:11:05,224 --> 00:11:07,220
the dependency graph of an application.

143
00:11:09,110 --> 00:11:12,702
So maybe you wonder why bothering with such complicated

144
00:11:12,766 --> 00:11:16,150
assessment? Why not just simply update such

145
00:11:16,220 --> 00:11:19,670
vulnerability dependencies to a fixed release? Well,

146
00:11:19,820 --> 00:11:23,462
this depends on the lifecycle phase your

147
00:11:23,516 --> 00:11:26,600
application is in and the deployment model.

148
00:11:26,970 --> 00:11:30,902
The earlier you are in your application lifecycle, the easier

149
00:11:30,966 --> 00:11:35,962
it is to just do this other update and

150
00:11:36,016 --> 00:11:39,986
resolve potential problems as part of the development

151
00:11:40,038 --> 00:11:44,174
effort. Anyhow, it is maybe not released and

152
00:11:44,212 --> 00:11:48,094
shipped and used anywhere and

153
00:11:48,132 --> 00:11:51,520
it is much more difficult and more costly and more

154
00:11:52,950 --> 00:11:56,654
important to understand in later lifecycle

155
00:11:56,702 --> 00:12:00,930
phases. So again, suppose you have your application already shipped to

156
00:12:01,080 --> 00:12:04,402
customers. Just updating would

157
00:12:04,456 --> 00:12:08,674
mean you create a new application patch that has to be provided

158
00:12:08,722 --> 00:12:12,326
to, tested by and installed by all those customers.

159
00:12:12,428 --> 00:12:16,694
Again, it's quite some effort and you will only want them to do this for

160
00:12:16,892 --> 00:12:20,186
vulnerabilities that really matter. So you wouldn't want

161
00:12:20,208 --> 00:12:23,446
to always update by default, causing all this effort

162
00:12:23,478 --> 00:12:27,354
for those guys. And of course, updates can also bring

163
00:12:27,392 --> 00:12:33,102
in breaking changes and semantic changes which

164
00:12:33,156 --> 00:12:37,038
could fail the compilation of your application or change

165
00:12:37,124 --> 00:12:38,190
the logic.

166
00:12:40,850 --> 00:12:44,242
This slide is another example why

167
00:12:44,296 --> 00:12:47,954
it is difficult for developers to use security,

168
00:12:48,072 --> 00:12:51,390
the little information part of security advisories,

169
00:12:51,470 --> 00:12:55,482
to perform such impact assessments. So here you see a vulnerability

170
00:12:55,646 --> 00:12:59,586
in a component called Eclipse Majara published

171
00:12:59,618 --> 00:13:02,902
in 2018, and what you see on the screen

172
00:13:02,956 --> 00:13:06,406
is really the whole thing, the whole content of

173
00:13:06,428 --> 00:13:09,830
that CVE, a short description, two sentences,

174
00:13:10,890 --> 00:13:15,130
a severity rating following CBS references

175
00:13:15,550 --> 00:13:19,258
as well as an enumeration of affected products.

176
00:13:19,344 --> 00:13:23,034
And here CPEs rely

177
00:13:23,082 --> 00:13:26,350
on CPEs which are so called common

178
00:13:26,420 --> 00:13:29,150
platform enumeration identifiers.

179
00:13:30,530 --> 00:13:34,942
They denote vendors

180
00:13:35,006 --> 00:13:38,574
and products and versions affected by the respective

181
00:13:38,622 --> 00:13:41,614
vulnerability, in this case eclipse Mojara,

182
00:13:41,662 --> 00:13:44,980
up to excluding version two, three, five.

183
00:13:45,690 --> 00:13:49,846
So why is it difficult for developers to use this information

184
00:13:49,948 --> 00:13:52,520
for context specific assessment? First,

185
00:13:53,130 --> 00:13:56,070
the description is very short and concise.

186
00:13:56,810 --> 00:14:00,698
So if eclipse Mojara is a transitive dependency, how could an application

187
00:14:00,784 --> 00:14:04,438
developer ever know whether the method get local prefix

188
00:14:04,534 --> 00:14:08,822
in the class resource manager matters in his application context,

189
00:14:08,886 --> 00:14:12,880
that is very detailed information of no

190
00:14:13,410 --> 00:14:17,294
immediate use I would say for the application

191
00:14:17,412 --> 00:14:21,146
developer. And also those references

192
00:14:21,258 --> 00:14:24,946
in this case to the fixed commit and to the Jira issue are

193
00:14:24,968 --> 00:14:29,362
not always much of a help and provide rather

194
00:14:29,416 --> 00:14:32,526
unstructured or little additional information supporting

195
00:14:32,558 --> 00:14:36,146
developers. Secondly, those CPE identifiers

196
00:14:36,178 --> 00:14:39,874
I've been mentioning, they do not really correspond to the Maven artifact

197
00:14:39,922 --> 00:14:43,122
identifiers. So here we speak, we have two different languages,

198
00:14:43,186 --> 00:14:46,786
the CPE identifiers talking about eclipse

199
00:14:46,818 --> 00:14:49,906
Mojara. But if you search for Eclipse

200
00:14:49,938 --> 00:14:54,122
Mojara on Maven central, you will find 36 search

201
00:14:54,176 --> 00:14:57,498
hits, but none of them is

202
00:14:57,584 --> 00:15:01,222
the actual artifact that contains the vulnerable

203
00:15:01,286 --> 00:15:04,350
code, which is or glassfish jarbox faces.

204
00:15:05,170 --> 00:15:09,230
So this demonstrates the problem of mapping names

205
00:15:09,970 --> 00:15:13,266
given by people to each other in the hope

206
00:15:13,368 --> 00:15:16,850
to find the right match. Another problem

207
00:15:16,920 --> 00:15:21,006
is not all ecosystems

208
00:15:21,038 --> 00:15:24,494
are well covered by NVD. Java is relatively

209
00:15:24,542 --> 00:15:27,990
well covered. NPM, for example, is not so well covered.

210
00:15:29,930 --> 00:15:33,814
And yet another problem is that those

211
00:15:33,932 --> 00:15:37,010
descriptions are error prone.

212
00:15:37,170 --> 00:15:41,050
So when we looked at this vulnerability back in 2018,

213
00:15:42,750 --> 00:15:45,942
we looked at the source code, the fixed commit

214
00:15:46,086 --> 00:15:49,290
in eclipse Mojara's git repository,

215
00:15:50,750 --> 00:15:54,046
and the bytecode, and we found that the

216
00:15:54,068 --> 00:15:57,674
versions two three five and two three six still contain the vulnerable

217
00:15:57,722 --> 00:16:01,402
code. So we reported this to NVD and they were then updating

218
00:16:01,466 --> 00:16:02,590
the description.

219
00:16:07,350 --> 00:16:11,918
So there are on high level two different approaches

220
00:16:12,014 --> 00:16:16,302
to support developers in detecting dependencies

221
00:16:16,366 --> 00:16:20,102
with a known vulnerabilities. The first is based

222
00:16:20,156 --> 00:16:24,374
on metadata, so data about code

223
00:16:24,572 --> 00:16:28,566
primarily based on package names,

224
00:16:28,678 --> 00:16:33,450
package versions, CPE identifiers or digests,

225
00:16:35,550 --> 00:16:40,526
which are mapped against each other to understand whether there

226
00:16:40,548 --> 00:16:45,882
is a vulnerabilities dependency, a vulnerable component in a given dependency

227
00:16:45,946 --> 00:16:49,210
tree of an application. A good example for this is ovas

228
00:16:49,290 --> 00:16:52,570
dependency check, a nice lightweight

229
00:16:52,730 --> 00:16:55,860
solution they've been developing for a couple of years now.

230
00:16:56,630 --> 00:17:00,290
It can be easily run from the command line without any really

231
00:17:00,360 --> 00:17:04,302
installation efforts, it will download the entire NVD

232
00:17:04,366 --> 00:17:08,722
and try to map cves

233
00:17:08,866 --> 00:17:12,680
against the dependencies of a given project.

234
00:17:15,290 --> 00:17:18,840
The other approach is based on code

235
00:17:20,810 --> 00:17:24,534
avoiding as far as possible the use of any

236
00:17:24,572 --> 00:17:28,266
major data. What you

237
00:17:28,288 --> 00:17:32,014
see on the right hand side is a method that was introduced by

238
00:17:32,052 --> 00:17:36,160
developers to fix a given vulnerability, CVE 2022

239
00:17:36,530 --> 00:17:37,280
something.

240
00:17:40,050 --> 00:17:43,698
When looking at code, the presence or absence of

241
00:17:43,704 --> 00:17:47,394
this method would already give you some clues and

242
00:17:47,432 --> 00:17:51,134
indicators on whether you use a vulnerable version

243
00:17:51,182 --> 00:17:55,022
or a fixed version of the respective component without

244
00:17:55,096 --> 00:17:58,994
needing to look into package names and package

245
00:17:59,042 --> 00:18:03,078
versions and to do this mapping. One example

246
00:18:03,164 --> 00:18:06,806
for a code centric approach for

247
00:18:06,828 --> 00:18:10,540
a tool implementing this approach is Eclipse steady and is

248
00:18:11,070 --> 00:18:14,710
relatively heavyweight compared to oversp dependency

249
00:18:14,790 --> 00:18:18,874
check on the one side because you need to run a docker compose application on

250
00:18:18,912 --> 00:18:22,378
a workstation or better in some internal

251
00:18:22,474 --> 00:18:25,834
cloud, but secondly because it requires

252
00:18:25,882 --> 00:18:29,054
fixed commits, fixed commits again being the

253
00:18:29,092 --> 00:18:32,346
changes done by the opensource developers to overcome a problem.

254
00:18:32,468 --> 00:18:36,386
And those fixed commits are not systematically collected by

255
00:18:36,568 --> 00:18:39,826
public vulnerabilities databases, and so

256
00:18:39,928 --> 00:18:43,374
coming up with them is a little bit of a manual

257
00:18:43,422 --> 00:18:47,026
effort which makes it more involved

258
00:18:47,138 --> 00:18:50,854
to use open source code. This opensource code

259
00:18:50,892 --> 00:18:54,280
centric solution, but once you have it, you can do

260
00:18:55,210 --> 00:18:58,682
additional analysis beyond the vulnerabilities of

261
00:18:58,736 --> 00:19:02,634
metadata based approaches which do not know much about

262
00:19:02,672 --> 00:19:06,438
the code. One example being this impact

263
00:19:06,534 --> 00:19:10,366
assessment reachability analysis. What you see here on the right hand

264
00:19:10,388 --> 00:19:14,350
side is the result of a call graph analysis,

265
00:19:15,010 --> 00:19:18,906
a call graph that was built starting from the application methods

266
00:19:18,938 --> 00:19:22,206
here in green and in this

267
00:19:22,228 --> 00:19:25,426
call graph there was also a path from those application

268
00:19:25,528 --> 00:19:29,006
methods to one of the vulnerable methods

269
00:19:29,118 --> 00:19:32,674
of this component, in this case a

270
00:19:32,712 --> 00:19:37,378
class constructor called interpolator string lookup.

271
00:19:37,474 --> 00:19:41,474
And so the presence of this path shows the developer

272
00:19:41,522 --> 00:19:45,394
that this vulnerabilities

273
00:19:45,442 --> 00:19:48,806
code is potentially executable in the context

274
00:19:48,838 --> 00:19:52,314
of his application. And also this

275
00:19:52,352 --> 00:19:55,610
information can be used to maybe implement

276
00:19:56,430 --> 00:19:59,740
custom controls, so he could pick

277
00:20:00,690 --> 00:20:04,686
maybe the most suitable method to implement a

278
00:20:04,708 --> 00:20:08,494
custom sanitization or an authorization check if

279
00:20:08,532 --> 00:20:10,240
ever the update is not possible.

280
00:20:12,050 --> 00:20:15,810
Another possibilities include the support

281
00:20:15,880 --> 00:20:19,186
of developers in choosing the best update path or

282
00:20:19,208 --> 00:20:23,700
migration update path, because you can understand whether

283
00:20:25,290 --> 00:20:28,760
methods that you call

284
00:20:29,130 --> 00:20:32,790
APIs in a dependencies that you call are also present

285
00:20:32,860 --> 00:20:35,942
in the newer releases, or maybe not.

286
00:20:35,996 --> 00:20:39,702
And if not they would result because if not they would result in compilation

287
00:20:39,766 --> 00:20:43,674
exceptions. So I hope this gives you an idea of

288
00:20:43,792 --> 00:20:47,174
the possibilities and opportunities of using code centric

289
00:20:47,222 --> 00:20:51,450
analysis for vulnerability management. Vulnerability assessment

290
00:20:53,630 --> 00:20:57,306
coming back to the strategy mentioned before. So metadata

291
00:20:57,338 --> 00:21:01,326
centric approaches due to the unawareness of

292
00:21:01,508 --> 00:21:04,974
code can only support in the initial detection,

293
00:21:05,022 --> 00:21:09,460
while code centric approaches can also help at other later

294
00:21:10,150 --> 00:21:13,982
activities, reachability, impact assessment

295
00:21:14,046 --> 00:21:17,254
and mitigation. But not only that, they can

296
00:21:17,292 --> 00:21:21,970
also identify and remove bloat,

297
00:21:22,130 --> 00:21:25,414
which is a very interesting feature. Coming back to what I was

298
00:21:25,452 --> 00:21:28,634
mentioning earlier on, only fractions of those

299
00:21:28,672 --> 00:21:32,426
open source dependencies are actually used in a

300
00:21:32,448 --> 00:21:36,810
given application context. Sometimes entire dependencies

301
00:21:37,390 --> 00:21:40,734
are pulled automatically, but not touched, not used at all.

302
00:21:40,772 --> 00:21:44,334
And of course you could remove those dependencies and this

303
00:21:44,372 --> 00:21:48,478
will improve several aspects of your application. The whole application

304
00:21:48,564 --> 00:21:50,910
will become a little bit smaller,

305
00:21:51,250 --> 00:21:54,660
slimmer build times may become

306
00:21:55,350 --> 00:21:58,546
better, and for those that you remove, there will

307
00:21:58,568 --> 00:22:02,146
be no new known vulnerabilities popping up the next time you

308
00:22:02,168 --> 00:22:05,446
run your open source vulnerability scanner. So this is

309
00:22:05,468 --> 00:22:09,698
really, this load removal and bloat identification

310
00:22:09,874 --> 00:22:14,790
is one of the very promising features

311
00:22:15,210 --> 00:22:18,810
supported by program analysis.

312
00:22:21,150 --> 00:22:25,142
So next I mentioned how eclipse steady

313
00:22:25,206 --> 00:22:28,794
approaches the whole problem and how this implementation looks

314
00:22:28,832 --> 00:22:32,240
like. So when performing the assessment, what you really want to know is,

315
00:22:33,090 --> 00:22:37,038
is a given vulnerability exploitable in my specific application?

316
00:22:37,204 --> 00:22:40,766
If yes, fix it now, if no, fix it

317
00:22:40,788 --> 00:22:44,514
later, reduce the priority, look at the things that

318
00:22:44,552 --> 00:22:47,906
matter more. But this is

319
00:22:47,928 --> 00:22:51,780
a very difficult question to answer because

320
00:22:52,310 --> 00:22:55,954
exploitability really depends on so many aspects,

321
00:22:56,002 --> 00:22:59,766
could be configurations, limitations in

322
00:22:59,788 --> 00:23:03,234
place depending on how the application is deployed,

323
00:23:03,282 --> 00:23:07,506
depending on the architecture. And so we

324
00:23:07,548 --> 00:23:11,034
decided to address and answer

325
00:23:11,232 --> 00:23:14,854
easier questions. And so rather than judging

326
00:23:14,902 --> 00:23:18,810
exploitability, we like to answer

327
00:23:18,880 --> 00:23:22,846
with eclipse study two questions. First, is vulnerabilities code

328
00:23:22,948 --> 00:23:26,506
contained? And if vulnerable code is contained,

329
00:23:26,618 --> 00:23:29,966
then is that executable in the context of

330
00:23:29,988 --> 00:23:34,260
an application? And so this is based on the assumption that

331
00:23:35,030 --> 00:23:38,658
if an application executes code for which a security

332
00:23:38,744 --> 00:23:42,466
fix exists, then there is also a significant risk that

333
00:23:42,488 --> 00:23:46,274
the vulnerability can be exploited. It must not be exploitable,

334
00:23:46,402 --> 00:23:50,390
but there is a risk it is exploitable in this specific

335
00:23:50,460 --> 00:23:51,830
application context.

336
00:23:53,770 --> 00:23:57,366
To answer whether vulnerabilities code is contained, we will have a look at,

337
00:23:57,468 --> 00:24:00,410
or we look at fixed commits.

338
00:24:02,350 --> 00:24:05,814
And to answer whether vulnerable code is executable.

339
00:24:05,942 --> 00:24:09,482
Is executable. Eclipse static uses a combination of

340
00:24:09,536 --> 00:24:11,950
static and dynamic analysis,

341
00:24:14,290 --> 00:24:18,254
and if it is found executed, for example as

342
00:24:18,292 --> 00:24:21,390
part of junit tests,

343
00:24:23,910 --> 00:24:27,694
or if it is potentially reachable according to call graph

344
00:24:27,742 --> 00:24:31,234
analysis, then we say the vulnerabilities is

345
00:24:31,352 --> 00:24:34,834
there is high risk, you better do something about it. If not, there is

346
00:24:34,872 --> 00:24:38,498
low risk. So how do we answer those questions?

347
00:24:38,584 --> 00:24:42,498
For the first one, is vulnerable code contained?

348
00:24:42,594 --> 00:24:46,402
We start from an advisory, could be a CVE,

349
00:24:46,546 --> 00:24:49,990
could be any other disclosure on Twitter,

350
00:24:50,070 --> 00:24:54,246
whatever. What is important is to have the patch information, the fixed

351
00:24:54,278 --> 00:24:57,962
commit, fixing the problem which is our starting point,

352
00:24:58,016 --> 00:25:01,502
and getting there. This is why I put a question mark is not

353
00:25:01,556 --> 00:25:05,418
straightforward. It would be nice if public vulnerability databases

354
00:25:05,514 --> 00:25:08,602
collected this information on a systematic basis,

355
00:25:08,746 --> 00:25:12,558
but they do not, unfortunately. But once we have

356
00:25:12,564 --> 00:25:16,146
the fixed commit, we can basically look at every commit and

357
00:25:16,168 --> 00:25:20,350
the changes introduced by them to understand which are the methods

358
00:25:20,430 --> 00:25:24,270
and constructors added, deleted and modified.

359
00:25:24,350 --> 00:25:28,360
And that is what we call a change list. You will see

360
00:25:29,770 --> 00:25:31,960
one such change list later on.

361
00:25:34,090 --> 00:25:37,706
This is a screenshot from the UI and

362
00:25:37,728 --> 00:25:41,226
here you see some elements of a

363
00:25:41,248 --> 00:25:44,842
change list of the vulnerability in Apache comments text.

364
00:25:44,976 --> 00:25:48,858
So here the fixed commit was b nine b

365
00:25:48,944 --> 00:25:53,920
something in the git repository on GitHub.com

366
00:25:54,450 --> 00:25:57,562
and they were modifying an enumeration, deleting a method,

367
00:25:57,626 --> 00:26:00,298
modifying a constructor and so forth.

368
00:26:00,474 --> 00:26:04,034
Here's the interpolator string lookup you were

369
00:26:04,072 --> 00:26:08,914
seeing earlier on in the call path and

370
00:26:08,952 --> 00:26:12,386
this change list is then input to

371
00:26:12,568 --> 00:26:16,802
answering the second question, which is is that vulnerable

372
00:26:16,866 --> 00:26:20,822
code executable or not? What you see here on this screen is

373
00:26:20,876 --> 00:26:24,870
basically one application with one method number four,

374
00:26:25,020 --> 00:26:28,634
part of the set of

375
00:26:28,832 --> 00:26:33,446
application methods. This application has a direct library

376
00:26:33,558 --> 00:26:36,922
dependency with methods five and six, and it also

377
00:26:36,976 --> 00:26:40,826
has a framework dependency with methods

378
00:26:40,938 --> 00:26:45,230
two and three. The library dependency also

379
00:26:45,380 --> 00:26:49,114
brings in two transitive dependencies with methods

380
00:26:49,162 --> 00:26:51,390
seven and eight respectively.

381
00:26:52,790 --> 00:26:56,850
Those methods call each other according to those edges

382
00:26:57,350 --> 00:26:58,610
and arrows.

383
00:27:00,550 --> 00:27:04,322
The red ones are dynamic invocations could be

384
00:27:04,376 --> 00:27:07,846
reflection could be, as in the

385
00:27:07,868 --> 00:27:12,450
case of frameworks like spring boot invocations

386
00:27:12,530 --> 00:27:16,146
happening by classes generated at runtime.

387
00:27:16,258 --> 00:27:19,814
And so those dynamic invocations typically represent

388
00:27:19,862 --> 00:27:23,802
a problem for static source code

389
00:27:23,856 --> 00:27:27,994
analysis tools. So how would we

390
00:27:28,032 --> 00:27:31,370
use eclipse study to understand whether the vulnerable methods

391
00:27:31,450 --> 00:27:35,406
two and eight are relevant are reachable in the context of

392
00:27:35,428 --> 00:27:38,240
this example application?

393
00:27:39,010 --> 00:27:43,022
We do this by running several analysis,

394
00:27:43,086 --> 00:27:46,686
one after the other. We would start with a reachability

395
00:27:46,798 --> 00:27:50,558
analysis, a call graph analysis

396
00:27:50,654 --> 00:27:54,370
starting from the application method number four, and we would

397
00:27:54,520 --> 00:27:58,102
try to see what are the other methods that can be reached starting

398
00:27:58,156 --> 00:28:01,414
from four, which in this example are five and six.

399
00:28:01,532 --> 00:28:05,334
And we stop there because the call graph construction fails to

400
00:28:05,372 --> 00:28:09,354
understand the dynamic information, the dynamic invocation from

401
00:28:09,392 --> 00:28:13,002
six to seven, and also since we used

402
00:28:13,136 --> 00:28:16,534
four as an entry point, as a starting point of the analysis,

403
00:28:16,582 --> 00:28:20,178
we also do not find this dynamic

404
00:28:20,214 --> 00:28:24,942
invocation of the framework method three of

405
00:28:25,076 --> 00:28:29,614
the application method number four. As the next step we

406
00:28:29,652 --> 00:28:32,926
run a dynamic analysis. What we

407
00:28:32,948 --> 00:28:36,226
do is we instrument all those methods of the

408
00:28:36,248 --> 00:28:39,570
application and all of the dependencies, and every time we find

409
00:28:39,640 --> 00:28:42,946
that such a method is executed either as part of a

410
00:28:42,968 --> 00:28:46,550
junit test or as part of really a runtime

411
00:28:46,890 --> 00:28:50,486
integration test, or maybe an application deployed in a

412
00:28:50,508 --> 00:28:53,574
runtime environment. We trace this information,

413
00:28:53,692 --> 00:28:57,080
we write it down, and in this example

414
00:28:58,590 --> 00:29:02,582
the dynamic test found that the framework

415
00:29:02,646 --> 00:29:07,450
method three and the method seven part of the transitive dependencies

416
00:29:07,870 --> 00:29:11,818
dependency was also executed. And in the next step

417
00:29:11,984 --> 00:29:15,854
we can run again a static analysis, but this time we do not take

418
00:29:15,892 --> 00:29:19,786
the application methods as a starting point to construct a call graph,

419
00:29:19,898 --> 00:29:23,362
but we take the traced methods three and seven

420
00:29:23,416 --> 00:29:27,774
as a starting point. And so this basically allowed

421
00:29:27,822 --> 00:29:31,362
us to bridge these

422
00:29:31,416 --> 00:29:35,594
dynamic invocations. To get beyond those dynamic invocations

423
00:29:35,742 --> 00:29:39,286
and starting from three and seven respectively, we find that the

424
00:29:39,308 --> 00:29:42,774
vulnerable methods, two in the framework and eight in

425
00:29:42,812 --> 00:29:46,950
this right, most transitive dependencies are

426
00:29:47,100 --> 00:29:48,650
potentially reachable.

427
00:29:52,670 --> 00:29:57,754
You can read all the details in the research paper here put

428
00:29:57,792 --> 00:30:01,022
on the slide, including an empiric study for

429
00:30:01,076 --> 00:30:04,922
how many vulnerabilities were reachable in the respective

430
00:30:05,066 --> 00:30:08,506
after the respective analysis steps.

431
00:30:08,618 --> 00:30:11,280
And we found that, if I remember well,

432
00:30:13,350 --> 00:30:16,882
something around 10% of vulnerable code

433
00:30:16,936 --> 00:30:21,182
was only reachable due to this combination

434
00:30:21,246 --> 00:30:26,150
of static dynamic and static analysis.

435
00:30:28,810 --> 00:30:31,030
So how does it look like in practice?

436
00:30:33,770 --> 00:30:38,294
For this, I would like to use again this Apache Commons

437
00:30:38,342 --> 00:30:41,562
text vulnerability I've been mentioning earlier on,

438
00:30:41,696 --> 00:30:45,242
and it has been disclosed in October 2022.

439
00:30:45,376 --> 00:30:49,094
Apache Commons text offers different features

440
00:30:49,142 --> 00:30:53,274
related to strings terms, not very surprisingly,

441
00:30:53,322 --> 00:30:56,938
for example computing the Levenstein distance

442
00:30:57,034 --> 00:30:59,630
or the Jakart distance, and so forth.

443
00:31:00,690 --> 00:31:05,022
But it also offers what they call a string substitution

444
00:31:05,166 --> 00:31:09,038
where you can include variables in strings

445
00:31:09,134 --> 00:31:12,626
that will be replaced at runtime. In the

446
00:31:12,648 --> 00:31:16,758
first box, the Java version and the operating system

447
00:31:16,844 --> 00:31:21,350
name will be replaced by the actual values

448
00:31:22,330 --> 00:31:25,430
by the method replace system properties.

449
00:31:26,570 --> 00:31:32,026
The vulnerabilities that was discovered is

450
00:31:32,128 --> 00:31:35,222
basically about certain dangerous

451
00:31:35,366 --> 00:31:39,622
interpolators or substitutors being included by default

452
00:31:39,686 --> 00:31:43,230
and enabled by default, one of them being for JavaScript.

453
00:31:43,570 --> 00:31:47,438
And so in the versions prior to 1100

454
00:31:47,604 --> 00:31:50,590
this would have allowed for remote code execution.

455
00:31:51,090 --> 00:31:55,998
If a user controlled attacker controlled input

456
00:31:56,094 --> 00:32:00,574
contains a JavaScript variable

457
00:32:00,702 --> 00:32:04,274
that is replaced by the library. In this

458
00:32:04,312 --> 00:32:06,840
example shown in the second box,

459
00:32:07,290 --> 00:32:10,818
the malicious script

460
00:32:10,914 --> 00:32:15,366
that would be executed as part of this replacement as

461
00:32:15,388 --> 00:32:19,274
part of this substitution would be Javalang runtime get

462
00:32:19,312 --> 00:32:22,602
runtime exec, and then in order to

463
00:32:22,656 --> 00:32:26,454
operate an operating system, execute an operating system command.

464
00:32:26,502 --> 00:32:30,250
In this case it would just touch and create a certain file.

465
00:32:32,290 --> 00:32:35,854
Thing about Apache comments text and this vulnerabilities is that

466
00:32:35,972 --> 00:32:40,218
users are only affected if they directly

467
00:32:40,314 --> 00:32:44,014
or any of their dependencies make use of this string

468
00:32:44,062 --> 00:32:47,794
substitution. They certainly know for their own code, but how could they

469
00:32:47,832 --> 00:32:51,182
know for all of the direct and especially all the transitive

470
00:32:51,246 --> 00:32:54,914
dependencies? And to figure

471
00:32:54,952 --> 00:32:58,360
this out, we will have a look at eclipse study.

472
00:33:01,050 --> 00:33:05,314
So this is how the application, a very simple sample

473
00:33:05,362 --> 00:33:09,366
application, looks like it has two dependencies,

474
00:33:09,558 --> 00:33:12,742
Apache comments, text in a vulnerable version,

475
00:33:12,806 --> 00:33:16,780
and junit. The only class,

476
00:33:17,150 --> 00:33:20,426
the main class, has a print

477
00:33:20,458 --> 00:33:24,590
method in which such a dangerous

478
00:33:25,490 --> 00:33:28,510
string substitution takes place.

479
00:33:28,580 --> 00:33:32,262
This is really copy and paste from the original advisory

480
00:33:32,426 --> 00:33:36,660
coming from the GitHub security team. And so here,

481
00:33:37,430 --> 00:33:42,210
if the replace method is called on this interpolator,

482
00:33:42,950 --> 00:33:46,994
this runtime exec statement

483
00:33:47,042 --> 00:33:51,010
would be executed and there will be a file

484
00:33:51,090 --> 00:33:54,822
foo being created. So I can quickly demonstrate this.

485
00:33:54,956 --> 00:33:58,790
First I will remove the file that is existing,

486
00:34:01,070 --> 00:34:04,666
and then I can just run the test, because there

487
00:34:04,688 --> 00:34:08,218
is one test case which is invoking this print method. So once

488
00:34:08,304 --> 00:34:11,934
I do this, you will see this foo file popping up again on the left

489
00:34:11,972 --> 00:34:15,440
hand side. There it is. Now, in order to

490
00:34:17,250 --> 00:34:20,830
analyze this application with eclipse steady, we will do the following.

491
00:34:21,890 --> 00:34:26,494
I already included the profile

492
00:34:26,622 --> 00:34:30,222
pointing to or referencing steady's

493
00:34:30,286 --> 00:34:34,238
maven plugin, so I can invoke

494
00:34:34,414 --> 00:34:38,230
the goals of this steady plugin

495
00:34:39,050 --> 00:34:42,966
very easily. And so here, first of all, I would clean

496
00:34:43,068 --> 00:34:46,498
the target folder locally on my disk,

497
00:34:46,594 --> 00:34:49,986
but I would also clean the analysis results that already exist

498
00:34:50,018 --> 00:34:53,466
in steady's back end, because I ran some analysis early on. So let me

499
00:34:53,488 --> 00:34:56,860
just clean all this. Once that is done,

500
00:34:57,870 --> 00:35:01,642
I can basically create a method

501
00:35:01,706 --> 00:35:06,602
level bit of material using the app analysis

502
00:35:06,666 --> 00:35:08,880
goal. What happens if I run this?

503
00:35:09,650 --> 00:35:13,182
Basically, the steady maven plugin looks

504
00:35:13,236 --> 00:35:17,154
into each and every method of the application

505
00:35:17,272 --> 00:35:21,186
and each and every method of all the dependencies to see

506
00:35:21,288 --> 00:35:24,818
whether there is any vulnerable code contained. And this is how it looks on

507
00:35:24,824 --> 00:35:25,880
the front end.

508
00:35:31,530 --> 00:35:34,710
So here we have the demo comments text vulnerabilities.

509
00:35:35,290 --> 00:35:38,726
Here we have all the dependencies, the two direct ones you

510
00:35:38,748 --> 00:35:40,970
have seen earlier on in the pump file,

511
00:35:43,390 --> 00:35:46,554
as well as two transitive ones brought in

512
00:35:46,672 --> 00:35:50,346
by, I think, one by junit, the other one by Commons

513
00:35:50,378 --> 00:35:51,440
text probably.

514
00:35:53,570 --> 00:35:58,654
And we also see that Commons text has been found to

515
00:35:58,692 --> 00:36:03,026
contain vulnerable code. And this decision hasn't been made on

516
00:36:03,048 --> 00:36:07,234
the basis of the name of this archive or the

517
00:36:07,272 --> 00:36:10,866
coordinates of this archive, but it has been taken on

518
00:36:10,888 --> 00:36:13,330
the basis of the presence of vulnerabilities,

519
00:36:14,070 --> 00:36:17,806
methods and constructors. And so here you see this kind

520
00:36:17,848 --> 00:36:21,446
of the same information I've shown you earlier on on the slide. So these

521
00:36:21,468 --> 00:36:25,014
are all methods added, deleted, removed as

522
00:36:25,052 --> 00:36:29,434
part of the fixed commit, which is this one by the

523
00:36:29,632 --> 00:36:33,002
opensource developers and for each

524
00:36:33,056 --> 00:36:37,094
construct, for each method and so forth, we check whether it is contained

525
00:36:37,142 --> 00:36:41,850
in this respective archive.

526
00:36:42,010 --> 00:36:46,094
So the archive could be really named completely different. We would still be able

527
00:36:46,212 --> 00:36:49,546
to find the signature of those methods,

528
00:36:49,738 --> 00:36:52,030
constructors and so forth.

529
00:36:52,710 --> 00:36:56,354
Now we just

530
00:36:56,392 --> 00:37:00,174
found that vulnerable code is present. We do not know yet whether it's

531
00:37:00,222 --> 00:37:03,474
reachable or not. To do this we can

532
00:37:03,512 --> 00:37:07,014
just run another goal and which is called a to

533
00:37:07,052 --> 00:37:10,614
c. So this is the call graphs construction. Starting from the

534
00:37:10,652 --> 00:37:14,838
application a to c, the change list

535
00:37:15,004 --> 00:37:18,790
of modified open source methods.

536
00:37:20,170 --> 00:37:23,946
If I do this, there will be a call graph constructed and it

537
00:37:23,968 --> 00:37:28,300
will be checked whether the vulnerabilities methods are part of this call graph and how

538
00:37:29,070 --> 00:37:32,874
this path is looking like from the application method to the vulnerable

539
00:37:32,922 --> 00:37:36,880
method. So if I

540
00:37:37,250 --> 00:37:40,954
reload this toggle the advanced

541
00:37:41,002 --> 00:37:43,730
analysis, there is now this red paw popping up,

542
00:37:43,800 --> 00:37:47,122
indicating that some of the methods have

543
00:37:47,176 --> 00:37:50,914
been found reachable according to the call

544
00:37:50,952 --> 00:37:54,094
graph analysis. And all those methods found reachable

545
00:37:54,142 --> 00:37:57,714
have this red paw in this detailed table. If I click on it,

546
00:37:57,832 --> 00:38:01,318
there is this call path we have been seeing earlier on. Again,

547
00:38:01,404 --> 00:38:06,006
main is a method from the application and by

548
00:38:06,108 --> 00:38:09,500
calling different other methods of different other

549
00:38:10,110 --> 00:38:13,878
artifacts, or potentially different artifacts, in this case it's

550
00:38:13,894 --> 00:38:18,522
always Commons text one nine, you end up in

551
00:38:18,576 --> 00:38:22,046
one of the vulnerable methods. In one of the methods, the developers had

552
00:38:22,068 --> 00:38:26,366
to change to fix the problem. Right now

553
00:38:26,388 --> 00:38:28,190
that was the static analysis.

554
00:38:28,930 --> 00:38:32,926
But I have explained earlier

555
00:38:32,958 --> 00:38:36,082
on, there are deficiencies, problems that

556
00:38:36,136 --> 00:38:39,966
make static analysis fail.

557
00:38:40,078 --> 00:38:43,906
Reflection, dynamic programming techniques. And so we

558
00:38:43,928 --> 00:38:47,394
could also run additionally a dynamic

559
00:38:47,442 --> 00:38:50,040
test where we instrument all the code.

560
00:38:50,970 --> 00:38:55,170
This is done using yet another maven

561
00:38:55,250 --> 00:38:59,020
goal here. In this case it's a little bit more involved. I basically

562
00:38:59,470 --> 00:39:02,934
have to prepare an agent comparable

563
00:39:02,982 --> 00:39:06,970
to the agents of Jacques or other coverage tools.

564
00:39:07,870 --> 00:39:11,934
I run the junit tests and then I upload all the information that is

565
00:39:11,972 --> 00:39:15,662
saved locally. Also I say

566
00:39:15,796 --> 00:39:19,578
how much information I would like to collect

567
00:39:19,674 --> 00:39:22,946
during the instrumentation. So in this case

568
00:39:23,048 --> 00:39:26,434
I would like to find all touch points which

569
00:39:26,472 --> 00:39:31,186
are API invocations from the application to

570
00:39:31,208 --> 00:39:35,830
the library. And I would also like to have the complete

571
00:39:35,900 --> 00:39:38,754
stack traces showing me the entire path.

572
00:39:38,882 --> 00:39:43,906
If I run this terms

573
00:39:43,938 --> 00:39:47,142
are executed. Foo would have been created yet another

574
00:39:47,196 --> 00:39:50,642
time if I deleted it and then everything is uploaded

575
00:39:50,706 --> 00:39:51,900
and the front end.

576
00:39:54,830 --> 00:39:59,194
Reload this once more. Now the

577
00:39:59,232 --> 00:40:02,510
red paw on the very rightmost column also appears.

578
00:40:03,010 --> 00:40:06,634
You see here that some of those methods

579
00:40:06,682 --> 00:40:10,430
are both statically and dynamically found reachable. Here,

580
00:40:10,500 --> 00:40:12,640
hoovering over it, you see the test,

581
00:40:14,770 --> 00:40:18,466
the execution time. If you

582
00:40:18,488 --> 00:40:21,246
go into the call graph, the call path,

583
00:40:21,438 --> 00:40:25,042
you will see that there is this reddish overlay over the black

584
00:40:25,096 --> 00:40:28,590
edges that existed before, indicating that,

585
00:40:28,760 --> 00:40:32,902
indicating the dynamic execution. So here we start from a test

586
00:40:32,956 --> 00:40:37,554
method, test print, which invokes

587
00:40:37,602 --> 00:40:40,746
the print method you have seen earlier on in visual studio code,

588
00:40:40,848 --> 00:40:44,586
which again takes this path all the way to one

589
00:40:44,608 --> 00:40:48,060
of the vulnerable constructs in Apache Commons text.

590
00:40:49,310 --> 00:40:52,890
Right. This being the different analysis goals,

591
00:40:52,970 --> 00:40:56,906
giving the developer a feeling for whether the vulnerable code matters

592
00:40:56,938 --> 00:41:00,430
in his application context. Now let me quickly go

593
00:41:00,580 --> 00:41:03,934
to other features of eclipse study that I mentioned earlier

594
00:41:03,982 --> 00:41:09,506
on. So next step would be to mitigate and

595
00:41:09,528 --> 00:41:13,454
here we see basically the number of vulnerabilities

596
00:41:13,582 --> 00:41:16,882
per component and the latest

597
00:41:17,026 --> 00:41:21,110
release published, which would be alternative

598
00:41:22,410 --> 00:41:25,574
to fix the problem. If I go on this,

599
00:41:25,772 --> 00:41:29,066
I will see first of all those touch points in the

600
00:41:29,088 --> 00:41:32,426
first table. And sorry for all this wealth of information that is

601
00:41:32,448 --> 00:41:35,770
always very developer oriented.

602
00:41:36,190 --> 00:41:40,294
The first table contains those touch points. So this is where

603
00:41:40,432 --> 00:41:44,286
our application calls into a

604
00:41:44,308 --> 00:41:47,422
library. So here there are three of these

605
00:41:47,476 --> 00:41:51,738
calls into a static initializer,

606
00:41:51,914 --> 00:41:56,034
into the replace method. You have seen this earlier on, and the

607
00:41:56,072 --> 00:41:59,410
create interpolator. Those touch points

608
00:41:59,480 --> 00:42:02,894
have been found both in the call graph and were actually traced

609
00:42:02,942 --> 00:42:06,226
during junit test execution. This is not always the

610
00:42:06,248 --> 00:42:10,390
case. Sometimes you have trues on one in one column

611
00:42:10,890 --> 00:42:14,822
and false in another column, showing how

612
00:42:14,876 --> 00:42:18,700
the different techniques complement each other, and then

613
00:42:19,710 --> 00:42:24,300
earlier, further below you have basically the

614
00:42:24,910 --> 00:42:28,966
available non vulnerabilities releases to which the developer

615
00:42:28,998 --> 00:42:32,958
could upgrade. And we see that for all these different touch points we

616
00:42:33,044 --> 00:42:36,414
check are those that I call also available in

617
00:42:36,452 --> 00:42:39,914
the nonvulnable release, in the fixed

618
00:42:39,962 --> 00:42:42,880
release, because if not I would have a compile issue.

619
00:42:44,390 --> 00:42:48,002
And we also show what we call the body

620
00:42:48,056 --> 00:42:51,298
stability, trying to indicate how

621
00:42:51,464 --> 00:42:54,946
different is the fixed version from the version that

622
00:42:54,968 --> 00:42:58,054
I use. And so in this example, when going

623
00:42:58,092 --> 00:42:59,510
from one nine to 1100,

624
00:42:59,580 --> 00:43:03,206
170 out of the

625
00:43:03,228 --> 00:43:06,690
171 methods

626
00:43:06,770 --> 00:43:10,700
that were part of the call graph have the same

627
00:43:11,310 --> 00:43:14,730
method body. So there was very little change

628
00:43:14,800 --> 00:43:18,634
from one version to the other, and so the likelihood of regression is

629
00:43:18,672 --> 00:43:22,346
relatively low. And in other examples

630
00:43:22,378 --> 00:43:25,914
you would see that if there are multiple fixed

631
00:43:25,962 --> 00:43:29,658
releases available, you would see how this reachable body stability

632
00:43:29,834 --> 00:43:33,394
decreases the greater the distance gets between what

633
00:43:33,432 --> 00:43:37,170
you use and this nonvulnerable fixed version.

634
00:43:38,550 --> 00:43:42,194
And last but not least, I would like to quickly show this

635
00:43:42,232 --> 00:43:45,734
table. This is a first attempt to understand what are

636
00:43:45,772 --> 00:43:49,046
bloated dependencies. I mean, here we have four,

637
00:43:49,148 --> 00:43:52,838
so there's not so much likely no bloat at all.

638
00:43:53,004 --> 00:43:56,438
But the table gives you an idea of how

639
00:43:56,604 --> 00:44:01,580
this can work out. So here you see two

640
00:44:02,750 --> 00:44:07,610
compile time dependencies. Test dependencies were excluded.

641
00:44:09,230 --> 00:44:13,614
They have a total of 3671

642
00:44:13,652 --> 00:44:18,154
and 1149 methods

643
00:44:18,202 --> 00:44:21,680
and constructors, out of which,

644
00:44:22,390 --> 00:44:25,934
according to the junit tests, to the dynamic

645
00:44:25,982 --> 00:44:29,822
tests, ten and 130 respectively

646
00:44:29,966 --> 00:44:34,130
were actually executed and six

647
00:44:34,200 --> 00:44:37,266
and 142 were potentially executed.

648
00:44:37,298 --> 00:44:41,560
They were part of the call graph that we have built and so

649
00:44:42,170 --> 00:44:45,734
removing this would likely cause some troubles. But in other

650
00:44:45,772 --> 00:44:49,900
cases in bigger dependencies, whenever there is no

651
00:44:50,430 --> 00:44:53,850
single method potentially reachable or actually

652
00:44:53,920 --> 00:44:57,206
executed during the tests, it would be worthwhile

653
00:44:57,238 --> 00:45:01,294
to removing this dependencies and seeing whether the application

654
00:45:01,412 --> 00:45:02,400
still works.

655
00:45:05,570 --> 00:45:09,600
This is concluding the demonstration, so let me get back to

656
00:45:10,770 --> 00:45:14,210
the slide check. So to conclude,

657
00:45:15,670 --> 00:45:20,158
I hope you have seen the capabilities

658
00:45:20,254 --> 00:45:24,526
and possibilities of supporting vulnerability management

659
00:45:24,638 --> 00:45:28,162
with code centric program analysis

660
00:45:28,226 --> 00:45:31,986
techniques. They can reduce false positives

661
00:45:32,018 --> 00:45:35,526
and false negatives. So due to compared to

662
00:45:35,548 --> 00:45:39,594
all these metadata centric approaches trying to map names against each

663
00:45:39,632 --> 00:45:43,194
other, but also false negatives because they

664
00:45:43,232 --> 00:45:47,274
can cover this phenomenon of rebundling where classes from

665
00:45:47,312 --> 00:45:50,590
one project are rebundled, copied into

666
00:45:50,740 --> 00:45:54,334
Java archives or other projects which would not be found

667
00:45:54,452 --> 00:45:57,646
on the basis of mapping names against each other.

668
00:45:57,828 --> 00:46:01,470
You can prioritize findings because of

669
00:46:01,620 --> 00:46:05,726
having this application context, understanding code

670
00:46:05,828 --> 00:46:11,106
reachability, and they

671
00:46:11,128 --> 00:46:14,782
can help you with updates, avoiding regressions, and to identify

672
00:46:14,846 --> 00:46:18,550
software bloat. On the negative side,

673
00:46:18,700 --> 00:46:22,306
I have to mention that of course they struggle

674
00:46:22,338 --> 00:46:25,714
with so called configuration vulnerability. So if a fix consisted

675
00:46:25,762 --> 00:46:29,046
only of changing a default configuration, a properties file

676
00:46:29,078 --> 00:46:32,810
or XML file that is coming with a Java archive

677
00:46:33,230 --> 00:46:36,422
code centric analysis cannot do much. And secondly,

678
00:46:36,566 --> 00:46:39,974
reachability and reachable is

679
00:46:40,032 --> 00:46:43,086
not the same as exploitable. There is a certain class of

680
00:46:43,108 --> 00:46:46,554
vulnerabilities, namely deserialization vulnerabilities,

681
00:46:46,682 --> 00:46:50,702
especially those using the

682
00:46:50,756 --> 00:46:55,566
old Java way of serializing

683
00:46:55,598 --> 00:46:56,770
Java objects.

684
00:46:59,590 --> 00:47:02,866
For a vulnerabilities to be exploitable, it is sufficient to have a

685
00:47:02,888 --> 00:47:05,842
vulnerabilities class, a gadget class in the class path.

686
00:47:05,906 --> 00:47:09,414
So in this special case, it doesn't matter at all

687
00:47:09,452 --> 00:47:13,286
whether this vulnerable class is in

688
00:47:13,308 --> 00:47:17,206
a call graph computed on

689
00:47:17,228 --> 00:47:20,290
the normal expected behavior of an application,

690
00:47:20,460 --> 00:47:23,706
just sufficient to be hidden somewhere in the

691
00:47:23,728 --> 00:47:26,938
class path to be exploited by attackers that

692
00:47:27,024 --> 00:47:30,358
send deserialized objects of that class

693
00:47:30,464 --> 00:47:34,030
to an application in order to trigger the vulnerability.

694
00:47:35,650 --> 00:47:39,230
The particular limitations of eclipse steady are as follows.

695
00:47:39,570 --> 00:47:42,846
First, as I've mentioned earlier

696
00:47:42,878 --> 00:47:46,574
on, none of the existing public vulnerability databases

697
00:47:46,702 --> 00:47:50,638
references fixed commit in a systematic fashion.

698
00:47:50,814 --> 00:47:54,482
This is why the tool has

699
00:47:54,536 --> 00:47:58,978
a limited coverage. So right now there are 700 vulnerabilities

700
00:47:59,074 --> 00:48:03,814
in a dedicated opensource project called Project KB where

701
00:48:03,852 --> 00:48:07,802
we listed the fixed commits for those 700

702
00:48:07,856 --> 00:48:11,386
vulnerabilities, so they are the input for

703
00:48:11,408 --> 00:48:15,354
the analysis you have seen earlier on. Secondly, we only support,

704
00:48:15,552 --> 00:48:20,450
or I could say only supports, Java Python

705
00:48:20,630 --> 00:48:23,742
limited Python support is available, but that is rather

706
00:48:23,796 --> 00:48:27,290
beta and does not include all the reachability

707
00:48:27,370 --> 00:48:32,282
analysis. And last but not least, compared to other approaches,

708
00:48:32,346 --> 00:48:35,678
it is relatively heavyweight in the sense that you need to have a

709
00:48:35,684 --> 00:48:39,680
Docker compose application running, ideally in a private cloud.

710
00:48:42,450 --> 00:48:46,294
Right. This concludes my talk, I hope. One it

711
00:48:46,332 --> 00:48:50,806
was interesting and I convinced you of the

712
00:48:50,828 --> 00:48:54,610
potential of using program analysis techniques.

713
00:48:54,770 --> 00:49:01,846
Thank you so much you.

714
00:49:01,948 --> 00:49:02,180
Thank you.

