1
00:00:20,090 --> 00:00:24,046
So let's get started with building Go CLI application I am

2
00:00:24,068 --> 00:00:26,946
Abhisek Pattnaik, full stack software engineer,

3
00:00:27,058 --> 00:00:30,386
currently working as senior software engineer at Impulses.

4
00:00:30,498 --> 00:00:34,614
To know more about me, please go to the link below. Before we

5
00:00:34,652 --> 00:00:39,094
start with building CLI apps, let's get some prerequisites.

6
00:00:39,222 --> 00:00:42,762
You should have some knowledge about basics syntax of

7
00:00:42,816 --> 00:00:46,154
Go. You may use vs code or

8
00:00:46,192 --> 00:00:49,498
intellij Goland IDE for writing the code.

9
00:00:49,664 --> 00:00:53,630
You should also have some basics of understanding

10
00:00:54,610 --> 00:00:59,070
about JSON and XML and

11
00:00:59,140 --> 00:01:02,814
to give you some general information about the talk. All the relevant

12
00:01:02,862 --> 00:01:06,002
links in the slides are clickable. All the code

13
00:01:06,056 --> 00:01:09,506
images are clickable and point to the repository with

14
00:01:09,528 --> 00:01:13,458
the appropriate commit. Slide and app project

15
00:01:13,624 --> 00:01:17,110
are published in speaker Deck and GitHub respectively.

16
00:01:17,450 --> 00:01:21,480
Relevant code commits are tagged as per the slide number.

17
00:01:22,330 --> 00:01:25,654
So this is the flow in which we will walk through

18
00:01:25,692 --> 00:01:29,234
this talk. I will provide the introduction to CLI

19
00:01:29,282 --> 00:01:32,822
app development and we will get started with

20
00:01:32,876 --> 00:01:36,934
flag model. In Go. We will learn how to parse

21
00:01:37,062 --> 00:01:41,022
various types of data from the CLI arguments and then

22
00:01:41,076 --> 00:01:45,034
finally use all the knowledge we gained to build a CLI

23
00:01:45,082 --> 00:01:47,280
application to generate random data.

24
00:01:48,930 --> 00:01:53,074
Introduction to CLI app why

25
00:01:53,112 --> 00:01:56,690
do we choose go for building CLI apps?

26
00:01:57,670 --> 00:02:00,994
Go provides reliable, efficient and

27
00:02:01,032 --> 00:02:04,062
scalable CLI application development.

28
00:02:04,206 --> 00:02:07,366
It makes it easy to build and it is fast.

29
00:02:07,548 --> 00:02:11,494
Go has a rich set of libraries for various tasks such

30
00:02:11,532 --> 00:02:14,886
as manipulating text files and data.

31
00:02:15,068 --> 00:02:18,534
It also has built in and third party module

32
00:02:18,582 --> 00:02:22,534
support for parsing commandline arguments and build CLI

33
00:02:22,582 --> 00:02:26,134
applications. CLI stands

34
00:02:26,182 --> 00:02:30,066
for command line interface where you write commands

35
00:02:30,118 --> 00:02:33,470
and its related information in textual form.

36
00:02:33,620 --> 00:02:37,418
You can launch programs and automate various tasks.

37
00:02:37,594 --> 00:02:41,406
That means you have native integration or you can run the

38
00:02:41,428 --> 00:02:44,290
program using any other programming languages.

39
00:02:45,430 --> 00:02:49,342
It is easy to write and understand, unlike complex graphical

40
00:02:49,406 --> 00:02:53,538
applications. Now let's see

41
00:02:53,704 --> 00:02:57,494
what Go's built in flag module offers. We can

42
00:02:57,532 --> 00:03:00,614
implement parsing the command line flags with various data

43
00:03:00,652 --> 00:03:03,858
types, specify defaults,

44
00:03:03,954 --> 00:03:07,754
and also provide the usage description about each

45
00:03:07,792 --> 00:03:11,290
flag. It also allows to parse the data

46
00:03:11,360 --> 00:03:15,258
into custom data structures. Getting started

47
00:03:15,344 --> 00:03:19,226
with the flag module let's look

48
00:03:19,248 --> 00:03:22,766
at the syntax for passing the flags and data to

49
00:03:22,788 --> 00:03:26,222
our CLI app. We can use single or

50
00:03:26,276 --> 00:03:29,946
double dashes before the name of the flag and optionally

51
00:03:30,058 --> 00:03:33,982
a value either with a space or equal symbol between

52
00:03:34,036 --> 00:03:37,714
the flag and value. Here is an example how

53
00:03:37,752 --> 00:03:41,826
we can pass the commandline flags. Let us

54
00:03:41,848 --> 00:03:46,038
look at the code so we check out the

55
00:03:46,204 --> 00:03:49,720
slide number eleven and

56
00:03:50,170 --> 00:03:51,830
to go mode vendor.

57
00:03:54,650 --> 00:03:58,540
And as you can see here,

58
00:04:00,590 --> 00:04:03,722
there is a name variable that is declared and we

59
00:04:03,776 --> 00:04:07,414
are passing the address of the name variable to the string

60
00:04:07,462 --> 00:04:11,294
VAR method with a

61
00:04:11,332 --> 00:04:14,958
name as the name of the flag itself and

62
00:04:15,124 --> 00:04:19,230
the default value as world, and the usage

63
00:04:19,730 --> 00:04:23,458
is as the name to say hello to.

64
00:04:23,624 --> 00:04:27,810
Then we parse the values, the argument

65
00:04:28,230 --> 00:04:32,946
command line arguments, and then we print the hello

66
00:04:33,048 --> 00:04:36,562
and the name that is provided. If no name is provided,

67
00:04:36,626 --> 00:04:40,194
then it will take the world as the value. So let's

68
00:04:40,242 --> 00:04:43,720
build it and test it out.

69
00:04:47,550 --> 00:04:51,734
So as you can see, we can provide double

70
00:04:51,782 --> 00:04:55,594
dash name and provide the actual name and

71
00:04:55,632 --> 00:04:58,650
it will print the greeting.

72
00:04:59,230 --> 00:05:02,478
And if we do not provide any value

73
00:05:02,564 --> 00:05:06,202
or any name, then it provides

74
00:05:06,346 --> 00:05:07,760
the default value.

75
00:05:10,370 --> 00:05:14,114
Parsing data with flagged module the

76
00:05:14,152 --> 00:05:17,566
flag module supports various ways to parse the command

77
00:05:17,598 --> 00:05:21,726
line argument into, such as to string integer,

78
00:05:21,918 --> 00:05:25,366
boolean float duration of time, which is

79
00:05:25,388 --> 00:05:28,594
a non primitive data structure you can parse

80
00:05:28,642 --> 00:05:31,814
to any other custom data structures using

81
00:05:32,012 --> 00:05:35,670
flag VAR and flag funk methods

82
00:05:36,970 --> 00:05:41,194
we saw how we parse flags where we need to provide the

83
00:05:41,232 --> 00:05:44,634
name of the flag, and often it happens that the name

84
00:05:44,672 --> 00:05:48,826
is too long to type. For this we can use flag aliases which

85
00:05:48,848 --> 00:05:52,650
are shorter way to pass data to the flag variables.

86
00:05:52,810 --> 00:05:54,160
Let's see the code.

87
00:05:56,850 --> 00:06:00,830
We will switch to the slide 14.

88
00:06:02,950 --> 00:06:07,540
Here you can see we have declared a variable name

89
00:06:07,990 --> 00:06:11,460
and we are using the same variable name

90
00:06:11,830 --> 00:06:15,038
for having a longer version of

91
00:06:15,064 --> 00:06:19,080
the flag and a shorter version of the flag and

92
00:06:20,330 --> 00:06:23,670
we parse the data and as before we are

93
00:06:23,740 --> 00:06:27,640
printing the data. So let us build that and

94
00:06:28,190 --> 00:06:31,402
let's use with

95
00:06:31,536 --> 00:06:34,700
full version and with a

96
00:06:35,470 --> 00:06:38,940
shorter version. As you can see, we were able to

97
00:06:39,550 --> 00:06:43,614
provide the name to the

98
00:06:43,812 --> 00:06:46,830
longer and the shorter version alias.

99
00:06:47,250 --> 00:06:51,918
If we check the help and

100
00:06:52,084 --> 00:06:55,220
we can see that we have two different

101
00:06:55,590 --> 00:06:59,170
flags defined with a shorter and the longer version

102
00:06:59,510 --> 00:07:01,170
in the usage.

103
00:07:06,890 --> 00:07:10,406
So conventionally we write

104
00:07:10,508 --> 00:07:14,662
a shorter version as the longer

105
00:07:14,716 --> 00:07:16,950
version first character of the longer version.

106
00:07:19,150 --> 00:07:23,126
It is often required that we have multiple flags

107
00:07:23,238 --> 00:07:27,414
and there are longer flag names that we need to type to handle

108
00:07:27,462 --> 00:07:31,546
it gracefully. With better maintainability and with ease,

109
00:07:31,658 --> 00:07:35,146
we can make use of getopt third party

110
00:07:35,178 --> 00:07:39,050
library. It provides a clean way to define the aliases

111
00:07:39,130 --> 00:07:42,320
and also show the usage in a better way.

112
00:07:44,310 --> 00:07:45,860
Let's look at the code.

113
00:07:47,590 --> 00:07:50,980
We'll switch to slide 15

114
00:07:51,910 --> 00:07:55,730
and make a go mod vendor.

115
00:07:56,710 --> 00:08:00,694
So here we use the get opt third

116
00:08:00,732 --> 00:08:04,550
party library to declare the longer

117
00:08:04,620 --> 00:08:08,474
version of the we declared the longer version of the flag using

118
00:08:08,512 --> 00:08:12,346
the flag model and using getopt. We define the

119
00:08:12,368 --> 00:08:15,690
alias with the formal name,

120
00:08:15,840 --> 00:08:19,706
same as the flag that is defined and a

121
00:08:19,728 --> 00:08:24,110
shorter name. And then we parse using getopt

122
00:08:25,650 --> 00:08:29,226
and we provide give the default print

123
00:08:29,258 --> 00:08:35,666
the defaults. So let's build and look at how

124
00:08:35,688 --> 00:08:38,020
it appears. As we can see,

125
00:08:38,550 --> 00:08:42,334
the shorter and the longer version of the flag

126
00:08:42,462 --> 00:08:46,150
appear in a much better way than the previous

127
00:08:46,490 --> 00:08:50,950
way of showing the usage.

128
00:08:52,890 --> 00:08:56,582
A user of the CLI app might not know what

129
00:08:56,636 --> 00:08:59,866
flags are available for CLI app and how to

130
00:08:59,888 --> 00:09:03,420
use them. To find out, we conventionally use

131
00:09:04,350 --> 00:09:07,754
hyphen h or double dash help

132
00:09:07,872 --> 00:09:10,800
to show the usage of the CLI application.

133
00:09:11,250 --> 00:09:13,760
Let's see how to implement that.

134
00:09:15,650 --> 00:09:19,422
Let's see the code we check

135
00:09:19,476 --> 00:09:21,230
out to slide 16.

136
00:09:22,710 --> 00:09:26,946
In this we have a

137
00:09:26,968 --> 00:09:30,610
name and repeat

138
00:09:31,110 --> 00:09:34,926
two different flags. We get the

139
00:09:34,968 --> 00:09:38,710
total arguments that are provided in the commandline.

140
00:09:39,290 --> 00:09:43,202
Using the OS args, we discard the first argument,

141
00:09:43,266 --> 00:09:47,302
which usually is the name

142
00:09:47,356 --> 00:09:50,860
of the commandline program that is used to run.

143
00:09:52,190 --> 00:09:56,650
Then we define a help flag

144
00:09:57,150 --> 00:10:00,262
and defaulting to false or

145
00:10:00,416 --> 00:10:03,950
true based on the total number of arguments.

146
00:10:05,810 --> 00:10:10,000
So if the total number of arguments is zero,

147
00:10:10,690 --> 00:10:14,226
the help will run and we

148
00:10:14,248 --> 00:10:20,206
will get the defaults the usage of the flags.

149
00:10:20,398 --> 00:10:24,260
So let's try that. Let's build it

150
00:10:25,610 --> 00:10:29,334
and without giving any

151
00:10:29,372 --> 00:10:33,558
arguments. As we can see, we got the help.

152
00:10:33,724 --> 00:10:38,470
Even if we provide hyphen h or double

153
00:10:38,890 --> 00:10:43,770
help, we get the usage

154
00:10:44,590 --> 00:10:46,060
of the command line.

155
00:10:48,350 --> 00:10:52,186
You built a nice CLI application, but a creation

156
00:10:52,218 --> 00:10:55,566
without a name is like a ship without a cell. Let's give

157
00:10:55,588 --> 00:10:59,710
a name to our application. For example greater CLI.

158
00:11:00,530 --> 00:11:03,906
We use the new flagset constructor function

159
00:11:04,088 --> 00:11:07,620
to create a new flagset with a name.

160
00:11:07,990 --> 00:11:12,066
Let's look at the code. We switch to the

161
00:11:12,168 --> 00:11:16,260
slide number 17 here.

162
00:11:16,950 --> 00:11:22,022
We create a new flag set with new

163
00:11:22,076 --> 00:11:25,906
flagset. Here we are using the gitopt

164
00:11:25,938 --> 00:11:29,814
library and we can provide

165
00:11:30,012 --> 00:11:33,850
the new name that we have reacher Cli

166
00:11:34,910 --> 00:11:38,730
as the first parameter to the new flagset

167
00:11:39,150 --> 00:11:42,510
constructor function and we use the

168
00:11:42,660 --> 00:11:46,506
new flag set to define

169
00:11:46,538 --> 00:11:50,110
the flags and also provide aliases

170
00:11:50,930 --> 00:11:54,526
so this can be used with the flag

171
00:11:54,558 --> 00:11:58,174
module as well. And then we parse

172
00:11:58,222 --> 00:12:02,002
the arguments. If help is true, we provide

173
00:12:02,056 --> 00:12:04,830
the usage. So let's see.

174
00:12:05,000 --> 00:12:10,502
Let's compile this and provide

175
00:12:10,556 --> 00:12:14,166
the help. And as you can see when we see

176
00:12:14,188 --> 00:12:18,054
the help, the usage of greeter

177
00:12:18,102 --> 00:12:21,306
CLI is as follows. So you can see

178
00:12:21,328 --> 00:12:24,762
the name of the CLI application that we have

179
00:12:24,816 --> 00:12:28,154
given. As noted before,

180
00:12:28,272 --> 00:12:31,774
we can parse a CLI flag value to a

181
00:12:31,812 --> 00:12:35,950
custom data type. For that you need to implement the

182
00:12:36,020 --> 00:12:39,374
flag dot value interface for the given custom data

183
00:12:39,412 --> 00:12:42,586
type. Let's see how

184
00:12:42,628 --> 00:12:43,490
to implement.

185
00:12:47,540 --> 00:12:50,400
We go to the slide number 19.

186
00:12:57,830 --> 00:13:03,080
It here we have address

187
00:13:04,250 --> 00:13:08,360
structure, which is a custom data type.

188
00:13:09,370 --> 00:13:13,398
Then we use the address structure

189
00:13:13,494 --> 00:13:17,434
as a pointer in the address value

190
00:13:17,632 --> 00:13:21,162
and we implement the get

191
00:13:21,296 --> 00:13:24,970
and the value interface. In the value interface,

192
00:13:25,050 --> 00:13:29,194
you implement the string method

193
00:13:29,242 --> 00:13:32,586
and the set method. In the string

194
00:13:32,618 --> 00:13:36,260
method, we simply return the string value of the address

195
00:13:37,110 --> 00:13:41,614
and in the set method we split

196
00:13:41,662 --> 00:13:45,570
the address that is provided in the given format

197
00:13:47,270 --> 00:13:50,838
and then assign it to the

198
00:13:51,004 --> 00:13:53,110
address structure.

199
00:13:54,890 --> 00:13:59,240
So let's build this and

200
00:14:02,830 --> 00:14:06,966
see how we can use it. As you can see here, it is expected

201
00:14:07,078 --> 00:14:10,250
in the format, street, city, state,

202
00:14:10,320 --> 00:14:13,886
pin code, and country. Let's provide the address in the

203
00:14:13,908 --> 00:14:18,654
same format and

204
00:14:18,692 --> 00:14:22,238
then as you can see here,

205
00:14:22,404 --> 00:14:26,260
we have given the address in a string and

206
00:14:28,310 --> 00:14:29,620
using the set,

207
00:14:31,910 --> 00:14:36,286
it has assigned the address to the corresponding

208
00:14:36,318 --> 00:14:39,030
fields in the address structure.

209
00:14:40,810 --> 00:14:44,434
We can also use flag funk method

210
00:14:44,482 --> 00:14:48,194
to parse and extract the required data from the CLI flag

211
00:14:48,242 --> 00:14:52,086
value. This might come in handy if a custom parsing

212
00:14:52,118 --> 00:14:55,980
function is required. Let's see the code.

213
00:14:57,550 --> 00:15:01,846
Let's go to the slide

214
00:15:01,878 --> 00:15:05,838
number 20. Here we have

215
00:15:06,004 --> 00:15:12,094
defined the flag num which

216
00:15:12,132 --> 00:15:16,702
will take a string and extract

217
00:15:16,766 --> 00:15:20,606
the number value from that and then assign

218
00:15:20,638 --> 00:15:24,050
it to the num which is. This is a custom

219
00:15:24,200 --> 00:15:28,180
parser function that we have written. So let's compile it

220
00:15:28,490 --> 00:15:34,358
and run it with

221
00:15:34,524 --> 00:15:35,240
num,

222
00:15:37,450 --> 00:15:41,690
and we can write any characters,

223
00:15:42,350 --> 00:15:45,514
and in

224
00:15:45,552 --> 00:15:49,340
between the characters we provide the number.

225
00:15:49,790 --> 00:15:53,570
Now that number is parsed and it is extracted

226
00:15:53,750 --> 00:15:56,490
assigned to the num integer.

227
00:15:56,650 --> 00:16:00,938
And then we print the number as promised.

228
00:16:01,034 --> 00:16:04,734
Let's see how we can provide a JSON file as

229
00:16:04,772 --> 00:16:08,126
input and parse it. The JSON file

230
00:16:08,318 --> 00:16:12,020
can have mixed data type for a given field.

231
00:16:12,630 --> 00:16:16,050
So let's look at the JSON file.

232
00:16:19,850 --> 00:16:24,620
So we go to slide number 21 and

233
00:16:26,830 --> 00:16:30,858
this is the input JSON. As you

234
00:16:30,864 --> 00:16:36,366
can see here we have an alias property which

235
00:16:36,388 --> 00:16:40,698
is a string with a comma separated aliases,

236
00:16:40,874 --> 00:16:44,734
and the same aliases property

237
00:16:44,852 --> 00:16:47,090
is an array of strings.

238
00:16:48,070 --> 00:16:53,730
So we will see how we can process

239
00:16:53,800 --> 00:16:54,420
this.

240
00:16:59,350 --> 00:17:02,834
To parse the input JSON, we implement the

241
00:17:02,872 --> 00:17:06,582
flag value interface and unmarshal the

242
00:17:06,636 --> 00:17:10,066
input to JSoN struct using the flag

243
00:17:10,178 --> 00:17:22,190
VAR method. So let's try that's.

244
00:17:22,370 --> 00:17:24,140
Let's walk through the code.

245
00:17:27,010 --> 00:17:31,200
We go to slide number 23.

246
00:17:33,810 --> 00:17:36,990
So here we have a JSON Cli.

247
00:17:42,960 --> 00:17:46,392
And in this JSON Cli, this is the input.

248
00:17:46,536 --> 00:17:50,456
This is the input which accept which will store the JSON values.

249
00:17:50,568 --> 00:17:52,060
And this is the item.

250
00:17:55,620 --> 00:17:59,584
So this corresponds to these values and

251
00:17:59,622 --> 00:18:03,696
it is expected the aliases will be a

252
00:18:03,718 --> 00:18:08,020
slice of strings. Now using

253
00:18:08,090 --> 00:18:11,616
the VAR method, we define

254
00:18:11,648 --> 00:18:15,124
the JSON input flag JSON input flag is defined as

255
00:18:15,162 --> 00:18:19,240
such. We provide the input file as a pointer

256
00:18:19,660 --> 00:18:23,720
and then define the

257
00:18:23,870 --> 00:18:27,732
set method. Here we extract

258
00:18:27,796 --> 00:18:31,352
the JSON, read the JSON file and then parse the

259
00:18:31,406 --> 00:18:35,060
JSON. Unmarshal the JSON to the structure

260
00:18:35,220 --> 00:18:37,000
the input file struct.

261
00:18:38,380 --> 00:18:42,792
So while unmarshalling here, we can see that we create an

262
00:18:42,946 --> 00:18:46,796
alias and unmarshall

263
00:18:46,828 --> 00:18:50,610
the file the JSON data.

264
00:18:53,060 --> 00:18:56,996
We have used the aliases as any in

265
00:18:57,018 --> 00:19:00,756
this case, so that the aliases with

266
00:19:00,858 --> 00:19:04,468
mixed data type is assigned to this

267
00:19:04,634 --> 00:19:08,272
aliases field. And from here

268
00:19:08,426 --> 00:19:12,260
we check if the aliases is a string,

269
00:19:12,420 --> 00:19:16,452
then we split the string using comma separated

270
00:19:16,516 --> 00:19:19,816
values. Otherwise, if it is

271
00:19:19,838 --> 00:19:23,404
a list of strings, then we run

272
00:19:23,442 --> 00:19:27,100
through the list and convert it to

273
00:19:27,170 --> 00:19:30,472
a string and assign it to the aliases

274
00:19:30,536 --> 00:19:33,776
array. So we

275
00:19:33,798 --> 00:19:38,560
can also use alias string likewise

276
00:19:39,300 --> 00:19:43,650
and let's build it and check

277
00:19:45,300 --> 00:19:49,904
json cli. Let's see the

278
00:19:49,942 --> 00:19:53,444
val the input file. We pass the input file using

279
00:19:53,482 --> 00:19:58,596
hyphen I. Let's see the flags

280
00:19:58,628 --> 00:20:01,784
which we can use. As you can see, hyphen I is for

281
00:20:01,822 --> 00:20:06,730
providing the input file. We provide the input file and

282
00:20:07,980 --> 00:20:11,372
it processes the file appropriately without

283
00:20:11,426 --> 00:20:17,236
any errors as

284
00:20:17,258 --> 00:20:18,340
per the print.

285
00:20:27,880 --> 00:20:31,504
Now since you have gone through many parts of the flag

286
00:20:31,632 --> 00:20:34,800
module, let's see how things are implemented

287
00:20:34,880 --> 00:20:38,084
internally. You can find the implementation source code

288
00:20:38,122 --> 00:20:39,430
from the given link.

289
00:20:41,580 --> 00:20:45,960
Let's see the browser.

290
00:20:49,980 --> 00:20:53,924
The parse one is the function which parses

291
00:20:53,972 --> 00:20:57,064
the ClI flag and that is implemented

292
00:20:57,112 --> 00:21:01,150
likewise. And you can see here the formal name.

293
00:21:03,920 --> 00:21:08,704
If it is not there, and if

294
00:21:08,742 --> 00:21:12,624
we have given the health or h

295
00:21:12,742 --> 00:21:16,672
as flag name,

296
00:21:16,806 --> 00:21:21,350
then we will get the usage of the CLI application.

297
00:21:25,880 --> 00:21:29,364
So this is how the

298
00:21:29,562 --> 00:21:33,380
flag model is implemented. You can go through this how the parse

299
00:21:33,460 --> 00:21:37,944
function works and how the parse function for

300
00:21:37,982 --> 00:21:39,960
each argument it parses.

301
00:21:43,440 --> 00:21:44,190
Okay,

302
00:21:49,620 --> 00:21:53,596
now we go through the final part of the session generating

303
00:21:53,708 --> 00:21:55,330
multiple random data.

304
00:21:56,900 --> 00:22:01,312
Let us start with generating a random number between a range

305
00:22:01,456 --> 00:22:05,750
given a max, min and max values from the

306
00:22:06,920 --> 00:22:08,340
CLI argument.

307
00:22:12,280 --> 00:22:16,790
So let's switch to the slide 26.

308
00:22:19,860 --> 00:22:23,696
Here we see we have a min and

309
00:22:23,718 --> 00:22:25,960
max variables,

310
00:22:26,140 --> 00:22:30,230
and those are bound to

311
00:22:31,560 --> 00:22:35,430
the min and max flags. And we have

312
00:22:36,440 --> 00:22:39,764
alias for mean as small m and capital

313
00:22:39,812 --> 00:22:43,624
m for max. And then we have

314
00:22:43,662 --> 00:22:46,904
a check where the max and max should

315
00:22:46,942 --> 00:22:48,890
be greater than min.

316
00:22:49,740 --> 00:22:53,980
We create a random generator

317
00:22:54,320 --> 00:22:58,284
and then create a random value from that and

318
00:22:58,322 --> 00:23:03,964
train the value. Let us build and check random

319
00:23:04,012 --> 00:23:07,264
ClI. Okay,

320
00:23:07,382 --> 00:23:11,490
we need to go mod vendor and then we build it

321
00:23:19,160 --> 00:23:22,692
random cli small m

322
00:23:22,826 --> 00:23:26,304
and capital m. We provide the mean as one and max

323
00:23:26,352 --> 00:23:29,784
as ten so we get a number between one and ten.

324
00:23:29,902 --> 00:23:33,320
If we provide max as 100 and mean as ten,

325
00:23:33,390 --> 00:23:36,010
we get a number between ten and 100.

326
00:23:40,710 --> 00:23:44,454
Now let's try generating random values using a

327
00:23:44,492 --> 00:23:47,794
third party library. We will use go fake

328
00:23:47,842 --> 00:23:51,698
it faker library which generates various types

329
00:23:51,714 --> 00:23:54,374
of valid random data such as address,

330
00:23:54,492 --> 00:23:57,050
name, text, et cetera.

331
00:24:02,690 --> 00:24:11,430
So let's go to the slide 27 and

332
00:24:12,280 --> 00:24:13,690
make a go mod.

333
00:24:18,220 --> 00:24:22,120
So here we have a student structure

334
00:24:22,700 --> 00:24:26,172
with a name, age,

335
00:24:26,306 --> 00:24:29,388
percentage, height, active with the

336
00:24:29,394 --> 00:24:33,576
given data types, string int float 32 int boolean

337
00:24:33,688 --> 00:24:36,920
and in the meta we have a description with a string data type.

338
00:24:37,090 --> 00:24:40,864
Now we will be using go

339
00:24:40,902 --> 00:24:44,770
fake it library and

340
00:24:46,420 --> 00:24:51,750
we seed the library and then we

341
00:24:52,120 --> 00:24:55,332
create a random we create

342
00:24:55,386 --> 00:24:58,852
random values for the fields of the struct using

343
00:24:58,906 --> 00:25:01,460
faker struct method.

344
00:25:02,920 --> 00:25:06,360
So then we

345
00:25:06,430 --> 00:25:09,492
dump the data in the structure.

346
00:25:09,556 --> 00:25:16,848
So let's compile that and seed.

347
00:25:16,964 --> 00:25:21,452
So as you can see here we have the

348
00:25:21,506 --> 00:25:24,990
name random values assigned to the name

349
00:25:25,360 --> 00:25:28,816
and other fields of

350
00:25:28,838 --> 00:25:30,000
the structure.

351
00:25:36,660 --> 00:25:40,320
We saw how we used the faker library to generate

352
00:25:40,400 --> 00:25:44,324
random data, but the data itself was not meaningful. We can

353
00:25:44,362 --> 00:25:47,396
provide some hints to get some meaningful data.

354
00:25:47,498 --> 00:25:48,710
Let us see how.

355
00:25:52,040 --> 00:25:56,516
So let's go to the slide

356
00:25:56,548 --> 00:26:01,576
28 and here we have address

357
00:26:01,758 --> 00:26:04,968
field and in the address field we

358
00:26:04,974 --> 00:26:08,152
have given some hints like

359
00:26:08,206 --> 00:26:12,110
strict street, city, zip, state and country.

360
00:26:12,560 --> 00:26:17,164
This will generate meaningful data for

361
00:26:17,202 --> 00:26:21,040
the given sales considering these hints.

362
00:26:21,540 --> 00:26:25,344
So we do the same. We again run

363
00:26:25,382 --> 00:26:30,930
the faker struct with the address and

364
00:26:31,480 --> 00:26:35,408
we execute that o mod vendor

365
00:26:35,584 --> 00:26:41,172
and run

366
00:26:41,226 --> 00:26:45,768
the build the code and

367
00:26:45,854 --> 00:26:49,620
again run it. So as you can see here we get meaningful

368
00:26:49,700 --> 00:26:52,616
street values, city values, pin code,

369
00:26:52,718 --> 00:26:54,090
state and country.

370
00:27:02,400 --> 00:27:06,812
We can also generate data using custom functions using

371
00:27:06,866 --> 00:27:08,300
the faker API.

372
00:27:10,660 --> 00:27:15,264
Let's see how. So we

373
00:27:15,302 --> 00:27:19,120
go to slide number 29 and here

374
00:27:19,190 --> 00:27:23,636
we have the address structure from

375
00:27:23,658 --> 00:27:27,652
the faker. We generate the address values using

376
00:27:27,706 --> 00:27:31,620
faker address and we assign the

377
00:27:31,690 --> 00:27:35,576
corresponding address values to the fields in

378
00:27:35,598 --> 00:27:39,400
our address struct and then dump the address

379
00:27:39,470 --> 00:27:43,320
value. So let's build

380
00:27:43,390 --> 00:27:47,462
it and

381
00:27:47,516 --> 00:27:50,954
run it. So as you can see again we

382
00:27:50,992 --> 00:27:54,730
got appropriate random values using

383
00:27:54,800 --> 00:27:57,130
the picker functions.

384
00:28:00,380 --> 00:28:05,116
Let's see how the

385
00:28:05,298 --> 00:28:08,396
gofaket library is what the

386
00:28:08,418 --> 00:28:11,848
API of Gofaket library provides.

387
00:28:12,024 --> 00:28:16,000
So we have various functions

388
00:28:18,020 --> 00:28:21,948
and the struct method

389
00:28:22,044 --> 00:28:23,170
that we used.

390
00:28:26,840 --> 00:28:31,140
So there are multiple different functions available for

391
00:28:31,210 --> 00:28:35,380
person generating person addresses

392
00:28:35,720 --> 00:28:40,970
and other miscellaneous things.

393
00:28:43,500 --> 00:28:47,256
So you can go through the

394
00:28:47,358 --> 00:28:50,536
API for learning more about how the

395
00:28:50,638 --> 00:28:52,170
Gofikit works.

396
00:28:53,840 --> 00:28:59,624
Now let's

397
00:28:59,672 --> 00:29:03,324
see here.

398
00:29:03,362 --> 00:29:07,824
We are having some

399
00:29:07,862 --> 00:29:11,520
of the libraries that we used for

400
00:29:11,590 --> 00:29:14,940
debugging the structure so that we can pretty print

401
00:29:15,020 --> 00:29:18,356
the struct and find what is the

402
00:29:18,378 --> 00:29:22,436
data in that. So you can refer this out

403
00:29:22,458 --> 00:29:27,012
of that. We are using spew dump and val

404
00:29:27,066 --> 00:29:30,856
ASD. So this can

405
00:29:30,878 --> 00:29:35,000
help you make a log based debugging.

406
00:29:44,240 --> 00:29:47,616
Let's see how we can embed data in

407
00:29:47,638 --> 00:29:51,164
the CLI app so that we can generate

408
00:29:51,292 --> 00:29:54,992
this embedded data later after the build based

409
00:29:55,046 --> 00:29:56,800
on command line flags.

410
00:30:00,120 --> 00:30:04,740
So let's check out 31

411
00:30:04,810 --> 00:30:08,420
slide 31 and we go

412
00:30:08,490 --> 00:30:12,088
mod. So here

413
00:30:12,254 --> 00:30:16,040
we have a person

414
00:30:16,110 --> 00:30:19,784
schema and we are embedding that

415
00:30:19,822 --> 00:30:23,772
person schema in our go application as

416
00:30:23,826 --> 00:30:27,260
defined here with the person schema variable.

417
00:30:29,760 --> 00:30:34,344
And then we generate

418
00:30:34,392 --> 00:30:36,610
a person.

419
00:30:37,380 --> 00:30:41,136
If the generate flag is present, then we generate a

420
00:30:41,158 --> 00:30:44,432
person schema. We generate the person

421
00:30:44,486 --> 00:30:45,360
schema.

422
00:30:47,800 --> 00:30:52,020
So let's see the person schema

423
00:30:52,760 --> 00:30:56,292
generation here we create a file and then write

424
00:30:56,346 --> 00:30:58,260
the person schema to that file.

425
00:31:00,300 --> 00:31:02,330
So let's see, let's build it.

426
00:31:06,490 --> 00:31:08,280
So here we will be,

427
00:31:09,930 --> 00:31:14,810
we can run the random

428
00:31:15,470 --> 00:31:19,130
and generate so here we generated the person schema file

429
00:31:19,790 --> 00:31:25,834
in the root directory by

430
00:31:25,872 --> 00:31:30,510
providing the command line argument as double dash generate.

431
00:31:31,730 --> 00:31:35,434
And one thing you can note here that the directory

432
00:31:35,482 --> 00:31:39,158
structure that we have is we have a commandline

433
00:31:39,274 --> 00:31:43,006
CMD directory and we have an internal directory in the internal directory.

434
00:31:43,118 --> 00:31:46,820
Whatever we have, it is internal for this application

435
00:31:47,350 --> 00:31:50,914
and no other application outside of

436
00:31:51,032 --> 00:31:55,590
this can import this directory

437
00:31:56,970 --> 00:32:00,546
exported values and CMD

438
00:32:00,658 --> 00:32:05,066
is for having the commandline for

439
00:32:05,088 --> 00:32:09,834
that. And you may also take

440
00:32:09,872 --> 00:32:14,006
a look at the mech file which generates the builds

441
00:32:14,038 --> 00:32:16,860
the command line application.

442
00:32:17,250 --> 00:32:20,922
So we have go build output directory specified

443
00:32:20,986 --> 00:32:24,826
as bin, provide the eligible flags if applicable,

444
00:32:25,018 --> 00:32:29,030
and then provide the structured directory structure

445
00:32:29,210 --> 00:32:31,380
that will be built.

446
00:32:36,150 --> 00:32:39,982
So go generates

447
00:32:40,046 --> 00:32:43,954
the directory, the command line applications

448
00:32:44,002 --> 00:32:47,186
with the same name as the directory where the main file

449
00:32:47,218 --> 00:32:51,426
is located, and hence

450
00:32:51,458 --> 00:32:55,574
we got the random CLI binary

451
00:32:55,622 --> 00:32:57,130
file in the bin directory.

452
00:33:04,030 --> 00:33:07,290
As we saw, we were able to generate the embedded file

453
00:33:07,370 --> 00:33:09,150
using CLI flag.

454
00:33:11,330 --> 00:33:15,694
Previously we have been generating only a single set of data.

455
00:33:15,892 --> 00:33:19,366
Now we will look at how to generate multiple random

456
00:33:19,418 --> 00:33:23,074
sets of data. We will generate a few person details using the

457
00:33:23,112 --> 00:33:26,322
number of persons count from the CLI num

458
00:33:26,376 --> 00:33:29,380
flag. Let's look at the code.

459
00:33:30,470 --> 00:33:34,194
So we will switch to slide

460
00:33:34,242 --> 00:33:35,880
number 33.

461
00:33:38,890 --> 00:33:43,366
So here we

462
00:33:43,388 --> 00:33:46,700
have a, we have the commandline application,

463
00:33:47,230 --> 00:33:51,290
we have a package directory where we have defined

464
00:33:52,430 --> 00:33:55,834
the details of the person

465
00:33:56,032 --> 00:33:57,280
that we need.

466
00:34:01,730 --> 00:34:05,760
And this will also have a new person

467
00:34:07,410 --> 00:34:11,186
factory function which will construct a person

468
00:34:11,288 --> 00:34:15,490
using the faker struct. And we

469
00:34:15,560 --> 00:34:19,650
also have provided hints for the person,

470
00:34:19,800 --> 00:34:23,560
that is the address for the first name, last name,

471
00:34:24,810 --> 00:34:27,894
and then we create a new

472
00:34:27,932 --> 00:34:28,520
person.

473
00:34:33,530 --> 00:34:37,434
So this is the

474
00:34:37,552 --> 00:34:41,242
internal CMD which will generate the persons based

475
00:34:41,296 --> 00:34:45,450
on some number of persons that we want to generate.

476
00:34:46,930 --> 00:34:50,750
And here the command line

477
00:34:50,900 --> 00:34:54,030
application will simply call that method,

478
00:34:54,370 --> 00:34:57,040
call that function and generate function.

479
00:34:57,410 --> 00:35:01,106
Persons and number of persons will be provided from

480
00:35:01,128 --> 00:35:05,140
the CLI. By default, number of persons was one

481
00:35:06,790 --> 00:35:10,062
and then we are printing the persons

482
00:35:10,126 --> 00:35:14,194
which we are generating. So when we print

483
00:35:14,242 --> 00:35:18,200
this then person,

484
00:35:19,690 --> 00:35:23,874
this stringer interface has been implemented and this

485
00:35:23,932 --> 00:35:27,434
is executed and the

486
00:35:27,472 --> 00:35:31,082
value return value is printed in the command line.

487
00:35:31,216 --> 00:35:37,044
So let's build it and

488
00:35:37,082 --> 00:35:40,632
provide the number of person.

489
00:35:40,766 --> 00:35:44,970
We can provide an alias using hyphen n.

490
00:35:45,500 --> 00:35:49,940
So let's generate ten persons.

491
00:35:50,100 --> 00:35:53,790
So as you can see here, we have generated ten

492
00:35:55,520 --> 00:35:59,004
persons with

493
00:35:59,122 --> 00:36:00,460
address values.

494
00:36:07,010 --> 00:36:10,254
We generated the data one after the other. We can also

495
00:36:10,292 --> 00:36:13,706
generate concurrently using go routines.

496
00:36:13,898 --> 00:36:16,970
We make use of weight groups and go routines.

497
00:36:17,130 --> 00:36:21,218
Let's see the code and see how we can generate the

498
00:36:21,384 --> 00:36:25,650
data concurrently. Let's switch to

499
00:36:25,720 --> 00:36:27,380
slide number 34.

500
00:36:30,250 --> 00:36:34,390
And here if we go to the internal

501
00:36:34,810 --> 00:36:38,758
CMD person we are using a weight group

502
00:36:38,924 --> 00:36:42,778
and we are generating the data concurrently. Here we have a

503
00:36:42,784 --> 00:36:45,978
go routine and we have a wait group to wait for

504
00:36:46,144 --> 00:36:49,434
all the coroutines to complete.

505
00:36:49,632 --> 00:36:53,510
So in this case all the coroutines are run simultaneously.

506
00:36:53,670 --> 00:36:57,902
So let's build

507
00:36:57,956 --> 00:37:01,440
it and run it.

508
00:37:03,330 --> 00:37:07,086
So it gives the same ten number of

509
00:37:07,108 --> 00:37:11,726
persons but all these persons

510
00:37:11,758 --> 00:37:13,970
are generated simultaneously.

511
00:37:14,390 --> 00:37:18,046
And the faker

512
00:37:18,078 --> 00:37:21,986
library all supports the simultaneous

513
00:37:22,098 --> 00:37:23,800
generation of person.

514
00:37:27,610 --> 00:37:30,850
Using it supports constructor concurrency.

515
00:37:31,010 --> 00:37:31,720
Sorry.

516
00:37:39,280 --> 00:37:42,616
So previously the concurrent threads

517
00:37:42,648 --> 00:37:46,204
ran all at a time, but we can also restrict the number

518
00:37:46,242 --> 00:37:50,128
of concurrent threads that run at a time which runs the data.

519
00:37:50,294 --> 00:37:53,644
We can make use of buffered channel to achieve

520
00:37:53,692 --> 00:37:57,136
this. Let's see how we go

521
00:37:57,158 --> 00:38:04,036
to slide number 35 and

522
00:38:04,138 --> 00:38:07,060
go to the persons.

523
00:38:07,960 --> 00:38:12,368
Here we

524
00:38:12,554 --> 00:38:16,996
go to main and let's

525
00:38:17,028 --> 00:38:20,664
see the

526
00:38:20,702 --> 00:38:23,976
number of persons we accept using the

527
00:38:23,998 --> 00:38:27,596
num flag and the concurrency using

528
00:38:27,698 --> 00:38:30,892
the concurrency and

529
00:38:31,026 --> 00:38:36,364
we are printing based on this and

530
00:38:36,402 --> 00:38:40,240
we pass the concurrency that we get from

531
00:38:40,310 --> 00:38:43,952
the generate person options through the generate person

532
00:38:44,006 --> 00:38:48,144
options to the gen

533
00:38:48,182 --> 00:38:54,164
persons function. And here

534
00:38:54,202 --> 00:38:57,604
we create a buffer for the

535
00:38:57,642 --> 00:39:01,444
kind of buffer for the channel and

536
00:39:01,482 --> 00:39:04,520
then we fill in the buffer,

537
00:39:04,940 --> 00:39:08,388
adding things in queue till

538
00:39:08,404 --> 00:39:12,536
the buffer is filled. And then we run the go routine as

539
00:39:12,558 --> 00:39:16,712
and when the go routine succeeds the buffer will be cleared

540
00:39:16,856 --> 00:39:20,396
and from here we wait for the go routines, all the go

541
00:39:20,418 --> 00:39:25,372
routines to be finished. And once

542
00:39:25,426 --> 00:39:29,136
there is less than the

543
00:39:29,158 --> 00:39:34,064
maximum buffer amount of data then this

544
00:39:34,102 --> 00:39:38,320
is returned and we get all the persons

545
00:39:39,140 --> 00:39:51,990
from here, so let's build it and

546
00:39:53,500 --> 00:39:56,648
so print the data.

547
00:39:56,814 --> 00:40:00,264
So this will use the concurrency of eight as

548
00:40:00,302 --> 00:40:03,400
the default or we can also specify the concurrency.

549
00:40:04,380 --> 00:40:07,452
As you can see here, we specify the concurrency as

550
00:40:07,506 --> 00:40:11,304
three and we generated ten persons

551
00:40:11,352 --> 00:40:11,950
data.

552
00:40:18,560 --> 00:40:21,900
It now that we have learned how to generate

553
00:40:21,980 --> 00:40:25,612
random data, we will use that to generate

554
00:40:25,676 --> 00:40:28,770
XML file output with random data.

555
00:40:29,140 --> 00:40:33,328
We will have the CLI flags for specifying the output

556
00:40:33,424 --> 00:40:36,724
directory and the name of the

557
00:40:36,762 --> 00:40:38,020
XML file.

558
00:40:41,960 --> 00:40:46,084
Here we also output the embedded schema file

559
00:40:46,132 --> 00:40:50,004
along with the XML. We pass the number of records

560
00:40:50,052 --> 00:40:54,356
to be created using hyphen n, the output

561
00:40:54,388 --> 00:40:57,784
directory using hyphen O, and the name of the XML

562
00:40:57,832 --> 00:41:01,452
file using hyphen capital n, and optionally pass

563
00:41:01,506 --> 00:41:05,230
the concurrency as well using hyphen C like before.

564
00:41:05,600 --> 00:41:09,516
This will create an XML and an XSD schema

565
00:41:09,548 --> 00:41:12,780
file for the XML. Now let's

566
00:41:12,860 --> 00:41:14,210
dive into the code.

567
00:41:16,260 --> 00:41:19,810
So we switch to slide number 37.

568
00:41:22,520 --> 00:41:26,768
So if we go to the command CMD

569
00:41:26,864 --> 00:41:30,310
directory and check the

570
00:41:31,880 --> 00:41:35,400
available flags which are bound,

571
00:41:35,820 --> 00:41:39,432
we have a num flag, we have a concurrency print name

572
00:41:39,486 --> 00:41:42,936
of the XML file, output directory of

573
00:41:42,958 --> 00:41:47,304
the XML file and force if we want to overwrite

574
00:41:47,352 --> 00:41:50,140
the files in the directory.

575
00:41:50,480 --> 00:41:53,976
So we will be outputting it to temporary

576
00:41:54,008 --> 00:41:57,310
directory. So let's delete that and

577
00:42:02,500 --> 00:42:06,512
we have some aliases. So let's first

578
00:42:06,646 --> 00:42:10,900
build it and see how we can generate

579
00:42:12,680 --> 00:42:15,568
XML file and associated XST file.

580
00:42:15,664 --> 00:42:18,310
And then we will look at the code.

581
00:42:19,880 --> 00:42:24,052
So XML

582
00:42:24,116 --> 00:42:28,792
CLI and we use

583
00:42:28,846 --> 00:42:33,290
the number as ten and

584
00:42:35,200 --> 00:42:39,116
the name of the XML as first gen and

585
00:42:39,138 --> 00:42:41,420
the output directory to be temporary directory.

586
00:42:42,160 --> 00:42:46,040
So here you can see we generated

587
00:42:46,120 --> 00:42:51,890
an XML file and

588
00:42:52,900 --> 00:42:57,010
we have the XST file associated with that.

589
00:42:58,500 --> 00:43:02,772
This xst file we have embedded from

590
00:43:02,826 --> 00:43:06,810
here using

591
00:43:06,880 --> 00:43:10,298
go embed and then we

592
00:43:10,384 --> 00:43:16,350
generate the XmL file using the XML

593
00:43:16,930 --> 00:43:20,160
struct that is found here

594
00:43:21,090 --> 00:43:24,510
and the persons are the items of the XML

595
00:43:25,410 --> 00:43:30,366
and that can be added

596
00:43:30,398 --> 00:43:33,586
from here. So persons data is the same

597
00:43:33,768 --> 00:43:37,860
person struct and the

598
00:43:38,330 --> 00:43:42,630
associated person data. So here again we are using the

599
00:43:42,780 --> 00:43:46,434
buffered concurrenced way of generating

600
00:43:46,482 --> 00:43:49,250
the data and creating the XML.

601
00:43:49,410 --> 00:43:53,014
So in this internal CMD file

602
00:43:53,142 --> 00:43:56,762
we create the XML using

603
00:43:56,816 --> 00:44:01,610
generate XML and this will write the data

604
00:44:01,760 --> 00:44:05,290
to the XML. We create an encoder for the XML

605
00:44:05,450 --> 00:44:07,710
and then we encode the XML.

606
00:44:09,970 --> 00:44:12,670
After that we create the XML file.

607
00:44:13,890 --> 00:44:18,034
So this will check if the file is existing and if

608
00:44:18,072 --> 00:44:21,730
it exists and the force is not true then it will

609
00:44:21,880 --> 00:44:25,278
give this error as file already exists.

610
00:44:25,454 --> 00:44:29,480
Otherwise it will create the file and

611
00:44:31,210 --> 00:44:34,786
generate the person generate the XML,

612
00:44:34,978 --> 00:44:38,022
create the schema file and then

613
00:44:38,076 --> 00:44:42,074
return. So schema file is

614
00:44:42,112 --> 00:44:45,514
also specified here, how it is being

615
00:44:45,552 --> 00:44:47,530
written to the disk,

616
00:44:48,910 --> 00:44:52,886
and then the schema

617
00:44:52,918 --> 00:44:56,910
file is after returning it will print the concurrency.

618
00:44:57,490 --> 00:44:58,590
Likewise,

619
00:45:02,450 --> 00:45:05,518
till now we created randomized data,

620
00:45:05,684 --> 00:45:09,138
but we can also pass some predefined data

621
00:45:09,224 --> 00:45:12,654
for a few fields and the rest will be random

622
00:45:12,702 --> 00:45:16,514
data. We can do that using a JSOn file as

623
00:45:16,552 --> 00:45:19,926
input. With the given data we will generate the

624
00:45:19,948 --> 00:45:23,366
placeholder JSON file and the JSON schema for the

625
00:45:23,388 --> 00:45:27,346
file using the hyphen g flag. This will create the files

626
00:45:27,378 --> 00:45:30,614
under the directory passed using the hyphen o

627
00:45:30,652 --> 00:45:34,390
flag and we will input the prefilled

628
00:45:34,470 --> 00:45:37,894
json file using the hyphen

629
00:45:37,942 --> 00:45:41,562
iflag. Now running

630
00:45:41,616 --> 00:45:45,226
our CLI app using the same parameters for generating

631
00:45:45,258 --> 00:45:48,762
the XML as before, we get the XML

632
00:45:48,826 --> 00:45:52,430
and XST files created in the output directory.

633
00:45:55,090 --> 00:46:00,904
Now let's look at the code switch

634
00:46:00,952 --> 00:46:10,770
to slide number 39 it.

635
00:46:11,460 --> 00:46:16,864
So here we

636
00:46:16,902 --> 00:46:20,636
have a few more flags like the input

637
00:46:20,668 --> 00:46:23,456
flag and the generate flag.

638
00:46:23,568 --> 00:46:26,596
The generate flag will generate the input Json and

639
00:46:26,618 --> 00:46:30,752
schema and input flag will input the prefilled

640
00:46:30,896 --> 00:46:36,306
Json data. So this

641
00:46:36,328 --> 00:46:40,466
is the schema input schema and this

642
00:46:40,488 --> 00:46:44,610
is the placeholder

643
00:46:45,670 --> 00:46:49,080
input json. So these two files are

644
00:46:49,850 --> 00:46:52,886
embedded. This is Json schema that is

645
00:46:52,908 --> 00:46:56,950
embedded and then this is the input Json file that is embedded

646
00:46:57,370 --> 00:47:00,934
and those files are generated when

647
00:47:00,972 --> 00:47:04,760
we run hyphen g

648
00:47:05,850 --> 00:47:10,102
when we generate using this and we have a few aliases

649
00:47:10,166 --> 00:47:14,640
as we usually do. So let's first

650
00:47:15,730 --> 00:47:19,120
remove the temporary directory and

651
00:47:21,410 --> 00:47:24,030
we can output generate.

652
00:47:25,090 --> 00:47:28,290
We will go mod vendor,

653
00:47:28,950 --> 00:47:32,340
we'll build the cli application,

654
00:47:34,870 --> 00:47:38,260
see how we can generate a

655
00:47:42,490 --> 00:47:46,214
so input json. So here

656
00:47:46,412 --> 00:47:50,390
we created an input json placeholder file.

657
00:47:52,990 --> 00:47:56,714
So here we can

658
00:47:56,752 --> 00:48:00,780
provide the first name and

659
00:48:01,470 --> 00:48:04,000
rest of the fields will be randomized data.

660
00:48:06,450 --> 00:48:10,314
So let's see if it is generic

661
00:48:10,442 --> 00:48:14,746
input json. If hyphen g command

662
00:48:14,778 --> 00:48:19,410
line argument is provided, then it will create

663
00:48:19,480 --> 00:48:23,154
an input Json file. And if

664
00:48:23,192 --> 00:48:26,958
we go into that we will generate an input

665
00:48:26,974 --> 00:48:30,660
json file in the given directory. And also

666
00:48:31,670 --> 00:48:36,114
we will create a schema file along

667
00:48:36,152 --> 00:48:39,646
with that. So this is the input schema file and this is the input json

668
00:48:39,678 --> 00:48:41,420
file it.

669
00:48:48,590 --> 00:48:53,194
Now if g

670
00:48:53,232 --> 00:48:57,002
is not there and we want to generate

671
00:48:57,066 --> 00:48:59,760
the xml file like before.

672
00:49:00,450 --> 00:49:04,030
So here we provide the predefined

673
00:49:05,590 --> 00:49:10,206
person. So the person is taken from the input

674
00:49:10,318 --> 00:49:13,726
file. If we have an input file

675
00:49:13,758 --> 00:49:17,474
path provided, then it will generate a

676
00:49:17,672 --> 00:49:19,160
refilled person.

677
00:49:21,050 --> 00:49:24,406
It will read the input json file and unmarshall it to the

678
00:49:24,428 --> 00:49:27,160
person info and return that.

679
00:49:28,090 --> 00:49:31,526
So that is added in the person info

680
00:49:31,638 --> 00:49:34,490
and it will pass to the xml generation.

681
00:49:36,750 --> 00:49:40,330
So here in the xml generation everything

682
00:49:40,400 --> 00:49:44,126
is as before. But while generating the

683
00:49:44,148 --> 00:49:46,800
person we also pass the predefined person data.

684
00:49:47,170 --> 00:49:51,114
And if we check the get generate

685
00:49:51,162 --> 00:49:55,294
person here we are copying the predefined data with

686
00:49:55,332 --> 00:49:59,410
the randomized data. This is the new code

687
00:49:59,480 --> 00:50:03,042
change that we have and for copying we have

688
00:50:03,096 --> 00:50:06,820
this code.

689
00:50:09,450 --> 00:50:13,174
Now let

690
00:50:13,212 --> 00:50:17,394
us see, since we have already added

691
00:50:17,442 --> 00:50:21,526
a first name to the prefilled

692
00:50:21,638 --> 00:50:26,250
JSON, so we can input that input JSON

693
00:50:26,590 --> 00:50:32,330
and we can name the XML file as Abhisaic

694
00:50:34,290 --> 00:50:38,126
and create ten records and the

695
00:50:38,148 --> 00:50:40,670
output specified will be temporary.

696
00:50:41,170 --> 00:50:44,526
So this will create an XML file with

697
00:50:44,548 --> 00:50:51,042
the first name prefilled as Abhishek and

698
00:50:51,096 --> 00:50:55,106
other fields are randomized. Now if

699
00:50:55,128 --> 00:51:00,280
we provide the last name as well and

700
00:51:01,850 --> 00:51:06,386
we generate the same thing with hyphen

701
00:51:06,418 --> 00:51:11,030
f so that we can force the overriding of the XML file.

702
00:51:12,590 --> 00:51:15,786
Then if we go to the

703
00:51:15,808 --> 00:51:19,222
XML file as you can see here, we generated

704
00:51:19,286 --> 00:51:22,618
the randomized data with some prefilled data for

705
00:51:22,624 --> 00:51:25,550
the first name and last name for all the records.

706
00:51:28,850 --> 00:51:32,394
So we discussed how we build a CLI

707
00:51:32,442 --> 00:51:36,734
application with randomly generated data input

708
00:51:36,782 --> 00:51:39,774
JSON with mixed data type fills,

709
00:51:39,902 --> 00:51:43,534
embed and generate XML and JSON files

710
00:51:43,582 --> 00:51:47,474
with prefilled data. So here are the key

711
00:51:47,512 --> 00:51:51,106
takeaways. CLA apps are important

712
00:51:51,208 --> 00:51:54,998
tools for developers and Go is a great

713
00:51:55,084 --> 00:51:59,250
language for building them due to its strong support for command line interfaces.

714
00:51:59,410 --> 00:52:03,094
The flag module in Go is a powerful tool for parsing command line

715
00:52:03,132 --> 00:52:07,082
arguments and building CLA apps to generate data

716
00:52:07,136 --> 00:52:10,986
concurrently. You can use Go's powerful concurrency features such

717
00:52:11,008 --> 00:52:14,922
as channels and Go routines. You can override randomized

718
00:52:14,986 --> 00:52:18,474
data with predefined data. When building CLI

719
00:52:18,522 --> 00:52:22,638
apps in Go, it's important to keep the user experience in mind and provide

720
00:52:22,724 --> 00:52:26,674
clear and helpful error messages when commandline arguments are

721
00:52:26,712 --> 00:52:29,986
incorrect. With the techniques covered in this talk,

722
00:52:30,088 --> 00:52:33,858
you'll be able to build powerful and flexible CLI applications in Go

723
00:52:33,944 --> 00:52:37,570
that can generate randomized data quickly and efficiently.

724
00:52:40,840 --> 00:52:45,076
Here are some of the resources that will

725
00:52:45,098 --> 00:52:48,740
be helpful for you in your journey to become the master of CLI.

726
00:52:49,160 --> 00:52:54,490
The first one is the repository for the workshop and

727
00:52:55,420 --> 00:52:58,984
then there is the presentation for the workshop which you can

728
00:52:59,022 --> 00:53:02,264
get from these links and

729
00:53:02,462 --> 00:53:06,364
awesome list of CLI applications are a list of

730
00:53:06,482 --> 00:53:09,804
CLI applications which

731
00:53:09,842 --> 00:53:12,940
will be helpful to

732
00:53:13,010 --> 00:53:16,350
understand how the CLI applications work.

733
00:53:16,720 --> 00:53:21,148
Flag model is the flag model API

734
00:53:21,244 --> 00:53:24,896
provided in the Go documentation and

735
00:53:24,918 --> 00:53:28,544
then there is a flag model source code that you can go

736
00:53:28,582 --> 00:53:32,588
through the GitHub library that we used for aliasing,

737
00:53:32,684 --> 00:53:36,736
the faker library that we use for generating fake data and

738
00:53:36,838 --> 00:53:40,988
if you want to build powerful and more complex

739
00:53:41,084 --> 00:53:44,440
CLis, then framework will come in handy.

740
00:53:48,640 --> 00:53:52,536
If you have any questions, do reach out to me. Kindly forgive

741
00:53:52,568 --> 00:53:56,236
me for any mistakes that I might have made, either verbal or

742
00:53:56,258 --> 00:53:59,804
otherwise. Please scan the code and

743
00:53:59,922 --> 00:54:02,730
provide anonymous feedback. Thank you.

