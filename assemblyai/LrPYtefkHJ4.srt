1
00:00:27,810 --> 00:00:31,618
Hello, welcome in our session. My name is Carlo

2
00:00:31,634 --> 00:00:35,142
Skripak, I'm technical director in the Melodic project

3
00:00:35,276 --> 00:00:38,886
and today, together with Alaran from

4
00:00:38,908 --> 00:00:42,566
the Melodic project, ALA is a technical lead in

5
00:00:42,588 --> 00:00:46,102
this project. We will tell you

6
00:00:46,156 --> 00:00:49,270
about our platform, our project,

7
00:00:49,420 --> 00:00:53,182
and probably most important, we will tell you how to

8
00:00:53,236 --> 00:00:56,942
deploy application into the multicloud and how to

9
00:00:56,996 --> 00:01:00,218
done it with the optimized way, fully automatic

10
00:01:00,314 --> 00:01:05,362
to the different cloud provided and

11
00:01:05,416 --> 00:01:09,010
using optimized resources

12
00:01:09,750 --> 00:01:13,410
to save the cost and to maximize the performance

13
00:01:13,750 --> 00:01:17,170
of the applications. Let's start from the very beginning.

14
00:01:17,250 --> 00:01:20,822
What is Melodic? Melodic is a single

15
00:01:20,956 --> 00:01:24,774
universal platform for two things. One is the

16
00:01:24,812 --> 00:01:28,086
deployment, automatic deployment of the application to

17
00:01:28,108 --> 00:01:32,118
the multi cloud, so to the different cloud providers.

18
00:01:32,294 --> 00:01:35,834
And the second one is the optimization of the

19
00:01:35,872 --> 00:01:40,570
usage of the resources. So melodic automatically optimizes

20
00:01:40,930 --> 00:01:44,334
which resources are used and how

21
00:01:44,372 --> 00:01:48,462
to save the cost, maximize the performance and

22
00:01:48,596 --> 00:01:51,760
other elements of the application.

23
00:01:52,630 --> 00:01:56,866
Melodic is fully open resources project so

24
00:01:56,888 --> 00:02:01,054
it cloud be download and use. It has been created

25
00:02:01,102 --> 00:02:05,134
using the horizontal 2020 melodic project and

26
00:02:05,192 --> 00:02:08,742
is further developed by the

27
00:02:08,796 --> 00:02:12,246
seven Bulls company. Today we

28
00:02:12,268 --> 00:02:16,198
will tell you what melodic is. We will show

29
00:02:16,364 --> 00:02:19,894
some use cases so how it can be used for the AI

30
00:02:19,942 --> 00:02:23,594
based application. And here we have the example of

31
00:02:23,632 --> 00:02:26,682
the AI investments company which is using

32
00:02:26,816 --> 00:02:31,466
melodic to optimize their trainings and trainings

33
00:02:31,498 --> 00:02:35,134
of their machine learning models. And also we

34
00:02:35,172 --> 00:02:38,286
will show the example of the big data application

35
00:02:38,468 --> 00:02:42,602
based off nongenome which is used during the

36
00:02:42,756 --> 00:02:46,798
research related to the genome processing and genome

37
00:02:46,894 --> 00:02:50,594
mutation identification. So I hope that you will

38
00:02:50,632 --> 00:02:54,098
find this session interesting. The first question

39
00:02:54,184 --> 00:02:57,942
is why we should use platform like

40
00:02:57,996 --> 00:03:01,942
melodic to deploy the applications. The first

41
00:03:01,996 --> 00:03:06,194
and probably the most important reasons is that melodic

42
00:03:06,242 --> 00:03:09,494
is the simplest and easiest way to use the

43
00:03:09,532 --> 00:03:13,526
multi cloud approach. So instead of deploying manually

44
00:03:13,638 --> 00:03:17,434
application choosing or selecting manually the

45
00:03:17,472 --> 00:03:21,200
right cloud CTO which we want to deploy the application,

46
00:03:21,570 --> 00:03:25,406
it is automatically done by the melodic based on

47
00:03:25,428 --> 00:03:29,054
the already predefined model. The second thing is that

48
00:03:29,092 --> 00:03:32,706
it's probably the only one unified way to

49
00:03:32,728 --> 00:03:35,278
deploy virtual machines, containers,

50
00:03:35,374 --> 00:03:39,182
serverless and big data frameworks automatically

51
00:03:39,246 --> 00:03:42,654
to the different cloud providers. So melodic

52
00:03:42,702 --> 00:03:45,846
supports all of these components and even more.

53
00:03:45,948 --> 00:03:50,242
We're currently working on the support for the GPU

54
00:03:50,306 --> 00:03:54,102
and FPGA's accelerators to

55
00:03:54,156 --> 00:03:58,834
allow to deploy the machine learning workloads

56
00:03:58,882 --> 00:04:02,402
to the accelerated resources.

57
00:04:02,546 --> 00:04:07,234
As I said, it is automatically deployed to these cloud providers

58
00:04:07,362 --> 00:04:11,262
listed below. So we are integrated them and the

59
00:04:11,316 --> 00:04:15,550
deployment is done fully, automatically and even more.

60
00:04:15,620 --> 00:04:19,594
Melodic optimize the usage of the cloud computing

61
00:04:19,642 --> 00:04:24,254
resources. So melodic fetch all of the offers

62
00:04:24,302 --> 00:04:27,790
from the cloud providers with pricing, with technical

63
00:04:27,870 --> 00:04:32,114
parameters and select the

64
00:04:32,152 --> 00:04:35,586
best one set of the resources to deploy

65
00:04:35,618 --> 00:04:40,790
the application. And even more, it automatically

66
00:04:41,610 --> 00:04:45,174
monitor the application and reconfigure the

67
00:04:45,212 --> 00:04:48,646
application to optimize that deployment.

68
00:04:48,758 --> 00:04:52,234
It's a very unique and probably the

69
00:04:52,272 --> 00:04:55,834
only one platform which supports all

70
00:04:55,872 --> 00:04:59,900
of this. The first step is to model the application

71
00:05:00,210 --> 00:05:03,662
and we are using the camel cloud application

72
00:05:03,796 --> 00:05:07,582
modeling and execution language. It is

73
00:05:07,636 --> 00:05:11,006
the cloud agnostic language, not like

74
00:05:11,028 --> 00:05:14,622
a cloud formation or heat or so it's

75
00:05:14,766 --> 00:05:18,606
very similar to the Tosca, but also contains

76
00:05:18,638 --> 00:05:22,706
the superset of additional features. Comparing to

77
00:05:22,728 --> 00:05:26,534
the Tosca, we can model application so

78
00:05:26,572 --> 00:05:30,322
not only the infrastructure, but also the application components,

79
00:05:30,386 --> 00:05:34,802
connections, security. We can of course model infrastructure

80
00:05:34,866 --> 00:05:37,458
as well. And very important,

81
00:05:37,644 --> 00:05:40,166
we can define requirements,

82
00:05:40,278 --> 00:05:44,202
constraints and utility function value for our

83
00:05:44,256 --> 00:05:47,514
application. Thanks to that, we are

84
00:05:47,552 --> 00:05:51,222
able to transform this model into the mathematical

85
00:05:51,286 --> 00:05:54,874
form like a constraint

86
00:05:54,922 --> 00:05:58,782
programming model. And this constraint programming model is

87
00:05:58,836 --> 00:06:02,010
based for the optimizing resources

88
00:06:02,090 --> 00:06:05,954
and that's the very unique element of

89
00:06:05,992 --> 00:06:09,582
the melodic platform. The second unique element

90
00:06:09,726 --> 00:06:13,474
is the way of determining what

91
00:06:13,512 --> 00:06:17,234
is the best deployment. Melodic collect the

92
00:06:17,272 --> 00:06:21,074
metrics or the different measurements like the cpu

93
00:06:21,122 --> 00:06:24,674
usage, memory usage and other technical metrics,

94
00:06:24,802 --> 00:06:28,486
but also the business metrics like average response

95
00:06:28,518 --> 00:06:31,994
time to the customer, average handling time for

96
00:06:32,032 --> 00:06:35,530
the customer, average time for the processing given

97
00:06:35,600 --> 00:06:39,382
job, and so on. And additional metric

98
00:06:39,446 --> 00:06:42,546
could be very easily add especially the metric

99
00:06:42,598 --> 00:06:46,142
specific for the application. Based on that

100
00:06:46,196 --> 00:06:50,080
collected metrics and the current deployment, we can

101
00:06:50,770 --> 00:06:54,482
define so called utility function

102
00:06:54,616 --> 00:06:58,526
which defines what is this best deployments.

103
00:06:58,638 --> 00:07:01,938
Usually this deployment is a trade off

104
00:07:02,024 --> 00:07:05,814
between the cost, performance, availability, security and

105
00:07:05,852 --> 00:07:09,014
other elements. Because if

106
00:07:09,052 --> 00:07:12,582
we do not have this trade off, then if we want

107
00:07:12,636 --> 00:07:16,006
to minimize the cost, then we just do not need to

108
00:07:16,028 --> 00:07:19,370
deploy the application because the cost will be zero.

109
00:07:19,520 --> 00:07:23,974
If we want to maximize performance without minimizing

110
00:07:24,022 --> 00:07:27,962
the cost, then we can deploy application

111
00:07:28,096 --> 00:07:31,838
on the biggest virtual machines, or also usually

112
00:07:32,004 --> 00:07:35,642
we have this trade off between the cost and performance,

113
00:07:35,706 --> 00:07:39,454
availability and so on. And melodic, based on

114
00:07:39,492 --> 00:07:42,618
the defined utility function is able

115
00:07:42,724 --> 00:07:45,890
to find the optimal solution for

116
00:07:45,960 --> 00:07:49,890
that. And this is the very unique

117
00:07:50,230 --> 00:07:54,302
feature of the melodic. It is not supported,

118
00:07:54,366 --> 00:07:59,202
at least according to my knowledge, by other platforms.

119
00:07:59,346 --> 00:08:02,918
How melodic works the first step is to

120
00:08:03,004 --> 00:08:06,566
prepare the application, the model of the application,

121
00:08:06,748 --> 00:08:10,506
and set the parameters, initial values of

122
00:08:10,528 --> 00:08:14,234
the requirements and constraints. It is done once,

123
00:08:14,352 --> 00:08:18,486
only once. Of course the parameters could be adjust,

124
00:08:18,678 --> 00:08:22,334
but they are also adjusted by the melodic during

125
00:08:22,372 --> 00:08:25,710
the optimization process. So it is usually done

126
00:08:25,860 --> 00:08:30,026
once. And after that melodic calculates

127
00:08:30,138 --> 00:08:34,578
initial deployments based on the predefined parameters and

128
00:08:34,664 --> 00:08:38,846
deploy the application to the selected cloud providers.

129
00:08:39,038 --> 00:08:43,758
After the deployment, the metrics started to be collected

130
00:08:43,934 --> 00:08:47,414
and melodic is verifying if the certain

131
00:08:47,532 --> 00:08:51,320
threshold are exceeded. So for example,

132
00:08:51,770 --> 00:08:55,842
if the response time is too long, or the typical

133
00:08:55,906 --> 00:09:00,662
processing time is too long, or any other metric

134
00:09:00,726 --> 00:09:04,566
is exceeded, we called that SLO violation.

135
00:09:04,678 --> 00:09:08,602
So in case of this SLO violation, the new

136
00:09:08,656 --> 00:09:12,554
deployment, the new solution is calculated,

137
00:09:12,682 --> 00:09:16,080
new optimization is started with the new

138
00:09:17,250 --> 00:09:20,430
values of the metrics and the parameters.

139
00:09:20,850 --> 00:09:25,262
Thanks to that, melodic is continuously optimizing

140
00:09:25,326 --> 00:09:28,434
application to allow them and to

141
00:09:28,472 --> 00:09:32,580
adjust them to the current workload. So it

142
00:09:33,030 --> 00:09:37,170
doesn't need to be done manually or through the predefined

143
00:09:37,250 --> 00:09:41,138
set of rules. It is done completely automatically.

144
00:09:41,314 --> 00:09:45,762
Melodic is using very advanced optimization algorithms.

145
00:09:45,906 --> 00:09:50,022
We are using constraint programming

146
00:09:50,086 --> 00:09:53,382
optimization, we are using genetic optimization.

147
00:09:53,526 --> 00:09:57,270
We are using Monte Carlo research with neural network

148
00:09:57,350 --> 00:10:01,294
in the similar way as the alphago is using for

149
00:10:01,332 --> 00:10:04,986
solving the optimization platform. So the results

150
00:10:05,018 --> 00:10:09,006
of proactive optimization are really good.

151
00:10:09,188 --> 00:10:12,390
Here we have the overall architecture of the melodic.

152
00:10:12,490 --> 00:10:16,066
I maybe not go into too deeply into that,

153
00:10:16,168 --> 00:10:20,146
but few key elements are that we

154
00:10:20,168 --> 00:10:23,394
are using the microservice architecture. Each of

155
00:10:23,432 --> 00:10:26,850
the key module is a separate microservice.

156
00:10:27,010 --> 00:10:30,546
We are using enterprise service pass mule,

157
00:10:30,578 --> 00:10:34,610
esp in the community edition as a control plane.

158
00:10:34,770 --> 00:10:38,474
The logic and business flow is

159
00:10:38,512 --> 00:10:42,362
orchestrated through the BPM. We are using Kamunda and

160
00:10:42,416 --> 00:10:46,390
monitoring plane using for the sending metrics

161
00:10:46,550 --> 00:10:50,414
is done presented using

162
00:10:50,452 --> 00:10:54,666
the active MQ broker that's

163
00:10:54,698 --> 00:10:58,702
melodic. But we are of course still working on

164
00:10:58,756 --> 00:11:02,678
that. And new version is developed

165
00:11:02,794 --> 00:11:06,114
within the morphemic project. And the

166
00:11:06,152 --> 00:11:09,394
first key novelty of that project

167
00:11:09,592 --> 00:11:13,890
will be the polymorph architecture. So application

168
00:11:14,040 --> 00:11:18,338
will not only be adapt through the selecting resources,

169
00:11:18,434 --> 00:11:22,294
through the selecting to which cloud providers we

170
00:11:22,332 --> 00:11:26,022
should deploy and CTO which type of virtual machines we should

171
00:11:26,076 --> 00:11:29,830
choose, but we can also adapt the architecture.

172
00:11:29,910 --> 00:11:33,434
So we would

173
00:11:33,472 --> 00:11:36,746
be able to change the architecture of

174
00:11:36,768 --> 00:11:40,494
the application. We could decide that instead of using

175
00:11:40,532 --> 00:11:44,954
the virtual machines or containers, we can use the serverless components

176
00:11:45,082 --> 00:11:49,962
and we can use also accelerated hardware

177
00:11:50,026 --> 00:11:53,166
like FPGA or GPU.

178
00:11:53,278 --> 00:11:57,390
The second novelty will be the proactive adaptation.

179
00:11:57,550 --> 00:12:01,438
Actually melodic is adapting to the current workload,

180
00:12:01,534 --> 00:12:05,006
to the current values of the metrics. But we

181
00:12:05,048 --> 00:12:08,630
want to make a step farther into the future.

182
00:12:08,780 --> 00:12:14,434
So we want to adapt to the expected

183
00:12:14,562 --> 00:12:18,838
workload. We want to try to forecast execution

184
00:12:18,934 --> 00:12:23,702
context and to be able to make a reconfiguration

185
00:12:23,846 --> 00:12:27,942
anticipating for example the increase of the workflow,

186
00:12:28,006 --> 00:12:29,980
increase number of the customers.

187
00:12:30,830 --> 00:12:34,418
Actually if the number of the customers is resync,

188
00:12:34,454 --> 00:12:37,534
we are starting reconfiguration and it

189
00:12:37,572 --> 00:12:40,974
takes some times. So there is

190
00:12:41,012 --> 00:12:44,450
a short period when the application is not ready

191
00:12:44,520 --> 00:12:47,874
for this increased number of the customers.

192
00:12:48,072 --> 00:12:52,034
But in morphemic we want to predicted that and to

193
00:12:52,072 --> 00:12:54,722
add that feature to the melodic platform.

194
00:12:54,856 --> 00:12:59,046
So we will be able to predict the future

195
00:12:59,148 --> 00:13:03,350
workloads and anticipated this deployment and

196
00:13:03,420 --> 00:13:05,560
prepare application for that.

197
00:13:06,570 --> 00:13:11,178
So the proactive adaptation will work starting

198
00:13:11,264 --> 00:13:14,586
from the initial deployment. Then the metrics will be

199
00:13:14,608 --> 00:13:18,086
collected as currently collected

200
00:13:18,118 --> 00:13:20,880
in the melodic. But in the third point,

201
00:13:21,650 --> 00:13:25,418
we will forecast the future values of the metrics

202
00:13:25,514 --> 00:13:28,942
and the optimization of the resources will

203
00:13:28,996 --> 00:13:32,454
be based on the forecasted values of the metrics,

204
00:13:32,522 --> 00:13:36,578
and the deployment of the optimal deployment plan

205
00:13:36,744 --> 00:13:40,702
will be determined based on that forecasted values.

206
00:13:40,766 --> 00:13:44,098
And then the application will be

207
00:13:44,184 --> 00:13:47,910
reconfigured anticipating

208
00:13:48,250 --> 00:13:51,382
that workflow. Yeah.

209
00:13:51,436 --> 00:13:54,774
So if you find that interesting, if you

210
00:13:54,812 --> 00:13:58,586
find melodic and melodic platform

211
00:13:58,688 --> 00:14:02,522
interesting, please stay in touch with us. Follow us

212
00:14:02,576 --> 00:14:05,894
on LinkedIn, Twitter and Facebook,

213
00:14:06,022 --> 00:14:10,380
or visit the melodic cloud website.

214
00:14:11,010 --> 00:14:16,046
And now I want to briefly tell about the

215
00:14:16,068 --> 00:14:20,282
use based so who is using melodic?

216
00:14:20,346 --> 00:14:23,242
What are the benefits of using melodic?

217
00:14:23,386 --> 00:14:27,426
And after these use cases, Allah will present

218
00:14:27,528 --> 00:14:31,182
the live demo, how to use melodic,

219
00:14:31,246 --> 00:14:35,034
how it looks like. And I really encourage

220
00:14:35,102 --> 00:14:39,350
you to give a so

221
00:14:39,420 --> 00:14:43,346
first user of the melodic is AI investments.

222
00:14:43,458 --> 00:14:46,840
It is a polish company, fintech company,

223
00:14:47,390 --> 00:14:50,982
which is working on advanced methods for the portfolio

224
00:14:51,046 --> 00:14:55,510
optimization using AI models.

225
00:14:55,670 --> 00:15:00,290
AI investments is working on the time series forecasting

226
00:15:00,390 --> 00:15:03,470
and also portfolio optimizations.

227
00:15:04,370 --> 00:15:08,686
AI investment platform invest in over 200

228
00:15:08,788 --> 00:15:12,666
markets, different markets, and for each

229
00:15:12,708 --> 00:15:17,342
market, separate forecasting model is trained

230
00:15:17,406 --> 00:15:20,206
and it needs to be retrained periodically.

231
00:15:20,318 --> 00:15:23,934
So the typical business goal for the AI

232
00:15:23,982 --> 00:15:27,654
investments is to train predefined number of the

233
00:15:27,692 --> 00:15:31,606
models in the specific time. Of course using

234
00:15:31,708 --> 00:15:34,998
as minimal number of resources as possible,

235
00:15:35,164 --> 00:15:37,720
just to save the cost.

236
00:15:38,350 --> 00:15:42,266
The investment analyst in the AI starts to

237
00:15:42,288 --> 00:15:46,620
train the models using on premises resources because

238
00:15:48,990 --> 00:15:52,240
it's already present, so it can be used.

239
00:15:53,170 --> 00:15:56,480
But if melodic determines that

240
00:15:57,250 --> 00:16:00,510
on premises resources, it takes too long.

241
00:16:00,660 --> 00:16:04,482
So for example, premises resources, it can

242
00:16:04,536 --> 00:16:07,858
take 3 hours. Then additional cloud

243
00:16:07,944 --> 00:16:12,926
resources are deployed and the number of the workers

244
00:16:13,038 --> 00:16:15,990
is increased. After that,

245
00:16:16,060 --> 00:16:21,206
new metrics value are collected and

246
00:16:21,388 --> 00:16:24,854
melodic is calculating the

247
00:16:24,892 --> 00:16:28,982
time to finish. If it's still too long, then additional

248
00:16:29,126 --> 00:16:32,220
resources are added and

249
00:16:33,390 --> 00:16:37,178
if the number of the resources is enough

250
00:16:37,264 --> 00:16:40,874
to process in the given time, the processing

251
00:16:40,922 --> 00:16:44,762
is finished and all of the cloud resources

252
00:16:44,826 --> 00:16:47,998
are removed just to save the cost.

253
00:16:48,084 --> 00:16:52,046
So that's a very typical process for

254
00:16:52,068 --> 00:16:55,666
the using of melodic. I think it's quite simple,

255
00:16:55,848 --> 00:16:59,860
but the results of that optimization are very

256
00:17:01,350 --> 00:17:04,450
significant. So the benefits

257
00:17:04,600 --> 00:17:08,454
are from the AI investments point of

258
00:17:08,492 --> 00:17:12,498
view, it is the very effective way of the optimization

259
00:17:12,594 --> 00:17:14,070
of the resources.

260
00:17:15,610 --> 00:17:19,094
Melodic is very well fit for the scaling machine

261
00:17:19,142 --> 00:17:23,306
learning training. Also we can control

262
00:17:23,408 --> 00:17:27,146
the budget because we could optimize the time

263
00:17:27,328 --> 00:17:31,150
having the budget constraints so not

264
00:17:31,220 --> 00:17:35,390
exceed the usage of the cloud resources.

265
00:17:35,730 --> 00:17:39,630
And also it increased

266
00:17:39,970 --> 00:17:43,314
reliability and higher availability of the application.

267
00:17:43,432 --> 00:17:46,734
Because in case of the failure of the one components,

268
00:17:46,862 --> 00:17:50,546
the melodic deploys additional one.

269
00:17:50,728 --> 00:17:54,782
So for the AI investments, the savings

270
00:17:54,846 --> 00:17:56,870
are quite significant.

271
00:17:57,930 --> 00:18:02,280
So we are able to save

272
00:18:02,810 --> 00:18:06,694
175,000 of

273
00:18:06,732 --> 00:18:10,198
us dollars. In the three years perspective,

274
00:18:10,294 --> 00:18:14,522
it is the difference between the optimal and

275
00:18:14,576 --> 00:18:18,202
the non optimal solutions. Probably the real

276
00:18:18,336 --> 00:18:23,070
savings are lower but are still very significant.

277
00:18:23,890 --> 00:18:27,694
We have published these results so they are

278
00:18:27,732 --> 00:18:31,486
available with all of the condition and

279
00:18:31,588 --> 00:18:35,380
how the measurements has been done.

280
00:18:35,830 --> 00:18:39,822
You can find that on the melodic webpage

281
00:18:39,886 --> 00:18:43,490
with the more detailed use case description.

282
00:18:44,550 --> 00:18:47,894
Second application this is the

283
00:18:47,932 --> 00:18:51,906
application big data application deployed

284
00:18:51,938 --> 00:18:56,338
on the spark and it is based to process genome

285
00:18:56,434 --> 00:19:00,234
data to find the mutation in

286
00:19:00,272 --> 00:19:04,182
the genome in the given genome comparing to the reference

287
00:19:04,246 --> 00:19:07,402
one. This application is used by the one

288
00:19:07,456 --> 00:19:11,950
of the polish universities to perform research

289
00:19:12,100 --> 00:19:15,966
related to the genome, especially to

290
00:19:15,988 --> 00:19:20,906
the mutation in the genome. And it is a very valuable

291
00:19:21,018 --> 00:19:24,590
knowledge to identify some genome

292
00:19:24,670 --> 00:19:28,820
based disease and diseases and other

293
00:19:29,430 --> 00:19:32,962
issues. And comparing this

294
00:19:33,016 --> 00:19:36,802
mutation and the similarity

295
00:19:36,866 --> 00:19:40,434
between this mutation give the researchers

296
00:19:40,482 --> 00:19:44,086
from the university very valuable knowledge. And they

297
00:19:44,108 --> 00:19:48,262
are also using melodic to optimize the processing

298
00:19:48,326 --> 00:19:51,962
time. The use case is

299
00:19:52,016 --> 00:19:55,414
very similar as for the AI investments.

300
00:19:55,542 --> 00:19:59,434
So the researcher on the university is starting

301
00:19:59,552 --> 00:20:03,390
processing the given workload. So usually it is the given

302
00:20:03,460 --> 00:20:07,600
genome data and want to compare them

303
00:20:09,010 --> 00:20:13,554
with the reference data. After starting the process,

304
00:20:13,752 --> 00:20:17,362
melodic is trying to determine how long it

305
00:20:17,416 --> 00:20:21,902
takes. If it takes too long, then additional resources

306
00:20:21,966 --> 00:20:25,666
are added and again the metrics

307
00:20:25,698 --> 00:20:29,062
are collected and melodic determines how long

308
00:20:29,116 --> 00:20:31,798
it takes. It's still too long.

309
00:20:31,884 --> 00:20:35,206
So the researcher wants to finish this

310
00:20:35,388 --> 00:20:38,842
task in the 1 hour. But even

311
00:20:38,896 --> 00:20:42,458
with the additional resources, it's still too long.

312
00:20:42,624 --> 00:20:46,300
Somalodic is automatically added new

313
00:20:47,150 --> 00:20:50,830
resources and the new time

314
00:20:50,900 --> 00:20:53,854
to finish is below the 1 hour.

315
00:20:53,972 --> 00:20:57,774
Also the costs are optimized to

316
00:20:57,812 --> 00:21:02,442
have a balance between the processing time and

317
00:21:02,516 --> 00:21:05,998
cost. And of course after the finishing deployment,

318
00:21:06,094 --> 00:21:09,554
melodic is removing all

319
00:21:09,592 --> 00:21:12,370
of the cloud resources.

320
00:21:13,430 --> 00:21:17,926
That's the most typical use case application.

321
00:21:18,108 --> 00:21:21,526
Of course we have more users of the melodic. All of

322
00:21:21,548 --> 00:21:25,586
these stories are described on the melodic

323
00:21:25,698 --> 00:21:29,020
website. So I really encourage you CTO,

324
00:21:29,550 --> 00:21:33,402
take a look and go

325
00:21:33,456 --> 00:21:37,482
deeply into that. And now allah will

326
00:21:37,616 --> 00:21:41,070
show the live demo how the melodic works.

327
00:21:41,220 --> 00:21:44,782
We will go through the whole workload. So we will

328
00:21:44,836 --> 00:21:47,520
start with the camel model of the application.

329
00:21:48,930 --> 00:21:53,002
Then maybe we will not deploy the melodic platform but

330
00:21:53,156 --> 00:21:56,180
briefly show the melodic platform.

331
00:21:57,430 --> 00:22:00,786
Then allah will show how to submit the

332
00:22:00,808 --> 00:22:04,382
camel model to the melodic, how to start the deployment

333
00:22:04,446 --> 00:22:08,114
application. Then everything is done fully,

334
00:22:08,162 --> 00:22:11,782
automatically and at the end you can

335
00:22:11,836 --> 00:22:15,222
connect CTO your application and

336
00:22:15,356 --> 00:22:19,338
enjoy. So now it's time for the

337
00:22:19,424 --> 00:22:22,954
live presentation. Now I would like to

338
00:22:22,992 --> 00:22:27,340
present you how to automatically deploy own application

339
00:22:27,710 --> 00:22:31,574
by melodic platform. I will perform deployment

340
00:22:31,622 --> 00:22:35,310
of spark based application. We will monitor application

341
00:22:35,460 --> 00:22:39,118
metrics and observe reconfiguration process

342
00:22:39,284 --> 00:22:43,330
which is done by melodic for reasons of optimization.

343
00:22:44,150 --> 00:22:47,982
My melodic platform is installed on virtual machine

344
00:22:48,046 --> 00:22:51,234
on AWS and it is up and running.

345
00:22:51,352 --> 00:22:56,214
I'm locked in. Melodic users are

346
00:22:56,252 --> 00:22:59,714
managed by LDAP. We have three possible roles

347
00:22:59,762 --> 00:23:03,990
of users common user he can perform application

348
00:23:04,140 --> 00:23:08,178
deployments admin user he manages

349
00:23:08,274 --> 00:23:11,770
of users accounts and also has all

350
00:23:11,840 --> 00:23:15,162
privileges from common user and

351
00:23:15,296 --> 00:23:18,954
technical user. He is used only internally by

352
00:23:18,992 --> 00:23:22,780
melodic components and he is not important

353
00:23:23,230 --> 00:23:26,510
from client's point of view. The first

354
00:23:26,580 --> 00:23:30,414
step in melodic usage is the defining of

355
00:23:30,452 --> 00:23:34,046
cloud settings. In provider settings menu

356
00:23:34,078 --> 00:23:37,694
part, we can check and update providers

357
00:23:37,742 --> 00:23:41,186
credentials and options. As we can see in

358
00:23:41,288 --> 00:23:44,754
cloud definition for providers view, filling these

359
00:23:44,792 --> 00:23:49,042
values is required in order to perform successful

360
00:23:49,106 --> 00:23:52,278
deployment because they are based in contact

361
00:23:52,364 --> 00:23:55,602
with providers. For example, by creating

362
00:23:55,666 --> 00:23:58,822
virtual instances on my environment,

363
00:23:58,966 --> 00:24:02,554
I have already defined these values for

364
00:24:02,672 --> 00:24:05,722
Amazon web service and for

365
00:24:05,776 --> 00:24:09,366
OpenStack providers. In these definitions

366
00:24:09,478 --> 00:24:13,754
we provided cloud credentials and properties,

367
00:24:13,882 --> 00:24:18,030
for example settings for Amazon Security group

368
00:24:18,180 --> 00:24:22,014
or set of private images which we would like to

369
00:24:22,052 --> 00:24:25,966
use in our deployments. When our platform

370
00:24:26,068 --> 00:24:29,422
is properly configured, we can go to deployment

371
00:24:29,486 --> 00:24:32,834
bookmark. Today I would like to

372
00:24:32,872 --> 00:24:36,434
deploy genome application which was described

373
00:24:36,482 --> 00:24:40,726
by Pavel a moment ago. Before deployment we

374
00:24:40,748 --> 00:24:44,918
need to model our application with its

375
00:24:45,004 --> 00:24:48,698
requirements in camel model which is human,

376
00:24:48,784 --> 00:24:51,980
understandable and editable form.

377
00:24:52,670 --> 00:24:57,094
After that such model is transformed to XMI

378
00:24:57,142 --> 00:25:01,930
format form understandable formulaic

379
00:25:02,370 --> 00:25:05,662
we upload this file here by drag and

380
00:25:05,716 --> 00:25:09,610
drop. Now our model is being validated

381
00:25:09,770 --> 00:25:13,250
and after that it will be saved in database.

382
00:25:13,830 --> 00:25:17,054
In a minute I will be asked for field values

383
00:25:17,102 --> 00:25:20,686
of AWS developers credentials.

384
00:25:20,878 --> 00:25:24,450
Providing these credentials is required in order

385
00:25:24,520 --> 00:25:28,930
to save results of our genome application in

386
00:25:29,000 --> 00:25:31,350
AWS S freebucket.

387
00:25:31,930 --> 00:25:35,458
But in view of security reasons, we shouldn't

388
00:25:35,554 --> 00:25:38,726
put them directly in camel model file.

389
00:25:38,918 --> 00:25:42,858
So we use placeholders in camel file and

390
00:25:42,944 --> 00:25:46,700
after that we need to provide these values here.

391
00:25:47,950 --> 00:25:51,310
In this case, it is not the first

392
00:25:51,380 --> 00:25:55,530
upload of such model on this virtual machine.

393
00:25:55,690 --> 00:25:59,162
So these variables already exist in predicted

394
00:25:59,226 --> 00:26:03,140
secure store. I can verify them

395
00:26:03,590 --> 00:26:07,410
update if they were changed and after that

396
00:26:07,560 --> 00:26:11,380
choose save button in the last step

397
00:26:11,910 --> 00:26:15,006
I need to choose which application I want to

398
00:26:15,048 --> 00:26:18,406
deploy and which cloud providers I want

399
00:26:18,428 --> 00:26:22,710
to use. Here is also possible to run application

400
00:26:22,860 --> 00:26:26,114
in simulation mode. Simulation mode

401
00:26:26,162 --> 00:26:29,562
is the case when we don't want to deploy real

402
00:26:29,616 --> 00:26:34,042
virtual machines on provided platform but

403
00:26:34,096 --> 00:26:38,074
only check which solution will be chosen by

404
00:26:38,112 --> 00:26:41,854
melodic. We manually set values of

405
00:26:41,892 --> 00:26:47,070
metrics in simulation part and

406
00:26:47,140 --> 00:26:50,906
observe the result but today our aim

407
00:26:50,938 --> 00:26:55,618
is to perform real deployment of

408
00:26:55,704 --> 00:26:59,426
genome application so

409
00:26:59,528 --> 00:27:03,234
I leave this option turned off. We would

410
00:27:03,272 --> 00:27:07,270
like to deploy genome only on AWS

411
00:27:08,010 --> 00:27:11,446
so we chose this cloud definition. Thanks to

412
00:27:11,468 --> 00:27:15,190
that melodic has credentials for this provider.

413
00:27:15,850 --> 00:27:20,346
After that we can go to the last step here where

414
00:27:20,528 --> 00:27:23,100
starting deployment is available.

415
00:27:24,190 --> 00:27:28,250
After starting the process, in a minute we are moved to the

416
00:27:28,320 --> 00:27:31,966
deployment process view. Here we

417
00:27:31,988 --> 00:27:35,246
can observe the progress of that. In the

418
00:27:35,268 --> 00:27:39,600
meantime, I would like to briefly describe application

419
00:27:41,250 --> 00:27:45,102
which is being deployed

420
00:27:45,166 --> 00:27:48,690
by melodic. Now Genome is a big data

421
00:27:48,760 --> 00:27:52,798
application which performs some calculations

422
00:27:52,894 --> 00:27:57,350
and safe results in AWS as freebacket

423
00:27:57,690 --> 00:28:01,990
so we need to provide developers credentials to AWS.

424
00:28:02,570 --> 00:28:06,018
Genome's performance is managed by Spark.

425
00:28:06,194 --> 00:28:10,154
In genome application we use Spark as platform

426
00:28:10,352 --> 00:28:14,390
for big data operations which are performed

427
00:28:14,470 --> 00:28:18,442
parallel on many machines and managed by

428
00:28:18,496 --> 00:28:21,390
one machine named Sparkmaster.

429
00:28:22,290 --> 00:28:25,566
Sparkmaster is available by default on

430
00:28:25,588 --> 00:28:29,358
melodic platform. Melodic creates proper

431
00:28:29,444 --> 00:28:33,250
number of spark workers as virtual machines

432
00:28:33,750 --> 00:28:37,380
considered our requirements from camel model.

433
00:28:38,310 --> 00:28:42,482
Thanks to measurements of application metrics, melodic makes

434
00:28:42,536 --> 00:28:46,194
a decision about creating additional instances

435
00:28:46,242 --> 00:28:50,242
with workers or about deleting unnecessary

436
00:28:50,306 --> 00:28:54,162
ones. Spark divides all calculations

437
00:28:54,306 --> 00:28:58,026
named tasks between available workers in

438
00:28:58,048 --> 00:29:01,370
order to optimize application performance and

439
00:29:01,440 --> 00:29:04,714
cost. Please let me come back

440
00:29:04,752 --> 00:29:08,554
to our process. Phishing offers is

441
00:29:08,592 --> 00:29:12,430
the first step of deployment process. We have

442
00:29:12,500 --> 00:29:16,014
information about current total number of

443
00:29:16,052 --> 00:29:19,850
offers from previously selected providers.

444
00:29:20,010 --> 00:29:22,830
So in this case from AWS.

445
00:29:23,810 --> 00:29:27,758
From these offers melodic will choose the best solution

446
00:29:27,854 --> 00:29:31,534
for worker component. After choosing

447
00:29:31,582 --> 00:29:35,706
this box or offer option from mani

448
00:29:35,758 --> 00:29:39,394
which is available here, we are directed

449
00:29:39,442 --> 00:29:43,190
to view of all currently available offers.

450
00:29:44,090 --> 00:29:47,822
There are clouds with my credentials

451
00:29:47,906 --> 00:29:51,706
and also with my properties for security group

452
00:29:51,808 --> 00:29:55,930
and for filters for our private images.

453
00:29:57,230 --> 00:30:01,070
Also we have here hardware

454
00:30:02,450 --> 00:30:05,866
with information about cores,

455
00:30:05,978 --> 00:30:10,830
ram and disk and available locations

456
00:30:11,170 --> 00:30:15,074
where our virtual machines could

457
00:30:15,112 --> 00:30:19,090
be located and the last element here images.

458
00:30:20,630 --> 00:30:24,462
There are only private images

459
00:30:24,526 --> 00:30:28,082
visible here but of course all public images

460
00:30:28,146 --> 00:30:31,654
are available for us. Now I come

461
00:30:31,692 --> 00:30:35,606
back to our process view and we can see that the

462
00:30:35,628 --> 00:30:39,500
next step of process is generating constraint problem.

463
00:30:39,950 --> 00:30:43,898
Constraint problem is generated based

464
00:30:43,984 --> 00:30:47,354
off our requirements defined in

465
00:30:47,392 --> 00:30:50,894
KaML model. In a simple process view

466
00:30:51,012 --> 00:30:55,440
there are visualized all variables from constraint problem

467
00:30:55,970 --> 00:30:59,386
with the domain values for genome

468
00:30:59,498 --> 00:31:03,694
worker, cardinality worker course and provider

469
00:31:03,742 --> 00:31:07,122
for Spark worker. Detailed data

470
00:31:07,256 --> 00:31:11,250
are shown after click of this box and

471
00:31:11,320 --> 00:31:15,606
here are presented list of variables with

472
00:31:15,708 --> 00:31:21,240
additional information about component type,

473
00:31:21,850 --> 00:31:25,026
domain and type of this domain.

474
00:31:25,218 --> 00:31:29,690
Utility formula. It is used for measure

475
00:31:30,190 --> 00:31:34,218
utility of each possible solutions and choose

476
00:31:34,304 --> 00:31:37,898
the best one list of constants with

477
00:31:37,984 --> 00:31:42,394
types and values. They are created from user requirements

478
00:31:42,522 --> 00:31:45,310
and are used in melodic calculations.

479
00:31:46,290 --> 00:31:49,742
Here we can see for example minimum and

480
00:31:49,796 --> 00:31:53,934
maximum values for cardinality of spark worker

481
00:31:53,982 --> 00:31:57,662
instances or the same type of restriction

482
00:31:57,806 --> 00:32:01,490
for number of spark worker cores.

483
00:32:02,630 --> 00:32:06,226
So we can see that in our deployments

484
00:32:06,338 --> 00:32:10,130
we would like CTO have from one to maximum

485
00:32:10,210 --> 00:32:14,390
ten workers and the last element here

486
00:32:14,460 --> 00:32:17,902
list of metrics with data types and values

487
00:32:17,986 --> 00:32:21,702
initial values. They describe current performance

488
00:32:21,766 --> 00:32:25,786
of this application. Thanks to them, melodic can make

489
00:32:25,808 --> 00:32:29,430
a decision about triggering the reconfiguration

490
00:32:29,510 --> 00:32:33,310
process which means creating new

491
00:32:33,380 --> 00:32:36,654
additional instances or deleting not

492
00:32:36,692 --> 00:32:39,898
fully used ones. Thanks to metrics,

493
00:32:39,994 --> 00:32:43,666
melodic can do the most important task which

494
00:32:43,688 --> 00:32:46,946
is cost optimization. We back to process

495
00:32:47,048 --> 00:32:51,230
view when constraint problem is generated,

496
00:32:51,390 --> 00:32:55,494
it is time for rezoning. Melodic finds here the

497
00:32:55,532 --> 00:32:59,714
best the most profitable solution for the problem defined

498
00:32:59,762 --> 00:33:03,154
by us. When resulting is completed,

499
00:33:03,282 --> 00:33:07,670
we can observe information about calculate solution

500
00:33:08,110 --> 00:33:12,966
utility value and values for each variables.

501
00:33:13,158 --> 00:33:16,682
In that case one as

502
00:33:16,736 --> 00:33:21,194
worker cardinality for worker cores and provider

503
00:33:21,242 --> 00:33:24,974
for spark worker from zero index. So it

504
00:33:25,012 --> 00:33:28,798
is AWS. The next

505
00:33:28,884 --> 00:33:31,930
step in process deployment is deploying.

506
00:33:32,090 --> 00:33:35,442
Here melodic performs operations based on

507
00:33:35,496 --> 00:33:39,822
calculated solution. This solution is deployed

508
00:33:39,966 --> 00:33:44,062
for each application component. Velodic creates

509
00:33:44,126 --> 00:33:48,470
proper instances, remains them or deletes.

510
00:33:49,130 --> 00:33:52,598
If you want to have more detailed view,

511
00:33:52,764 --> 00:33:56,978
it is possible to see the process view using kamunda

512
00:33:57,074 --> 00:34:01,382
by choosing advanced view button from upper

513
00:34:01,446 --> 00:34:03,580
left corner. From this view,

514
00:34:04,190 --> 00:34:09,482
Kamunda is tool for monitoring and

515
00:34:09,536 --> 00:34:13,374
for modeling processes in BPM and standard and

516
00:34:13,412 --> 00:34:17,134
for management of them. I log in by the same

517
00:34:17,172 --> 00:34:21,550
credentials as for my melodic platform and

518
00:34:21,620 --> 00:34:25,006
in order to see detailed view in Kamunda,

519
00:34:25,118 --> 00:34:29,502
I need to choose running process instances

520
00:34:29,646 --> 00:34:33,122
and after that process to monitoring from

521
00:34:33,176 --> 00:34:36,902
the list. And now we can see

522
00:34:36,956 --> 00:34:41,106
view of chosen process with all day variables

523
00:34:41,218 --> 00:34:46,214
and also detailed view of

524
00:34:46,252 --> 00:34:49,930
the whole process with each steps.

525
00:34:50,270 --> 00:34:53,574
This view is for more technical users.

526
00:34:53,702 --> 00:34:58,214
It could be useful for example during diagnostic

527
00:34:58,262 --> 00:35:01,710
of some problems. We can see

528
00:35:01,780 --> 00:35:05,438
that now we are even

529
00:35:05,524 --> 00:35:08,480
here. So it is the end of our process.

530
00:35:11,890 --> 00:35:15,518
In order to verify this fact I go to

531
00:35:15,684 --> 00:35:19,314
Merlot Qi again and yes we can see

532
00:35:19,352 --> 00:35:22,900
that our application successfully started.

533
00:35:24,790 --> 00:35:28,022
So the deployment process is

534
00:35:28,076 --> 00:35:32,950
finished and I can check the result in

535
00:35:33,100 --> 00:35:35,830
your application bookmark.

536
00:35:36,890 --> 00:35:40,490
In this view there are displayed list

537
00:35:40,560 --> 00:35:43,910
of created virtual machines and functions.

538
00:35:44,070 --> 00:35:48,102
Genome application requires only virtual machines.

539
00:35:48,246 --> 00:35:51,690
We can see that melodic creates one virtual

540
00:35:51,770 --> 00:35:55,022
machine. As far this machine is

541
00:35:55,076 --> 00:35:59,230
created in AWS EC two provided in Dublin.

542
00:35:59,970 --> 00:36:03,806
What is more we have here button for web SSH

543
00:36:03,918 --> 00:36:08,340
connection which is really useful in testing process.

544
00:36:09,110 --> 00:36:13,406
When I successfully deployed spark application by melodic

545
00:36:13,518 --> 00:36:16,098
I can go to Grafana.

546
00:36:16,274 --> 00:36:19,462
Grafana is tool for

547
00:36:19,516 --> 00:36:23,510
monitoring displaying statistics and metrics.

548
00:36:25,210 --> 00:36:29,146
We can use them for monitoring performance of

549
00:36:29,168 --> 00:36:33,180
applications deployed by melodic. Each application

550
00:36:33,630 --> 00:36:36,794
has own metrics and own parameters to

551
00:36:36,832 --> 00:36:40,746
control so we need to create predicted Grafana

552
00:36:40,778 --> 00:36:44,714
dashboard for each of them. Also genome

553
00:36:44,762 --> 00:36:48,122
application has own grafana settings

554
00:36:48,266 --> 00:36:51,120
and we can see them here.

555
00:36:51,570 --> 00:36:55,540
For now metrics from our application

556
00:36:56,070 --> 00:37:00,114
are not available yet. We can see only that

557
00:37:00,152 --> 00:37:04,578
we have now one instance so one

558
00:37:04,664 --> 00:37:08,360
worker. In the meantime we can control

559
00:37:09,290 --> 00:37:13,830
our application in Sparkmaster

560
00:37:14,490 --> 00:37:15,510
UI.

561
00:37:17,630 --> 00:37:21,100
Sparkmaster is built into melodic platform

562
00:37:22,590 --> 00:37:26,762
so we go to the same IP address and 81

563
00:37:26,816 --> 00:37:30,334
81 port in order to

564
00:37:30,372 --> 00:37:35,038
check the Sparkmaster UI and

565
00:37:35,124 --> 00:37:39,118
here we can observe list

566
00:37:39,204 --> 00:37:42,362
of available workers after refreshing

567
00:37:42,426 --> 00:37:46,114
of this view, of course we can see

568
00:37:46,152 --> 00:37:50,434
that now we have one worker and

569
00:37:50,552 --> 00:37:53,906
one running application and also

570
00:37:54,008 --> 00:37:58,518
one driver. So now all

571
00:37:58,684 --> 00:38:03,506
tasks are sent to this one worker

572
00:38:03,698 --> 00:38:07,720
by our spark master and

573
00:38:08,090 --> 00:38:12,790
it is situation after initial deployment decision

574
00:38:12,870 --> 00:38:16,618
about creating the new ones or

575
00:38:16,704 --> 00:38:21,258
deleting. Some of workers

576
00:38:21,434 --> 00:38:26,026
are made by melodic based on measured metrics.

577
00:38:26,218 --> 00:38:29,262
In such situation new process is

578
00:38:29,316 --> 00:38:32,822
triggered and it is named reconfiguration

579
00:38:32,906 --> 00:38:37,154
process. I think that now we can

580
00:38:37,272 --> 00:38:40,930
go again to our grafana dashboard

581
00:38:41,430 --> 00:38:45,086
and we can see that metrics are

582
00:38:45,128 --> 00:38:48,630
being correctly calculated and passed

583
00:38:49,770 --> 00:38:53,346
to the melodic because they are visible

584
00:38:53,458 --> 00:38:56,920
also in our Grafana view.

585
00:38:57,710 --> 00:39:01,926
Color of limitation of traffic lights

586
00:39:02,038 --> 00:39:05,580
inform us if application will finish on time.

587
00:39:06,190 --> 00:39:10,862
Now we can see the first estimation so

588
00:39:10,996 --> 00:39:14,960
it can be not correct. I think

589
00:39:15,650 --> 00:39:19,262
because we

590
00:39:19,316 --> 00:39:23,042
have no enough data

591
00:39:23,176 --> 00:39:26,642
for a good estimation so we need

592
00:39:26,696 --> 00:39:30,210
to wait a minute and even now we can see

593
00:39:30,280 --> 00:39:32,900
that our light is red.

594
00:39:35,210 --> 00:39:38,854
Also we

595
00:39:38,892 --> 00:39:44,600
can see that our time left is

596
00:39:45,290 --> 00:39:49,274
not enough to finish our calculate on time

597
00:39:49,472 --> 00:39:52,550
because the initial

598
00:39:52,630 --> 00:39:56,810
time indicated time because

599
00:39:56,880 --> 00:40:00,086
the expected time is indicated in

600
00:40:00,128 --> 00:40:03,502
camel model and in this case it is equal to

601
00:40:03,556 --> 00:40:06,970
60 minutes. We can observe

602
00:40:07,050 --> 00:40:10,734
how many minutes left from this time period. Under this

603
00:40:10,772 --> 00:40:14,626
time left value and based on current

604
00:40:14,728 --> 00:40:18,718
performance it is calculate the estimated

605
00:40:18,814 --> 00:40:21,538
time left on the left.

606
00:40:21,624 --> 00:40:25,414
On the first chart we can monitor number

607
00:40:25,452 --> 00:40:29,254
of instances. So now we have one

608
00:40:29,292 --> 00:40:32,886
node so one worker and

609
00:40:32,988 --> 00:40:36,422
in the bottom ones it is presented number

610
00:40:36,476 --> 00:40:39,722
of remaining simulation. This value is

611
00:40:39,776 --> 00:40:43,670
decreasing with performing

612
00:40:43,750 --> 00:40:45,770
next task by spark.

613
00:40:47,310 --> 00:40:51,290
On the right on chart named number

614
00:40:51,360 --> 00:40:54,682
of cores we can see value of minimum

615
00:40:54,746 --> 00:40:58,400
course needed to finish calculations on time

616
00:40:59,490 --> 00:41:03,538
and current number of course under total

617
00:41:03,624 --> 00:41:07,678
course value the green one is the value of required

618
00:41:07,774 --> 00:41:12,290
number, of course, and the yellow one means current number

619
00:41:12,440 --> 00:41:15,974
of them. Now melodic claims that

620
00:41:16,012 --> 00:41:20,182
we need at least four cores and even

621
00:41:20,236 --> 00:41:22,790
now six cores, seven cores,

622
00:41:23,770 --> 00:41:27,800
seven cores and we have only one.

623
00:41:28,190 --> 00:41:32,586
Also estimated time is higher

624
00:41:32,688 --> 00:41:36,170
than time left. We can see red

625
00:41:36,240 --> 00:41:40,146
light. So tree are signals

626
00:41:40,278 --> 00:41:43,950
that our application needs more resources.

627
00:41:44,850 --> 00:41:49,002
In such situation, melodic makes a decision

628
00:41:49,146 --> 00:41:52,640
about triggering reconfiguration process.

629
00:41:54,470 --> 00:41:58,798
So we can suppose that in the background reconfiguration

630
00:41:58,894 --> 00:42:03,890
process should being done in

631
00:42:03,960 --> 00:42:05,940
order to verify it.

632
00:42:07,210 --> 00:42:10,706
I back CTo our melodic UI

633
00:42:10,818 --> 00:42:14,566
and I go to process view and here

634
00:42:14,668 --> 00:42:18,362
we can see current process and

635
00:42:18,416 --> 00:42:23,158
it is our reconfiguration process. In reconfiguration

636
00:42:23,254 --> 00:42:27,546
process, melodic doesn't fetch new offers and

637
00:42:27,648 --> 00:42:31,562
uses the same constraint problem as for initial

638
00:42:31,626 --> 00:42:35,422
deployment. For tree reasons, the first

639
00:42:35,476 --> 00:42:38,526
step is rezoning. As result,

640
00:42:38,708 --> 00:42:42,802
we can see new calculated solution which

641
00:42:42,856 --> 00:42:46,510
will be deployed. Now melody claims

642
00:42:46,590 --> 00:42:50,020
that two workers will be needed

643
00:42:50,790 --> 00:42:54,930
and this solution is now deployed.

644
00:42:55,690 --> 00:42:59,446
So in a minute we will see

645
00:42:59,548 --> 00:43:01,830
our new worker.

646
00:43:02,490 --> 00:43:06,226
Oh yes, even now our new worker

647
00:43:06,418 --> 00:43:10,230
should be visible because the reconfiguration

648
00:43:10,310 --> 00:43:14,294
process is finished. I can verify

649
00:43:14,422 --> 00:43:17,834
this fact also in your application part.

650
00:43:18,032 --> 00:43:21,530
And yes, now we have two virtual machines,

651
00:43:21,610 --> 00:43:25,406
two workers and this is the new one from

652
00:43:25,508 --> 00:43:27,680
our reconfiguration process.

653
00:43:29,250 --> 00:43:33,058
Also I can check this fact

654
00:43:33,144 --> 00:43:36,514
in our Sparkmaster UI. I need to

655
00:43:36,552 --> 00:43:40,542
refresh this view. And now two workers

656
00:43:40,606 --> 00:43:44,770
are available. We have two live workers.

657
00:43:46,730 --> 00:43:50,290
So now we can see that Sparkmaster

658
00:43:50,370 --> 00:43:53,622
divides tasks between these two

659
00:43:53,676 --> 00:43:58,442
workers in case of

660
00:43:58,496 --> 00:44:02,330
genome. In the first part of performing calculations,

661
00:44:02,750 --> 00:44:06,522
additional workers are created. As far as

662
00:44:06,576 --> 00:44:10,494
melodic measures that effectiveness of application is

663
00:44:10,532 --> 00:44:14,622
too low. In the final part of performance of

664
00:44:14,676 --> 00:44:18,398
spark jobs, melodic makes decision about

665
00:44:18,484 --> 00:44:22,014
deleting unnecessary instances when

666
00:44:22,052 --> 00:44:26,050
it is visible that application will

667
00:44:26,120 --> 00:44:29,554
finish on time. And now we are

668
00:44:29,592 --> 00:44:34,478
in our initial

669
00:44:34,574 --> 00:44:38,102
part of the whole process because as

670
00:44:38,156 --> 00:44:43,110
I mentioned, we have 60 minutes to

671
00:44:43,180 --> 00:44:46,722
perform the whole process. So we are at the beginning

672
00:44:46,786 --> 00:44:52,874
of them and now additional workers are

673
00:44:52,912 --> 00:44:57,622
being created because of effectiveness

674
00:44:57,686 --> 00:44:58,940
of our application.

675
00:45:01,650 --> 00:45:06,590
Now I go to Grafana view and

676
00:45:06,740 --> 00:45:10,762
we can see that now we have two workers,

677
00:45:10,826 --> 00:45:14,322
two nodes. Next tasks are

678
00:45:14,376 --> 00:45:18,178
done and we can see that now

679
00:45:18,344 --> 00:45:22,340
our estimated time is close to time left.

680
00:45:23,430 --> 00:45:27,446
And even now melody claims that it will

681
00:45:27,468 --> 00:45:31,560
be possible to finish the whole process on time.

682
00:45:34,010 --> 00:45:38,140
But now our estimated time is

683
00:45:38,830 --> 00:45:42,870
bigger again. So we can suppose

684
00:45:42,950 --> 00:45:47,962
that in a minute our time will

685
00:45:48,016 --> 00:45:51,520
be red again. And probably

686
00:45:52,770 --> 00:45:56,800
we will see the new reconfiguration process

687
00:45:58,930 --> 00:46:02,754
and the whole process is being performed to

688
00:46:02,792 --> 00:46:06,398
the moment where our estimated

689
00:46:06,494 --> 00:46:10,818
time will be enough for us,

690
00:46:10,984 --> 00:46:14,580
enough for our requirements and

691
00:46:15,210 --> 00:46:20,614
thanks to that, finishing the whole process in

692
00:46:20,652 --> 00:46:24,978
our expected time will be possible, right? So we successfully

693
00:46:25,074 --> 00:46:29,180
observed the configuration process of spark application.

694
00:46:29,630 --> 00:46:33,638
This is the end of spark application deployment

695
00:46:33,814 --> 00:46:37,466
done by melodic demonstration and we

696
00:46:37,488 --> 00:46:42,110
can see that the whole optimization process is

697
00:46:42,180 --> 00:46:45,198
done fully automatically. Okay,

698
00:46:45,364 --> 00:46:48,718
so thank you very much for your

699
00:46:48,804 --> 00:46:52,494
attention and this is all from my

700
00:46:52,532 --> 00:46:55,550
side. Thank you. Thank you Allah.

701
00:46:56,290 --> 00:47:00,050
I hope you enjoyed that presentation. If you have any

702
00:47:00,120 --> 00:47:04,340
question, please do not hesitate to ask these questions.

703
00:47:05,050 --> 00:47:09,442
And also as I said, I really encourage to download melodic

704
00:47:09,506 --> 00:47:12,326
and at least give a try.

705
00:47:12,428 --> 00:47:16,642
Especially that melodic is fully open source release

706
00:47:16,706 --> 00:47:20,234
under the Mozilla Public License 20.

707
00:47:20,352 --> 00:47:24,220
So you can use that for any type of

708
00:47:24,590 --> 00:47:28,614
workloads, commercial and non commercial

709
00:47:28,742 --> 00:47:32,798
one. And also please follow

710
00:47:32,884 --> 00:47:35,642
us on the LinkedIn, Twitter,

711
00:47:35,786 --> 00:47:39,354
Facebook and please visit melodic

712
00:47:39,402 --> 00:47:43,040
site www. Melodic Cloud.

713
00:47:43,410 --> 00:47:47,250
If you have any questions, please do not hesitate

714
00:47:47,590 --> 00:47:49,460
to contact us.

715
00:47:50,310 --> 00:47:54,494
Also, I really encourage to follow our morphemic

716
00:47:54,542 --> 00:47:57,970
project which is the successor of the melodic

717
00:47:58,050 --> 00:48:01,494
and aim for the further development of the

718
00:48:01,532 --> 00:48:05,410
melodic platform with really novel

719
00:48:05,490 --> 00:48:09,506
and unique concept like polymorphic adaptation

720
00:48:09,618 --> 00:48:13,382
and proactive adaptation. So stay

721
00:48:13,436 --> 00:48:16,758
tuned, take a look and I think

722
00:48:16,844 --> 00:48:20,830
that it could be very interesting see

723
00:48:20,900 --> 00:48:24,702
what are the results will be. And once

724
00:48:24,756 --> 00:48:27,902
again thank you for the invitation. We are very

725
00:48:27,956 --> 00:48:31,840
happy that able to present

726
00:48:32,290 --> 00:48:35,742
you this session and I hope that you would

727
00:48:35,796 --> 00:48:38,300
find that useful. Thank you.

