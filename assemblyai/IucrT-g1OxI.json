{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/46f39b7a-5b99-4113-8d22-0e4230a6fc93", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["app", "applications", "better", "bill", "boundaries", "cloud", "complicated", "conf fourty two", "google", "laptop", "logiccloud", "microservice", "modern development", "performancean", "repos", "robert grandl", "service weaver", "software engineer", "weaverfocus", "x"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "id": "8af36f95-e3c9-44b9-8970-0c3abfa57b04", "status": "completed", "error": null, "text": "Today, I'm going to talk about service weaver new programming framework for writing distributed applications in go based on our experience of writing distributed applications at Google, teams usually organize their applications into microservice, where a microservice is a piece of code that exports an RPC service. A team usually owns multiple microservices and based on our analysis, teams frequently add new microservices. Finally, they use an internal tool to manage their microservices. There are many reasons why people split their applications into microservices, for example, to achieve fault tolerance and to scale their applications. Another reason is to improve the development velocity or to make it easier to maintain. However, we did some analysis and we found out that teams often split into microservices without having valid concerns. For example, they claim that they want to use different programming languages for different microservices. However, we found out that the vast majority of the teams use only one language. Another argument to split is that the team wants to release microservice using different rollout schedules. However, our analysis shows that a significant fraction of the teams release all microservice altogether. And finally, developers claim that they want to release some microservices very often, like subdaily. However, we found out that only a tiny fraction of the microservice are released very often. So the takeaway here is that teams split their applications into microservices for some good reasons, but often also not valid reasons. However, splitting into an application into microservices is challenging. For example, the developers now have to deal with multiple versions of microservices, and they have to implement logic to ensure different running instances at different versions are backward compatible. One implication of versioning is API hardening. That means that once a developer splits into microservices and deploys them, it is incredibly difficult to change the APIs because of versioning concerns. Also, to deploy a microservice, it requires complicated configuration files and the developer has to add logic to connect microservices together and organize application code into low level interactions through an ideal and finally, end to end testing and local testing becomes incredibly difficult. Another popular paradigm to write distributed applications is to organize your application into a monolith that consists of a single binary, and usually it is deployed with a single config. With the monolithic architecture, it's easier to address many of the challenges introduced to using microservice, for example, drano versioning concerns. However, monoliths suffer from challenges that microservice are designed to handle, so service weaver bridges a gap between the two models. It provides a programming model of a monolith and enables the flexibility of using microservices. If we have to remember only one thing about service Weaver, then you should remember that service Weaver allows you to write your application as a modular binary while is deploying the application as a set of connected microservices. Finally, service Weaver enables writing high performance applications and enables portability. This means it allows you to deploy the same application binary into different cloud environments and can support applications written in multiple languages, although we don't support that for now. So at a glance, service Weaver allows you to develop applications using native language constructs and organize your code around native language interfaces. While writing your application business logic, you don't have to worry about versioning and finally, you can use some embedded fields to vivify the application. As I'm going to show slightly later, to deploy your service weaver application, you will have a single binary and a tiny config. Service Weaver will run your application as a set of microservices at the same code version and provides multiple deployment environments. For now, you can deploy your application on the local machine, in a cluster of machines or in Google Cloud. However, we can add new deployers for AWS and Azure and other cloud providers to roll out a new application version. Service Weaver will ensure your rollout is safe, and it does bluegrain deployments, a widely popular technique to deploy new application versions in a distributed environment. One nice thing about service Weaver is that it provides observability, like logging metrics and tracing that can be easily integrated with different monitoring tools. Also, it allows easy testing and debugging. Finally, service weaver runtime implements various high performance mechanisms that enable high performance applications. In the following slides, we'll go into more details into how service Weaver handled each of these topics. So, development a service Weaver application consists of a set of components that call each other, where a component is somehow similar to actors. For those familiar with the actor model under the hood, service Weaver uses a code generator to vivify the application, for example, to generate, you know, registration and so on. To write your service weaver application, you write a modeler binary and then you can deploy it on your local machine where components can run in the same process or in multiple processes, and then you can run it distributed on different machines pods, it can be replicated, traffic is load balanced between replicas and so on. To define a service weaver component, you simply define a go interface. Here we define a cache component with a put method, and of course you can have other methods as well. Next to implement the component, you write a ghost struct, except that you have to add weaver implements embedding. This allows the service Weaver framework to identify that this is a component. To instantiate a service weaver application in the main function, you can simply call Weaver init and to get a client to a component, you call Weaver get. And finally, once you got a handle on the component, you can interact with the component by simply doing method calls. To deploy a service weaver application, you release a single binary and a tiny config. You just have to specify the name of the application binary. Optionally, you can also choose whether to collocate certain components in the same process for performance or other reasons. Also, you can specify how long you want to roll out a new instance of the application. Once you write this tiny config, you can simply execute go run on your local machine to run the application in a single process. Or you can call Weaver multideeploy to run the application on the same machine, but in multiple processes. Now, if you want to deploy in a distributed environment, you can add a per deployment information in the config file. For example, to run on multiple machines via SSH, you just need to specify a file that contains the names of the machines, and then you can run Weaver SSH deploy to run the same application binary that you run locally, but now on multiple machines, if you want to run in the Google Cloud, you have to specify the regions where you want to run the application and some public listeners that enable you to get access to the application. Then you can simply run Weaver GKE deploy to run the application in the cloud. Under the hood, the deployer will automatically create containers, place the components into pods, replicate them, load balance the traffic among different replicas, and so on. Let's look a little bit in more detail about on how a serviceiver application is deployed. As mentioned before, you write the application as a monolith that consists of a set of components. Service Weaver bill place these components into processes. By default, it places each component in a different process. However, if you specify any colocation in the config, as we saw before, then service weaver will respect those constraints. Next, service Weaver will attach corresponding libraries to the application that are responsible to manage the interaction between the application and the runtime environment. Finally, service weaver runtime can have different implementation. As mentioned before, for now we have deployers for the local machine for a set of machines and Google Cloud. However, service weaver enables relatively easy to write new deployers, for example for AWS or Azure. Now let's talk about telemetry and testing. Service Weaver provides integrated login with service weaver, each component comes with an associated logger, and it's pretty straightforward to log in to manipulate logs. Also, it provides metrics like counters, gouges, and histograms. One interesting observation is that service viewer generates some metrics by default for your application. For example, metrics that capture the throughput and the latency between various components. For tracing, service viewer relies on open telemetry, and to enable tracing, you simply have to create an autel handler in your main function. Once tracing is enabled, service Weaver will trace for you all the HTTP requests and component metal calls. And finally, service Weaver allows you to with a single command weaver GK profile, for example, to capture the performance of your application as a whole by profiling each individual process and aggregating into a single profile. In terms of monitoring, service weaver provides dashboards for our application. One nice feature of service viewer is that it can provide a bird's eye view into your application. For example, as you can see on this slide, it can display the call graph and interactions between all the components, along with various metrics to reflect interaction between these components and also to provide more insight into the behavior of each component. Service Weaver also provides integration with various monitoring frameworks. For example, you can run your application on multiple machines with the SSH deployer, and then you can open the dashboard on your local machine and click on tracing, and you can see all the traces across all components across all the machines in your local chrome browser. And here is a list of all the monitoring frameworks service Weaver integrates so far for testing. Service Weaver provides a weaver test package that allows you to run unit tests that can run in a single and multi process mode. Writing unit test is as easy as writing a service weaver application. The only difference is that instead of using Weaver init to instantiate an application, you have to use weavertest init in your unit tests. For end to end testing, service Weaver provides status commands and you also can check the logs, metrics, traces, and the dashboards we provide. For example, if you want to make a change to your application and see if the application is still running, you can simply do go run. Now, if you want to test whether your changes make any assumptions about the distributed nature of the application, you can run Weaver multideeploy. And finally, if you want to make sure that the application still works in the presence of multiple application versions running, you can run Weaver GKE local let's talk about performance. Service Weaver provides a highly efficient runtime that enables high performance applications for example, it provides an efficient encoding decoding mechanism that has no versioning overheads. It uses an efficient transport protocol built on top of tcp that embeds custom load balancing. It provides collocation that enables flexibility on how components are complicated. For example, chatty components can be placed together in the same process, and they can use simple local method calls to interact with each other. And finally, service people provides routing that helps to balance the load across multiple component replicas and also increases the cache hit ratio in case you want to collocate caches with your components. For performance reasons, we benchmarked a popular application called online boutique that contains eleven microservices. We ran the application using the Google Cloud deployer and compared the performance using three different approaches. Nonweaver, which is the microservice version of the application, except that we rewrote all the microservice in go for a fair comparison. Weaver split which is the application written with service Weaver, except that all the components run in a single process. And finally we were merged, which is the applications written with service Weaver, except that all the components run in separate processes. Our results show that with service Weaver you write less code into your application up to 1.25 x. And this is because you don't have to write boilerplate code related to encoding decoding, you don't have to add service discovery, you don't have to define protos, you don't have to integrate to the cloud provider, and so on. Also with service Weaver you just write a tiny config, while if you deploy as microservice, there are many configurations in their very complicated YAML files. Because of a high performancean runtime, service Weaver can handle the same throughput as a nonweaver version of the application, but with less resources. Hence it can reduce the cost by up to four x. And finally, the application latency significantly reduces service Weaver. In our benchmarking it's up to 37 x better at 99 percentile before I conclude the talk, I want to address briefly some of the common questions we get with service Weaver. You write a single modular binary and you can postpone the decisions on how to split into microservices for later. A nice property of service viewer is that you don't have to worry about the underlying network transport or the underlying serialization mechanisms. Also, by decoupling of the application code from RPC bindings, service Weaver allows cross component calls within the same process to be optimized down to local method calls. However, service Weaver doesn't hide the network and the application developers should treat method calls as remote by default. Also, with service Weaver, you don't have to organize the application code and low level interactions through an IDL. And finally, you don't have to worry about code versioning issues and rollouts. Service Weaver take care of these things for you. So I presented service Weaver a framework for writing distributed applications. With service Weaver, it's easy to develop, deploy, and monitor performance applications. We are looking for community contributions. We want people to get involved with us, give us feedback, and contribute to the project. And so please don't hesitate to contact us. With this I conclude my talk. Thank you.", "words": [], "utterances": null, "confidence": 0.940368581052631, "audio_duration": 1090.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Service weaver is a new programming framework for writing distributed applications in go. Teams usually organize their applications into microservices. But splitting into an application into microservice is challenging. Service Weaver enables writing high performance applications and enables portability.\n- Service Weaver provides integrated login with service weaver. Each component comes with an associated logger. Service Weaver also provides integration with various monitoring frameworks. And finally, if you want to test whether your application still works in the presence of multiple application versions running, you can run Weaver GKE local.", "auto_highlights_result": {"status": "success", "results": [{"count": 6, "rank": 0.11, "text": "Weaver application", "timestamps": [{"start": 316856, "end": 317762}, {"start": 392576, "end": 393580}, {"start": 418008, "end": 419010}, {"start": 468616, "end": 469570}, {"start": 491036, "end": 491882}, {"start": 789120, "end": 790060}]}, {"count": 48, "rank": 0.11, "text": "service Weaver", "timestamps": [{"start": 35676, "end": 36966}, {"start": 241548, "end": 242610}, {"start": 255876, "end": 257018}, {"start": 258596, "end": 259306}, {"start": 268344, "end": 269422}, {"start": 291202, "end": 292574}, {"start": 316568, "end": 317246}, {"start": 322790, "end": 323646}, {"start": 346006, "end": 346886}, {"start": 359284, "end": 360202}, {"start": 375464, "end": 376366}, {"start": 385548, "end": 386226}, {"start": 392288, "end": 392966}, {"start": 405498, "end": 406730}, {"start": 417528, "end": 418446}, {"start": 441232, "end": 442054}, {"start": 461988, "end": 462630}, {"start": 468328, "end": 469006}, {"start": 490764, "end": 491358}, {"start": 599950, "end": 600818}, {"start": 612244, "end": 612958}, {"start": 617560, "end": 618206}, {"start": 628364, "end": 629138}, {"start": 638544, "end": 639206}, {"start": 648670, "end": 649622}, {"start": 652992, "end": 653686}, {"start": 693070, "end": 693926}, {"start": 699232, "end": 700098}, {"start": 719610, "end": 720438}, {"start": 745630, "end": 746534}, {"start": 771118, "end": 771726}, {"start": 777506, "end": 778306}, {"start": 788784, "end": 789446}, {"start": 802758, "end": 803418}, {"start": 844910, "end": 846134}, {"start": 921928, "end": 922654}, {"start": 930092, "end": 931106}, {"start": 938732, "end": 939574}, {"start": 961988, "end": 962814}, {"start": 975118, "end": 975886}, {"start": 989222, "end": 990214}, {"start": 1004532, "end": 1005370}, {"start": 1027138, "end": 1028066}, {"start": 1035340, "end": 1036354}, {"start": 1044192, "end": 1045350}, {"start": 1057114, "end": 1057994}, {"start": 1063130, "end": 1064234}, {"start": 1071796, "end": 1072426}]}, {"count": 3, "rank": 0.1, "text": "application code", "timestamps": [{"start": 198326, "end": 199370}, {"start": 1024648, "end": 1025382}, {"start": 1046928, "end": 1047594}]}, {"count": 4, "rank": 0.09, "text": "performance applications", "timestamps": [{"start": 270792, "end": 272254}, {"start": 380104, "end": 381590}, {"start": 849552, "end": 851070}, {"start": 1074986, "end": 1076578}]}, {"count": 1, "rank": 0.09, "text": "multiple application versions", "timestamps": [{"start": 835308, "end": 836722}]}, {"count": 4, "rank": 0.09, "text": "distributed applications", "timestamps": [{"start": 38786, "end": 40082}, {"start": 44866, "end": 45986}, {"start": 212612, "end": 213902}, {"start": 1068850, "end": 1070590}]}, {"count": 3, "rank": 0.09, "text": "high performance applications", "timestamps": [{"start": 270510, "end": 272254}, {"start": 379902, "end": 381590}, {"start": 849318, "end": 851070}]}, {"count": 1, "rank": 0.09, "text": "new application versions", "timestamps": [{"start": 353018, "end": 354170}]}, {"count": 2, "rank": 0.09, "text": "service weaver runtime", "timestamps": [{"start": 375464, "end": 376814}, {"start": 628364, "end": 629474}]}, {"count": 1, "rank": 0.08, "text": "service weaver new programming framework", "timestamps": [{"start": 35676, "end": 38114}]}, {"count": 4, "rank": 0.08, "text": "service viewer", "timestamps": [{"start": 667768, "end": 668366}, {"start": 680158, "end": 681098}, {"start": 724008, "end": 724766}, {"start": 1015508, "end": 1016278}]}, {"count": 1, "rank": 0.08, "text": "service people", "timestamps": [{"start": 879148, "end": 879830}]}, {"count": 1, "rank": 0.08, "text": "service discovery", "timestamps": [{"start": 953284, "end": 954378}]}, {"count": 2, "rank": 0.08, "text": "Weaver GKE", "timestamps": [{"start": 569992, "end": 570702}, {"start": 838112, "end": 838902}]}, {"count": 2, "rank": 0.08, "text": "Weaver init", "timestamps": [{"start": 472072, "end": 473390}, {"start": 792800, "end": 793942}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}