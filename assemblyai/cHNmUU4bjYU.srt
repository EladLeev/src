1
00:01:42,590 --> 00:01:46,002
You. Hello and

2
00:01:46,056 --> 00:01:49,342
welcome to my Conf 42 talk on continuous feedback

3
00:01:49,406 --> 00:01:53,054
and opentelemetry. If you're not familiar

4
00:01:53,102 --> 00:01:56,866
with the term continuous feedback, I promise you I didn't make it

5
00:01:56,888 --> 00:02:00,818
up and I hope that by the end of this talk

6
00:02:00,904 --> 00:02:04,626
you will have a firm grasp of what it is and why

7
00:02:04,648 --> 00:02:08,860
I think it's absolutely important for develop purs to master it.

8
00:02:11,070 --> 00:02:13,740
Now, just a few words about me.

9
00:02:14,350 --> 00:02:17,594
Most of my background is in development. I've been a developer for

10
00:02:17,632 --> 00:02:21,790
over 25 years. Throughout that time

11
00:02:21,940 --> 00:02:25,342
I've been pretty obsessed with how to create the right

12
00:02:25,396 --> 00:02:28,874
development processes, and I've

13
00:02:28,922 --> 00:02:32,900
seen a lot of situations where we're doing things pretty wrong.

14
00:02:34,390 --> 00:02:37,746
And one of the things I did notice was that even when

15
00:02:37,768 --> 00:02:41,506
we were following best practices and kind

16
00:02:41,528 --> 00:02:44,810
of developing according to the latest Gitops

17
00:02:44,910 --> 00:02:48,742
processes doing continuous deployment, we were

18
00:02:48,796 --> 00:02:52,230
missing something in that loop. And that particular something

19
00:02:52,300 --> 00:02:54,680
is what I want to discuss today.

20
00:02:56,810 --> 00:03:00,282
Now, I've been a developer for 25

21
00:03:00,336 --> 00:03:03,686
years, and one thing I can say is that coding

22
00:03:03,718 --> 00:03:06,940
practices really changed throughout that time.

23
00:03:08,110 --> 00:03:10,720
So those of you are old enough to remember,

24
00:03:11,170 --> 00:03:14,526
this was our git ops process back in the days. Like,

25
00:03:14,628 --> 00:03:18,320
we basically took whatever release we

26
00:03:19,010 --> 00:03:22,586
managed to stabilize, we burned

27
00:03:22,618 --> 00:03:26,434
it on CD and we gave it to the guys across

28
00:03:26,472 --> 00:03:29,618
the hall called the QA department and they would test it sometimes,

29
00:03:29,704 --> 00:03:33,330
give us back some errors to fix, and eventually this would get

30
00:03:33,400 --> 00:03:37,494
deployed. Now, obviously this

31
00:03:37,532 --> 00:03:41,766
isn't the case anymore, and as of yesterday at least,

32
00:03:41,948 --> 00:03:45,702
developers have much more involvement in how to test

33
00:03:45,756 --> 00:03:49,654
and validate their code. So your job as a developer

34
00:03:49,702 --> 00:03:53,274
doesn't end when you finish the coding part.

35
00:03:53,472 --> 00:03:56,534
Usually you at least write some unit test integration

36
00:03:56,582 --> 00:04:00,486
tests perhaps. And then many developers are also very involved

37
00:04:00,518 --> 00:04:04,094
in how their code gets deployed. So that means that to be a

38
00:04:04,132 --> 00:04:07,514
kind of a full stack whole product developer,

39
00:04:07,562 --> 00:04:10,800
you need to worry about helm files and terraform as well.

40
00:04:12,050 --> 00:04:15,906
But the question remains, and I'm going to

41
00:04:15,928 --> 00:04:19,300
leave that out there for a second and we'll come back to that point.

42
00:04:19,830 --> 00:04:23,618
And this is a really pivotal point, which is what happens

43
00:04:23,784 --> 00:04:27,810
next. So what happens after you deploy

44
00:04:27,890 --> 00:04:31,894
to production? And I

45
00:04:31,932 --> 00:04:34,840
mentioned before that I am,

46
00:04:35,610 --> 00:04:39,306
or I adopted the latest and

47
00:04:39,328 --> 00:04:43,110
greatest dev practices, we're doing continuous deployment,

48
00:04:43,270 --> 00:04:45,260
we're releasing pretty fast.

49
00:04:47,950 --> 00:04:51,514
But if there is no kind of continuation to this

50
00:04:51,552 --> 00:04:56,622
process, it seems that all we were doing, in fact, is actually just

51
00:04:56,676 --> 00:04:59,822
throwing features over the fence, maybe at a higher rate

52
00:04:59,876 --> 00:05:03,394
or a higher velocity. Because what

53
00:05:03,432 --> 00:05:07,390
really strikes me about this particular diagram

54
00:05:07,470 --> 00:05:09,330
is that it's pretty linear.

55
00:05:10,230 --> 00:05:13,646
And if you recall from all of what we've

56
00:05:13,678 --> 00:05:17,430
been taught or how we learn to code our craft.

57
00:05:18,010 --> 00:05:21,334
Development is supposed to be nonlinear. It's supposed to be kind of like

58
00:05:21,372 --> 00:05:25,318
a loop, right? So where is the loop in this straight line

59
00:05:25,404 --> 00:05:28,986
if all you're doing is just following these

60
00:05:29,008 --> 00:05:32,620
stages and moving on? But we'll get back to that.

61
00:05:34,590 --> 00:05:38,026
However, all of this was happening yesterday, and I think today there

62
00:05:38,048 --> 00:05:42,014
are a lot of new tools that we can leverage to actually make

63
00:05:42,052 --> 00:05:46,126
us even more production. So definitely

64
00:05:46,308 --> 00:05:50,558
code generation tools are helping me, us create

65
00:05:50,644 --> 00:05:54,558
code faster. Oftentimes we create

66
00:05:54,724 --> 00:05:58,466
pieces of code with copilot, and if we're lucky enough, then we

67
00:05:58,488 --> 00:06:01,874
don't just delete them because they're not good enough and rewrite them.

68
00:06:01,912 --> 00:06:05,206
But sometimes there is actually things we can use, or at least we

69
00:06:05,228 --> 00:06:08,310
get a working model. But at the same

70
00:06:08,380 --> 00:06:11,606
time, it looks like we're just beginning to scratch the

71
00:06:11,628 --> 00:06:15,560
surface about what these same AI tools can do

72
00:06:16,410 --> 00:06:20,390
to make information about our code more accessible.

73
00:06:21,370 --> 00:06:24,646
So if you think about it this way, it's kind of input and output.

74
00:06:24,678 --> 00:06:28,042
So the output is the code that you write. That's fine, we're doing that much

75
00:06:28,096 --> 00:06:31,694
faster. But how are we improving on

76
00:06:31,732 --> 00:06:34,718
actually analyzing what the code does?

77
00:06:34,804 --> 00:06:38,174
How are we improving on actually learning from our

78
00:06:38,212 --> 00:06:41,742
code? And the question is, what do we know about

79
00:06:41,796 --> 00:06:45,794
our code, really? Now this

80
00:06:45,832 --> 00:06:49,442
may seem to be a very dumb question. Like, what do you mean,

81
00:06:49,496 --> 00:06:53,486
what do I know about my code? I wrote it, I compiled

82
00:06:53,518 --> 00:06:56,950
it. If it's a language that requires compilation,

83
00:06:57,370 --> 00:07:01,110
I debugged it, I ran my tests.

84
00:07:01,690 --> 00:07:05,190
Is that enough? That's a really good question.

85
00:07:05,260 --> 00:07:08,794
Right? Because in the spectrum of what is

86
00:07:08,832 --> 00:07:12,410
enough to know about your code, you can

87
00:07:12,560 --> 00:07:16,090
kind of put knowing that your code

88
00:07:16,160 --> 00:07:19,434
works or makes the world better or makes your software better,

89
00:07:19,472 --> 00:07:23,534
or doesn't cause any regressions to be something on one

90
00:07:23,572 --> 00:07:27,470
end of the spectrum, which may be requiring a little bit more analysis.

91
00:07:28,210 --> 00:07:32,090
But at a very basic level, it can also mean, do I know

92
00:07:32,180 --> 00:07:34,690
if my code even runs?

93
00:07:36,550 --> 00:07:40,034
So I'll give you an example. I was working on one

94
00:07:40,072 --> 00:07:43,614
project where one of the developers wrote this meticulous

95
00:07:43,662 --> 00:07:47,990
piece of code that is a complete refactoring of the data access layer.

96
00:07:49,050 --> 00:07:52,534
And he completed this piece of code. He did

97
00:07:52,572 --> 00:07:55,986
a code review, everybody looked at it. He wrote

98
00:07:56,018 --> 00:07:59,130
the test that validated that it's working as expected.

99
00:07:59,470 --> 00:08:01,770
Then he pushed that into production.

100
00:08:03,310 --> 00:08:06,986
And eventually, and when I say eventually, I mean like a month later,

101
00:08:07,168 --> 00:08:11,390
we find out that it never ran due to some bad if statement.

102
00:08:12,850 --> 00:08:16,640
So in the spectrum of what do I know about my code?

103
00:08:18,450 --> 00:08:22,202
Sometimes it doesn't go even beyond do I know

104
00:08:22,276 --> 00:08:25,634
whether my code runs? And I

105
00:08:25,672 --> 00:08:29,060
actually confirmed that that developer and I asked them,

106
00:08:31,190 --> 00:08:34,740
why didn't you check, you actually

107
00:08:35,190 --> 00:08:39,346
wrote this great piece of code, you rolled it into production.

108
00:08:39,538 --> 00:08:43,558
Why didn't you check that your code is running? And he gave me an answer

109
00:08:43,644 --> 00:08:47,030
that it was very hard for me to challenge.

110
00:08:47,550 --> 00:08:50,634
And his answer was,

111
00:08:50,832 --> 00:08:54,746
well, how? And I

112
00:08:54,768 --> 00:08:59,100
think this is something that is in the very

113
00:08:59,730 --> 00:09:03,242
center of this talk about continuous feedback,

114
00:09:03,386 --> 00:09:06,958
because the how is really

115
00:09:07,044 --> 00:09:10,590
a missing piece here. So if the developer asks me

116
00:09:10,660 --> 00:09:13,842
how do I actually test that my code is running

117
00:09:13,896 --> 00:09:16,180
and I don't have a good answer for him,

118
00:09:16,870 --> 00:09:18,980
then that's a problem.

119
00:09:19,910 --> 00:09:23,474
And what adds to that problem is the fact that what that

120
00:09:23,512 --> 00:09:27,014
developer did right after he rolled that feature into

121
00:09:27,052 --> 00:09:30,726
production is just to take the next feature from

122
00:09:30,748 --> 00:09:33,160
the backlog and continue on.

123
00:09:33,530 --> 00:09:36,934
And it's no fault of his

124
00:09:36,972 --> 00:09:40,522
own, because us software organizations are pretty forward

125
00:09:40,576 --> 00:09:44,090
leaning. I was a product management manager at one stage,

126
00:09:44,430 --> 00:09:48,220
and as a product manager I kind of contributed to this problem

127
00:09:49,070 --> 00:09:52,350
because I put a lot of pressure on engineers to move

128
00:09:52,420 --> 00:09:55,486
forward. Like, I don't think any

129
00:09:55,588 --> 00:09:59,214
product manager that I met in the world has a roadmap that

130
00:09:59,252 --> 00:10:03,470
says, okay, roll out user management feature

131
00:10:03,970 --> 00:10:07,374
and then another box that says get technical

132
00:10:07,422 --> 00:10:10,802
feedback about whether it's scalable. No, nobody has that right.

133
00:10:10,856 --> 00:10:14,574
So when a developer tells me he's done, I'm already putting pressure

134
00:10:14,622 --> 00:10:16,550
on how do we get to the next stage?

135
00:10:18,570 --> 00:10:22,198
And this creates a gap both in

136
00:10:22,284 --> 00:10:25,686
the code itself and in what

137
00:10:25,708 --> 00:10:29,034
we know about it. And when we don't understand our

138
00:10:29,072 --> 00:10:33,290
code, when we start pushing features into production

139
00:10:34,190 --> 00:10:37,814
and only discovering later that they're

140
00:10:37,862 --> 00:10:41,740
lacking, or that we didn't quite get things right,

141
00:10:42,050 --> 00:10:45,838
then we end up troubleshooting. When we troubleshoot in the middle of

142
00:10:45,844 --> 00:10:49,054
the night, a problem in production, it's because we don't know how our

143
00:10:49,092 --> 00:10:50,910
code works and performs.

144
00:10:53,110 --> 00:10:56,260
Now this is a problem.

145
00:10:56,710 --> 00:11:00,226
And in some teams this escalates to the

146
00:11:00,248 --> 00:11:03,570
point where it's actually interfering with regular work.

147
00:11:03,640 --> 00:11:07,014
I worked in one team where we were actually using the

148
00:11:07,052 --> 00:11:10,402
phrase BDD, and I don't mean behavior

149
00:11:10,466 --> 00:11:14,006
driven design, I mean bug driven development, because all

150
00:11:14,028 --> 00:11:17,298
we were doing is actually chase the bugs that

151
00:11:17,324 --> 00:11:21,274
we were introducing by just quickly

152
00:11:21,472 --> 00:11:25,194
throwing features over the fence, or in this case rolling in

153
00:11:25,232 --> 00:11:29,558
features without getting any feedback about how

154
00:11:29,664 --> 00:11:32,814
that actually works, about whether our code

155
00:11:32,852 --> 00:11:36,734
is good or bad. And this

156
00:11:36,852 --> 00:11:40,906
feedback doesn't need to exist in production.

157
00:11:41,018 --> 00:11:44,834
We can actually get a lot of feedback from our code much

158
00:11:44,872 --> 00:11:48,210
before. So I will give you an example

159
00:11:48,280 --> 00:11:52,002
of that. And this is, I'm the last person

160
00:11:52,056 --> 00:11:56,086
to believe a ten X engineer exists. I actually think engineers are

161
00:11:56,108 --> 00:11:59,862
very versatile and usually are kind of, they have

162
00:11:59,916 --> 00:12:04,120
different traits that mesh together to create maybe a ten X team

163
00:12:04,650 --> 00:12:07,350
when you have the lights, combination of skills.

164
00:12:08,090 --> 00:12:12,060
But in this instance, I was working with a team of about ten people,

165
00:12:13,070 --> 00:12:16,362
and one of the developers really stood out to me

166
00:12:16,416 --> 00:12:20,320
as a Tanx engineer, and he did something amazing.

167
00:12:20,770 --> 00:12:24,670
He also did something terrible that I wouldn't actually recommend anybody

168
00:12:24,740 --> 00:12:27,840
to do. And here's the story.

169
00:12:28,210 --> 00:12:31,742
He was working on a feature, he was working on

170
00:12:31,796 --> 00:12:35,998
some kind of a refactoring

171
00:12:36,094 --> 00:12:40,034
and adding features to a batch job that was

172
00:12:40,072 --> 00:12:43,698
doing data processing. And as he was working

173
00:12:43,784 --> 00:12:47,214
on that, he decided to do something strange.

174
00:12:47,262 --> 00:12:50,546
And I witnessed that, or I was kind of exposed

175
00:12:50,578 --> 00:12:54,466
to that. When I was looking at the logs and I started seeing rows

176
00:12:54,498 --> 00:12:57,438
upon rows upon rows of numbers appear,

177
00:12:57,634 --> 00:13:01,226
it was completely spamming the application output and

178
00:13:01,248 --> 00:13:05,162
it was something like 30, 40, 60 40,

179
00:13:05,296 --> 00:13:07,610
kind of looked like the screen from the matrix.

180
00:13:09,390 --> 00:13:13,580
And obviously I confronted him about it and asked like,

181
00:13:14,850 --> 00:13:18,110
why are you generating so many numbers to the output?

182
00:13:18,770 --> 00:13:21,498
And he said two things. First of all, that he was sorry that he checked

183
00:13:21,514 --> 00:13:25,730
it and he was working locally on some customer database

184
00:13:26,150 --> 00:13:30,114
or customer like database. And here is what he was

185
00:13:30,152 --> 00:13:32,980
doing. He was actually,

186
00:13:33,670 --> 00:13:37,382
as he was working, keeping track of

187
00:13:37,436 --> 00:13:41,094
how much time each iteration of

188
00:13:41,132 --> 00:13:45,046
this batch job took. And somehow in

189
00:13:45,068 --> 00:13:48,678
his peripheral vision, in his kind of spider sense

190
00:13:48,764 --> 00:13:52,554
that he had developed, he was able

191
00:13:52,592 --> 00:13:55,786
to discern whether the numbers were going a little crazy,

192
00:13:55,888 --> 00:13:59,722
whether it was like too many seventy s and eighty s or ninety s

193
00:13:59,856 --> 00:14:03,078
and too little of the he

194
00:14:03,104 --> 00:14:07,486
expected in milliseconds. And whenever that happened,

195
00:14:07,668 --> 00:14:11,006
he knew that the code that he was adding all the

196
00:14:11,028 --> 00:14:14,354
time into the code base and adding into

197
00:14:14,392 --> 00:14:18,226
the loop was actually degrading the application

198
00:14:18,328 --> 00:14:21,650
performance. Now, first of all,

199
00:14:21,720 --> 00:14:24,660
I do not recommend this practices, but second,

200
00:14:25,050 --> 00:14:29,142
I think that this is a great thing

201
00:14:29,196 --> 00:14:32,770
that he did, because unlike the other ten developers

202
00:14:32,850 --> 00:14:36,662
in the team, he actually cared enough. He had

203
00:14:36,716 --> 00:14:40,266
that sense of ownership in order

204
00:14:40,368 --> 00:14:44,598
to check, to validate, to continuously

205
00:14:44,694 --> 00:14:47,914
try to get feedback about what

206
00:14:47,952 --> 00:14:51,242
he was trying to do. And in

207
00:14:51,296 --> 00:14:54,494
fact, if we kind of examined where we

208
00:14:54,532 --> 00:14:58,334
have feedback and where we don't have feedback, so sure when

209
00:14:58,372 --> 00:15:02,158
we develop, we get some feedback because we can debug our code and

210
00:15:02,164 --> 00:15:06,078
we can see it working. But even that is kind of limited

211
00:15:06,174 --> 00:15:10,286
because if you've ever worked with a debugger,

212
00:15:10,318 --> 00:15:14,222
then you introduced a breakpoint and it's kind of like an instance

213
00:15:14,286 --> 00:15:18,406
in time and space where you've captured a specific state of the

214
00:15:18,428 --> 00:15:22,178
system. It doesn't tell you anything about how it will behave

215
00:15:22,274 --> 00:15:25,654
the minute after you resume your breakpoint. And the same

216
00:15:25,692 --> 00:15:29,610
goes for tests. Tests offer a very limited pass fail results,

217
00:15:29,950 --> 00:15:33,450
but they don't really tell you anything about how the system

218
00:15:33,520 --> 00:15:37,180
behaved during the test, which is maybe the more interesting part.

219
00:15:38,110 --> 00:15:41,254
Now, if you talk about production feedback, then that's where developers

220
00:15:41,302 --> 00:15:45,390
are clueless. Like, there's so many observability systems and so many

221
00:15:45,460 --> 00:15:48,814
instances where I've seen developers are

222
00:15:48,852 --> 00:15:51,840
reaping none of those benefits at all.

223
00:15:52,310 --> 00:15:55,410
And it, through no fault of their own.

224
00:15:55,480 --> 00:15:57,170
I think for generations,

225
00:15:59,510 --> 00:16:03,262
software generations, APM software

226
00:16:03,406 --> 00:16:07,014
kind of evolved towards it,

227
00:16:07,132 --> 00:16:10,934
Sres DevOps, and less towards developers and

228
00:16:10,972 --> 00:16:15,078
their code. I was actually in

229
00:16:15,244 --> 00:16:18,474
one, visiting one company in Israel where I was

230
00:16:18,512 --> 00:16:22,058
talking to the VP of engineering, and he was showing me

231
00:16:22,224 --> 00:16:25,846
they had this amazing observability dashboards

232
00:16:25,878 --> 00:16:29,660
on their but,

233
00:16:30,670 --> 00:16:33,934
and I was actually awestruck by that. I told him, look,

234
00:16:33,972 --> 00:16:37,390
you guys are way ahead of the curve, I need to learn from you.

235
00:16:37,540 --> 00:16:40,926
And he said, well, I'm not so sure because I

236
00:16:40,948 --> 00:16:45,378
just had an interview or a review with one

237
00:16:45,384 --> 00:16:48,482
of the engineers on the team, and what he said was,

238
00:16:48,536 --> 00:16:52,610
they actually believe these dashboards were just screenshots.

239
00:16:53,190 --> 00:16:56,882
So it seemed that for some organizations, for some engineers,

240
00:16:56,946 --> 00:17:00,054
the point of observability is to

241
00:17:00,092 --> 00:17:03,602
create dashboards or to support production monitoring

242
00:17:03,746 --> 00:17:08,070
rather than integrate them as feedback towards the developers.

243
00:17:09,370 --> 00:17:13,114
And I was kind of surprised by that and

244
00:17:13,152 --> 00:17:16,794
kind of not, because at the same time I've been feeling the same pain again

245
00:17:16,832 --> 00:17:19,654
and again in all of those examples from continuous deployment,

246
00:17:19,702 --> 00:17:23,242
lacking that one piece of feedback through developers

247
00:17:23,306 --> 00:17:26,650
not knowing if their code was even running to developers,

248
00:17:26,730 --> 00:17:30,574
resorting to very strange solutions just to be able to be

249
00:17:30,612 --> 00:17:33,700
capturing what their code is doing even while in dev.

250
00:17:34,630 --> 00:17:39,074
So I went back to kind of the source where we

251
00:17:39,112 --> 00:17:42,660
kind of always like to model,

252
00:17:43,270 --> 00:17:45,800
and I have to be frank, by now,

253
00:17:48,890 --> 00:17:52,760
this analogy of the DevOps loop has completely worn itself out.

254
00:17:53,130 --> 00:17:56,518
I think we need to find a better one. But for lack of one,

255
00:17:56,604 --> 00:17:59,546
let's stick with this model,

256
00:17:59,728 --> 00:18:03,334
ancient as it is. And if we look at the DevOps

257
00:18:03,382 --> 00:18:06,890
loop, we can notice something really alarming about

258
00:18:06,960 --> 00:18:10,134
it because, and by the way, this is just an image.

259
00:18:10,182 --> 00:18:13,294
Like, I think it's one of the first images that you get if you search

260
00:18:13,332 --> 00:18:17,166
for DevOps loop on Google images. And one thing

261
00:18:17,188 --> 00:18:20,574
you'll notice here is that there's so many tools attached to

262
00:18:20,612 --> 00:18:23,730
each stage of the feedback loop.

263
00:18:25,110 --> 00:18:29,102
So we have plan, build, CI deployment,

264
00:18:29,166 --> 00:18:32,814
all of that. Sorry, the dev loop, it has a lot of tools associated

265
00:18:32,862 --> 00:18:36,242
with it, but smack in the middle of this diagram,

266
00:18:36,306 --> 00:18:41,186
we have this actual portion that says there's

267
00:18:41,218 --> 00:18:43,670
this segment that says continuous feedback.

268
00:18:45,690 --> 00:18:49,058
As I mentioned in the beginning of the talk, I didn't make

269
00:18:49,084 --> 00:18:52,826
this up. It's not something that I came up with. It was there all

270
00:18:52,848 --> 00:18:56,666
along. But you will notice can alarming lack of

271
00:18:56,688 --> 00:19:00,170
any tools associated with it, except for some reason

272
00:19:00,240 --> 00:19:03,706
for Salesforce, which of course has nothing to do with continuous

273
00:19:03,738 --> 00:19:07,214
feedback from operations to planning. Well, maybe it does if you look

274
00:19:07,252 --> 00:19:12,138
more from a product manager's perspective, from an engineering perspective,

275
00:19:12,234 --> 00:19:15,490
it's not related. So we have this

276
00:19:15,560 --> 00:19:19,010
hole in the middle of our DevOps loop that is

277
00:19:19,080 --> 00:19:22,354
actually causing all of these different symptoms. And the

278
00:19:22,392 --> 00:19:26,358
question is, how do we actually solve it? How do we actually

279
00:19:26,524 --> 00:19:30,310
bridge this gap? And going

280
00:19:30,380 --> 00:19:34,040
back to these two examples that I mentioned,

281
00:19:34,410 --> 00:19:37,786
the developer that didn't know if his code was

282
00:19:37,808 --> 00:19:41,014
even running, and evidently it didn't,

283
00:19:41,142 --> 00:19:44,390
and the developer that had to use these primitive

284
00:19:44,550 --> 00:19:48,300
tools to actually try to use a spider sense to

285
00:19:49,310 --> 00:19:52,974
discern if something was off as he was writing the

286
00:19:53,012 --> 00:19:56,606
code, what is the actual

287
00:19:56,708 --> 00:20:00,270
technology that can help us solve this? And to go back

288
00:20:00,340 --> 00:20:03,940
to the way practices are changing, we talked about

289
00:20:04,470 --> 00:20:07,934
how we can use AI to generate code. What is the equivalent

290
00:20:07,982 --> 00:20:11,586
that we can use here? So this

291
00:20:11,608 --> 00:20:15,338
is a perfect segue to start discussing

292
00:20:15,534 --> 00:20:18,280
opentelemetry and why it is important.

293
00:20:20,570 --> 00:20:24,198
So one thing I would say about opentelemetry is that

294
00:20:24,284 --> 00:20:27,814
it is not revolutionary. It is more

295
00:20:27,852 --> 00:20:31,174
evolutionary. It is the merging together of two

296
00:20:31,212 --> 00:20:34,406
standards, open census and Opentrace. It didn't

297
00:20:34,438 --> 00:20:37,420
bring anything groundbreaking in terms of the technology,

298
00:20:39,230 --> 00:20:43,294
but it did bring something else that's really groundbreaking to

299
00:20:43,332 --> 00:20:46,270
the software development industry,

300
00:20:47,250 --> 00:20:51,550
and that is that everybody agrees on it, because that didn't exist.

301
00:20:53,110 --> 00:20:57,234
Never before has there been such a gold standard for

302
00:20:57,272 --> 00:21:00,690
observability. Why is that important?

303
00:21:00,840 --> 00:21:04,094
Because it's open. Because it's

304
00:21:04,142 --> 00:21:07,814
accepted by everyone. And that means that all of the

305
00:21:07,852 --> 00:21:11,126
libraries that you all are using, and it

306
00:21:11,148 --> 00:21:15,410
doesn't matter if you're using Java or using Python

307
00:21:15,490 --> 00:21:19,342
or you're using go. It doesn't matter if you're using Fastapi

308
00:21:19,426 --> 00:21:22,586
or if you're using Echo or Mox and

309
00:21:22,608 --> 00:21:26,394
go, or if you're using net with ASP Net MVC or

310
00:21:26,432 --> 00:21:28,650
if you're using spring in Java,

311
00:21:29,810 --> 00:21:33,146
if you're using Kafka or RabbitMQ, if you're

312
00:21:33,178 --> 00:21:37,530
using postgres databases or mongodb. All of these libraries

313
00:21:37,610 --> 00:21:41,194
have already introduced support for Opentelemetry

314
00:21:41,242 --> 00:21:44,900
because it was a simple choice to support that standard.

315
00:21:46,950 --> 00:21:50,994
But why is that important? Because that means that all

316
00:21:51,032 --> 00:21:54,274
of the data that you need to make all of these

317
00:21:54,312 --> 00:21:58,114
decisions to understand how the code is working, to know that it's

318
00:21:58,162 --> 00:22:01,654
working correctly, to know that you haven't introduced a regression in

319
00:22:01,692 --> 00:22:05,670
dev test and prod, all of that data is already

320
00:22:05,740 --> 00:22:09,678
there. It's just a matter of flipping

321
00:22:09,714 --> 00:22:13,242
a switch, turning the light on, because the minute you

322
00:22:13,296 --> 00:22:16,666
activate opentelemetry, and we'll take a look at

323
00:22:16,688 --> 00:22:20,414
an example in this talk, which is based off of Java, but the

324
00:22:20,452 --> 00:22:23,920
minute you activate open telemetry, you already have access

325
00:22:24,930 --> 00:22:28,714
to a lot of data. Now I've

326
00:22:28,762 --> 00:22:32,494
been in many organizations where yeah, all of these things were very

327
00:22:32,532 --> 00:22:36,238
important to us and we treated it like a project. Yeah, we have this observability

328
00:22:36,334 --> 00:22:40,126
project and we needed to prioritize it and we needed to create backlog

329
00:22:40,158 --> 00:22:43,646
items for it, and it was always less urgent

330
00:22:43,678 --> 00:22:47,270
than other things and the technical debt just kept piling up.

331
00:22:47,340 --> 00:22:50,838
This completely obliterates that problem, because we no longer

332
00:22:50,924 --> 00:22:54,646
have this issue where we need to do something. You don't

333
00:22:54,668 --> 00:22:58,918
need to make any code changes in some languages to just activate it.

334
00:22:59,084 --> 00:23:03,034
And the problem may be transformed from having too

335
00:23:03,072 --> 00:23:06,826
little data to having too much data. But we'll talk about how to

336
00:23:06,848 --> 00:23:10,686
solve that, because having too much data is an easier problem

337
00:23:10,788 --> 00:23:14,234
to solve. So in the context

338
00:23:14,282 --> 00:23:17,306
of today's talk, I'll be talking mostly about tracing.

339
00:23:17,498 --> 00:23:21,022
Opentelemetry does offer other integrations with

340
00:23:21,076 --> 00:23:24,386
metrics and logging, and the ability to actually

341
00:23:24,488 --> 00:23:28,194
triangulate these three. But in this case

342
00:23:28,232 --> 00:23:31,726
I'll talk about tracing because I think it's a much undervalued

343
00:23:31,758 --> 00:23:35,650
and underused technology that developers can reap a lot of benefit

344
00:23:35,730 --> 00:23:39,478
from. So to maybe

345
00:23:39,564 --> 00:23:42,822
start off, I want to explain what tracing is

346
00:23:42,876 --> 00:23:46,854
and why it is so important. Apologies if

347
00:23:46,892 --> 00:23:51,290
this is already familiar to you. So just a refresher about traces.

348
00:23:52,190 --> 00:23:55,914
So traces are essentially an anatomy of a request. They tell

349
00:23:55,952 --> 00:23:59,194
us what our code is doing. If I

350
00:23:59,232 --> 00:24:02,910
look at an API call, in this case, this is a spring boot application.

351
00:24:03,060 --> 00:24:06,570
I have an API that uses javaspring.

352
00:24:06,650 --> 00:24:10,510
It does a lot of things. It then goes and makes an external call

353
00:24:10,580 --> 00:24:14,960
to an API, and it uses hibernate to

354
00:24:15,490 --> 00:24:19,170
use a database driver to talk to postgres.

355
00:24:19,830 --> 00:24:23,394
All of these things that happen when a request get

356
00:24:23,432 --> 00:24:27,206
handled. And this can extend to other microservices. This is why it's

357
00:24:27,228 --> 00:24:30,726
called distributed tracing. So we can follow along as the

358
00:24:30,748 --> 00:24:33,698
request gets handled by multiple microservices.

359
00:24:33,874 --> 00:24:37,670
But this entire kind of flow we call a trace.

360
00:24:38,250 --> 00:24:41,786
And another piece of terminology that we should be

361
00:24:41,808 --> 00:24:45,386
familiar with is a span. And a span is kind of

362
00:24:45,408 --> 00:24:48,410
an activity that happens within that trace.

363
00:24:48,750 --> 00:24:52,378
In fact, if you're using net then activity is the terminology

364
00:24:52,474 --> 00:24:56,094
they chose for it. It's synonymous to span for some reason.

365
00:24:56,292 --> 00:25:00,394
So in this case I would look at the request anatomy

366
00:25:00,442 --> 00:25:03,902
and say okay, so this is what happens when my code gets

367
00:25:03,956 --> 00:25:08,206
executed. It first handles the HTTP request and it might have some checking

368
00:25:08,238 --> 00:25:11,810
of permissions validating with other sources. Maybe some queries are running.

369
00:25:11,960 --> 00:25:15,334
Each of these is a segment in the trace and this kind

370
00:25:15,372 --> 00:25:18,582
of gives me a breakdown of

371
00:25:18,716 --> 00:25:22,546
exactly what occurred when my code was invoked.

372
00:25:22,578 --> 00:25:26,566
This is exactly what would tell me if when somebody was

373
00:25:26,748 --> 00:25:30,582
running my new refactoring of the data access layer,

374
00:25:30,726 --> 00:25:33,050
my new code was actually triggered.

375
00:25:33,870 --> 00:25:38,602
And this is an example trace. We'll look at an actual code

376
00:25:38,656 --> 00:25:42,654
example in a sec, but this is what a trace looks like. We have

377
00:25:42,852 --> 00:25:46,362
the different segments or different spans

378
00:25:46,506 --> 00:25:50,334
that happen throughout that request handling. We have things like

379
00:25:50,372 --> 00:25:53,690
queries and we'll actually see that we're able to go down and see

380
00:25:53,860 --> 00:25:57,986
all the way to the actual query that was running and

381
00:25:58,008 --> 00:26:01,794
we have the different processes where we can identify where the issues are

382
00:26:01,912 --> 00:26:04,660
or what is taking so long.

383
00:26:06,090 --> 00:26:09,238
Enabling instrumentation is very easy. Again,

384
00:26:09,324 --> 00:26:13,298
this is a Java example. You can easily find examples

385
00:26:13,314 --> 00:26:17,234
for other languages. I like the Java implementation of opentelemetry

386
00:26:17,282 --> 00:26:20,646
because it doesn't require any code changes. If you want

387
00:26:20,668 --> 00:26:23,642
to run it in dev or test you can just use a Java agent.

388
00:26:23,776 --> 00:26:27,846
So you download the agent, you just add an environment variable

389
00:26:28,038 --> 00:26:31,662
as you can see in the box above here. And immediately you start

390
00:26:31,716 --> 00:26:35,326
seeing information about your code. Then if you

391
00:26:35,348 --> 00:26:39,082
want to track specific functions you can just add an annotation

392
00:26:39,146 --> 00:26:42,990
and that will start tracking how that piece of code behaves.

393
00:26:43,330 --> 00:26:46,146
All of that will be made clear in a sec when we look at the

394
00:26:46,168 --> 00:26:50,354
example, but I just want to make it

395
00:26:50,392 --> 00:26:54,130
clear that my goal in this session is

396
00:26:54,200 --> 00:26:58,102
not to show you how to activate telemetry or

397
00:26:58,156 --> 00:26:59,960
observability in your code.

398
00:27:00,810 --> 00:27:04,802
There are way too many talks

399
00:27:04,866 --> 00:27:08,202
and guides on how to do that and I feel

400
00:27:08,256 --> 00:27:11,500
I don't really have anything useful to add to that.

401
00:27:12,430 --> 00:27:15,990
I do think that where many of these guides

402
00:27:16,070 --> 00:27:19,846
are lacking or what we are missing is more information

403
00:27:19,968 --> 00:27:23,070
about how to actually use it. When we're developing,

404
00:27:23,490 --> 00:27:27,374
it's one thing to collect information, but then

405
00:27:27,412 --> 00:27:30,938
we're just left at that we have a lot of pretty dashboards.

406
00:27:31,034 --> 00:27:34,274
Situation where we want to get to is

407
00:27:34,312 --> 00:27:37,826
a situation where we actually generate data and

408
00:27:37,848 --> 00:27:40,850
then we can use it as we code.

409
00:27:41,000 --> 00:27:44,820
So I'm going to show you a quick example in my ide

410
00:27:45,430 --> 00:27:48,966
and then we can take it from there and see kind of where does

411
00:27:48,988 --> 00:27:53,334
that leave us? And is that enough? What else do we need to actually make

412
00:27:53,372 --> 00:27:57,446
the process better? In the course of this demo I

413
00:27:57,468 --> 00:28:00,602
will use Jaeger, which is an open source tool.

414
00:28:00,736 --> 00:28:04,906
And in fact everything that will be on

415
00:28:04,928 --> 00:28:08,582
this talk will be either open source or free tooling.

416
00:28:08,726 --> 00:28:12,094
So there are no commercial tools that I'll use

417
00:28:12,132 --> 00:28:15,920
in this talk that actually require you to pay money to use.

418
00:28:16,290 --> 00:28:19,886
We may have some time to talk about Grafana and

419
00:28:19,908 --> 00:28:22,798
Prometheus open source version, we may not.

420
00:28:22,884 --> 00:28:26,318
And I'll also show you a library that I'm working on called digma,

421
00:28:26,334 --> 00:28:29,746
which is also a free library that you can use

422
00:28:29,768 --> 00:28:33,700
as developers to maybe make use of that data.

423
00:28:34,730 --> 00:28:39,670
So without further ado, let's open the ide and stop

424
00:28:39,740 --> 00:28:43,560
looking at slideware and maybe start looking at code for a change.

425
00:28:53,230 --> 00:28:56,874
So let's take a look at some code to demonstrate how

426
00:28:56,912 --> 00:29:00,410
we can really do this feat or

427
00:29:00,480 --> 00:29:04,646
manage this feat of actually using observability

428
00:29:04,758 --> 00:29:08,730
when we code. I've opened a familiar

429
00:29:08,810 --> 00:29:12,286
project for every Java developer out there called the

430
00:29:12,308 --> 00:29:16,078
Pet Clinic project. It's kind of a go to sample

431
00:29:16,174 --> 00:29:20,820
for the spring boot framework and

432
00:29:21,190 --> 00:29:25,270
to make things interesting and also to kind of

433
00:29:25,420 --> 00:29:28,418
simulate some kind of a realistic scenario,

434
00:29:28,594 --> 00:29:32,326
I've actually added some functionality to it. So this

435
00:29:32,348 --> 00:29:35,862
is a pet shop that allows you to see

436
00:29:35,916 --> 00:29:39,020
pets and owners and visits and things like that.

437
00:29:40,190 --> 00:29:43,846
I have added the functionality of vaccinations.

438
00:29:43,958 --> 00:29:47,820
So I used some mock API to create

439
00:29:48,430 --> 00:29:50,960
this vaccination external service.

440
00:29:53,490 --> 00:29:57,294
We're going to asynchronously kind of get the data

441
00:29:57,412 --> 00:30:01,680
about the pet vaccines from that service

442
00:30:02,370 --> 00:30:06,302
and we can see we created this adapter

443
00:30:06,446 --> 00:30:10,386
that actually does all of the work of actually

444
00:30:10,488 --> 00:30:13,602
kind of retrieving the object.

445
00:30:13,736 --> 00:30:17,318
We've also extended or added a table to

446
00:30:17,324 --> 00:30:19,894
the database to keep the vaccination data.

447
00:30:20,092 --> 00:30:23,814
And after working on this feature for a few

448
00:30:23,852 --> 00:30:27,266
hours, kind of proud to say that it

449
00:30:27,308 --> 00:30:31,020
seems to be working. Let's take a look at

450
00:30:31,390 --> 00:30:35,194
what it is. So you may notice some text here.

451
00:30:35,232 --> 00:30:39,340
This is because I've actually enabled opentelemetry for this project.

452
00:30:40,030 --> 00:30:44,874
Again, if you want to see how to do that, go to continuousfeedback.org.

453
00:30:44,922 --> 00:30:48,782
This is where I have all of the kind of open

454
00:30:48,836 --> 00:30:52,374
telemetry 101 things that I'm not touching

455
00:30:52,442 --> 00:30:55,906
on in this talk. I've set up

456
00:30:55,928 --> 00:30:59,220
all of the links so you can very easily follow.

457
00:31:00,230 --> 00:31:03,826
And let's take a look at what this pet clinic Project

458
00:31:03,928 --> 00:31:07,990
looks like. So I've

459
00:31:08,570 --> 00:31:12,886
started my app. I can see pretty

460
00:31:12,988 --> 00:31:16,166
straightforward interface. My own

461
00:31:16,268 --> 00:31:20,114
small contribution was to add the vaccination

462
00:31:20,162 --> 00:31:23,622
status. And that means when I look at a specific owner,

463
00:31:23,686 --> 00:31:27,418
I can see whether they need a vaccine for their pets, which is awesome.

464
00:31:27,584 --> 00:31:31,150
And I can also add a new pet,

465
00:31:31,570 --> 00:31:35,946
which now will also include

466
00:31:35,978 --> 00:31:39,326
the vaccination data or kind of trigger a

467
00:31:39,348 --> 00:31:43,506
call to this vaccination service to get the vaccine information for

468
00:31:43,528 --> 00:31:46,754
this pet. So let's add lucky the

469
00:31:46,792 --> 00:31:47,380
dog.

470
00:31:52,230 --> 00:31:54,340
Whoa, this looks like an issue.

471
00:31:55,750 --> 00:31:58,982
Oh, there is already a lucky one. So let's call

472
00:31:59,036 --> 00:32:02,834
him lucky tools. Perfect. And we've

473
00:32:02,882 --> 00:32:06,306
added this dog. I can assure you that in the background we're

474
00:32:06,338 --> 00:32:09,542
running some processes to get the vaccination status

475
00:32:09,686 --> 00:32:12,438
for this pet. Pretty neat.

476
00:32:12,534 --> 00:32:15,338
Now the question is, again,

477
00:32:15,424 --> 00:32:17,820
to go back to what we were talking about before.

478
00:32:19,470 --> 00:32:23,594
What do I actually know about this code? So I

479
00:32:23,632 --> 00:32:26,782
can check via tests? And indeed I'm using

480
00:32:26,836 --> 00:32:30,430
test containers here. I wrote some integration tests

481
00:32:31,170 --> 00:32:34,202
to test this very scenario. I can show you.

482
00:32:34,276 --> 00:32:37,634
So, for example, we have some tests here that

483
00:32:37,672 --> 00:32:41,534
check that the owner is created. There are kind of end to end tests

484
00:32:41,582 --> 00:32:45,234
and they get all of the data, kind of

485
00:32:45,272 --> 00:32:48,760
making sure it's persisted in the database, making sure it's rendered in the view.

486
00:32:49,770 --> 00:32:53,414
We've kind of done our due diligence about the

487
00:32:53,452 --> 00:32:56,290
testing part here. This code was also reviewed.

488
00:32:56,450 --> 00:33:00,310
So all in all, I would say that I've

489
00:33:00,390 --> 00:33:04,810
kind of reached the limit of what I'm able to do as a developer.

490
00:33:05,150 --> 00:33:08,170
And to go to the previous examples we were discussing,

491
00:33:09,630 --> 00:33:13,566
this is pretty much the limits of what any developer would do in

492
00:33:13,588 --> 00:33:18,126
a similar situation. So, recap. I've written this code.

493
00:33:18,308 --> 00:33:21,886
Maybe not the best because my Java was a little rusty, but it

494
00:33:21,908 --> 00:33:25,506
works. Somebody's reviewed it. I have written the

495
00:33:25,528 --> 00:33:29,042
tests. I'm ready to move on to the next feature. But like we mentioned

496
00:33:29,096 --> 00:33:32,414
in the previous examples, that isn't

497
00:33:32,462 --> 00:33:36,526
really getting feedback about my code. So let's see how opentelemetry

498
00:33:36,558 --> 00:33:39,878
can help me, because as I mentioned, I was running open telemetry in

499
00:33:39,884 --> 00:33:43,334
the background. So the first tool I'm going to

500
00:33:43,372 --> 00:33:46,930
use is an open source tool called Yeager. And Yeager

501
00:33:47,010 --> 00:33:51,158
is just a simple tool to visualize the traces that I've been collecting

502
00:33:51,334 --> 00:33:54,666
while debugging and running this code.

503
00:33:54,848 --> 00:33:58,458
So I'm going to open up the yeager interface. And this

504
00:33:58,464 --> 00:34:02,202
is just a container that's running on my machine. And immediately

505
00:34:02,266 --> 00:34:07,034
I can see the different actions

506
00:34:07,162 --> 00:34:10,782
that were carried out here. And we can see

507
00:34:10,836 --> 00:34:14,626
kind of the adding of the pet, the post request, and then getting of

508
00:34:14,648 --> 00:34:17,940
the pet details, all of that tools fine.

509
00:34:18,550 --> 00:34:22,114
I may notice some very strange things here.

510
00:34:22,312 --> 00:34:25,310
The first thing is that the number of spans,

511
00:34:25,390 --> 00:34:28,754
and remember span is like a segment inside the trace

512
00:34:28,882 --> 00:34:33,462
is exceedingly high. This is 256 spans, it's 164

513
00:34:33,516 --> 00:34:37,158
spans. That's quite a lot for

514
00:34:37,324 --> 00:34:39,430
a request of adding a new pet.

515
00:34:40,750 --> 00:34:44,220
And we can drill in to see exactly

516
00:34:44,590 --> 00:34:47,500
why that is and what was going on here.

517
00:34:48,430 --> 00:34:51,706
So the first thing I may notice, and I'll

518
00:34:51,738 --> 00:34:56,830
make this a little bigger, but if you are familiar with orms,

519
00:34:58,210 --> 00:35:01,520
then this particular pattern will be

520
00:35:02,070 --> 00:35:03,460
familiar to you.

521
00:35:04,790 --> 00:35:08,930
We have one select statement followed by many select statements,

522
00:35:09,270 --> 00:35:12,754
a longer specific relationship. And this is

523
00:35:12,792 --> 00:35:17,026
usually an indication that there

524
00:35:17,048 --> 00:35:20,758
is a select and plus one issue. And I can kind of go in a

525
00:35:20,764 --> 00:35:24,598
little deeper and actually see what the queries were.

526
00:35:24,684 --> 00:35:28,246
And if I take a look at that, I will see that there

527
00:35:28,268 --> 00:35:31,830
is indeed because of the lazy coding

528
00:35:31,910 --> 00:35:35,274
of the objects, an m plus one issue in here in

529
00:35:35,312 --> 00:35:38,538
dev, it's not that problematic. But you can imagine if

530
00:35:38,544 --> 00:35:41,834
I had a lot of visits, then the problem would

531
00:35:41,872 --> 00:35:46,042
escalate. The next thing you may notice,

532
00:35:46,106 --> 00:35:49,646
and by the way, we can see the same thing around types, which seems

533
00:35:49,668 --> 00:35:52,240
to be also related to the issue that we saw before.

534
00:35:53,190 --> 00:35:57,140
But what I completely missed out on was these

535
00:35:58,950 --> 00:36:02,366
amazing number of HTTP requests

536
00:36:02,398 --> 00:36:04,850
that are also happening here in the background.

537
00:36:06,390 --> 00:36:09,926
And this seems to indicate a problem in the way

538
00:36:09,948 --> 00:36:13,686
that I'm fetching the vaccine data. I would have to

539
00:36:13,708 --> 00:36:17,762
guess that this is kind of a leaky abstraction where I'm accessing

540
00:36:17,906 --> 00:36:21,226
the vaccine error record and I'm not noticing that

541
00:36:21,248 --> 00:36:24,922
it's actually triggering an HTTP call. We can see

542
00:36:24,976 --> 00:36:28,826
more of these crazy queries right around

543
00:36:29,008 --> 00:36:33,022
the types table and the visits table that I've both

544
00:36:33,156 --> 00:36:36,430
highlighted as areas that are problematic.

545
00:36:37,090 --> 00:36:41,054
So as you can see, I was just about ready to check in my

546
00:36:41,092 --> 00:36:44,898
code, but a closer inspection of

547
00:36:44,984 --> 00:36:49,102
the anatomy of a request or what is happening when my code gets handled

548
00:36:49,166 --> 00:36:53,202
shows me that there were a lot of issues just hiding behind

549
00:36:53,256 --> 00:36:56,494
the scenes that are very easy to surface.

550
00:36:56,542 --> 00:37:00,440
If you just are able to take a look at the request as a whole.

551
00:37:00,890 --> 00:37:04,630
Let's take a look at the other operation that I've modified where

552
00:37:04,780 --> 00:37:08,518
I'm actually looking at or rendering

553
00:37:08,534 --> 00:37:11,878
the owner view as well as whether they need a vaccination.

554
00:37:12,054 --> 00:37:15,980
So here again we see the familiar issues with

555
00:37:16,670 --> 00:37:21,270
the select statements around visits and types,

556
00:37:21,430 --> 00:37:25,006
but we also see another antipattern. So this is the

557
00:37:25,028 --> 00:37:28,830
rendering stage. We can see, by the way,

558
00:37:28,900 --> 00:37:32,234
all of this data without having changed our code

559
00:37:32,292 --> 00:37:36,930
almost at all. So all of these come from the built

560
00:37:37,000 --> 00:37:40,574
in support that all of these libraries have for opentelemetry.

561
00:37:40,622 --> 00:37:43,474
So hibernate has, or, sorry,

562
00:37:43,592 --> 00:37:47,842
spring data has support for opentelemetry.

563
00:37:47,906 --> 00:37:51,910
So we automatically get the repository operations.

564
00:37:52,650 --> 00:37:56,466
Here we have the postgres driver,

565
00:37:56,498 --> 00:38:00,306
the JDBC driver, actually reporting the queries.

566
00:38:00,498 --> 00:38:04,134
And here spring itself is reporting that the rendering

567
00:38:04,182 --> 00:38:07,450
phase is happening. And then after that

568
00:38:07,520 --> 00:38:11,530
we can see calls that are being made to my newly added

569
00:38:11,610 --> 00:38:15,022
table, the pet vaccines. And what that

570
00:38:15,076 --> 00:38:18,670
means is that in the view, we're accessing a lazy

571
00:38:20,210 --> 00:38:24,206
reference to an object and triggering

572
00:38:24,238 --> 00:38:27,758
queries during the rendering phase, which is generally considered an anti

573
00:38:27,774 --> 00:38:30,146
pattern called open session and view.

574
00:38:30,328 --> 00:38:34,034
So all of these kind of new

575
00:38:34,072 --> 00:38:37,698
things that I found out about my code I would categorize

576
00:38:37,794 --> 00:38:41,160
as things that are pretty easy to pick up on.

577
00:38:41,770 --> 00:38:45,718
They're not very complex, and you can detect them just by looking

578
00:38:45,804 --> 00:38:49,962
at a single trace. Now the

579
00:38:50,016 --> 00:38:53,610
question is, will this be useful?

580
00:38:55,790 --> 00:38:59,370
So just to be clear, these are the easy things.

581
00:38:59,440 --> 00:39:03,454
We just mentioned three or four different issues here that

582
00:39:03,492 --> 00:39:06,926
are pretty easy to pick up on if you have

583
00:39:06,948 --> 00:39:10,206
the expertise, if you know what you're looking for, and if

584
00:39:10,228 --> 00:39:14,114
you know to look. I'm not talking here at

585
00:39:14,152 --> 00:39:17,922
all yet about these things that would

586
00:39:17,976 --> 00:39:21,620
require more processing to understand. For example,

587
00:39:22,390 --> 00:39:24,020
does this scale well?

588
00:39:27,770 --> 00:39:31,750
Did my changes introduce a regression in terms of the system performance?

589
00:39:32,250 --> 00:39:35,974
Are there any new errors that are happening here behind the scenes that I'm not

590
00:39:36,012 --> 00:39:39,994
seeing? All sorts of things that are not

591
00:39:40,032 --> 00:39:42,950
necessarily manifesting within a single request.

592
00:39:43,110 --> 00:39:46,202
But if I look at a collection of requests, I lights

593
00:39:46,256 --> 00:39:49,818
pick up on them. So they may not be

594
00:39:49,984 --> 00:39:53,106
like, this is just a random trace,

595
00:39:53,238 --> 00:39:56,894
a specific action that I've taken. But it could be that more

596
00:39:56,932 --> 00:40:01,162
interesting things can be picked up by looking at 1000 or 100,000 traces

597
00:40:01,226 --> 00:40:04,930
and seeing the stream of data and what we can

598
00:40:05,000 --> 00:40:08,594
discern from it about the code changes. But for now

599
00:40:08,632 --> 00:40:12,354
on, let's stay in the simple territory. And the truth is that I

600
00:40:12,392 --> 00:40:16,234
took this tool and I took these methods

601
00:40:16,302 --> 00:40:19,734
and I went back to the team and I told them, here you are,

602
00:40:19,772 --> 00:40:23,410
you can go and apply them. The developer that added

603
00:40:23,490 --> 00:40:26,642
the rendering to the console

604
00:40:26,706 --> 00:40:31,914
of how much each iteration of the loop was taking can

605
00:40:31,952 --> 00:40:35,690
now use this, or maybe just add

606
00:40:35,760 --> 00:40:39,542
a few metrics. We didn't talk about metrics. Yet the

607
00:40:39,616 --> 00:40:43,102
developer that didn't see if their code was even running within

608
00:40:43,156 --> 00:40:45,520
the flow can kind of check and see.

609
00:40:46,290 --> 00:40:50,480
And the truth is that nobody used this.

610
00:40:51,410 --> 00:40:56,306
And this is, I think, one of the problems with

611
00:40:56,488 --> 00:41:01,300
what we have today, because sure,

612
00:41:02,630 --> 00:41:05,082
collecting the data is a prerequisite,

613
00:41:05,246 --> 00:41:09,222
but as you recall, the name of this

614
00:41:09,276 --> 00:41:12,934
methodology is continuous feedback. It's not just

615
00:41:13,052 --> 00:41:16,386
feedback, meaning what I've

616
00:41:16,418 --> 00:41:20,342
just demonstrated is manual feedback. It's reactively

617
00:41:20,406 --> 00:41:24,314
going into an equivalent of a dashboards and drilling in

618
00:41:24,352 --> 00:41:27,546
to find issues, which is nice, but the reason it doesn't work

619
00:41:27,648 --> 00:41:31,130
is twofold. And you could kind of see that by

620
00:41:31,280 --> 00:41:35,226
the number of developers who actually use this tool. When I tried to introduce

621
00:41:35,258 --> 00:41:39,022
it, and two developers used it twice, one of them

622
00:41:39,156 --> 00:41:43,214
used it and then saw it highlighted too many issues,

623
00:41:43,412 --> 00:41:46,686
many of which he did not want to fix because they were not related

624
00:41:46,718 --> 00:41:50,658
to him. And eventually it was more painful, more of

625
00:41:50,664 --> 00:41:54,082
a headache than it's worth. The other developer didn't find

626
00:41:54,136 --> 00:41:58,226
anything. He tried again, didn't find anything again. And then he assumed

627
00:41:58,258 --> 00:42:01,526
that by production that means that there are no issues in his

628
00:42:01,548 --> 00:42:05,254
code. So the

629
00:42:05,292 --> 00:42:09,514
problem is, how do we take this information and make

630
00:42:09,552 --> 00:42:12,842
it a part of our dev workflow, make it

631
00:42:12,896 --> 00:42:16,614
continuous. And I'm kind of reminded of tests,

632
00:42:16,742 --> 00:42:20,186
and with tests we kind of face the same issue.

633
00:42:20,288 --> 00:42:23,722
We're testing when they were manual.

634
00:42:23,786 --> 00:42:27,658
And I remember that phase in the DevOps

635
00:42:27,674 --> 00:42:31,486
cycle where there was no DevOps cycle, and we actually had to run

636
00:42:31,508 --> 00:42:35,610
tests manually upon as a preparation for each release.

637
00:42:35,770 --> 00:42:39,106
And no developer wanted to be the one stuck with running the

638
00:42:39,128 --> 00:42:42,738
build of the test, seeing all of the red tests because nobody was maintaining them

639
00:42:42,824 --> 00:42:45,782
and then going to fix them all one by one.

640
00:42:45,836 --> 00:42:48,710
That was a chore that everybody wanted to avoid.

641
00:42:49,290 --> 00:42:52,774
And only when tests became continuous, then we were able

642
00:42:52,812 --> 00:42:57,234
to overcome that barrier and people were kind of internalizing

643
00:42:57,282 --> 00:43:01,306
that. Tests are just a part of what you do when you develop in

644
00:43:01,328 --> 00:43:04,714
the same manner. The question is, how do we get this

645
00:43:04,752 --> 00:43:08,186
data and make it automatic, if you will? Why do I

646
00:43:08,208 --> 00:43:11,594
need to have a developer go and review

647
00:43:11,712 --> 00:43:14,400
these traces and find these issues,

648
00:43:14,770 --> 00:43:18,286
both the ones that are easy to detect and the ones that require me to

649
00:43:18,308 --> 00:43:22,234
do some statistical modeling and anomaly detection and regressions and removing

650
00:43:22,282 --> 00:43:26,290
outliers and so on, to look at a huge number of traces

651
00:43:26,630 --> 00:43:30,114
when we can have some kind of an intelligent agent that does

652
00:43:30,152 --> 00:43:34,014
that. And going back to the original point where we're talking about the changing

653
00:43:34,062 --> 00:43:37,654
landscape, we all are witnessing the

654
00:43:37,692 --> 00:43:41,126
change in generating code and how easy it is to

655
00:43:41,148 --> 00:43:44,434
use copilot or Chachi PT or other technologies to generate

656
00:43:44,482 --> 00:43:48,042
code. But at the same time we can use the same technology

657
00:43:48,176 --> 00:43:51,850
in order to analyze what our code is doing. So we

658
00:43:51,920 --> 00:43:55,210
start getting some feedback back

659
00:43:55,280 --> 00:43:58,890
from it and there are many commercial

660
00:43:59,230 --> 00:44:02,182
tools that are moving in this direction.

661
00:44:02,246 --> 00:44:05,838
Recognizing that this is possible, I'm going to

662
00:44:05,844 --> 00:44:09,294
show you a library that I'm working on and that library is free

663
00:44:09,332 --> 00:44:13,022
for developers, which is why I feel very comfortable showing it to you and

664
00:44:13,076 --> 00:44:16,402
in fact would encourage you to let me know what you think because

665
00:44:16,456 --> 00:44:19,954
it's still under development and something that I think

666
00:44:19,992 --> 00:44:23,086
would benefit from a lot of developer feedback.

667
00:44:23,278 --> 00:44:27,106
So going back to the original code, I'm just going to

668
00:44:27,288 --> 00:44:31,570
repeat these actions that I've just performed.

669
00:44:31,910 --> 00:44:37,178
So we're coding to be adding a new pat and

670
00:44:37,224 --> 00:44:37,820
it,

671
00:44:45,630 --> 00:44:48,922
and then I want to see what

672
00:44:48,976 --> 00:44:52,526
that pet looks like for a specific owner. That's fine.

673
00:44:52,628 --> 00:44:56,478
Now you may notice that in the ide here,

674
00:44:56,564 --> 00:45:00,014
I see a green dot pop up next

675
00:45:00,052 --> 00:45:03,570
to a telescope icon, which is where I can see observability.

676
00:45:03,910 --> 00:45:07,730
So to get to that point, and in fact to

677
00:45:07,880 --> 00:45:11,650
kind of streamline this entire scenario, all I did was

678
00:45:11,720 --> 00:45:15,978
install an intellij plugin, a free one called Digma,

679
00:45:16,094 --> 00:45:19,334
which is the project that I'm working on. So what

680
00:45:19,372 --> 00:45:22,786
Digma does essentially is collect open telemetry

681
00:45:22,818 --> 00:45:26,278
data and analyze it and then show it back to you

682
00:45:26,444 --> 00:45:29,414
based on the analysis that it performs.

683
00:45:29,462 --> 00:45:33,190
Similar to what we just did here when we reviewed the traces,

684
00:45:33,270 --> 00:45:36,490
but also going beyond to look at what happens

685
00:45:36,560 --> 00:45:39,766
across numerous traces. So I've

686
00:45:39,798 --> 00:45:43,582
installed IgMA here in my IDE. This is, by the way,

687
00:45:43,716 --> 00:45:48,106
only supports Java at the moment, but we are expanding to other languages

688
00:45:48,298 --> 00:45:51,886
and immediately what you can see is exactly all of

689
00:45:51,908 --> 00:45:55,634
the different actions that I

690
00:45:55,672 --> 00:45:59,106
just performed. I'm going to move this a little away so that you

691
00:45:59,128 --> 00:46:02,594
can see this better, so we can see all

692
00:46:02,632 --> 00:46:06,382
of these actions that I've performed, the post request,

693
00:46:06,446 --> 00:46:10,214
the get request and so on. And if I go

694
00:46:10,252 --> 00:46:13,526
to the post request for a second and you can see by

695
00:46:13,548 --> 00:46:15,800
the way that there are some issues found here,

696
00:46:17,050 --> 00:46:21,542
I can start seeing a lot of things that are now plain

697
00:46:21,606 --> 00:46:25,274
and obvious and I'm going to make this a little bigger so you guys can

698
00:46:25,312 --> 00:46:28,954
see. But basically it's telling me that there's an

699
00:46:28,992 --> 00:46:32,846
excessive HTTP calls, which is exactly what we saw. We can kind of see

700
00:46:32,868 --> 00:46:36,202
a breakdown of what's going on. And because this is asynchronous,

701
00:46:36,266 --> 00:46:39,518
we actually never noticed that this was taking too long.

702
00:46:39,684 --> 00:46:43,214
But we now can see that DB queries are taking

703
00:46:43,252 --> 00:46:46,530
133 milliseconds, which is quite a lot as well.

704
00:46:46,600 --> 00:46:49,906
But the HTTP clients running in the background and asynchronously are

705
00:46:49,928 --> 00:46:53,266
taking over 7 seconds, which is insane. Of course we

706
00:46:53,288 --> 00:46:57,238
can see what are the bottlenecks and of course it's the mock API that is

707
00:46:57,324 --> 00:47:00,886
slowing me down and also the

708
00:47:00,908 --> 00:47:04,742
call to get the vaccines, which is again, it makes sense.

709
00:47:04,876 --> 00:47:09,030
And then we can actually go and see what's going on with

710
00:47:09,100 --> 00:47:12,886
this n plus one issue. We can see the query that's causing

711
00:47:12,918 --> 00:47:16,570
it, we can see the affected endpoints and we can also

712
00:47:16,640 --> 00:47:20,634
go and see what the trace looks like. And in

713
00:47:20,672 --> 00:47:24,174
that we can actually see these select statements that are

714
00:47:24,212 --> 00:47:27,854
repeating themselves and we can go in a little deeper to

715
00:47:27,892 --> 00:47:31,486
understand exactly where it is happening into trace. So in

716
00:47:31,508 --> 00:47:34,702
fact what we've done is we've inversed the pyramid.

717
00:47:34,846 --> 00:47:37,966
Instead of looking at or sifting

718
00:47:37,998 --> 00:47:42,210
through a lot of traces and logs and metrics, trying to find issues

719
00:47:42,360 --> 00:47:46,046
which is time consuming and reactive, we're doing that automatically

720
00:47:46,078 --> 00:47:49,734
in bringing that data to us so that we can

721
00:47:49,772 --> 00:47:53,206
see in the id exactly what are the

722
00:47:53,228 --> 00:47:57,126
issues. And then if we want to go to the related traces, logs and

723
00:47:57,148 --> 00:48:00,646
metrics or understand more about the impact and who's affected

724
00:48:00,678 --> 00:48:04,474
by it, that's very easy and effortless to

725
00:48:04,512 --> 00:48:07,834
do. At the same time we've also streamlined and removed the whole

726
00:48:07,872 --> 00:48:11,126
kind of boilerplate around enabling open telemetry. So once I've

727
00:48:11,158 --> 00:48:14,318
installed the plugin to collect all of this data, all I need to

728
00:48:14,324 --> 00:48:17,454
do is click enable for observability and

729
00:48:17,492 --> 00:48:21,146
that would start collecting all of that data for me, which is neat

730
00:48:21,178 --> 00:48:24,382
and nice. Now at the same time

731
00:48:24,436 --> 00:48:28,470
I've been collecting information from other sources because opentelemetry

732
00:48:28,490 --> 00:48:33,234
is so easy to use. I also collected information from CI and

733
00:48:33,272 --> 00:48:37,222
I can see some of those results here and they're also

734
00:48:37,276 --> 00:48:40,742
quite intriguing. So for example here we can see

735
00:48:40,796 --> 00:48:44,182
that during my performance test

736
00:48:44,236 --> 00:48:48,166
I've found a scaling issue. So this specific

737
00:48:48,348 --> 00:48:52,282
area of the code is actually scaling badly. And what does that mean?

738
00:48:52,416 --> 00:48:56,314
It means, and this again takes this a step further, to not

739
00:48:56,352 --> 00:49:00,042
only just look at the immediate suspects, which is analyzing traces

740
00:49:00,106 --> 00:49:04,286
and understanding what's wrong there, but this actually looks at

741
00:49:04,388 --> 00:49:08,638
kind of a whole lot of traces and

742
00:49:08,724 --> 00:49:12,734
what the agent was doing here. It was just looking at concurrent

743
00:49:12,782 --> 00:49:16,258
calls and trying to find out whether

744
00:49:16,344 --> 00:49:20,354
whenever this code was called concurrently, whether it

745
00:49:20,392 --> 00:49:23,570
exhibited a degradation in performance and by how much.

746
00:49:23,720 --> 00:49:27,550
So is it scaling linearly? Is it scaling exponentially?

747
00:49:27,630 --> 00:49:30,998
Like what can we figure out here? And I know it's a

748
00:49:31,004 --> 00:49:34,706
little small, but if you can pick that up. Basically what we're

749
00:49:34,738 --> 00:49:38,454
seeing is that there's a constant performance degradation by about 3 seconds

750
00:49:38,502 --> 00:49:42,682
per execution after or when we tested it

751
00:49:42,816 --> 00:49:46,586
at about 31 concurrent calls. And there

752
00:49:46,608 --> 00:49:49,946
is also a root cause that was identified just by studying the

753
00:49:49,968 --> 00:49:54,270
traces, which is the validate owner with external service function.

754
00:49:54,420 --> 00:49:58,286
And we can actually see exactly where the bad scaling is happening,

755
00:49:58,468 --> 00:50:02,238
how that specific function scaling is correlated to the entire

756
00:50:02,324 --> 00:50:05,666
action. We can see a trace again, or we can

757
00:50:05,688 --> 00:50:09,554
go see exactly where that is happening in the code to find

758
00:50:09,592 --> 00:50:13,294
out that yes, this is scaling badly and is also a bottleneck.

759
00:50:13,422 --> 00:50:17,240
So all of these examples are just meant to show you how

760
00:50:17,850 --> 00:50:21,622
where continuous feedback is taking the

761
00:50:21,676 --> 00:50:24,966
observability is not towards

762
00:50:25,148 --> 00:50:28,426
its traditional role of being dashboards pretty as

763
00:50:28,448 --> 00:50:31,754
they are, but how can we actually take them

764
00:50:31,872 --> 00:50:35,382
and include them into the development cycle.

765
00:50:35,446 --> 00:50:40,126
So it actually gives us can opportunity to

766
00:50:40,148 --> 00:50:44,282
improve our code on the one hand to catch issues earlier

767
00:50:44,346 --> 00:50:47,870
in dev or even earlier in test, or earlier before

768
00:50:47,940 --> 00:50:51,738
they manifest to their full degree in production

769
00:50:51,914 --> 00:50:56,222
and get to that level of code ownership very similar to that developer

770
00:50:56,286 --> 00:51:00,226
I was describing, the ten x developer where

771
00:51:00,328 --> 00:51:03,934
we actually know our code and how it behaves,

772
00:51:04,062 --> 00:51:07,202
and we don't need to use our peripheral vision

773
00:51:07,266 --> 00:51:11,122
or spider sense to get those insights.

774
00:51:11,266 --> 00:51:14,978
And I think this is kind of the key takeaway,

775
00:51:15,074 --> 00:51:19,202
which is there is an opportunity here that did not exist

776
00:51:19,266 --> 00:51:22,774
before, in the same way that before we had containers,

777
00:51:22,822 --> 00:51:26,234
we did not have the opportunity to run tests so much and

778
00:51:26,272 --> 00:51:29,942
with such ease, and we had to do config management

779
00:51:30,006 --> 00:51:33,994
and things like that. And today we can use immutable

780
00:51:34,042 --> 00:51:38,026
infrastructure and we don't need to worry about these things. And anybody can include

781
00:51:38,058 --> 00:51:41,694
integration tests very easily into their project. In the

782
00:51:41,732 --> 00:51:45,934
same way, I think today the ability to both collect

783
00:51:45,982 --> 00:51:49,650
data, which is what we saw with open telemetry on the one hand,

784
00:51:49,800 --> 00:51:53,026
but also to analyze it using in

785
00:51:53,048 --> 00:51:56,274
this case data science. Some of it is statistics,

786
00:51:56,322 --> 00:51:59,586
some of it is anomaly detection and analytics.

787
00:51:59,778 --> 00:52:03,590
And different models that we're running here that are very basic,

788
00:52:04,250 --> 00:52:07,906
can still provide so much value so

789
00:52:07,948 --> 00:52:12,090
that we can have a different type of development process

790
00:52:12,160 --> 00:52:15,206
that allows us to shine as developers to assume

791
00:52:15,238 --> 00:52:18,746
more responsibility over our code and to be that

792
00:52:18,848 --> 00:52:22,978
next developer. Now being practicing continuous

793
00:52:23,014 --> 00:52:26,202
feedback myself, I would really appreciate your feedback.

794
00:52:26,266 --> 00:52:29,886
So please do try it. It is free. If you happen to be

795
00:52:29,908 --> 00:52:33,962
using Java, you can just go ahead and pick it up from the intellij

796
00:52:34,026 --> 00:52:38,050
marketplace and let me know what you think. If you are

797
00:52:38,120 --> 00:52:41,614
using a different technology or if you just want to experiment

798
00:52:41,742 --> 00:52:44,886
and not use this specific tool, I would love to hear from

799
00:52:44,908 --> 00:52:48,566
you as well. And that is why I created the

800
00:52:48,588 --> 00:52:52,726
continuous feedback website and you

801
00:52:52,748 --> 00:52:56,230
can find it again@continuousfeedback.org. It's just

802
00:52:56,380 --> 00:53:00,026
a notion page where I set up all of these links that I want to

803
00:53:00,048 --> 00:53:03,254
make sure that people have access to, and it just contains a lot of useful

804
00:53:03,302 --> 00:53:07,610
data. It covers

805
00:53:07,950 --> 00:53:11,194
setting up Otel, collecting observatory data, some tooling.

806
00:53:11,242 --> 00:53:14,414
I've even included an opensource stack of

807
00:53:14,452 --> 00:53:18,186
various tools that you can use, some blog posts on the subject,

808
00:53:18,378 --> 00:53:22,434
my contact details, as well as more

809
00:53:22,472 --> 00:53:25,774
information about the continuous feedback manifesto

810
00:53:25,822 --> 00:53:30,530
that I'm trying to kind of understand with

811
00:53:30,600 --> 00:53:33,714
other folks and kind of phrase it so that

812
00:53:33,752 --> 00:53:37,558
we can kind of understand what it is that we're trying to create here

813
00:53:37,724 --> 00:53:41,478
that is really new and needs a

814
00:53:41,484 --> 00:53:45,240
lot of other minds to consider and think about.

815
00:53:46,090 --> 00:53:50,006
Now, the last thing I want to mention is that I do have a udemy

816
00:53:50,038 --> 00:53:53,834
course that covers these basics as well as some more about how to

817
00:53:53,872 --> 00:53:57,722
enable opentelemetry work with it. What are the

818
00:53:57,776 --> 00:54:01,018
things that you can detect and what are some anti patterns

819
00:54:01,034 --> 00:54:04,030
you should avoid? If you're interested in that,

820
00:54:04,100 --> 00:54:07,840
please email me. My email me is at.

821
00:54:11,090 --> 00:54:15,460
You can email me either at ro ni dover@gmail.com

822
00:54:16,390 --> 00:54:19,854
or my work email which is rd ovr

823
00:54:19,902 --> 00:54:23,346
at digma. Just email me there and I will

824
00:54:23,368 --> 00:54:26,846
gladly send you a coupon with free access to that udemy

825
00:54:26,878 --> 00:54:30,814
course. That's it. It was a pleasure to be hosted

826
00:54:30,862 --> 00:54:34,558
here on con 42 to talk about what is only my favorite

827
00:54:34,654 --> 00:54:38,106
subject in the world, and again, would love

828
00:54:38,128 --> 00:54:39,960
to hear from you and provide more information.

