1
00:00:40,930 --> 00:00:44,486
Welcome to our session about the cloud native configuration. First of

2
00:00:44,508 --> 00:00:48,098
all, we would like to thank comfortitu forks

3
00:00:48,194 --> 00:00:51,806
for letting us introduce you with this topic that

4
00:00:51,828 --> 00:00:55,258
Joachim and I think often overlooked,

5
00:00:55,354 --> 00:00:58,734
and also to thank you for being with us right

6
00:00:58,772 --> 00:01:02,190
now. We know it's always very difficult to choose

7
00:01:02,260 --> 00:01:05,326
a session amongst these numerous topics.

8
00:01:05,438 --> 00:01:09,490
So like we said, in a cloud native context, when we

9
00:01:09,560 --> 00:01:13,234
consider application that are massively distributed, that are

10
00:01:13,272 --> 00:01:16,918
relying on application that are constantly updating, and also

11
00:01:17,004 --> 00:01:21,138
infrastructure that may fail, we need to embrace this uncertainty

12
00:01:21,234 --> 00:01:24,870
and we need to apply patterns in order to

13
00:01:24,940 --> 00:01:28,826
tackle this uncertainty. And configuration is no exception to

14
00:01:28,848 --> 00:01:32,790
that. However, we see that topic overlooked.

15
00:01:32,870 --> 00:01:36,694
And when we talk about cloud native patterns, we are more focused

16
00:01:36,742 --> 00:01:40,794
on services, the relationship between those services and

17
00:01:40,832 --> 00:01:44,954
even the data, but not so much on the configuration. And that's

18
00:01:45,002 --> 00:01:48,750
why we would like to introduce you with a specific

19
00:01:48,900 --> 00:01:52,318
pattern that will help you to think your configuration in a

20
00:01:52,324 --> 00:01:56,318
cloud native context. So first of all, we will introduce

21
00:01:56,414 --> 00:01:59,650
the configuration as a definition not only in the cloud

22
00:01:59,720 --> 00:02:03,394
native public, but also on premise, because both

23
00:02:03,432 --> 00:02:06,626
of which take the same approach,

24
00:02:06,738 --> 00:02:10,246
but we have the same definition but not the same approach. And we

25
00:02:10,268 --> 00:02:14,006
will see why we need a different approach in

26
00:02:14,028 --> 00:02:17,954
a cloud native context. And usually we

27
00:02:18,092 --> 00:02:21,562
meet two different approaches, but they come

28
00:02:21,616 --> 00:02:25,418
with shortage in term of dealing with the specific

29
00:02:25,504 --> 00:02:28,998
challenges on the cloud and we will see what those limits

30
00:02:29,094 --> 00:02:32,654
are and how we can overcome them with a specific

31
00:02:32,772 --> 00:02:36,058
pattern. That is the central point of this session.

32
00:02:36,154 --> 00:02:39,886
Aside from the theory we will introduce you with

33
00:02:40,068 --> 00:02:43,378
practical cases we see, we saw on the field

34
00:02:43,464 --> 00:02:47,010
and also a demo so that you can yourself think

35
00:02:47,080 --> 00:02:50,866
your configuration with inside your own business model.

36
00:02:51,048 --> 00:02:54,622
I am Ismail. I am a cloud developer at Wescale.

37
00:02:54,686 --> 00:02:58,286
And I am Joe Kim, a cloud native developer and coding

38
00:02:58,318 --> 00:03:02,278
architect at Wescale. So at Wescale we are a community

39
00:03:02,444 --> 00:03:05,446
of 50 experts on the cloud.

40
00:03:05,548 --> 00:03:09,114
More than expert, I would say passionate, passionate about what we

41
00:03:09,152 --> 00:03:12,634
do, that is to say, helping clients to think

42
00:03:12,672 --> 00:03:16,778
their business in the cloud. To think from day one where we will

43
00:03:16,864 --> 00:03:20,282
architect the business inside the cloud, but also

44
00:03:20,336 --> 00:03:24,542
to day two when we will help clients already on the cloud to

45
00:03:24,596 --> 00:03:27,806
enhance the existing projects in order to

46
00:03:27,828 --> 00:03:31,022
be more secure, to be more reliable, to be more

47
00:03:31,076 --> 00:03:34,350
available and so on. We are not bound

48
00:03:34,430 --> 00:03:38,354
to any cloud provider nor any tools. And we

49
00:03:38,392 --> 00:03:42,994
think that there is always context to think on.

50
00:03:43,112 --> 00:03:46,806
And usually what we will do is to discuss with

51
00:03:46,828 --> 00:03:51,238
the clients so that we can advise the best platform,

52
00:03:51,324 --> 00:03:54,886
the best tool that we fit your own needs.

53
00:03:54,988 --> 00:03:58,618
And to help this process, we also provide

54
00:03:58,784 --> 00:04:02,522
training on those different tools and

55
00:04:02,656 --> 00:04:05,942
platforms. Let's go back to our main topic,

56
00:04:06,006 --> 00:04:08,646
configuration. What is configuration?

57
00:04:08,758 --> 00:04:12,654
Configuration could be simply defined as the

58
00:04:12,692 --> 00:04:16,206
thing that will change between deploys that

59
00:04:16,228 --> 00:04:19,646
is likely to change, and we distinguish two kind of them.

60
00:04:19,748 --> 00:04:23,726
First one that is under our control, called application configuration,

61
00:04:23,838 --> 00:04:27,778
will tell how the application behaves. Third party services

62
00:04:27,864 --> 00:04:31,246
location. I'll go with them. Configuration feature enabling

63
00:04:31,358 --> 00:04:35,298
the second one is more about how the application is

64
00:04:35,384 --> 00:04:39,030
called IP address port, and this time we are not able

65
00:04:39,100 --> 00:04:42,422
to change it, or usually it's up to the

66
00:04:42,476 --> 00:04:45,634
cloud platform to provide it. Why are we considering

67
00:04:45,682 --> 00:04:48,440
it? Because in the cloud native application,

68
00:04:48,810 --> 00:04:52,478
we in fact deals with hundred if not thousands

69
00:04:52,514 --> 00:04:55,782
of instances. Still, we want this application to behave

70
00:04:55,846 --> 00:04:59,238
as a single logical entity, meaning we want hidden

71
00:04:59,254 --> 00:05:03,302
potency. It does not matter that I call the first instance

72
00:05:03,366 --> 00:05:06,458
or the 42nd one. If I have the same input,

73
00:05:06,554 --> 00:05:10,222
I should get the same result. We see two obstacles to that.

74
00:05:10,276 --> 00:05:13,346
First one is the history of your request, and we

75
00:05:13,368 --> 00:05:17,314
know that providing a stateless application will solve this issue.

76
00:05:17,432 --> 00:05:21,390
Second one is what if my instance

77
00:05:21,550 --> 00:05:25,054
42 contain a different configuration than

78
00:05:25,112 --> 00:05:28,390
the instance one? I won't have the same result

79
00:05:28,460 --> 00:05:31,494
for sure. So the challenge is to

80
00:05:31,532 --> 00:05:35,110
get an automatic way to guarantee that

81
00:05:35,260 --> 00:05:38,546
each spawn instances for a given version

82
00:05:38,658 --> 00:05:42,186
of given application version will spawn with

83
00:05:42,208 --> 00:05:45,594
the right application configuration version. And this

84
00:05:45,632 --> 00:05:49,366
is not possible to consider a semi

85
00:05:49,398 --> 00:05:53,342
automatic ways, because unlike the good old days

86
00:05:53,396 --> 00:05:57,322
when an operator were connecting inside a virtual machine

87
00:05:57,386 --> 00:06:01,226
to upload the right configuration file, now we are dealing

88
00:06:01,258 --> 00:06:04,926
with ephemeral instances and even instances

89
00:06:05,038 --> 00:06:08,882
that we cannot connect to. So usually we can think

90
00:06:08,936 --> 00:06:13,138
two classical approaches. First one, the simplest one, is to

91
00:06:13,224 --> 00:06:16,530
embed inside the artifact that we deploy

92
00:06:16,610 --> 00:06:20,182
the configuration file with its values. That way we are sure

93
00:06:20,236 --> 00:06:24,310
that each instances spawn from this artifact will

94
00:06:24,380 --> 00:06:28,594
get the right configuration. Also, from developer

95
00:06:28,642 --> 00:06:32,634
point of view, it's easy to think that way because we hard

96
00:06:32,672 --> 00:06:36,490
code the values inside the artifact, and also because we have

97
00:06:36,560 --> 00:06:40,362
a central model of your configuration. And it's easy

98
00:06:40,416 --> 00:06:44,670
to think that way because it gives you a mean to know what

99
00:06:44,820 --> 00:06:48,570
your application needs to start. But from the operator

100
00:06:48,650 --> 00:06:51,966
point of view, we now have an artifact that

101
00:06:51,988 --> 00:06:55,902
is linked to an environment. The artifact meant

102
00:06:55,966 --> 00:06:59,586
for the dev environment won't be able to be deployed on the

103
00:06:59,608 --> 00:07:02,994
staging environment, so we break any kind

104
00:07:03,032 --> 00:07:06,518
of traceability between deployments, and also we break the trust

105
00:07:06,604 --> 00:07:10,262
between a developer and an operator, because we will

106
00:07:10,316 --> 00:07:14,294
fall into the problem of it works on my machine. So we

107
00:07:14,332 --> 00:07:17,794
need to reconciliate those two words and

108
00:07:17,932 --> 00:07:21,194
providing a single artifact would help.

109
00:07:21,312 --> 00:07:24,970
Twelve factor app with a third factor tells you to store

110
00:07:25,040 --> 00:07:28,774
the configuration inside the environment more precisely

111
00:07:28,902 --> 00:07:33,194
and how we see it implemented is to store the values

112
00:07:33,242 --> 00:07:37,054
of the configuration inside environment variable so

113
00:07:37,092 --> 00:07:40,494
that the application code

114
00:07:40,612 --> 00:07:44,514
could consume it. Problem is, although we have a

115
00:07:44,552 --> 00:07:48,686
single artifact now, we directly consume

116
00:07:48,798 --> 00:07:53,010
the environment variable and also we have a code

117
00:07:53,080 --> 00:07:57,394
that is spread with get of course, and prevent

118
00:07:57,442 --> 00:08:01,602
your developer to have a single logical view of your configuration.

119
00:08:01,746 --> 00:08:05,554
We need a third path, and the configuration layer pattern

120
00:08:05,682 --> 00:08:09,546
is this path. In this model, we have a single

121
00:08:09,648 --> 00:08:13,434
artifact that embeds a configuration model

122
00:08:13,552 --> 00:08:17,322
without its values. And values will be stored inside

123
00:08:17,376 --> 00:08:20,554
the environment. It would be up to the configuration

124
00:08:20,602 --> 00:08:24,174
layer to one, expose the values to

125
00:08:24,212 --> 00:08:27,866
the application and two, fetch those value previously

126
00:08:27,898 --> 00:08:31,706
to exposing fetch those values from the environment.

127
00:08:31,898 --> 00:08:36,002
So this is what we describe here we have the

128
00:08:36,136 --> 00:08:39,540
templates that represent our configuration model

129
00:08:39,910 --> 00:08:42,994
and whether it is deployed inside the

130
00:08:43,032 --> 00:08:46,390
first environment. A second one, it will have

131
00:08:46,460 --> 00:08:50,066
different inject, render different values.

132
00:08:50,178 --> 00:08:54,226
So now we have an applications that is protected from its environment.

133
00:08:54,338 --> 00:08:58,570
We do not consume it directly. We see that the

134
00:08:58,640 --> 00:09:02,346
configuration layers act as a single point of

135
00:09:02,368 --> 00:09:06,470
truth for the configuration values, and also the configuration

136
00:09:06,550 --> 00:09:11,046
layer is in charge to fetch the data that

137
00:09:11,088 --> 00:09:14,494
will constitute the configuration values. So we have to

138
00:09:14,532 --> 00:09:18,010
keep in mind that the configuration layer is conceptual.

139
00:09:18,090 --> 00:09:21,854
It's not a technology, it's more an association of libraries and

140
00:09:21,892 --> 00:09:25,314
patterns. If we talk about libraries, we know that we

141
00:09:25,352 --> 00:09:28,962
would have different kind of libraries according to the ecosystem we consider.

142
00:09:29,096 --> 00:09:32,930
And in this term we know that we can have

143
00:09:33,000 --> 00:09:36,930
different kind level of work to produce in order to implement

144
00:09:37,010 --> 00:09:41,122
configuration layer. So we saw the theory,

145
00:09:41,186 --> 00:09:44,870
now let's see the practice, in particular how

146
00:09:44,940 --> 00:09:48,246
to expose values to the configuration layer.

147
00:09:48,358 --> 00:09:52,070
We can expose it as always with environment variables,

148
00:09:52,150 --> 00:09:56,022
but we can also provide values through web servers

149
00:09:56,086 --> 00:09:59,702
that the configuration layer will be in charge to request

150
00:09:59,846 --> 00:10:03,530
and get value from. In particular, we have

151
00:10:03,600 --> 00:10:07,246
this technology printlock configuration that will expose you a

152
00:10:07,268 --> 00:10:10,970
web application, and under the hood it will be able to fetch

153
00:10:11,050 --> 00:10:15,342
data from different data store, whether it be a git repository,

154
00:10:15,406 --> 00:10:19,250
a blob store and a vault. For instance, note that

155
00:10:19,400 --> 00:10:23,262
the application foo here represented by this container,

156
00:10:23,326 --> 00:10:26,542
kubernetes pod, won't be able to communicate directly

157
00:10:26,606 --> 00:10:29,878
from with this environment nor with

158
00:10:29,964 --> 00:10:33,942
the web server. It's only the configuration layer that will

159
00:10:33,996 --> 00:10:37,582
serve as a single point of truth for the configuration failures,

160
00:10:37,666 --> 00:10:41,462
and we can see the configuration layer as a configuration

161
00:10:41,526 --> 00:10:45,546
gateway. In that sense, the previous example does not

162
00:10:45,728 --> 00:10:49,302
shows you how to fetch those values.

163
00:10:49,366 --> 00:10:52,842
It's more about how to store the configuration values.

164
00:10:52,906 --> 00:10:57,114
And with the client we implemented in a PHP ecosystem

165
00:10:57,242 --> 00:11:00,974
this pattern with the following initial situation.

166
00:11:01,092 --> 00:11:05,118
We had an application repository that were deployed

167
00:11:05,214 --> 00:11:09,362
through a sync operation on a non premise environment on

168
00:11:09,416 --> 00:11:13,214
a given server. Configuration was not embedded inside this repo,

169
00:11:13,262 --> 00:11:17,246
it was embedded inside a second repo that contained

170
00:11:17,358 --> 00:11:20,946
every configuration of all the applications of

171
00:11:20,968 --> 00:11:24,614
the clients applications. And the deployment process

172
00:11:24,732 --> 00:11:28,794
was taking into account the two deployments, the first the

173
00:11:28,832 --> 00:11:32,810
application code, and the second one the configuration repo, and doing

174
00:11:32,880 --> 00:11:36,474
the symbolic link, creating the symbolic link

175
00:11:36,592 --> 00:11:40,654
with the right files. So one obvious problem that

176
00:11:40,772 --> 00:11:43,806
was that we were exposing too much information.

177
00:11:43,988 --> 00:11:48,026
And second, we had no way as a developer

178
00:11:48,138 --> 00:11:52,158
to know the model of the configuration unless we have access

179
00:11:52,244 --> 00:11:55,442
to this configuration repo. So our first point was

180
00:11:55,496 --> 00:11:58,814
to implement a CI CD pipeline to replace

181
00:11:58,862 --> 00:12:02,206
the in house CLI tool that was in charge

182
00:12:02,238 --> 00:12:06,466
of the synchronization with the server, and also the creation

183
00:12:06,498 --> 00:12:09,846
of symbolic link to the configuration file. And what we

184
00:12:09,868 --> 00:12:13,686
can notice is that inside a pipeline environment we

185
00:12:13,708 --> 00:12:17,390
can do everything we want. In particular we can implement

186
00:12:17,490 --> 00:12:21,242
this concept of configuration layer. So first

187
00:12:21,296 --> 00:12:25,446
point was to set the template of the configuration

188
00:12:25,558 --> 00:12:28,794
inside the source code. This way we can,

189
00:12:28,912 --> 00:12:33,246
inside the pipeline environment, render it with

190
00:12:33,348 --> 00:12:36,586
the environment values that we provided.

191
00:12:36,698 --> 00:12:40,094
How? Thanks to a of file that

192
00:12:40,132 --> 00:12:43,554
we fetched from spring cloud config web

193
00:12:43,592 --> 00:12:47,186
server. And then a rendering process was in

194
00:12:47,208 --> 00:12:50,850
charge to set the values inside the template. And finally

195
00:12:51,000 --> 00:12:54,274
we managed these configuration files with the

196
00:12:54,312 --> 00:12:57,938
PHP files inside the final artifacts

197
00:12:58,034 --> 00:13:00,754
that we deployed on the environment.

198
00:13:00,882 --> 00:13:05,106
So we still have the drawbacks

199
00:13:05,218 --> 00:13:09,350
to produce packages that are related to a given environment.

200
00:13:09,430 --> 00:13:13,702
But we saw that we now have the configuration

201
00:13:13,766 --> 00:13:17,366
layer concept inside the pipeline environment,

202
00:13:17,478 --> 00:13:21,054
and we think that we can move this

203
00:13:21,092 --> 00:13:24,654
logic inside the true platform that in

204
00:13:24,692 --> 00:13:27,674
our case was fortunately kubernetes,

205
00:13:27,802 --> 00:13:31,866
into which we defined a ninit container

206
00:13:32,058 --> 00:13:36,014
into which we implemented a logic of fetching

207
00:13:36,142 --> 00:13:40,082
the values from the environment, and also

208
00:13:40,216 --> 00:13:43,826
the same spring cloud config server in order to

209
00:13:43,848 --> 00:13:47,574
render the template that was exposed inside the

210
00:13:47,612 --> 00:13:51,394
configuration volume. Once this staging

211
00:13:51,442 --> 00:13:55,062
was done, the application was allowed to start

212
00:13:55,196 --> 00:13:58,554
with the right configuration. So we can say that we can

213
00:13:58,592 --> 00:14:03,158
see that configuration layer is more about implementing

214
00:14:03,254 --> 00:14:06,666
the right tool and associating it with

215
00:14:06,688 --> 00:14:10,606
the right platform. And in theory it's accessible to

216
00:14:10,708 --> 00:14:14,474
every kind of ecosystem. But we may say that it's

217
00:14:14,522 --> 00:14:18,330
too much manual works and maybe it exists

218
00:14:18,410 --> 00:14:22,542
some libraries that will do the work anyway. And with

219
00:14:22,596 --> 00:14:26,146
Drakim we think that light bend is this kind

220
00:14:26,168 --> 00:14:30,334
of library that was not thought at the beginning as a configuration

221
00:14:30,382 --> 00:14:33,666
layer technology, but which is very adapted to

222
00:14:33,688 --> 00:14:36,902
the cases we just described. So now we will

223
00:14:36,956 --> 00:14:40,150
see an example with lightbane configuration

224
00:14:40,490 --> 00:14:44,230
about how to implement our

225
00:14:44,380 --> 00:14:48,250
three layers of configuration. Lightbane config is

226
00:14:48,400 --> 00:14:52,054
Java library that you can use in Java,

227
00:14:52,182 --> 00:14:55,878
Scala, Kotlin, etc. All JVM

228
00:14:55,974 --> 00:14:59,580
languages. It's a new configuration format at the same time,

229
00:15:00,030 --> 00:15:03,578
so it describes the Hokon format

230
00:15:03,674 --> 00:15:07,114
that is close to JSON. It is compatible with JSON.

231
00:15:07,162 --> 00:15:10,702
If you have a valid JSON, you have a valid hook on. But it comes

232
00:15:10,756 --> 00:15:14,030
with a lot of interesting failures,

233
00:15:14,190 --> 00:15:17,566
like the order of definitions that matters.

234
00:15:17,678 --> 00:15:21,854
Temporal units to make clear temporal

235
00:15:21,902 --> 00:15:25,830
values, like 30 seconds it is typed,

236
00:15:26,250 --> 00:15:30,630
so it's a real object like JSON configuration.

237
00:15:31,050 --> 00:15:35,240
And you may have references and

238
00:15:36,250 --> 00:15:39,606
a central entry point for all

239
00:15:39,628 --> 00:15:43,438
your configuration. Because once you ask Lightband

240
00:15:43,474 --> 00:15:47,462
config to load your configuration, all configuration

241
00:15:47,526 --> 00:15:51,262
files, system properties from the JVM and

242
00:15:51,396 --> 00:15:55,022
environment variable are visible in the same place

243
00:15:55,156 --> 00:15:58,954
in the config object. You can still separate

244
00:15:59,002 --> 00:16:02,634
your configuration file to keep the separation of concern and

245
00:16:02,692 --> 00:16:06,782
have only one entry point with includes,

246
00:16:06,926 --> 00:16:10,926
and we'll see how the standard orchestration of loading

247
00:16:10,958 --> 00:16:14,414
and merging will allow us to build three layers

248
00:16:14,462 --> 00:16:18,086
of configuration. For our first layer, we will use

249
00:16:18,188 --> 00:16:22,406
standard behavior of Laban config, that is the

250
00:16:22,508 --> 00:16:26,562
automatic loading of all files that are named reference

251
00:16:26,626 --> 00:16:30,022
conf at the root of the class pass. They are concatenated

252
00:16:30,086 --> 00:16:34,342
merged. So it's very important to have your own namespace

253
00:16:34,486 --> 00:16:38,714
to avoid conflict. But it's very useful because if

254
00:16:38,752 --> 00:16:42,714
you have a library, you will use this file

255
00:16:42,762 --> 00:16:46,814
to validate your config structure because you will have

256
00:16:46,852 --> 00:16:50,186
inside the full configuration with default values. If it's

257
00:16:50,218 --> 00:16:53,694
an application, we won't have all the structure,

258
00:16:53,742 --> 00:16:56,930
but only default values. Mandatory values

259
00:16:57,510 --> 00:16:59,860
without default won't be here,

260
00:17:00,470 --> 00:17:04,702
and the application will still access the configuration

261
00:17:04,766 --> 00:17:08,530
through the configuration layer that is the library config library

262
00:17:08,610 --> 00:17:13,030
here. Then our second layer will

263
00:17:13,100 --> 00:17:16,774
have another file, applicationfix.com,

264
00:17:16,972 --> 00:17:20,158
that will be load programmatically as a fullback

265
00:17:20,194 --> 00:17:23,354
configuration for the third layer that

266
00:17:23,392 --> 00:17:28,070
we will see later. But because reference

267
00:17:28,150 --> 00:17:31,870
conf is always low priority, because it's always

268
00:17:31,940 --> 00:17:35,166
default values, the application fixed conf will

269
00:17:35,268 --> 00:17:38,922
contain values that can overwrite some default

270
00:17:39,066 --> 00:17:42,254
and some values that can complete what is

271
00:17:42,292 --> 00:17:45,842
missing in reference. Typically you will put in this

272
00:17:45,896 --> 00:17:50,574
file, you will put algorithm parameters, business parameters,

273
00:17:50,702 --> 00:17:54,354
everything that is tied to the behavior of one

274
00:17:54,392 --> 00:17:57,586
version of your artifact and this file, very important,

275
00:17:57,688 --> 00:18:00,786
like the reference, it will be inside your artifact.

276
00:18:00,898 --> 00:18:06,166
So it will be shipped with your applications if

277
00:18:06,188 --> 00:18:09,986
you want in the docker image,

278
00:18:10,018 --> 00:18:13,802
but the preference inside the jar itself because

279
00:18:13,856 --> 00:18:17,306
it is tied to a version of your application. All that

280
00:18:17,328 --> 00:18:21,322
is inside will not vary depending on the environment,

281
00:18:21,466 --> 00:18:25,418
but for more flexibility you can already include

282
00:18:25,514 --> 00:18:29,422
references to environment variables. Then our

283
00:18:29,556 --> 00:18:34,434
third layer will be the application runtime.com

284
00:18:34,472 --> 00:18:37,860
file, this one.

285
00:18:39,510 --> 00:18:44,290
For this one we will profit from standard

286
00:18:44,360 --> 00:18:48,466
behavior of Lisben config. You can specify

287
00:18:48,658 --> 00:18:51,862
a path or a URL for this

288
00:18:51,916 --> 00:18:55,234
file as a system properties. That is, when you launch

289
00:18:55,282 --> 00:18:59,606
your JVM, you can specify uppercase

290
00:18:59,638 --> 00:19:03,082
d flags that are system properties and one of them

291
00:19:03,136 --> 00:19:07,606
will be the path of the configuration file.

292
00:19:07,798 --> 00:19:12,006
That will allow us to write a code without a specific reference

293
00:19:12,038 --> 00:19:15,678
to this file. And this is very important that we don't have a

294
00:19:15,684 --> 00:19:19,566
specific reference to this file because it comes from

295
00:19:19,588 --> 00:19:23,630
the environment. In our example it will be on an external,

296
00:19:24,070 --> 00:19:28,050
external disk, it will be mount like volume inside

297
00:19:28,120 --> 00:19:31,538
our container. But you may put it on a

298
00:19:31,544 --> 00:19:34,946
config server and specify it as

299
00:19:34,968 --> 00:19:38,802
a URL. And basically we will put inside

300
00:19:38,936 --> 00:19:42,082
everything that depends on the environment.

301
00:19:42,226 --> 00:19:46,034
You can put hostname ports,

302
00:19:46,162 --> 00:19:49,706
sizing parameters, technical parameters, depending on

303
00:19:49,728 --> 00:19:53,450
the environment or arguments that you

304
00:19:53,600 --> 00:19:56,906
would pass to your application to specialize the

305
00:19:56,928 --> 00:20:00,862
instance. Then we'll see how to implement it.

306
00:20:00,996 --> 00:20:04,320
So I will show you scalar application.

307
00:20:05,410 --> 00:20:09,914
What do we have here? Here we have the reference

308
00:20:10,042 --> 00:20:14,002
confile. So because it's an application I will but only

309
00:20:14,136 --> 00:20:17,794
default values. And here you can see

310
00:20:17,832 --> 00:20:21,582
what you can do with lightband config,

311
00:20:21,726 --> 00:20:25,354
especially hocon formats. It's like JSON,

312
00:20:25,422 --> 00:20:29,490
but you can use dot syntax to avoid

313
00:20:29,570 --> 00:20:33,154
using a cascade of curly braces.

314
00:20:33,282 --> 00:20:36,710
For example, this namespace is equivalent in

315
00:20:36,860 --> 00:20:40,370
JSON format of config. Demo object inside the scratchpad,

316
00:20:40,450 --> 00:20:43,930
object inside the j arrow object

317
00:20:44,000 --> 00:20:47,450
inside object. But you can shorten it.

318
00:20:47,520 --> 00:20:50,294
You have an application name that is fixed,

319
00:20:50,342 --> 00:20:53,886
it's a default value. It's okay. You have an instance id that

320
00:20:53,908 --> 00:20:57,502
is defined only if the hostname variable is defined because

321
00:20:57,556 --> 00:21:01,134
of the question mark. If the hostname variable is not

322
00:21:01,172 --> 00:21:04,834
defined, instance id won't be defined. And for

323
00:21:04,872 --> 00:21:08,274
this example we decide to imagine that our

324
00:21:08,312 --> 00:21:12,222
applications is consuming and producing messages

325
00:21:12,286 --> 00:21:16,746
on the Kafka cluster. So we want to structure

326
00:21:16,878 --> 00:21:20,770
our Kafka configuration. We put a default,

327
00:21:20,930 --> 00:21:25,126
we have a consumer configuration object with the

328
00:21:25,308 --> 00:21:28,598
default session timeout. We have some default

329
00:21:28,774 --> 00:21:32,554
producer parameters. And so let's say

330
00:21:32,592 --> 00:21:37,194
that these default parameters makes the application works

331
00:21:37,392 --> 00:21:41,086
nearly everywhere except if you want to override it

332
00:21:41,108 --> 00:21:46,190
for specific use case. So these

333
00:21:46,260 --> 00:21:49,806
are default values. Then in the same

334
00:21:49,908 --> 00:21:54,180
jar we will have applications.com.

335
00:21:55,030 --> 00:21:58,420
So here the example, very simple.

336
00:21:58,950 --> 00:22:03,246
I don't have any business example values, but let's

337
00:22:03,278 --> 00:22:07,814
imagine that all

338
00:22:07,852 --> 00:22:11,618
those variables are tied to the application version,

339
00:22:11,794 --> 00:22:15,110
so we want to redefine the application name.

340
00:22:15,260 --> 00:22:18,678
So this line overrides the one in the config

341
00:22:18,774 --> 00:22:20,410
reference confile,

342
00:22:21,710 --> 00:22:24,874
but only if the up name environment variable is

343
00:22:24,912 --> 00:22:29,974
defined. We add another environment

344
00:22:30,022 --> 00:22:33,614
variable for instances id. So if osname isn't here it

345
00:22:33,652 --> 00:22:37,406
will try instance id because the definition are read in

346
00:22:37,428 --> 00:22:41,566
order. So the last one will override the first one and

347
00:22:41,588 --> 00:22:45,346
then we add the group id for the consumer group

348
00:22:45,448 --> 00:22:48,926
and we add a client id for message production.

349
00:22:49,038 --> 00:22:52,734
And we decide that for example the consumer

350
00:22:52,782 --> 00:22:56,598
group is linked to the application

351
00:22:56,764 --> 00:23:00,946
name. Here it's a reference to the upname attribute

352
00:23:01,138 --> 00:23:04,354
because all instance

353
00:23:04,402 --> 00:23:08,954
of the application will be in the same consumer group, and because each

354
00:23:09,152 --> 00:23:12,310
instance of the application will have its own producer.

355
00:23:12,390 --> 00:23:16,426
I create client id name from the app

356
00:23:16,448 --> 00:23:19,866
name and the instance id. So you may have

357
00:23:19,888 --> 00:23:23,214
noticed that the instance id is not always here because for

358
00:23:23,252 --> 00:23:26,650
now we define it only if some environment

359
00:23:26,730 --> 00:23:30,800
variable are here. That means that if we start our application

360
00:23:31,170 --> 00:23:35,534
with no environment variable, this reference won't

361
00:23:35,582 --> 00:23:39,346
work and lightband config will throw an

362
00:23:39,368 --> 00:23:42,962
exception and so the application won't start. That's exactly

363
00:23:43,016 --> 00:23:47,202
what we want. If the configuration is not consistent,

364
00:23:47,346 --> 00:23:51,574
we won't start. Another file is

365
00:23:51,772 --> 00:23:55,122
outside our application. This is the configuration

366
00:23:55,186 --> 00:23:59,298
file we pass at start time. This is application runtime

367
00:23:59,394 --> 00:24:03,354
conf. So here you will find some attributes that

368
00:24:03,392 --> 00:24:08,090
will be merged inside the Kafka consumer structure.

369
00:24:08,670 --> 00:24:12,542
The host names the port

370
00:24:12,596 --> 00:24:16,874
number, and for this example we decide to keep the default

371
00:24:16,922 --> 00:24:20,078
port. But in a real example you may want to

372
00:24:20,164 --> 00:24:23,906
put a reference to another element variable or a fixed number.

373
00:24:24,008 --> 00:24:27,566
And here I copy the bootstrap server

374
00:24:27,598 --> 00:24:31,470
array from consumer to the producer bootstrap server

375
00:24:31,550 --> 00:24:35,086
attribute because I consume and produce on the same

376
00:24:35,128 --> 00:24:38,262
cluster. So here we see all

377
00:24:38,396 --> 00:24:42,226
features of lightband config

378
00:24:42,338 --> 00:24:45,766
and we will see how it is cloud in

379
00:24:45,868 --> 00:24:49,386
our application. So it is very simple, it loads the

380
00:24:49,408 --> 00:24:53,146
configuration, display it, and then that's all. The first interesting

381
00:24:53,248 --> 00:24:56,954
line is this one. So with

382
00:24:56,992 --> 00:25:00,974
this line you will cloud reference conf, you will

383
00:25:01,012 --> 00:25:04,842
load the application runtime.com, the applicationfig

384
00:25:04,906 --> 00:25:09,134
conf, and everything will be overridden with

385
00:25:09,252 --> 00:25:13,182
JVM system properties. Because this is convention

386
00:25:13,246 --> 00:25:15,090
in lightband config.

387
00:25:16,070 --> 00:25:19,602
The load method will load the reference conf.

388
00:25:19,656 --> 00:25:23,250
It's mandatory, it will always be done. And because

389
00:25:23,320 --> 00:25:27,266
we don't specify a path for the config file,

390
00:25:27,378 --> 00:25:30,870
it will use the system properties that specify

391
00:25:31,370 --> 00:25:34,738
the path or the URL of the default file config.

392
00:25:34,914 --> 00:25:38,234
That is for us a path that point to a

393
00:25:38,272 --> 00:25:42,154
volume that is mounted and with a

394
00:25:42,192 --> 00:25:46,090
specific name. Application runtime conf

395
00:25:46,240 --> 00:25:49,814
and as we said in slide about layer two,

396
00:25:49,952 --> 00:25:53,166
we won't define the application fix conf that

397
00:25:53,188 --> 00:25:57,130
is inside the application jar as a fallback. So because reference

398
00:25:57,210 --> 00:26:01,658
Comf is always low priority, even with fallback,

399
00:26:01,754 --> 00:26:05,166
the reference conf will be used after a while.

400
00:26:05,348 --> 00:26:09,300
So here we have applicationaroundtime.com that is

401
00:26:09,670 --> 00:26:14,226
high priority. Then if

402
00:26:14,248 --> 00:26:19,266
we don't find our variable inside this

403
00:26:19,368 --> 00:26:23,110
application runtime.com file, we will look into

404
00:26:23,260 --> 00:26:27,462
the applicationfix.com and then if you don't find

405
00:26:27,596 --> 00:26:32,540
variable inside this file, we will look inside reference.

406
00:26:33,070 --> 00:26:37,110
And because JVM system properties are overriding

407
00:26:37,190 --> 00:26:40,286
everything, they are very interesting to

408
00:26:40,308 --> 00:26:44,586
be used for overriding some values of the configuration

409
00:26:44,698 --> 00:26:48,862
at launch time. It's very interesting. So here

410
00:26:48,996 --> 00:26:52,682
we display the configuration and we map it then

411
00:26:52,756 --> 00:26:56,260
here to configuration to a configuration model.

412
00:26:56,710 --> 00:27:00,194
Lightbane is advising us to

413
00:27:00,232 --> 00:27:03,554
always have an object model for our configuration and

414
00:27:03,592 --> 00:27:07,414
map it to the file. Why? Because it

415
00:27:07,452 --> 00:27:11,286
will make the code using simple objects that

416
00:27:11,308 --> 00:27:13,510
are safe without side effects.

417
00:27:15,050 --> 00:27:18,410
And so once the configuration is load and validated,

418
00:27:18,750 --> 00:27:23,062
your application can start without any risk

419
00:27:23,126 --> 00:27:27,066
of inconsistency in the configuration. That's very important. So here,

420
00:27:27,168 --> 00:27:30,498
because we are in scalar, we are using scalar.

421
00:27:30,694 --> 00:27:34,810
The pure config library is mapping automatically

422
00:27:34,970 --> 00:27:39,150
the file structure to my model. So we'll see quickly

423
00:27:39,300 --> 00:27:42,970
how the model is done.

424
00:27:43,140 --> 00:27:47,426
So here you

425
00:27:47,448 --> 00:27:51,598
can see that it is like the file

426
00:27:51,694 --> 00:27:55,890
with up name and instance id. KFC configuration

427
00:27:55,970 --> 00:27:59,526
at the first level. Then inside KfK configuration we have

428
00:27:59,548 --> 00:28:02,310
the consumer configuration, the producer configuration.

429
00:28:03,210 --> 00:28:07,254
Then we have the bootstrap servers that are inside an

430
00:28:07,292 --> 00:28:11,114
array. And if occurrence of the each

431
00:28:11,152 --> 00:28:14,678
occurrence of the array is a host per instance,

432
00:28:14,774 --> 00:28:18,300
with a host and a port, my model is

433
00:28:18,990 --> 00:28:22,478
tightly linked to the file structure and that's very important

434
00:28:22,564 --> 00:28:25,678
for validation and for our application.

435
00:28:25,844 --> 00:28:30,026
So our application, not only the application is loading

436
00:28:30,218 --> 00:28:34,542
the configuration from only one entry

437
00:28:34,606 --> 00:28:39,666
point, it is mapped to a model so

438
00:28:39,688 --> 00:28:44,722
that the configuration became totally transparent and

439
00:28:44,776 --> 00:28:48,162
without any complicated

440
00:28:48,226 --> 00:28:52,166
method or inconsistent method like

441
00:28:52,348 --> 00:28:56,200
call to get off. Check if

442
00:28:57,050 --> 00:29:00,330
the variable is defined,

443
00:29:01,070 --> 00:29:05,402
check the type at runtime at the time the

444
00:29:05,456 --> 00:29:06,700
variable is used.

445
00:29:08,430 --> 00:29:12,254
All those things have been checked just before. So I will

446
00:29:12,452 --> 00:29:14,960
show you a run of your application.

447
00:29:15,570 --> 00:29:23,046
So I should be in the docker directory.

448
00:29:23,178 --> 00:29:26,386
I will show you the docker file quickly to

449
00:29:26,408 --> 00:29:29,634
understand how it is done. How here you see

450
00:29:29,672 --> 00:29:33,860
that I'm using system property

451
00:29:34,890 --> 00:29:38,546
to specify the path. So the config path

452
00:29:38,578 --> 00:29:42,818
will point to a config directory. That is the volumes

453
00:29:42,834 --> 00:29:46,566
that we will and config file that is

454
00:29:46,668 --> 00:29:48,520
application runtime.com.

455
00:29:51,210 --> 00:29:55,066
Then I will run my application with a script that

456
00:29:55,088 --> 00:29:58,794
will launch docker. And on this line you see

457
00:29:58,832 --> 00:30:02,910
that I am using a host directory to mount

458
00:30:03,410 --> 00:30:08,330
a configuration volume inside my container.

459
00:30:08,490 --> 00:30:12,586
So I can put everything that

460
00:30:12,628 --> 00:30:16,610
is depending on the environment

461
00:30:17,910 --> 00:30:23,570
in the host directory. And what

462
00:30:23,640 --> 00:30:27,880
we are going to get is this.

463
00:30:28,330 --> 00:30:32,790
So we have a lot of things here because I activated

464
00:30:33,290 --> 00:30:36,806
a kind of debug display so that we

465
00:30:36,828 --> 00:30:39,974
can understand how the failures are merged.

466
00:30:40,102 --> 00:30:44,486
So for example have here our original

467
00:30:44,678 --> 00:30:48,186
namespace. Then we have comments from the

468
00:30:48,208 --> 00:30:51,510
lightband config libraries that are telling us that

469
00:30:51,600 --> 00:30:55,434
application name is coming from the line two of the reference confile.

470
00:30:55,482 --> 00:30:59,454
So no app name of our own variable was here. So the

471
00:30:59,492 --> 00:31:02,670
default app name has been kept,

472
00:31:03,430 --> 00:31:07,198
the instance id has been defined, so we can deduce

473
00:31:07,214 --> 00:31:10,926
that another variable defines it defined

474
00:31:10,958 --> 00:31:14,126
it. And in this case this is a hostname

475
00:31:14,158 --> 00:31:17,800
variable that is defined to the container id.

476
00:31:18,330 --> 00:31:22,114
Then the Kafka structure has been merged

477
00:31:22,162 --> 00:31:25,542
from a lot of files you may notice to run

478
00:31:25,596 --> 00:31:28,650
application runtime comf, applications conf

479
00:31:28,720 --> 00:31:32,202
and the reference conf. And if

480
00:31:32,256 --> 00:31:36,582
we go deeper into this structure, we can see that each variable

481
00:31:36,646 --> 00:31:40,486
has an origin, some coming from application runtime.com,

482
00:31:40,608 --> 00:31:43,246
some coming from reference conf.

483
00:31:43,428 --> 00:31:47,434
So everything is exactly what we expected.

484
00:31:47,562 --> 00:31:52,320
We have only one big configuration for

485
00:31:53,270 --> 00:31:57,762
all files, even if the

486
00:31:57,816 --> 00:32:01,090
application configuration, our artifact, was not complete,

487
00:32:01,240 --> 00:32:05,194
and even if we specified the configuration,

488
00:32:05,342 --> 00:32:09,170
the last part of the configuration at the last minute,

489
00:32:09,330 --> 00:32:13,506
and the result is here we have a display

490
00:32:13,538 --> 00:32:17,850
of our configuration model. So I hope it was

491
00:32:17,920 --> 00:32:21,306
clear for you. And I write an

492
00:32:21,328 --> 00:32:25,446
article about Liband configuration on blog.

493
00:32:25,558 --> 00:32:30,358
Ismail wrote about the

494
00:32:30,384 --> 00:32:34,506
configuration in the cloud on the same blog. And then I can't

495
00:32:34,538 --> 00:32:38,378
let you go without saying that we are hiring.

496
00:32:38,474 --> 00:32:42,094
So if you are interested about what

497
00:32:42,132 --> 00:32:45,806
we are doing, if you are passionate, you can join

498
00:32:45,838 --> 00:32:49,394
us. And the new things is that we are

499
00:32:49,592 --> 00:32:54,126
creating a new remote agency. So if you are not near Paris

500
00:32:54,238 --> 00:32:58,114
or near Nance, you still can join

501
00:32:58,162 --> 00:33:01,542
us from all around France in this

502
00:33:01,596 --> 00:33:06,114
new remote agency. That's all folks, thank you for your attention.

503
00:33:06,242 --> 00:33:09,842
Thank you for everything. And we hope that this session

504
00:33:09,906 --> 00:33:13,170
will inspire you to apply this new pattern

505
00:33:13,250 --> 00:33:16,454
or this pattern you already know on your own

506
00:33:16,492 --> 00:33:20,046
business context. And we also hope to see you on

507
00:33:20,108 --> 00:33:23,790
the Discord channel so that we can further discuss

508
00:33:23,940 --> 00:33:26,540
about these topics. See you, see you.

