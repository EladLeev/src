1
00:01:42,210 --> 00:01:45,498
Hello and welcome to this talk about contract driven development.

2
00:01:45,674 --> 00:01:49,594
We're going to be talking about deploying your microservices independently without integration

3
00:01:49,642 --> 00:01:53,258
testing. My name is Hari Krishnan. I'm a consultant and a coach.

4
00:01:53,354 --> 00:01:57,802
I help both unicorn startups and enterprises with their transformation

5
00:01:57,866 --> 00:02:01,166
activities. My interests include distributed systems and

6
00:02:01,188 --> 00:02:04,994
high performance application architectures, and these are some of the conferences

7
00:02:05,082 --> 00:02:08,694
I speak often at. Let's start

8
00:02:08,732 --> 00:02:12,070
off with some context setting on the topic. Why do we really need

9
00:02:12,140 --> 00:02:15,298
contract driven development? Let's say we're

10
00:02:15,314 --> 00:02:19,334
building a mobile application that requests data from a back end and

11
00:02:19,372 --> 00:02:22,986
then displays the same the application requesting the data is

12
00:02:23,008 --> 00:02:26,666
the consumer and the application responding with the data. Let's call

13
00:02:26,688 --> 00:02:30,346
it the provider. Now, with the terminology out of the way, let's look at

14
00:02:30,368 --> 00:02:33,854
how we would go about building the consumer. Now. One way is to wait

15
00:02:33,892 --> 00:02:36,782
for the dependency, which is the actual provider application,

16
00:02:36,916 --> 00:02:40,126
to become available as a reference so that then we can build it

17
00:02:40,148 --> 00:02:43,774
out against it. However, this is not very production because

18
00:02:43,812 --> 00:02:47,538
it's a sequential style of development. So usual practice would be to

19
00:02:47,544 --> 00:02:51,026
stand up a mock server to emulate the provider so that the

20
00:02:51,048 --> 00:02:54,286
consumer application development can progress independent

21
00:02:54,318 --> 00:02:57,686
of whether the provider itself is actually built or not.

22
00:02:57,868 --> 00:03:01,522
While this looks good on paper, there is a fundamental flaw with this approach,

23
00:03:01,666 --> 00:03:05,686
which is the mock server need not be truly representative of

24
00:03:05,708 --> 00:03:09,226
the real provider. By which I mean as a

25
00:03:09,248 --> 00:03:13,130
consumer application developer, I may wrongly assume that I could send

26
00:03:13,200 --> 00:03:16,858
the id as a string wherein the actual provider application

27
00:03:16,944 --> 00:03:20,406
may be expecting an integer, and likewise the provider

28
00:03:20,438 --> 00:03:24,286
may be responding with the name and SKu of the product, while I may

29
00:03:24,308 --> 00:03:27,422
be wrongly assuming that I'd be getting the name and the price.

30
00:03:27,556 --> 00:03:31,822
Now what does it all lead to? When we deploy these applications together,

31
00:03:31,956 --> 00:03:35,954
there is going to be broken integration, and such issues are not really easy

32
00:03:35,992 --> 00:03:39,954
to find on our local environment for the consumer application developer like

33
00:03:39,992 --> 00:03:43,634
we saw, and also in the continuous integration environment, because we

34
00:03:43,672 --> 00:03:47,322
might pretty much be leveraging the same hand rolled stub.

35
00:03:47,406 --> 00:03:51,410
Right? And for the provider there is no emulation of the consumer,

36
00:03:51,490 --> 00:03:54,726
so thereby even provider application development is also happening in

37
00:03:54,748 --> 00:03:58,566
isolation. Now when you put these two applications together in an environment

38
00:03:58,598 --> 00:04:01,866
such as integration testing, that's when you realize there is

39
00:04:01,888 --> 00:04:05,558
a compatibility issue. Now this first of all compromises

40
00:04:05,654 --> 00:04:09,046
your integration testing environment, and worse,

41
00:04:09,158 --> 00:04:12,714
if at all, you have a break from integration

42
00:04:12,762 --> 00:04:15,898
testing and these issues do happen to make it to production

43
00:04:16,074 --> 00:04:19,374
ends up in creating incidents which we do not like,

44
00:04:19,492 --> 00:04:22,926
right? And because these issues are usually found on the right

45
00:04:22,948 --> 00:04:26,740
hand side much later in the cycle they're also quite expensive to fix.

46
00:04:27,190 --> 00:04:30,206
Wouldn't it be nice to prevent such incidents

47
00:04:30,238 --> 00:04:33,790
from happening altogether and to be able to identify such compatibility

48
00:04:33,870 --> 00:04:38,066
issues very much on the left hand side. What do we want to achieve?

49
00:04:38,178 --> 00:04:41,782
We'd like to shift left and identify compatibility issues

50
00:04:41,916 --> 00:04:44,870
without really integration testing applications.

51
00:04:46,490 --> 00:04:49,866
Now one way of solving this problem could be to

52
00:04:49,888 --> 00:04:53,546
reduce the ambiguity in communication between the teams so that there are

53
00:04:53,568 --> 00:04:57,162
no assumptions which can lead to problems, right? So putting

54
00:04:57,216 --> 00:05:01,078
it down in an industry standard specification such as OpenAPI

55
00:05:01,174 --> 00:05:05,066
or WSTL is a good way of governing both application development

56
00:05:05,098 --> 00:05:09,486
on the consumer side and provider side, so that you have the

57
00:05:09,508 --> 00:05:13,314
two applications talking to each other well when they are deployed together.

58
00:05:13,512 --> 00:05:17,138
However, do you think just having an API specification standard

59
00:05:17,224 --> 00:05:20,834
or adopting one solves your problem? That we are

60
00:05:20,872 --> 00:05:23,810
trying to look for a solution?

61
00:05:24,150 --> 00:05:28,022
Not necessarily. API specifications in themselves are just

62
00:05:28,076 --> 00:05:31,814
describing what the API looks like. It is up to us

63
00:05:31,852 --> 00:05:35,286
how we enforce these API specifications on the

64
00:05:35,308 --> 00:05:38,890
application development itself. And that's where the difference

65
00:05:38,960 --> 00:05:42,374
is between API specifications and executable contracts.

66
00:05:42,502 --> 00:05:46,406
What we'd like to achieve is to be able to take API specifications

67
00:05:46,518 --> 00:05:49,882
and treat them like executable contracts. Now that's exactly

68
00:05:49,936 --> 00:05:53,374
what specmatic is able to do. Specmatic is a tool

69
00:05:53,412 --> 00:05:57,290
which can read your open API specification or WSDL specification

70
00:05:57,450 --> 00:06:01,146
and then convert that and make it available as a contractor

71
00:06:01,178 --> 00:06:04,386
stub server for your consumer application so that you

72
00:06:04,408 --> 00:06:08,046
can independently continue on the development of the consumer

73
00:06:08,078 --> 00:06:11,602
application. This stub is significantly different

74
00:06:11,736 --> 00:06:15,454
in comparison to handrolled stubs because it is truly representative

75
00:06:15,502 --> 00:06:19,746
of the provider, because it is based off of the mutually agreed

76
00:06:19,778 --> 00:06:23,202
upon API specification. Now we have to keep the equation

77
00:06:23,266 --> 00:06:27,806
balanced on the provider side also. So for which specmatic

78
00:06:27,858 --> 00:06:31,542
is able to convert your API specification into contract

79
00:06:31,606 --> 00:06:35,594
as test and make sure that it is verifying that the

80
00:06:35,632 --> 00:06:38,970
provider is adhering to the contract also.

81
00:06:39,120 --> 00:06:43,226
Now with this you are able to independently develop both consumer

82
00:06:43,258 --> 00:06:47,246
and provider applications while still being sure that when you deploy them

83
00:06:47,268 --> 00:06:50,894
together, they will work well with each other.

84
00:06:51,092 --> 00:06:54,674
Now let's take a look at a live demo of

85
00:06:54,712 --> 00:06:57,780
what this will look like on the provider side.

86
00:06:58,230 --> 00:07:01,794
Let's say I have this API specification and then

87
00:07:01,832 --> 00:07:05,298
I have the system under test, which is the provider itself.

88
00:07:05,464 --> 00:07:09,046
Now I'd like to be able to test if the provider application is

89
00:07:09,068 --> 00:07:12,694
in line with the API specification. What I'm going to do is

90
00:07:12,732 --> 00:07:16,082
take specmatic, leverage the API specifications

91
00:07:16,146 --> 00:07:19,626
as contract as test, and then verify if

92
00:07:19,648 --> 00:07:23,466
the provider is able to match up.

93
00:07:23,568 --> 00:07:27,322
So for this, I'm quickly going to show you

94
00:07:27,376 --> 00:07:30,814
an example of an API specification. I have a

95
00:07:30,852 --> 00:07:35,402
typical e commerce like open API specification

96
00:07:35,466 --> 00:07:39,230
here. It's got a bunch of paths with products

97
00:07:39,300 --> 00:07:43,680
and orders, and on each of these paths it's got multiple operations to

98
00:07:44,050 --> 00:07:47,726
support crud operations for a product or an order. And it's

99
00:07:47,758 --> 00:07:51,534
also detailing out the schema in terms of what are the type of values

100
00:07:51,582 --> 00:07:55,182
you can support and whatnot. So that's typically

101
00:07:55,246 --> 00:07:58,662
this API specification. And then I also have this

102
00:07:58,716 --> 00:08:03,126
application here which says the

103
00:08:03,148 --> 00:08:06,646
team is claiming that they have completed building this application and it

104
00:08:06,668 --> 00:08:10,214
should be able to support all the operations that we saw in the API

105
00:08:10,262 --> 00:08:13,466
specification itself. Now how, as a person who

106
00:08:13,488 --> 00:08:16,746
is supposed to be responsible for this application going live in

107
00:08:16,768 --> 00:08:20,854
production, that this is indeed adhering to the specification

108
00:08:20,902 --> 00:08:24,890
we saw earlier. So what I'm going to do now is leverage

109
00:08:24,970 --> 00:08:28,318
specmatic to take the API specification and run

110
00:08:28,404 --> 00:08:32,262
it as a test. So what I have here as a basic

111
00:08:32,426 --> 00:08:35,874
setup is I'm using Specmatic's junit support while

112
00:08:35,912 --> 00:08:40,206
I am using the junit support within a Java springboard application Kotlin

113
00:08:40,238 --> 00:08:44,094
application. Specmatic itself is language

114
00:08:44,142 --> 00:08:47,862
agnostic and platform agnostic. You could use it from a command line.

115
00:08:47,916 --> 00:08:51,474
Also, it's just an executable, but for the purpose of convenience,

116
00:08:51,522 --> 00:08:54,914
I have this junit support extension here and then some plumbing

117
00:08:54,962 --> 00:08:58,434
to start and stop the app and the coordinates

118
00:08:58,482 --> 00:09:01,546
of where the app itself is running so that Specmatic can hit it.

119
00:09:01,648 --> 00:09:05,770
Now, how does Specmatic know where to pull the API specifications from?

120
00:09:05,920 --> 00:09:09,866
That's where this JSON configuration comes in. I've directly pointed it

121
00:09:09,888 --> 00:09:14,054
to one of the git repositories where I'm adopting the API specifications

122
00:09:14,102 --> 00:09:17,310
which we saw on the swagger editor. Now with this,

123
00:09:17,380 --> 00:09:20,926
let's actually run the test. And what you

124
00:09:20,948 --> 00:09:24,414
will notice is a bunch of tests getting generated

125
00:09:24,462 --> 00:09:28,034
and run against your application without you having to write any

126
00:09:28,072 --> 00:09:30,740
line of code. And this is all I have done.

127
00:09:31,350 --> 00:09:34,030
And you notice we got twelve tests,

128
00:09:34,190 --> 00:09:37,374
right? That's money for nothing and tests for free.

129
00:09:37,432 --> 00:09:41,046
Who doesn't want free tests, right? And let's actually analyze what

130
00:09:41,068 --> 00:09:44,694
these tests are actually doing. Let's take the first one for example.

131
00:09:44,732 --> 00:09:47,734
It says fetch product details response okay,

132
00:09:47,852 --> 00:09:52,118
get products. Now if you recollect the gaps specification,

133
00:09:52,294 --> 00:09:55,626
the first operation, if you remember, is a get operation on

134
00:09:55,648 --> 00:09:59,222
the path products and its fetch product details. So Specmatic

135
00:09:59,286 --> 00:10:03,446
was able to convert each of these operations inside your open API specification into

136
00:10:03,488 --> 00:10:06,814
a test scenario and run it. Now what did it do?

137
00:10:06,932 --> 00:10:11,038
It generated a request based off of the API specifications. It knew that

138
00:10:11,124 --> 00:10:14,962
there is a URL called products and there's an id and that

139
00:10:15,016 --> 00:10:18,594
id is supposed to be number. So this

140
00:10:18,792 --> 00:10:22,558
specmatic kind of went ahead and generated a value which is adheres

141
00:10:22,574 --> 00:10:26,150
to the specimen. And then when the response came back from the

142
00:10:26,220 --> 00:10:29,814
application, it verified that this is indeed in line

143
00:10:29,852 --> 00:10:34,280
with the schema that is expected from the actual

144
00:10:34,890 --> 00:10:37,954
API specification itself. So thereby the tests are green.

145
00:10:38,092 --> 00:10:41,978
Now that's great. Obviously it's good news that the application

146
00:10:42,064 --> 00:10:45,446
is in line with the API specification, but that's

147
00:10:45,478 --> 00:10:48,986
not necessarily the reality for most of

148
00:10:49,008 --> 00:10:52,466
us, right? Incidents do not happen in the happy path scenarios.

149
00:10:52,518 --> 00:10:55,950
Incidents are hiding in the places that we are not looking for them,

150
00:10:56,020 --> 00:11:00,318
right? So let's throw a curveball at this whole application.

151
00:11:00,484 --> 00:11:03,914
So what I'm going to do is I have this quick snippet

152
00:11:03,962 --> 00:11:07,202
here called specmatic generative test.

153
00:11:07,256 --> 00:11:10,686
I'm going to paste that in and say specmatic,

154
00:11:10,878 --> 00:11:14,274
I want you to do some extra testing on this application and see if there

155
00:11:14,312 --> 00:11:18,334
are any loopholes beyond what you have already verified.

156
00:11:18,462 --> 00:11:21,846
So right now you're saying twelve tests. Just hold on to that number in your

157
00:11:21,868 --> 00:11:24,822
head and let's rerun the test and see what happens.

158
00:11:24,876 --> 00:11:28,566
Now the interesting

159
00:11:28,668 --> 00:11:32,230
bit here is we want to test boundary conditions.

160
00:11:32,310 --> 00:11:35,962
Correct? The happy path is when you expect given

161
00:11:36,016 --> 00:11:39,706
a we are just checking, right? We are not really deploying. What are

162
00:11:39,728 --> 00:11:43,158
the possibilities? We just checked so far, but this time around we are going

163
00:11:43,184 --> 00:11:46,686
to be deploying what are the boundaries of the application itself.

164
00:11:46,868 --> 00:11:50,494
Now this time around you have 26 tests, which is a lot

165
00:11:50,532 --> 00:11:54,114
more than twelve, and only 16 of them passed, which means we also have test

166
00:11:54,152 --> 00:11:57,794
failures. Now. Now that's interesting. Let's take

167
00:11:57,832 --> 00:12:01,666
a look at and analyze what these scenarios are

168
00:12:01,688 --> 00:12:05,326
like. So earlier you saw only scenario I did not have positive

169
00:12:05,358 --> 00:12:09,106
or negative. Now you have labeling. It says this scenario is a

170
00:12:09,128 --> 00:12:12,406
positive scenario and this one said negative and the negative one

171
00:12:12,428 --> 00:12:15,080
is what failed. So let's take a look at it.

172
00:12:15,850 --> 00:12:19,738
So on the negative scenarios, the first one I'm looking at the

173
00:12:19,824 --> 00:12:23,926
error we see here. Oh my, it's a 500 internal server

174
00:12:23,958 --> 00:12:28,262
error. Now how did that happen? It looks like specmatic

175
00:12:28,326 --> 00:12:31,882
tried to send a null for a value that is not

176
00:12:31,936 --> 00:12:35,198
supposed to be null according to the API specification. Right.

177
00:12:35,364 --> 00:12:39,146
Now, what would have been ideal is if the application had done a null

178
00:12:39,178 --> 00:12:43,230
check and then responded with an appropriate four to two or a 400.

179
00:12:43,380 --> 00:12:46,818
But then there is no null check in the application, which is evident here.

180
00:12:46,904 --> 00:12:50,162
And the application instead threw a 500,

181
00:12:50,296 --> 00:12:53,986
which is not desirable. This could easily have become an incident in

182
00:12:54,008 --> 00:12:57,426
production. But lucky for us, we have specmatic and we

183
00:12:57,448 --> 00:13:01,266
were able to identify it right here and we can now fix it. Now isn't

184
00:13:01,298 --> 00:13:04,422
this awesome that I did not have to write any line of code

185
00:13:04,556 --> 00:13:08,106
and I have so much ability to both verify the

186
00:13:08,128 --> 00:13:11,850
positive and the boundary conditions for an application all with just

187
00:13:11,920 --> 00:13:15,846
open API specification. Okay, now that we've

188
00:13:15,878 --> 00:13:19,478
seen the power of OpenAPI specifications

189
00:13:19,574 --> 00:13:23,486
and specmatic and how it is able to leverage it

190
00:13:23,588 --> 00:13:27,374
on the provider side, let's switch gears and look at how this

191
00:13:27,412 --> 00:13:31,550
can help the consumer side of the equation.

192
00:13:32,210 --> 00:13:35,906
So let's again look at a quick demo here. What I

193
00:13:35,928 --> 00:13:39,774
have is an API specification

194
00:13:39,902 --> 00:13:43,234
called Products Yaml. This is a fairly straightforward one.

195
00:13:43,352 --> 00:13:47,426
This is not even like 30 40 lines, which is fairly

196
00:13:47,458 --> 00:13:51,158
straightforward for any small application.

197
00:13:51,324 --> 00:13:55,062
All it says is I have a path called get products and

198
00:13:55,116 --> 00:13:59,206
given an id, it gives me back a product for

199
00:13:59,228 --> 00:14:02,650
that particular id which has the name and the SKU.

200
00:14:03,230 --> 00:14:06,426
Now this is all I have to start off with and I need to build

201
00:14:06,448 --> 00:14:10,186
a mobile application. Now how do I go about my

202
00:14:10,208 --> 00:14:13,566
business? So first thing obviously is I want to play around with

203
00:14:13,588 --> 00:14:17,006
this API and see what values I get. So what I have done here

204
00:14:17,028 --> 00:14:20,526
is I've imported it into Postman and I have

205
00:14:20,708 --> 00:14:24,314
pretty much the ability to do that because Postman

206
00:14:24,362 --> 00:14:27,682
recognizes open API and I've got it in. The next step

207
00:14:27,736 --> 00:14:31,134
is I need to have a stop server, right? One option is to hand roll

208
00:14:31,182 --> 00:14:35,534
it. I could just hard code some values in a block

209
00:14:35,582 --> 00:14:39,126
or a record and replay service, but why will I do that? I have

210
00:14:39,148 --> 00:14:42,838
the ability to use specmatic. So what I'm going to do is

211
00:14:43,004 --> 00:14:47,046
start a new terminal and I'm going to say go

212
00:14:47,068 --> 00:14:50,246
into this folder called smartmocks where we have this file

213
00:14:50,278 --> 00:14:53,286
lying around. I'm going to say specmatic,

214
00:14:53,478 --> 00:14:57,370
stop this file called products Yaml.

215
00:14:58,110 --> 00:15:01,966
And that's pretty much all it says. Hey, there is this

216
00:15:01,988 --> 00:15:05,406
server called 9000 running on localhost and

217
00:15:05,508 --> 00:15:09,422
we have a step server going. So what does this mean? Let's actually

218
00:15:09,476 --> 00:15:13,134
take a look. Let's try sending a value. I just have

219
00:15:13,172 --> 00:15:16,898
some random number and I send the

220
00:15:16,984 --> 00:15:20,894
request and I get back a response, which is a name under an SKU magic,

221
00:15:21,022 --> 00:15:24,338
right? And this is specmatic doing the job for us.

222
00:15:24,424 --> 00:15:27,974
And every time I send a different value, or just send the same

223
00:15:28,012 --> 00:15:31,154
value, it gives me different responses for the name and the sku.

224
00:15:31,282 --> 00:15:36,262
Now this is happening because specmatic is able to guess

225
00:15:36,396 --> 00:15:39,962
what data it is supposed to respond with based off of the

226
00:15:40,016 --> 00:15:43,466
schema which we saw earlier which said both name and

227
00:15:43,488 --> 00:15:47,046
SKU are strings and so thereby specmatic is generating values

228
00:15:47,078 --> 00:15:50,582
within that boundary. Now usually this is not useful.

229
00:15:50,646 --> 00:15:54,522
As a mobile application developer or a client application developer,

230
00:15:54,666 --> 00:15:57,918
I would want specific values. Like for example,

231
00:15:58,084 --> 00:16:01,326
I want for one, I want a particular book to

232
00:16:01,348 --> 00:16:03,966
come back to me. So I'm going to say one.

233
00:16:04,148 --> 00:16:07,714
And magically specmatic gave me back the name mythical man month

234
00:16:07,832 --> 00:16:10,820
and the sk for that book. Now how did this happen?

235
00:16:11,190 --> 00:16:15,042
What we did here is, if you notice there is a folder called products

236
00:16:15,176 --> 00:16:18,882
underscore data which has a convention based

237
00:16:18,936 --> 00:16:22,214
naming here which is based off of the products. Yaml I just

238
00:16:22,252 --> 00:16:25,778
have underscore data. Now under that I can have as many jsons

239
00:16:25,794 --> 00:16:29,610
as I want and each json is basically a request response pair.

240
00:16:30,750 --> 00:16:34,394
Excuse me, what I've done here is for the

241
00:16:34,432 --> 00:16:38,042
product id one I want to return mythical manment and

242
00:16:38,096 --> 00:16:41,486
this status code and whatnot. Now thereby I'm able

243
00:16:41,508 --> 00:16:45,486
to get back this information. Now let's actually see

244
00:16:45,588 --> 00:16:49,118
if we can fool specmatic right? Now. The issue

245
00:16:49,204 --> 00:16:53,066
earlier, which we noticed was that as the mobile application developer,

246
00:16:53,098 --> 00:16:56,658
I was wrongly assuming that the server is going to

247
00:16:56,664 --> 00:17:00,238
be giving me name and price and not name and Sku.

248
00:17:00,334 --> 00:17:04,050
And I was going to say name and SkU, sorry, name and price

249
00:17:04,120 --> 00:17:07,846
is basically this $10 for this book, for example.

250
00:17:08,028 --> 00:17:11,506
And now let's take a look at what happened. The stub server

251
00:17:11,538 --> 00:17:14,630
running picked up this file change and then

252
00:17:14,700 --> 00:17:17,702
said error, right?

253
00:17:17,756 --> 00:17:21,698
And it says in scenario get products key

254
00:17:21,724 --> 00:17:25,318
name price in the stub server was not part of the contract.

255
00:17:25,494 --> 00:17:28,934
Now that's very helpful for me, right? Because I would have otherwise wrongly

256
00:17:28,982 --> 00:17:32,734
assumed and set up my stubbing incorrectly. And maybe

257
00:17:32,772 --> 00:17:37,230
this would have turned out to be a production incident. But instead what

258
00:17:37,300 --> 00:17:40,634
now happened is I am completely safeguarded

259
00:17:40,682 --> 00:17:44,062
as an engineer from making any wrong assumptions because

260
00:17:44,116 --> 00:17:47,666
every time I make a mistake, hey, specmatic is

261
00:17:47,688 --> 00:17:50,514
able to point me, hey, this is not the right value.

262
00:17:50,632 --> 00:17:54,066
You should probably be adhering to the specification and only if

263
00:17:54,088 --> 00:17:58,054
you go back to saying SKU and give

264
00:17:58,092 --> 00:18:01,702
any value which can be any string right within

265
00:18:01,756 --> 00:18:05,094
that format. And now it's going to be fine and this error will

266
00:18:05,132 --> 00:18:08,694
magically go away. Now that's why we call

267
00:18:08,732 --> 00:18:12,586
this smart mocks. And now when you

268
00:18:12,608 --> 00:18:15,802
go back to your postman, then I send the request again.

269
00:18:15,856 --> 00:18:19,578
This time you get back any string. So now that we've seen both sides of

270
00:18:19,584 --> 00:18:23,882
the equation for the consumer and the provider,

271
00:18:24,026 --> 00:18:27,914
let's actually look at the anatomy of a test for the consumer

272
00:18:27,962 --> 00:18:31,742
itself. Now typically for a component tests. Your system

273
00:18:31,796 --> 00:18:35,034
under test needs to be isolated from its dependencies,

274
00:18:35,082 --> 00:18:39,154
and that's where specmatic comes in to provide your smart block. And for

275
00:18:39,192 --> 00:18:43,042
a component test, there are three parts to it. Any test to that matter

276
00:18:43,096 --> 00:18:46,686
has arrange act assert, which is the standard set of steps,

277
00:18:46,798 --> 00:18:50,374
and during the arrange step, just like you would use any tool, like in

278
00:18:50,412 --> 00:18:53,874
unit testing, like Mokito. Here you are testing an API,

279
00:18:53,922 --> 00:18:57,970
so thereby you're setting up an expectation at the API level with Specmatic.

280
00:18:58,130 --> 00:19:01,978
You saw how I set up the expectation with a

281
00:19:01,984 --> 00:19:06,214
JSON file, but you could also do this over an HTTP endpoint

282
00:19:06,262 --> 00:19:10,006
if you were to dynamically if you want to set it up dynamically at

283
00:19:10,048 --> 00:19:13,242
runtime. Now specmatic thoroughly verifies

284
00:19:13,306 --> 00:19:17,786
this expectation against the open API and only then stores

285
00:19:17,818 --> 00:19:19,390
it into its local storage.

286
00:19:20,610 --> 00:19:24,030
And then your component test can invoke the actual

287
00:19:24,100 --> 00:19:27,886
system under test. And in turn the system under test interacts

288
00:19:27,918 --> 00:19:31,374
with specmatic stuff server and specmatic stuff server

289
00:19:31,422 --> 00:19:35,022
looks up if it has any corresponding data based on the expectation,

290
00:19:35,166 --> 00:19:38,982
or it will generate some random data and give it back to the system

291
00:19:39,036 --> 00:19:42,886
under test, and which in turn returns to the test, and the test asserts if

292
00:19:42,908 --> 00:19:47,000
the response is good. Now if you look at this setup, this is

293
00:19:47,550 --> 00:19:51,466
very helpful to isolate the system under test while still

294
00:19:51,568 --> 00:19:55,894
being sure that you are emulating the provider fairly

295
00:19:55,942 --> 00:19:59,466
well. Otherwise, now that we've seen both sides of the

296
00:19:59,488 --> 00:20:02,974
story for the consumer and the provider in terms of how we could use

297
00:20:03,012 --> 00:20:06,394
contract as test and contract was stub server, let's block at backward

298
00:20:06,442 --> 00:20:10,126
compatibility. Compatibility issues begin to

299
00:20:10,148 --> 00:20:14,154
grow a lot more with API evolution and now API production

300
00:20:14,202 --> 00:20:17,966
is natural, right? We want to be able to add ensures. The difficulty,

301
00:20:17,998 --> 00:20:21,502
however, is when you are adding a new capability to an API

302
00:20:21,646 --> 00:20:24,942
for supporting a newer consumer or a client or a new feature,

303
00:20:25,086 --> 00:20:28,130
existing consumers and clients can potentially

304
00:20:28,290 --> 00:20:32,146
become incompatible. And that's where it might be helpful

305
00:20:32,258 --> 00:20:36,162
if you could just take a contract and another version of the same contract

306
00:20:36,226 --> 00:20:39,330
and just verify it and say, are these two compatible?

307
00:20:39,410 --> 00:20:42,554
That would be a nice experiment to run, right?

308
00:20:42,592 --> 00:20:46,138
Without really getting into a situation where you have to make the changes on

309
00:20:46,224 --> 00:20:50,138
the consumer and the provider applications deploy it, and only then realize that they

310
00:20:50,144 --> 00:20:54,094
are not compatible. Let's take a look at a live

311
00:20:54,132 --> 00:20:57,918
demo of this sort of comparison. So let's take a

312
00:20:57,924 --> 00:21:01,790
look at a popQuest. Which of these changes are backward compatible

313
00:21:02,290 --> 00:21:05,940
in a request? If I add a mandatory or a required field,

314
00:21:06,550 --> 00:21:10,770
is that change a backward compatible change to the API?

315
00:21:11,590 --> 00:21:15,702
Now this is a fairly straightforward answer because it's easy to guess,

316
00:21:15,756 --> 00:21:19,026
right? Because if you add a new parameter to the request,

317
00:21:19,138 --> 00:21:21,960
obviously existing clients will not be able to send it,

318
00:21:22,890 --> 00:21:25,954
and thereby it is a backward

319
00:21:26,002 --> 00:21:29,106
incompatible change. Now why take my word for it?

320
00:21:29,148 --> 00:21:32,234
Let's actually test this out. So I'm going to kill

321
00:21:32,272 --> 00:21:36,474
this subserver which was running before. I'm going to go back and

322
00:21:36,592 --> 00:21:39,770
go into this folder called backward compatibility.

323
00:21:40,110 --> 00:21:43,454
And what I have here are two

324
00:21:43,492 --> 00:21:46,894
files, products v one, products v two.

325
00:21:47,092 --> 00:21:50,714
At this point both of these files are pretty much identical,

326
00:21:50,842 --> 00:21:54,942
and they have this one operation wherein you can create a production by

327
00:21:54,996 --> 00:21:58,606
posting product details. And by now we are quite familiar

328
00:21:58,638 --> 00:22:02,114
with what the product has, right? It's got a name and an SKU of

329
00:22:02,152 --> 00:22:06,082
which only name is required. SKU is optional and then

330
00:22:06,216 --> 00:22:09,954
in response it gives you the id of the product. Let's assume

331
00:22:10,002 --> 00:22:13,126
this is the API we have to work with, and we need

332
00:22:13,148 --> 00:22:16,534
to understand if these two are backward compatible. So obviously

333
00:22:16,652 --> 00:22:19,898
before we make changes, we want to make sure that we are starting on a

334
00:22:19,904 --> 00:22:24,150
clean slate. So I'm going to say specmatic compare

335
00:22:24,310 --> 00:22:27,580
products v one with products v two.

336
00:22:29,070 --> 00:22:31,950
And when I do that, you will notice,

337
00:22:37,730 --> 00:22:41,710
my bad, I did not put the extension

338
00:22:42,370 --> 00:22:45,934
then yes, the newer contract is backward

339
00:22:45,982 --> 00:22:49,602
compatible. Now for the change that we saw in the block quiz, right,

340
00:22:49,656 --> 00:22:53,806
which is basically if I add a new parameter,

341
00:22:53,918 --> 00:22:57,414
if I add a parameter which is required. So the quick one

342
00:22:57,452 --> 00:23:01,494
to do here is maybe I will make SKu also

343
00:23:01,692 --> 00:23:05,686
mandatory. Now if I do this, what is

344
00:23:05,708 --> 00:23:09,394
going to happen? I'm going to run the compare command

345
00:23:09,442 --> 00:23:12,954
again, and this time around, you see this issue, right? It says

346
00:23:12,992 --> 00:23:16,538
new contract expects key named SkU in the request, but it

347
00:23:16,544 --> 00:23:19,834
is missing from the older contract, and therefore new

348
00:23:19,872 --> 00:23:23,486
contract is not backward compatible. Okay, so that just

349
00:23:23,508 --> 00:23:29,130
proves what we already guessed. That's not really very groundbreaking,

350
00:23:29,210 --> 00:23:32,918
earth shattering. Let's look at something more complex.

351
00:23:33,114 --> 00:23:36,386
What if I change an optional nullable field to

352
00:23:36,408 --> 00:23:40,318
an optional non nullable field? Let me repeat

353
00:23:40,334 --> 00:23:44,020
it. An optional nullable field to an optional non nullable field.

354
00:23:44,890 --> 00:23:48,854
Let's actually look at it with an example, right? So it's easier to

355
00:23:49,052 --> 00:23:52,822
process. We are back to square one here.

356
00:23:52,876 --> 00:23:56,680
Both contracts are compatible. And you will notice in

357
00:23:58,030 --> 00:24:02,218
the v one SKU is the optional field

358
00:24:02,384 --> 00:24:05,946
and it is nullable. Now what I'm going to do is,

359
00:24:06,048 --> 00:24:09,766
according to the quiz question, going to take the optional

360
00:24:09,798 --> 00:24:13,274
nullable field and make it optional non

361
00:24:13,322 --> 00:24:17,134
nullable. Now this is not

362
00:24:17,172 --> 00:24:20,798
straightforward to process in order to guess whether it's going to

363
00:24:20,804 --> 00:24:23,742
be backward compatibility, breaking change or not,

364
00:24:23,876 --> 00:24:27,406
because there are at least three or four permutation communication.

365
00:24:27,598 --> 00:24:30,894
So let's try and check what happens. And this time specmatic

366
00:24:30,942 --> 00:24:34,142
says, hey, this is a string in the new contract

367
00:24:34,206 --> 00:24:38,658
and nullable in the old contract, which is basically you made something mandatory,

368
00:24:38,834 --> 00:24:42,406
but the older contract, it was nullable. And that is actually correct.

369
00:24:42,508 --> 00:24:46,898
How specmatic is able to point it out to us, because whenever

370
00:24:47,074 --> 00:24:50,474
you are going to send SKU, you are supposed to send the value and not

371
00:24:50,512 --> 00:24:53,798
a null. But in the earlier case you could send a null,

372
00:24:53,974 --> 00:24:57,386
thereby it is a backward incompatible change. Now this

373
00:24:57,408 --> 00:25:00,954
is getting progressively harder, right? To figure out if this is a backward

374
00:25:01,002 --> 00:25:04,574
compatibility change or not. Compatible change or not.

375
00:25:04,692 --> 00:25:07,806
Let's take it to the next level. What if I

376
00:25:07,828 --> 00:25:11,374
change a schema component that is referenced in request and

377
00:25:11,412 --> 00:25:14,878
response? Okay, I have an example

378
00:25:14,964 --> 00:25:18,322
of such a contract here, which is a fairly large one.

379
00:25:18,376 --> 00:25:21,620
I do not expect you to read all of it,

380
00:25:22,070 --> 00:25:25,474
but what I'd like to draw your attention to is this one

381
00:25:25,512 --> 00:25:27,640
particular schema component called address.

382
00:25:28,570 --> 00:25:32,022
Now let's actually take a look at where address is used.

383
00:25:32,156 --> 00:25:35,810
So I'm going to see address is part of storage,

384
00:25:35,970 --> 00:25:40,234
it is part of warehouse, and it

385
00:25:40,272 --> 00:25:43,446
is also part of cart response.

386
00:25:43,638 --> 00:25:47,414
Okay? Now the other problem is storage

387
00:25:47,462 --> 00:25:51,982
itself is

388
00:25:52,036 --> 00:25:56,510
part of request,

389
00:25:56,850 --> 00:26:00,442
but address is also part of directly response.

390
00:26:00,586 --> 00:26:03,854
Now if the same schema is part of

391
00:26:03,892 --> 00:26:07,346
both request and response now, how would you

392
00:26:07,368 --> 00:26:11,486
make a decision whether it's backward compatible or not? Now that doesn't

393
00:26:11,518 --> 00:26:15,038
stop there, right? The next one is the hierarchy, which is basically what

394
00:26:15,064 --> 00:26:19,122
you noticed, because address was directly part of the storage

395
00:26:19,266 --> 00:26:23,202
and one more element, and it is also directly appearing

396
00:26:23,266 --> 00:26:27,480
under the master element, which means you don't know what

397
00:26:28,010 --> 00:26:30,860
sort of issues it can create if you change a value.

398
00:26:31,230 --> 00:26:34,406
What can make it even more complicated is if this schema

399
00:26:34,438 --> 00:26:38,006
is referenced across multiple files, which is normal,

400
00:26:38,198 --> 00:26:42,550
for example with open API remote references, then that can make

401
00:26:42,720 --> 00:26:46,026
life a lot more harder. So for an engineer who's

402
00:26:46,058 --> 00:26:49,934
probably just joined the team, and you ask me to make the change here

403
00:26:50,052 --> 00:26:53,706
to say address, which is required now, and it's

404
00:26:53,738 --> 00:26:56,914
got these four parameters which are required. I want you to

405
00:26:56,952 --> 00:27:00,754
remove this from required to making it optional. Now is

406
00:27:00,792 --> 00:27:04,306
this change backward compatible? I'm pretty sure at least

407
00:27:04,328 --> 00:27:07,646
I am not smart enough to compatible this mentally.

408
00:27:07,678 --> 00:27:11,046
I need the help of something like specmatic to figure this out.

409
00:27:11,148 --> 00:27:14,646
And isn't this very powerful to do? Because all you've noticed is

410
00:27:14,668 --> 00:27:18,242
I've been able to experiment which change is compatible

411
00:27:18,306 --> 00:27:21,674
or not, just by changing the specifications and not really

412
00:27:21,712 --> 00:27:25,958
writing any code now this would be a great way of collaborating between teams

413
00:27:26,054 --> 00:27:29,354
to understand if a change made for one team can

414
00:27:29,392 --> 00:27:33,054
break the compatibility with another consumer or

415
00:27:33,092 --> 00:27:36,000
client team. Now with that out of the way,

416
00:27:37,170 --> 00:27:40,654
let's further move to the next topic, which is called

417
00:27:40,692 --> 00:27:43,922
central contract repo. Are we on the same page?

418
00:27:43,976 --> 00:27:47,662
What do I mean by that? Now we've seen contract

419
00:27:47,726 --> 00:27:51,726
was tests, contract as stub, we've seen backward compatibility verification,

420
00:27:51,838 --> 00:27:54,674
and all of this hard work that we've done.

421
00:27:54,792 --> 00:27:58,482
And still it is possible that let's say I am the provider

422
00:27:58,626 --> 00:28:01,894
developer and I make a change to the application and

423
00:28:01,932 --> 00:28:05,522
then I either miss updating the open API specification

424
00:28:05,586 --> 00:28:08,954
or I update the wrong file for whatever reason.

425
00:28:09,152 --> 00:28:13,190
And likewise, let's say if I am the consumer application developer,

426
00:28:13,350 --> 00:28:16,886
I somehow ended up referring to the older version

427
00:28:16,918 --> 00:28:20,654
of the contract, or I am not looking

428
00:28:20,692 --> 00:28:23,840
at the largest version that someone sent me over email,

429
00:28:25,170 --> 00:28:28,670
and thereby I have ended up using

430
00:28:28,740 --> 00:28:32,586
the wrong API specification as reference for building my consumer

431
00:28:32,618 --> 00:28:34,880
application. Now if this happens,

432
00:28:35,650 --> 00:28:39,366
irrespective of whether you're using specmatic and all the smart block

433
00:28:39,418 --> 00:28:42,706
and contract test and whatnot, you can still end up with

434
00:28:42,728 --> 00:28:46,702
a broken integration. Now that's not a desirable place to be,

435
00:28:46,776 --> 00:28:50,354
right? What we want is to have the API

436
00:28:50,402 --> 00:28:54,610
specification as a single source of truth. It is code practically,

437
00:28:54,690 --> 00:28:58,150
and how do we treat code? We keep it in a version control

438
00:28:58,220 --> 00:29:01,974
system and that's where what we believe is

439
00:29:02,012 --> 00:29:05,126
open API or any other API specification standards you're

440
00:29:05,158 --> 00:29:08,518
using should reside in a central contract repository

441
00:29:08,614 --> 00:29:12,362
which is a version control system. And if you are treating it like code,

442
00:29:12,496 --> 00:29:15,674
then you will end up having something like a pull request or merge

443
00:29:15,722 --> 00:29:19,502
request process, which is a good thing because you can now have

444
00:29:19,636 --> 00:29:23,838
some sort of a style or an API enter with

445
00:29:23,924 --> 00:29:27,346
probably tools such was stoplight spectral. And once

446
00:29:27,368 --> 00:29:31,438
you have gone through the basic process there, then you can do the backward compatibility

447
00:29:31,534 --> 00:29:35,842
testing which we just spoke about, right? And verify that the

448
00:29:35,896 --> 00:29:40,322
change that is being proposed is compatible or not. Now specmatic,

449
00:29:40,466 --> 00:29:44,086
you noticed I was able to compare to files. Likewise it

450
00:29:44,108 --> 00:29:48,066
can also compare to versions of the same file in a version

451
00:29:48,098 --> 00:29:51,434
control system, right? And thereby give you a go ahead whether

452
00:29:51,472 --> 00:29:55,338
it is compatible or not. If it is compatible, you'll go ahead and review

453
00:29:55,424 --> 00:29:58,060
and merge it manually after,

454
00:29:58,430 --> 00:30:01,680
sorry, you would do a manual review and then merge it

455
00:30:02,210 --> 00:30:05,642
and pretty much evolve the API further.

456
00:30:05,706 --> 00:30:09,486
Or if you realize that it's a backward incompatible change, then you may have to

457
00:30:09,508 --> 00:30:13,086
think about a versioning strategy

458
00:30:13,118 --> 00:30:16,900
for your API itself. Now with this

459
00:30:17,750 --> 00:30:20,962
pretty much we have covered four topics right, which is

460
00:30:21,096 --> 00:30:24,894
contract was tests, contract was stub contract versus contract backward

461
00:30:24,942 --> 00:30:28,946
compatibility testing and then the central contract repo.

462
00:30:29,138 --> 00:30:32,598
How do all these pieces come together eventually in the

463
00:30:32,604 --> 00:30:36,118
CI pipeline to solve our initial problem, which is

464
00:30:36,204 --> 00:30:40,050
to shift left the identification of compatibility issues.

465
00:30:40,220 --> 00:30:43,770
Now that we know that the gaps specifications is being stored

466
00:30:44,270 --> 00:30:47,942
in the central contract repository, which is a single source of truth

467
00:30:48,086 --> 00:30:51,638
and specmatic is able to read it, make it available as contract was

468
00:30:51,664 --> 00:30:55,182
step services for your consumer application and

469
00:30:55,236 --> 00:30:58,654
contract as test for your provider application. Let's see

470
00:30:58,692 --> 00:31:02,026
what happens further in the continued integration environment of the consumer

471
00:31:02,058 --> 00:31:05,918
application after the unit tests are done. For component testing, you don't

472
00:31:05,934 --> 00:31:09,234
need to look for another tool to stub out the

473
00:31:09,352 --> 00:31:13,218
provider. You can use the specmatic stub server which

474
00:31:13,224 --> 00:31:17,794
you are using on your local environment itself. Spec environment

475
00:31:17,842 --> 00:31:21,654
was well, like I mentioned earlier. So now that you've been

476
00:31:21,692 --> 00:31:24,738
able to emulate the provider for the consumer,

477
00:31:24,834 --> 00:31:29,026
let's look at what happens for the provider itself. Now after the unit testing

478
00:31:29,058 --> 00:31:33,226
is done, we run the contract test first to verify that the

479
00:31:33,328 --> 00:31:36,954
provider is adhering to the API specifications, and only after

480
00:31:36,992 --> 00:31:40,842
that we run the component testing. Now that we have adhered

481
00:31:40,906 --> 00:31:44,606
with the API specifications both on our local and on

482
00:31:44,628 --> 00:31:48,362
our CI for both the consumer and the provider applications,

483
00:31:48,506 --> 00:31:52,186
we can confidently deploy it to this integration

484
00:31:52,218 --> 00:31:56,034
testing environment and be sure that it's going to work. And you also

485
00:31:56,072 --> 00:31:59,842
have an unblocked path to production. And pretty much

486
00:31:59,896 --> 00:32:03,518
none of the compatibility related incidents are bound

487
00:32:03,534 --> 00:32:07,106
to happen now in production at all because we have completely

488
00:32:07,208 --> 00:32:11,286
shifted left the identification of compatibility issues to

489
00:32:11,308 --> 00:32:14,662
the local environment or at most to the CI very much in the green

490
00:32:14,716 --> 00:32:18,106
right, which is what the heat map is representing. So which means the

491
00:32:18,128 --> 00:32:21,254
cost of fixing such issues is also fairly

492
00:32:21,302 --> 00:32:24,806
low. And that is how specmatic

493
00:32:24,918 --> 00:32:29,238
and contract driven development can help you identify

494
00:32:29,414 --> 00:32:33,054
compatibility issues early in your development cycle without

495
00:32:33,172 --> 00:32:37,162
depending on integration testing, and then allow you to confidently

496
00:32:37,226 --> 00:32:40,510
deploy your applications independently to production.

497
00:32:42,050 --> 00:32:45,722
With that, I'll open up for the Q A on the discord server.

498
00:32:45,866 --> 00:32:49,454
And thank you very much. Please do feel free to reach

499
00:32:49,492 --> 00:32:53,950
out to me on my social handle here and do check out specmatic

500
00:32:54,290 --> 00:32:55,700
in thank you.

