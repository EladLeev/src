1
00:00:17,370 --> 00:00:21,226
Hello, fellow Rastasians. My name is Andre Marinika and I'm

2
00:00:21,258 --> 00:00:24,030
from the Internet scale blockchain,

3
00:00:24,610 --> 00:00:27,926
and I'm very excited to be today here to have

4
00:00:27,948 --> 00:00:31,334
this presentation, which is a bit unusual for me. I haven't done anything like this

5
00:00:31,372 --> 00:00:34,946
ever before. This one is going to be something aimed

6
00:00:34,978 --> 00:00:38,498
more at rust enthusiasts and rust programmers,

7
00:00:38,674 --> 00:00:42,106
unlike the more usual presentations that we do for the

8
00:00:42,128 --> 00:00:45,658
blockchain crowd. So, without further ado, let's get going.

9
00:00:45,744 --> 00:00:49,334
The title of today is pushing Rust to the limit in a blockchain

10
00:00:49,382 --> 00:00:53,278
environment. And it's really a story. It's a story about

11
00:00:53,444 --> 00:00:57,678
how we came to create some of our products and

12
00:00:57,764 --> 00:01:01,626
how we discovered Rust, how we learned about rusts, and how we eventually

13
00:01:01,658 --> 00:01:04,690
pushed it to its limits and we almost broke it.

14
00:01:04,760 --> 00:01:08,450
Not quite. Rust is a resilient riddle crab.

15
00:01:09,830 --> 00:01:12,914
First off, who I am, my name is Andrei Marinica. As I said,

16
00:01:12,952 --> 00:01:16,946
I've been an engineer at Elrond for almost four years and a proud rustician

17
00:01:16,978 --> 00:01:21,394
for about three. I've always, always been very passionate about programming

18
00:01:21,442 --> 00:01:25,026
language frameworks, language models,

19
00:01:25,138 --> 00:01:28,326
program models and all that. And I'm probably going to keep doing

20
00:01:28,348 --> 00:01:31,686
this for the rest of my life, for reasons you will see later. My favorite

21
00:01:31,718 --> 00:01:35,434
emoji is the axe, but also, of course, our little friend there,

22
00:01:35,472 --> 00:01:39,578
the crab. This presentation will have

23
00:01:39,664 --> 00:01:43,898
three parts. The first part, I have to give you a primer

24
00:01:43,994 --> 00:01:47,898
on what we're doing. What is it actually that we're trying to achieve?

25
00:01:47,994 --> 00:01:51,678
Because otherwise the rest don't make much sense. I'm going

26
00:01:51,684 --> 00:01:54,846
to try to keep it short, though. Now, the second one is the juicy

27
00:01:54,878 --> 00:01:58,098
bit. It's a bit of like a

28
00:01:58,104 --> 00:02:01,490
manual. Have you ever wondered how it is to write a framework?

29
00:02:01,990 --> 00:02:06,094
Spoiler alert. I do not know the exact number of steps involved,

30
00:02:06,142 --> 00:02:09,926
but it's many. And again, I'm not going to present everything that we

31
00:02:09,948 --> 00:02:13,926
ever did, but I'm going to tell

32
00:02:13,948 --> 00:02:16,600
you about the fun bits. I'm going to try to keep it fun.

33
00:02:17,290 --> 00:02:20,714
And then the third part is a collection of

34
00:02:20,912 --> 00:02:24,842
fun little tales about stuff we encountered and crazy

35
00:02:24,896 --> 00:02:28,346
solutions we came up with to fix problems which none of them would have

36
00:02:28,368 --> 00:02:31,962
been possible without the generous support of the rust language.

37
00:02:32,106 --> 00:02:33,840
So let's keep going.

38
00:02:35,330 --> 00:02:38,814
A short crash course in Elrond architecture. So, first off,

39
00:02:38,852 --> 00:02:41,598
what is Elrond? Maybe you've heard of it? Maybe not.

40
00:02:41,764 --> 00:02:45,146
Elrond is a super fast and cheap

41
00:02:45,178 --> 00:02:48,434
layer. One blockchain. And if you ask me, the coolest out there.

42
00:02:48,552 --> 00:02:52,942
Don't let anybody else fool you. We have a lot of very cool features.

43
00:02:53,086 --> 00:02:56,766
Sharding is one of the big ones. We have really fast smart contract,

44
00:02:56,878 --> 00:03:00,754
and something we pride ourselves very much in is the great Dapps,

45
00:03:00,802 --> 00:03:03,938
both mobile and on the web. And we hope we're

46
00:03:03,954 --> 00:03:07,898
going to end up being on every person's cell phone or web browser in

47
00:03:07,984 --> 00:03:11,530
the world soon. So stay tuned for that.

48
00:03:11,680 --> 00:03:15,238
We have our own coin, our own token called egold,

49
00:03:15,254 --> 00:03:18,838
with very cool tokenomics and a growing ecosystem

50
00:03:18,934 --> 00:03:22,854
which we are very, very grateful for and trying to cherish

51
00:03:22,902 --> 00:03:26,334
and grow. And I could be going on

52
00:03:26,372 --> 00:03:29,598
about all of these subjects on and on forever, but I really want to

53
00:03:29,604 --> 00:03:32,000
focus on one thing and one thing only today.

54
00:03:33,170 --> 00:03:36,366
And it is the smart contracts. You see,

55
00:03:36,548 --> 00:03:39,410
we are trying to be the fastest blockchain on the planet.

56
00:03:39,990 --> 00:03:43,074
Yeah, I'm not sure if there yet, but we're trying to get there.

57
00:03:43,192 --> 00:03:46,982
And the thing is, with the fastest blockchain is that there are nothing

58
00:03:47,036 --> 00:03:50,566
without the fastest vms, which in turn are nothing without the

59
00:03:50,588 --> 00:03:54,294
fastest smart contract. Right? Because no matter how

60
00:03:54,332 --> 00:03:56,630
fast you can churn out transactions,

61
00:03:57,930 --> 00:04:02,166
if the smart contract is a bottleneck, I mean, that's where the interesting parts

62
00:04:02,198 --> 00:04:06,074
are. And so nowadays everybody is trying to go

63
00:04:06,112 --> 00:04:10,122
for this or that copy of solidity and of EVM. And from the get

64
00:04:10,176 --> 00:04:13,566
go, we felt it wasn't really quite the thing for us, so we

65
00:04:13,588 --> 00:04:17,278
opted instead for Webassembly. And I must tell you, I don't know how many of

66
00:04:17,284 --> 00:04:20,538
you have worked with Webassembly. I love webassembly

67
00:04:20,634 --> 00:04:24,334
really, really much. It's so clean, it's so

68
00:04:24,372 --> 00:04:27,906
portable, it's so nice and sandboxed. I feel it's the

69
00:04:27,928 --> 00:04:31,634
perfect match for the blockchain and was an underlying technology. We chose

70
00:04:31,672 --> 00:04:35,102
Wasmer, which is awesome technology. It's a webassembly

71
00:04:35,166 --> 00:04:38,600
executor, which we've built our products around.

72
00:04:40,010 --> 00:04:43,526
But we're not talking about wasmer today. We're talking about how

73
00:04:43,548 --> 00:04:47,366
we integrate contracts into Wasmer and how we run them. And this

74
00:04:47,388 --> 00:04:50,566
is a helpful chart. Maybe it's a bit much

75
00:04:50,668 --> 00:04:54,362
at first glance, but really it's nothing very complicated going on right here.

76
00:04:54,416 --> 00:04:58,266
So we have a blockchain or a node. Well, it's a machine somewhere in

77
00:04:58,288 --> 00:05:01,710
your cloud most of the time. We have a vm on top,

78
00:05:01,780 --> 00:05:06,190
which we lovingly named Arwen.

79
00:05:07,410 --> 00:05:11,134
And then on top we run the Wasmar engine, which takes

80
00:05:11,172 --> 00:05:14,974
the smart contracts, compiles them into some machine

81
00:05:15,022 --> 00:05:18,446
code, and then runs them and does all those kind of magic

82
00:05:18,478 --> 00:05:22,066
tricks. Simply put, just think

83
00:05:22,088 --> 00:05:25,890
of these three levels. So there's a programmer writing a smart contract

84
00:05:27,510 --> 00:05:30,646
in a high level language, obviously, and then they're going to compile it

85
00:05:30,668 --> 00:05:34,118
down to something like to webassembly. The webassembly gets saved on the

86
00:05:34,124 --> 00:05:37,922
blockchain. It's portable, it's super clean. And then whenever

87
00:05:37,986 --> 00:05:41,482
you need to run that smart contract code, it will get

88
00:05:41,536 --> 00:05:45,114
just in time compiled. It gets cached into machine code and

89
00:05:45,152 --> 00:05:48,714
run. Right. So why am I talking about

90
00:05:48,752 --> 00:05:52,110
all of this? It's because of our objectives.

91
00:05:52,770 --> 00:05:55,562
Contract size for us is crucial,

92
00:05:55,706 --> 00:05:58,846
aka byteco size. You want to build a

93
00:05:58,868 --> 00:06:02,106
smart contract that is as small as possible. We're talking kilobytes.

94
00:06:02,138 --> 00:06:05,674
We even have smart contract that are smaller than one kilobytes, that are like 800,

95
00:06:05,732 --> 00:06:08,180
900 bytes, which is kind of crazy.

96
00:06:09,190 --> 00:06:12,894
And this is very important for two reasons. One, the just in time compilation

97
00:06:12,942 --> 00:06:16,322
is actually not so cheap. I mean, it's not so expensive either.

98
00:06:16,376 --> 00:06:19,894
But if you're trying to run thousands of contracts per second,

99
00:06:20,092 --> 00:06:24,066
even with caching, it can get in the way. And also, blockchain storage

100
00:06:24,098 --> 00:06:27,238
is expensive because you have to replicate this for everybody that's in

101
00:06:27,244 --> 00:06:31,314
the network. And so we want these things, and we also want speed.

102
00:06:31,362 --> 00:06:34,954
We want a bit fast because we want to again run thousands of them per

103
00:06:34,992 --> 00:06:37,850
second. And in the process,

104
00:06:37,920 --> 00:06:41,146
we also don't want to burden the smart contract developers with

105
00:06:41,168 --> 00:06:43,530
all the low level details.

106
00:06:44,670 --> 00:06:48,042
And to be honest, they cannot be trusted.

107
00:06:48,186 --> 00:06:51,614
I cannot be trusted. I do not want to know

108
00:06:51,652 --> 00:06:55,086
how to optimize a smart contract. I need a framework

109
00:06:55,118 --> 00:06:58,530
that does it for me. And looking around,

110
00:06:58,600 --> 00:07:02,034
we realized it's really only one language that can

111
00:07:02,072 --> 00:07:05,666
cut it, and we all know what that language is because otherwise we

112
00:07:05,688 --> 00:07:09,682
wouldn't be at this conference. So without further ado,

113
00:07:09,746 --> 00:07:12,818
I'm going to present you a very, very high level overview

114
00:07:12,994 --> 00:07:16,326
of how to build a smart contract framework. Obviously,

115
00:07:16,428 --> 00:07:20,330
in rust, which satisfies all this criteria,

116
00:07:20,990 --> 00:07:24,300
I'm going to give it a bridge because it's been three years of work.

117
00:07:24,750 --> 00:07:28,860
So first things first, you got to make it fast.

118
00:07:29,710 --> 00:07:33,438
As I said, you want your smart contracts to be as small as possible,

119
00:07:33,524 --> 00:07:36,926
as smart as possible. This means smart contracts cannot be

120
00:07:36,948 --> 00:07:40,666
bothered with a lot of the stuff your regular programs are bothered.

121
00:07:40,778 --> 00:07:44,298
For instance, big numbers are the bread and butter on the blockchain.

122
00:07:44,394 --> 00:07:48,482
You can't be bothered with defining addition and stuff like that.

123
00:07:48,616 --> 00:07:52,062
You also need to use all kinds of crypto functions.

124
00:07:52,126 --> 00:07:55,566
You don't want to implement any of your code in every smart contract.

125
00:07:55,678 --> 00:07:59,254
And oh boy, don't get me started about memory allocation. Memory allocation is

126
00:07:59,292 --> 00:08:02,210
great. But when you're running on such a tight schedule,

127
00:08:02,290 --> 00:08:06,054
you want everything out. So there's this trick we've been using,

128
00:08:06,252 --> 00:08:10,190
you see, as in very helpfully displayed

129
00:08:10,290 --> 00:08:14,026
in the table to the right. Smart contracts are supposed to be the

130
00:08:14,048 --> 00:08:17,498
brain. They're supposed to be the what, what we are doing.

131
00:08:17,664 --> 00:08:21,174
And then all the muscle stuff, it shouldn't be in a smart contract.

132
00:08:21,222 --> 00:08:24,510
So we put it in the vm, and our vm is doing actually a lot

133
00:08:24,660 --> 00:08:28,366
for the smart contract. Not crazy

134
00:08:28,468 --> 00:08:31,406
smart stuff, mind you, but crazy powerful stuff.

135
00:08:31,508 --> 00:08:34,954
Like it's doing all the big number arithmetic,

136
00:08:35,002 --> 00:08:38,506
addition abstractions, powers all the functions,

137
00:08:38,538 --> 00:08:41,966
everything. And there's a helpful example here. So this

138
00:08:41,988 --> 00:08:45,478
is a function that's very simple function. You will see in

139
00:08:45,484 --> 00:08:48,594
a moment. This is extremely, extremely sanitized,

140
00:08:48,642 --> 00:08:53,586
the webassembly. So don't be scared about it. It's pretty much assembly,

141
00:08:53,778 --> 00:08:56,758
but check out what we're doing here. So we have a function which is the

142
00:08:56,764 --> 00:09:00,662
smarts. It's the smart contract doing the smarts. And then we

143
00:09:00,716 --> 00:09:04,106
just want to get some arguments and then add them together and return them back

144
00:09:04,128 --> 00:09:07,706
to the user. That's it. And we don't want the

145
00:09:07,728 --> 00:09:11,286
contract to do that. There's no logic for that. And all of those functions

146
00:09:11,318 --> 00:09:14,198
like add two big ins, that's actually in the VM.

147
00:09:14,374 --> 00:09:18,106
The VM actually does it. And the way it communicates with a smart

148
00:09:18,138 --> 00:09:21,406
contract is it gives it some handles. It's like a pointer, but it's not a

149
00:09:21,428 --> 00:09:25,458
pointer, just an integer that says, hey, I'm going to add

150
00:09:25,544 --> 00:09:29,058
big int number five with bigging number seven. Can you do

151
00:09:29,064 --> 00:09:32,674
the math for me? And the beautiful thing is, the smart contract never

152
00:09:32,712 --> 00:09:35,906
even sees these numbers. The smart contract is like the

153
00:09:35,928 --> 00:09:39,266
recipe. It's not the food, it's just the recipe. It just tells

154
00:09:39,298 --> 00:09:42,790
you what you do. There's no food there, there's nothing to eat.

155
00:09:42,940 --> 00:09:47,062
The VM does everything. So that's first

156
00:09:47,116 --> 00:09:50,374
thing that we have to do. We thought, how many things fast and small?

157
00:09:50,412 --> 00:09:54,202
And that's probably the smallest thing you can do because you can do all these

158
00:09:54,256 --> 00:09:58,170
huge operations in just a few lines of assembly. But obviously

159
00:09:58,240 --> 00:10:01,498
nobody wants to write code like red. I definitely don't want to do.

160
00:10:01,584 --> 00:10:04,160
I guess you don't either. So,

161
00:10:04,850 --> 00:10:08,702
tada. The second thing you want to do in a framework is make it pretty.

162
00:10:08,836 --> 00:10:12,794
And when I say pretty, I'm not only talking about aesthetics.

163
00:10:12,842 --> 00:10:16,146
I mean, aesthetics are nice. Everybody wants to look at

164
00:10:16,168 --> 00:10:19,666
some piece of code and say nice. But that's not

165
00:10:19,688 --> 00:10:23,166
really the point of it. The point of it is these little smart contracts,

166
00:10:23,278 --> 00:10:27,010
they're not your average programs that do average program

167
00:10:27,080 --> 00:10:30,486
things. There's millions of dollars flowing through them. So you want to make

168
00:10:30,508 --> 00:10:33,890
sure you don't have bugs. You really want to make sure you don't

169
00:10:33,970 --> 00:10:37,174
have bugs. And the only way to do that is to write

170
00:10:37,212 --> 00:10:40,378
some really, really high level code. And high level code has to be pretty,

171
00:10:40,464 --> 00:10:43,898
has to be readable. The programmer has to look

172
00:10:43,904 --> 00:10:47,674
at the code and say, yeah, that's an addition. It shoulders be

173
00:10:47,712 --> 00:10:51,114
bothered with how the addition was performed. So it's actually

174
00:10:51,152 --> 00:10:54,446
one of the most important things when you're designing a framework. This should have probably

175
00:10:54,468 --> 00:10:57,840
been the first, but the segu wouldn't have flowed so well anyway.

176
00:10:58,850 --> 00:11:02,206
And the point is, what makes rust so great is

177
00:11:02,228 --> 00:11:05,826
that rust makes this possible. All this crazy stuff with numbers that

178
00:11:05,848 --> 00:11:09,140
are not even in memory, that are not even regular things.

179
00:11:09,510 --> 00:11:12,740
And still you can override operators and

180
00:11:13,510 --> 00:11:16,994
you can have these two beautiful big and objects, and you can add them and

181
00:11:17,032 --> 00:11:20,246
get a result, and you don't care what happens behind. And as

182
00:11:20,268 --> 00:11:24,066
we'll see later, you don't even know what happens behind. But it's

183
00:11:24,098 --> 00:11:28,120
beautiful. It's pretty. So next thing on list,

184
00:11:29,130 --> 00:11:32,858
a smart contract. How it looks like this is one of the really simple ones.

185
00:11:33,024 --> 00:11:36,474
And I just wanted to post this here to show how

186
00:11:36,512 --> 00:11:41,694
pretty it is. Not only that, but I also wanted to

187
00:11:41,732 --> 00:11:45,338
talk about another thing. When designing frameworks,

188
00:11:45,514 --> 00:11:49,214
what abstractions do you choose? For instance, here we chose to

189
00:11:49,332 --> 00:11:52,766
make all the contracts traits. They could have been modules, they could

190
00:11:52,788 --> 00:11:56,446
have been just random functions thrown in, but we chose traits for several reasons that

191
00:11:56,468 --> 00:11:59,986
we're going to see in a moment. And one of them is you make a

192
00:12:00,008 --> 00:12:03,630
framework, you want your stuff to be testable, right? You write a smart contract,

193
00:12:03,710 --> 00:12:06,500
you want to test it. So first thing,

194
00:12:07,190 --> 00:12:10,114
you write a smart contract, you ship it to Webassembly,

195
00:12:10,162 --> 00:12:13,206
you convert it into a smart contract, and you run it

196
00:12:13,228 --> 00:12:16,162
on the blockchain. But it's hard to test. It's a complex scenario.

197
00:12:16,306 --> 00:12:19,206
You want to write unit tests, you want to write integration tests. So what you

198
00:12:19,228 --> 00:12:23,126
do, you make this straight. You change its implementation completely. The implementation is

199
00:12:23,148 --> 00:12:26,634
auto generated. The developer doesn't care really, but you change its

200
00:12:26,672 --> 00:12:29,546
implementation and now it's a library and you can run it and you can run

201
00:12:29,568 --> 00:12:32,000
tests on it. Yeah, we got it.

202
00:12:33,010 --> 00:12:36,122
Now the next thing, you want to make it interoperable.

203
00:12:36,186 --> 00:12:40,058
Interoperability is not easy. See, these smart contracts, they don't

204
00:12:40,074 --> 00:12:44,042
live in a vacuum. They're not everyone alone in their tiny little rooms.

205
00:12:44,106 --> 00:12:46,770
They have to talk to each other because otherwise where's the fun?

206
00:12:46,920 --> 00:12:50,354
And thing is, they're not regular programs, they're not even

207
00:12:50,392 --> 00:12:53,938
regular functions that you can call. So calling them is a

208
00:12:53,944 --> 00:12:56,770
bit weird. You have to pass through all these gates,

209
00:12:57,430 --> 00:13:00,246
you have to put them on a blockchain, you have to make a transaction from

210
00:13:00,268 --> 00:13:03,842
another transaction and stuff like that. You have to format transaction strings,

211
00:13:03,906 --> 00:13:06,966
you have to interpret results. No programmer wants to do this.

212
00:13:07,068 --> 00:13:10,646
Programmers just want, I want to call this function, I want to call

213
00:13:10,668 --> 00:13:14,506
this endpoint as I would be calling a normal function. So a

214
00:13:14,528 --> 00:13:18,026
good framework would do that for you. You want to call a contract from

215
00:13:18,048 --> 00:13:21,386
another contract. It should be like, oh yeah, sure, this is contract, this is

216
00:13:21,408 --> 00:13:25,102
an object, just call method, add on it. And you can see that add

217
00:13:25,156 --> 00:13:29,134
with bun of five. And of course in between

218
00:13:29,172 --> 00:13:32,314
the call and the receiver, it's going to be a lot of magic.

219
00:13:32,362 --> 00:13:35,274
But how do you do that? Magic? Well, we're in rusts,

220
00:13:35,322 --> 00:13:38,626
we can do anything, don't we? So there's a thing called

221
00:13:38,648 --> 00:13:42,318
a proxy you want to call something. So it's like a facade, a proxy,

222
00:13:42,494 --> 00:13:45,922
what will you. So for this contract, for instance, for the add

223
00:13:45,976 --> 00:13:49,490
method, you can have another trait that is an interface to your trait.

224
00:13:49,570 --> 00:13:52,550
So yeah, it's traits all the way, I guess.

225
00:13:52,700 --> 00:13:55,974
And then you can call this add function in the trait and have

226
00:13:56,012 --> 00:13:59,270
some ugly auto generated code to do all the magic for you.

227
00:13:59,340 --> 00:14:03,066
Right? Cool solution done. Well, not quite done

228
00:14:03,248 --> 00:14:06,698
because we're in rusts. We can go even further than that. I mean, look at

229
00:14:06,704 --> 00:14:10,262
that other proxy, it's beautiful. But we had to write by hands and we're lazy,

230
00:14:10,326 --> 00:14:14,038
aren't we? So we're going to auto generate the proxy too. And now

231
00:14:14,064 --> 00:14:18,014
we have an auto generated proxy with an auto generated implementation. That was

232
00:14:18,052 --> 00:14:21,614
a lot of magic behind it. And now contracts can call each other as

233
00:14:21,652 --> 00:14:24,446
if nothing happened, as if they're not even on a blockchain,

234
00:14:24,638 --> 00:14:29,202
almost. And now another

235
00:14:29,256 --> 00:14:32,258
short story about a thing that happened.

236
00:14:32,344 --> 00:14:35,730
So we were writing actually the first arguably useful smart contract.

237
00:14:35,810 --> 00:14:39,778
And you know that pesky time when you just started programming

238
00:14:39,874 --> 00:14:43,266
and you suddenly realize your source

239
00:14:43,298 --> 00:14:47,046
code is 2000 lines long and it's all

240
00:14:47,068 --> 00:14:50,586
in one file and you start hating your life? Yeah, well, we've been

241
00:14:50,608 --> 00:14:54,538
there. So in order to fix this problem, we had to

242
00:14:54,544 --> 00:14:58,038
find a way to cut smart contracts

243
00:14:58,054 --> 00:15:01,178
into pieces. And we call them modules. So you

244
00:15:01,184 --> 00:15:03,886
have a smart contract, you have some module that was some code and you just

245
00:15:03,908 --> 00:15:06,480
import it and it's as if they become one.

246
00:15:07,170 --> 00:15:09,786
And it seems easy, you make another trade.

247
00:15:09,978 --> 00:15:12,670
We have super traits in rust, which is really handy.

248
00:15:13,890 --> 00:15:17,506
They work a bit like inheritance, so that's really cool. And it

249
00:15:17,528 --> 00:15:21,698
all seems easy and dandy, but then you realize, oh no,

250
00:15:21,784 --> 00:15:25,394
I auto generated a bunch of code. And now I

251
00:15:25,432 --> 00:15:28,526
don't only have to compose my main trait

252
00:15:28,558 --> 00:15:31,974
that I wrote, I also have to compose all those auto implemented things

253
00:15:32,012 --> 00:15:35,286
that I wrote. And I didn't even talk about half of them, but just the

254
00:15:35,308 --> 00:15:39,042
proxy, think of it, it's like auto generated thing calling another auto generated

255
00:15:39,106 --> 00:15:42,614
thing, and they have to know about each other because they have to be accessible

256
00:15:42,662 --> 00:15:47,178
to one another. So a big, big bunch of code,

257
00:15:47,264 --> 00:15:50,954
but you toil away, you work on it and you

258
00:15:50,992 --> 00:15:54,430
manage, you just manage at some point to write all this auto generated code.

259
00:15:54,500 --> 00:15:57,774
But guess what? There's another problem, and I guess you won't be thinking

260
00:15:57,812 --> 00:16:01,694
about it, but in the process you've been having

261
00:16:01,732 --> 00:16:05,758
all these modules put together and you've been generating all these kinds

262
00:16:05,774 --> 00:16:09,358
of c type endpoints that end up being endpoints

263
00:16:09,374 --> 00:16:13,298
in webassembly. And you realize that actually

264
00:16:13,464 --> 00:16:16,786
these endpoints are not generated based on your

265
00:16:16,808 --> 00:16:20,982
super duper inheritance. They're always generated. If they're in a crate, they're always

266
00:16:21,036 --> 00:16:25,174
generated. And we call them stray endpoints. And they're a pain.

267
00:16:25,372 --> 00:16:29,714
They're a real pain because imagine you have this beautiful library with 20 modules

268
00:16:29,762 --> 00:16:33,210
and you want only one of them, and guess what? You got entire

269
00:16:33,280 --> 00:16:36,586
family with you, and surprise, you're on the blockchain and

270
00:16:36,608 --> 00:16:39,794
somebody can call a meta that you didn't even know existed in your contract,

271
00:16:39,942 --> 00:16:43,694
which sucks. So another story about how we went

272
00:16:43,732 --> 00:16:47,418
about it is we had to go like really meta,

273
00:16:47,594 --> 00:16:49,470
I mean really meta.

274
00:16:51,010 --> 00:16:54,798
So brace yourselves, there's going to be pictures coming soon. So the

275
00:16:54,804 --> 00:16:57,586
first attempt is you want to create this thing called an API, and Abi is

276
00:16:57,608 --> 00:17:00,514
just a description of your public functions. That's it,

277
00:17:00,552 --> 00:17:04,482
nothing fancy. But you can't just generate it because you get modules and

278
00:17:04,616 --> 00:17:07,714
you don't have access to those modules. So you have no idea what those modules

279
00:17:07,762 --> 00:17:11,042
contain. So zero, it's failure,

280
00:17:11,106 --> 00:17:14,946
doesn't work. So what you actually want to do, instead of creating the ABI

281
00:17:14,978 --> 00:17:18,370
in macros, you generate a generator of an abbey

282
00:17:18,450 --> 00:17:22,106
in the macros, and then the abis call each other, and then you have a

283
00:17:22,128 --> 00:17:25,674
metacrate that puts everything together, and then you generate some more

284
00:17:25,712 --> 00:17:28,838
code that will generate then your webassembly,

285
00:17:29,014 --> 00:17:32,406
and then you take a deep breath and wait for the next slide,

286
00:17:32,438 --> 00:17:35,882
which is the picture. So I hope this makes it a bit clearer.

287
00:17:35,946 --> 00:17:39,450
So we have a contract with a module.

288
00:17:39,610 --> 00:17:43,226
The contract gets an ABI generator generated,

289
00:17:43,338 --> 00:17:46,926
which calls the generated module generator

290
00:17:47,038 --> 00:17:50,386
and so forth. And so you get a nice ABI, and then you have a

291
00:17:50,408 --> 00:17:53,714
nice webassembly smart contract. And what

292
00:17:53,752 --> 00:17:57,746
if you have this

293
00:17:57,768 --> 00:18:01,618
sort of module that is astray lying around, is not included anywhere?

294
00:18:01,714 --> 00:18:05,042
Well, because it is not included in the API generator,

295
00:18:05,106 --> 00:18:07,910
it will also not be included in the webassembly in the end.

296
00:18:08,060 --> 00:18:12,646
Tada. All you needed to do was tons

297
00:18:12,678 --> 00:18:16,186
of metacode and metaprogramming. But hey, that's okay, because we're in rust, we can

298
00:18:16,208 --> 00:18:19,802
do everything we want. And now the final, final thing,

299
00:18:19,936 --> 00:18:23,190
we had these beautiful smart contracts living in the blockchain,

300
00:18:23,270 --> 00:18:26,446
like in a cage. We can make them escape, right? We have so much

301
00:18:26,468 --> 00:18:30,094
magic, we know how they call each other. So if contracts can call each other

302
00:18:30,132 --> 00:18:33,370
so elegantly, why not call them from outside of the blockchain?

303
00:18:33,450 --> 00:18:36,718
Rusts as elegantly, why not use these smart contract, like,

304
00:18:36,804 --> 00:18:40,366
I don't know, some web weird services and call them directly

305
00:18:40,398 --> 00:18:43,598
from the outside? And we can do just that because we just made a bunch

306
00:18:43,614 --> 00:18:46,994
of proxies, a bunch of facades, a bunch of magic code.

307
00:18:47,112 --> 00:18:51,126
So you can go almost like in a database, like, oh, just query this function.

308
00:18:51,228 --> 00:18:54,534
Oh, make a transaction to this function. And as you can see,

309
00:18:54,572 --> 00:18:57,962
all you got there is like a function

310
00:18:58,016 --> 00:19:01,846
call, like call, sum, call, add. That's it. And rust

311
00:19:01,878 --> 00:19:06,282
is magic enough that you can do that. So to

312
00:19:06,336 --> 00:19:09,722
recapitulate, all these 300

313
00:19:09,776 --> 00:19:14,254
plus easy steps in three years can

314
00:19:14,292 --> 00:19:17,742
be thought of as make it fast, make it pretty,

315
00:19:17,796 --> 00:19:21,662
make it testable, make it interoperable, make it composable, and finally

316
00:19:21,716 --> 00:19:25,214
make it escape. And not necessarily in that order. And they're not

317
00:19:25,252 --> 00:19:27,380
in one particular order or another. Anyway,

318
00:19:28,230 --> 00:19:31,806
so there we go. We have a framework. We have a rust

319
00:19:31,838 --> 00:19:35,220
framework. We can write smart contracts. We can test them. And now

320
00:19:36,070 --> 00:19:39,618
I want to talk to you about some even more interesting stuff, some stories,

321
00:19:39,714 --> 00:19:43,480
some stuff that we just happened along the way.

322
00:19:43,850 --> 00:19:47,314
And there's going to be three exhibits. There could be more, but three exhibits,

323
00:19:47,362 --> 00:19:50,774
it is of fun problems,

324
00:19:50,892 --> 00:19:54,150
fun solutions, and I hope they inspire you. And if not,

325
00:19:54,220 --> 00:19:57,260
at least that you have a little bit of fun. So exhibit a,

326
00:19:57,710 --> 00:20:01,402
how a sane person would write a decentralizer trait. So this is like really simple

327
00:20:01,456 --> 00:20:04,314
stuff. You want to decode stuff, you want to handle errors.

328
00:20:04,362 --> 00:20:07,520
And everybody knows in rust, you just use a result.

329
00:20:08,130 --> 00:20:12,058
Results are super cool. You know what error you got super elegant.

330
00:20:12,154 --> 00:20:16,130
There's a problem, though. We started investigating the bytecode because we were crazy,

331
00:20:16,200 --> 00:20:19,860
crazy, crazy about performance. And what do you know,

332
00:20:20,790 --> 00:20:24,322
the actually innocent result turned out to be producing a lot of

333
00:20:24,376 --> 00:20:28,066
jumps, a lot of ifs, because every time you get

334
00:20:28,088 --> 00:20:30,546
out of a method, you have to check for errors, and if there's an error,

335
00:20:30,578 --> 00:20:33,958
you want to jump out and stuff like that. And the

336
00:20:33,964 --> 00:20:36,994
thing is, we didn't really care about it, because you're on a blockchain,

337
00:20:37,042 --> 00:20:41,050
if something goes wrong, you wanted to go wrong fast, you wanted to crash ASAP.

338
00:20:41,550 --> 00:20:45,066
So we didn't care about these results, but still, we didn't want

339
00:20:45,088 --> 00:20:48,540
to write some horrible piece of code. So what did we come up with?

340
00:20:49,390 --> 00:20:52,758
This thing, whatever this is. So we

341
00:20:52,784 --> 00:20:55,690
have an error handler. An error handler is static,

342
00:20:55,770 --> 00:20:59,754
is generic, and there's a thing called an handled

343
00:20:59,802 --> 00:21:03,054
error. And the thing is, we didn't want the result at all, actually. We wanted

344
00:21:03,092 --> 00:21:05,634
to have something that replaces the result completely.

345
00:21:05,832 --> 00:21:09,614
And, oh, boy, did we try some ugly

346
00:21:09,662 --> 00:21:13,586
solutions before we came up with this. The trick is the

347
00:21:13,608 --> 00:21:17,602
rust compiler does a very, very smart thing. So if you convince it

348
00:21:17,656 --> 00:21:21,670
that your error type is a thing called the Never type,

349
00:21:21,740 --> 00:21:25,526
which, by the way, is a very cool thing, it's written as an exclamation mark,

350
00:21:25,708 --> 00:21:29,238
and it's a type that can never be called that nobody can call. It's a

351
00:21:29,244 --> 00:21:32,586
sign of code that is unreachable. And rust knows this.

352
00:21:32,688 --> 00:21:36,294
And if you pop it in with your generics, the never type rust

353
00:21:36,342 --> 00:21:40,058
will know that the result that has a never error is basically not a

354
00:21:40,064 --> 00:21:43,834
result. It's always success. So it will just replace it

355
00:21:43,872 --> 00:21:47,470
with the actual result you have. And we cut, I think, like 20%

356
00:21:47,540 --> 00:21:51,086
of some of the smart contracts with this. So that's the

357
00:21:51,108 --> 00:21:54,778
first story we got for you. In case you were wondering how to get rid

358
00:21:54,794 --> 00:21:57,140
of result, that's the way.

359
00:21:58,630 --> 00:22:02,638
Now, exhibit B is what we would call Varag madness,

360
00:22:02,814 --> 00:22:06,078
or monomorphization madness, you call it.

361
00:22:06,184 --> 00:22:09,554
So, the thing is, you might have noticed in one of the previous slides,

362
00:22:09,602 --> 00:22:13,234
we have this really nice contract,

363
00:22:13,362 --> 00:22:16,786
and the contract just takes some arguments,

364
00:22:16,818 --> 00:22:20,338
and the framework does everything for you, just gets them off the blockchain, it prepares

365
00:22:20,354 --> 00:22:23,834
them for you and all that. But you want VAR arcs, you want variable number

366
00:22:23,872 --> 00:22:27,626
of arguments. And to be honest, the first real smart contract that we ever

367
00:22:27,648 --> 00:22:30,958
wrote relied heavily on them. So it was a problem from the

368
00:22:30,964 --> 00:22:34,234
get go. And the thing is, again, we're obsessed,

369
00:22:34,282 --> 00:22:38,494
obsessed about performance. So if

370
00:22:38,532 --> 00:22:41,982
there are no varags, you just want to hard code arc number

371
00:22:42,036 --> 00:22:44,798
zero, arc number one, and so forth. If there are varags,

372
00:22:44,894 --> 00:22:47,586
you want to have a loop going through them, right?

373
00:22:47,768 --> 00:22:51,346
Right. So who should decide which

374
00:22:51,368 --> 00:22:55,026
one is which? Well, the macros can do it because we

375
00:22:55,048 --> 00:22:58,930
don't want to pollute with annotations and stuff like that. So the compiler

376
00:22:59,010 --> 00:23:02,214
should know, right? It should know. And it can know

377
00:23:02,252 --> 00:23:06,120
based on type, because we know which types are varags and which types are not.

378
00:23:07,530 --> 00:23:10,646
But how do you do it? Because think of it, you have

379
00:23:10,668 --> 00:23:14,154
to decide whether you have varugs or not on the first argument. But the first

380
00:23:14,192 --> 00:23:16,998
argument might not be relevant. The last one is probably going to be the varg.

381
00:23:17,014 --> 00:23:20,506
So you have to kind of make the compiler peek into

382
00:23:20,528 --> 00:23:24,474
the future and now start, just think for it for a moment

383
00:23:24,592 --> 00:23:27,614
how you would do it. You would probably start try to do something with,

384
00:23:27,652 --> 00:23:31,070
I don't know, tuples and stuff. But then how do you peek into the future?

385
00:23:31,140 --> 00:23:34,274
How do you make sure everything is at compile time? Okay,

386
00:23:34,392 --> 00:23:38,260
spoiler, whatever this is,

387
00:23:38,710 --> 00:23:42,802
you can do sort of like a functional style fold. And just

388
00:23:42,856 --> 00:23:46,738
look at the magic there. There's let value of value of value

389
00:23:46,824 --> 00:23:50,038
in a tuple, in a tuple, in a tuple, in a tuple. Turns out you

390
00:23:50,044 --> 00:23:53,686
can nest tuples forever. Turns out you can make lists of tuples that

391
00:23:53,708 --> 00:23:56,520
go on forever, right.

392
00:23:57,130 --> 00:24:00,586
Just like a list in a functional programming. And then you can have

393
00:24:00,608 --> 00:24:03,766
them as generics, and then the outer

394
00:24:03,798 --> 00:24:06,822
tuple can look at the inner tuple and so forth,

395
00:24:06,966 --> 00:24:10,586
and can actually interrogate at compile time if

396
00:24:10,608 --> 00:24:13,294
it's a varac down the line or not, and can decide what to do about

397
00:24:13,332 --> 00:24:16,990
it with not. And this pattern, by the way, works in this beautiful

398
00:24:17,060 --> 00:24:20,846
let that rusts very helpfully decomposes for us in

399
00:24:20,868 --> 00:24:24,414
this beautiful explicit type definition, and also

400
00:24:24,452 --> 00:24:28,498
as an argument, because we need an argument for the error reporting. So there goes

401
00:24:28,584 --> 00:24:31,380
infinite tuples forever. Rusts can do that.

402
00:24:32,070 --> 00:24:35,810
Exhibit C. Now this is a bit of a weirdo, but I will

403
00:24:35,880 --> 00:24:38,806
have to let you bear with it for a moment. We all know that the

404
00:24:38,828 --> 00:24:42,006
bread and butter of rust is ownership. If you don't know what

405
00:24:42,028 --> 00:24:43,160
ownership is.

406
00:24:46,410 --> 00:24:49,866
And remember again, in one of the previous slides we were talking about these

407
00:24:49,888 --> 00:24:53,706
managed types, which they are orchestrated by

408
00:24:53,728 --> 00:24:56,940
the smart contract, but they're actually in the vm, they're not there.

409
00:24:57,470 --> 00:25:01,114
And these handles, these types, they actually act like pointers of

410
00:25:01,152 --> 00:25:04,654
something that rusts, isn't there. And think of this

411
00:25:04,692 --> 00:25:07,806
big int. This big int is just not there. But we use it

412
00:25:07,828 --> 00:25:11,486
as if it's there and the variable X has

413
00:25:11,508 --> 00:25:14,478
ownership over it, even though there's no memory there,

414
00:25:14,644 --> 00:25:18,206
and then you can take references to it, and then in the bytecode,

415
00:25:18,238 --> 00:25:21,554
you'll have a reference to an in 32, and then you can clone them and

416
00:25:21,592 --> 00:25:25,518
whatnot. But now think about what happens in this scenario.

417
00:25:25,614 --> 00:25:29,474
You have a vector that is also managed somewhere

418
00:25:29,522 --> 00:25:33,334
in the vm that contains begins, and you

419
00:25:33,372 --> 00:25:37,190
want a reference to it. You want a reference to whatever random element, element I,

420
00:25:37,340 --> 00:25:40,906
and you get an item out, and that is

421
00:25:40,928 --> 00:25:44,460
a reference to a position in a vector that is not there.

422
00:25:44,830 --> 00:25:48,374
What type do you make it? What kind of a reference

423
00:25:48,422 --> 00:25:51,020
is that in rusts that is not there.

424
00:25:52,030 --> 00:25:55,038
And you also want to dereference it and actually use it as a

425
00:25:55,044 --> 00:25:58,830
regular reference. And how do you do that? Because there's nothing there to reference.

426
00:25:59,170 --> 00:26:02,638
And the solution is, well, of course we had to create our own type because

427
00:26:02,724 --> 00:26:06,114
you can't just overwrite references in rust. It would be fun,

428
00:26:06,232 --> 00:26:09,346
but probably horribly unsafe. So we

429
00:26:09,368 --> 00:26:13,186
did write our type, which is manage rusts, but it

430
00:26:13,208 --> 00:26:16,726
also has a lifetime. But it's not really the point. How do you work

431
00:26:16,748 --> 00:26:19,318
with it? And it turns out,

432
00:26:19,484 --> 00:26:23,506
drumroll. It's transmutation. So apparently

433
00:26:23,618 --> 00:26:26,966
you can take this type and you can create a sort

434
00:26:26,988 --> 00:26:30,002
of weird zombie reference out of it. By transmutation.

435
00:26:30,066 --> 00:26:33,898
You can trick rust into thinking there's something there where there's nothing there,

436
00:26:33,984 --> 00:26:37,674
so you can work with reference to nothing.

437
00:26:37,872 --> 00:26:41,214
And I think that's the coolest thing in rust, and I think it's also

438
00:26:41,332 --> 00:26:44,400
the closest we got to actually breaking it and actually

439
00:26:45,970 --> 00:26:49,166
getting to the limits of what rust can and cannot do.

440
00:26:49,348 --> 00:26:52,814
And luckily, we did not quite break

441
00:26:52,852 --> 00:26:55,860
it, and we're still using it, and it's great.

442
00:26:56,790 --> 00:27:00,402
So I hope you enjoyed the ride. There's a lot more to be talked about,

443
00:27:00,456 --> 00:27:04,370
but of course I had to keep it within reasonable bounds.

444
00:27:04,710 --> 00:27:07,778
I'm probably going to try to make a blog post out of it that's a

445
00:27:07,784 --> 00:27:11,554
bit more detailed. So that's actually the first time this kind of stories

446
00:27:11,682 --> 00:27:15,330
surfaced into the world. I hope you enjoyed it. You can find me on telegram,

447
00:27:15,410 --> 00:27:19,586
you can email me. We have some telegram channels

448
00:27:19,618 --> 00:27:23,282
that we use for all kinds of questions, but especially for the crazier

449
00:27:23,346 --> 00:27:26,918
questions. Just email me directly and I hope to see you soon.

450
00:27:27,004 --> 00:27:30,874
It was a pleasure being here with you and, and onwards

451
00:27:30,922 --> 00:27:33,580
to the questions and the discussion. Have a nice day.

