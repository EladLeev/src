{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/3aa107b6-e293-4bf1-89c2-94417e749e01", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["applications", "approaches", "architecting", "architectures", "based", "be", "benefits", "between", "build", "by", "can", "changes", "cloud", "computing", "conf fourty two", "considered", "container", "containerbased", "containers", "core", "deploying", "environments", "managing", "microservice", "microservices", "microservicesbased", "microsoft", "mvp in developer technologies", "net", "patterns", "principles", "rebai hamida", "serviceoriented", "software", "solutions", "technologies", "two", "understand", "using"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "id": "3e6075c0-5fc8-46b7-9b49-b8a0fa24a290", "status": "completed", "error": null, "text": "You. Hello everyone, I am hamidarabay. Thank you for joining me today in Conf 42 and welcome to my talk about architecting dotted microservices in Docker ecosystem. So who I am? I am Microsoft MVP, MVP, MVP. MVP. MVP. MVP. MVP in developer technologies speaker in doubt. Net foundation. I'm also MCT Edge certified and book author. You can follow me on mittenblog, LinkedIn, YouTube or Twitter. Today we will talk about microservices architecture, container and Docker. We will see the difference between Docker, container, Docker image. We will set up our development environments to be able to test some demonstrations. So what is microservices architectures? Microservices are the natural evolution of service oriented architectures. But there are difference between microservices and service oriented architecture. So we can talk about some characteristics related to microservices. In microservices architecture, services are small, independent and loosely coupled. Each service is separate code base which can be managed by a small development team. All services can be deployed independently. A team can update an existing service without rebuilding and deploying the entire application. Services are responsible for persisting their own data or any external state. This differs from the traditional model where a separate data layer handles data persistence. Services communicate with each other by using welldefined APIs. Internal implementation details of each service are hidden from other services. Services don't need to share the same technology step libraries or frameworks. Besides for the services themselves, some other components appears in typical microservices architecture, management of the component is responsible for placing services on nodes, identifying failures, rebalancing services across nodes, and so forth. We can talk about the different elements related to microservices like service discovery that maintain a list of services and which nodes they are located on. It enables service lookup to find the endpoint for a service. When we talk about microservices architectures, we have another important element to understand that is API Gateway. That is the entry point for all the entire clients. Developers consider microservices as an architectural style that promotes the development of complex applications as a suite of small services based on business capabilities and multiple independent subsystems in the form of can autonomous services. The following pictures shows the microservices architecture style. There are various components in a microservices architectures apart from the microservices themselves. So we'll start talking about the management part that maintain the nodes for the services. We have also identity provider that manage the identity information and provides authentication services within a distributed network. Service discovery keeps track of services and service addresses and endpoints. Here we have the API gateway. It serves a client's entry point, the single point of contact from the client, which in turn returns responses from underlying microservices and sometimes an aggregated response from multiple underlying microservices. An API gateway sits between the clients and the services. It acts as reverse proxy, routing requests from clients to services. It may also perform various cross cutting tasks such as authentication, SSL termination, and braid limiting. If you don't deploy gateway, clients must send requests directly. Two front end services it creates coupling between the client and the backends. The client needs to know how the individual services are decomposed. That makes it harder to maintain the client and also harder to refactor services. So the API gateway can perform other cross cutting functions, as we said before, like authentication, logging, SSL termination and load balancing. Let's now understand the role of an architect. An architect will define the software architectures of a computing system that presents a set of structures needed to reason above, a system which comprises software elements, relations among them, and the properties of both. This architecture should meet the nonfunctional requirements in development like maintainability, the stability, all deployability, and in runtime like scalability, performance and availability. The microservices architectures offer tremendous benefits, but it's not a silver bullet. It also has some significant drawbacks, and the microservices pattern languages is a collection of patterns that solve architectures, design development and operational problems. It enables software developers to apply the microservices architecture effectively. Containers combine an Apple plus, its configuration and dependency into a single, independently deployable units. Containers are an excellent fit for bundling and deploying independent microservices. Let's learn more about containers. Containerization is an approach to software development in which an application or service, its dependency and its configuration are packaged together as a container image. The configuration can be abstracted as deployment manifestoise. For example, the containerized application can be tested as a unit and deployed as a container image instance to the host operating system. Just as shipping container allow goods to be transported by sheep, train or truck, regardless of the cargo inside. Software containers act as a standard unit of software deploying that can container different code and dependency. Containerizing of software this way enables developers and it professionals to deploy them across environments with little or no modification. Containers also isolate application from each other on a shared operating system. Containerbased applications run on top of a container hosted that in turn runs on the operating system, Linux or Windows, for example. Containers therefore have significantly smaller footprint than virtual machine images. Each container can run a wall web application or a service as shown in this picture. We have some examples here. In Docker a container host, we can run the first application, another application, a service, and another service, for example. Another benefit of a containerization is scalability. You can scale out quickly by creating new containers for short term tasks. From an application point of view, instantiating an image it's like creating a container is similar to instantiating a process like service or web app for reliability. However, when you run multiple instance of the same image across multiple host server, you typically want each container image instance to run in a different host server or between machine in different fold domains. In short, containers offer the benefit of isolation, portability, agility, scalability and control across the wall application lifecycle or flow. The most important definite benefits is the environments as solutions between the dev and the operations. What is the difference between Docker container and Docker image? Let's start by Docker container. Docker container is virtualized runtime environment used in application developments. As we mentioned before in the definition of Docker, with Docker, we are able to create, run, and deploy applications that are isolated from the deploying hardware. A docker container can use just one machine, share its kernel, and virtualize the operating system to run more isolated processes. So docker containers are lightweight. Docker image is like a snapshot in other types of virtual machine environments, it's a record of Docker container at a specific point in time. Docker images are also immutable. Why? They can't be changed, they can be duplicated, shared or deleted. The feature is useful for testing new software or configurations because whatever happens, the image remains and changes. Containers require the existing runnable images. Two exist. They are independent on images because they are used to construct runtime environments and are needed to run an application. You might want to use Docker containers just to simplify deployments. Even if you are not creating microservices, for example, perhaps you want to improve your DevOps. Workflow with Docker containers can give you better isolated test environments and can also eliminate deploying issues caused by missing dependency when you move to production environments. In cases like this, even if you are deploying a monolithic applications, it makes sense to use Docker and Windows containers for your current. NET framework applications in most cases. For this scenario, you will not need to migrate your existing application to. NET six or seven. You can use Docker containers that include the traditional. NET framework. However, a recommended approach is to use the latest version of. NET six or seven in our case, as you extend an existing application such as writing a new service in SP net core. Let's prepare our environment for running containers locally and for that we need to follow all these steps. We need to install Docker desktop. It's free and it's available for Mac and Windows. Use this link to be able to install the latest version of Docker desktop with the latest updates. So we can open Docker.com and we can click download Docker desktop here we can install it on Windows, Linux or macOS. We need to install Visual Studio 2019 or the latest version 2022. We can also use visual Studio code and two do that we will go to the website of Visual Studio and here we will use Visual Studio Microsoft.com. Here we can select Visual Studio. We have many version, we can use community version, it's really free and we have professional enterprise but in our demo we can use only community version. We have also visual studio for macOS, for the environment of macOS and here we can download visual studio code and it's available for Windows, macOS and also for Linux. We need to have an Azure account where we are able to create an Azure container registry and every other Azure services. We will use Powershell in Windows or Azure cloud shell using direct link. You need to open your browser shell azure.com else you select the cloud shell icon on the Azure portal. We will see that in Azure after if you are using visual studio code, don't forget to add the different extensions like Microsoft C sharp for visual studio code, Docker extension and Azure app service extension must be unsteaded. As soon as our environment is ready, we will start with the first step which is the creation of a docker image of a web application that we will create from an existing visual studio template. This is the demonstration flow. We start by creating and building Docker image. We will see two methods, the first one using visual studio and the second using Docker command liner. After we will tag and pull the image locally and in the end we will build and store images using Azure container registry docker app and we will start discovering Azure container apps. After installing Docker desktop we will open it. It should be running. As you can see here the engine is running. Here we have a list of containers that we will create it and here we have a list of images. If you need to see more about the different settings, you click just here in this icon and you have all information needed for Dockering giant. If you needed to enable kubernetes you just select here the different extension. For example here I enable docker extension. The use of this extension and here we have general information related general settings related to Docker desktop. Now we will open visual studio. This is visual Studio and we will create a. NEt project. We will select this template ASp. NEt core web API we can select web API for example, but in our case we select just web API. We select next. Here we give a name to our application. We identify the location of our application and we will select after next and I select here next. Here we have to select the framework. It can be. Net six or. Net seven for example we select the latest version of. NET framework. I will disable the configuration for HTTPs. Here we are able to enable Docker or not. If it's not enabled, we can also add our Docker file. We see that after but I will keep it enabled. We will select the docker operating system, Linux or Windows after we select create button to be able to create our application. So the first demo consists on building a docker image. We will use we just showed you the previous solution that we created. The web application that we created we will use also visual studio core. Let's start. Now we come back to our solution. In our conference managing project we have Docker file that is generated automatically. As you can see here. We can add this file just by right click on the solution. It's really simple. We select add and we select Docker support. Here we select the target Linux operating system or Windows and we click on ok and the file can be generated also if we didn't enable the Docker support when we created our solution or if we want to add Docker file to containerize our solution in an old application. So let's try to discover this docker file. We will start from this line from Microsoft.com. Net SDK seven to tell Docker what image we would like to use to build our application. Docker images can be inherited from other images. Therefore instead of creating our own image, we will use the official. Net SDK image that already has all the tools and packages that we need to build a. Net application. We will use multistage build as defined stage for building the web application. We define build stage in our docker file using us to make things easier when running the rest of the comments we will use workteer with the source to create working directory for our source files. This instructs udoker to use this path as the default location for all subsequent commands. By doing this we do not have type out full file paths, but can use relative paths based on the working directory also not necessary. The comments below will make a copy here only the CS project files and then runnet restore. Each comment creates a new container layers to speed the building of containers. Docker caches these layers. Since these files won't change often, we can take advantage of the caching by copying these files and running restore as separate comments. Next we will need to copy all the rest of our source files into the image. This line below is copy the files here from the source directory on your local machine to directory called source in the images in the local so we keep the copy locally and here. In the end we need to run net publish command line to build our project. Let's go back to the first line. We will specify the image that we will use two run our application and we will define our runtime stage. We will specify the working directory at this stage also and we will expose the poor 80 to incoming requests. We will use entry point to tell Docker what command we want to run when our image is executed inside the container. We do this using the. Net here and our dll of the solution as you can see here and to make your build context as more as possible. We have inside this docker docker ignore that includes all these folders. Now to build our image. It's really simple. We just select here build or rebuild to clean and build and we will try to check docker desktop if we have any container deploying or any image. As you can see here we have conference manager we will try to check our container. We need to run our solution to be able to have or to create our container and to see it in this place. So I will select Docker. It's really simple way to run our solution and our container using Visual Studio 2022 and I will try to see here what happens. As you can see we have container support. We can see our container, we can stop it. We can open terminal windows to see what's going on. And this is our application. It's really simple application. Let's check Docker desktop here and we see as a container already running here we have the conference manager is created, our container is created and we are able to see it here using Docker desktop. Now we will open visual studio code and we will create. Net web API using. Net. Net web API as it's created. I will close the terminal and we will use control shift p command line if you want to see the different command line to create our docker file for example. Now I will open the folder and this is our solutions. After we will select control shift p to be able to add our docker file control shift and p and we say docker add file to workspace. We select this one, we select our framework. Net in our case the operating system, the ports needed. I will change it here and he will ask me about adding Docker compose. I will say maybe yes, in this time we will detail it after. This is our Docker file. It's more and more detailed, but it's the same concept we use from Workteer copy. We have the endpoint so we using publishing net restore. So we have basically the same content as before. Now to build our image I will open terminal, new terminal and I will use this comment line Docker build t minus t conference manager image and I give version, let's say version. It will be a tag. We will see that after and we enter here and it's building as you can see here. Now to run our container we will use Docker can. This is the port number and our image that we already build it and we select here and we check in Docker here. Let's go back to images. We have our image conference managing image and in container we have the name of this container as you can see here and this is the image I go back here. This is container created from our image. Now we will see how we can tag an image. The docker tag helps maintain the build version to push the image to the Docker app. The Docker hub allow us to group images together based on name and tag. And we have the same thing with the azure container registry. Multiple docker tags can point to a particular image, basically as a git. Docker tags are similar to specific commits. Docker tags are just an alias for an image id. Let's see now how we can use visual studio code to add text if we come back to our solutions in the terminal. If we come back to the terminal, we use it a command line, this one run. This is the port and we use it. Conference image 1010 is our tag in our case, but we can add more tags using Docker extension. As you can see here we have the first tag and we can click right click on conference and we add our tag by selecting tag here we select tag and we can use this one 2.0 for example and we run it as you can see here we have our second tag. We will see in Docker if we have any changes related to the tag here. As you can see we have the first one and the second one. Now to build and store our docker images we will use Azure container registry. So we'll open Azure portal and we will create Azure Container registry. After we will deploying using visual Studio 2022 now we will create our Azure container registry using Azure portal Select create a resource after in categories we will select containers and here we have container history. We click on Create. We have multiple tabs. We start by basics tab and here in project details we need to define subscription, resource group and the different elements needed to create our container registry. The name of our registry location availability zone and here we select basic or standard or premium SKU. As you can see I updated my page. If you are using a private ip you need to select networking tab and you select private access. Here we have encryption. If you need to use customer manager key you can enable it and use it. We can add some tags and in the end we will select review and create. As you can see the validation based after we select create even our Azure Container registry is created. We will use here visual studio to publish our application in this registry. To do that we select container manager the project right click publish. Here we have multiple choices. We select Azure because we need to use Azure Container registry. You can also use a docker container registry or folder, FTP, ftps server, ias or just import profile. If I select Docker container registry I will select next for example and we can find also azure Container registry in Azure. We have also Azure container registry. Here we have Azure app service and Azure container registry. We can use also Azure app service as a container. If we need to just deploy one container. But if you have multiple containers, we need to add our container in Azure container history. We select next and I need to check if our container history is already created. As you can see here it's already created. We click go to the resource. Here we have the login server. We need just to check the repositories. We don't have any repositories. When we upload our application we will see our repository and our container inside the repository. Let's go back to visual studio. Here we have conference manager. We click on finish after we select close and we click on publish to be able to publish our container in Azure Container registry it takes few seconds. Now we check Azure portal to see our registry and here we select repositories and we have our repository container manager as you can see here now if we open Docker desktop here we can see our repository added in the list. As you can see here we will use now visual studio code to see how we can push our image to Azure container registry that we already created. We go back to visual studio code and we will use the docker extension as we did before and here we can see all the registry. We have Azure or Docker hub. I will select the first second one, this one I will say push for example and I will select Azure. I have a list of the registries inside my Azure account. I will select conference manager and we will use the tag image, the same tag image. We've not made a change here and here. As you can see it takes few seconds to be pushed to our registry and we check after can Azure portal I will finish it. I will open Azure portal and I will go to repositories and we find conference mentor image using our tiger as you can see here, this is the tiger. If we check Docker we are able to see also the image here conference manager image if you need for example to push the first tag, we see how we can proceed. What is the result? I will use the same tag for the same image. Let's go back two Azure portal repositories and here we will check the first one, the second one as you can see here we have the fourth project we created using Visual Studio 2022 and this is the second project uses visual studio code. Here we have only one tag. Latest the default one, use the default one and here we have two tags. To create Azure container registry we can use Azure porter, Azure Cli, Azure Powershell, any template arm templates. In our case we just tested the use of Azure portal. We can use Azure Cli. So I will just go to shell azure.com I need to be authenticated to my account and we use this command line Azacr created I will define our resource group. I will use the previous created one, the name and my plan. I select enter and in a few seconds our edge container registry will be created inside the same resource group. It's running now and as you can see here we have a JSON file as a result and I will check in my resource group the different resources created here. And here I have my container for conference that present our container registry as registry. We are using Azure container registry but we are able to deploy our image, our container image two docker app that is a public registry and to do that it's really simple. We can use the same publish here I will select a second one for example here a new one here I will select docker container and I will select Docker as you can see here we are able to publish our application as a docker image to any container registry in the cloud in prem so you need just to define your path of your repository. Now we select Docker hub. We click on next we need to add the username the password after we click on finish. As you can see here we click it on finish. After we select close and we select publish it takes few seconds. Two be published to Docker Hub and we will try to check Docker hub to see if our configuration image was pushed or not in Docker hub. Now if I open Docker hub using app docker.com, I'm using my personal account and we can find my container image conference manager. If you are using visual studio code, we can also publish our image to Docker Hub. So for example let's select this one and we click push and instead of selecting as before Azure, we will select Docker hub. I select my own account. If I have multiple accounts you can select the convenient account needed. I leave the same tag after it takes few seconds to be run. In this way if I go back to my Docker app we can find the conference manager image. Let's open some description. Here we have the tag as you can see the first one. As you break down your monolithic application into separate, closely copied microservices, your team will gain core autonomy and freedom. However, they still have to closely cooperate when interacting with the infrastructure the microservices must turn on. You will have to solve problems like predicting how much computing resource each service will need, how these requirements change under cloud, how to carve out infrastructure partition and divide them between microservices and enforce resource restrictions. Kubernetes or orchestrator solves these problems quite elegantly and provides a common framework to describe, inspect and reason about infrastructure research, sharing and utilization. That's why adopting Kubernetes as part of your microservice rearchitecture is a good idea. Microsoft Azure offers many options to work with containers and orchestrators. We use it before Azure container registry to store and manage our private container image. We use also docker app for public images. Azure container instance or Azure app services can be used to run isolated containers. We have also Azure Kubernetes service that is a great option for more complex scenario in which full container orchestration, automatic scaling and service discovery are required. The problem is Kubernetes is extremely difficult to use and we have another service that is Azure container app. If you need two, learn more about building modern application using microservices containers. Azure services orchestrator you can see these books on Amazon and if you have any questions after this session you can reach me by email via Twitter LinkedIn. Thank you for joining me today.", "words": [], "utterances": null, "confidence": 0.926931502902596, "audio_duration": 2275.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Hamidarabay will talk about architecting dotted microservices in Docker ecosystem. We will see the difference between Docker, container, Docker image. Will set up our development environments to be able to test some demonstrations.\n- In microservices architecture, services are small, independent and loosely coupled. Each service is separate code base which can be managed by a small development team. Services communicate with each other by using welldefined APIs. Developers consider microservices as an architectural style.\n- Containers combine an Apple plus, its configuration and dependency into a single, independently deployable units. Containers are an excellent fit for bundling and deploying independent microservices. The microservices architecture offer tremendous benefits, but it's not a silver bullet.\n- Docker container is virtualized runtime environment used in application developments. You might want to use Docker containers just to simplify deployments. Workflow with Docker containers can give you better isolated test environments. Let's prepare our environment for running containers locally.\n- We will see two methods, the first one using visual studio and the second using Docker command liner. After we will tag and pull the image locally and in the end we will build and store images using Azure container registry docker app. After installing Docker desktop we will open it.\n- First demo consists on building a docker image. We will use the official. Net SDK image that already has all the tools and packages that we need to build a. Net application. The web application that we created we will use also visual studio core. Let's see what happens.\n- Docker tags are just an alias for an image id. We can add more tags using Docker extension. To build and store our docker images we will use Azure container registry. We will use here visual studio to publish our application in this registry.\n- We have also Azure Kubernetes service that is a great option for more complex scenario in which full container orchestration, automatic scaling and service discovery are required. If you need two, learn more about building modern application using microservices containers.", "auto_highlights_result": {"status": "success", "results": [{"count": 2, "rank": 0.09, "text": "Docker container registry", "timestamps": [{"start": 1673784, "end": 1675566}, {"start": 1683096, "end": 1684290}]}, {"count": 9, "rank": 0.09, "text": "Docker container", "timestamps": [{"start": 65240, "end": 66174}, {"start": 560868, "end": 561914}, {"start": 564072, "end": 564942}, {"start": 565006, "end": 565806}, {"start": 581052, "end": 582146}, {"start": 602244, "end": 603242}, {"start": 1673784, "end": 1674574}, {"start": 1683096, "end": 1683826}, {"start": 2032396, "end": 2033746}]}, {"count": 1, "rank": 0.08, "text": "microservices containers", "timestamps": [{"start": 2258260, "end": 2260122}]}, {"count": 1, "rank": 0.08, "text": "can autonomous services", "timestamps": [{"start": 218056, "end": 220514}]}, {"count": 1, "rank": 0.08, "text": "Azure container app", "timestamps": [{"start": 2250256, "end": 2252240}]}, {"count": 16, "rank": 0.08, "text": "Azure container registry", "timestamps": [{"start": 788172, "end": 789954}, {"start": 857540, "end": 859034}, {"start": 1477832, "end": 1479998}, {"start": 1561892, "end": 1563174}, {"start": 1566840, "end": 1568414}, {"start": 1574696, "end": 1576482}, {"start": 1641950, "end": 1643894}, {"start": 1670760, "end": 1672302}, {"start": 1687612, "end": 1689110}, {"start": 1691280, "end": 1693130}, {"start": 1695888, "end": 1697210}, {"start": 1759812, "end": 1761630}, {"start": 1798656, "end": 1800034}, {"start": 1920904, "end": 1922302}, {"start": 2006176, "end": 2007402}, {"start": 2216360, "end": 2217614}]}, {"count": 1, "rank": 0.08, "text": "Azure container registry docker app", "timestamps": [{"start": 857540, "end": 860078}]}, {"count": 1, "rank": 0.08, "text": "Software containers", "timestamps": [{"start": 440460, "end": 441750}]}, {"count": 2, "rank": 0.08, "text": "container manager", "timestamps": [{"start": 1656050, "end": 1657594}, {"start": 1776250, "end": 1777750}]}, {"count": 1, "rank": 0.08, "text": "multiple containers", "timestamps": [{"start": 1708916, "end": 1710250}]}, {"count": 1, "rank": 0.07, "text": "new containers", "timestamps": [{"start": 508202, "end": 509242}]}, {"count": 1, "rank": 0.07, "text": "Azure container instance", "timestamps": [{"start": 2224550, "end": 2226002}]}, {"count": 3, "rank": 0.07, "text": "Azure app service", "timestamps": [{"start": 820856, "end": 821938}, {"start": 1694768, "end": 1695610}, {"start": 1701410, "end": 1702702}]}, {"count": 1, "rank": 0.07, "text": "Azure container history", "timestamps": [{"start": 1713192, "end": 1714386}]}, {"count": 1, "rank": 0.07, "text": "container support", "timestamps": [{"start": 1271750, "end": 1273058}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}