1
00:00:25,410 --> 00:00:29,126
You. Hey everyone, I'm glad to

2
00:00:29,148 --> 00:00:32,486
see you here. Thank you for joining the talk. And in the

3
00:00:32,508 --> 00:00:36,150
next 35 40 minutes we will be talking

4
00:00:36,220 --> 00:00:39,842
about infrastructure scored for JavaScript application on AWS.

5
00:00:39,906 --> 00:00:43,238
Visit typescript. And my promise for you is that

6
00:00:43,324 --> 00:00:47,426
till the end of this talk you're going to have complete infrastructure

7
00:00:47,618 --> 00:00:50,960
production ready one for your front application.

8
00:00:51,410 --> 00:00:54,160
So if you're ready, let's crack on.

9
00:00:55,090 --> 00:00:59,274
Before we continue, let me introduce myself, my name is Denis, Denis Artyuhovich,

10
00:00:59,322 --> 00:01:02,654
I'm from Belarus, originally, now based in London. I'm Tim

11
00:01:02,692 --> 00:01:06,798
Lita at the zone and at the zone we're changing every aspect

12
00:01:06,894 --> 00:01:09,454
how fans are engaging with sports,

13
00:01:09,582 --> 00:01:13,086
starting from these content distribution and truly

14
00:01:13,118 --> 00:01:17,226
immersive experience for live matches and boat

15
00:01:17,278 --> 00:01:20,914
content, we are available on various type of devices

16
00:01:21,042 --> 00:01:24,322
including smart tvs, mobiles and tablets,

17
00:01:24,466 --> 00:01:28,614
laptops, game consider such as PS five or Xbox

18
00:01:28,662 --> 00:01:32,534
whatever. And I think youll can imagine how many types of various

19
00:01:32,582 --> 00:01:36,394
infrastructure we have. So why

20
00:01:36,432 --> 00:01:39,690
do we need infrastructure AWS code? I think the answer is obvious,

21
00:01:39,760 --> 00:01:43,054
but nowadays it's increasingly crucial to

22
00:01:43,092 --> 00:01:46,000
automate literally everything, what can be automated, right?

23
00:01:46,770 --> 00:01:51,018
And yeah, let's consider just normal feature

24
00:01:51,194 --> 00:01:54,238
development flow. We're starting with one idea,

25
00:01:54,324 --> 00:01:58,274
implementing one feature, then the other shine idea comes to

26
00:01:58,312 --> 00:02:01,698
stage and we have two features and then boom, hundreds of them.

27
00:02:01,784 --> 00:02:05,670
And that's actually exactly our case. We have hundreds of probably

28
00:02:05,740 --> 00:02:09,782
thousands of different features, and we can expect changes

29
00:02:09,836 --> 00:02:13,062
in our infrastructure even multiple times per day.

30
00:02:13,196 --> 00:02:16,520
So I think you can imagine how stress it could be

31
00:02:17,050 --> 00:02:20,474
if you're going to do it manually. What if someone forget to

32
00:02:20,512 --> 00:02:24,474
document specific checkboxes? Or what if UI on

33
00:02:24,512 --> 00:02:27,542
our cloud provider? Let's say AWS has changed

34
00:02:27,606 --> 00:02:31,742
and we click on the wrong tick box and our

35
00:02:31,796 --> 00:02:34,846
site not available anymore. Oh, that can be

36
00:02:34,868 --> 00:02:38,446
stressy. Just to avoid such situation,

37
00:02:38,628 --> 00:02:42,394
we need to take advantage of the infrastructure

38
00:02:42,442 --> 00:02:46,114
as code. And before we continue,

39
00:02:46,232 --> 00:02:49,634
let's consider these two programming paradigms because they

40
00:02:49,672 --> 00:02:53,054
are quite relevant when we're talking about coding

41
00:02:53,102 --> 00:02:56,418
for our infrastructure. So imperative one stands

42
00:02:56,434 --> 00:03:00,230
for explicit instructions, which actually

43
00:03:00,300 --> 00:03:03,762
these biggest advantage of the approach, you're basically specifying

44
00:03:03,826 --> 00:03:07,598
all your instructions, usually in some bash scripts,

45
00:03:07,714 --> 00:03:11,446
and you kind of have full control. Youll flexibility.

46
00:03:11,638 --> 00:03:14,714
But at the same time it's the biggest concern because you

47
00:03:14,752 --> 00:03:18,554
need to maintain everything to yourself and

48
00:03:18,752 --> 00:03:22,442
likely it won't going to scale well with a declarative

49
00:03:22,506 --> 00:03:25,534
approach. Instead of specifying cabrosync step by step,

50
00:03:25,572 --> 00:03:29,226
you're just describing the outcome of these shape

51
00:03:29,258 --> 00:03:32,598
of your state which you expect to be applied.

52
00:03:32,794 --> 00:03:36,238
And yeah, it's usually way simpler

53
00:03:36,334 --> 00:03:39,794
scales better if someone has implemented this

54
00:03:39,832 --> 00:03:43,886
declarative approach, if someone has implemented those providers

55
00:03:43,918 --> 00:03:47,526
which allow you to work in a declarative way. So just

56
00:03:47,548 --> 00:03:51,126
to recap imperative stands for explicit instructions when

57
00:03:51,228 --> 00:03:54,642
if something goes wrong, you likely going to blame

58
00:03:54,706 --> 00:03:58,454
system because you route so many code. You're a truly amazing developer,

59
00:03:58,502 --> 00:04:02,058
but it doesn't work as expected. But with a

60
00:04:02,064 --> 00:04:06,326
declarative approach you rely on providers

61
00:04:06,358 --> 00:04:09,722
which are doing the job for you. And yeah, you don't really care

62
00:04:09,776 --> 00:04:13,790
what happens under the hood. So in the good news that terraform,

63
00:04:14,210 --> 00:04:17,626
which is open source infrastructure

64
00:04:17,658 --> 00:04:21,738
AWS code software tool region developed by Hashicorp

65
00:04:21,914 --> 00:04:25,090
provide us option to write our

66
00:04:25,160 --> 00:04:28,750
infrastructure AWS code in a declarative approach. And what's

67
00:04:28,830 --> 00:04:32,862
even more important today it supports typescript

68
00:04:33,006 --> 00:04:36,774
and more than 1000 providers. So or better to say that

69
00:04:36,812 --> 00:04:41,314
CDK, which is cloud development kit developed by AWS,

70
00:04:41,362 --> 00:04:45,286
supports typescript. And in

71
00:04:45,308 --> 00:04:49,622
the next 30 minutes or so we're going to build production

72
00:04:49,686 --> 00:04:53,242
ready infrastructure for our front end application.

73
00:04:53,376 --> 00:04:57,814
I will be using react as a boilerplate

74
00:04:57,862 --> 00:05:01,246
for the application itself, but you can use whatever you

75
00:05:01,268 --> 00:05:04,670
prefer if you want to do it on view framework or

76
00:05:04,740 --> 00:05:08,350
handguard, whatever, any framework you choose. It's going to work for

77
00:05:08,500 --> 00:05:11,520
any Javascript application.

78
00:05:13,250 --> 00:05:16,754
So yeah, I think we can start.

79
00:05:16,952 --> 00:05:20,494
And to start with, we're going to generate

80
00:05:20,542 --> 00:05:24,142
the project and it's actually only one time when we're going to type the react

81
00:05:24,206 --> 00:05:28,550
itself. So I'm going to use react create up to

82
00:05:28,620 --> 00:05:32,230
generate the basic project. I call it IAC talk demo

83
00:05:32,300 --> 00:05:35,814
project. I'm passing these template which is typescript and

84
00:05:35,932 --> 00:05:39,274
after command executed and finished we should be able

85
00:05:39,312 --> 00:05:43,420
to see this familiar for many of us website

86
00:05:44,670 --> 00:05:48,214
if you've done it, we ready to start creating

87
00:05:48,262 --> 00:05:52,718
our infrastructures. We have like prepared project.

88
00:05:52,884 --> 00:05:56,910
So as a prerequirement we need to install CDK CLI

89
00:05:57,570 --> 00:06:01,694
and you can install it globally on your laptop or you can have it per

90
00:06:01,732 --> 00:06:04,178
project, it's up to you.

91
00:06:04,344 --> 00:06:09,166
So once we have it, we can run CDKTF

92
00:06:09,198 --> 00:06:12,606
to generate the terraform polar plate,

93
00:06:12,638 --> 00:06:17,026
but before we need to create the terraform folder where

94
00:06:17,048 --> 00:06:20,722
we're going to do all this magic. So we are running CDKTF

95
00:06:20,786 --> 00:06:24,086
init and passing to play typescript similarly as what we

96
00:06:24,108 --> 00:06:27,186
have done with the reactreate app. And yeah, it asks

97
00:06:27,218 --> 00:06:31,914
us for the project name. We think that terraform as

98
00:06:31,952 --> 00:06:36,330
a default name of our folder and it starts execution

99
00:06:36,990 --> 00:06:40,702
after this you're going to see some failures. No worries. It's just

100
00:06:40,756 --> 00:06:44,842
because terraform CLI probably not expecting

101
00:06:44,906 --> 00:06:48,560
that there will be other typescript project

102
00:06:50,290 --> 00:06:53,682
in the same place, but it's really easy to fix. These are

103
00:06:53,736 --> 00:06:57,362
related to our react project, those errors. So we just need to

104
00:06:57,416 --> 00:07:01,314
fix our TS config and add skip leap check with

105
00:07:01,352 --> 00:07:05,266
the flag true and after that everything will be

106
00:07:05,288 --> 00:07:09,654
okay. So I'm passing Skiplab check true and

107
00:07:09,852 --> 00:07:14,200
after that you're going to see that now

108
00:07:14,650 --> 00:07:18,278
we have terraform folder and we have main TS file.

109
00:07:18,374 --> 00:07:22,550
This main TS file we will be modifying and writing

110
00:07:22,630 --> 00:07:26,154
infrastructure in. As you can see it's just

111
00:07:26,192 --> 00:07:29,946
a class which is extend from the terraform stack and

112
00:07:30,048 --> 00:07:33,774
yeah, as I said, everything. What we're going to do we're going to do here

113
00:07:33,812 --> 00:07:37,902
in these file, but later you can create let's say source folder and

114
00:07:37,956 --> 00:07:42,830
any subfolders and structure in these way you prefer your infrastructure

115
00:07:43,410 --> 00:07:46,900
because you have a typescript and literally everything is possible.

116
00:07:47,750 --> 00:07:51,710
So now let's

117
00:07:51,790 --> 00:07:55,138
add the provider. As I said, we're going to use AWS as a

118
00:07:55,144 --> 00:08:01,506
cloud provider. So we need to modify our CdK JSON file

119
00:08:01,698 --> 00:08:05,174
and add the provider here I'm going to use AWS one.

120
00:08:05,212 --> 00:08:09,338
These are no other providers required at the moment and we

121
00:08:09,424 --> 00:08:13,210
ready to start. So now let's think about

122
00:08:13,280 --> 00:08:17,114
how our infrastructure going to look like what we actually need from

123
00:08:17,152 --> 00:08:20,678
it. We definitely need to store our

124
00:08:20,864 --> 00:08:24,750
static file somewhere, right? So for these purpose we're going to use s three

125
00:08:24,820 --> 00:08:28,746
which stands for simple storage service provided

126
00:08:28,778 --> 00:08:32,670
by AWS. It has great availability, I think about

127
00:08:32,740 --> 00:08:36,482
99.99% scalability and

128
00:08:36,536 --> 00:08:40,242
all these stuff. But yeah, what's important

129
00:08:40,296 --> 00:08:43,634
for us, it allow us to store files and get access to

130
00:08:43,672 --> 00:08:48,306
them. It even supports some domains. So let's

131
00:08:48,338 --> 00:08:52,614
going to try it and let's going to create code

132
00:08:52,652 --> 00:08:56,226
for it. So we're going to import AWS provider

133
00:08:56,258 --> 00:09:01,754
and s three bucket provider from generated providers which

134
00:09:01,792 --> 00:09:05,402
are available for us because in the previous slide we have

135
00:09:05,456 --> 00:09:08,938
added them to the list of providers. I'm going to

136
00:09:08,944 --> 00:09:12,638
use bucket name as my domain name because we building

137
00:09:12,724 --> 00:09:15,946
the real infrastructure.

138
00:09:16,138 --> 00:09:19,214
So I think it makes sense.

139
00:09:19,412 --> 00:09:23,570
You can use as many providers as you like in your configurations.

140
00:09:24,630 --> 00:09:28,286
You can use any regions you prefer for your s three bucket.

141
00:09:28,398 --> 00:09:31,602
But just keep in mind that as

142
00:09:31,656 --> 00:09:35,554
later on we will be using the provider for ACM to

143
00:09:35,592 --> 00:09:39,350
issue SSL certificate. AWS requires us

144
00:09:39,420 --> 00:09:43,030
east one provider. So if you're going to use a different region

145
00:09:44,250 --> 00:09:47,654
for your provider for s three bucket, dont forget to create other one

146
00:09:47,772 --> 00:09:51,066
for ACM. But we will cover it a bit later.

147
00:09:51,168 --> 00:09:55,126
Okay, so is a s three bucket everything quite straightforward? We're just passing

148
00:09:55,158 --> 00:09:58,682
our bucket name. We specifying access control list as public read

149
00:09:58,736 --> 00:10:01,600
because who cares about security, right?

150
00:10:02,530 --> 00:10:06,382
Sorry, I'm making fun. Of course we're going to fix

151
00:10:06,436 --> 00:10:10,094
this a bit later. We're specifying that our s three bucket will be

152
00:10:10,132 --> 00:10:13,694
these website and we're going to have index

153
00:10:13,742 --> 00:10:17,522
HTML AWS index document after

154
00:10:17,576 --> 00:10:20,740
this. What we need to do, we need to run yarn, build,

155
00:10:21,190 --> 00:10:24,402
synthize our code, go to the CDK out

156
00:10:24,456 --> 00:10:28,342
folder and run following comments. So we

157
00:10:28,396 --> 00:10:32,018
start with init. This is one time comment because we're

158
00:10:32,034 --> 00:10:35,670
just starting. We need to run it later on. We can

159
00:10:35,820 --> 00:10:39,020
continue only with plan and apply plan.

160
00:10:39,390 --> 00:10:43,146
It's not the same as validation, but it

161
00:10:43,168 --> 00:10:46,714
just shows you what will be planned to

162
00:10:46,752 --> 00:10:50,566
apply with your infrastructure, what state

163
00:10:50,608 --> 00:10:53,982
you plan for the next apply and apply.

164
00:10:54,036 --> 00:10:56,718
It's basically command to apply your changes.

165
00:10:56,804 --> 00:10:59,998
Okay. So if you run them, you're going to

166
00:11:00,004 --> 00:11:02,990
see such output in your terminal. Thank you.

167
00:11:03,060 --> 00:11:06,990
That website, endpoint will be this domain.

168
00:11:07,150 --> 00:11:10,754
And actually now what we can do, we can

169
00:11:10,792 --> 00:11:14,530
try to build our project. These is a react project. So we

170
00:11:14,600 --> 00:11:18,374
go out from the terraform folder back to our

171
00:11:18,412 --> 00:11:22,374
application folder and we're going to copy everything to

172
00:11:22,412 --> 00:11:25,526
our s three bucket. And with the deployment state I would like

173
00:11:25,548 --> 00:11:29,194
to highlight few bits actually. Deployment can

174
00:11:29,232 --> 00:11:33,066
be done with the infrastructure together. Terraform can handle it.

175
00:11:33,168 --> 00:11:36,826
But in this particular case I think

176
00:11:36,848 --> 00:11:40,846
it's a bit pointless because you can expect

177
00:11:40,948 --> 00:11:45,440
deployments, I dont know, in a more frequent manner. And usually

178
00:11:46,370 --> 00:11:49,838
you're going to have either some

179
00:11:50,004 --> 00:11:52,298
CI integration for your deployments,

180
00:11:52,474 --> 00:11:55,934
separate one, or probably even some deployment

181
00:11:55,982 --> 00:11:59,714
dashboard. It depends on your preferences. So usually those

182
00:11:59,752 --> 00:12:03,954
things are separated and we're going to keep these separated here too. So we

183
00:12:04,072 --> 00:12:07,846
will be used just command line instruction and

184
00:12:07,868 --> 00:12:12,066
going to use AWS CLI. So you need to have preinstalled AWS ClI

185
00:12:12,098 --> 00:12:16,194
to execute this command. But yeah, basically we're just saying AWS

186
00:12:16,242 --> 00:12:19,866
s three sync, passing the build folder which we would like to put to

187
00:12:19,888 --> 00:12:23,578
the s three bucket and specifying our s these bucket name

188
00:12:23,664 --> 00:12:27,210
which we just have created. We're also passing the access control

189
00:12:27,280 --> 00:12:31,426
list as public read, same as we've done it previously.

190
00:12:31,558 --> 00:12:34,254
As I said, we're going to code it a bit later.

191
00:12:34,452 --> 00:12:37,982
So if we run it now we can go to the

192
00:12:38,036 --> 00:12:41,934
bucket name s three Amazon Aws.com

193
00:12:41,972 --> 00:12:45,060
index HTML and see that our website is available.

194
00:12:45,430 --> 00:12:49,074
And let me congrats you because

195
00:12:49,272 --> 00:12:53,380
that's a great achievement we just implemented. Probably as simple as possible,

196
00:12:54,230 --> 00:12:58,406
but our own infrastructure with code for

197
00:12:58,428 --> 00:13:01,606
the front end application. But to make

198
00:13:01,628 --> 00:13:05,142
it now, to make it more production ready, we need to

199
00:13:05,196 --> 00:13:08,598
connect it with real domain name. Right. So for this we're

200
00:13:08,614 --> 00:13:15,958
going to use route 53, which is domain

201
00:13:15,974 --> 00:13:20,730
name system service provider by AWS DNS

202
00:13:20,810 --> 00:13:24,560
in short. And yeah,

203
00:13:25,650 --> 00:13:29,642
let's have a look on our user

204
00:13:29,706 --> 00:13:33,666
flow in this case. So basically users, they're going

205
00:13:33,688 --> 00:13:37,426
to write WW, whatever our domain is, they will

206
00:13:37,448 --> 00:13:41,134
be later transferred to the AWS private infrastructure,

207
00:13:41,182 --> 00:13:45,042
which is going to allow us our call to their route 53.

208
00:13:45,096 --> 00:13:48,694
And route 53 will be aliasing our users to the s

209
00:13:48,732 --> 00:13:52,214
three bucket. Okay, so now as

210
00:13:52,252 --> 00:13:55,830
we know what we're going to do, we can build it for this.

211
00:13:55,900 --> 00:14:00,170
We're going to import route 53 zone and route 53

212
00:14:00,240 --> 00:14:04,026
record and going to create initially hosted zone for

213
00:14:04,048 --> 00:14:08,086
which we need just pass these provider and the domain host.

214
00:14:08,198 --> 00:14:12,010
This is domain host because I'm going to create our domain

215
00:14:12,090 --> 00:14:15,774
actually to be a subdomain of these main domain if it makes

216
00:14:15,812 --> 00:14:19,150
sense for you. And we're going to use a record.

217
00:14:19,300 --> 00:14:23,022
So again, we creating root 53

218
00:14:23,076 --> 00:14:26,594
records, passing our domain name and specifying the

219
00:14:26,632 --> 00:14:30,850
behavior that it's going to alias our user to the bucket.

220
00:14:32,950 --> 00:14:36,482
We run again yarn, build yarn scenes from the terraform folder,

221
00:14:36,546 --> 00:14:40,022
go to the CDKTF out run, plan and apply.

222
00:14:40,156 --> 00:14:45,622
And yeah, our state will

223
00:14:45,676 --> 00:14:49,046
be applied. But during this execution,

224
00:14:49,158 --> 00:14:52,874
these time you will see that

225
00:14:53,072 --> 00:14:57,082
apply staff going to fail on

226
00:14:57,136 --> 00:15:00,746
the very last part. And the reason for

227
00:15:00,768 --> 00:15:04,542
this, I did it intentionally. Sorry, let me probably show it a bit more.

228
00:15:04,596 --> 00:15:07,982
Yeah, so it fails and fails on the validation step.

229
00:15:08,116 --> 00:15:11,642
And the reason for this, because intentionally

230
00:15:11,706 --> 00:15:15,486
I bought domain not on AWS itself. I bought

231
00:15:15,518 --> 00:15:19,170
it from the different domain provider, which is I think quite common

232
00:15:19,240 --> 00:15:22,500
case. And you need to remember that

233
00:15:22,950 --> 00:15:26,498
youll need to meet them somehow. Right together. So let's have a look what we

234
00:15:26,504 --> 00:15:30,166
have created on AWS. And I think it's going

235
00:15:30,188 --> 00:15:34,002
to be clear. So we go to the route 53, we see that hosted zone

236
00:15:34,066 --> 00:15:37,538
actually already created. And in this hosted zone we're

237
00:15:37,554 --> 00:15:41,094
going to see that there are even records created. There will be two default

238
00:15:41,142 --> 00:15:45,546
records and one a record. So as soon as you

239
00:15:45,568 --> 00:15:49,482
see ns and so records, they are created by default and a record

240
00:15:49,536 --> 00:15:53,486
is what we have created. So now from the NS record we need to

241
00:15:53,508 --> 00:15:56,702
copy NS values and add

242
00:15:56,756 --> 00:16:00,910
them to our domain provider. If you use quite popular domain provider

243
00:16:01,250 --> 00:16:05,194
and have provider for this in terraform, you can even handle

244
00:16:05,242 --> 00:16:08,946
this terraform. But it is one time instruction so we can even do

245
00:16:08,968 --> 00:16:12,414
it manually. Like what I going to do because my domain provides russian

246
00:16:12,462 --> 00:16:16,146
one and it's not very popular. These don't have any IP

247
00:16:16,178 --> 00:16:20,050
configuration. I don't think they even support updates

248
00:16:20,130 --> 00:16:23,160
with I don't know, rest API or something.

249
00:16:24,410 --> 00:16:27,958
I really think they not but yeah. So I'm going to do

250
00:16:27,964 --> 00:16:31,654
it manually. I'm just adding my NS servers there. I'm pressing

251
00:16:31,702 --> 00:16:35,686
save and I need to wait 510 minutes till

252
00:16:35,718 --> 00:16:40,010
NS servers will be updated. And as soon as they are updated

253
00:16:40,910 --> 00:16:44,462
we're ready to run terraform apply again. There is no need to run any

254
00:16:44,516 --> 00:16:47,790
other commands aws we haven't done any changes

255
00:16:47,860 --> 00:16:50,894
so there's no reasons to build it again or something.

256
00:16:51,092 --> 00:16:55,138
So we're running apply again. It's asking

257
00:16:55,224 --> 00:16:59,346
do we want to add these changes. But this time

258
00:16:59,528 --> 00:17:03,410
you're going to see that it's going to be completed successfully.

259
00:17:03,830 --> 00:17:07,446
So it means now we

260
00:17:07,468 --> 00:17:10,838
can open our domain and see that our website

261
00:17:10,924 --> 00:17:12,200
available here,

262
00:17:14,250 --> 00:17:17,878
but still, right. To make it production ready

263
00:17:18,044 --> 00:17:21,160
we need a few things.

264
00:17:21,690 --> 00:17:25,546
I may think that we need at least SSL certificate to make it

265
00:17:25,648 --> 00:17:29,034
secure here. And I think

266
00:17:29,072 --> 00:17:33,274
we need to make it more performant, right because currently we have created

267
00:17:33,322 --> 00:17:36,634
our website and put it to the s three bucket

268
00:17:36,682 --> 00:17:41,262
which is available only in United States because

269
00:17:41,316 --> 00:17:44,160
we used us east region one.

270
00:17:45,570 --> 00:17:49,794
And you can imagine that John Trip won't be so

271
00:17:49,832 --> 00:17:53,442
fast as we may expect to be to

272
00:17:53,496 --> 00:17:57,014
edge locations, right? So we can need to take

273
00:17:57,052 --> 00:18:01,714
advantage of cdms and distribute

274
00:18:01,762 --> 00:18:06,022
our code across different age locations so our

275
00:18:06,156 --> 00:18:10,330
users can have best

276
00:18:10,400 --> 00:18:13,850
performance possible to fetch our website.

277
00:18:14,000 --> 00:18:19,574
So let's try to implement it. For this we're going to use previous

278
00:18:19,622 --> 00:18:23,306
one. For this we're going to use Cloudfront and AWS certificate

279
00:18:23,338 --> 00:18:27,434
manager. These cloudfront is can

280
00:18:27,482 --> 00:18:28,350
provider,

281
00:18:32,690 --> 00:18:36,446
can stands for content delivery network and certificate manager

282
00:18:36,478 --> 00:18:40,126
will be responsible to provide to issue SSL

283
00:18:40,158 --> 00:18:43,060
certificate which we will assign to the cloud front.

284
00:18:43,590 --> 00:18:47,234
Cool. Let's have a look on our infrastructure diagram one more

285
00:18:47,272 --> 00:18:51,814
time. Again we have route 53, we have cloud dont but

286
00:18:51,852 --> 00:18:55,350
now. So route 53 instead of elastic directly to the s three will be

287
00:18:55,420 --> 00:18:59,654
redirecting to closed edge location available with

288
00:18:59,692 --> 00:19:03,082
cloud front and cloud front itself will be responsible to retrieve object

289
00:19:03,136 --> 00:19:07,718
for caching during cache invalidation or for the very first requests.

290
00:19:07,894 --> 00:19:11,574
So it also going to have certificate

291
00:19:11,622 --> 00:19:15,374
issued by ICM and to create

292
00:19:15,412 --> 00:19:17,310
it. Let's start with a certificate.

293
00:19:17,730 --> 00:19:22,846
We gonna create certificate

294
00:19:22,878 --> 00:19:27,134
with ACM certificate provider. We specifying wildcard

295
00:19:27,182 --> 00:19:31,106
here because I would like to issue these certificate for all

296
00:19:31,288 --> 00:19:34,900
subdomains. I'm creating validation record

297
00:19:35,610 --> 00:19:39,366
and after this I'm creating the validation itself. Passing the

298
00:19:39,468 --> 00:19:43,782
record and passing the certificate once it's ready we

299
00:19:43,836 --> 00:19:47,926
can create cloud from distribution and assign it. So with

300
00:19:47,948 --> 00:19:51,066
the cloud from distribution we just specifying the origin,

301
00:19:51,168 --> 00:19:54,822
passing our bucket

302
00:19:54,966 --> 00:19:58,966
and domain name. After this we're going to specify default root

303
00:19:58,998 --> 00:20:01,854
object and saying that there is no any restrictions yet.

304
00:20:01,972 --> 00:20:06,606
You can later assign any restrictions you

305
00:20:06,628 --> 00:20:10,830
may have. For example if you youll like to disable

306
00:20:12,470 --> 00:20:15,554
certain countries because of,

307
00:20:15,592 --> 00:20:19,278
I don't know, maybe youll don't have rights

308
00:20:19,294 --> 00:20:22,738
to launch on these or something, whatever youll call.

309
00:20:22,904 --> 00:20:26,198
And we're going to specify default cache behavior which is going

310
00:20:26,204 --> 00:20:30,102
to be for get a hat and options methods only

311
00:20:30,236 --> 00:20:35,526
because we don't really need to have it for post or

312
00:20:35,548 --> 00:20:38,774
something as it has this infrastructure for the

313
00:20:38,812 --> 00:20:42,842
front end only. We're going to redirect everyone to steps as we have now

314
00:20:42,896 --> 00:20:46,394
issued certificate. Why not to use it? We're specifying the

315
00:20:46,432 --> 00:20:50,162
default ETL as one day in seconds

316
00:20:50,246 --> 00:20:53,582
and we're not specifying order

317
00:20:53,636 --> 00:20:57,578
cache behavior yet. And actually order cache behavior

318
00:20:57,674 --> 00:21:01,386
is responsible for override. So for example you can have default cache

319
00:21:01,418 --> 00:21:04,830
behavior for everything, let's say to be cached for one day,

320
00:21:04,900 --> 00:21:08,718
but specific folder you want to be cached only for 1 minute or let's

321
00:21:08,734 --> 00:21:12,718
say forever, you can list it in order cache behavior.

322
00:21:12,814 --> 00:21:15,922
You also can say that index HTML shouldn't be cached at all.

323
00:21:15,976 --> 00:21:17,780
And yeah that's also possible.

324
00:21:19,590 --> 00:21:23,910
Yeah we are assigning viewer certificate, our ACM certificate

325
00:21:24,330 --> 00:21:27,918
and we're going to change route 53. Instead of aliasing

326
00:21:27,954 --> 00:21:31,418
to the s these bucket like previously, now it's going

327
00:21:31,424 --> 00:21:35,354
to be alias users to the cloud dont

328
00:21:35,392 --> 00:21:39,366
distribution. So we specify cloud from distribution name and hosted

329
00:21:39,398 --> 00:21:43,566
zone id. As soon as we're ready we can

330
00:21:43,668 --> 00:21:47,440
again run build scenes and terraform plan and apply

331
00:21:48,690 --> 00:21:52,494
and magic happens. Everything should pass successfully and you

332
00:21:52,532 --> 00:21:55,874
should be able to open the website and this time you're going to see that

333
00:21:55,912 --> 00:21:59,714
it is secure. And moreover it wasn't fetched from the

334
00:21:59,752 --> 00:22:03,586
United okay, for very first call, probably it still was fetched from the

335
00:22:03,768 --> 00:22:07,318
United States s these bucket, but in general

336
00:22:07,404 --> 00:22:11,720
it's now fetched from the cloud front. So it's way more,

337
00:22:12,650 --> 00:22:16,082
yeah it's distributed across all edge automation

338
00:22:16,146 --> 00:22:20,362
AWS support and yeah

339
00:22:20,496 --> 00:22:23,626
that's awesome. And now I think it's the time just

340
00:22:23,648 --> 00:22:26,886
to cover the security part because we skipped at the beginning

341
00:22:26,918 --> 00:22:30,018
of the talk, right. So we'll

342
00:22:30,054 --> 00:22:32,890
use one more thing which is called origin access identity.

343
00:22:33,050 --> 00:22:36,430
So let me show you diagram

344
00:22:37,810 --> 00:22:41,806
to help you understand how exactly it's going to

345
00:22:41,828 --> 00:22:45,362
work. So as you can see, not many things

346
00:22:45,416 --> 00:22:49,570
changed, but now Cloudfront

347
00:22:50,470 --> 00:22:54,206
going to retrieve objects for caching from the s three as previously.

348
00:22:54,318 --> 00:22:58,098
But this time s three bucket going to have some bucket policies

349
00:22:58,194 --> 00:23:02,440
which will be allowing access to anyone who tries to

350
00:23:03,850 --> 00:23:09,062
perform some operations on the s three bucket to

351
00:23:09,116 --> 00:23:12,874
only those who have origin access identity. It means Cloudfront should have

352
00:23:12,912 --> 00:23:16,246
origin access identity specific one which will be listed

353
00:23:16,278 --> 00:23:19,146
in bucket policies to have access to it. Okay,

354
00:23:19,328 --> 00:23:23,146
so our s these bucket no longer will be publicly

355
00:23:23,178 --> 00:23:26,766
available. And yeah, it's going

356
00:23:26,788 --> 00:23:29,310
to be our complete infrastructure.

357
00:23:29,890 --> 00:23:33,474
So to achieve that, what we need to do, we need to create origin access

358
00:23:33,512 --> 00:23:37,118
identity here we need to create policy document.

359
00:23:37,214 --> 00:23:39,330
Again, sorry, one route,

360
00:23:41,430 --> 00:23:45,122
probably worse to mention it early, but please

361
00:23:45,176 --> 00:23:48,438
don't be scared if you see some configuration which you don't really understand

362
00:23:48,524 --> 00:23:52,600
because they sometimes not really related to the infrastructure AWS code

363
00:23:54,490 --> 00:23:58,310
as a sync, they sometimes related to the cloud provider. In our case

364
00:23:58,380 --> 00:24:02,266
there are quite a few things which are related to the AWS itself

365
00:24:02,368 --> 00:24:06,170
and if you haven't worked with it, you probably

366
00:24:06,240 --> 00:24:10,134
just don't know in which format they want configuration

367
00:24:10,182 --> 00:24:14,158
to be passed in. But it's quite easy to get it from

368
00:24:14,244 --> 00:24:18,026
looking to their docs. Plus for each provider

369
00:24:18,218 --> 00:24:22,790
which supported by terraform, on the terraform website you can find reach documentation

370
00:24:22,970 --> 00:24:25,140
which help you to understand everything.

371
00:24:27,750 --> 00:24:31,374
Sorry. So we're creating the policy document,

372
00:24:31,502 --> 00:24:34,978
we specifying that we want to have access to objects. We're specifying that

373
00:24:34,984 --> 00:24:38,390
we want to have access to list of objects.

374
00:24:38,970 --> 00:24:42,358
And after this we creating the s three bucket policy,

375
00:24:42,444 --> 00:24:46,338
assigning the bucket itself and the policy itself. I think it's straightforward.

376
00:24:46,514 --> 00:24:50,282
After we had a look to these diagram and

377
00:24:50,416 --> 00:24:53,654
yeah, we're adding these changes to our SAM certificate

378
00:24:53,702 --> 00:24:57,306
to have this origin access identity. Okay, so it

379
00:24:57,328 --> 00:25:00,906
will be available for the cloud front. Now what we can do,

380
00:25:01,008 --> 00:25:05,194
simplest option, just remove everything what we have previously deployed

381
00:25:05,242 --> 00:25:08,906
to the s three bucket and redeploy it again, this time not specifying KCL

382
00:25:08,938 --> 00:25:12,800
at all. So it will be use default one private one.

383
00:25:13,190 --> 00:25:17,202
And if you've done it, we can try

384
00:25:17,256 --> 00:25:21,380
to open the s three domain again and see that

385
00:25:22,150 --> 00:25:25,998
we have this nice access denied

386
00:25:26,094 --> 00:25:30,466
page provided by AWS for us. And when

387
00:25:30,568 --> 00:25:34,322
with a cloud front and route 53 with a regional domain

388
00:25:34,386 --> 00:25:38,094
normal one, everything is okay. So site still operatable.

389
00:25:38,162 --> 00:25:42,134
So all good. So if you're now sweating

390
00:25:42,182 --> 00:25:46,010
as I am, take a deep breath.

391
00:25:46,670 --> 00:25:50,218
We very close to the end of this talk. We're not going

392
00:25:50,224 --> 00:25:54,154
to write infrastructure more during this

393
00:25:54,192 --> 00:25:57,806
talk at least, but there are a few bits which I'd like to

394
00:25:57,828 --> 00:26:01,066
cover with you. And first one is remote backend.

395
00:26:01,098 --> 00:26:04,350
If you remember at the beginning of the talk, when we initialized the project,

396
00:26:04,420 --> 00:26:07,380
we started with a local backend. And I said that, yeah,

397
00:26:08,230 --> 00:26:11,554
if you know what backends in terraform world means, that's great.

398
00:26:11,592 --> 00:26:14,626
If not, we're going to cover it. And it's time to cover it,

399
00:26:14,728 --> 00:26:17,110
because when you work alone,

400
00:26:17,770 --> 00:26:21,142
in theory, yeah, you can handle everything and store

401
00:26:21,196 --> 00:26:24,680
it on your local machine. But if you work

402
00:26:25,210 --> 00:26:28,860
at least with some other dev or in a team,

403
00:26:30,190 --> 00:26:33,786
you need to store your state of

404
00:26:33,808 --> 00:26:37,402
the Terraform somewhere, right? You probably may think

405
00:26:37,456 --> 00:26:40,910
the first thing about GitHub, but it's not the best idea

406
00:26:40,980 --> 00:26:44,254
because it's certainly going to have some sensitive information.

407
00:26:44,452 --> 00:26:47,982
And terraform provides better options for this.

408
00:26:48,036 --> 00:26:51,614
And it calls back ends. So it

409
00:26:51,652 --> 00:26:55,374
supports various databases, including DynamoDB,

410
00:26:55,502 --> 00:26:58,802
it supports s three bucket. They have even their

411
00:26:58,856 --> 00:27:02,958
own cloud storage for this. So as we started with AWS,

412
00:27:03,054 --> 00:27:06,982
let's stick with this and let's put our back

413
00:27:07,036 --> 00:27:10,866
end on AWS. So let's

414
00:27:10,898 --> 00:27:14,166
create the s three backend. For this we actually need just

415
00:27:14,188 --> 00:27:17,346
three parameters. We need to specify bucket name. It shouldn't

416
00:27:17,378 --> 00:27:20,858
be the same bucket name AWS we store for our application. It's like completely

417
00:27:20,944 --> 00:27:24,250
separate thing. So it can be

418
00:27:24,320 --> 00:27:30,560
completely private, manually created or created with a different terraform project.

419
00:27:31,490 --> 00:27:35,006
We specify key, which is just our name for

420
00:27:35,028 --> 00:27:38,874
the file. Yeah, I just specified infrastructure

421
00:27:38,922 --> 00:27:43,380
as code talk demo project. And again we specify ingredient, which can be any.

422
00:27:44,630 --> 00:27:46,980
After we done with this,

423
00:27:48,470 --> 00:27:52,654
we need to build scenes, of course, and go to the Cdktf

424
00:27:52,702 --> 00:27:56,142
out folder. And here we need to run terraform

425
00:27:56,206 --> 00:27:59,794
init again, this command, if you remember, we have

426
00:27:59,832 --> 00:28:03,014
run at the beginning of the talk, we need to run it again. And this

427
00:28:03,052 --> 00:28:06,886
time it's going to ask us do we want to copy existing state to the

428
00:28:06,908 --> 00:28:10,554
new back end? If answer is yes, local version will

429
00:28:10,592 --> 00:28:13,914
be removed and on our s three bucket there will be this

430
00:28:13,952 --> 00:28:17,674
deployed version. So in this file it's actually just json with

431
00:28:17,712 --> 00:28:21,342
a state describing our current

432
00:28:21,476 --> 00:28:25,534
infrastructure. So now

433
00:28:25,652 --> 00:28:29,754
why typescript? Why we need to use typescript to coding

434
00:28:29,802 --> 00:28:34,018
for our infrastructure. So I think it's important that

435
00:28:34,184 --> 00:28:40,722
there is no new language to learn, because with

436
00:28:40,776 --> 00:28:44,766
terraform previously you need to learn hashicorp

437
00:28:44,798 --> 00:28:48,454
configuration language, which is not that bad. I mean, it's even not

438
00:28:48,492 --> 00:28:51,954
complex at all. It's slightly more complex than YamL or JSon,

439
00:28:52,082 --> 00:28:55,634
not configuration languages, but this one has some loops.

440
00:28:55,762 --> 00:28:59,206
But we are developers, right? And I'm

441
00:28:59,238 --> 00:29:03,654
coding for many years. I really like the power of programming

442
00:29:03,702 --> 00:29:07,562
languages. And that's certainly what I'd like create

443
00:29:07,616 --> 00:29:11,134
my infrastructure in and get all

444
00:29:11,172 --> 00:29:14,926
advantages it shares with me, such as powerful autocomplete and

445
00:29:14,948 --> 00:29:18,510
typings. Because now it's even

446
00:29:18,580 --> 00:29:21,870
way easier to understand what exactly

447
00:29:21,940 --> 00:29:25,102
I need to specify to certain providers.

448
00:29:25,166 --> 00:29:28,526
Because previously I was always needed to visit

449
00:29:28,558 --> 00:29:32,302
the terraform website to check the documentation. Now I can check just typing

450
00:29:32,366 --> 00:29:36,038
send, sometimes there are even comments and yeah,

451
00:29:36,124 --> 00:29:39,666
that's great. It speed up these development.

452
00:29:39,858 --> 00:29:42,310
Plus we have all mature language advantages.

453
00:29:42,970 --> 00:29:46,594
We have, I don't know, like Visa array, all those methods like maps,

454
00:29:46,642 --> 00:29:50,234
reduce, whatever. We have options for code structuring because

455
00:29:50,272 --> 00:29:53,610
we have models. That's something you don't expect

456
00:29:53,680 --> 00:29:57,274
from the hashicorp configuration language. With this

457
00:29:57,312 --> 00:30:00,586
you just store everything in a single folder and you don't know

458
00:30:00,608 --> 00:30:04,454
what depends on what. With a typescript youll have models.

459
00:30:04,502 --> 00:30:07,946
These you can import certain bits, you can share certain bits,

460
00:30:07,978 --> 00:30:12,030
you can create functions which accepting some parameters

461
00:30:12,390 --> 00:30:15,614
and mixing your state, whatever, do any magic

462
00:30:15,662 --> 00:30:19,346
you want. There are way more features available now for

463
00:30:19,368 --> 00:30:23,250
you. And we have new ways of sharing

464
00:30:23,750 --> 00:30:27,602
because previously there were options to share complete models

465
00:30:27,746 --> 00:30:31,254
through terraform ecosystem. Now we have completely new

466
00:30:31,292 --> 00:30:34,610
ecosystem when we're talking about javascript, and I mean NPM.

467
00:30:34,690 --> 00:30:38,454
So we can partially or fully share our infrastructure with reusable

468
00:30:38,502 --> 00:30:41,110
functions, classes,

469
00:30:41,190 --> 00:30:45,910
whatever. We can implement tests for our infrastructure

470
00:30:46,070 --> 00:30:49,094
on the same language on the typescript.

471
00:30:49,222 --> 00:30:53,086
So I think now it's a

472
00:30:53,108 --> 00:30:55,950
big step closer to developers.

473
00:30:56,370 --> 00:30:59,694
And yeah, that's one of the reason why I'm doing this

474
00:30:59,732 --> 00:31:03,070
talk, especially for front end developers, because I found that

475
00:31:03,140 --> 00:31:06,030
of course DevOps and back end developers,

476
00:31:06,610 --> 00:31:09,906
they know what infrastructure is called. Usually they

477
00:31:09,928 --> 00:31:13,122
know what infrastructure is, code is, and why it's needed.

478
00:31:13,256 --> 00:31:16,414
When for many front end engineers

479
00:31:16,462 --> 00:31:19,734
I found that it is still buzzword and I want to change it because

480
00:31:19,772 --> 00:31:23,554
it's very important not only to create the infrastructure

481
00:31:23,602 --> 00:31:26,454
for these website like we just did during this talk,

482
00:31:26,572 --> 00:31:30,214
but create infrastructure for monitoring and alerting.

483
00:31:30,262 --> 00:31:33,802
Let's say we want to specify some

484
00:31:33,856 --> 00:31:37,174
specific conditions to alert with a new relic,

485
00:31:37,222 --> 00:31:40,518
or maybe we want to specify them with sentry. I don't

486
00:31:40,534 --> 00:31:44,266
know, maybe we want to integrate some incident management flow,

487
00:31:44,298 --> 00:31:48,266
including the pager duty for all these things. We can create infrastructure

488
00:31:48,298 --> 00:31:52,762
and we should create infrastructure with any IAC solution.

489
00:31:52,906 --> 00:31:56,050
And again, I would personally recommend terraform.

490
00:31:56,550 --> 00:31:59,806
But let me mention one more thing, because I think it's

491
00:31:59,838 --> 00:32:03,906
incredibly crucial. Terraform itself is quite mature, used in

492
00:32:03,928 --> 00:32:07,094
production. We use it for lots of different services,

493
00:32:07,292 --> 00:32:10,770
but CDK, it's still under active development.

494
00:32:10,850 --> 00:32:14,230
So CDK, it's something what you may expect

495
00:32:14,300 --> 00:32:18,394
changes in because

496
00:32:18,432 --> 00:32:22,006
it's can active development phase. I think it's obvious now it's

497
00:32:22,038 --> 00:32:25,546
in beta, so it's not alpha anymore, which is great.

498
00:32:25,728 --> 00:32:30,390
Still, they have this warning on their GitHub,

499
00:32:30,550 --> 00:32:34,080
so just remember about it. And yeah,

500
00:32:34,610 --> 00:32:38,042
everything. What is generated? I mean all the terraform

501
00:32:38,106 --> 00:32:42,222
output, if it's generated, if it works for you, it's going to work because after

502
00:32:42,276 --> 00:32:46,450
you run scenes youll already generated

503
00:32:47,350 --> 00:32:49,090
terraform JSON file,

504
00:32:51,110 --> 00:32:55,098
which is going to work with the terraform previously, and that's

505
00:32:55,134 --> 00:32:56,280
the stable part.

506
00:32:58,970 --> 00:33:04,342
If it's okay for you, if you're ready to

507
00:33:04,396 --> 00:33:07,430
have some minor issues with CDK,

508
00:33:09,390 --> 00:33:12,682
you please adopt it with your projects. I found it super

509
00:33:12,736 --> 00:33:16,470
useful because I really like power AwS a typescript.

510
00:33:16,630 --> 00:33:19,858
If youll feel that you need more stable solution,

511
00:33:19,974 --> 00:33:23,198
stick with hashicorp configuration language for now and then

512
00:33:23,284 --> 00:33:27,150
migrate partially or fully your infrastructure to the typescript.

513
00:33:27,730 --> 00:33:31,550
Okay, all code samples,

514
00:33:33,010 --> 00:33:36,858
all of them available in this repo.

515
00:33:36,954 --> 00:33:40,622
They cover a full talk. I tried to follow the same

516
00:33:40,676 --> 00:33:45,026
history in comments as we just did it during the presentation.

517
00:33:45,178 --> 00:33:49,106
Plus there is one more repo which I'd like to share with you. Terraform typescript

518
00:33:49,138 --> 00:33:52,630
frontend infrastructure which has slightly more advanced

519
00:33:53,450 --> 00:33:56,754
structuring, so you may use it as a reference

520
00:33:56,802 --> 00:34:00,230
to cool. Thank you so much again,

521
00:34:00,300 --> 00:34:04,086
my name is Dennis. Hope youll enjoy it and see you

522
00:34:04,108 --> 00:34:04,180
later.

