1
00:00:00,730 --> 00:00:04,366
What if you could work with some of the world's most innovative companies,

2
00:00:04,548 --> 00:00:07,338
all from the comfort of a remote workplace?

3
00:00:07,514 --> 00:00:11,294
Andela has matched thousands of technologists across the globe to their

4
00:00:11,332 --> 00:00:14,494
next career adventure. We're empowering new

5
00:00:14,532 --> 00:00:18,094
talent worldwide, from Sao Paulo to Egypt and

6
00:00:18,132 --> 00:00:22,186
Lagos to Warsaw. Now the future of work is yours

7
00:00:22,218 --> 00:00:25,846
to create. Anytime, anywhere. The world is at

8
00:00:25,868 --> 00:00:29,190
your fingertips. This is Andela.

9
00:01:14,610 --> 00:01:18,066
Welcome to a new session of this conference. I'm glad

10
00:01:18,098 --> 00:01:21,590
to be part of a new version of Conf 42 Golan.

11
00:01:21,930 --> 00:01:25,970
This time I'm going to talk about testing using Go language.

12
00:01:26,130 --> 00:01:29,574
The main propose is to present some alternatives

13
00:01:29,622 --> 00:01:33,082
that we can have available and good practices so that

14
00:01:33,136 --> 00:01:36,874
testing our applications becomes a common practice in our

15
00:01:36,912 --> 00:01:40,206
teams. So whether you are a beginner in the go

16
00:01:40,228 --> 00:01:43,534
language or an experienced developer, this talk

17
00:01:43,652 --> 00:01:45,840
could be quite useful for you.

18
00:01:49,010 --> 00:01:52,894
To start, I want to introduce myself. My name is

19
00:01:52,932 --> 00:01:56,866
Francisco Daines, but I really prefer when

20
00:01:56,888 --> 00:01:58,770
the people just call me Dino.

21
00:02:00,470 --> 00:02:03,598
I am a principal software engineer at Walmart Chile.

22
00:02:03,694 --> 00:02:06,914
I'm working in the artificial intelligence

23
00:02:06,962 --> 00:02:10,150
and data exploitation team when

24
00:02:10,220 --> 00:02:13,814
we have a lot of very interesting products and

25
00:02:13,932 --> 00:02:18,298
most of our backend services are developed using

26
00:02:18,384 --> 00:02:21,914
Go language. I have experience in

27
00:02:21,952 --> 00:02:25,562
different languages like Java, C, Javascript and

28
00:02:25,616 --> 00:02:29,050
so many others. I'm using go since

29
00:02:29,120 --> 00:02:32,714
two years ago and I am the maintainer

30
00:02:32,762 --> 00:02:34,190
of Arcgo,

31
00:02:36,370 --> 00:02:39,582
which is a very interesting testing tool

32
00:02:39,716 --> 00:02:42,850
that helps teams to check if their

33
00:02:42,920 --> 00:02:46,270
applications implies with a set of architectural

34
00:02:46,350 --> 00:02:50,114
guidelines. Okay, the first part of

35
00:02:50,152 --> 00:02:53,806
this talk is a brief introduction to application testing.

36
00:02:53,998 --> 00:02:57,606
In this section I'm going to talk about why we should

37
00:02:57,708 --> 00:03:01,046
test our applications and

38
00:03:01,228 --> 00:03:05,154
talking about a few benefits of doing testing

39
00:03:05,282 --> 00:03:09,082
and finally presenting two approaches for planning our

40
00:03:09,136 --> 00:03:12,330
efforts, coding different kind of tests.

41
00:03:12,990 --> 00:03:16,746
So to start, we need to

42
00:03:16,848 --> 00:03:19,820
answer the question, why is testing important?

43
00:03:20,450 --> 00:03:23,802
To explain the importance of testing,

44
00:03:23,866 --> 00:03:27,550
I included this diagram proposed by Ken Beck.

45
00:03:28,050 --> 00:03:32,042
The title of this diagram is the no time for testing

46
00:03:32,106 --> 00:03:35,282
heard spiral. As you

47
00:03:35,336 --> 00:03:38,818
said, it's a very aggressive title and

48
00:03:38,904 --> 00:03:42,546
what it means? Well, the explanation is

49
00:03:42,648 --> 00:03:45,818
the more stress you feel, the less testing

50
00:03:45,854 --> 00:03:49,510
you will do. The less testing you do, the more

51
00:03:49,580 --> 00:03:52,982
errors you will make. And then the more

52
00:03:53,036 --> 00:03:56,822
errors you make, the more stress you feel. And this

53
00:03:56,876 --> 00:04:00,234
will be repeated once and once again in an

54
00:04:00,272 --> 00:04:04,474
infinite loop. This diagram is

55
00:04:04,672 --> 00:04:08,202
presented by Ken Beck in his book the Test

56
00:04:08,256 --> 00:04:12,238
Driven development by example. And it's a

57
00:04:12,244 --> 00:04:16,030
very common situation when we are doing manual testing.

58
00:04:16,370 --> 00:04:20,222
So to break this loop, one thing

59
00:04:20,356 --> 00:04:24,178
that we can do is to have

60
00:04:24,264 --> 00:04:28,690
automated testing as part of our practices.

61
00:04:30,150 --> 00:04:32,850
But why automated tests?

62
00:04:33,270 --> 00:04:36,614
Well, Ken Beck, in his book, in the same

63
00:04:36,652 --> 00:04:40,406
book tries to explain this and this is the

64
00:04:40,428 --> 00:04:44,454
quote. The quote says rather than apply minutes

65
00:04:44,572 --> 00:04:47,930
of suspecting reasoning, we can just ask

66
00:04:48,000 --> 00:04:52,026
the computer by making the change and running the test what

67
00:04:52,048 --> 00:04:55,770
it means. Well, the computer can repeat

68
00:04:56,110 --> 00:04:59,610
once and once again the same test battery,

69
00:05:00,050 --> 00:05:03,262
expecting the same results and in a very

70
00:05:03,316 --> 00:05:07,486
very short time. So we

71
00:05:07,508 --> 00:05:11,054
can make an initial effort creating this

72
00:05:11,092 --> 00:05:14,322
tests and then changing our application,

73
00:05:14,456 --> 00:05:17,586
changing over and over again and running the test

74
00:05:17,688 --> 00:05:21,314
and the expected results should be the

75
00:05:21,352 --> 00:05:24,210
application having the same behavior.

76
00:05:24,710 --> 00:05:28,646
So we

77
00:05:28,668 --> 00:05:32,534
can do this in

78
00:05:32,652 --> 00:05:36,070
can easy way doing automated testing.

79
00:05:36,650 --> 00:05:40,330
So what are the benefits of application testing?

80
00:05:40,750 --> 00:05:44,220
Well, here we have three.

81
00:05:45,230 --> 00:05:49,450
There are a lot of benefits, but those

82
00:05:49,520 --> 00:05:54,250
three are these most important related

83
00:05:54,330 --> 00:05:58,142
to application quality. The first is

84
00:05:58,276 --> 00:06:00,350
to reduce bugs.

85
00:06:01,330 --> 00:06:05,522
Why? Because if we are continuously testing different use

86
00:06:05,576 --> 00:06:07,998
cases for our applications,

87
00:06:08,174 --> 00:06:12,034
then it's more probably to find bugs and

88
00:06:12,072 --> 00:06:15,970
fix them before publishing our software

89
00:06:16,050 --> 00:06:18,710
artifacts into production environments.

90
00:06:19,690 --> 00:06:22,440
The second one is to improve security.

91
00:06:24,330 --> 00:06:28,042
Here we have to think

92
00:06:28,176 --> 00:06:31,482
and consider that every bug that

93
00:06:31,536 --> 00:06:35,482
we brings into production environment can

94
00:06:35,536 --> 00:06:36,140
be,

95
00:06:40,450 --> 00:06:44,302
can be increased the risk of

96
00:06:44,356 --> 00:06:48,590
a security issue. It's not

97
00:06:48,740 --> 00:06:52,882
always that every bug is a security issue,

98
00:06:52,936 --> 00:06:56,786
but we have to think and prepare and

99
00:06:56,968 --> 00:07:00,770
change our mindsets to trying

100
00:07:00,840 --> 00:07:05,302
to avoid as much as possible the

101
00:07:05,356 --> 00:07:07,510
bugs into production environment.

102
00:07:08,250 --> 00:07:09,240
And finally,

103
00:07:11,930 --> 00:07:15,720
testing our applications will increase the software quality

104
00:07:16,650 --> 00:07:20,374
because as we can catch some bugs

105
00:07:20,422 --> 00:07:23,990
as part of our development cycle, we are fixing

106
00:07:24,070 --> 00:07:28,410
them in the same development

107
00:07:29,230 --> 00:07:33,054
flow. Our software products will

108
00:07:33,092 --> 00:07:36,686
be of higher quality compared to products

109
00:07:36,788 --> 00:07:41,040
that have manual testing or maybe

110
00:07:41,570 --> 00:07:44,020
doesn't have testing at all.

111
00:07:46,310 --> 00:07:50,900
Those three benefits are

112
00:07:51,270 --> 00:07:54,674
well knowed by technical people. But how we can

113
00:07:54,712 --> 00:07:59,030
convince business people or stakeholders that

114
00:07:59,180 --> 00:08:02,934
expect we as a teams will

115
00:08:03,052 --> 00:08:07,110
produce different

116
00:08:07,180 --> 00:08:09,530
releases very closely,

117
00:08:10,430 --> 00:08:14,300
one by other. There are two

118
00:08:14,670 --> 00:08:18,170
benefits. I titled this slide the ones

119
00:08:18,240 --> 00:08:21,982
that really matters. But those are the ones that really

120
00:08:22,036 --> 00:08:25,902
matters for business people, for some

121
00:08:25,956 --> 00:08:30,030
kind of stakeholders. The first benefits is

122
00:08:30,100 --> 00:08:34,178
that testing our applications will save

123
00:08:34,264 --> 00:08:36,962
money. Why?

124
00:08:37,096 --> 00:08:40,402
Because increasing the software quality will

125
00:08:40,456 --> 00:08:43,010
reduce these production errors.

126
00:08:43,510 --> 00:08:47,938
And then if you have less errors in production,

127
00:08:48,114 --> 00:08:51,682
we will spend tests time in debugging

128
00:08:51,746 --> 00:08:55,640
and finding and fixing those issues

129
00:08:56,170 --> 00:08:59,386
so that we can focus our time in

130
00:08:59,408 --> 00:09:00,940
adding value to the business.

131
00:09:04,270 --> 00:09:07,658
This will save money. And the second one

132
00:09:07,744 --> 00:09:12,286
is even more important than the

133
00:09:12,308 --> 00:09:16,030
first. Doing testing in our

134
00:09:16,100 --> 00:09:19,630
applications will implies the customer satisfaction.

135
00:09:20,370 --> 00:09:24,254
Why? Because increasing deployment frequency

136
00:09:24,382 --> 00:09:27,842
and releasing higher quality products should

137
00:09:27,896 --> 00:09:31,250
improve our customer satisfaction and loyalty.

138
00:09:31,590 --> 00:09:35,294
So we can use these two benefits

139
00:09:35,432 --> 00:09:39,750
to convince business people for doing

140
00:09:39,820 --> 00:09:43,938
testing as part of our deployment and development.

141
00:09:44,034 --> 00:09:47,510
Sorry, of part of our development practices.

142
00:09:49,790 --> 00:09:53,286
Well, finally there are two different testing

143
00:09:53,318 --> 00:09:56,890
approaches. Those are the most popular approaches.

144
00:09:57,470 --> 00:10:00,902
The first one is the testing pyramid proposed

145
00:10:00,966 --> 00:10:04,746
by Mycom and the second one is the testing trophy

146
00:10:04,858 --> 00:10:08,880
proposed by Kensey. Dots in both

147
00:10:09,970 --> 00:10:13,330
approaches we have different kind of tests.

148
00:10:13,750 --> 00:10:17,582
The difference between these approaches

149
00:10:17,646 --> 00:10:21,502
is how many effort

150
00:10:21,646 --> 00:10:24,738
we will spend in those

151
00:10:24,824 --> 00:10:26,690
different kind of tests.

152
00:10:28,470 --> 00:10:31,798
Mycon focus the effort on

153
00:10:31,884 --> 00:10:35,890
have faster feedback from testing.

154
00:10:35,970 --> 00:10:39,674
So that's the reason why the

155
00:10:39,712 --> 00:10:45,130
unit test have a lot of tests.

156
00:10:45,710 --> 00:10:49,274
This is the representation of having more tests than service

157
00:10:49,392 --> 00:10:53,182
test and UI test because are

158
00:10:53,236 --> 00:10:56,750
more easy to code and are faster to run.

159
00:10:56,900 --> 00:11:00,474
So then we will have a faster

160
00:11:00,522 --> 00:11:04,322
feedback. On the other

161
00:11:04,376 --> 00:11:07,860
side. Kensidots prefers to

162
00:11:09,750 --> 00:11:14,194
focus our effort in integration testing because

163
00:11:14,312 --> 00:11:17,990
those are the harder and the more complex

164
00:11:18,490 --> 00:11:21,814
test and then we

165
00:11:21,932 --> 00:11:27,534
will testing more realistic

166
00:11:27,602 --> 00:11:31,226
use cases. And of course we have end to

167
00:11:31,248 --> 00:11:34,220
end and unit test and static ones.

168
00:11:34,910 --> 00:11:38,374
But there are just different approaches.

169
00:11:38,502 --> 00:11:42,174
You can choose whatever you

170
00:11:42,212 --> 00:11:45,742
prefer. There is no rule of thumb to select

171
00:11:45,796 --> 00:11:50,074
the right testing approach because there is no a right testing

172
00:11:50,122 --> 00:11:53,966
approach. And this talk is about unit

173
00:11:53,998 --> 00:11:58,034
testing. So it

174
00:11:58,072 --> 00:12:01,410
doesn't matter what kind or what

175
00:12:01,480 --> 00:12:04,660
approach for testing you will select.

176
00:12:05,290 --> 00:12:09,362
Well, the next section is testing go first steps

177
00:12:09,506 --> 00:12:13,590
in this section we are going to look at

178
00:12:13,740 --> 00:12:17,362
the testing tool provided by go language

179
00:12:17,506 --> 00:12:21,242
and standard package that we can use

180
00:12:21,296 --> 00:12:23,930
to create unit tests.

181
00:12:24,430 --> 00:12:28,262
So our first steps includes knowing

182
00:12:28,326 --> 00:12:32,526
two things. First is the go testing tool.

183
00:12:32,708 --> 00:12:36,026
It's a standard tool to automate the testing

184
00:12:36,138 --> 00:12:39,534
for desired packages. It's included as part

185
00:12:39,572 --> 00:12:43,266
of go language so you

186
00:12:43,368 --> 00:12:47,170
have nothing too extra to install in

187
00:12:47,320 --> 00:12:50,834
your computer. The second one is the

188
00:12:50,872 --> 00:12:52,050
testing package.

189
00:12:54,070 --> 00:12:58,626
As the go testing tool. The testing package is includes

190
00:12:58,818 --> 00:13:02,006
as part of these Go language, one of

191
00:13:02,028 --> 00:13:05,362
the standard packages. It provides

192
00:13:05,426 --> 00:13:08,822
features to create unit test benchmarks and

193
00:13:08,876 --> 00:13:12,554
fusity test. But as part

194
00:13:12,592 --> 00:13:17,770
of this talk, we are only used

195
00:13:17,840 --> 00:13:22,378
the unit test provided by this package.

196
00:13:22,554 --> 00:13:26,574
Okay, for more information, of course you can go

197
00:13:26,612 --> 00:13:30,266
to the Godoc web page for the testing

198
00:13:30,298 --> 00:13:33,330
package or use the command line go help

199
00:13:33,400 --> 00:13:36,926
test for the go testing

200
00:13:36,958 --> 00:13:37,540
tool.

201
00:13:39,830 --> 00:13:40,580
Okay,

202
00:13:42,870 --> 00:13:46,838
we have some minutes to create

203
00:13:47,004 --> 00:13:51,078
a demo to use the go testing tool and the

204
00:13:51,164 --> 00:13:54,280
testing package. Okay guys,

205
00:13:55,130 --> 00:13:58,546
we have a very simple project for the demos.

206
00:13:58,658 --> 00:14:00,780
It's hello world project.

207
00:14:01,390 --> 00:14:05,238
Here I created an examples package

208
00:14:05,334 --> 00:14:08,666
and in this examples package I created a

209
00:14:08,688 --> 00:14:13,230
very simple function. It's an add numbers function which

210
00:14:13,300 --> 00:14:16,378
receives a list of numbers and adds

211
00:14:16,474 --> 00:14:20,000
all of these numbers and return the result.

212
00:14:20,850 --> 00:14:24,500
To test this function,

213
00:14:24,870 --> 00:14:28,514
we need to create a testing file. First by

214
00:14:28,552 --> 00:14:33,220
conventions we try to follow

215
00:14:35,350 --> 00:14:39,174
a naming conventions. It's the name of the

216
00:14:39,212 --> 00:14:42,760
file followed by

217
00:14:43,130 --> 00:14:47,302
underscore test all the files that

218
00:14:47,356 --> 00:14:50,842
ends with underscore test will be used by

219
00:14:50,896 --> 00:14:54,618
go testing tool. Well then

220
00:14:54,704 --> 00:14:58,410
we need to create a function. The name of this

221
00:14:58,480 --> 00:15:02,302
function must start with test and then

222
00:15:02,436 --> 00:15:05,786
the name of the function that we are testing.

223
00:15:05,898 --> 00:15:09,342
Okay, so we are creating the test as

224
00:15:09,396 --> 00:15:13,314
numbers function and the parameters of

225
00:15:13,352 --> 00:15:16,994
these function are one

226
00:15:17,112 --> 00:15:20,180
variable of type testing t.

227
00:15:20,630 --> 00:15:23,826
This is used to tell the

228
00:15:23,928 --> 00:15:28,374
go testing tool that this is a

229
00:15:28,412 --> 00:15:31,240
simple test unit test. Okay.

230
00:15:31,770 --> 00:15:36,982
And then inside these test we can set

231
00:15:37,036 --> 00:15:41,162
the expected result and

232
00:15:41,216 --> 00:15:44,940
set it with a number, for example 55

233
00:15:45,310 --> 00:15:49,420
and then call the function that

234
00:15:50,210 --> 00:15:54,160
we want to test, for example result.

235
00:15:55,250 --> 00:15:59,502
There we assign it to numbers

236
00:15:59,636 --> 00:16:04,466
and the numbers from one to that.

237
00:16:04,648 --> 00:16:08,978
Okay, and finally this checking,

238
00:16:09,144 --> 00:16:12,802
we need to check if these result is the expected value.

239
00:16:12,936 --> 00:16:16,402
So we can use a simple if sentence.

240
00:16:16,546 --> 00:16:19,638
If the expected result

241
00:16:19,804 --> 00:16:23,080
is different than the given result,

242
00:16:23,770 --> 00:16:27,898
then we can tell the tests to

243
00:16:27,984 --> 00:16:31,882
fail. And that

244
00:16:31,936 --> 00:16:36,202
is we can run the test using the

245
00:16:36,256 --> 00:16:43,054
id or using the

246
00:16:43,092 --> 00:16:46,586
terminal using the go testing

247
00:16:46,618 --> 00:16:50,106
tool. Go test and passing.

248
00:16:50,298 --> 00:16:56,078
Sorry, my mic is having troubles passing

249
00:16:56,174 --> 00:17:00,018
the root package and this will run

250
00:17:00,104 --> 00:17:03,150
all the tests under this package.

251
00:17:03,310 --> 00:17:06,998
Okay, in this case, the go testing tool is

252
00:17:07,084 --> 00:17:10,342
telling that the root package has no test

253
00:17:10,396 --> 00:17:14,354
files and the examples

254
00:17:14,402 --> 00:17:20,810
package have some

255
00:17:20,880 --> 00:17:24,220
test inside. Okay, well,

256
00:17:24,590 --> 00:17:27,910
what happens if I change the behavior

257
00:17:27,990 --> 00:17:32,782
of my function and for example change

258
00:17:32,916 --> 00:17:36,814
the return value and there is not the addition of

259
00:17:36,852 --> 00:17:40,286
all the numbers, it's adding all the

260
00:17:40,308 --> 00:17:43,074
numbers but plus one.

261
00:17:43,192 --> 00:17:47,460
Okay, in this case, if I run my test,

262
00:17:48,790 --> 00:17:52,402
the go testing tool tell me that one

263
00:17:52,456 --> 00:17:55,830
test fails, the test at numbers is

264
00:17:55,900 --> 00:17:58,360
failing. But just this,

265
00:17:59,930 --> 00:18:04,070
most of the time I need more information. But what

266
00:18:04,140 --> 00:18:07,566
happened, why the test fails.

267
00:18:07,698 --> 00:18:10,858
So in this case, I prefer to not use

268
00:18:10,944 --> 00:18:14,250
this sentence, the t fail and use

269
00:18:14,320 --> 00:18:18,342
t error f. With t error

270
00:18:18,406 --> 00:18:22,014
f, I can pass a message to the go

271
00:18:22,052 --> 00:18:26,138
testing tool. In this case, I compare

272
00:18:26,234 --> 00:18:30,240
expected value and

273
00:18:32,210 --> 00:18:34,880
what I got. In this case,

274
00:18:36,310 --> 00:18:39,060
expected result and result.

275
00:18:39,830 --> 00:18:43,554
So how I can see this

276
00:18:43,592 --> 00:18:47,494
in action? Well, we can run the

277
00:18:47,532 --> 00:18:50,854
test in the terminal and as you see,

278
00:18:51,052 --> 00:18:54,920
we are having more information about what happens.

279
00:18:55,370 --> 00:18:59,174
The test at numbers fails. But these go testing

280
00:18:59,222 --> 00:19:04,380
tool is telling me that on line eleven here,

281
00:19:05,870 --> 00:19:09,402
I'm raising an error with this

282
00:19:09,456 --> 00:19:13,454
message. I'm expecting 55,

283
00:19:13,572 --> 00:19:17,598
but I got 56 from TDD numbers.

284
00:19:17,764 --> 00:19:22,106
So I can fix this behavior and roll

285
00:19:22,138 --> 00:19:28,306
back this change and coming back to the

286
00:19:28,328 --> 00:19:30,850
right behavior of this function. Okay,

287
00:19:31,000 --> 00:19:35,314
so I'm going to run this again and these

288
00:19:35,352 --> 00:19:39,158
is all good. This is running all the tests under

289
00:19:39,324 --> 00:19:43,318
examples package and all have

290
00:19:43,484 --> 00:19:47,910
succeed. And that's

291
00:19:50,270 --> 00:19:54,234
all about this demo. We are creating our first test.

292
00:19:54,432 --> 00:19:57,738
This is a very simple test. So we come back

293
00:19:57,824 --> 00:20:02,640
and see another topics of this talk.

294
00:20:03,810 --> 00:20:07,214
So what happens if we want

295
00:20:07,252 --> 00:20:10,880
to test multiple cases? For example,

296
00:20:11,570 --> 00:20:15,150
when we want to test border

297
00:20:15,230 --> 00:20:19,060
cases or invalid input values or

298
00:20:21,670 --> 00:20:24,820
some common values for a function

299
00:20:25,270 --> 00:20:29,838
or unexpected

300
00:20:29,934 --> 00:20:34,230
values, and check for the

301
00:20:34,300 --> 00:20:38,220
return values that we are expecting for each case?

302
00:20:39,070 --> 00:20:42,586
A grown approach is to copy and paste the test,

303
00:20:42,768 --> 00:20:45,834
changing only the input parameters and the

304
00:20:45,872 --> 00:20:47,210
expected values.

305
00:20:49,630 --> 00:20:53,200
Should it works? Of course,

306
00:20:53,570 --> 00:20:56,190
but it's not the ideal.

307
00:20:57,810 --> 00:21:01,230
Why? Because we are duplicating code.

308
00:21:01,380 --> 00:21:03,220
As you can see in this example,

309
00:21:04,950 --> 00:21:08,866
the only thing that we are changing in these two

310
00:21:08,888 --> 00:21:12,126
tests are the expected value and the input

311
00:21:12,158 --> 00:21:16,358
parameters for the TDD numbers function. The rest

312
00:21:16,444 --> 00:21:19,606
of the test is exactly the same,

313
00:21:19,788 --> 00:21:23,558
so we need to find a way to avoid this

314
00:21:23,644 --> 00:21:26,886
code duplication. That's why copy and

315
00:21:26,908 --> 00:21:29,660
paste the test is not a good idea,

316
00:21:30,510 --> 00:21:34,620
but what we can do well,

317
00:21:35,230 --> 00:21:38,682
the proposal is called the

318
00:21:38,816 --> 00:21:42,494
table driven tests and

319
00:21:42,692 --> 00:21:46,622
the main idea is to define a table with input and

320
00:21:46,676 --> 00:21:49,950
expected values and

321
00:21:50,100 --> 00:21:54,066
these translate this into code and

322
00:21:54,248 --> 00:21:57,758
test for each row

323
00:21:57,934 --> 00:22:01,620
in these table using the same

324
00:22:03,030 --> 00:22:07,462
code snippet. Avoiding code duplication as

325
00:22:07,516 --> 00:22:11,890
you can see, in this example we are creating a table

326
00:22:11,970 --> 00:22:15,334
with input values and expected results and

327
00:22:15,372 --> 00:22:17,890
then translated this into code.

328
00:22:18,060 --> 00:22:21,914
Remember, tests are code so we

329
00:22:21,952 --> 00:22:26,538
can create use

330
00:22:26,624 --> 00:22:30,182
some common

331
00:22:30,336 --> 00:22:34,222
operations from code. In this case,

332
00:22:34,276 --> 00:22:37,710
we are using a for loop to iterate over

333
00:22:37,860 --> 00:22:40,350
the different rows in this table.

334
00:22:44,150 --> 00:22:47,874
So let's go and see how

335
00:22:47,912 --> 00:22:51,890
we can create some table driven tests in

336
00:22:51,960 --> 00:22:54,900
our go project.

337
00:22:57,930 --> 00:23:00,982
Okay, in this demo we will start with

338
00:23:01,036 --> 00:23:04,834
the wrong approach to test multiple cases.

339
00:23:04,962 --> 00:23:08,140
As you see, I am

340
00:23:09,150 --> 00:23:13,190
replicating the same tests and checking

341
00:23:13,270 --> 00:23:17,178
only these expected results for each case

342
00:23:17,344 --> 00:23:21,150
and the input parameters. All of the

343
00:23:21,220 --> 00:23:24,510
rest of the test is exactly the same.

344
00:23:24,660 --> 00:23:28,654
So we can see that these are

345
00:23:28,772 --> 00:23:32,078
almost identical. And what happened

346
00:23:32,164 --> 00:23:37,570
if I want to test 100 cases?

347
00:23:39,110 --> 00:23:42,946
Believe me, we really don't want to

348
00:23:43,128 --> 00:23:46,230
replicate the same test 100

349
00:23:46,300 --> 00:23:50,118
times. So what are

350
00:23:50,204 --> 00:23:54,440
we going to do is to use table driven test

351
00:23:56,890 --> 00:24:00,314
to follow test table driven test we can

352
00:24:00,352 --> 00:24:04,150
create. First, we can create a table containing

353
00:24:04,230 --> 00:24:07,530
the inputs and expected values

354
00:24:08,430 --> 00:24:10,880
we can create using bar,

355
00:24:12,370 --> 00:24:16,320
for example add numbers

356
00:24:17,090 --> 00:24:20,720
test cases and this

357
00:24:21,490 --> 00:24:27,726
will be a struct and

358
00:24:27,748 --> 00:24:31,774
a slice of a struct. These struct continuous

359
00:24:31,902 --> 00:24:33,490
input values.

360
00:24:34,630 --> 00:24:38,470
Input values will be slice of integers

361
00:24:38,970 --> 00:24:42,870
and expected

362
00:24:43,290 --> 00:24:47,538
result. That will be an integer

363
00:24:47,634 --> 00:24:51,754
too. Okay, this is our struct and

364
00:24:51,872 --> 00:24:55,740
what values we can add here

365
00:24:56,270 --> 00:25:00,380
all the test cases. I will change this,

366
00:25:01,730 --> 00:25:05,920
right? We can create different

367
00:25:06,690 --> 00:25:09,630
instances to this slice.

368
00:25:10,050 --> 00:25:13,394
For example, the first case

369
00:25:13,512 --> 00:25:17,026
will have one, two and three as the

370
00:25:17,048 --> 00:25:21,074
input parameters, and the expected value will

371
00:25:21,112 --> 00:25:24,500
be six okay,

372
00:25:24,890 --> 00:25:30,950
for the second case we use

373
00:25:31,100 --> 00:25:34,690
one and 100 as the input parameters

374
00:25:34,770 --> 00:25:37,014
and expected value will be 101.

375
00:25:37,052 --> 00:25:41,340
And then we

376
00:25:43,630 --> 00:25:45,980
can add another value.

377
00:25:47,950 --> 00:25:52,160
Sorry, I'm going to copy paste this for

378
00:25:56,770 --> 00:26:00,574
sorry to do

379
00:26:00,612 --> 00:26:05,250
this more quickly. One, two and zeros

380
00:26:07,110 --> 00:26:10,420
should return three.

381
00:26:11,270 --> 00:26:16,180
Then 201 and 403

382
00:26:17,190 --> 00:26:20,934
it should return 604 and

383
00:26:20,972 --> 00:26:24,646
then another cases. For example one, one, two to

384
00:26:24,668 --> 00:26:29,634
two. These four, four should

385
00:26:29,692 --> 00:26:33,322
return this

386
00:26:33,376 --> 00:26:37,654
value. And finally can empty input

387
00:26:37,782 --> 00:26:40,800
to return zero. Okay,

388
00:26:41,330 --> 00:26:43,790
what's happening here? Too many values.

389
00:26:44,690 --> 00:26:47,360
Don't worry about this. It's just the ide.

390
00:26:47,810 --> 00:26:51,614
And then we don't need to repeat the

391
00:26:51,652 --> 00:26:56,018
same test over and over again. We need just

392
00:26:56,184 --> 00:26:59,460
the TDD numbers as the base.

393
00:27:00,230 --> 00:27:04,762
We can test driven

394
00:27:04,926 --> 00:27:09,350
approach and table

395
00:27:13,210 --> 00:27:17,378
table driven approach and what we'll do

396
00:27:17,484 --> 00:27:21,290
inside this tests. Well, we need a for loop.

397
00:27:23,390 --> 00:27:27,530
This is the test

398
00:27:27,600 --> 00:27:31,422
case. We are

399
00:27:31,476 --> 00:27:35,120
iterate over the

400
00:27:35,890 --> 00:27:41,054
TDD numbers test cases and

401
00:27:41,172 --> 00:27:44,770
for each test case we will

402
00:27:44,840 --> 00:27:56,040
run a test running

403
00:27:56,890 --> 00:28:01,606
case and we

404
00:28:01,628 --> 00:28:05,126
will run a function that

405
00:28:05,228 --> 00:28:10,118
is the test itself describing

406
00:28:10,214 --> 00:28:13,818
testing t. And inside

407
00:28:13,904 --> 00:28:18,138
this function we will program

408
00:28:18,224 --> 00:28:21,966
the behavior of the test itself. It's exactly

409
00:28:22,148 --> 00:28:26,126
the same that we have here, but we

410
00:28:26,148 --> 00:28:30,030
will copy just this part and

411
00:28:30,100 --> 00:28:33,362
we will use the test case value.

412
00:28:33,496 --> 00:28:38,206
Test case input.

413
00:28:38,398 --> 00:28:42,466
Passing the input to

414
00:28:42,488 --> 00:28:46,520
the numbers we need to convert into

415
00:28:47,690 --> 00:28:51,014
variable arguments here. And then we

416
00:28:51,052 --> 00:28:55,400
don't have an expected result. This is part of the test case.

417
00:28:55,930 --> 00:29:00,854
Test case expected

418
00:29:00,902 --> 00:29:04,300
result. Oh,

419
00:29:04,830 --> 00:29:08,700
here we have an issue.

420
00:29:11,490 --> 00:29:15,166
That's a problem. Okay. These we

421
00:29:15,188 --> 00:29:19,070
have an expected result. And if the case

422
00:29:19,140 --> 00:29:22,682
is that the expected result is different than

423
00:29:22,756 --> 00:29:27,586
the result from

424
00:29:27,608 --> 00:29:31,300
the cow to the function, these will we

425
00:29:32,070 --> 00:29:36,214
tell the function to fail and pass it here.

426
00:29:36,412 --> 00:29:39,720
Test case expected result.

427
00:29:41,610 --> 00:29:45,078
The behavior will be exactly the same.

428
00:29:45,244 --> 00:29:49,162
But the big difference is

429
00:29:49,216 --> 00:29:53,146
that we need much

430
00:29:53,248 --> 00:29:56,362
less code.

431
00:29:56,496 --> 00:30:00,006
And it's very simple to add new test cases. We need

432
00:30:00,048 --> 00:30:04,474
to just add cases to this slice.

433
00:30:04,602 --> 00:30:08,494
Okay, how it see when

434
00:30:08,532 --> 00:30:12,080
we run this, we can run this here

435
00:30:14,070 --> 00:30:18,018
with the id and this will show us all the

436
00:30:18,104 --> 00:30:22,660
test cases. But maybe we can change

437
00:30:26,170 --> 00:30:31,000
this identification of each test case and

438
00:30:32,010 --> 00:30:34,360
for input. For example,

439
00:30:36,730 --> 00:30:42,586
we can format a

440
00:30:42,608 --> 00:30:48,780
message for input b

441
00:30:49,150 --> 00:30:53,310
and test case input.

442
00:30:53,810 --> 00:30:58,142
This will be more easy

443
00:30:58,196 --> 00:31:00,560
to identify each case.

444
00:31:01,570 --> 00:31:05,298
Here. As you see each case will be

445
00:31:05,464 --> 00:31:08,814
ident. We can identify the input parameters

446
00:31:08,942 --> 00:31:12,930
for each case. So this is why

447
00:31:13,080 --> 00:31:16,322
table driven test is a good approach.

448
00:31:16,466 --> 00:31:20,520
It's a good knowledge to have because will be

449
00:31:20,890 --> 00:31:24,166
easy some the

450
00:31:24,188 --> 00:31:26,390
test of different use cases.

451
00:31:27,470 --> 00:31:31,206
Now we are going to talk about code examples.

452
00:31:31,398 --> 00:31:35,386
Examples are code snippets that

453
00:31:35,488 --> 00:31:39,322
will be running as tests by go testing tool

454
00:31:39,456 --> 00:31:42,682
but also are displayed as package

455
00:31:42,746 --> 00:31:46,650
documentation and we can visit

456
00:31:46,810 --> 00:31:50,686
and see these examples in

457
00:31:50,708 --> 00:31:54,754
the Godoc web page for the package to

458
00:31:54,792 --> 00:31:58,894
create code examples we need to comply with a naming

459
00:31:58,942 --> 00:32:02,900
convention. Our function should

460
00:32:03,510 --> 00:32:07,302
start with example and have

461
00:32:07,436 --> 00:32:12,086
different conventions for

462
00:32:12,108 --> 00:32:16,370
the cases that we need to create. Examples for functions

463
00:32:16,450 --> 00:32:20,460
type or methods inside a type okay,

464
00:32:20,990 --> 00:32:24,380
here are some examples. For example

465
00:32:25,390 --> 00:32:29,386
to create an example for the compare function in

466
00:32:29,408 --> 00:32:32,794
the package string, an example

467
00:32:32,912 --> 00:32:36,718
for the writer type

468
00:32:36,884 --> 00:32:40,766
in the package buff IO and

469
00:32:40,948 --> 00:32:44,930
finally an example for the lines method

470
00:32:46,550 --> 00:32:49,842
for the scanner type which

471
00:32:49,896 --> 00:32:55,540
is part of the package buff IO and

472
00:32:56,250 --> 00:32:59,640
how is displayed this example

473
00:33:00,810 --> 00:33:04,566
in the Godog web page where here is an

474
00:33:04,588 --> 00:33:09,210
example of this. These is an example for the continuous

475
00:33:10,270 --> 00:33:13,430
function which is part of the string

476
00:33:13,510 --> 00:33:18,220
package. This is the link for looking

477
00:33:18,910 --> 00:33:25,102
this page and as you can see the

478
00:33:25,156 --> 00:33:29,182
Godoc web page will display these example and

479
00:33:29,236 --> 00:33:33,202
present a very simple playground that

480
00:33:33,256 --> 00:33:37,426
we can change some of this code

481
00:33:37,608 --> 00:33:39,810
and changing the output.

482
00:33:41,830 --> 00:33:46,040
This is very useful to create some

483
00:33:46,730 --> 00:33:50,630
examples and tests in line how to

484
00:33:50,700 --> 00:33:54,520
use a specific function.

485
00:33:55,770 --> 00:33:59,754
Okay, this is the time to see how we can

486
00:33:59,792 --> 00:34:03,066
create an example. To create an example,

487
00:34:03,168 --> 00:34:06,474
we need to create a function that the name

488
00:34:06,512 --> 00:34:11,026
of the function must start with example followed

489
00:34:11,078 --> 00:34:14,574
by the name of the function that we want to

490
00:34:14,612 --> 00:34:18,320
create. This example in this case al numbers.

491
00:34:19,330 --> 00:34:23,086
These functions needs no parameters

492
00:34:23,198 --> 00:34:27,230
so we create this block inside the block.

493
00:34:27,390 --> 00:34:31,202
The idea is to create an example of how

494
00:34:31,256 --> 00:34:35,446
we can use these function. For example, we can create a

495
00:34:35,548 --> 00:34:39,640
variable result that is assigned to

496
00:34:40,010 --> 00:34:43,478
numbers, the values one, two,

497
00:34:43,644 --> 00:34:49,160
four and

498
00:34:50,170 --> 00:34:53,786
to tell the examples to work as a

499
00:34:53,808 --> 00:34:57,466
test, we need to send a

500
00:34:57,488 --> 00:35:00,894
value or a couple of values to the

501
00:35:00,932 --> 00:35:04,720
standard output. In this case we can do this with

502
00:35:06,370 --> 00:35:10,880
the FMt package printlen result.

503
00:35:12,390 --> 00:35:16,018
We are sending the result value to the

504
00:35:16,104 --> 00:35:19,714
standard but and these assertion the

505
00:35:19,752 --> 00:35:23,346
check will be we need to

506
00:35:23,528 --> 00:35:28,106
set the output. This is reserved

507
00:35:28,238 --> 00:35:32,546
word for the example functions output.

508
00:35:32,658 --> 00:35:36,214
We expect to get the value ten in this

509
00:35:36,252 --> 00:35:40,090
case. So the go testing tool will run

510
00:35:40,240 --> 00:35:44,154
this piece of code. This part

511
00:35:44,192 --> 00:35:48,074
of the function will checking and will

512
00:35:48,112 --> 00:35:52,390
check that the output. The standard output receives

513
00:35:52,470 --> 00:35:55,590
the number ten and that's it.

514
00:35:55,760 --> 00:36:00,490
The example will be published as part of the Godoc

515
00:36:00,570 --> 00:36:04,434
web page of this package. Well, the next

516
00:36:04,472 --> 00:36:06,690
topic is test assertions.

517
00:36:09,030 --> 00:36:12,530
And what are assertions? Well,

518
00:36:12,680 --> 00:36:15,942
assertions are sentences that must

519
00:36:15,996 --> 00:36:19,670
be true. In any other case our

520
00:36:19,740 --> 00:36:23,634
test will fail. There are a lot of assertion

521
00:36:23,682 --> 00:36:27,938
libraries, but I prefer the

522
00:36:28,124 --> 00:36:31,354
testify package because it offers a lot

523
00:36:31,392 --> 00:36:35,114
of interesting assertions as the ones

524
00:36:35,312 --> 00:36:38,570
I list in this slide. For example,

525
00:36:38,640 --> 00:36:41,934
the equal or not equal to check if two

526
00:36:41,972 --> 00:36:45,246
values are equals. By the

527
00:36:45,268 --> 00:36:48,606
way, to check nil values or

528
00:36:48,708 --> 00:36:52,410
to check if a slice contains a

529
00:36:52,500 --> 00:36:56,654
specific value, to check kinds

530
00:36:56,702 --> 00:37:01,010
of errors or the message inside an error

531
00:37:02,230 --> 00:37:04,100
elements match. For example,

532
00:37:05,350 --> 00:37:08,770
allows us to check if two slice

533
00:37:09,370 --> 00:37:13,446
have the same values but not necessarily in

534
00:37:13,468 --> 00:37:18,138
the same order. And there are other

535
00:37:18,304 --> 00:37:22,150
interesting assertions like file system assertions,

536
00:37:22,310 --> 00:37:25,766
HTTP assertions and equivalence

537
00:37:25,878 --> 00:37:29,370
between JSON objects and general objects.

538
00:37:29,890 --> 00:37:34,090
What it means that two objects will be equivalent

539
00:37:34,250 --> 00:37:37,434
if they have the same attributes and the same values,

540
00:37:37,482 --> 00:37:40,160
but not necessarily in the same order.

541
00:37:40,770 --> 00:37:44,370
And in the left are an example of

542
00:37:44,520 --> 00:37:49,054
using the assert package

543
00:37:49,182 --> 00:37:53,380
from the testify model.

544
00:37:55,910 --> 00:37:59,282
And what happens if can fails.

545
00:37:59,426 --> 00:38:03,122
For example, in this case we are checking

546
00:38:03,186 --> 00:38:07,378
that the slice continuous the VAR x value

547
00:38:07,564 --> 00:38:11,130
and it does not contain this value. So the test

548
00:38:11,200 --> 00:38:14,906
will fail. And what happens these we will

549
00:38:14,928 --> 00:38:18,314
get a more readable output with more

550
00:38:18,352 --> 00:38:23,614
details. So it's an improvement to find what

551
00:38:23,652 --> 00:38:26,560
was wrong with our code.

552
00:38:28,610 --> 00:38:36,050
So let's go to hands

553
00:38:36,120 --> 00:38:39,218
on demo. Okay guys,

554
00:38:39,304 --> 00:38:42,850
for the example for the assertions package,

555
00:38:43,670 --> 00:38:47,346
first we need to download

556
00:38:47,458 --> 00:38:51,254
these testify package. This is how

557
00:38:51,292 --> 00:38:56,358
we can do it. Go get you

558
00:38:56,444 --> 00:39:00,054
to update dependencies and the URL

559
00:39:00,102 --> 00:39:03,770
for the package. In this case I have downloaded

560
00:39:04,910 --> 00:39:08,266
before so it will do nothing.

561
00:39:08,368 --> 00:39:11,646
But with this common you

562
00:39:11,668 --> 00:39:15,214
can get the testified package to create a

563
00:39:15,252 --> 00:39:19,630
test. To show what

564
00:39:19,700 --> 00:39:24,660
we can do with the assertion package, I'm going to create another

565
00:39:25,590 --> 00:39:31,346
test at numbers with

566
00:39:31,448 --> 00:39:34,500
assertions. This is another test.

567
00:39:34,970 --> 00:39:38,600
And to show you some

568
00:39:39,210 --> 00:39:43,160
features of the assert package thing.

569
00:39:43,530 --> 00:39:46,626
Imagine that we have two slides.

570
00:39:46,818 --> 00:39:50,214
Slice one that will

571
00:39:50,252 --> 00:39:54,074
be slice of integral having the

572
00:39:54,112 --> 00:39:56,780
values 1234 and five,

573
00:39:57,310 --> 00:40:01,470
and another slice having the same values.

574
00:40:02,370 --> 00:40:06,938
And we need to check that both slice

575
00:40:07,034 --> 00:40:10,910
continuous the same values.

576
00:40:12,470 --> 00:40:17,266
To do that we cannot do slice this

577
00:40:17,368 --> 00:40:21,422
slice one different than slice

578
00:40:21,486 --> 00:40:25,526
two because this cannot be

579
00:40:25,548 --> 00:40:29,474
doing. This operator doesn't

580
00:40:29,522 --> 00:40:33,206
exist on go. So first we will need

581
00:40:33,228 --> 00:40:36,946
to create a function that compares

582
00:40:37,138 --> 00:40:41,098
dot, two, slice and

583
00:40:41,264 --> 00:40:44,954
return if they are equals or not. But the

584
00:40:44,992 --> 00:40:48,906
searching package contains a function that will help

585
00:40:49,008 --> 00:40:52,894
this. We can call it

586
00:40:53,012 --> 00:40:57,710
with equals equal

587
00:40:59,250 --> 00:41:03,138
and put a message we

588
00:41:03,224 --> 00:41:07,458
need to pass the test. Slice one and

589
00:41:07,544 --> 00:41:11,474
slice two and a message when

590
00:41:11,592 --> 00:41:14,100
the two slice are different,

591
00:41:15,450 --> 00:41:19,494
slices are

592
00:41:19,532 --> 00:41:23,400
different. Okay, so to check this

593
00:41:23,930 --> 00:41:27,094
we will run the test and the test will

594
00:41:27,132 --> 00:41:30,860
pass because both contains the same

595
00:41:31,390 --> 00:41:35,594
values in the same order. If we

596
00:41:35,712 --> 00:41:38,810
create different slices,

597
00:41:39,230 --> 00:41:43,358
this test will fail and we will get

598
00:41:43,524 --> 00:41:47,134
a very detailed message

599
00:41:47,252 --> 00:41:50,222
about what was happening,

600
00:41:50,356 --> 00:41:54,180
okay, with our message here, of course,

601
00:41:55,990 --> 00:41:59,202
that's good. It's a very simple way to check if

602
00:41:59,256 --> 00:42:02,740
two slice are equals. But sometimes

603
00:42:06,090 --> 00:42:09,510
we need to check if two slices

604
00:42:10,090 --> 00:42:13,782
contains the same values, but maybe

605
00:42:13,916 --> 00:42:17,186
in different positions.

606
00:42:17,298 --> 00:42:20,570
For example, we can change the second slice,

607
00:42:22,750 --> 00:42:26,458
these numbers of the third, and the last number of

608
00:42:26,464 --> 00:42:29,674
the second slice. And if we

609
00:42:29,712 --> 00:42:33,422
run this, the test will

610
00:42:33,476 --> 00:42:37,754
fail because the equal checks

611
00:42:37,882 --> 00:42:41,502
that both slices contain the same

612
00:42:41,636 --> 00:42:43,860
numbers in the same order.

613
00:42:46,230 --> 00:42:51,454
To resolve this issue, assert library offers

614
00:42:51,502 --> 00:42:55,266
another function that

615
00:42:55,368 --> 00:42:57,480
is elements match.

616
00:42:59,210 --> 00:43:03,302
And this function check is if

617
00:43:03,436 --> 00:43:07,618
the elements of two slice or two

618
00:43:07,804 --> 00:43:11,578
objects are the same and

619
00:43:11,664 --> 00:43:15,082
doesn't matter, what's the position of

620
00:43:15,136 --> 00:43:19,130
each element. So if we run this

621
00:43:19,200 --> 00:43:21,974
test, should we pass?

622
00:43:22,112 --> 00:43:25,722
Okay, that's good. And that's

623
00:43:25,786 --> 00:43:28,766
a very interesting function.

624
00:43:28,948 --> 00:43:32,346
Another testing function is

625
00:43:32,468 --> 00:43:37,266
to assert that a

626
00:43:37,288 --> 00:43:41,426
slice contains another specific value.

627
00:43:41,608 --> 00:43:45,206
For example, slice one. You need

628
00:43:45,228 --> 00:43:49,030
to check if slice one contains the value

629
00:43:49,100 --> 00:43:52,886
these we

630
00:43:52,908 --> 00:43:57,190
will, but just a new if it doesn't contain.

631
00:43:57,790 --> 00:44:01,606
So we will run the test and both assertions

632
00:44:01,718 --> 00:44:05,210
will pass. Okay, but if we try to

633
00:44:05,360 --> 00:44:09,626
check if it continuous the number 35,

634
00:44:09,728 --> 00:44:11,150
it will fail.

635
00:44:16,470 --> 00:44:19,874
It fails because the slice does not

636
00:44:19,912 --> 00:44:23,330
contain the number that we are expecting.

637
00:44:24,330 --> 00:44:28,482
Well, as I said, the testify assert

638
00:44:28,546 --> 00:44:32,022
package is not the only option that we

639
00:44:32,076 --> 00:44:36,018
have. There are many others libraries

640
00:44:36,114 --> 00:44:39,814
like Gomega, assertions, fluent asserts

641
00:44:39,862 --> 00:44:43,562
and so on. If you want to search for

642
00:44:43,616 --> 00:44:46,922
more options, you can use the Godoc web

643
00:44:46,976 --> 00:44:50,046
page. Here is the

644
00:44:50,148 --> 00:44:54,302
search query and you can find and look

645
00:44:54,356 --> 00:44:57,806
for different options and choose the options

646
00:44:57,908 --> 00:45:02,578
that fits better

647
00:45:02,744 --> 00:45:06,562
for your needs. Let's talk about test

648
00:45:06,616 --> 00:45:10,130
doubles, especially about the mocks and staffs.

649
00:45:11,750 --> 00:45:15,746
This is the context that I'm

650
00:45:15,778 --> 00:45:19,238
going to use to trying to explain the idea behind

651
00:45:19,324 --> 00:45:23,670
test doubles. In the top diagram

652
00:45:24,170 --> 00:45:27,026
we can see a real implementation we have.

653
00:45:27,148 --> 00:45:30,986
But the system under test, these system that we

654
00:45:31,088 --> 00:45:35,546
want to test, our application for example,

655
00:45:35,728 --> 00:45:39,770
and this system depends on an artifacts

656
00:45:40,210 --> 00:45:43,806
has a dependency. This dependency can be a

657
00:45:43,828 --> 00:45:47,390
database, an API, a file system, a message

658
00:45:47,460 --> 00:45:51,520
queue or whatever. So this is a

659
00:45:52,470 --> 00:45:56,386
very hard to test situation because

660
00:45:56,488 --> 00:46:00,318
we depends on an external system we cannot

661
00:46:00,414 --> 00:46:05,986
trust, on having the same responses

662
00:46:06,098 --> 00:46:09,490
when we create queries for the database,

663
00:46:09,570 --> 00:46:13,810
for example, or having the same responses

664
00:46:13,890 --> 00:46:17,782
when we request an API.

665
00:46:17,926 --> 00:46:21,450
Because those systems are externals,

666
00:46:21,950 --> 00:46:25,354
we have no control over the content of

667
00:46:25,392 --> 00:46:28,906
these systems. So the idea

668
00:46:29,008 --> 00:46:32,126
behind the testing with doubles is that the

669
00:46:32,148 --> 00:46:35,920
test suite will call the system under test.

670
00:46:36,690 --> 00:46:40,350
As we see in the previous examples, we are calling

671
00:46:40,420 --> 00:46:45,666
the functions of our system. But the

672
00:46:45,688 --> 00:46:49,650
test suite has to create a double,

673
00:46:50,790 --> 00:46:54,190
which will be something like a

674
00:46:54,280 --> 00:46:56,790
replacement of this dependency,

675
00:46:57,850 --> 00:47:01,270
and the test suite can control this double,

676
00:47:01,930 --> 00:47:05,718
this replacement. So the system

677
00:47:05,804 --> 00:47:09,834
under test will think

678
00:47:09,952 --> 00:47:13,130
that this double is the real dependency

679
00:47:13,550 --> 00:47:17,690
and we can test these behavior in a controlled

680
00:47:18,030 --> 00:47:22,798
environment because the test suite can control what

681
00:47:22,964 --> 00:47:26,800
answers, what will be the responses of this

682
00:47:27,170 --> 00:47:31,230
double implementation. What are the benefits of this

683
00:47:31,380 --> 00:47:34,818
approach? Will be easier to test the system

684
00:47:34,904 --> 00:47:39,186
under test. We can trust in expected states

685
00:47:39,368 --> 00:47:43,634
because the test suite is defined the

686
00:47:43,672 --> 00:47:47,414
state of the double. There will be no

687
00:47:47,452 --> 00:47:50,642
side effects we can create, we can delete,

688
00:47:50,706 --> 00:47:54,390
we can run the test suite 100

689
00:47:54,460 --> 00:47:58,090
times and there will be no side effects on these real

690
00:47:58,160 --> 00:48:02,518
systems. And finally the test will run faster

691
00:48:02,694 --> 00:48:06,346
because all of

692
00:48:06,528 --> 00:48:10,750
the dependency will be controlled inside the test suite.

693
00:48:14,850 --> 00:48:20,190
There are a couple of things

694
00:48:20,260 --> 00:48:23,998
that is important to talk about. The test doubles.

695
00:48:24,174 --> 00:48:27,794
The first one is that test doubles are a

696
00:48:27,832 --> 00:48:31,730
replacement for some dependency to EC testing.

697
00:48:33,590 --> 00:48:36,360
How test double works?

698
00:48:36,730 --> 00:48:40,162
Well, the test double merely has to provide the same API

699
00:48:40,226 --> 00:48:44,166
as the real dependency so that our real

700
00:48:44,268 --> 00:48:48,054
system, our system under test think it's

701
00:48:48,102 --> 00:48:52,310
the real one. We are creating a replacement

702
00:48:52,390 --> 00:48:56,010
and as we offer the same API the system under

703
00:48:56,080 --> 00:48:59,314
test think that is interacting

704
00:48:59,382 --> 00:49:03,680
with these real dependency. Well we have

705
00:49:04,130 --> 00:49:08,362
five variations for test doubles.

706
00:49:08,506 --> 00:49:13,970
These I will talking about very resume

707
00:49:15,030 --> 00:49:18,546
for each variation. The first one is

708
00:49:18,568 --> 00:49:21,714
the dummy object. The focus of this

709
00:49:21,752 --> 00:49:24,998
dummy object is just to comply with a function

710
00:49:25,084 --> 00:49:28,440
signature. We are not using

711
00:49:29,130 --> 00:49:34,130
the content of the object. We are just creating

712
00:49:34,290 --> 00:49:38,220
a dummy for comply with these signature and can

713
00:49:38,670 --> 00:49:42,874
allow us to use

714
00:49:42,912 --> 00:49:45,740
a function and call a function.

715
00:49:46,750 --> 00:49:50,014
The second one is a fake. It's a

716
00:49:50,052 --> 00:49:53,338
real implementation of the dependency

717
00:49:53,434 --> 00:49:55,950
but it's more simpler.

718
00:49:57,730 --> 00:50:02,022
Usually it takes some shortcut which makes them not suitable

719
00:50:02,106 --> 00:50:04,020
for production. For example,

720
00:50:06,310 --> 00:50:10,530
common example is an in memory test database.

721
00:50:12,310 --> 00:50:16,434
In this case we can create an in memory test database.

722
00:50:16,562 --> 00:50:20,530
We can control what objects or how to populate

723
00:50:20,610 --> 00:50:24,418
this database, but it's not ready for production.

724
00:50:24,514 --> 00:50:28,806
We cannot publish the

725
00:50:28,828 --> 00:50:32,198
application with an in memory database

726
00:50:32,294 --> 00:50:35,530
because we have another system most

727
00:50:35,600 --> 00:50:39,850
robust database as a real dependency.

728
00:50:40,750 --> 00:50:43,934
The third one is a stab. It's one of the

729
00:50:43,972 --> 00:50:48,400
important doubles that we will focus on this talk.

730
00:50:49,090 --> 00:50:52,334
A step provides canned answers to calls

731
00:50:52,382 --> 00:50:55,534
made during the test. Usually not responding

732
00:50:55,582 --> 00:50:59,118
at all to anything outside what's programmed

733
00:50:59,294 --> 00:51:03,780
in for the test, what it means we can set

734
00:51:06,330 --> 00:51:11,430
fixed response for calls to several

735
00:51:11,770 --> 00:51:15,622
functions. The next

736
00:51:15,676 --> 00:51:19,260
one is spice. In this case

737
00:51:20,030 --> 00:51:24,026
are different from stabs. In terms

738
00:51:24,128 --> 00:51:27,466
of that spies are focused on

739
00:51:27,568 --> 00:51:30,654
how we are calling the

740
00:51:30,692 --> 00:51:34,430
functions. We are focusing on checking

741
00:51:34,930 --> 00:51:38,638
what parameters we are passing in different

742
00:51:38,724 --> 00:51:42,110
calls and that's

743
00:51:42,190 --> 00:51:45,906
the idea with spice. An example can

744
00:51:45,928 --> 00:51:48,962
be a login service. For example.

745
00:51:49,016 --> 00:51:55,320
In this case we can check what

746
00:51:56,250 --> 00:51:59,382
messages are logged or what

747
00:51:59,436 --> 00:52:02,966
kind of login level we are using in

748
00:52:02,988 --> 00:52:06,882
different calls. This is an example of spice

749
00:52:07,026 --> 00:52:10,374
and the last one are mocks. They are

750
00:52:10,412 --> 00:52:13,834
similar to steps but the difference is that we

751
00:52:13,872 --> 00:52:19,486
can create different behaviors of

752
00:52:19,508 --> 00:52:22,510
the function based on the input parameters.

753
00:52:23,970 --> 00:52:26,830
But how we can use stabs.

754
00:52:27,410 --> 00:52:31,354
The easiest way to stop a dependency is to implement

755
00:52:31,402 --> 00:52:35,038
an object that complies with a required

756
00:52:35,134 --> 00:52:38,754
interface. This will be easy if we are

757
00:52:38,792 --> 00:52:42,594
following clean code principles. What it means, for example,

758
00:52:42,712 --> 00:52:46,182
when we are describing interface to

759
00:52:46,236 --> 00:52:50,070
interact with infrastructure components.

760
00:52:51,290 --> 00:52:54,870
The example in the left is an example

761
00:52:54,940 --> 00:52:58,934
of a poor design because my business type

762
00:52:59,132 --> 00:53:02,906
which can be can use case for

763
00:53:02,928 --> 00:53:07,098
example, depends directly on a concrete type,

764
00:53:07,264 --> 00:53:10,826
for example in an SQL driver

765
00:53:11,018 --> 00:53:14,590
component. In this case it's really

766
00:53:14,660 --> 00:53:18,234
hard to test because this concrete

767
00:53:18,282 --> 00:53:22,174
type will call external services and trigger

768
00:53:22,222 --> 00:53:27,442
side effects and this will be really

769
00:53:27,496 --> 00:53:31,074
hard to check and

770
00:53:31,112 --> 00:53:34,854
trust in responses from this

771
00:53:34,892 --> 00:53:38,214
interaction. The case in

772
00:53:38,252 --> 00:53:41,480
the right is

773
00:53:41,850 --> 00:53:44,600
a better design example.

774
00:53:45,770 --> 00:53:48,970
In these case, we are defining an interface,

775
00:53:49,310 --> 00:53:52,954
my interface, which defines the

776
00:53:52,992 --> 00:53:56,954
signature or the API that

777
00:53:57,152 --> 00:54:00,974
all the infrastructure component must

778
00:54:01,092 --> 00:54:04,030
comply with. In this case,

779
00:54:04,100 --> 00:54:08,142
for example, this SQL driver should

780
00:54:08,196 --> 00:54:12,194
comply with this interface and the

781
00:54:12,232 --> 00:54:16,100
business type, the my business type. Remember the use case

782
00:54:17,990 --> 00:54:21,646
interacts directly with the interface,

783
00:54:21,838 --> 00:54:24,020
not the concrete type.

784
00:54:24,650 --> 00:54:29,480
The my business type will not worry about what

785
00:54:29,850 --> 00:54:33,750
specific implementation of the my interface

786
00:54:34,570 --> 00:54:38,054
is receiving and is interacting

787
00:54:38,102 --> 00:54:41,980
with. He only worry about that

788
00:54:45,550 --> 00:54:50,282
these variable he's receiving must

789
00:54:50,336 --> 00:54:56,762
comply with the interface that

790
00:54:56,816 --> 00:55:00,570
is important for these my business type.

791
00:55:00,720 --> 00:55:04,418
Okay, in this case it's easy to stuff

792
00:55:04,584 --> 00:55:08,114
this behavior because in the test

793
00:55:08,232 --> 00:55:11,934
we can create a concrete

794
00:55:11,982 --> 00:55:16,322
type, a concrete struct that complies

795
00:55:16,386 --> 00:55:19,030
with the my interface signature.

796
00:55:19,610 --> 00:55:23,462
If we create this type, we can create

797
00:55:23,516 --> 00:55:27,674
an instance of this type, a variable of this type and

798
00:55:27,712 --> 00:55:31,354
pass this variable to the my business type.

799
00:55:31,552 --> 00:55:35,030
And with this we can staff the behavior

800
00:55:35,190 --> 00:55:39,180
and trust in the responses that

801
00:55:39,890 --> 00:55:43,758
my interface will return to. These my business

802
00:55:43,844 --> 00:55:47,838
type maybe these

803
00:55:48,004 --> 00:55:51,774
is not easy to understand when I

804
00:55:51,892 --> 00:55:53,280
am talking about.

805
00:55:55,650 --> 00:55:59,620
Let's go and see how steps works

806
00:56:00,390 --> 00:56:02,500
in the code in a demo.

807
00:56:03,510 --> 00:56:08,370
Okay, well the next example is about steps.

808
00:56:08,810 --> 00:56:12,306
And for these case, imagine that we have a concrete

809
00:56:12,338 --> 00:56:16,760
dependency. Our software depends on specific

810
00:56:17,310 --> 00:56:20,794
system and we have here a

811
00:56:20,832 --> 00:56:24,314
structure and a method. The method is called

812
00:56:24,432 --> 00:56:28,540
do stuff. And when this method is called

813
00:56:29,250 --> 00:56:32,798
we are going to print to the standard output a message,

814
00:56:32,964 --> 00:56:36,302
fixed message and maybe we

815
00:56:36,356 --> 00:56:39,982
can call external services, maybe an

816
00:56:40,036 --> 00:56:44,302
API or do some queries to a database

817
00:56:44,446 --> 00:56:48,226
or change some values in

818
00:56:48,248 --> 00:56:52,850
the file system, anything. Okay, this is a concrete implementation

819
00:56:54,790 --> 00:56:58,210
of one of our dependencies.

820
00:56:59,850 --> 00:57:03,254
Now for the case of a

821
00:57:03,292 --> 00:57:07,146
use case structure. This is an example

822
00:57:07,248 --> 00:57:10,986
of a use case that

823
00:57:11,168 --> 00:57:14,890
has a poor design

824
00:57:15,040 --> 00:57:19,726
because we

825
00:57:19,748 --> 00:57:23,402
have a dependency here, direct dependency

826
00:57:23,546 --> 00:57:26,000
to the concrete type.

827
00:57:26,370 --> 00:57:31,454
Okay, this is very simple to program we

828
00:57:31,492 --> 00:57:35,086
will just call the do stuff method for

829
00:57:35,108 --> 00:57:38,594
the concrete dependency, maybe do more

830
00:57:38,632 --> 00:57:41,970
things and in the main method

831
00:57:42,710 --> 00:57:47,526
I can call first I need to create a

832
00:57:47,548 --> 00:57:51,062
variable of type my use case and then call

833
00:57:51,196 --> 00:57:54,774
this method some business logic method and

834
00:57:54,812 --> 00:57:58,406
this will call my concrete dependencies

835
00:57:58,518 --> 00:58:01,722
do stuff method. We can test

836
00:58:01,776 --> 00:58:05,322
this running this main

837
00:58:05,376 --> 00:58:09,530
function and here you can see that my concrete dependency

838
00:58:10,050 --> 00:58:13,758
do stuff was called okay, but this design

839
00:58:13,924 --> 00:58:18,254
is very difficult, it's hard to test because

840
00:58:18,372 --> 00:58:21,950
we have a direct dependency and we cannot

841
00:58:23,110 --> 00:58:26,322
control the behavior of this

842
00:58:26,376 --> 00:58:31,314
dependency. So an

843
00:58:31,352 --> 00:58:37,254
alternative way is to create

844
00:58:37,372 --> 00:58:41,830
an interface. The interface will define

845
00:58:42,810 --> 00:58:47,074
all the API for every

846
00:58:47,212 --> 00:58:51,660
concrete dependency that our system

847
00:58:53,630 --> 00:58:57,322
needs. Okay, in this case I have

848
00:58:57,376 --> 00:59:01,742
defined only the do stuff method and

849
00:59:01,876 --> 00:59:06,606
then we

850
00:59:06,628 --> 00:59:10,302
can define our use case. These is

851
00:59:10,356 --> 00:59:13,794
other use case in terms of the

852
00:59:13,992 --> 00:59:17,586
interface, not in terms of the direct

853
00:59:17,688 --> 00:59:21,634
dependency. With this we

854
00:59:21,832 --> 00:59:25,474
can link the sum business logic method

855
00:59:25,602 --> 00:59:29,078
with the interface do stuff

856
00:59:29,164 --> 00:59:32,534
method. Here my other use

857
00:59:32,572 --> 00:59:36,706
case doesn't for

858
00:59:36,748 --> 00:59:41,130
this use case doesn't matter what concrete type

859
00:59:41,280 --> 00:59:45,020
of dependency we are working with.

860
00:59:46,750 --> 00:59:50,366
This use case just need a concrete type

861
00:59:50,468 --> 00:59:54,570
that complies with the signature of my dependency

862
00:59:54,650 --> 00:59:58,606
interface. And finally we

863
00:59:58,628 --> 01:00:03,840
can link our concrete type with

864
01:00:04,690 --> 01:00:08,402
the interface and assign to

865
01:00:08,456 --> 01:00:12,114
this inner dependency. So in

866
01:00:12,152 --> 01:00:15,862
the main method we can call this as use

867
01:00:15,916 --> 01:00:20,150
case two equals

868
01:00:22,010 --> 01:00:26,760
concrete stuffs new

869
01:00:27,070 --> 01:00:30,858
and we need to pass a dependency heard

870
01:00:31,024 --> 01:00:35,370
we can pass staffs

871
01:00:36,590 --> 01:00:42,094
my concrete dependencies. So if

872
01:00:42,132 --> 01:00:46,110
we call my use case two some

873
01:00:46,180 --> 01:00:50,974
business logic, this should

874
01:00:51,092 --> 01:00:54,130
run my concrete dependency

875
01:00:55,910 --> 01:00:59,538
do stuff method. Again here we can

876
01:00:59,624 --> 01:01:03,182
see that this message is repeated

877
01:01:03,246 --> 01:01:07,014
twice because we are calling these my

878
01:01:07,052 --> 01:01:10,438
concrete dependency in use case one and

879
01:01:10,524 --> 01:01:12,200
in use case two.

880
01:01:15,930 --> 01:01:19,450
So why we need to

881
01:01:19,600 --> 01:01:23,430
refactor our code using this interface?

882
01:01:23,510 --> 01:01:27,180
Because when we create a test

883
01:01:28,590 --> 01:01:32,720
for examples we can create this use case

884
01:01:33,730 --> 01:01:37,840
test file and a function

885
01:01:38,530 --> 01:01:44,242
test my

886
01:01:44,296 --> 01:01:47,854
other use case some business logic

887
01:01:47,902 --> 01:01:51,746
method here we

888
01:01:51,768 --> 01:01:57,190
need to call the first

889
01:01:57,260 --> 01:02:01,414
we need to create a

890
01:02:01,452 --> 01:02:05,430
use case. So my use

891
01:02:05,580 --> 01:02:08,940
case new

892
01:02:09,390 --> 01:02:12,954
my other use case we need to pass a

893
01:02:12,992 --> 01:02:18,202
concrete implementation of my

894
01:02:18,256 --> 01:02:23,120
dependency interface so we can create here type

895
01:02:25,330 --> 01:02:29,310
my staff dependency

896
01:02:30,930 --> 01:02:34,994
is a struct and we

897
01:02:35,032 --> 01:02:41,570
can create a function my

898
01:02:41,640 --> 01:02:45,222
staff dependency to

899
01:02:45,356 --> 01:02:48,200
staff sorry.

900
01:02:52,970 --> 01:03:03,130
And here we can another

901
01:03:03,200 --> 01:03:07,210
behavior we are changing this is another implementation

902
01:03:09,570 --> 01:03:14,074
of the my dependency interface complies

903
01:03:14,122 --> 01:03:17,390
with the signature so we can pass

904
01:03:17,540 --> 01:03:23,438
an instance of this my stuff sorry,

905
01:03:23,604 --> 01:03:30,370
stuff dependency dependency

906
01:03:31,190 --> 01:03:35,266
yeah, sorry. But for the typo

907
01:03:35,298 --> 01:03:38,886
here to

908
01:03:38,908 --> 01:03:43,014
the constructor of this use case and these we can call

909
01:03:43,132 --> 01:03:47,554
use case some business method

910
01:03:47,602 --> 01:03:51,590
and finally some searches.

911
01:03:52,270 --> 01:03:56,058
But we are not to

912
01:03:56,224 --> 01:04:00,126
do any assertion for

913
01:04:00,148 --> 01:04:04,510
these example we just want to know how to

914
01:04:04,660 --> 01:04:08,320
create a stack. So let's go and run this

915
01:04:10,770 --> 01:04:14,100
case. And as you see here,

916
01:04:15,030 --> 01:04:18,782
we are running the sum business logic method

917
01:04:18,846 --> 01:04:23,154
of the use case. But the

918
01:04:23,192 --> 01:04:27,538
do stuff method is from my

919
01:04:27,624 --> 01:04:32,162
stuff dependency, so I can control the behavior

920
01:04:32,306 --> 01:04:36,022
of the dependency. And then what are

921
01:04:36,076 --> 01:04:39,866
the expected values that the use case will get.

922
01:04:39,968 --> 01:04:43,370
So it's more easy to test some

923
01:04:43,440 --> 01:04:46,220
scenarios. Okay,

924
01:04:47,150 --> 01:04:49,594
how we can use mocks? Well,

925
01:04:49,712 --> 01:04:53,066
remember a mock is very similar to a

926
01:04:53,088 --> 01:04:57,118
stack, but the tests will also verify that the object

927
01:04:57,204 --> 01:05:01,470
under test calls these mock. As expected,

928
01:05:03,430 --> 01:05:06,610
this is represented in the diagram.

929
01:05:07,270 --> 01:05:10,834
The system under test will call these market object.

930
01:05:11,032 --> 01:05:14,834
The behavior of the market object is defined by

931
01:05:14,872 --> 01:05:18,662
the test suite. Because remember these market object is

932
01:05:18,716 --> 01:05:23,014
a w. And what things we

933
01:05:23,052 --> 01:05:26,798
can do with a market object, we can define

934
01:05:26,914 --> 01:05:31,158
several behaviors given different input

935
01:05:31,254 --> 01:05:35,020
parameters. And another

936
01:05:35,390 --> 01:05:38,950
interesting thing is that the test

937
01:05:39,120 --> 01:05:42,510
will fail if these system

938
01:05:42,580 --> 01:05:45,834
under test calls the mocket

939
01:05:45,882 --> 01:05:49,742
object with a set of parameters that were not

940
01:05:49,796 --> 01:05:54,050
configured. This is a very powerful feature.

941
01:05:56,950 --> 01:06:00,866
Well, in this case I will use

942
01:06:00,968 --> 01:06:04,690
testify as the checking

943
01:06:05,690 --> 01:06:09,650
library. And why? Because testify

944
01:06:09,730 --> 01:06:13,222
offers some useful features. For example, we can

945
01:06:13,356 --> 01:06:17,238
control that given several parameters,

946
01:06:17,334 --> 01:06:20,650
I want to return some

947
01:06:20,720 --> 01:06:23,770
values once, twice,

948
01:06:24,350 --> 01:06:27,020
definite number of times,

949
01:06:28,270 --> 01:06:33,450
and other interesting features

950
01:06:33,530 --> 01:06:37,070
of this library. This is an example of

951
01:06:37,140 --> 01:06:41,360
how to mock object

952
01:06:41,670 --> 01:06:44,980
will behave. In this case,

953
01:06:45,670 --> 01:06:49,554
the mocket service will return hello only once,

954
01:06:49,672 --> 01:06:53,534
only the first time these system under test calls

955
01:06:53,662 --> 01:06:59,574
this service. All the next

956
01:06:59,612 --> 01:07:03,014
times that the system under test call the

957
01:07:03,052 --> 01:07:06,290
mocket service, the my method

958
01:07:06,370 --> 01:07:10,314
will return by. This is the

959
01:07:10,352 --> 01:07:14,742
kind of things that we can do with mocked feature

960
01:07:14,806 --> 01:07:19,194
of testify. But as

961
01:07:19,232 --> 01:07:22,766
we are developers, maybe with an example, with a

962
01:07:22,788 --> 01:07:26,126
demo, it's more easy to understand what we

963
01:07:26,148 --> 01:07:30,366
can do with mock. And in this case with

964
01:07:30,548 --> 01:07:34,642
testify, I prepare another example and

965
01:07:34,776 --> 01:07:37,890
a little bit more complex example

966
01:07:37,960 --> 01:07:42,270
of dependency. Now our dependency interface

967
01:07:42,350 --> 01:07:46,310
define one method, but this method receives

968
01:07:47,050 --> 01:07:50,710
parameters and has a return value. Okay,

969
01:07:50,860 --> 01:07:54,674
so our concrete dependency to comply

970
01:07:54,722 --> 01:07:58,620
with this signature, so it

971
01:07:58,990 --> 01:08:02,646
receives an input parameter and return ensuring

972
01:08:02,678 --> 01:08:06,714
value. Inside this

973
01:08:06,752 --> 01:08:10,074
method we

974
01:08:10,112 --> 01:08:14,620
could call external services, external services

975
01:08:14,990 --> 01:08:18,810
and maybe return a response

976
01:08:19,630 --> 01:08:24,002
from this call. Okay, for these

977
01:08:24,136 --> 01:08:27,746
demo we just return three times

978
01:08:27,848 --> 01:08:32,354
the input value. It's a very dummy return value,

979
01:08:32,472 --> 01:08:38,130
but we are not trying to demonstrate

980
01:08:38,210 --> 01:08:41,110
anything in this concrete dependency.

981
01:08:41,850 --> 01:08:45,506
So we have this dependency interface,

982
01:08:45,618 --> 01:08:49,450
the use case receives an inner dependency

983
01:08:50,590 --> 01:08:54,854
using this constructor here it's

984
01:08:54,902 --> 01:09:00,134
very similar to the requirements for the staff

985
01:09:00,182 --> 01:09:04,010
doubles and our

986
01:09:04,080 --> 01:09:08,800
sum business logic method receive an input value and

987
01:09:09,650 --> 01:09:12,690
do some stuff using our

988
01:09:12,760 --> 01:09:16,500
dependency and return the processor value. Okay,

989
01:09:17,110 --> 01:09:20,626
so what can do in the

990
01:09:20,648 --> 01:09:24,274
tests of these methods to

991
01:09:24,312 --> 01:09:26,770
mock this dependency.

992
01:09:27,270 --> 01:09:30,854
Well, to mock the dependencies we

993
01:09:30,892 --> 01:09:33,814
need to first create an object.

994
01:09:34,012 --> 01:09:37,306
These object needs to be

995
01:09:37,328 --> 01:09:41,686
can instructor and implements

996
01:09:41,798 --> 01:09:45,770
the mock interface from the mock packet.

997
01:09:47,230 --> 01:09:51,466
And we need to make

998
01:09:51,568 --> 01:09:55,680
these mocked objects to comply with

999
01:09:56,210 --> 01:09:59,326
my dependencies interface. So we

1000
01:09:59,348 --> 01:10:03,586
need to add the do stuff method that

1001
01:10:03,688 --> 01:10:07,346
needs to receive one parameter of type string and return

1002
01:10:07,448 --> 01:10:10,900
some string value. And this is

1003
01:10:12,390 --> 01:10:16,262
needed to call the

1004
01:10:16,316 --> 01:10:19,782
original method with this parameter and

1005
01:10:19,836 --> 01:10:23,880
return the first returned value to the color.

1006
01:10:24,650 --> 01:10:28,922
And how we can mock this

1007
01:10:28,976 --> 01:10:31,820
object in our test? Well,

1008
01:10:32,190 --> 01:10:36,202
first we need to create the test, then create

1009
01:10:36,256 --> 01:10:39,920
a mocket object from the

1010
01:10:41,250 --> 01:10:43,870
mocket object structure.

1011
01:10:45,570 --> 01:10:48,446
And then it's the interesting part,

1012
01:10:48,628 --> 01:10:52,340
we can link a set of

1013
01:10:53,910 --> 01:10:57,860
arguments input parameters with a set of

1014
01:10:58,550 --> 01:11:02,034
expected values. In this case we

1015
01:11:02,152 --> 01:11:08,374
are telling the mock package to

1016
01:11:08,412 --> 01:11:12,070
change the behavior of our do stuff method.

1017
01:11:12,490 --> 01:11:16,594
This do stuff method. So when

1018
01:11:16,732 --> 01:11:20,922
the color passes the hello as

1019
01:11:20,976 --> 01:11:24,394
the input parameter, then the

1020
01:11:24,432 --> 01:11:27,802
do stuff method will return a fixed value hello

1021
01:11:27,856 --> 01:11:31,354
world. Okay, it's very simple and it's

1022
01:11:31,402 --> 01:11:35,370
very easy to understand these logic.

1023
01:11:35,530 --> 01:11:39,418
So then we can create a use case passing

1024
01:11:39,514 --> 01:11:44,078
this object market object to the use case and

1025
01:11:44,164 --> 01:11:47,742
call some business logic method

1026
01:11:47,806 --> 01:11:51,538
with these hello as parameter and

1027
01:11:51,704 --> 01:11:54,742
storing the message, the returned message as

1028
01:11:54,796 --> 01:11:58,662
the message one variable and

1029
01:11:58,716 --> 01:12:02,054
finally made an assertion that we

1030
01:12:02,092 --> 01:12:06,200
are expecting hello world. This is the value

1031
01:12:06,990 --> 01:12:10,794
for the variable message one. Let's go and see

1032
01:12:10,832 --> 01:12:13,180
what happened when we run this test.

1033
01:12:15,710 --> 01:12:19,402
Okay, this test is

1034
01:12:19,536 --> 01:12:23,262
passed because we are

1035
01:12:23,316 --> 01:12:26,640
expecting this value. If we change the expected value,

1036
01:12:27,010 --> 01:12:30,958
for example by this will fail of course because

1037
01:12:31,124 --> 01:12:34,562
we are linked the hello input parameter with hello

1038
01:12:34,616 --> 01:12:38,580
world return value. So this will not

1039
01:12:39,110 --> 01:12:40,020
be true.

1040
01:12:41,910 --> 01:12:46,760
Another interesting thing is

1041
01:12:47,290 --> 01:12:50,694
world is when we

1042
01:12:50,732 --> 01:12:55,670
pass another value unexpected

1043
01:12:56,010 --> 01:13:00,074
input bad. What will happen

1044
01:13:00,192 --> 01:13:05,254
if we pass a value that was not settled

1045
01:13:05,302 --> 01:13:09,138
up here as a linked in the mocket

1046
01:13:09,174 --> 01:13:12,670
object? Well then the test will fail

1047
01:13:13,570 --> 01:13:18,894
and the message will tell us that there

1048
01:13:18,932 --> 01:13:22,914
is an expected method called because we only are

1049
01:13:22,952 --> 01:13:26,738
expecting the hello as

1050
01:13:26,824 --> 01:13:30,850
input parameters. We can create another

1051
01:13:31,000 --> 01:13:36,662
input parameters and put

1052
01:13:36,716 --> 01:13:40,760
here unexpected return

1053
01:13:41,610 --> 01:13:45,766
value. For example, running this test we

1054
01:13:45,788 --> 01:13:50,902
will get another error

1055
01:13:50,966 --> 01:13:56,406
because we are trying to compare

1056
01:13:56,518 --> 01:14:00,010
this message that will be unexpected return value

1057
01:14:00,080 --> 01:14:03,950
with hello world. So we can fix it

1058
01:14:04,020 --> 01:14:07,662
with for example

1059
01:14:07,796 --> 01:14:11,200
here with hello and

1060
01:14:11,990 --> 01:14:16,354
message two with

1061
01:14:16,552 --> 01:14:19,220
the expected value.

1062
01:14:26,530 --> 01:14:30,500
These test will pass because we are calling

1063
01:14:31,190 --> 01:14:35,118
some business logic method and then the duostaff

1064
01:14:35,214 --> 01:14:38,674
method of our mocket object with

1065
01:14:38,712 --> 01:14:42,050
the expected parameters. At this time

1066
01:14:42,120 --> 01:14:45,990
we are talking about how to create tests,

1067
01:14:46,730 --> 01:14:52,354
how to use assertions and how to use

1068
01:14:52,492 --> 01:14:56,874
test doubles to test

1069
01:14:56,992 --> 01:15:00,170
some hard scenarios,

1070
01:15:00,670 --> 01:15:05,214
more complex scenarios. But there is

1071
01:15:05,412 --> 01:15:09,440
another thing that is very useful for us

1072
01:15:10,450 --> 01:15:14,078
and it's very important to have in mind always

1073
01:15:14,244 --> 01:15:17,120
is where to put the test,

1074
01:15:17,430 --> 01:15:20,546
where we

1075
01:15:20,568 --> 01:15:25,634
should create the test. So where

1076
01:15:25,672 --> 01:15:28,100
should we put our test?

1077
01:15:28,790 --> 01:15:32,726
There is a convention in go.

1078
01:15:32,828 --> 01:15:35,750
Go is a language with a lot of conventions.

1079
01:15:36,330 --> 01:15:40,166
The go testing files should always be

1080
01:15:40,188 --> 01:15:43,866
located in the same folder and package where the

1081
01:15:43,888 --> 01:15:48,010
code they are testing receipts. What it means

1082
01:15:48,080 --> 01:15:52,474
for example, if I have my package with

1083
01:15:52,592 --> 01:15:56,560
a couple of functions and I want to test this function,

1084
01:16:00,770 --> 01:16:04,366
my testing code should receive in

1085
01:16:04,388 --> 01:16:07,774
the same directory and use the same package,

1086
01:16:07,902 --> 01:16:10,100
my package. In this case,

1087
01:16:11,750 --> 01:16:15,710
the go compiler will exclude all the testing files

1088
01:16:15,790 --> 01:16:19,546
when building our applications. So we don't need to worry

1089
01:16:19,598 --> 01:16:23,510
about having testing code into production

1090
01:16:24,090 --> 01:16:27,254
artifacts. Okay, we should

1091
01:16:27,292 --> 01:16:31,126
not worry about this. But there

1092
01:16:31,148 --> 01:16:35,674
is another interesting thing

1093
01:16:35,872 --> 01:16:39,930
related to the package that we will use

1094
01:16:40,080 --> 01:16:43,466
in the test. Imagine for example that we

1095
01:16:43,488 --> 01:16:47,614
have my package, a package called my

1096
01:16:47,652 --> 01:16:51,226
package. In this package, we have three functions.

1097
01:16:51,338 --> 01:16:55,310
The first one is a public function, it's my public function

1098
01:16:55,460 --> 01:16:58,510
and we have two private functions.

1099
01:16:58,670 --> 01:17:02,418
Okay? And my test were located in

1100
01:17:02,424 --> 01:17:06,420
these mypackage underscore tests go.

1101
01:17:08,310 --> 01:17:12,182
So we can choose two options for

1102
01:17:12,236 --> 01:17:14,760
these package of my test.

1103
01:17:16,090 --> 01:17:20,710
Even if the conventions

1104
01:17:21,130 --> 01:17:25,514
tell me that I should use my package as

1105
01:17:25,552 --> 01:17:27,980
the package of my test,

1106
01:17:28,990 --> 01:17:32,502
I have two options. The first one is use my package.

1107
01:17:32,646 --> 01:17:36,414
And in this case I can test the

1108
01:17:36,452 --> 01:17:40,334
these functions separately because as

1109
01:17:40,372 --> 01:17:43,902
the test code is in these same package that

1110
01:17:43,956 --> 01:17:46,240
the working code,

1111
01:17:46,950 --> 01:17:50,946
the system under test, I can access all

1112
01:17:51,128 --> 01:17:53,330
of these three functions.

1113
01:17:55,990 --> 01:18:00,120
I really don't prefer this case.

1114
01:18:02,010 --> 01:18:05,862
I prefer the second option. The second option is to use

1115
01:18:05,996 --> 01:18:10,854
a different package. In this case can

1116
01:18:10,892 --> 01:18:14,822
official convention is use the package underscore

1117
01:18:14,886 --> 01:18:18,474
tests. In this case, my tests

1118
01:18:18,672 --> 01:18:22,442
can only access my

1119
01:18:22,496 --> 01:18:25,806
public function because as the

1120
01:18:25,828 --> 01:18:28,750
test code is in another package,

1121
01:18:29,650 --> 01:18:33,834
the test code cannot access the private functions

1122
01:18:33,882 --> 01:18:37,650
of the package. There is no

1123
01:18:37,800 --> 01:18:41,666
right way. I prefer the

1124
01:18:41,688 --> 01:18:45,940
second one, but the convention is the first one

1125
01:18:46,630 --> 01:18:50,278
you have to choose. I really recommend the

1126
01:18:50,364 --> 01:18:54,338
second choice because we will testing

1127
01:18:54,514 --> 01:18:56,710
the interfaces of the packages.

1128
01:18:59,770 --> 01:19:03,018
So to see this in code,

1129
01:19:03,184 --> 01:19:07,050
let's go and see some examples

1130
01:19:07,390 --> 01:19:12,700
in a hands on demo. For the next example,

1131
01:19:13,470 --> 01:19:17,486
imagine that we have a public function which

1132
01:19:17,588 --> 01:19:20,926
depends on two private functions in the

1133
01:19:20,948 --> 01:19:24,462
same package, okay? In this case they do some

1134
01:19:24,516 --> 01:19:28,882
complex operations should do

1135
01:19:29,016 --> 01:19:33,326
more complex logic, maybe applying a hashing algorithm

1136
01:19:33,438 --> 01:19:37,326
or anything. And the complies

1137
01:19:37,358 --> 01:19:41,862
with custom verification function can

1138
01:19:41,916 --> 01:19:44,966
verify if the input value complies with a custom

1139
01:19:45,068 --> 01:19:49,490
algorithm, for example. So our public blick functions,

1140
01:19:49,570 --> 01:19:53,274
the function that will be visible to

1141
01:19:53,312 --> 01:19:57,018
the rest of our application depends on these

1142
01:19:57,104 --> 01:20:00,346
two private functions. If I want to

1143
01:20:00,368 --> 01:20:04,006
tests this package?

1144
01:20:04,118 --> 01:20:09,550
I can create the do stuff underscore

1145
01:20:09,970 --> 01:20:13,486
test function.

1146
01:20:13,668 --> 01:20:17,186
By default, by the convention my

1147
01:20:17,208 --> 01:20:21,086
test will be created in the package,

1148
01:20:21,198 --> 01:20:24,914
in the location package, in the same package, and I

1149
01:20:24,952 --> 01:20:29,394
will create the function test my

1150
01:20:29,432 --> 01:20:33,122
public function. And here can

1151
01:20:33,176 --> 01:20:35,570
be searches.

1152
01:20:37,690 --> 01:20:42,200
For example, I don't know return

1153
01:20:45,710 --> 01:20:50,102
response return value equals

1154
01:20:50,166 --> 01:20:53,834
to my public function, passing some

1155
01:20:53,872 --> 01:20:58,190
value I don't know and then assertions

1156
01:20:58,610 --> 01:21:03,294
and expected will

1157
01:21:03,332 --> 01:21:07,954
be bar and

1158
01:21:08,072 --> 01:21:11,250
can assertion will be assert

1159
01:21:12,870 --> 01:21:17,890
equal expected

1160
01:21:18,390 --> 01:21:21,558
return value. This is my test.

1161
01:21:21,644 --> 01:21:25,270
Okay, but what's

1162
01:21:26,010 --> 01:21:30,134
the issue with but my tests in

1163
01:21:30,172 --> 01:21:33,260
the same package than the code?

1164
01:21:34,910 --> 01:21:38,662
The issue is that I can access the private

1165
01:21:38,806 --> 01:21:42,940
functions. For example, these do

1166
01:21:43,390 --> 01:21:45,230
some complex operation,

1167
01:21:49,570 --> 01:21:54,670
I can do that bar

1168
01:21:54,740 --> 01:21:57,120
one equals two.

1169
01:21:58,870 --> 01:22:02,900
The test will not fail because I can see

1170
01:22:03,910 --> 01:22:06,850
these functions because I am located,

1171
01:22:07,750 --> 01:22:11,240
my test is in the same package than the code.

1172
01:22:11,690 --> 01:22:16,002
So the recommendation here is to change this package

1173
01:22:16,146 --> 01:22:19,560
and use the underscore, underscore test.

1174
01:22:21,370 --> 01:22:24,906
And in this case I need to import the

1175
01:22:24,928 --> 01:22:28,506
location packets to access

1176
01:22:28,608 --> 01:22:29,900
my public function.

1177
01:22:32,990 --> 01:22:39,486
But if I try to access the

1178
01:22:39,588 --> 01:22:43,930
private function, I cannot

1179
01:22:44,010 --> 01:22:46,870
access this function because it's private.

1180
01:22:47,050 --> 01:22:52,802
So this is the case to

1181
01:22:52,856 --> 01:22:56,738
demonstrate what happened if

1182
01:22:56,824 --> 01:23:00,642
I put my tests in one package

1183
01:23:00,706 --> 01:23:04,774
or in another. These test can be

1184
01:23:04,812 --> 01:23:07,974
located in the same directory but in

1185
01:23:08,012 --> 01:23:14,042
different package using this

1186
01:23:14,176 --> 01:23:17,734
underscore tests at the end of the testing

1187
01:23:17,782 --> 01:23:21,178
package. So the recommendation is to

1188
01:23:21,264 --> 01:23:24,910
use this package for the test to test

1189
01:23:24,980 --> 01:23:29,002
the public functions and only in the cases

1190
01:23:29,066 --> 01:23:33,982
that we need to have

1191
01:23:34,036 --> 01:23:37,406
an exhaustive testing of.

1192
01:23:37,588 --> 01:23:41,066
Some of our private packages

1193
01:23:41,258 --> 01:23:44,222
use the same package of the code.

1194
01:23:44,356 --> 01:23:46,938
Okay, this is the recommendation.

1195
01:23:47,034 --> 01:23:51,382
Prefer use another package to test

1196
01:23:51,436 --> 01:23:53,190
the public functions.

1197
01:23:54,970 --> 01:23:59,302
Okay, I want to finish my talk with

1198
01:23:59,356 --> 01:24:02,450
a brief introduction to behavior driven development

1199
01:24:02,530 --> 01:24:05,882
because it's a topic that I think it's very

1200
01:24:05,936 --> 01:24:10,220
useful for us and very interesting too.

1201
01:24:10,670 --> 01:24:14,578
What's the motivation behind behavior driven

1202
01:24:14,614 --> 01:24:18,078
development? It's to focus on the gap between

1203
01:24:18,244 --> 01:24:22,254
specification and coding. What it means when

1204
01:24:22,292 --> 01:24:25,822
we specify our software, we are talking

1205
01:24:25,876 --> 01:24:29,358
about user stories, acceptance criteria,

1206
01:24:29,534 --> 01:24:34,462
and those artifacts commonly

1207
01:24:34,526 --> 01:24:37,630
are defined in terms of human language,

1208
01:24:37,790 --> 01:24:41,342
maybe sometimes using Gerkin syntax.

1209
01:24:41,486 --> 01:24:45,494
This group of, and you

1210
01:24:45,532 --> 01:24:48,600
know, and for the other side,

1211
01:24:48,970 --> 01:24:53,174
we have a test suite that, it's a

1212
01:24:53,212 --> 01:24:56,710
group of many tests,

1213
01:24:57,610 --> 01:25:01,478
but those tests are commonly created based

1214
01:25:01,564 --> 01:25:05,278
on plain code language. So it, it's hard

1215
01:25:05,364 --> 01:25:09,134
to match a couple

1216
01:25:09,172 --> 01:25:12,590
of acceptance criteria with a couple

1217
01:25:12,660 --> 01:25:15,520
of tests. It's not easy.

1218
01:25:16,050 --> 01:25:21,938
So the idea is to have a way to make

1219
01:25:22,024 --> 01:25:26,180
easy these match between acceptance criteria and test.

1220
01:25:26,630 --> 01:25:30,450
And then behavior driven development uses

1221
01:25:30,530 --> 01:25:34,706
a simple DSL, a domain specific language to convert

1222
01:25:34,818 --> 01:25:37,938
structured human language into executable

1223
01:25:38,034 --> 01:25:41,560
tests. Okay, so the idea is

1224
01:25:42,830 --> 01:25:48,106
to make easy the

1225
01:25:48,128 --> 01:25:52,390
task to match between acceptance criteria

1226
01:25:52,470 --> 01:25:56,240
and every related test

1227
01:25:57,250 --> 01:26:00,270
related to this acceptance criteria.

1228
01:26:01,890 --> 01:26:05,546
Well, there are many testing

1229
01:26:05,578 --> 01:26:09,070
frameworks that offers behavior driven development

1230
01:26:09,150 --> 01:26:12,334
style. I prefer

1231
01:26:12,462 --> 01:26:16,370
Ginkgo, but there are others like

1232
01:26:16,440 --> 01:26:20,280
Gocon, B. Goblin, Mao, and Sen. So you can choose

1233
01:26:20,730 --> 01:26:24,470
the one that fits better for your

1234
01:26:24,540 --> 01:26:27,974
requirements. So an

1235
01:26:28,012 --> 01:26:31,640
example for why we can,

1236
01:26:32,010 --> 01:26:35,526
or how we can use ginkgo in a behavior driven

1237
01:26:35,558 --> 01:26:39,594
development scenario. Imagine that we have a

1238
01:26:39,632 --> 01:26:43,434
user story, a very simple user story. These is an example.

1239
01:26:43,552 --> 01:26:47,194
As a dean, I want to know if a student is eligible

1240
01:26:47,242 --> 01:26:51,326
for a scholarship so that I'll have enough information to

1241
01:26:51,348 --> 01:26:54,782
prepare the scholarships budget. It's very

1242
01:26:54,836 --> 01:26:59,134
simple. This user story defines

1243
01:26:59,262 --> 01:27:01,490
four acceptance criteria.

1244
01:27:03,030 --> 01:27:06,946
Given a student that is part of the medicine program,

1245
01:27:07,048 --> 01:27:10,886
and these GPA is over 80. These it's eligible for

1246
01:27:10,908 --> 01:27:14,178
a scholarship. And there are another cases.

1247
01:27:14,354 --> 01:27:18,326
Okay, so why I prefer Ginkgo and

1248
01:27:18,348 --> 01:27:22,078
Gomera? Ginkgo first offers a BDD

1249
01:27:22,114 --> 01:27:25,898
style testing framework, but offers a

1250
01:27:25,904 --> 01:27:29,270
lot of functions like describe context,

1251
01:27:29,350 --> 01:27:33,274
gwen it and many others that allows us to

1252
01:27:33,312 --> 01:27:36,890
create tests based on this acceptance criteria

1253
01:27:36,970 --> 01:27:40,720
with little effort and are very

1254
01:27:42,210 --> 01:27:45,246
human readable too. Okay,

1255
01:27:45,348 --> 01:27:49,010
and comega. Comega is a mature assertion library.

1256
01:27:49,350 --> 01:27:53,042
Yeah, it's very similar to the

1257
01:27:53,096 --> 01:27:56,770
assert package of testify.

1258
01:27:58,550 --> 01:28:03,202
But this API helps us to represent expectations

1259
01:28:03,346 --> 01:28:08,886
in this acceptance criteria. So the

1260
01:28:08,908 --> 01:28:13,566
combination on Ginkgo and Gomega allows

1261
01:28:13,698 --> 01:28:17,658
us to create tests that are very close

1262
01:28:17,824 --> 01:28:21,690
to the language user in the acceptance criteria.

1263
01:28:22,750 --> 01:28:26,080
So let's go and see an example of this.

1264
01:28:26,450 --> 01:28:30,874
This is an example for the first acceptance

1265
01:28:30,922 --> 01:28:34,286
criteria. And here we

1266
01:28:34,308 --> 01:28:37,790
are representing the checking scholarship

1267
01:28:37,870 --> 01:28:42,290
eligibility. When the program is medicine,

1268
01:28:42,630 --> 01:28:46,740
we create a context that is the and operation of the

1269
01:28:47,110 --> 01:28:50,742
acceptance criteria. And these GPA is over

1270
01:28:50,796 --> 01:28:54,214
80, then the

1271
01:28:54,252 --> 01:28:58,790
then will be the it in Ginkgo

1272
01:29:00,090 --> 01:29:04,010
receives the scholarship. And inside the it that is

1273
01:29:04,080 --> 01:29:07,338
the test itself, we can

1274
01:29:07,504 --> 01:29:11,014
include the expectations from the Gomela.

1275
01:29:11,142 --> 01:29:14,942
So as you see, it's very, very easy

1276
01:29:14,996 --> 01:29:18,766
to read this test and match

1277
01:29:18,948 --> 01:29:22,942
that. Those two tests are part

1278
01:29:22,996 --> 01:29:25,706
of the first acceptance criteria.

1279
01:29:25,898 --> 01:29:29,646
So this is the idea behind behavior driven

1280
01:29:29,678 --> 01:29:32,946
development, to make easy

1281
01:29:33,048 --> 01:29:37,330
these match between acceptance criteria and tests.

1282
01:29:38,390 --> 01:29:41,794
Well, these funk

1283
01:29:41,922 --> 01:29:45,560
test section. It's a requirement to connect

1284
01:29:46,010 --> 01:29:49,302
the ginkgo and Gomega to the go

1285
01:29:49,356 --> 01:29:52,886
testing tool. So it's a

1286
01:29:52,988 --> 01:29:56,438
function that we always need to add.

1287
01:29:56,524 --> 01:30:00,850
But the really important part is the describe

1288
01:30:00,930 --> 01:30:04,366
section that we are creating here,

1289
01:30:04,508 --> 01:30:08,654
the acceptance criteria that

1290
01:30:08,772 --> 01:30:12,720
will be executed as test

1291
01:30:13,330 --> 01:30:15,790
in our test suite.

1292
01:30:18,790 --> 01:30:21,380
So this is all.

1293
01:30:24,230 --> 01:30:27,694
I share a couple of links

1294
01:30:27,742 --> 01:30:30,962
and reference the first two are very interesting.

1295
01:30:31,096 --> 01:30:35,078
The first is the test driven development by example

1296
01:30:35,164 --> 01:30:37,880
book by Ken Peck. It's a very important,

1297
01:30:39,370 --> 01:30:43,814
it's a must to read a

1298
01:30:43,852 --> 01:30:47,302
book for testing purposes. And the second

1299
01:30:47,356 --> 01:30:51,254
one is a very interesting page x

1300
01:30:51,292 --> 01:30:55,294
unit patterns. So. So with

1301
01:30:55,412 --> 01:30:58,654
these two assets, I think that we can

1302
01:30:58,772 --> 01:31:02,190
start with testing practices.

1303
01:31:05,010 --> 01:31:08,690
There are links for testify, Ginkgo and Gomega.

1304
01:31:09,590 --> 01:31:13,586
And that's all. Thank you very much for joining me in

1305
01:31:13,608 --> 01:31:17,074
this session. If you have any question, you can find

1306
01:31:17,112 --> 01:31:19,882
me using my nickname, fdinus,

1307
01:31:20,046 --> 01:31:25,720
or send me an email to fdinus@gmail.com.

1308
01:31:26,170 --> 01:31:28,834
And remember, as a gophers,

1309
01:31:28,962 --> 01:31:32,566
we have many options to

1310
01:31:32,748 --> 01:31:35,160
make test, to create test.

1311
01:31:36,650 --> 01:31:40,742
So just go and put

1312
01:31:40,796 --> 01:31:44,494
this in practice. See you another

1313
01:31:44,572 --> 01:31:45,340
ten by.

