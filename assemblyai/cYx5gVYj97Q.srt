1
00:00:00,410 --> 00:00:06,126
Jamaica make up real

2
00:00:06,148 --> 00:00:09,902
time feedback into the behavior of your distributed systems and

3
00:00:09,956 --> 00:00:13,374
observing changes exceptions. Errors in

4
00:00:13,412 --> 00:00:16,666
real time allows you to not only experiment with confidence,

5
00:00:16,778 --> 00:00:20,480
but respond instantly to get things working again.

6
00:00:24,610 --> 00:01:05,638
Close can

7
00:01:05,674 --> 00:01:09,294
welcome to my talk. I would like to thank the organizers

8
00:01:09,342 --> 00:01:12,450
for giving me an opportunity to speak at this conference.

9
00:01:12,790 --> 00:01:16,022
I will be speaking about defining a steady, steady,

10
00:01:16,076 --> 00:01:19,510
steady states developing hypotheses, security chaos engineering.

11
00:01:19,850 --> 00:01:23,538
So the primary focus will be to discuss challenges

12
00:01:23,634 --> 00:01:26,962
in moving chaos experiments beyond regular

13
00:01:27,026 --> 00:01:29,130
testing of downtime and resiliency.

14
00:01:30,190 --> 00:01:33,786
Finally, I'll also be exploring how these challenges can

15
00:01:33,808 --> 00:01:37,146
be addressed by utilizing existing security benchmarks and

16
00:01:37,168 --> 00:01:40,218
frameworks. And what I

17
00:01:40,304 --> 00:01:43,646
hope by end of this talk is to explore a concept that

18
00:01:43,668 --> 00:01:47,610
would help adoption of security chaos engineering to broader cybersecurity

19
00:01:47,690 --> 00:01:51,646
practices. So, a little introduction about myself I

20
00:01:51,668 --> 00:01:55,566
am Sakshyam Shah and I currently work as a developer relations engineer

21
00:01:55,598 --> 00:01:59,042
at Teleport. For those of you who you don't know,

22
00:01:59,096 --> 00:02:02,562
teleport is teleport provides passwordless access

23
00:02:02,616 --> 00:02:05,974
to infrastructure. It's one of the most easiest yet

24
00:02:06,012 --> 00:02:09,270
secure access to SSH servers,

25
00:02:09,850 --> 00:02:13,622
Windows servers, kubernetes, clusters, databases, and web application across

26
00:02:13,676 --> 00:02:17,298
all environments. Before teleport, I have eight years of experience

27
00:02:17,404 --> 00:02:21,030
exclusively in cybersecurity. Been doing both offensive

28
00:02:21,110 --> 00:02:24,774
and defensive stuff. And besides cybersecurity,

29
00:02:24,902 --> 00:02:27,946
I love talking about new technologies and startups in

30
00:02:27,968 --> 00:02:31,118
general. So if you have any question or you want to

31
00:02:31,124 --> 00:02:34,266
connect with me, feel free to ping me in either Twitter

32
00:02:34,298 --> 00:02:36,640
or LinkedIn. Happy to chat with you.

33
00:02:37,330 --> 00:02:40,858
So let's begin by explaining

34
00:02:40,874 --> 00:02:44,706
what is security chaos Engineering? Please bear with me on this.

35
00:02:44,808 --> 00:02:48,354
This is chaos Engineering conference, and I can bet that there

36
00:02:48,392 --> 00:02:52,066
are speakers who can explain what is

37
00:02:52,088 --> 00:02:55,970
security chaos engineering more appropriately than me. But then again,

38
00:02:56,040 --> 00:03:00,014
just let me set a stage for the topic. So security

39
00:03:00,072 --> 00:03:03,474
chaos engineering is applied chaos engineering to validate

40
00:03:03,522 --> 00:03:06,310
security implementation and test for resiliency.

41
00:03:07,130 --> 00:03:09,690
To understand secure chaos engineering,

42
00:03:10,270 --> 00:03:13,782
you first have to understand what led to the whole chaos

43
00:03:13,846 --> 00:03:17,574
engineering itself. In a typical software application developing

44
00:03:17,622 --> 00:03:21,166
and delivery process, developer writes unit test,

45
00:03:21,268 --> 00:03:24,862
they write integration test, they write end to end test,

46
00:03:24,916 --> 00:03:28,030
and the applications are deployed in production.

47
00:03:28,930 --> 00:03:32,802
But despite all those testes, despite 100%

48
00:03:32,856 --> 00:03:37,410
test coverage, applications are bound to fail crash

49
00:03:38,550 --> 00:03:42,100
or they are bound to

50
00:03:42,710 --> 00:03:46,398
face a downtime. And the reason for downtime can

51
00:03:46,424 --> 00:03:50,114
be related directly to the application itself or can be affected

52
00:03:50,162 --> 00:03:54,226
by many other dependency that goes into production. So that's

53
00:03:54,258 --> 00:03:57,014
where chaos engineering comes in and tells that,

54
00:03:57,052 --> 00:04:00,700
okay, despite the fact that you tested all those stuff,

55
00:04:01,870 --> 00:04:05,558
the application services are still crashing in production.

56
00:04:05,654 --> 00:04:08,842
So let's just try to find out those

57
00:04:08,896 --> 00:04:13,246
unknowns way before they

58
00:04:13,268 --> 00:04:17,120
become an incident in production. So chaos engineering comes in and

59
00:04:18,610 --> 00:04:22,454
tries with many experimentation to validate

60
00:04:22,522 --> 00:04:26,930
assumptions that the test written are actually working as expected.

61
00:04:27,350 --> 00:04:30,978
So security chaos engineering, it works in the same way.

62
00:04:31,144 --> 00:04:34,466
So despite organizations practicing security

63
00:04:34,568 --> 00:04:38,354
for a very long time, so organizations

64
00:04:38,402 --> 00:04:42,018
are buying security products, the next gen firewalls

65
00:04:42,034 --> 00:04:46,274
and whatnot, they have been implementing both security reactive

66
00:04:46,322 --> 00:04:50,134
and proactive practices. They have been doing vulnerability assessment,

67
00:04:50,182 --> 00:04:53,482
pen testing, red teaming. They are awareing their

68
00:04:53,536 --> 00:04:57,254
users, end users, internal employees

69
00:04:57,302 --> 00:05:00,878
and even developers for secure software development practices for security

70
00:05:00,964 --> 00:05:04,410
awareness. Yet, despite all these efforts,

71
00:05:04,570 --> 00:05:08,160
data breach is nowhere going to end anytime soon.

72
00:05:12,050 --> 00:05:15,282
Security chaos engineering comes in and tells that,

73
00:05:15,336 --> 00:05:18,674
okay, despite all the fact and effort that we put in

74
00:05:18,712 --> 00:05:19,300
security,

75
00:05:22,950 --> 00:05:27,074
the rate of compromisation of any organization is just growing

76
00:05:27,122 --> 00:05:31,782
and it's not stopping anytime soon. So let's just try to find

77
00:05:31,836 --> 00:05:35,654
those unknowns that can

78
00:05:35,692 --> 00:05:39,180
escalate to a data breach. Let's try to find those things

79
00:05:39,710 --> 00:05:42,854
earlier as much as possible so that they are prevented

80
00:05:42,902 --> 00:05:46,870
in the future. So security chaos engineering involves experimentation

81
00:05:46,950 --> 00:05:51,162
to validate assumption and find the unknowns. Basically test

82
00:05:51,216 --> 00:05:54,414
the effectiveness of all the controls that have already been

83
00:05:54,452 --> 00:05:58,318
implemented. So the way I see it, in a short, is security

84
00:05:58,404 --> 00:06:02,670
chaos engineering are test to validate all the teams

85
00:06:03,350 --> 00:06:05,890
how a chaos experiment is conducted.

86
00:06:07,190 --> 00:06:11,166
A typical chaos experiment starts

87
00:06:11,198 --> 00:06:14,690
by defining a steady state by measuring a normal behavior,

88
00:06:15,030 --> 00:06:18,214
so how the application behaves in a normal case.

89
00:06:18,412 --> 00:06:22,130
Then a hypothesis is developed

90
00:06:22,210 --> 00:06:26,294
with a what if scenario to create can experimental process

91
00:06:26,492 --> 00:06:30,438
and some chaotic variables are introduced which will affect the CD,

92
00:06:30,534 --> 00:06:33,660
which tries to affect the CD state of application.

93
00:06:34,110 --> 00:06:37,354
And at the end we measure the

94
00:06:37,392 --> 00:06:40,534
results and validate that.

95
00:06:40,672 --> 00:06:44,400
Are the assumptions still correct or not? For example,

96
00:06:45,250 --> 00:06:48,878
let's say that we have an application service responsible for

97
00:06:48,964 --> 00:06:52,606
handling 1 million requests per second. That's a steady state of that

98
00:06:52,628 --> 00:06:55,998
application. So a chaos engineer comes in and tells

99
00:06:56,014 --> 00:06:59,554
that, okay, what if the caching proxy in front of this

100
00:06:59,592 --> 00:07:03,940
application service is down for ten minutes? In that case,

101
00:07:04,550 --> 00:07:07,606
would our application service still be able

102
00:07:07,628 --> 00:07:10,646
to handle 1 million requests per second? So the

103
00:07:10,668 --> 00:07:14,360
chaos engineering comes in and deliberately takes down the

104
00:07:14,810 --> 00:07:18,070
existing proxy and takes

105
00:07:18,140 --> 00:07:21,980
some metrics and tries to again come with a result that

106
00:07:22,350 --> 00:07:26,138
tests that. In that case, would the application service really

107
00:07:26,304 --> 00:07:28,986
can handle 1 million requests per second?

108
00:07:29,088 --> 00:07:32,814
And if it can't handle that, then we have fined and

109
00:07:32,852 --> 00:07:36,910
the chaos engineer has find an unknown that was thought to be

110
00:07:36,980 --> 00:07:40,874
already addressed by developers or reliability

111
00:07:40,922 --> 00:07:44,670
engineers. But then again, despite all those efforts, we can verify

112
00:07:44,750 --> 00:07:48,274
that in fact the application service will

113
00:07:48,312 --> 00:07:51,634
not be able to perform as it is supposed

114
00:07:51,672 --> 00:07:56,070
to perform. So that's a typical example of chaos experiment.

115
00:07:56,410 --> 00:07:59,720
So how this can be related to security.

116
00:08:00,170 --> 00:08:04,466
So first thing is of course an obvious testing

117
00:08:04,498 --> 00:08:07,922
for resiliency. Testing for resiliency

118
00:08:07,986 --> 00:08:11,450
is route. That's not related to only security

119
00:08:11,520 --> 00:08:15,066
chaos engineering, but the regular chaos engineering in general as well.

120
00:08:15,168 --> 00:08:18,950
So in testing for resiliency, so we have lots of expectations

121
00:08:19,030 --> 00:08:22,286
for resiliency. And as a

122
00:08:22,308 --> 00:08:25,902
developer, as a site reliability engineer, always think that

123
00:08:25,956 --> 00:08:29,434
the application or service will work as expected

124
00:08:29,562 --> 00:08:32,030
in the server or in the production.

125
00:08:33,270 --> 00:08:36,494
If you take this topic

126
00:08:36,542 --> 00:08:39,966
resiliency and try to relate it with modern

127
00:08:40,078 --> 00:08:43,762
infrastructure or application development and deployment process,

128
00:08:43,816 --> 00:08:46,982
that is cloud native and that is cloud

129
00:08:47,036 --> 00:08:50,914
native along with many microservices. So a typical

130
00:08:50,962 --> 00:08:54,966
resiliency dependency of an application has grown lot

131
00:08:55,148 --> 00:08:58,554
bigger. For example, I have a picture here in this

132
00:08:58,592 --> 00:09:02,774
slide which shows the resiliency dependency of an infrastructure

133
00:09:02,822 --> 00:09:06,602
access solution, right? Access control, infrastructure access

134
00:09:06,656 --> 00:09:10,182
solution. We take these things for granted and

135
00:09:10,256 --> 00:09:15,130
we think that okay, what could there be? Just might be a host

136
00:09:15,210 --> 00:09:18,910
bastion server or VPN server, or modern access

137
00:09:18,980 --> 00:09:22,506
proxy that allows the access. But then you

138
00:09:22,548 --> 00:09:25,874
can see that a typical access control solution in modern infrastructure has

139
00:09:25,912 --> 00:09:29,246
many, many resiliency dependency. For example, it depends

140
00:09:29,278 --> 00:09:33,390
on identity providers, access providers, certificate authorities,

141
00:09:33,470 --> 00:09:36,786
multifactor authentication providers, hardware security models,

142
00:09:36,818 --> 00:09:41,062
approval systems, routers and files and switches. And these are just the main

143
00:09:41,196 --> 00:09:44,278
dependency that I've listed here. So there are many

144
00:09:44,364 --> 00:09:49,846
ways an application can face disruption

145
00:09:49,958 --> 00:09:53,382
due to failure of the dependency

146
00:09:53,446 --> 00:09:57,014
that it depends to operate its whole feature

147
00:09:57,062 --> 00:09:59,942
set. So assumptions can be like, okay,

148
00:10:00,016 --> 00:10:04,506
so the services can withstand downtime of this dependency

149
00:10:04,698 --> 00:10:08,506
and a developer or DevOps

150
00:10:08,538 --> 00:10:12,046
engineer comes in and tells that, okay, a whole new infrastructure service can

151
00:10:12,068 --> 00:10:15,940
be running in under five minutes, and we have already tested for it.

152
00:10:16,470 --> 00:10:19,938
Security engineers can come and tell you that in case

153
00:10:20,024 --> 00:10:23,906
we find a vulnerability, the security patches can be applied as

154
00:10:23,928 --> 00:10:27,682
soon as patch is available. So these are the general assumptions

155
00:10:27,826 --> 00:10:31,714
that existing in operation infrastructure

156
00:10:31,762 --> 00:10:35,186
operations of every organization. So security with secured

157
00:10:35,218 --> 00:10:38,626
chaos engineering, we try to validate

158
00:10:38,658 --> 00:10:41,746
these assumptions. For example, so for testing

159
00:10:41,778 --> 00:10:44,426
for resiliency, for example,

160
00:10:44,528 --> 00:10:47,766
is surviving a downtime due to outage of service provider,

161
00:10:47,798 --> 00:10:52,026
okay, so when a DevOps engineer

162
00:10:52,058 --> 00:10:56,014
comes and tells you that the service can withstand downtime of

163
00:10:56,052 --> 00:10:59,166
a certain dependency chaos, engineers can come and

164
00:10:59,268 --> 00:11:03,246
okay, let's try to check if that assumption

165
00:11:03,278 --> 00:11:06,926
is correct. And they can introduce chaotic variables which include

166
00:11:06,958 --> 00:11:10,238
shutting down containers, virtual machines, servers,

167
00:11:10,334 --> 00:11:14,142
disconnecting network interfaces. They can also mock a dependency

168
00:11:14,206 --> 00:11:16,150
downtime to validate the assumptions.

169
00:11:18,010 --> 00:11:21,398
Let's say when there is an assumption that security patches can

170
00:11:21,404 --> 00:11:25,138
be applied as soon as the patch is available. So chaos engineering

171
00:11:25,314 --> 00:11:28,346
can come in and try to check that.

172
00:11:28,448 --> 00:11:32,090
Okay, is that assumption true in any regard?

173
00:11:32,240 --> 00:11:36,566
So how much time does it actually takes for upgrades

174
00:11:36,598 --> 00:11:40,518
and patches? Do we even have an infrastructure ready for

175
00:11:40,704 --> 00:11:43,710
rolling out certain kinds of patches to

176
00:11:43,780 --> 00:11:47,326
our fleet of servers in our infrastructure? What happens when new

177
00:11:47,348 --> 00:11:50,654
pipelines and workflows being introduced? Okay, we talk

178
00:11:50,692 --> 00:11:54,242
about security, but are we in a position that

179
00:11:54,296 --> 00:11:57,970
would help us smoothly roll out credential rotation

180
00:11:58,630 --> 00:12:02,126
operations like rotation of passwords, API keys and certificate

181
00:12:02,158 --> 00:12:06,098
authorities without a downtime?

182
00:12:06,274 --> 00:12:10,150
So obviously these things are already

183
00:12:10,220 --> 00:12:13,240
thought out when they are designed. But then again,

184
00:12:14,170 --> 00:12:17,742
given operations inside any organization,

185
00:12:17,906 --> 00:12:21,466
the changes are bound to happen. There will be drift in

186
00:12:21,488 --> 00:12:25,900
configurations. Some new introduction of new workflows will

187
00:12:26,670 --> 00:12:30,650
have a side effect on existing procedure, and they can

188
00:12:30,720 --> 00:12:34,126
affect the resiliency of what the assumptions we

189
00:12:34,148 --> 00:12:37,662
already have thought out or test out. So security chaos engineering can

190
00:12:37,716 --> 00:12:41,934
come in and test for those assumptions. Okay, now we are venturing more

191
00:12:42,132 --> 00:12:45,330
into core cybersecurity topics.

192
00:12:45,750 --> 00:12:48,818
So testing for effectiveness of security

193
00:12:48,904 --> 00:12:53,102
controls example of security administrators

194
00:12:53,166 --> 00:12:56,658
comes and tells that web application

195
00:12:56,824 --> 00:13:00,258
firewall policy will detect cross site scripting attacks.

196
00:13:00,354 --> 00:13:04,214
A SoC engineer will come and tell that, okay, our SIEM policies are

197
00:13:04,332 --> 00:13:07,522
configured to detect credential compromise and lateral moment

198
00:13:07,596 --> 00:13:11,226
adversarial tactics. And security engineer of

199
00:13:11,248 --> 00:13:15,210
a web application comes and tells that, okay, in case our x

200
00:13:15,280 --> 00:13:19,066
application is compromised, it still will only be affect the

201
00:13:19,088 --> 00:13:22,714
y database and not be able to pivot beyond that

202
00:13:22,752 --> 00:13:26,270
database. So these are the generic types of

203
00:13:26,340 --> 00:13:30,238
generic assumptions we have inside of our security

204
00:13:30,324 --> 00:13:34,082
operations. The problem with testing these type of

205
00:13:34,136 --> 00:13:37,694
assumptions when it comes to security chaos engineering

206
00:13:37,742 --> 00:13:42,190
is how can you define and measure a steady

207
00:13:42,270 --> 00:13:46,014
state appropriately? For example, when an administrator

208
00:13:46,062 --> 00:13:50,166
tells that, okay, WaF policy will detect cross site scripting attack

209
00:13:50,348 --> 00:13:54,550
in this case. So it's really hard to take

210
00:13:54,620 --> 00:13:58,380
metrics and measurements in terms of security.

211
00:13:58,830 --> 00:14:03,340
For example, in regular chaos testing, you can go and take a measurement of

212
00:14:04,110 --> 00:14:07,610
the example I gave earlier, that handling of 1 million

213
00:14:07,680 --> 00:14:12,694
requests per second. You can collect bandwidth

214
00:14:12,742 --> 00:14:16,246
metrics, you can collect cpu and memory metrics,

215
00:14:16,358 --> 00:14:19,534
right? So you can take

216
00:14:19,572 --> 00:14:22,622
metrics that's related to request handle per second,

217
00:14:22,756 --> 00:14:26,682
send those data to monitoring

218
00:14:26,746 --> 00:14:30,786
dashboard, prometheus and Grafana dashboards, and you

219
00:14:30,808 --> 00:14:34,370
can collect metrics. But it's lot hard to apply

220
00:14:34,440 --> 00:14:38,120
the same concept to security because you can

221
00:14:38,970 --> 00:14:41,862
quantify security in terms of, let's say,

222
00:14:41,916 --> 00:14:45,894
okay, the security that we have applied is 100% secure or

223
00:14:45,932 --> 00:14:49,980
90% secure. And now we want to test

224
00:14:50,590 --> 00:14:54,266
a hypothesis and check if it will reduce the security to

225
00:14:54,288 --> 00:14:57,994
80% or 90%. So that's not justifiable in

226
00:14:58,032 --> 00:15:02,282
terms when we speak about security. So when can administrator

227
00:15:02,346 --> 00:15:05,978
tells that policy will detect cross site scripting attacks?

228
00:15:06,074 --> 00:15:10,250
There are many, many ways to bypass that cross site scripting attacks.

229
00:15:10,410 --> 00:15:14,034
If you go and check the existing cross site

230
00:15:14,072 --> 00:15:17,282
scripting bypass cheat sheets, there are many.

231
00:15:17,416 --> 00:15:20,834
And given the condition and the pace where the

232
00:15:20,872 --> 00:15:23,714
front end developing ecosystem is moving forward with,

233
00:15:23,832 --> 00:15:26,962
the chances are that more of bypass techniques will be

234
00:15:27,016 --> 00:15:30,774
found in the future. And this is just not ever going to stop.

235
00:15:30,812 --> 00:15:34,034
So it's hard to quantify that. The steady

236
00:15:34,082 --> 00:15:37,302
state of this application we are testing against is already

237
00:15:37,436 --> 00:15:41,210
the best and possible way about it. So in a similar states,

238
00:15:41,360 --> 00:15:45,050
what should you test? Okay, you can test for a hypothesis,

239
00:15:45,790 --> 00:15:49,322
and again, it's hard to quantify that. This hypothesis is

240
00:15:49,376 --> 00:15:53,918
bound to test that if the CD state will decrease to certain numbers

241
00:15:54,004 --> 00:15:57,578
that we can measure in terms of security chaos experiments

242
00:15:57,754 --> 00:16:00,830
and exactly what variables should we introduce?

243
00:16:01,410 --> 00:16:04,946
Will this going to be enough? So these are the generic problems

244
00:16:05,048 --> 00:16:08,734
you will be facing when trying to test effectiveness

245
00:16:08,782 --> 00:16:12,334
of security controls and with continuing

246
00:16:12,382 --> 00:16:15,730
on that. So when the chaos experiments

247
00:16:15,810 --> 00:16:19,238
now tries to directly tackle with

248
00:16:19,244 --> 00:16:22,646
the existing security processes that's already in

249
00:16:22,668 --> 00:16:26,070
place in your organization, now the biggest question

250
00:16:26,140 --> 00:16:29,562
your team will have is how can you align these

251
00:16:29,616 --> 00:16:32,870
experiments with existing security processes?

252
00:16:33,030 --> 00:16:37,126
So where does security chaos testing fit? Can we adapt

253
00:16:37,158 --> 00:16:39,980
security chaos testing to speed up compliance process?

254
00:16:40,290 --> 00:16:44,106
These are the questions when do you even start security chaos testing?

255
00:16:44,138 --> 00:16:48,654
So these are the questions that

256
00:16:48,692 --> 00:16:52,726
the security chaos engineer aspiring or the practitioner

257
00:16:52,778 --> 00:16:56,482
will be facing when they try to venture out more

258
00:16:56,536 --> 00:17:00,190
inside testing of existing security processes.

259
00:17:00,350 --> 00:17:04,254
So this is where the core

260
00:17:04,302 --> 00:17:07,590
topic of my talk is how security

261
00:17:07,740 --> 00:17:11,862
chaos engineering based on security benchmarks and frameworks and

262
00:17:11,916 --> 00:17:15,414
best practices allows us to

263
00:17:15,532 --> 00:17:18,614
align security chaos engineering with existing

264
00:17:18,662 --> 00:17:21,610
security processes in your organization.

265
00:17:22,030 --> 00:17:25,098
So it's just a way that would help us for a

266
00:17:25,104 --> 00:17:28,726
broader adoption of chaos engineering, because chaos engineering

267
00:17:28,758 --> 00:17:32,414
is a good concept and it must be practiced, but unless it is

268
00:17:32,452 --> 00:17:35,946
aligned with existing security process in your organization,

269
00:17:36,138 --> 00:17:38,590
it wouldn't go much further.

270
00:17:39,490 --> 00:17:42,770
Okay, so what I mean by security

271
00:17:42,840 --> 00:17:46,606
benchmarks and best practices? So there are security baselines

272
00:17:46,638 --> 00:17:49,934
such as CIS benchmarks or vendor

273
00:17:49,982 --> 00:17:52,798
specific best practices like AWS,

274
00:17:52,894 --> 00:17:56,614
Azure, Google cloud best

275
00:17:56,652 --> 00:17:59,640
practices for identity and access management, for example.

276
00:18:00,410 --> 00:18:03,766
And you have compliance specific controls such

277
00:18:03,788 --> 00:18:07,586
as PCI, DSS, HIPAA, or SoC whatever

278
00:18:07,708 --> 00:18:11,578
compliance your organization is following. Then you have

279
00:18:11,664 --> 00:18:14,186
security frameworks such as Mitra, attack,

280
00:18:14,368 --> 00:18:17,946
cyber kill, can, et cetera. So these are the examples of

281
00:18:17,968 --> 00:18:21,374
security baselines, benchmarks, frameworks that

282
00:18:21,572 --> 00:18:25,710
one way or another your organization is already practicing

283
00:18:26,690 --> 00:18:30,286
or have implemented few parts of it. So how

284
00:18:30,308 --> 00:18:33,620
can you introduce chaos testing in those parts? Right? So for example,

285
00:18:34,790 --> 00:18:38,782
here is testing effective implementation of cis benchmark.

286
00:18:38,926 --> 00:18:43,054
So as an example, I have taken benchmark

287
00:18:43,102 --> 00:18:46,470
that's related to access control of cis v eight.

288
00:18:46,620 --> 00:18:50,434
So in that benchmark,

289
00:18:50,482 --> 00:18:54,294
so you have list of these things that the benchmark tells you to do.

290
00:18:54,412 --> 00:18:57,858
And if you

291
00:18:57,884 --> 00:19:01,894
pass security audit, chances are that you will have a green light among

292
00:19:01,942 --> 00:19:06,006
all this implementation. But security proper, the purpose

293
00:19:06,038 --> 00:19:08,874
of security chaos testing is to come and check, okay,

294
00:19:09,072 --> 00:19:12,350
although we have implemented these benchmarks,

295
00:19:13,090 --> 00:19:17,182
have we implemented them correctly? A security auditor will not go that

296
00:19:17,236 --> 00:19:21,242
far to try to validate all these assumptions.

297
00:19:21,386 --> 00:19:25,122
The compliance security auditor will come and most probably will

298
00:19:25,176 --> 00:19:29,186
check that you have implemented or not. So this

299
00:19:29,208 --> 00:19:32,402
is where security chaos engineering can come in and tell

300
00:19:32,456 --> 00:19:36,022
that, okay, we are going to validate this assumptions based

301
00:19:36,076 --> 00:19:40,178
on experiments. So for example, you might have already implemented

302
00:19:40,274 --> 00:19:43,320
access granting process, access revoking process,

303
00:19:44,090 --> 00:19:48,214
require multifactor authentication for externally exposed

304
00:19:48,262 --> 00:19:51,802
application remote network access, or for administrator access,

305
00:19:51,936 --> 00:19:55,322
and have defined maintenance role based access control, right?

306
00:19:55,456 --> 00:19:58,726
But security chaos engineering comes in and tells,

307
00:19:58,758 --> 00:20:02,394
okay, let's try to validate our assumption that

308
00:20:02,432 --> 00:20:06,634
we have implemented requirement for multi effect authentication for administrative

309
00:20:06,682 --> 00:20:10,654
access and the test cases can be okay, can other

310
00:20:10,692 --> 00:20:14,674
special policy override this requirement? Or let's say if

311
00:20:14,712 --> 00:20:18,334
we deploy a new application that doesn't require multifactor authentication

312
00:20:18,382 --> 00:20:22,066
for administrative access, will this be detected? So these are

313
00:20:22,088 --> 00:20:25,226
the types of test cases that can be introduced.

314
00:20:25,358 --> 00:20:28,982
And these

315
00:20:29,036 --> 00:20:32,342
types of changes will happen one

316
00:20:32,396 --> 00:20:35,602
day or another, later or sooner,

317
00:20:35,746 --> 00:20:39,478
because the static state of any organization

318
00:20:39,574 --> 00:20:42,906
is never true. And changes

319
00:20:43,008 --> 00:20:46,374
happen as the team grows, as the requirements grows.

320
00:20:46,502 --> 00:20:50,274
There are many teams responsible for handling managing

321
00:20:50,342 --> 00:20:53,722
infrastructures. There will be many new teams

322
00:20:53,786 --> 00:20:57,546
responsible for developing new applications,

323
00:20:57,658 --> 00:21:01,726
whether it's customer facing application or internal application.

324
00:21:01,908 --> 00:21:06,526
So it will affect the current state of infrastructure.

325
00:21:06,718 --> 00:21:10,482
And again, there will be changes in drift in

326
00:21:10,536 --> 00:21:13,986
configurations. So these assumptions will come in

327
00:21:14,008 --> 00:21:18,054
and try to validate the same assumptions and might be

328
00:21:18,092 --> 00:21:20,600
that at current point of time,

329
00:21:21,450 --> 00:21:25,046
the security policies will detect a new application that

330
00:21:25,148 --> 00:21:28,406
has been deployed without requiring multifactor authentication.

331
00:21:28,518 --> 00:21:32,022
But later stage of your organization,

332
00:21:32,166 --> 00:21:35,158
as the team grows, as the requirement grows,

333
00:21:35,334 --> 00:21:39,100
some policies or new workflows might have already disturbed that

334
00:21:39,710 --> 00:21:43,822
security policy. So chaos engineering comes in and can

335
00:21:43,876 --> 00:21:46,110
help you validate those assumptions.

336
00:21:47,010 --> 00:21:50,794
Second thing is we can also use chaos

337
00:21:50,922 --> 00:21:55,090
testing to test for adversarial tactics

338
00:21:55,910 --> 00:21:59,934
that will help to test for breach readiness withstanding

339
00:21:59,982 --> 00:22:04,034
adversarial tactics, test for threat contentment or

340
00:22:04,152 --> 00:22:08,242
validating blast radius. And so these tactics

341
00:22:08,306 --> 00:22:12,146
are well mentioned, well cataloged

342
00:22:12,178 --> 00:22:15,160
in frameworks such as mitre attack,

343
00:22:15,770 --> 00:22:19,834
cyber kill chain, Gartner's cyber attack

344
00:22:20,032 --> 00:22:23,878
model, NIST cybersecurity framework.

345
00:22:24,054 --> 00:22:27,530
And these are the primary ones that are popular in security

346
00:22:27,600 --> 00:22:31,470
industry. So how can we introduce chaos experiments

347
00:22:32,050 --> 00:22:35,920
within these frameworks? Right? So for example, I have taken can

348
00:22:36,530 --> 00:22:39,834
sample of adversarial tactics that is related

349
00:22:39,882 --> 00:22:43,490
to enterprise metrics of mitre attack

350
00:22:43,640 --> 00:22:49,122
and for example of this

351
00:22:49,176 --> 00:22:52,926
talk. So I've taken four primary tactics.

352
00:22:53,118 --> 00:22:55,640
Example are initial access,

353
00:22:56,010 --> 00:22:59,240
credential access, privilege, escalation and lateral moment.

354
00:22:59,930 --> 00:23:04,210
These are the common tactics that are presented in enterprise metrics.

355
00:23:04,290 --> 00:23:07,570
So we can take subtactics.

356
00:23:07,650 --> 00:23:11,142
For example, here we have in credential access we have modify

357
00:23:11,206 --> 00:23:14,630
authentication process so we can test that although

358
00:23:14,710 --> 00:23:18,746
these, in a typical security mature organization, these things would

359
00:23:18,768 --> 00:23:22,826
have been already practiced. So as a security chaos engineer,

360
00:23:22,938 --> 00:23:26,846
our propose is to validate the assumption that even

361
00:23:27,028 --> 00:23:30,414
that our system is ready to detect this stuff.

362
00:23:30,532 --> 00:23:34,162
We will come with assumptions that, okay, what if in certain cases we

363
00:23:34,216 --> 00:23:36,770
might miss this detection?

364
00:23:38,230 --> 00:23:41,486
For example, I have taken here a sample of tactics

365
00:23:41,518 --> 00:23:45,226
that is modified authentication process. So we can take that topic

366
00:23:45,278 --> 00:23:48,982
as the security chaos experiment and build

367
00:23:49,036 --> 00:23:52,726
our hypothesis that, okay, SoC team should

368
00:23:52,748 --> 00:23:56,246
be alerted. That's the assumption of the

369
00:23:56,268 --> 00:24:00,294
security team. That SoC team will be alerted if there is a modification in authentication

370
00:24:00,342 --> 00:24:03,430
process. Now, as a security chaos engineer,

371
00:24:03,510 --> 00:24:07,786
we go and deliberately change the authentication process from

372
00:24:07,968 --> 00:24:11,706
SAML to oath and disable the lock server

373
00:24:11,738 --> 00:24:13,760
for 20 minutes and resume it back.

374
00:24:15,250 --> 00:24:17,600
The hypothesis here is that, okay,

375
00:24:19,330 --> 00:24:23,874
the policy is defined to detect a change in authentication process,

376
00:24:23,992 --> 00:24:27,746
but what if when lock server is down for 20 minutes or

377
00:24:27,768 --> 00:24:30,482
cannot handle request for 20 minutes, right?

378
00:24:30,616 --> 00:24:34,126
So we do that as a security chaos engineer.

379
00:24:34,238 --> 00:24:37,540
And in the fourth step,

380
00:24:41,030 --> 00:24:44,386
we might discuss or chat with Sock team that if it's

381
00:24:44,418 --> 00:24:48,410
been detected or alerted or not. If not, it means that process

382
00:24:48,480 --> 00:24:52,006
responsible for shipping logs is existing,

383
00:24:52,038 --> 00:24:55,626
a retry mechanism. Maybe that was implemented way before,

384
00:24:55,728 --> 00:24:59,430
maybe not, maybe it never was implemented, but that's

385
00:24:59,510 --> 00:25:03,046
unknown. We found that in certain cases that a log server

386
00:25:03,078 --> 00:25:06,206
is unable to handle requests for 20 minutes, we will

387
00:25:06,228 --> 00:25:09,594
be missing the alerts that were related

388
00:25:09,642 --> 00:25:15,220
to the change process, and we might miss this whole

389
00:25:15,830 --> 00:25:19,682
alert of can adversarial tactics that

390
00:25:19,736 --> 00:25:21,890
has been already going in your network.

391
00:25:22,550 --> 00:25:26,534
So these are the examples of how chaos experiments can

392
00:25:26,572 --> 00:25:30,306
be performed with respect to existing

393
00:25:30,338 --> 00:25:33,494
security frameworks. But again, why should we

394
00:25:33,532 --> 00:25:37,640
do that? To summarize, is that

395
00:25:38,170 --> 00:25:41,754
it will help you catch misconfigurations or logical flaws that are

396
00:25:41,792 --> 00:25:45,066
introduced over time. As I said, drifts are bound to

397
00:25:45,088 --> 00:25:49,482
happen and changes in workflow will introduce new side

398
00:25:49,536 --> 00:25:53,114
effects in your existing security policies. So it will help to catch

399
00:25:53,162 --> 00:25:56,560
misconfiguration or logical flaws that are introduced over time.

400
00:25:56,930 --> 00:26:00,554
Then it also helps to automate and close gap

401
00:26:00,602 --> 00:26:04,266
between vulnerability assessment and penetration existing and incident response

402
00:26:04,298 --> 00:26:07,646
drills. The third one is that it will help to validate

403
00:26:07,678 --> 00:26:11,246
the effectiveness of existing security policies and security controls.

404
00:26:11,358 --> 00:26:15,800
Even if you don't find

405
00:26:16,570 --> 00:26:20,326
any flaws in the assumption, it's just a

406
00:26:20,348 --> 00:26:24,294
way of scientific way to say that, okay, rather than

407
00:26:24,332 --> 00:26:28,250
just ticking a box that we have implemented or not, we have actually

408
00:26:28,320 --> 00:26:32,314
just carried out some exercise that

409
00:26:32,352 --> 00:26:37,238
allows us to scientifically or mathematically justify

410
00:26:37,334 --> 00:26:40,418
that this is indeed being implemented,

411
00:26:40,614 --> 00:26:46,954
right? Then again, security chaos test with engaging

412
00:26:47,002 --> 00:26:51,098
security chaos experiment with existing security benchmarks and frameworks

413
00:26:51,114 --> 00:26:54,638
will also align security chaos test with existing security

414
00:26:54,724 --> 00:26:58,434
initiatives in your organization. So that means it will be helpful for

415
00:26:58,552 --> 00:27:02,082
executive buy ins or buy ins from the security team

416
00:27:02,136 --> 00:27:05,542
that okay, we should do chaos existing and that will help

417
00:27:05,596 --> 00:27:09,510
us increase our effectiveness rather than be

418
00:27:09,580 --> 00:27:13,030
just another security concept,

419
00:27:13,450 --> 00:27:17,678
okay, I mentioned earlier that lining chaos experiments

420
00:27:17,714 --> 00:27:20,842
with existing security benchmarks and frameworks would also

421
00:27:20,896 --> 00:27:24,778
allow us to close gap and align it with existing security

422
00:27:24,864 --> 00:27:28,410
practices. So any typical organization will have already

423
00:27:28,480 --> 00:27:32,762
been practicing proactive security practices such as vulnerability

424
00:27:32,826 --> 00:27:37,022
assessment, pen testing, incident response drills. So how

425
00:27:37,076 --> 00:27:40,666
will chaos experiment compare with existing proactive

426
00:27:40,698 --> 00:27:44,222
security practices? So for example, in this scenario,

427
00:27:44,286 --> 00:27:47,874
I have taken a case of just in

428
00:27:47,912 --> 00:27:50,514
time access request system.

429
00:27:50,712 --> 00:27:53,410
So in a vulnerability scanning,

430
00:27:54,150 --> 00:27:57,906
you are looking for known vulnerabilities in the GIT

431
00:27:57,938 --> 00:28:01,800
access granting system itself. In vulnerability research,

432
00:28:02,490 --> 00:28:06,146
you'll be looking and identifying previously unknown

433
00:28:06,178 --> 00:28:09,420
vulnerabilities that might affect the GIt system.

434
00:28:10,270 --> 00:28:12,380
In a penetration test,

435
00:28:13,790 --> 00:28:17,098
you try to find a way to bypass the Git access

436
00:28:17,184 --> 00:28:21,606
granting process by exploiting a known vulnerability or by developing

437
00:28:21,638 --> 00:28:25,298
a novel logical flaw explores or via

438
00:28:25,334 --> 00:28:29,150
social engineering and security engineering and security

439
00:28:29,220 --> 00:28:32,702
chaos testing, you will try to test

440
00:28:32,756 --> 00:28:36,750
that. What if the GiT system chaos crashed? Will a downgraded

441
00:28:36,830 --> 00:28:40,562
and can insecure access request system be activated and misused to

442
00:28:40,616 --> 00:28:44,446
bypass the Git policies? So these are the typical differences

443
00:28:44,558 --> 00:28:47,110
between each of the proactive security practices.

444
00:28:48,570 --> 00:28:53,282
So security chaos engineering comes with a unique

445
00:28:53,426 --> 00:28:56,902
point of view to validate the assumption. What if,

446
00:28:56,956 --> 00:29:00,934
despite the fact that policies has been implemented and deployed,

447
00:29:01,062 --> 00:29:04,986
will the change or downtime or

448
00:29:05,088 --> 00:29:09,066
any effect in the dependency will affect or

449
00:29:09,248 --> 00:29:12,880
lead to downgrade of security? That would just let the

450
00:29:15,330 --> 00:29:19,454
security control to be bypassed. So when to

451
00:29:19,492 --> 00:29:21,710
introduce security chaos testing?

452
00:29:22,550 --> 00:29:26,034
In this case, I've taken a sample of security and

453
00:29:26,072 --> 00:29:29,220
privacy capability maturity model,

454
00:29:30,070 --> 00:29:33,346
which is also known as SPCMM and short.

455
00:29:33,528 --> 00:29:37,334
And it

456
00:29:37,372 --> 00:29:40,694
just shows you how you can measure a

457
00:29:40,732 --> 00:29:44,626
maturity model of your security and privacy controls implemented

458
00:29:44,658 --> 00:29:49,100
in your organization. And it's just one of the framework given

459
00:29:49,550 --> 00:29:53,066
the industry your organization is on,

460
00:29:53,248 --> 00:29:56,700
might be following the other security maturity model.

461
00:29:57,150 --> 00:30:00,922
And again, this is just for example. So when should you introduce

462
00:30:01,066 --> 00:30:04,682
security chaos testing in organization? Personally,

463
00:30:04,746 --> 00:30:08,414
I believe that security chaos experiments works best when

464
00:30:08,452 --> 00:30:12,190
it is introduced later in your security process. For example,

465
00:30:12,260 --> 00:30:16,318
if you don't have any implemented cybersecurity

466
00:30:16,414 --> 00:30:20,862
baselines benchmarks if there is not any team that's

467
00:30:21,006 --> 00:30:24,922
practicing security, there's no point in conducting

468
00:30:25,006 --> 00:30:29,000
experiments and trying to find the unknowns, right? So first,

469
00:30:29,370 --> 00:30:32,706
the basic is that you have to go and implement basic

470
00:30:32,738 --> 00:30:36,066
controls. Ensure that the basic hardening

471
00:30:36,178 --> 00:30:39,126
stuffs have been implemented. The benchmarks,

472
00:30:39,238 --> 00:30:43,146
basic benchmarks or frameworks have been followed and implemented to

473
00:30:43,168 --> 00:30:47,158
tighten security and enhance security, right? So security chaos experiment

474
00:30:47,254 --> 00:30:51,214
is a way to validate the assumptions that you

475
00:30:51,252 --> 00:30:54,490
have once you have implemented all those security practices.

476
00:30:54,650 --> 00:30:58,410
Without that, I think it can be helpful

477
00:30:58,490 --> 00:31:02,582
if you use security chaos experiments just to identify a gap

478
00:31:02,666 --> 00:31:07,166
on where should you focus on implementing

479
00:31:07,198 --> 00:31:10,322
or prioritizing security. But again,

480
00:31:10,376 --> 00:31:13,780
the most effectiveness of security chaos experiments will come

481
00:31:14,970 --> 00:31:18,280
when you are later in the maturity model of security process.

482
00:31:19,050 --> 00:31:24,002
So that's about my presentation

483
00:31:24,066 --> 00:31:27,654
for today, concluding all

484
00:31:27,692 --> 00:31:31,478
the things that I've said is so secure chaos experiments

485
00:31:31,574 --> 00:31:34,380
are a noble way to find unknowns in security.

486
00:31:34,990 --> 00:31:38,618
But then again, the experiments should be aligned with existing security

487
00:31:38,704 --> 00:31:42,334
process to gain adoption. Otherwise, it's a good concept and

488
00:31:42,372 --> 00:31:45,662
it will have challenges to grow beyond just

489
00:31:45,716 --> 00:31:48,926
concepts and just a few steady, steady,

490
00:31:49,028 --> 00:31:52,618
steady states. Developing hypotheses, security baselines, benchmarks and

491
00:31:52,644 --> 00:31:55,966
frameworks would help security chaos engineering with existing

492
00:31:55,998 --> 00:31:59,586
security process. So the challenge is

493
00:31:59,608 --> 00:32:03,554
to align it with existing security process. And to address that

494
00:32:03,592 --> 00:32:07,654
challenge, we can integrate or bring

495
00:32:07,692 --> 00:32:11,954
the security chaos experiments to validate all the security controls

496
00:32:12,002 --> 00:32:15,110
that we have already placed in our organization.

497
00:32:16,010 --> 00:32:19,226
And security chaos testing should close the

498
00:32:19,248 --> 00:32:22,950
gaps not addressed with penetration test and incident response drills.

499
00:32:23,030 --> 00:32:26,666
So any mature security organization will have been

500
00:32:26,688 --> 00:32:30,602
practicing this proactive security practices, including penetration

501
00:32:30,666 --> 00:32:33,946
testing and incident response drills, vulnerability scanning.

502
00:32:33,978 --> 00:32:38,158
So security chaos experiment is not about replacing them,

503
00:32:38,324 --> 00:32:42,190
but it's about closing a gap that are left by these

504
00:32:42,260 --> 00:32:45,698
tests, right? So if you think that way, there's a

505
00:32:45,704 --> 00:32:49,090
spot for security chaos engineering. If your team

506
00:32:49,160 --> 00:32:53,102
wants to replace the existing process, then it will have a challenge

507
00:32:53,246 --> 00:32:56,802
to change what is already in place and followed

508
00:32:56,866 --> 00:33:00,280
by many many security teams over the world.

509
00:33:00,650 --> 00:33:04,866
So finally, and security chaos testing is more effective as organizations

510
00:33:04,898 --> 00:33:08,186
move closer to the highest level of security maturity model.

511
00:33:08,368 --> 00:33:12,122
So it's security chaos experiments. It works best

512
00:33:12,176 --> 00:33:15,894
to find the unknowns when the knowns are implemented

513
00:33:15,942 --> 00:33:19,654
correctly or have been implemented without the known knowns.

514
00:33:19,782 --> 00:33:23,630
You'll just be firing experiments all over the place without

515
00:33:23,780 --> 00:33:27,802
any good result and validate any security prior

516
00:33:27,866 --> 00:33:31,838
implemented security assumptions. Okay, that's it for my talk today.

517
00:33:32,004 --> 00:33:35,646
I hope it was helpful for those of you who started

518
00:33:35,828 --> 00:33:39,550
planning to start venturing out in security chaos experiments.

519
00:33:41,170 --> 00:33:44,446
I would like to thank again the organizers for giving me an

520
00:33:44,468 --> 00:33:47,590
opportunity to speak at this conference.

521
00:33:48,250 --> 00:33:51,800
If you have any questions feel free to ping me. I have

522
00:33:52,250 --> 00:33:55,558
provided with my social media handles in

523
00:33:55,564 --> 00:33:59,718
the earlier sites of this presentation. Okay thank you so much. Have a

524
00:33:59,804 --> 00:34:00,342
great day.

