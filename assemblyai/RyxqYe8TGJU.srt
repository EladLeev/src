1
00:00:41,250 --> 00:00:43,000
Hello and welcome.

2
00:00:44,970 --> 00:00:47,794
Today I'm going to be talking about open telemetry,

3
00:00:47,922 --> 00:00:51,710
specifically on how I got open telemetry working

4
00:00:51,780 --> 00:00:55,886
in a polyglot environment. Before we begin,

5
00:00:55,988 --> 00:01:00,270
my name is Michael Sickles and I'm a solutions architect at Honeycombio.

6
00:01:01,810 --> 00:01:05,966
And so I've been working with our customers recently setting

7
00:01:05,998 --> 00:01:09,502
up their instrumentation for their environments,

8
00:01:09,566 --> 00:01:12,526
using Opentelemetry to get application insights.

9
00:01:12,558 --> 00:01:16,354
And that's what it's really for. Opentelemetry gives you tools,

10
00:01:16,402 --> 00:01:20,134
APIs and sdks to ask questions about

11
00:01:20,172 --> 00:01:23,590
your system. So seeing things like traces, metrics and

12
00:01:23,660 --> 00:01:27,254
logs and why it's important and useful is

13
00:01:27,292 --> 00:01:31,642
that it's a standard so that you can spend

14
00:01:31,696 --> 00:01:35,980
the work to instrument and get these application insights once,

15
00:01:36,350 --> 00:01:39,226
but not have to redo it later.

16
00:01:39,408 --> 00:01:43,246
Typically, the old style is a lot of the vendors out there have their

17
00:01:43,268 --> 00:01:46,926
own proprietary format on how to add instrumentation and

18
00:01:46,948 --> 00:01:50,334
get insights. And it's frustrating when you want to either try

19
00:01:50,452 --> 00:01:54,078
multiple tools or switch to a new tool because it takes work that you

20
00:01:54,084 --> 00:01:57,362
have to lift and shift and rewrite code in order to try

21
00:01:57,416 --> 00:02:01,700
things out. With Opentelemetry, you do that once

22
00:02:02,150 --> 00:02:06,046
and then as you move along you can keep adding the opentelemetry

23
00:02:06,078 --> 00:02:09,494
insights as you develop new code. You can then

24
00:02:09,532 --> 00:02:12,486
point it to one or multiple vendors, to be honest.

25
00:02:12,588 --> 00:02:16,054
And from there you can see which tool is

26
00:02:16,092 --> 00:02:18,954
going to be best for your situation and where you're going to get the most

27
00:02:18,992 --> 00:02:22,506
value. You're no longer locked in just because of all

28
00:02:22,528 --> 00:02:27,018
that work you put in upfront. And so I

29
00:02:27,184 --> 00:02:30,794
wanted to find a good demo and

30
00:02:30,832 --> 00:02:34,174
good environment to help our customers see how to use

31
00:02:34,292 --> 00:02:37,834
Opentelemetry. There's a lot of examples

32
00:02:37,882 --> 00:02:41,438
on individual like here's a node app. How do you

33
00:02:41,444 --> 00:02:44,126
set it up for a node app? Here's a Java app. How do you set

34
00:02:44,148 --> 00:02:47,314
it up for a Java app? But there's not a lot of good tutorials or

35
00:02:47,352 --> 00:02:51,506
examples on something that's more complex, something that is

36
00:02:51,608 --> 00:02:55,338
distributed tracing and talking across multiple different kinds

37
00:02:55,374 --> 00:02:59,062
of code systems. And so I found the CNCF Google

38
00:02:59,116 --> 00:03:02,790
Microservices demo. This is a microservice on Kubernetes

39
00:03:03,290 --> 00:03:07,350
and it's polyglot, so it's got no Javago net and python,

40
00:03:08,010 --> 00:03:11,866
which also uses Opensensus. So Opensensus was

41
00:03:11,968 --> 00:03:16,310
the way it got its telemetry insights. And Opensensus

42
00:03:16,390 --> 00:03:20,106
is a standard before opentelemetry, and there was

43
00:03:20,128 --> 00:03:23,726
another standard called open tracing, and Opensensus and open tracing decided to

44
00:03:23,748 --> 00:03:27,306
come together. Let's unify the standard and have one. And that's

45
00:03:27,338 --> 00:03:30,878
where opentelemetry came about. They merged together. So I

46
00:03:30,884 --> 00:03:34,674
could take that open census instrumentation and know I

47
00:03:34,712 --> 00:03:38,398
can switch it over to the open telemetry style.

48
00:03:38,574 --> 00:03:42,482
There might be some semantic differences, but I could say,

49
00:03:42,616 --> 00:03:45,666
look here, it's using Opensensus to get insight here.

50
00:03:45,768 --> 00:03:49,560
Let's get insight in opentelemetry as well.

51
00:03:50,090 --> 00:03:53,926
The application itself is on

52
00:03:53,948 --> 00:03:57,554
the right and it's an ecommerce website. It allows you to find

53
00:03:57,612 --> 00:04:00,460
items to add to your cart, check out,

54
00:04:01,070 --> 00:04:04,506
you can convert different currencies, you can get ads. And these

55
00:04:04,528 --> 00:04:07,580
are the different services that make up your application.

56
00:04:09,710 --> 00:04:13,006
And what's going to happen is we're going to start at our front end,

57
00:04:13,028 --> 00:04:16,222
which is written in go, and we're going to take some kind of

58
00:04:16,276 --> 00:04:20,510
action. Maybe it's add to cart or check

59
00:04:20,580 --> 00:04:24,398
out or see ad. These are

60
00:04:24,484 --> 00:04:27,882
the traces, and I'll get more into that later

61
00:04:28,036 --> 00:04:31,234
that we're going to follow through as it makes a call to a back end

62
00:04:31,272 --> 00:04:34,802
service which might make calls to other back end services. And these are on different

63
00:04:34,856 --> 00:04:38,326
servers and that's the different coding languages. We want to be

64
00:04:38,348 --> 00:04:41,990
able to watch one call, one action, one transaction,

65
00:04:42,490 --> 00:04:46,626
and see all the different pieces that that action

66
00:04:46,738 --> 00:04:50,198
talks to and connects to. And what that allows us to do then is we

67
00:04:50,204 --> 00:04:53,606
can see where slowness might be in the system or where there's

68
00:04:53,638 --> 00:04:57,338
errors in my system. I can target and get to root cause faster with a

69
00:04:57,344 --> 00:05:01,260
tool like Opentelemetry and some vendor out there.

70
00:05:03,090 --> 00:05:06,766
When I was considering how do I instrument, what do I

71
00:05:06,788 --> 00:05:10,090
want to do? I right away thought I'm going to reuse

72
00:05:10,590 --> 00:05:14,478
that open census code like I mentioned before, it's already in place.

73
00:05:14,564 --> 00:05:17,794
I can just convert it to open telemetry semantics and open

74
00:05:17,832 --> 00:05:21,618
telemetry libraries. It will give us good insights. Just going to

75
00:05:21,624 --> 00:05:24,594
go follow the front end to the back end. So I'll start with that front

76
00:05:24,632 --> 00:05:28,098
end first, move my way to the other services it talks to. And then I'm

77
00:05:28,114 --> 00:05:32,338
going to use automatic instrumenting when possible. When you're

78
00:05:32,514 --> 00:05:35,894
going through and adding telemetry to your system, all the different code

79
00:05:35,932 --> 00:05:39,158
languages have various ways to have automatic insights.

80
00:05:39,174 --> 00:05:42,726
And that can vary from automatically hooking say to the JVM

81
00:05:42,758 --> 00:05:46,454
for Java to pulling in specific wrappers

82
00:05:46,502 --> 00:05:50,338
that are going to wrap the libraries themselves and say like node

83
00:05:50,374 --> 00:05:54,698
js to automatically do tracing for us and automatically

84
00:05:54,874 --> 00:05:58,094
starting and stopping units of work for those

85
00:05:58,132 --> 00:06:01,566
libraries. So if we can do less work for us,

86
00:06:01,588 --> 00:06:04,862
that's great, right? That's another benefit of opentelemetry

87
00:06:05,006 --> 00:06:08,210
is we have all these different organizations working

88
00:06:08,280 --> 00:06:11,426
on it where that if there is a library being used

89
00:06:11,448 --> 00:06:16,014
at one organization and they can then add the instrumentation

90
00:06:16,062 --> 00:06:19,746
pieces that might make its way upstream into open telemetry, then any other organizations

91
00:06:19,778 --> 00:06:23,110
that might use those libraries can get insights. Finally,

92
00:06:23,180 --> 00:06:26,566
though, that I'm going to want to add manual instrumentation as well. So you can

93
00:06:26,588 --> 00:06:30,458
get a lot from automatic instrumentation, but it can only take you so far.

94
00:06:30,624 --> 00:06:34,582
You know your system better than anyone else and no automatic

95
00:06:34,646 --> 00:06:38,266
instrumentation is going to get to where you need to really understand the state of

96
00:06:38,288 --> 00:06:42,266
your system because you got this auto

97
00:06:42,298 --> 00:06:45,534
instrumentation, which is good, but take it to the next

98
00:06:45,572 --> 00:06:49,262
level. You can add things like user details or

99
00:06:49,396 --> 00:06:52,878
server details or product details that

100
00:06:52,964 --> 00:06:56,394
are really going to be those nuanced differences on why

101
00:06:56,452 --> 00:07:00,482
your system might be performing or breaking in different ways. And by

102
00:07:00,536 --> 00:07:03,810
adding in those details you can ask more questions about your system.

103
00:07:03,880 --> 00:07:06,786
And that's what we ultimately want to do is we want to understand how it's

104
00:07:06,818 --> 00:07:11,542
performing and maybe for whom does it suck it in my system before

105
00:07:11,596 --> 00:07:15,218
I go on a little bookkeeping here, terminology.

106
00:07:15,394 --> 00:07:19,210
So a span is a unit of work.

107
00:07:19,280 --> 00:07:23,126
It's an action encode, it's maybe a function, a method,

108
00:07:23,238 --> 00:07:26,778
and it took some amount of time, it took

109
00:07:26,944 --> 00:07:30,862
three milliseconds, 20 milliseconds. It's something we

110
00:07:30,916 --> 00:07:34,666
measured and then we have a span attribute. So we're

111
00:07:34,698 --> 00:07:38,430
going to add contextual details. That's that user id,

112
00:07:38,500 --> 00:07:42,346
session id. We want to add the variables

113
00:07:42,378 --> 00:07:45,498
in our code to the span so I could understand what was going

114
00:07:45,524 --> 00:07:49,394
on in my system at that specific point in time. And then

115
00:07:49,512 --> 00:07:52,786
I can add span events that is essentially a

116
00:07:52,808 --> 00:07:56,254
log attached to a span, more or less. It's something that doesn't

117
00:07:56,302 --> 00:08:00,022
necessarily have a duration, but is something that is

118
00:08:00,076 --> 00:08:03,926
interesting. So for example, an exception, if there is an exception, we want to take

119
00:08:03,948 --> 00:08:07,426
that information and attach it to this specific point in time. That span,

120
00:08:07,458 --> 00:08:11,162
that unit of work, it's where it happened. But an exception doesn't trace

121
00:08:11,296 --> 00:08:14,602
a certain amount of time. It's just something that happened at a point

122
00:08:14,656 --> 00:08:18,490
in time. A trace then is a collection of

123
00:08:18,560 --> 00:08:21,862
spans for a certain action that add to cart that

124
00:08:21,936 --> 00:08:25,134
check out. That is something that your

125
00:08:25,172 --> 00:08:28,606
users are doing and it's going to touch different spans as

126
00:08:28,628 --> 00:08:32,942
it goes through different pieces of your code and connect them together using

127
00:08:32,996 --> 00:08:36,894
a unique id, so that opentelemetry is automatically

128
00:08:36,942 --> 00:08:40,514
generating that id and able to connect it across your code.

129
00:08:40,632 --> 00:08:43,874
That your vendor tool choice is going to be able then to

130
00:08:43,912 --> 00:08:47,286
render it some way in the UI in some kind of view to make

131
00:08:47,308 --> 00:08:50,838
sense of that. If you ever see me talk about OtLP in this

132
00:08:51,004 --> 00:08:55,126
presentation, OTLP is just the specific protocol and

133
00:08:55,148 --> 00:08:59,862
format for opentelemetry itself. And then exporters,

134
00:09:00,006 --> 00:09:02,698
exporter is where we are sending our data.

135
00:09:02,784 --> 00:09:06,134
So you can export to the window, the console window,

136
00:09:06,182 --> 00:09:10,230
or we can export to a vendor, we can export to

137
00:09:10,400 --> 00:09:13,630
somewhere those application insights.

138
00:09:14,290 --> 00:09:18,206
So I started with the front end and we can see

139
00:09:18,308 --> 00:09:21,902
that I ripped out the open

140
00:09:21,956 --> 00:09:23,870
census libraries.

141
00:09:24,610 --> 00:09:28,286
And this code. By the way, this GitHub repo

142
00:09:28,318 --> 00:09:31,202
of where I made these changes will be at the end of the presentation as

143
00:09:31,256 --> 00:09:35,650
a follow up for if you want to go in and see the specific things

144
00:09:35,720 --> 00:09:38,806
that I changed from open census to opentelemetry, you can

145
00:09:38,828 --> 00:09:42,738
see all the changes I did using the get history and compare.

146
00:09:42,914 --> 00:09:46,134
I'm not going to throw in every single little code change I did just because

147
00:09:46,172 --> 00:09:50,154
it'd be something it took me a couple of hours to do and

148
00:09:50,192 --> 00:09:52,410
thus I can't keep it in one presentation.

149
00:09:53,550 --> 00:09:56,986
But yeah, I loaded the open telemetry sdks so you can

150
00:09:57,008 --> 00:10:00,650
see us changing. You can see some

151
00:10:00,800 --> 00:10:03,814
of the libraries have similar namings.

152
00:10:03,862 --> 00:10:08,426
So for example there's an open census trace. Well there's also an open telemetry trace.

153
00:10:08,538 --> 00:10:12,894
So that idea of traces and spans are similar across the two.

154
00:10:13,092 --> 00:10:16,322
And then I have this idea of auto instrumentation and go,

155
00:10:16,376 --> 00:10:19,906
we're going to have wrappers around the various libraries. So in this case I have

156
00:10:19,928 --> 00:10:23,794
a gorilla mux router and I want to automatically get

157
00:10:23,832 --> 00:10:27,566
insights on my different HTTP requests. So there is a library out there that

158
00:10:27,608 --> 00:10:31,110
exists that automatically does that for me. I import it in and then just

159
00:10:31,180 --> 00:10:34,886
wrap my router when

160
00:10:34,908 --> 00:10:38,278
we go through in opentelemetry. This is going to be pretty common across

161
00:10:38,364 --> 00:10:41,818
all the different coding languages. But we're going to go through and we're going

162
00:10:41,824 --> 00:10:45,226
to create some kind of exporter. We need to send our data to

163
00:10:45,248 --> 00:10:48,538
a location. I've removed some vendor specific

164
00:10:48,624 --> 00:10:52,394
information in here, but the gist is you're going to send it to some API

165
00:10:52,442 --> 00:10:55,562
endpoint. If that API endpoint is secure,

166
00:10:55,626 --> 00:10:59,070
you're going to have to be careful with that and that

167
00:10:59,140 --> 00:11:02,854
you're going to want to have some SSL credentials.

168
00:11:02,922 --> 00:11:06,258
So this is something, this is a nuance I found. Going through

169
00:11:06,424 --> 00:11:09,646
go doesn't automatically infer if it's

170
00:11:09,758 --> 00:11:13,726
HTTP or HTTPs. You have to add in these blank

171
00:11:13,838 --> 00:11:17,314
credentials to say hey, this is going to a secure

172
00:11:17,362 --> 00:11:21,014
endpoint, but if yours going to an unsecure endpoint you wouldn't need that

173
00:11:21,052 --> 00:11:25,090
specific piece and we're exporting in that OTLP

174
00:11:25,170 --> 00:11:28,566
format over GRPC. The next thing we're going to do is

175
00:11:28,588 --> 00:11:32,074
we are going to create this tracer. So what this trace does

176
00:11:32,112 --> 00:11:35,754
is it's going to automatically propagate the trace context, the tracing information,

177
00:11:35,872 --> 00:11:38,700
connect and create that unique id.

178
00:11:39,070 --> 00:11:42,806
And then we're having this spam processor that's just processing

179
00:11:42,838 --> 00:11:46,506
our spans. We have a batch span processor. Rather than hitting the endpoint

180
00:11:46,538 --> 00:11:49,966
for every single event, it's going to batch them together so that you can save

181
00:11:49,988 --> 00:11:53,066
some network bandwidth and we just have to add a little bit more contextual

182
00:11:53,098 --> 00:11:56,738
information. You added a service name for my front end here.

183
00:11:56,904 --> 00:12:00,066
Beyond that, there's a couple of other pieces in code that

184
00:12:00,088 --> 00:12:03,442
I wanted to add. You can see at the top that

185
00:12:03,496 --> 00:12:07,030
R use middleware. And when you look at the code, that is me

186
00:12:07,100 --> 00:12:12,914
taking that opentelemetry middleware and wrapping my gorilla

187
00:12:12,962 --> 00:12:16,726
mux router and getting that auto instrumentation piece. That's what I

188
00:12:16,748 --> 00:12:19,738
wanted. Right. Beyond that,

189
00:12:19,904 --> 00:12:23,606
the microservices demo uses GrPC to communicate

190
00:12:23,638 --> 00:12:27,414
to all the different backends. So there is actually an open telemetry

191
00:12:27,462 --> 00:12:32,170
GrPC wrapper as well. And so I was able to utilize that to automatically

192
00:12:32,250 --> 00:12:35,898
add trace, connect and span durations

193
00:12:35,994 --> 00:12:39,534
for my GRPC calls. So great rest work for

194
00:12:39,572 --> 00:12:43,098
me. But I do need some

195
00:12:43,124 --> 00:12:44,530
manual instrumentation.

196
00:12:45,430 --> 00:12:48,498
Ultimately, if I'm going to ask questions about my system,

197
00:12:48,664 --> 00:12:52,402
I want to understand what is going on in my code. So for example,

198
00:12:52,536 --> 00:12:56,450
maybe that session id, I get a support email and

199
00:12:56,520 --> 00:12:59,734
I can look at that session id to be able to see what happened

200
00:12:59,772 --> 00:13:03,366
for that user. So not only am I understanding high

201
00:13:03,388 --> 00:13:06,694
level details of how my system is performing and how my calls are doing,

202
00:13:06,812 --> 00:13:10,646
I now am empowered with extra details for

203
00:13:10,668 --> 00:13:13,834
the variables and code. I have things like an email,

204
00:13:13,952 --> 00:13:17,002
in this case a zip code, state, country and session. But I can add

205
00:13:17,056 --> 00:13:20,126
absolutely anything that I think will be useful for me later when I want to

206
00:13:20,148 --> 00:13:24,062
ask questions about that data. So with that

207
00:13:24,116 --> 00:13:28,170
I was able to deploy it. The Google microservices

208
00:13:28,250 --> 00:13:31,722
demo uses scaffold to automatically deploy in this Kubernetes

209
00:13:31,786 --> 00:13:36,482
environment. This is in our AWS cluster and

210
00:13:36,536 --> 00:13:39,570
honestly I just took that front end

211
00:13:39,720 --> 00:13:43,218
instrumentation and I copied it.

212
00:13:43,384 --> 00:13:46,726
There is three other go services and how you do it in one

213
00:13:46,748 --> 00:13:50,406
coding language, you reuse that copy and

214
00:13:50,428 --> 00:13:54,290
paste, just change the service name. I uses the same like GRPC

215
00:13:54,370 --> 00:13:58,598
wrappers because they also use GRPC to communicate. It was

216
00:13:58,764 --> 00:14:02,858
something that was pretty easy once I got the first front end working.

217
00:14:03,024 --> 00:14:06,506
So from there I needed to do my next service

218
00:14:06,608 --> 00:14:09,734
and I was looking downstream, like I said, front end to backend.

219
00:14:09,782 --> 00:14:11,920
Well this front end is touching this ad service.

220
00:14:12,530 --> 00:14:17,386
Java is really nice. So for Java

221
00:14:17,578 --> 00:14:21,454
it has an agent. This is different from the other

222
00:14:21,652 --> 00:14:25,338
libraries and other coding technologies. Those use sdks.

223
00:14:25,514 --> 00:14:28,866
Java has an agent that can hook into the JVM itself. And as

224
00:14:28,888 --> 00:14:32,786
it hooks into the JVM you just set a couple of environment variables you

225
00:14:32,808 --> 00:14:36,194
can see down here on the bottom and

226
00:14:36,232 --> 00:14:39,734
it's coming to the rescue. It's just going to hook into and has a long

227
00:14:39,772 --> 00:14:43,014
list of automatic instrumentations, tons of different libraries like

228
00:14:43,052 --> 00:14:46,418
spring and databases and HTTP calls,

229
00:14:46,594 --> 00:14:50,570
Kafka. It's going to wrap those automatically for you from

230
00:14:50,640 --> 00:14:53,818
the JVM context and you're using to

231
00:14:53,824 --> 00:14:56,614
get a lot of good insights in Java.

232
00:14:56,662 --> 00:15:00,378
Java is Ga. Now when I originally did this and you look at

233
00:15:00,384 --> 00:15:03,626
the code, I still need to update it. It was version like 16

234
00:15:03,658 --> 00:15:07,726
or 17, but now that it's Ga I do need to eventually update to

235
00:15:07,748 --> 00:15:11,438
the newest Java agent. So starting with this Java agent,

236
00:15:11,524 --> 00:15:15,214
that's great. But there was existing open census

237
00:15:15,262 --> 00:15:18,626
manual instrumentation and one of the things I wanted to do as I said is

238
00:15:18,728 --> 00:15:22,210
reuse it, right? And so you can see how

239
00:15:22,360 --> 00:15:26,020
the terminology is very similar

240
00:15:26,490 --> 00:15:30,582
from the open census to opentelemetry. And this is common

241
00:15:30,716 --> 00:15:34,118
across a lot of the other languages as well. But here you can see

242
00:15:34,284 --> 00:15:37,766
I wanted to add attributes and in

243
00:15:37,788 --> 00:15:41,526
open census it was put attribute. Now I just switch

244
00:15:41,558 --> 00:15:46,118
it over to set attribute, easy change, add annotation

245
00:15:46,294 --> 00:15:49,686
became add event. So now I have a span event and I have that logging

246
00:15:49,718 --> 00:15:53,034
information with context about my Java application and that's

247
00:15:53,082 --> 00:15:56,734
awesome. Java also has a really neat thing

248
00:15:56,852 --> 00:16:00,650
in that you can take the manual instrumentation and sdks

249
00:16:00,730 --> 00:16:04,014
and hook into the automatic instrumentation. So it has

250
00:16:04,052 --> 00:16:07,646
this app with span annotation that will automatically wrap

251
00:16:07,678 --> 00:16:12,178
your function, call here and do the tracing and the

252
00:16:12,264 --> 00:16:15,598
timing for that span, that get add span, which is

253
00:16:15,624 --> 00:16:19,560
great. And then I can get this span current to

254
00:16:19,930 --> 00:16:23,650
get the specific span in the auto instrumentation,

255
00:16:23,730 --> 00:16:27,970
that point in time that I am at and add in different attributes.

256
00:16:28,050 --> 00:16:31,218
So that's that set attribute, the add event, et cetera. This allows

257
00:16:31,234 --> 00:16:34,602
me not to have to sit there and manually start and stop my

258
00:16:34,656 --> 00:16:38,298
spans. That's something I was trying to avoid if at all possible. Just that's a

259
00:16:38,304 --> 00:16:41,562
little bit more work with this. I got going

260
00:16:41,616 --> 00:16:44,934
pretty quickly and I started seeing ad

261
00:16:44,992 --> 00:16:49,520
service information in my code or in my vendor tool.

262
00:16:50,450 --> 00:16:54,542
So I'm going to continue down that path of I want to trace

263
00:16:54,686 --> 00:16:57,140
across multiple parts of my system.

264
00:16:57,510 --> 00:17:01,074
Moving down from the checkout service I see that it touches two

265
00:17:01,112 --> 00:17:04,526
node services. So I decided let's

266
00:17:04,558 --> 00:17:06,340
just go there next.

267
00:17:08,070 --> 00:17:11,510
So inside my payment service this is one of them node is

268
00:17:11,580 --> 00:17:14,758
a little bit different and this is common theme. There's going to be a little

269
00:17:14,764 --> 00:17:18,642
bit nuances. The node code uses this tracing

270
00:17:18,786 --> 00:17:22,806
js file and that's going to be start up

271
00:17:22,988 --> 00:17:26,714
with the node command. So you'll see in the docker image for this

272
00:17:26,752 --> 00:17:30,538
in the source code I just added hey start up

273
00:17:30,544 --> 00:17:34,014
with this tracing js and I'm using to go through

274
00:17:34,052 --> 00:17:37,550
and do similar things. I'm going to have an auto instrumentation piece.

275
00:17:37,620 --> 00:17:41,246
Note is nice in that you can wrap or

276
00:17:41,268 --> 00:17:45,006
rewrite the javascript code. So in

277
00:17:45,028 --> 00:17:48,834
this case I have plugins and I'm loading in a GRPC plugin. Once again

278
00:17:48,872 --> 00:17:51,950
GrPC calls is what it's making and an HTTP plugin,

279
00:17:52,030 --> 00:17:55,726
but there's multiple plugins out there. There's an exprs plugin.

280
00:17:55,838 --> 00:17:59,078
If you go on NPm you can find them and it's also

281
00:17:59,164 --> 00:18:03,062
on the GitHub and it

282
00:18:03,116 --> 00:18:06,040
might not be yet in the docs, but I'm sure it'll be there soon.

283
00:18:06,410 --> 00:18:08,870
You just Npm install these plugins.

284
00:18:10,010 --> 00:18:13,802
In reality I shouldn't have had to actually manually put

285
00:18:13,856 --> 00:18:17,306
this plugin code this plugins and enabled and location it should

286
00:18:17,328 --> 00:18:21,142
have automatically according to the docs done it for me. It wasn't working.

287
00:18:21,216 --> 00:18:24,938
So I manually said hey, these are my plugin names, this is where they're located,

288
00:18:25,034 --> 00:18:28,414
please enable them from

289
00:18:28,452 --> 00:18:30,720
there. We're setting up a collector again,

290
00:18:31,170 --> 00:18:34,274
Java didn't have it where you needed to do this. Create SSl. But no,

291
00:18:34,312 --> 00:18:37,566
does I have to create SSL credentials if I'm

292
00:18:37,598 --> 00:18:41,634
sending to a secure endpoint? And in this case for this

293
00:18:41,672 --> 00:18:45,438
specific implementation I am. And with that I'm

294
00:18:45,454 --> 00:18:48,802
also exporting in my OTLp format and GRPC.

295
00:18:48,866 --> 00:18:52,578
So I have to be mindful of using the right nodejs

296
00:18:52,594 --> 00:18:56,246
libraries. GrPC is usable in the back end so I could

297
00:18:56,268 --> 00:19:00,246
use that and my otlp format so I can send it directly

298
00:19:00,278 --> 00:19:03,546
to this vendor. With that creating my

299
00:19:03,568 --> 00:19:07,018
trace I'm using to in this case just kick it off,

300
00:19:07,104 --> 00:19:10,338
register it and add the instrumentation auto

301
00:19:10,454 --> 00:19:14,206
pieces and go see what is in my

302
00:19:14,228 --> 00:19:18,094
UI eventually. But there is

303
00:19:18,132 --> 00:19:21,450
some things to understand. There's more nuance,

304
00:19:21,530 --> 00:19:26,002
it's not always great. For example,

305
00:19:26,136 --> 00:19:29,826
when I wrote this nodejs and it still might not

306
00:19:29,848 --> 00:19:32,994
be ga, I'm pretty sure it's still not ga. But it's working towards it.

307
00:19:33,032 --> 00:19:36,338
Node not being ga means that there are going

308
00:19:36,344 --> 00:19:39,318
to be sometimes changes to the spec,

309
00:19:39,404 --> 00:19:43,238
the APIs and how you do things. And this is a case of when I

310
00:19:43,324 --> 00:19:47,302
originally did this. Compared to now, there is a little bit different

311
00:19:47,356 --> 00:19:52,198
on how you might do things. I will eventually update

312
00:19:52,294 --> 00:19:56,662
the repository to use the new method and add in the versions

313
00:19:56,726 --> 00:20:00,742
or update to the newest version of the node JS opentelemetry. But essentially

314
00:20:00,806 --> 00:20:03,738
it's similar. Instead of a plugin, it's an instrumentation.

315
00:20:03,834 --> 00:20:07,440
It's still loading that auto piece and wrapping around it.

316
00:20:09,330 --> 00:20:12,602
All right, so now I have my two node services. Once again

317
00:20:12,756 --> 00:20:17,010
I'm just copying and pasting

318
00:20:17,910 --> 00:20:21,570
my tracing js and I'm going to move on to the next piece.

319
00:20:21,720 --> 00:20:25,794
And that next piece I decided to go downstream to this

320
00:20:25,832 --> 00:20:29,650
cart service. Coming from that checkout service, it's net core,

321
00:20:29,810 --> 00:20:33,506
and with net core and net there's

322
00:20:33,618 --> 00:20:36,998
once again more nuances. So these are things that I had to kind

323
00:20:37,004 --> 00:20:40,250
of work out going through the documentation, going through the GitHub repos.

324
00:20:40,910 --> 00:20:44,902
Net uses the built in Microsoft profiling libraries.

325
00:20:44,966 --> 00:20:49,286
And so there's a little bit of differences in namings.

326
00:20:49,398 --> 00:20:52,606
Like if you were to use the manual instrumentation, you'll see they have a little

327
00:20:52,628 --> 00:20:56,510
bit different terminology on adding attributes, putting attributes, et cetera.

328
00:20:57,010 --> 00:21:01,258
But at a high level, getting that automatic instrumentation

329
00:21:01,354 --> 00:21:05,342
was very similar. Pretty straightforward in that I have a startup file

330
00:21:05,406 --> 00:21:08,850
where I am configuring my services and I'm using to

331
00:21:09,000 --> 00:21:13,410
initialize my telemetry. So I add

332
00:21:13,480 --> 00:21:17,238
my tracer, my open telemetry tracer to the services

333
00:21:17,324 --> 00:21:21,254
itself. From there I'm having my

334
00:21:21,292 --> 00:21:24,994
instrumentations. So instrumentations is my wrappers.

335
00:21:25,042 --> 00:21:28,826
These are my automatic instrumentations. Automatically take

336
00:21:28,848 --> 00:21:32,380
that trace id, automatically take the

337
00:21:33,710 --> 00:21:36,970
durations on how long pieces took and

338
00:21:37,040 --> 00:21:38,860
less work for me.

339
00:21:40,110 --> 00:21:44,174
With that I then also want to add an exporter once

340
00:21:44,212 --> 00:21:48,042
again OTLP format, and I'm going to a specific endpoint.

341
00:21:48,106 --> 00:21:51,294
I remove this vendor specific code in here

342
00:21:51,332 --> 00:21:54,786
because you might have to add things like API keys and the

343
00:21:54,808 --> 00:21:58,386
vendor URL where you want to send the data, but you

344
00:21:58,408 --> 00:22:02,370
should be able to take this and apply it to different

345
00:22:02,440 --> 00:22:05,842
vendors, at least from a reference standpoint. And then

346
00:22:05,896 --> 00:22:09,078
of course finally we see that same issue.

347
00:22:09,164 --> 00:22:13,378
We need to make sure empty SSL if you are sending

348
00:22:13,394 --> 00:22:17,830
to a secure endpoint, and in this case it's GRPC secure endpoint.

349
00:22:19,050 --> 00:22:22,874
And I left the automatic for the net. I didn't add

350
00:22:22,912 --> 00:22:26,106
in the manual instrumentation yet. That is still on my to do

351
00:22:26,128 --> 00:22:29,980
list. So I decided to move downstream. Once again,

352
00:22:30,370 --> 00:22:33,886
all that's left is two Python services. I'm getting close to

353
00:22:33,908 --> 00:22:37,278
the end to be able to see this grand trace of

354
00:22:37,364 --> 00:22:40,960
my system, to see communication between services.

355
00:22:43,650 --> 00:22:47,922
So I have this email service in Python, and I

356
00:22:47,976 --> 00:22:51,762
personally have not used a lot of python in a production environment. I've used

357
00:22:51,816 --> 00:22:55,682
Python from scripting, but not really in terms of a web

358
00:22:55,736 --> 00:22:59,126
application. So I had to do a little bit more reading up

359
00:22:59,148 --> 00:23:02,870
and figuring out how a requirements in

360
00:23:02,940 --> 00:23:06,534
work. And so using that requirements in, I was able to

361
00:23:06,572 --> 00:23:10,694
once again remove the open census code and libraries

362
00:23:10,742 --> 00:23:14,106
and references and instead add the open telemetry stuff.

363
00:23:14,288 --> 00:23:18,460
The documentation was a little bit lacking on the Python side.

364
00:23:18,830 --> 00:23:22,206
I think it's just the nature of things are still growing and

365
00:23:22,228 --> 00:23:26,350
are still in flux for some of the languages, but it will get there eventually

366
00:23:28,610 --> 00:23:32,142
where we're following the same thing we did before. We have

367
00:23:32,196 --> 00:23:35,506
an exporter, and with our exporter we

368
00:23:35,528 --> 00:23:39,410
are doing OtLPF format to our endpoint like before with

369
00:23:39,560 --> 00:23:43,186
empty SSL credentials. Great. We have a

370
00:23:43,208 --> 00:23:46,306
trace provider, a tracer, whatever have you want to call it

371
00:23:46,328 --> 00:23:49,702
in the different languages. And in this case we give it our service name and

372
00:23:49,756 --> 00:23:53,702
we're adding our spam processor. We're just going to simply export to

373
00:23:53,756 --> 00:23:57,886
this location. And then I wanted to add some manual instrumentation

374
00:23:57,938 --> 00:24:01,414
as well. There is this server interceptor.

375
00:24:01,542 --> 00:24:04,902
This is a hotel

376
00:24:04,966 --> 00:24:08,374
specific wrapper for my GRPC server,

377
00:24:08,422 --> 00:24:12,274
and it allows it to get that trace id from the upstream

378
00:24:12,342 --> 00:24:15,550
calls and automatically add it to the python calls.

379
00:24:16,130 --> 00:24:19,662
And I like that automatic instrumenting. As I've mentioned

380
00:24:19,716 --> 00:24:22,866
before, I kind of want to get going quick and see what I get out

381
00:24:22,888 --> 00:24:25,380
of it and then add my manual instrumentation later.

382
00:24:27,430 --> 00:24:30,340
So we got that.

383
00:24:30,870 --> 00:24:33,780
What does it all look like? Did we actually do it?

384
00:24:34,870 --> 00:24:38,374
And the short answer is yes. The long answer

385
00:24:38,412 --> 00:24:41,526
is it took me a couple of tries. There was a

386
00:24:41,548 --> 00:24:45,682
lot of learnings in that where I didn't get tracing

387
00:24:45,746 --> 00:24:49,722
propagating, right. I had to add the, for example, in that go piece,

388
00:24:49,776 --> 00:24:53,702
I had to add that automatic GRPC

389
00:24:53,846 --> 00:24:57,142
instrumentation, because without it it wasn't propagating the trace ids.

390
00:24:57,206 --> 00:25:00,918
And that's really the problem and why I wanted to do this is

391
00:25:00,944 --> 00:25:04,862
there's all those good examples individually, but we really need

392
00:25:04,916 --> 00:25:08,282
more examples of a complex environment where microservices,

393
00:25:08,346 --> 00:25:11,502
architecture, talking to different types of code environments and tracing through

394
00:25:11,556 --> 00:25:15,194
it. And so here's the grand trace.

395
00:25:15,242 --> 00:25:19,170
This is in honeycomb because I work for honeycomb, but it might look similar

396
00:25:19,240 --> 00:25:22,594
in the tool that you choose. And we can see that we are

397
00:25:22,632 --> 00:25:26,562
tracing across services. So it's taking that trace id from my front end,

398
00:25:26,616 --> 00:25:30,390
sending it to my checkout back end. It's telling me how long

399
00:25:30,460 --> 00:25:33,874
I spent. That's great. This is the power of a trace and a span

400
00:25:33,922 --> 00:25:37,526
and a trace waterfall view is I can see where most of

401
00:25:37,548 --> 00:25:40,906
the time is being spent. I can follow through and

402
00:25:40,928 --> 00:25:44,922
I see from that java piece or

403
00:25:45,056 --> 00:25:48,902
the go pieces or whatever have you, they all have these ideas span events,

404
00:25:49,046 --> 00:25:52,730
and I can see those span events in this case as those dots,

405
00:25:52,810 --> 00:25:56,480
those are maybe those exceptions or log messages that are important

406
00:25:57,010 --> 00:26:00,410
and those span attributes.

407
00:26:00,570 --> 00:26:04,194
So now in my system I can ask questions. I can

408
00:26:04,232 --> 00:26:07,554
see someone@example.com what was

409
00:26:07,592 --> 00:26:11,534
their experience when they did a checkout? And that's

410
00:26:11,582 --> 00:26:15,154
ultimately the thing we want to solve for,

411
00:26:15,192 --> 00:26:19,206
right? We want to understand where the bottlenecks are,

412
00:26:19,228 --> 00:26:21,960
we want to get to root cause, because if your system is down,

413
00:26:23,530 --> 00:26:27,110
your users are not happy. And we want our users to be happy to continue

414
00:26:27,180 --> 00:26:28,380
using our products.

415
00:26:30,510 --> 00:26:32,330
A lot of lessons learned.

416
00:26:34,270 --> 00:26:37,994
Honestly, the biggest problem I had when going through all this

417
00:26:38,032 --> 00:26:41,110
is the documentation can be lacking for some of the languages.

418
00:26:41,190 --> 00:26:44,670
I did have to sift through the GitHub code itself. That is

419
00:26:44,740 --> 00:26:48,094
continually changing already since I did this a few months ago.

420
00:26:48,132 --> 00:26:51,774
There's better documentation. More of the languages are

421
00:26:51,812 --> 00:26:55,410
ga. Opentelemetry is moving very fast

422
00:26:55,480 --> 00:26:58,494
and it is becoming more and robust like daily.

423
00:26:58,622 --> 00:27:02,274
And this is why it's important to have this

424
00:27:02,312 --> 00:27:05,974
nice and open format is you have the mind share of everyone out

425
00:27:06,012 --> 00:27:09,800
there who is interested in it to be able to work on it. That's great.

426
00:27:10,970 --> 00:27:14,438
But with that we saw that some of

427
00:27:14,444 --> 00:27:18,438
the languages are prega. That is something,

428
00:27:18,524 --> 00:27:22,214
a risk you might have to take, but that is once again also continually changing.

429
00:27:22,262 --> 00:27:25,818
More and more languages are becoming ga, and I expect that

430
00:27:25,904 --> 00:27:29,546
at least for tracing, to really be pretty robust on

431
00:27:29,568 --> 00:27:32,122
all the different languages we've seen today to be ga.

432
00:27:32,186 --> 00:27:35,646
Right? Metrics and logs, those are in

433
00:27:35,668 --> 00:27:39,280
the pipeline for open telemetry, but eventually we'll get there too.

434
00:27:39,890 --> 00:27:43,386
There's a different nuances I saw. So I was having troubles

435
00:27:43,418 --> 00:27:47,394
with that SSL piece, and that is something I had

436
00:27:47,432 --> 00:27:50,450
to just dig into the code and figure out why I needed

437
00:27:50,520 --> 00:27:53,746
to do it for some of the languages, but not for

438
00:27:53,768 --> 00:27:57,566
Java. And I figured out that it's just one of the nuances.

439
00:27:57,678 --> 00:28:01,494
We definitely also need more examples. Like I

440
00:28:01,532 --> 00:28:04,774
kind of mentioned that the individual examples are good.

441
00:28:04,812 --> 00:28:08,530
You can go into the GitHub, they all have examples on how to use opentelemetry.

442
00:28:08,610 --> 00:28:12,314
Tons of vendors have examples on how to use opentelemetry for the

443
00:28:12,352 --> 00:28:15,514
individual languages. We need more

444
00:28:15,552 --> 00:28:19,638
examples on complex real environments because that's

445
00:28:19,734 --> 00:28:23,294
where you're going to run into the more nuances, the more

446
00:28:23,412 --> 00:28:26,638
edge cases on how to set up something, how to

447
00:28:26,644 --> 00:28:29,920
get tracing across the different languages, for example. Right.

448
00:28:30,530 --> 00:28:33,678
Hopefully now with this Google microservices demo,

449
00:28:33,764 --> 00:28:36,962
that's going to help some more people out there and I'm going to keep

450
00:28:37,016 --> 00:28:40,926
updating it. Auto instruments, your mileage

451
00:28:40,958 --> 00:28:45,294
may vary, so that is something always to keep in mind. Auto instrumentation

452
00:28:45,342 --> 00:28:49,206
is good, definitely to get up and going. It's not going to

453
00:28:49,228 --> 00:28:52,726
be the end, be all, it's not going to solve all your

454
00:28:52,748 --> 00:28:55,350
problems for you. I don't think it will.

455
00:28:55,420 --> 00:28:59,302
So be prepared to go in to do some manual

456
00:28:59,366 --> 00:29:03,226
instrumentation. And yeah, I need to add back

457
00:29:03,248 --> 00:29:07,434
in some of the health checks. I had to remove them because for

458
00:29:07,472 --> 00:29:10,902
some reason when I added my open telemetry, the Kubernetes

459
00:29:10,966 --> 00:29:14,606
pods would crash because they weren't starting fast enough. But when I

460
00:29:14,628 --> 00:29:18,414
removed that health check to see if the pod was ready, it started

461
00:29:18,452 --> 00:29:22,538
up fine. That's just something I need to do to get this demo back to

462
00:29:22,564 --> 00:29:26,174
a good standing on how the original open census

463
00:29:26,222 --> 00:29:29,134
stuff was. So my next steps,

464
00:29:29,262 --> 00:29:32,974
add more information. Just recently

465
00:29:33,022 --> 00:29:36,450
I wanted to figure out how to use baggage, and so I was

466
00:29:36,520 --> 00:29:40,246
able to dig through the docs, dig through code, figure out

467
00:29:40,268 --> 00:29:44,082
how do I add baggage, and I got baggage working. So baggage

468
00:29:44,146 --> 00:29:47,542
is taking something like that session id you saw

469
00:29:47,596 --> 00:29:51,226
earlier and how can I propagate that as well to all

470
00:29:51,248 --> 00:29:54,534
the downstream calls, not just a trace

471
00:29:54,582 --> 00:29:57,866
id, so that I can set something like that session id on every

472
00:29:57,888 --> 00:30:01,194
single one of my spans. And I was able to add that into the code.

473
00:30:01,232 --> 00:30:05,006
You'll see that at least for the front end and a couple of pieces it

474
00:30:05,028 --> 00:30:09,038
touches. I definitely need to add more manual instrumentation. That's another piece

475
00:30:09,124 --> 00:30:12,830
that might be lacking in some of the documentation is how to get specific

476
00:30:12,980 --> 00:30:16,900
situations set up. So I want to make sure I have all those situations for

477
00:30:17,270 --> 00:30:21,170
any of my customers and anyone out there who is interested in setting up

478
00:30:21,320 --> 00:30:24,850
specific attributes and such for the different coding languages.

479
00:30:25,350 --> 00:30:28,702
Eventually we also want to use this as a demo environment,

480
00:30:28,766 --> 00:30:32,070
and with that we want to be able to add some arbitrary slowness.

481
00:30:32,650 --> 00:30:36,118
Your tracing tool should be able to identify bottlenecks and we want to

482
00:30:36,124 --> 00:30:40,194
be able to showcase that even in a complicated environment we can add slowness

483
00:30:40,242 --> 00:30:43,594
and quickly identify it. And you should make sure your tool that you're using can

484
00:30:43,632 --> 00:30:46,986
do that. As well. Obviously I just mentioned health checks need to go back

485
00:30:47,008 --> 00:30:50,282
in and then finally I need to update to the latest versions.

486
00:30:50,346 --> 00:30:54,240
Feel free to make some prs to the code,

487
00:30:55,650 --> 00:30:58,798
it's fast. The open telemetry stuff just a

488
00:30:58,804 --> 00:31:01,998
few months has just updated multiple versions already as everyone

489
00:31:02,084 --> 00:31:04,910
is working towards that GA for all the different languages.

490
00:31:05,250 --> 00:31:08,578
So eventually they're using to get all of them will get

491
00:31:08,584 --> 00:31:11,618
to stable and it'll be perfect and great. Until then just going to have to

492
00:31:11,624 --> 00:31:14,450
keep monitoring and get it to update.

493
00:31:16,070 --> 00:31:19,334
Thank you. I really appreciate you taking

494
00:31:19,372 --> 00:31:22,994
the time to watch my presentation. Here's some of the resources.

495
00:31:23,042 --> 00:31:26,806
At the bottom there you can see the microservices fork that I

496
00:31:26,828 --> 00:31:31,042
created on our GitHub repository

497
00:31:31,106 --> 00:31:34,390
page. Also you can look at the

498
00:31:34,460 --> 00:31:38,022
Opentelemetry docs and GitHub. That's where you're going to find

499
00:31:38,156 --> 00:31:42,126
a lot of your information to really understand how

500
00:31:42,148 --> 00:31:45,802
to uses it. And then there is also a Slack channel, the CNCF

501
00:31:45,866 --> 00:31:50,240
Slack does have open telemetry channels for you to ask questions there as well.

502
00:31:51,410 --> 00:31:51,900
Thank you.

