1
00:00:39,090 --> 00:00:43,042
Hello everyone and welcome to my talk about Kubernetes gateway API.

2
00:00:43,186 --> 00:00:46,434
And I will be happy to show you the differences

3
00:00:46,482 --> 00:00:50,222
between this new API and the ingress API that

4
00:00:50,396 --> 00:00:53,200
we use it to use until now.

5
00:00:53,570 --> 00:00:57,002
Okay, let's get to some presentations.

6
00:00:57,146 --> 00:01:00,702
And I am Gregorio Palama. I work as

7
00:01:00,756 --> 00:01:04,306
DevOps and cloud engineer at Pinwave and I

8
00:01:04,328 --> 00:01:08,286
am a community manager at the local chapter of GDGs

9
00:01:08,318 --> 00:01:11,758
in Pescara. You can find me on social networks,

10
00:01:11,854 --> 00:01:14,770
especially on X and on LinkedIn.

11
00:01:15,210 --> 00:01:18,598
Okay, let's start with saying what

12
00:01:18,684 --> 00:01:22,262
are we talking about? We are talking about exposing our

13
00:01:22,316 --> 00:01:26,038
services outside the cluster. Well,

14
00:01:26,204 --> 00:01:31,450
note that in this slide and in

15
00:01:31,520 --> 00:01:35,914
all the other slides we are referring to services such

16
00:01:35,952 --> 00:01:40,210
as the service resource in Kubernetes.

17
00:01:40,310 --> 00:01:43,630
And it's done because of simplicity.

18
00:01:44,130 --> 00:01:47,486
We can say that until now we

19
00:01:47,508 --> 00:01:51,614
use ingresses API to expose our services

20
00:01:51,732 --> 00:01:54,978
outside the cluster. And that's an API that is

21
00:01:55,064 --> 00:01:58,914
globally available since Kubernetes one nine

22
00:01:59,032 --> 00:02:02,962
and is widely used. Let's see how

23
00:02:03,016 --> 00:02:06,514
it works using a way that is known

24
00:02:06,562 --> 00:02:10,662
as north south that depicts the way

25
00:02:10,716 --> 00:02:14,518
that traffic goes from our client, the top

26
00:02:14,604 --> 00:02:17,480
the north, to our service.

27
00:02:18,170 --> 00:02:21,278
We will see it on the bottom, the south.

28
00:02:21,474 --> 00:02:24,954
So let's say for example that our

29
00:02:24,992 --> 00:02:28,186
client performs request to a

30
00:02:28,208 --> 00:02:32,378
DNS myapplication.com. And on that DNS

31
00:02:32,474 --> 00:02:37,070
there is attached an ingress called my ingress and

32
00:02:37,140 --> 00:02:41,162
that ingress will route the request

33
00:02:41,226 --> 00:02:44,722
to our service. Let's say it is called

34
00:02:44,856 --> 00:02:48,450
my service. Well, what happens from now on

35
00:02:48,520 --> 00:02:52,878
is, for example, my service is backed

36
00:02:53,054 --> 00:02:57,314
by an endpoint that

37
00:02:57,432 --> 00:03:02,182
collects eps and posts for our

38
00:03:02,236 --> 00:03:06,294
pods that will receive the request and

39
00:03:06,492 --> 00:03:10,634
answer with a response that will be handled back to

40
00:03:10,672 --> 00:03:14,186
the client. The important

41
00:03:14,288 --> 00:03:19,130
thing is the way that the requests is routed.

42
00:03:19,710 --> 00:03:22,974
Okay, we can see the yaml that

43
00:03:23,012 --> 00:03:26,640
is representing the example that we've seen

44
00:03:27,570 --> 00:03:31,294
right now. And I added for

45
00:03:31,332 --> 00:03:35,010
example, a way to define a particular path

46
00:03:35,350 --> 00:03:38,914
that the ingress can

47
00:03:38,952 --> 00:03:42,100
handle for us. Okay,

48
00:03:43,270 --> 00:03:47,906
before we go to see the limitation

49
00:03:48,098 --> 00:03:51,560
of the ingresses API, let's start by

50
00:03:52,010 --> 00:03:55,334
reading small part of the

51
00:03:55,372 --> 00:03:59,530
documentation, the official documentation about the ingresses.

52
00:04:00,030 --> 00:04:03,782
Well, the official documentation says that Ingress

53
00:04:03,926 --> 00:04:08,486
exposes HTTP and HTTPs routes

54
00:04:08,678 --> 00:04:12,070
from outside the cluster to services within the cluster.

55
00:04:12,150 --> 00:04:15,786
In traffic routing is controlled by rules defined

56
00:04:15,818 --> 00:04:18,894
on the ingress results. Well,

57
00:04:19,012 --> 00:04:23,310
first of all, HTTP and HTTPs,

58
00:04:23,750 --> 00:04:27,618
the Ingress API API was

59
00:04:27,704 --> 00:04:31,458
designed with these two protocols in mind,

60
00:04:31,624 --> 00:04:33,490
no other protocols.

61
00:04:34,470 --> 00:04:38,018
Also, everything is defined in the same resource

62
00:04:38,114 --> 00:04:41,158
and that's a limitation that, well,

63
00:04:41,244 --> 00:04:46,742
we can see the implication going

64
00:04:46,796 --> 00:04:50,380
forward in our presentation because

65
00:04:51,630 --> 00:04:55,722
let's see the personas that were in mind when

66
00:04:55,856 --> 00:05:00,342
the Ingress API was designed. Well, the only personas

67
00:05:00,486 --> 00:05:04,378
was the user, the ingress owner. And that's a

68
00:05:04,384 --> 00:05:09,582
big limitation because the user had

69
00:05:09,636 --> 00:05:13,742
the responsibility to manage the infrastructure

70
00:05:13,806 --> 00:05:17,182
configuration or for example TLS

71
00:05:17,246 --> 00:05:20,750
configuration and the routing configuration

72
00:05:20,830 --> 00:05:24,866
too. Going through

73
00:05:24,888 --> 00:05:28,550
the years, a Persona was added

74
00:05:29,050 --> 00:05:32,614
and the Persona was added when the

75
00:05:32,652 --> 00:05:35,586
Ingress class resources was added.

76
00:05:35,778 --> 00:05:39,670
Ingress class are resources that contain additional

77
00:05:39,750 --> 00:05:43,082
configuration, including the name of the controller that should

78
00:05:43,136 --> 00:05:46,860
implement a class. That's what the documentation says.

79
00:05:47,550 --> 00:05:50,814
Okay, what does it mean? First of

80
00:05:50,852 --> 00:05:54,110
all, we have, as I said, another personas.

81
00:05:55,170 --> 00:05:58,314
The user that was the original

82
00:05:58,362 --> 00:06:01,866
owner of the ingress resource

83
00:06:02,058 --> 00:06:05,746
still has the responsibility of

84
00:06:05,928 --> 00:06:09,634
working on the routing configuration. The new

85
00:06:09,672 --> 00:06:14,050
Personas infrastructure provider and cluster operator

86
00:06:14,550 --> 00:06:18,486
has the responsibility of

87
00:06:18,588 --> 00:06:22,278
working on the infrastructure configuration and on

88
00:06:22,364 --> 00:06:24,310
the TLS configuration.

89
00:06:25,530 --> 00:06:28,886
Well, this was a nice addition,

90
00:06:28,998 --> 00:06:32,842
but still the first design was with just

91
00:06:32,896 --> 00:06:36,490
one personas in mind. So this is an addition,

92
00:06:36,830 --> 00:06:40,250
it's not been redesigned,

93
00:06:41,490 --> 00:06:45,326
no process of redesign was done on the

94
00:06:45,508 --> 00:06:49,342
whole API. So we still have

95
00:06:49,476 --> 00:06:54,138
other limitations, for example extensibility.

96
00:06:54,314 --> 00:06:56,830
It relies on annotations.

97
00:06:57,570 --> 00:07:01,118
We have different implementation of the Ingress API,

98
00:07:01,294 --> 00:07:05,082
and every different implementation

99
00:07:05,166 --> 00:07:09,174
has to rely on the annotation if it

100
00:07:09,212 --> 00:07:14,226
wants to add something that is not provided

101
00:07:14,338 --> 00:07:16,440
by the API itself.

102
00:07:17,290 --> 00:07:21,510
So you have a situation where some implementation

103
00:07:21,590 --> 00:07:23,530
created custom extensions.

104
00:07:27,710 --> 00:07:31,262
The easier way is to rely on

105
00:07:31,316 --> 00:07:34,894
annotation. So we have different kind of

106
00:07:34,932 --> 00:07:38,218
annotation, different ways to annotate

107
00:07:38,314 --> 00:07:41,550
these technologies from implementation to implementation.

108
00:07:42,390 --> 00:07:46,302
And these custom extensions are valid

109
00:07:46,366 --> 00:07:50,034
for this single implementation only. And that's a

110
00:07:50,072 --> 00:07:53,922
strong limitation. Well, let's get to

111
00:07:53,976 --> 00:07:57,190
the Gateway API. The Gateway API

112
00:07:57,690 --> 00:08:02,918
is a global available since Kubernetes 125

113
00:08:03,084 --> 00:08:07,946
that has been released in October, the 31

114
00:08:08,048 --> 00:08:11,958
in 2023. So it's

115
00:08:12,134 --> 00:08:15,642
kind of new if we want

116
00:08:15,696 --> 00:08:19,610
to call it new, but it's new

117
00:08:19,680 --> 00:08:23,120
if we refer to the global availability of it.

118
00:08:23,970 --> 00:08:28,318
The API is available,

119
00:08:28,484 --> 00:08:32,618
not in global available since

120
00:08:32,724 --> 00:08:36,420
like two or three years. Well,

121
00:08:36,950 --> 00:08:41,540
let's get to the details. API Gateway describes anything

122
00:08:42,310 --> 00:08:46,054
that exposes capabilities of a backend service,

123
00:08:46,172 --> 00:08:50,274
while providing extra capabilities for traffic routing

124
00:08:50,402 --> 00:08:55,190
and manipulation and sometimes more advanced features.

125
00:08:56,010 --> 00:09:00,380
What does it mean? Let's start by

126
00:09:02,030 --> 00:09:05,930
saying that the first thing

127
00:09:06,000 --> 00:09:09,942
that was in the mind of who designed this

128
00:09:10,016 --> 00:09:14,174
API was the personas. Why is that?

129
00:09:14,292 --> 00:09:17,566
Well, we will see it shortly. Let's get to

130
00:09:17,588 --> 00:09:20,814
the personas and we can see that the

131
00:09:20,852 --> 00:09:23,780
first personas have even a name,

132
00:09:24,790 --> 00:09:28,782
any personas of the Gateway API

133
00:09:28,846 --> 00:09:32,642
as a name, because who design wants to

134
00:09:32,696 --> 00:09:35,966
give a strong meaning to the personas.

135
00:09:36,158 --> 00:09:40,366
The first personas is called Yan. It is

136
00:09:40,488 --> 00:09:44,070
an infrastructure provider.

137
00:09:44,650 --> 00:09:48,186
The second one is Chihiro and he is

138
00:09:48,208 --> 00:09:51,498
a cluster operator. And the third one

139
00:09:51,584 --> 00:09:54,650
is Anna, an application developer.

140
00:09:54,990 --> 00:09:58,682
Well, the first implication of these is that

141
00:09:58,816 --> 00:10:02,814
we can refer to these personas and think

142
00:10:02,852 --> 00:10:07,040
about them like a single

143
00:10:09,010 --> 00:10:13,442
Persona, but we can think about them like

144
00:10:13,576 --> 00:10:17,582
teams. Also, for examples, we can have Anna

145
00:10:17,726 --> 00:10:21,874
that works with her team as

146
00:10:21,912 --> 00:10:25,278
an application developer, but we can have another team.

147
00:10:25,464 --> 00:10:28,662
We will use the same personas, but we can

148
00:10:28,716 --> 00:10:32,770
think about two teams working on the routing

149
00:10:32,850 --> 00:10:36,882
that our traffic management

150
00:10:36,946 --> 00:10:39,898
system needs to implement. Okay,

151
00:10:39,984 --> 00:10:43,258
what are their responsibilities? First of

152
00:10:43,264 --> 00:10:47,430
all, Jan, the infrastructure provider, he has the responsibility

153
00:10:47,510 --> 00:10:50,974
of configurate the infrastructure and can

154
00:10:51,012 --> 00:10:54,574
work on multiple clusters. So we

155
00:10:54,612 --> 00:10:58,474
see that here the design is totally

156
00:10:58,522 --> 00:11:01,646
different because for the first time we are thinking

157
00:11:01,748 --> 00:11:06,626
about working on the configuration on

158
00:11:06,728 --> 00:11:10,274
different multiple clusters, and the

159
00:11:10,312 --> 00:11:13,522
whole API is designed around this kind

160
00:11:13,576 --> 00:11:16,450
of possibility.

161
00:11:17,270 --> 00:11:20,226
Let's get to here. The cluster operator,

162
00:11:20,418 --> 00:11:23,730
he has the responsibility of configuration

163
00:11:23,810 --> 00:11:26,200
and configurate the entry points,

164
00:11:28,990 --> 00:11:32,502
not only the endpoints, he can only configure

165
00:11:32,566 --> 00:11:36,394
Tls and so on. And finally,

166
00:11:36,512 --> 00:11:39,466
the application developer, Anna, well,

167
00:11:39,648 --> 00:11:43,114
she has the responsibility of configurating

168
00:11:43,242 --> 00:11:46,942
the routing rules. And that's something that

169
00:11:46,996 --> 00:11:50,138
is application related,

170
00:11:50,314 --> 00:11:57,074
because the application needs to perform

171
00:11:57,192 --> 00:12:01,970
the routing rules and the application guides

172
00:12:02,390 --> 00:12:05,620
the developer well,

173
00:12:06,550 --> 00:12:10,486
its intrinsic needs. So the

174
00:12:10,508 --> 00:12:14,470
application developer is the only one that really knows

175
00:12:14,890 --> 00:12:18,426
how the routing configurations should be done.

176
00:12:18,608 --> 00:12:22,122
So we can see a separation of concerns that

177
00:12:22,256 --> 00:12:25,958
the ingress API doesn't provide. But the Gateway

178
00:12:26,054 --> 00:12:29,322
API provides. And that's a great thing

179
00:12:29,456 --> 00:12:33,262
because every team, every personas can

180
00:12:33,316 --> 00:12:37,162
think on its own responsibility

181
00:12:37,306 --> 00:12:40,590
and its own concern

182
00:12:41,410 --> 00:12:45,378
while he or she works

183
00:12:45,464 --> 00:12:48,180
on their works.

184
00:12:48,710 --> 00:12:51,650
Okay, let's get to the resources.

185
00:12:52,390 --> 00:12:56,280
The first resource of the Gateway API is a gateway class.

186
00:12:56,970 --> 00:13:00,966
It defines a set of gateways that share a

187
00:13:00,988 --> 00:13:04,742
common configuration and behavior, and each

188
00:13:04,796 --> 00:13:08,890
gateway class will be handled by a single controller.

189
00:13:10,110 --> 00:13:13,802
The gateway class is resources that

190
00:13:13,856 --> 00:13:17,660
is a cluster scoped, and it is

191
00:13:18,110 --> 00:13:21,470
somehow similar to the ingress class for ingresses.

192
00:13:22,050 --> 00:13:25,200
The second resource is the gateway itself.

193
00:13:25,890 --> 00:13:29,854
It describes how traffic can be translated to

194
00:13:29,892 --> 00:13:33,902
services within the cluster and defines a request

195
00:13:33,966 --> 00:13:37,214
for a specific load balancer config

196
00:13:37,262 --> 00:13:40,974
that implements the gateway class configuration and behavior

197
00:13:41,102 --> 00:13:44,850
contract. So the gateway class configuration

198
00:13:47,770 --> 00:13:49,510
will configurate,

199
00:13:50,890 --> 00:13:54,258
will configure behavior,

200
00:13:54,354 --> 00:13:58,154
and the gateway defines a

201
00:13:58,192 --> 00:14:00,650
request for that specific behavior.

202
00:14:01,550 --> 00:14:05,830
It may be attached to one or more route references.

203
00:14:05,990 --> 00:14:11,594
So we can have a way to define

204
00:14:11,722 --> 00:14:15,642
security boundaries that the ingresses API

205
00:14:15,706 --> 00:14:19,114
didn't provide. And it is possible to limit

206
00:14:19,162 --> 00:14:22,110
the routes that can attach to a gateway.

207
00:14:22,630 --> 00:14:26,370
The third resource is routes.

208
00:14:27,030 --> 00:14:31,150
Routes define protocol specific rules for mapping requests

209
00:14:31,230 --> 00:14:34,180
from a gateway to a Kubernetes services.

210
00:14:35,130 --> 00:14:37,990
In version one alpha two,

211
00:14:38,140 --> 00:14:41,970
there are four route resource

212
00:14:42,050 --> 00:14:44,786
types that are included,

213
00:14:44,978 --> 00:14:48,810
and our route can attach to one or more gateways.

214
00:14:49,550 --> 00:14:52,726
As I said, the possibility

215
00:14:52,838 --> 00:14:56,058
to be attached can be limited and

216
00:14:56,144 --> 00:15:00,086
filters and advanced rules can be applied on

217
00:15:00,128 --> 00:15:03,742
the route. Well, I said that there are four

218
00:15:03,796 --> 00:15:07,130
routes in the actual version.

219
00:15:07,290 --> 00:15:11,098
The four out are these ones, HTTP route,

220
00:15:11,274 --> 00:15:15,134
TLS route, TCP and UDP

221
00:15:15,182 --> 00:15:19,010
route, and GRRPC route.

222
00:15:19,430 --> 00:15:24,526
As we can see, we have HTTP

223
00:15:24,558 --> 00:15:28,054
route and tls route that maps the HTTP and

224
00:15:28,092 --> 00:15:31,894
HTTPs capability of the

225
00:15:31,932 --> 00:15:35,442
Ingress API. But we also have TCP

226
00:15:35,506 --> 00:15:39,306
and UDP route. Those are two protocols that

227
00:15:39,328 --> 00:15:42,842
are not available in the Ingress API. And we

228
00:15:42,896 --> 00:15:46,742
also have GRRPC route.

229
00:15:46,806 --> 00:15:50,686
That is another protocol that was not available

230
00:15:50,788 --> 00:15:55,086
in the Ingress API. And we have a bunch of new

231
00:15:55,188 --> 00:15:59,242
functionalities with gateway API that we didn't

232
00:15:59,306 --> 00:16:01,950
have with the Ingress API.

233
00:16:02,950 --> 00:16:06,610
Okay, as we seen

234
00:16:06,760 --> 00:16:10,354
in the Ingress API, let's get to the

235
00:16:10,392 --> 00:16:14,046
north south, the peak

236
00:16:14,078 --> 00:16:17,254
thing, so we can understand how it

237
00:16:17,292 --> 00:16:22,194
works. Let's start from our client that sends

238
00:16:22,322 --> 00:16:26,440
a request to myapplication.com. In this

239
00:16:26,810 --> 00:16:30,394
situation, we will have a gateway called,

240
00:16:30,512 --> 00:16:34,666
for example, my gateway. With the Ingress API, we add

241
00:16:34,768 --> 00:16:35,930
my ingress.

242
00:16:38,430 --> 00:16:42,314
Well, the gateway implements gateway

243
00:16:42,362 --> 00:16:46,250
class that defines all the rules

244
00:16:46,410 --> 00:16:50,510
and all the behaviors and the controller, for example,

245
00:16:50,580 --> 00:16:54,290
that will be used to implement that gateway.

246
00:16:55,670 --> 00:16:59,460
And the gateway itself

247
00:17:04,890 --> 00:17:08,070
sends the requests to the route.

248
00:17:08,410 --> 00:17:12,166
In this case, I call the example

249
00:17:12,268 --> 00:17:15,720
route my route. It will have

250
00:17:16,570 --> 00:17:20,774
his particular rules defined,

251
00:17:20,902 --> 00:17:24,730
for example, from one or two or more teams.

252
00:17:25,230 --> 00:17:28,922
And these rules will help

253
00:17:29,056 --> 00:17:32,750
will define how the

254
00:17:32,900 --> 00:17:36,318
route will route the

255
00:17:36,404 --> 00:17:40,750
request to the service or the services inside my cluster.

256
00:17:41,650 --> 00:17:45,026
Well, from now on it will be

257
00:17:45,208 --> 00:17:49,678
handled the same way we've

258
00:17:49,694 --> 00:17:53,234
seen with the ingress API. What's different

259
00:17:53,352 --> 00:17:56,678
here is everything that comes before

260
00:17:56,764 --> 00:18:01,234
the service resource. Okay, let's get to the examples.

261
00:18:01,362 --> 00:18:05,640
First of all, in the gateway example

262
00:18:06,090 --> 00:18:09,958
we can see here gateway called my gateway.

263
00:18:10,054 --> 00:18:13,260
In the namespace Gateway API ns one,

264
00:18:13,790 --> 00:18:18,060
it implements a class that is called my gateway class.

265
00:18:18,670 --> 00:18:22,254
And for example, we have a

266
00:18:22,292 --> 00:18:27,614
listener that is called my application. And we

267
00:18:27,652 --> 00:18:31,146
can see here that we are limiting

268
00:18:31,338 --> 00:18:34,926
the route that can attach this gateway.

269
00:18:35,038 --> 00:18:38,866
In this case, we said that on this

270
00:18:38,888 --> 00:18:42,318
gateway can attach only an HTTP route.

271
00:18:42,494 --> 00:18:46,262
Not only, we also said that to this

272
00:18:46,316 --> 00:18:50,438
gateway can attach a route that

273
00:18:50,604 --> 00:18:54,530
is in the Gateway

274
00:18:54,610 --> 00:18:57,560
API and namespace. Two,

275
00:18:57,950 --> 00:19:01,050
let's get to the route.

276
00:19:01,470 --> 00:19:04,950
This is an HTTP route, so it can attach

277
00:19:05,030 --> 00:19:08,682
to the my gateway gateway and it is

278
00:19:08,736 --> 00:19:11,994
in the namespace Gateway API NS

279
00:19:12,042 --> 00:19:15,918
two. So it is everything

280
00:19:16,004 --> 00:19:20,778
that is defined as a loaded route. So it requests

281
00:19:20,874 --> 00:19:24,654
these limitations. It is

282
00:19:24,692 --> 00:19:28,506
an HTTP route, it is in the right. Net base

283
00:19:28,628 --> 00:19:31,682
so it can attach to that gateway and

284
00:19:31,736 --> 00:19:36,370
it has some specifications, the parent refresh.

285
00:19:37,450 --> 00:19:40,786
It is defined as a kind namespace

286
00:19:40,818 --> 00:19:47,426
and name kind gateway. So we are defining

287
00:19:47,618 --> 00:19:50,826
on which gateway it is going to attach and

288
00:19:50,848 --> 00:19:54,854
it is going to attach to the gateway called my gateway. In the namespace

289
00:19:54,902 --> 00:19:58,662
Gateway API Ns one, we also define

290
00:19:58,726 --> 00:20:02,540
some rules and in this case

291
00:20:02,910 --> 00:20:06,400
we also define the service that

292
00:20:08,770 --> 00:20:12,042
it is the back end for this route.

293
00:20:12,186 --> 00:20:14,846
My service on port 80.

294
00:20:15,038 --> 00:20:18,674
Well, it's a very simple,

295
00:20:18,792 --> 00:20:22,340
easy example. Let's get to some,

296
00:20:23,510 --> 00:20:27,478
maybe more complex, even if

297
00:20:27,564 --> 00:20:31,462
we are still in a simple

298
00:20:31,516 --> 00:20:35,046
example the same route but

299
00:20:35,148 --> 00:20:38,954
with different rules. In this case we

300
00:20:38,992 --> 00:20:43,514
have for example two service, my service and my second service.

301
00:20:43,712 --> 00:20:48,234
But here we are giving particular

302
00:20:48,352 --> 00:20:51,920
rules that define the weight. In this case,

303
00:20:54,530 --> 00:20:57,760
one time out of ten,

304
00:20:58,930 --> 00:21:02,302
the route will route the request to

305
00:21:02,356 --> 00:21:06,098
my second service. So we have a 10%

306
00:21:06,184 --> 00:21:09,570
of the traffic that will be served by my second

307
00:21:09,640 --> 00:21:12,866
service and all the other traffic will

308
00:21:12,888 --> 00:21:16,646
be served by my service. That's easy.

309
00:21:16,828 --> 00:21:20,658
We have a load balancing strategy directly

310
00:21:20,834 --> 00:21:25,158
on the route and

311
00:21:25,244 --> 00:21:29,610
it can be done directly from the application developers.

312
00:21:30,110 --> 00:21:33,686
Let's get to more complex rules.

313
00:21:33,798 --> 00:21:37,260
In this case we have only

314
00:21:37,710 --> 00:21:41,454
service that runs as the back

315
00:21:41,492 --> 00:21:45,562
end of this route, but we have different matching

316
00:21:45,626 --> 00:21:49,646
rules. In these cases we have a neither that

317
00:21:49,748 --> 00:21:52,994
should match and the match should

318
00:21:53,032 --> 00:21:56,958
be exact. So we need a neither

319
00:21:57,134 --> 00:22:01,010
that is called conference and with a value of

320
00:22:01,080 --> 00:22:04,750
conf 42 and also everything

321
00:22:04,920 --> 00:22:08,694
that is requested on

322
00:22:08,732 --> 00:22:12,246
the path sum thing

323
00:22:12,428 --> 00:22:16,040
will be routed to my service service.

324
00:22:16,810 --> 00:22:20,570
Still another example, in this case we also have

325
00:22:20,640 --> 00:22:24,380
filters. Filters allows us to

326
00:22:25,630 --> 00:22:30,814
modify for example our

327
00:22:31,012 --> 00:22:34,590
request some fields on the request.

328
00:22:35,010 --> 00:22:39,454
In this case we are modifying the

329
00:22:39,652 --> 00:22:43,454
request, adding an eater and

330
00:22:43,492 --> 00:22:47,090
the header that we will be adding is

331
00:22:47,160 --> 00:22:51,122
the my heater and it

332
00:22:51,176 --> 00:22:54,690
will have a value of conf

333
00:22:54,760 --> 00:22:55,700
fourty two.

334
00:22:57,350 --> 00:23:00,440
Okay, let's get to demo.

335
00:23:01,050 --> 00:23:05,366
And for the demo I will

336
00:23:05,468 --> 00:23:09,498
use a cluster that is served by

337
00:23:09,664 --> 00:23:13,338
Google cloud platform. So I will

338
00:23:13,424 --> 00:23:17,194
use Google Kubernetes engine. And as we can

339
00:23:17,232 --> 00:23:20,878
see from the documentation, we have

340
00:23:21,044 --> 00:23:24,446
different gateway class

341
00:23:24,548 --> 00:23:27,920
that are served by the

342
00:23:28,370 --> 00:23:32,720
platform itself. And we can choose one of these

343
00:23:33,510 --> 00:23:37,038
if we want to create a gateway

344
00:23:37,134 --> 00:23:42,606
and we can use one wit to implement

345
00:23:42,798 --> 00:23:46,422
a gateway, I will use this

346
00:23:46,476 --> 00:23:50,518
one global external managed because it

347
00:23:50,684 --> 00:23:54,854
gives me an external ip and it gives

348
00:23:54,972 --> 00:23:58,810
me a load balancer that will balance

349
00:23:59,310 --> 00:24:02,380
every request. Okay,

350
00:24:02,990 --> 00:24:05,580
let's get to our example.

351
00:24:06,910 --> 00:24:10,540
And first of all, let's create

352
00:24:11,710 --> 00:24:15,726
everything that we

353
00:24:15,748 --> 00:24:20,622
are going to create everything that we will need to see

354
00:24:20,756 --> 00:24:24,546
how these demo works. And for

355
00:24:24,568 --> 00:24:28,962
example, I will create two

356
00:24:29,016 --> 00:24:32,434
pods, pod one and my pod one and

357
00:24:32,472 --> 00:24:36,054
my pod two. Two services my service one and my

358
00:24:36,092 --> 00:24:39,800
service two. A gateway called my gateway and

359
00:24:40,410 --> 00:24:43,830
route called my route. Okay,

360
00:24:43,980 --> 00:24:48,140
let's get to see what's inside

361
00:24:49,070 --> 00:24:53,210
the definition of my gateway. We are using the

362
00:24:53,360 --> 00:24:57,606
GTL seven global external manager,

363
00:24:57,798 --> 00:25:01,166
and it's just gateway with a

364
00:25:01,188 --> 00:25:04,794
listener on port 80 and protocol

365
00:25:04,842 --> 00:25:08,526
HTTP. Okay, let's get to

366
00:25:08,548 --> 00:25:12,240
the route. And we can see here that

367
00:25:12,550 --> 00:25:16,146
the route is reached to the gateway called my

368
00:25:16,168 --> 00:25:20,702
gateway. And we have some matching

369
00:25:20,766 --> 00:25:24,546
rules. And we have configured two

370
00:25:24,648 --> 00:25:28,806
path one that will

371
00:25:28,988 --> 00:25:32,870
route the request to my service one,

372
00:25:33,020 --> 00:25:36,502
and a slash two that will route the

373
00:25:36,556 --> 00:25:39,910
request to the service, my service

374
00:25:39,980 --> 00:25:43,866
two. Okay, what we

375
00:25:43,888 --> 00:25:46,778
can do here is, first thing,

376
00:25:46,944 --> 00:25:50,846
let's get the address, and, okay, we have

377
00:25:51,028 --> 00:25:54,990
that address that it is the public ip

378
00:25:56,130 --> 00:26:00,686
of our gateway. It is given

379
00:26:00,788 --> 00:26:04,978
by the platform, and we can use it to perform

380
00:26:05,144 --> 00:26:08,894
a request. We configured two routes,

381
00:26:09,022 --> 00:26:12,642
so, for example, we can see something

382
00:26:12,776 --> 00:26:14,260
like this,

383
00:26:15,130 --> 00:26:18,920
and one, let's get.

384
00:26:20,170 --> 00:26:23,080
Okay, we can see my pod one.

385
00:26:23,530 --> 00:26:27,590
The two pods are the same container,

386
00:26:27,950 --> 00:26:31,862
and the container is a simple one that I created

387
00:26:32,006 --> 00:26:35,770
that just prints out the australian.

388
00:26:36,190 --> 00:26:39,820
So in this case, we have my pod one.

389
00:26:40,290 --> 00:26:44,270
Let's try the other route two.

390
00:26:44,420 --> 00:26:48,238
Okay, we have my pod two. That's because I use

391
00:26:48,324 --> 00:26:52,350
the same container but for two different pods.

392
00:26:52,790 --> 00:26:55,700
Call it my pod one and my pod two.

393
00:26:56,230 --> 00:27:00,434
But what happens if I perform a

394
00:27:00,472 --> 00:27:05,140
request to the root address?

395
00:27:05,610 --> 00:27:09,490
Well, I didn't configure any route

396
00:27:09,570 --> 00:27:13,602
for that path, so a fault filter abort

397
00:27:13,746 --> 00:27:17,990
will be received as a response.

398
00:27:18,590 --> 00:27:22,182
That's perfectly normal, because I didn't

399
00:27:22,246 --> 00:27:26,090
configure anything for that route.

400
00:27:26,510 --> 00:27:29,980
Okay, what we can do here is, for example,

401
00:27:30,930 --> 00:27:34,494
adding, let's see what's inside

402
00:27:34,612 --> 00:27:38,154
of it. Okay, I created some tests,

403
00:27:38,202 --> 00:27:41,978
and this is the fourth test that I created,

404
00:27:42,074 --> 00:27:45,106
but it is the most interesting one.

405
00:27:45,288 --> 00:27:49,220
For example, I configured this

406
00:27:50,870 --> 00:27:53,634
path three. Oh,

407
00:27:53,752 --> 00:27:57,250
I forgot to mention this filter.

408
00:27:57,330 --> 00:28:00,760
It is valid for the other path, too.

409
00:28:01,370 --> 00:28:04,982
It just says that everything that is

410
00:28:05,036 --> 00:28:10,220
in the path will be replaced because the

411
00:28:10,670 --> 00:28:14,026
application inside of the pod answers on

412
00:28:14,048 --> 00:28:17,740
the root path. So if we

413
00:28:18,110 --> 00:28:21,162
have, for example, one,

414
00:28:21,296 --> 00:28:25,614
it will be translated to the lash before

415
00:28:25,732 --> 00:28:29,278
it will be routed to the service

416
00:28:29,364 --> 00:28:32,754
and then to the pod. In this case, it's just

417
00:28:32,792 --> 00:28:35,810
the same three as the path,

418
00:28:36,150 --> 00:28:40,242
but the 20%

419
00:28:40,296 --> 00:28:43,842
of traffic will be sent to my service one. And the

420
00:28:43,896 --> 00:28:47,686
80% of the traffic will be sent to my service

421
00:28:47,788 --> 00:28:50,982
two. What we will see, or what

422
00:28:51,036 --> 00:28:54,342
we will expect to see here,

423
00:28:54,396 --> 00:28:58,410
is that two

424
00:28:58,480 --> 00:29:01,894
out of ten requests will print

425
00:29:02,022 --> 00:29:05,500
my pod two. And the other ones.

426
00:29:06,270 --> 00:29:09,258
Oh no, my pod one and the other ones.

427
00:29:09,344 --> 00:29:12,366
My pod two. Okay,

428
00:29:12,548 --> 00:29:16,846
let's apply it and

429
00:29:16,948 --> 00:29:20,590
let's see what are the results.

430
00:29:21,170 --> 00:29:24,610
Let's wait for it to be configured.

431
00:29:26,870 --> 00:29:31,362
We also have our myroot four, and what

432
00:29:31,416 --> 00:29:34,926
we can test is

433
00:29:35,048 --> 00:29:39,000
that path three, we add

434
00:29:39,610 --> 00:29:43,538
the okay, let's add the path

435
00:29:43,634 --> 00:29:47,586
three. We can see my pod two as the

436
00:29:47,628 --> 00:29:51,580
answer, and it is in this

437
00:29:53,230 --> 00:29:56,570
situation. So that's the 80%

438
00:29:56,640 --> 00:30:00,302
of the traffic, but let's try to

439
00:30:00,356 --> 00:30:03,642
send more requests.

440
00:30:03,706 --> 00:30:07,280
And we should see my pod one too.

441
00:30:07,970 --> 00:30:11,360
And let's get to.

442
00:30:12,630 --> 00:30:16,066
Here we are. So the 80% of

443
00:30:16,088 --> 00:30:20,050
the traffic is backed by the

444
00:30:20,200 --> 00:30:23,794
my service two, and the other 20% of

445
00:30:23,832 --> 00:30:28,166
the traffic is backed by my pod one. So the

446
00:30:28,188 --> 00:30:32,438
service, my service one. The interesting stuff

447
00:30:32,524 --> 00:30:37,350
here is that we have two routes,

448
00:30:38,810 --> 00:30:42,406
my route and my route four. And that's

449
00:30:42,438 --> 00:30:45,770
interesting because we use the same

450
00:30:45,840 --> 00:30:48,950
gateway but two different routes.

451
00:30:49,110 --> 00:30:52,800
And that's something that we can

452
00:30:53,170 --> 00:30:55,680
think about in the real world.

453
00:30:56,850 --> 00:31:00,734
Like if two different teams working

454
00:31:00,852 --> 00:31:05,118
on, for example, two different microservices

455
00:31:05,214 --> 00:31:08,690
of the same application that configured

456
00:31:09,030 --> 00:31:12,706
the different routes, and not only

457
00:31:12,888 --> 00:31:15,554
one, two and three path,

458
00:31:15,602 --> 00:31:19,800
but a whole subset of

459
00:31:20,170 --> 00:31:24,146
paths, and they created

460
00:31:24,258 --> 00:31:29,018
an HTTP route to perform,

461
00:31:29,184 --> 00:31:32,826
or the rules for that microservice, for the

462
00:31:32,848 --> 00:31:36,762
single microservice, and the

463
00:31:36,896 --> 00:31:41,050
two teams created the two routes

464
00:31:41,130 --> 00:31:44,302
that are attached to the same

465
00:31:44,356 --> 00:31:48,320
gateway. So we have Jihiro that will

466
00:31:49,170 --> 00:31:52,870
configure the gateway. So the cluster

467
00:31:52,970 --> 00:31:56,434
operator working on the

468
00:31:56,472 --> 00:32:00,610
configuration of the, for example, single DNS,

469
00:32:01,030 --> 00:32:04,370
but the single team working on this single

470
00:32:04,440 --> 00:32:08,350
microservice, configuring all the routes

471
00:32:08,430 --> 00:32:12,200
for that single microservice, and that's a great

472
00:32:12,970 --> 00:32:16,360
step forward in the possibility of

473
00:32:17,850 --> 00:32:22,220
separation, of concern when it comes to the

474
00:32:23,310 --> 00:32:28,298
security level of the things

475
00:32:28,384 --> 00:32:31,162
that are served by the API.

476
00:32:31,306 --> 00:32:34,858
Okay, let's get back to our slides

477
00:32:34,954 --> 00:32:38,014
and we've seen a live demo.

478
00:32:38,212 --> 00:32:43,200
And let's get to the next interesting

479
00:32:44,610 --> 00:32:48,430
feature of the Gateway API, the gum initiative.

480
00:32:48,510 --> 00:32:53,170
Gum stands for Gateway API for mesh management and administration.

481
00:32:53,830 --> 00:32:59,074
And basically it is an initiative that allows

482
00:32:59,122 --> 00:33:03,202
the API to works not only north south

483
00:33:03,266 --> 00:33:06,950
but east west. So for the mesh,

484
00:33:07,390 --> 00:33:10,540
the communication between the services.

485
00:33:11,470 --> 00:33:13,980
Okay, what we have here,

486
00:33:14,910 --> 00:33:19,210
the gamma initiative introduced

487
00:33:19,970 --> 00:33:23,470
three. We can call them two,

488
00:33:23,540 --> 00:33:26,606
but they are basically three changes.

489
00:33:26,788 --> 00:33:30,094
The first change is that a

490
00:33:30,132 --> 00:33:33,726
route can be associated directly with a service too.

491
00:33:33,828 --> 00:33:36,962
You've seen that the parent ref was

492
00:33:37,016 --> 00:33:40,878
a gateway until now, but we can also define

493
00:33:40,894 --> 00:33:45,054
it as service. We can define the

494
00:33:45,112 --> 00:33:50,402
kind service and indicate

495
00:33:50,466 --> 00:33:53,862
the name of the service as a parent ref of

496
00:33:53,916 --> 00:33:58,330
a route. And also the gamma initiative

497
00:33:59,950 --> 00:34:03,450
said that a service has

498
00:34:03,520 --> 00:34:07,242
two facets, a front end and back

499
00:34:07,296 --> 00:34:11,034
end. The from end is a combination of the cluster IP

500
00:34:11,082 --> 00:34:14,302
and the DNS of the service. The back

501
00:34:14,356 --> 00:34:18,010
end is the collection of the endpoint ips.

502
00:34:18,170 --> 00:34:22,522
So every IP that the endpoint

503
00:34:22,586 --> 00:34:26,302
that is backing the service is called back

504
00:34:26,356 --> 00:34:29,140
end, the back end of the service.

505
00:34:29,750 --> 00:34:33,214
Okay, let's see how the traffic

506
00:34:33,262 --> 00:34:36,518
is handled by seeing

507
00:34:36,604 --> 00:34:41,474
the east west graph

508
00:34:41,602 --> 00:34:44,550
of our traffic.

509
00:34:45,370 --> 00:34:48,842
In this case, the request is not

510
00:34:48,896 --> 00:34:52,300
done by a client, but the client in this case is

511
00:34:52,670 --> 00:34:55,740
another microservice, for example.

512
00:34:56,110 --> 00:34:59,942
So the pod asks for a

513
00:35:00,016 --> 00:35:04,042
service, and that's the particularity.

514
00:35:04,186 --> 00:35:07,694
The pod still performs a request to a

515
00:35:07,732 --> 00:35:13,294
service, but here we have three different scenarios

516
00:35:13,342 --> 00:35:17,380
that can happen. The first scenario is

517
00:35:17,910 --> 00:35:22,062
the service has no routes reached

518
00:35:22,126 --> 00:35:25,750
to it, but it still

519
00:35:25,820 --> 00:35:30,294
have an endpoint. So the

520
00:35:30,332 --> 00:35:34,054
request is routed to one of the

521
00:35:34,092 --> 00:35:37,706
p back selected by the

522
00:35:37,728 --> 00:35:42,220
endpoint. That's the standard way of

523
00:35:44,910 --> 00:35:48,410
the function of the service and its endpoint.

524
00:35:49,230 --> 00:35:52,560
The second scenario is the one where

525
00:35:53,010 --> 00:35:56,894
we have a route that is attached to

526
00:35:56,932 --> 00:36:00,302
my service. So we have the my route that

527
00:36:00,356 --> 00:36:02,640
is attached to my service,

528
00:36:04,070 --> 00:36:08,670
but there is no path

529
00:36:08,750 --> 00:36:12,798
that is defined in my route and matches

530
00:36:12,894 --> 00:36:16,520
the one that is requested to my service.

531
00:36:17,370 --> 00:36:20,470
In this case, the request will be aborted.

532
00:36:21,450 --> 00:36:25,446
The third scenario is the one where

533
00:36:25,628 --> 00:36:29,034
there is one or more path that

534
00:36:29,232 --> 00:36:33,162
is defined in my route and matches the one

535
00:36:33,216 --> 00:36:36,140
that is requested to my service.

536
00:36:36,590 --> 00:36:40,602
In this case, all the rules inside my route

537
00:36:40,666 --> 00:36:43,854
will be executed and the requests will

538
00:36:43,892 --> 00:36:47,598
be sent to the endpoint backing the service

539
00:36:47,684 --> 00:36:51,182
that is defined as the back

540
00:36:51,236 --> 00:36:54,114
end inside my route. In this case,

541
00:36:54,152 --> 00:36:57,758
we see that the requests is handled

542
00:36:57,854 --> 00:37:01,538
to the endpoint, and not to

543
00:37:01,624 --> 00:37:04,954
the service, but directly to endpoint.

544
00:37:05,102 --> 00:37:09,570
It is the default behavior. We can define

545
00:37:09,650 --> 00:37:13,000
that it still should

546
00:37:13,770 --> 00:37:16,600
route the requests to a service.

547
00:37:17,130 --> 00:37:22,218
It's clear that it should be a different service and

548
00:37:22,304 --> 00:37:25,660
not my service. Okay,

549
00:37:26,110 --> 00:37:29,802
let's get back to the general discussion about

550
00:37:29,856 --> 00:37:34,190
the gateway API and talk about the implementations.

551
00:37:34,850 --> 00:37:38,446
The API it's a set of

552
00:37:38,628 --> 00:37:42,510
rules of design guides.

553
00:37:43,030 --> 00:37:47,218
The actual implementations are different ones,

554
00:37:47,304 --> 00:37:51,202
and not every one of them are

555
00:37:51,256 --> 00:37:54,370
global available. For example, the one that I use,

556
00:37:54,440 --> 00:37:57,554
the Google Kubernetes engine, is global

557
00:37:57,602 --> 00:38:01,558
available. Kong is global available.

558
00:38:01,724 --> 00:38:05,174
But we have some implementations that

559
00:38:05,212 --> 00:38:08,474
are not global available and are in

560
00:38:08,592 --> 00:38:12,890
beta stage, for example Apache API six and istio.

561
00:38:13,550 --> 00:38:17,878
At this link we can see a list of implementation

562
00:38:17,974 --> 00:38:20,560
with their maturity level.

563
00:38:21,170 --> 00:38:24,814
Okay, and let's get to the takeaways of this

564
00:38:24,852 --> 00:38:29,006
talk. First of all, the ingress API will

565
00:38:29,108 --> 00:38:33,234
not be deprecated. It's a great API. It works

566
00:38:33,432 --> 00:38:37,090
and it worked until now. It will not be

567
00:38:37,160 --> 00:38:42,974
extended or enhanced. And that's

568
00:38:43,022 --> 00:38:46,206
one of the limitations that brought us to get a

569
00:38:46,248 --> 00:38:50,022
API so we can still use

570
00:38:50,076 --> 00:38:53,734
it. But let's take in mind that we will

571
00:38:53,772 --> 00:38:56,962
not see any new implementation,

572
00:38:57,106 --> 00:39:00,966
any new extension. The ingresses API

573
00:39:01,078 --> 00:39:03,660
has an insufficient permission model.

574
00:39:04,350 --> 00:39:07,850
Okay, we use it until now and we

575
00:39:07,920 --> 00:39:12,046
somehow, maybe someone

576
00:39:12,148 --> 00:39:15,662
decided that there

577
00:39:15,796 --> 00:39:19,294
is a shared responsibility on

578
00:39:19,332 --> 00:39:23,120
the ingress resource. The ingress class

579
00:39:23,830 --> 00:39:24,850
helped,

580
00:39:26,390 --> 00:39:29,860
introducing another resource that is

581
00:39:31,430 --> 00:39:35,846
maintained by a different team

582
00:39:36,028 --> 00:39:39,606
instead of the application development team.

583
00:39:39,708 --> 00:39:43,714
But still the Ingress API has an insufficient permission

584
00:39:43,762 --> 00:39:47,850
model. The Gateway API permission model with

585
00:39:47,920 --> 00:39:52,300
the three personas is definitely better

586
00:39:52,750 --> 00:39:56,346
than the Ingress API one. And we

587
00:39:56,368 --> 00:40:00,050
have a new roleoriented and extensible

588
00:40:00,230 --> 00:40:04,010
and portable and very expressive

589
00:40:04,090 --> 00:40:08,030
API, the gateway API. And we can use it

590
00:40:08,180 --> 00:40:12,590
and it has different good implementations

591
00:40:13,010 --> 00:40:17,030
and all of them adhere to the standard. And we'll

592
00:40:17,050 --> 00:40:21,298
always adhere to the standard because the standard is definitely

593
00:40:21,464 --> 00:40:25,590
extensible. So what

594
00:40:25,740 --> 00:40:29,080
we are saying here is that we should not

595
00:40:29,610 --> 00:40:33,302
stop using Ingress API because

596
00:40:33,356 --> 00:40:37,394
it is evil. It works great. It just

597
00:40:37,532 --> 00:40:42,634
has some limitations. And those limitations are

598
00:40:42,752 --> 00:40:45,834
not in the gateway API. So that's why we

599
00:40:45,872 --> 00:40:50,490
should start using the Gateway API instead of the Ingress API.

600
00:40:51,710 --> 00:40:55,486
Here we can find some useful links starting

601
00:40:55,588 --> 00:41:01,066
from the website of the Gateway API with the official documentation

602
00:41:01,258 --> 00:41:06,100
and some example

603
00:41:06,550 --> 00:41:11,678
with the API

604
00:41:11,774 --> 00:41:15,538
and with the Ingress API.

605
00:41:15,634 --> 00:41:19,480
And you can also find a YouTube channel with

606
00:41:20,490 --> 00:41:24,230
some videos, some official videos from Google

607
00:41:24,380 --> 00:41:27,806
that talks about the Gateway API

608
00:41:27,858 --> 00:41:31,562
and gives us some example on some

609
00:41:31,616 --> 00:41:36,410
specific topics.

610
00:41:37,870 --> 00:41:41,614
Okay, we are at the end of this talk and here

611
00:41:41,652 --> 00:41:45,950
you can find a feedback form that I

612
00:41:46,100 --> 00:41:49,962
kindly ask you to submit

613
00:41:50,106 --> 00:41:53,746
because every good talk

614
00:41:53,928 --> 00:41:58,014
becomes good because of the feedback. It's not designed

615
00:41:58,062 --> 00:42:01,730
to be good from the start.

616
00:42:01,880 --> 00:42:05,638
It becomes good and great.

617
00:42:05,804 --> 00:42:09,494
So if you want, and I

618
00:42:09,532 --> 00:42:12,806
will be very grateful to you if you

619
00:42:12,828 --> 00:42:16,694
want to send me some feedback. And that's the end of my talk.

620
00:42:16,812 --> 00:42:19,974
And I thank you for following me

621
00:42:20,092 --> 00:42:23,574
and I really hope the talk

622
00:42:23,772 --> 00:42:27,298
will be useful and the concept

623
00:42:27,394 --> 00:42:30,720
that I talked about will be

624
00:42:32,610 --> 00:42:36,302
useful for you. And let's hope that you

625
00:42:36,356 --> 00:42:40,446
will switch to the gateway API very soon because it

626
00:42:40,548 --> 00:42:43,770
is really great. Thank you and bye.

