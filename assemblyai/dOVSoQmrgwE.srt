1
00:01:44,830 --> 00:01:48,850
Hello. Thank you very much for joining this session about

2
00:01:49,000 --> 00:01:52,802
securing secrets in the Gitops era, which we're going to store right

3
00:01:52,856 --> 00:01:55,380
now, because you'll see that.

4
00:01:56,390 --> 00:01:59,730
Yeah, we always talk about

5
00:01:59,800 --> 00:02:03,634
Githubs, which is super nice. We talk about kubernetes, which is super nice. But how

6
00:02:03,672 --> 00:02:07,626
about the secrets? How we can manage the secrets under these

7
00:02:07,728 --> 00:02:11,546
environments? Because you know what, I know that there

8
00:02:11,568 --> 00:02:15,366
is the resource Kubernetes secret in Kubernetes.

9
00:02:15,478 --> 00:02:19,910
But let me tell you one thing, a Kubernetes secret

10
00:02:20,070 --> 00:02:23,466
is not a secret at all by default.

11
00:02:23,578 --> 00:02:27,374
So this is the reason for attending this talk to learn how

12
00:02:27,412 --> 00:02:31,006
to manage all these secrets. My name is Alexsoto. My tutor is

13
00:02:31,028 --> 00:02:35,186
Alexsoto. My email is altovy@redhat.com. Feel free to

14
00:02:35,368 --> 00:02:38,766
reach me there. And also, I'm the co author

15
00:02:38,798 --> 00:02:42,514
of these four books, which basically the more

16
00:02:42,632 --> 00:02:46,498
important for this topic is the secrets and Kubernetes secret

17
00:02:46,594 --> 00:02:50,134
book or money, which is this one.

18
00:02:50,252 --> 00:02:54,370
Okay, so let's start. First of all, a definition.

19
00:02:54,450 --> 00:02:57,798
What is a secret? A secret is a piece of information

20
00:02:57,884 --> 00:03:01,386
that is only known by one person or a few people and should not be

21
00:03:01,408 --> 00:03:05,450
told to others. Okay. Yeah, it's that the Cambridge dictionary definition.

22
00:03:06,110 --> 00:03:09,570
Basically, today we're going to talk about the secrets

23
00:03:09,670 --> 00:03:13,054
that needs to manage by our application.

24
00:03:13,252 --> 00:03:17,134
It's not the secrets of our

25
00:03:17,172 --> 00:03:21,294
users. So we are not talking about how to store the users passwords into

26
00:03:21,332 --> 00:03:24,482
a database. No, we're not going to do this.

27
00:03:24,536 --> 00:03:28,654
We are going to talk about the secrets that our applications requires

28
00:03:28,702 --> 00:03:31,874
to work. For example a username or a

29
00:03:31,912 --> 00:03:35,814
password, or for example a certificate, these kind of

30
00:03:35,932 --> 00:03:39,400
elements. So just one thing,

31
00:03:39,930 --> 00:03:43,270
all the things related to security,

32
00:03:43,420 --> 00:03:47,094
it's about layers. There is no 100%

33
00:03:47,212 --> 00:03:51,270
secure system. Anyone who tells you that

34
00:03:51,340 --> 00:03:55,110
it's 100% secure, it's not telling you the truth.

35
00:03:55,270 --> 00:03:59,718
So what you can do with security, and for

36
00:03:59,744 --> 00:04:03,210
example, in this case for secrets, is creating layers

37
00:04:03,290 --> 00:04:06,798
of protection. So if one layer is broken by

38
00:04:06,804 --> 00:04:10,586
an attacker, there is another layer protecting.

39
00:04:10,698 --> 00:04:13,970
And if this also is broken, we've got another

40
00:04:14,040 --> 00:04:18,594
layer. So it's about creating as much layers around our

41
00:04:18,632 --> 00:04:24,290
system as possible. So today

42
00:04:24,360 --> 00:04:27,850
we're going to talk about two different phases

43
00:04:27,950 --> 00:04:31,894
of the secret. The first one, which is the easy one, is when we

44
00:04:31,932 --> 00:04:36,006
create the secrets and we want to store it into git because we are using

45
00:04:36,108 --> 00:04:39,278
Githubs. Okay. If you're using Githubs,

46
00:04:39,474 --> 00:04:43,450
then you need to take care of how you store these secrets

47
00:04:44,350 --> 00:04:47,706
into git and then say that this is the

48
00:04:47,728 --> 00:04:51,898
easy part. And then we've got the complex

49
00:04:51,994 --> 00:04:55,962
part, the part that is like, okay, now I've got my secret in git.

50
00:04:56,106 --> 00:04:59,866
Now I apply this secret into my Kubernetes cluster.

51
00:04:59,978 --> 00:05:03,854
What's happened with this secret? How can I store it correctly

52
00:05:03,902 --> 00:05:08,254
into Kubernetes? Because at the end, the secret is stored inside kubernetes.

53
00:05:08,382 --> 00:05:12,222
So how can I store it correctly? And you'll see that that's

54
00:05:12,286 --> 00:05:15,598
more complicated. Okay, so first of all,

55
00:05:15,624 --> 00:05:19,094
what is DevOps and Githubs? Okay, DevOps is the key to meet

56
00:05:19,132 --> 00:05:22,322
the insurable demand for delivering quality applications rapidly.

57
00:05:22,386 --> 00:05:25,602
So basically, what is DevOps?

58
00:05:25,666 --> 00:05:29,562
It's that we are able to deliver our

59
00:05:29,616 --> 00:05:32,806
applications faster and it's

60
00:05:32,838 --> 00:05:35,340
like an infinite loop, which is we code,

61
00:05:36,270 --> 00:05:40,066
we test, we build, we deploy,

62
00:05:40,118 --> 00:05:43,326
we release, we parade and so on. And we are continually doing this kind of

63
00:05:43,348 --> 00:05:47,360
thing. But, okay, that's nice.

64
00:05:47,730 --> 00:05:52,010
But one of the problems that we might figure out

65
00:05:52,100 --> 00:05:55,890
most of the time is how we can deploy

66
00:05:56,870 --> 00:06:00,466
this application into production so

67
00:06:00,488 --> 00:06:03,698
we can adopt DevOps. That's fine. All shift lab,

68
00:06:03,784 --> 00:06:06,600
everyone working together. That's fine. Yes.

69
00:06:07,050 --> 00:06:11,750
Testers, developers, operations, everyone together, this DevOps

70
00:06:12,730 --> 00:06:15,782
figure, right? Okay, everyone together. Okay. Yes.

71
00:06:15,836 --> 00:06:19,674
But now we need to put this service, this application into

72
00:06:19,872 --> 00:06:23,242
production. And usually it happens something like this,

73
00:06:23,296 --> 00:06:26,890
right? We've got our application, which is, this is our application,

74
00:06:26,960 --> 00:06:30,518
okay? And all the developers here just using

75
00:06:30,614 --> 00:06:34,542
the application to go to production, we say, hey, yes, that's my application,

76
00:06:34,676 --> 00:06:38,240
let's go to production. But who is this guy?

77
00:06:38,690 --> 00:06:41,614
Yeah, probably it's the product owner, right? It's pushing back.

78
00:06:41,652 --> 00:06:46,002
No, we are not ready. We need more features before

79
00:06:46,056 --> 00:06:49,634
we go to production. Or maybe it's the tester. No, we have not

80
00:06:49,672 --> 00:06:53,186
tested correctly. The application. Who is this

81
00:06:53,208 --> 00:06:56,726
guy? Yeah, probably this guy is the architect of the application

82
00:06:56,908 --> 00:07:00,406
on top of the application. Yeah, I architected this super well.

83
00:07:00,508 --> 00:07:02,920
Right? No worries, it's going to work.

84
00:07:03,530 --> 00:07:06,706
Yeah. And this, yeah, probably is the DBA

85
00:07:06,738 --> 00:07:10,230
admin, right? Like he's always saying, or oh,

86
00:07:10,300 --> 00:07:13,430
maybe we should know, go to production

87
00:07:13,510 --> 00:07:16,906
yet. Yeah, but we need to go. Or, yeah, but there's the SQL indexes that

88
00:07:16,928 --> 00:07:20,462
I need to update. Oh, and the developers asked me to

89
00:07:20,516 --> 00:07:23,358
remove a column. Oh my. No.

90
00:07:23,524 --> 00:07:27,178
So probably, probably this is the TVA,

91
00:07:27,274 --> 00:07:30,602
right? And the problem, and this is repeated

92
00:07:30,746 --> 00:07:34,346
again and again and again, maybe once every month, maybe once every three

93
00:07:34,388 --> 00:07:37,794
months. Or you say, hey, Alex, we are delivering to production once

94
00:07:37,832 --> 00:07:42,334
every year. That's fine. But it's

95
00:07:42,382 --> 00:07:46,230
always a hard work. And the truth is that this should be something like this,

96
00:07:46,300 --> 00:07:50,358
right? Just having an application and all of us moving

97
00:07:50,444 --> 00:07:54,246
forward this to production, and this is exactly

98
00:07:54,348 --> 00:07:57,822
what we're trying to achieve with Gitops,

99
00:07:57,986 --> 00:08:01,734
githubs. We can think that it's like an implementation of DevOps,

100
00:08:01,862 --> 00:08:05,338
which basically everything is in git. Git is the

101
00:08:05,344 --> 00:08:09,258
single source of truth. We are not

102
00:08:09,344 --> 00:08:13,182
only having our

103
00:08:13,236 --> 00:08:16,654
source code into Git, but also the

104
00:08:16,692 --> 00:08:20,494
infrastructure that

105
00:08:20,532 --> 00:08:24,734
is required by our application, also the scripts

106
00:08:24,782 --> 00:08:28,926
or the manifests that we need to deploy

107
00:08:29,118 --> 00:08:31,886
our application. So everything is in git.

108
00:08:32,078 --> 00:08:35,682
Okay, then thinks of this, the infrastructure

109
00:08:35,826 --> 00:08:39,702
is as code. So when we only not work

110
00:08:39,836 --> 00:08:43,638
with our source come, but also with the manifest. In the

111
00:08:43,644 --> 00:08:47,014
case of Kubernetes Yaml files that we

112
00:08:47,052 --> 00:08:50,890
want to use to deploy this application, this service into

113
00:08:50,960 --> 00:08:53,706
production, and not only this,

114
00:08:53,808 --> 00:08:57,334
also the YAml files that we need to configure.

115
00:08:57,462 --> 00:09:01,582
For example, our Kubernetes cluster. So everything is as

116
00:09:01,636 --> 00:09:05,294
code. And one of the great advantages of this is

117
00:09:05,332 --> 00:09:09,390
that now we can use our Git commands

118
00:09:10,130 --> 00:09:13,718
to deploy our application, for example to production.

119
00:09:13,754 --> 00:09:17,410
We can use all these things that we already know, but Git

120
00:09:17,910 --> 00:09:21,374
for deploying to production or to deploy into staging.

121
00:09:21,502 --> 00:09:25,622
For example, one approach that we could have is having one

122
00:09:25,676 --> 00:09:29,270
branch name it staging, which basically is

123
00:09:29,420 --> 00:09:33,714
the manifests that are applied

124
00:09:33,762 --> 00:09:37,686
to the staging environment. And then we can have a branch being the production

125
00:09:37,718 --> 00:09:41,306
environment, which basically it's the manifest that we apply it to have the

126
00:09:41,328 --> 00:09:44,986
application running on production. Then how you move an

127
00:09:45,008 --> 00:09:48,730
application from a staging to production,

128
00:09:49,470 --> 00:09:52,494
basically sending a pull request from

129
00:09:52,532 --> 00:09:56,270
a staging branch to production branch. So we send a pull request,

130
00:09:57,010 --> 00:10:00,942
everyone can review that. The pull request is okay, that it will

131
00:10:00,996 --> 00:10:05,122
work in production and finally merge it. And when we merge it,

132
00:10:05,256 --> 00:10:09,582
then the new application will be deployed to production.

133
00:10:09,646 --> 00:10:13,842
So you can see clearly here that everything

134
00:10:13,976 --> 00:10:17,426
is code, everything goes to the git workflow.

135
00:10:17,458 --> 00:10:20,838
There is no ending console there,

136
00:10:20,924 --> 00:10:23,670
no minimal steps. Everything is automated.

137
00:10:24,730 --> 00:10:28,698
Basically when we adapt the Gitops application

138
00:10:28,784 --> 00:10:32,646
delivery model, we are saying that we've got two git

139
00:10:32,678 --> 00:10:36,394
repositories. Of course this is opinionated, I know, but my

140
00:10:36,432 --> 00:10:40,346
suggestion is that you have always two repositories.

141
00:10:40,458 --> 00:10:43,866
One, which is the source git repository. Basically it's

142
00:10:43,898 --> 00:10:47,694
the source code,

143
00:10:47,892 --> 00:10:51,120
okay, the source code that developers does here.

144
00:10:51,730 --> 00:10:55,422
Then we've got a config git repository. This other repository

145
00:10:55,486 --> 00:11:00,050
is the manifest that we need to deploy

146
00:11:01,510 --> 00:11:05,554
my service, my application to the cluster.

147
00:11:05,682 --> 00:11:09,560
So in the source git repository, usually we've got here the CI CD part,

148
00:11:10,250 --> 00:11:14,040
building the application, doing some kind of

149
00:11:14,730 --> 00:11:18,722
code analysis. Finally create a container image

150
00:11:18,866 --> 00:11:22,466
and store this container image,

151
00:11:22,498 --> 00:11:25,914
internal image, registry. This is the first part that we

152
00:11:25,952 --> 00:11:28,778
do with this GitHub's application delivery model.

153
00:11:28,864 --> 00:11:32,842
But the second part and which is important is the config repository.

154
00:11:32,906 --> 00:11:37,038
This is the manifest, this is the YAML files that

155
00:11:37,124 --> 00:11:40,800
we require for deploying this application.

156
00:11:41,650 --> 00:11:45,358
Usually in the case of kubernetes here we will have a deployment

157
00:11:45,454 --> 00:11:48,734
YAML file. Then when we create a new version

158
00:11:48,782 --> 00:11:52,542
here of the image, we will send a pull request to this git repository

159
00:11:52,686 --> 00:11:56,810
saying hey, check the deployment Yaml

160
00:11:56,830 --> 00:12:01,320
file, change this deployment YaML file and

161
00:12:01,770 --> 00:12:05,250
add the new tag. So just find the image

162
00:12:05,330 --> 00:12:08,810
section of the deployment YML file and just change

163
00:12:08,960 --> 00:12:12,426
the tag value from for example

164
00:12:12,528 --> 00:12:14,538
10 to one.

165
00:12:14,624 --> 00:12:17,020
10. Okay,

166
00:12:17,550 --> 00:12:21,214
what's going to happen then when we make this change? When we

167
00:12:21,252 --> 00:12:25,200
change this deployment yaml file? So we're changing the

168
00:12:25,970 --> 00:12:29,534
manifest that are responsible of

169
00:12:29,572 --> 00:12:32,802
deploying the application. What's happening? Okay, that we will have

170
00:12:32,856 --> 00:12:36,206
here some kind of monitor.

171
00:12:36,318 --> 00:12:39,902
Okay, in this case I'm just showing here Argo CD,

172
00:12:40,046 --> 00:12:43,634
but it could be flux CD as well or any

173
00:12:43,672 --> 00:12:47,358
other detops, let's say

174
00:12:47,384 --> 00:12:50,566
in this way technology. Okay, in this

175
00:12:50,588 --> 00:12:54,246
case we've got here argo CD which basically will detect the change that we

176
00:12:54,268 --> 00:12:57,820
did in here. So the Argo CD will detect, hey,

177
00:12:59,790 --> 00:13:03,366
we've got a deployment Yaml file

178
00:13:03,398 --> 00:13:07,014
that has changed, someone has changed the tag.

179
00:13:07,142 --> 00:13:10,782
So it will detect this change and will take action. Basically this

180
00:13:10,836 --> 00:13:14,506
action will be apply this new deployment.

181
00:13:14,618 --> 00:13:17,550
So it's going to deploy the new manifest.

182
00:13:18,050 --> 00:13:22,386
So after RBCD applies this change in

183
00:13:22,408 --> 00:13:26,302
production, we will have the new version.

184
00:13:26,366 --> 00:13:29,778
And finally we'll get back to monitor for any change.

185
00:13:29,944 --> 00:13:33,794
Okay, so this could be an example of

186
00:13:33,832 --> 00:13:36,894
a Githubs repository.

187
00:13:36,942 --> 00:13:40,166
You can see here there is a lot of YAML files, one that

188
00:13:40,188 --> 00:13:43,878
creates animal space, another one that creates a service, another one that creates a

189
00:13:43,884 --> 00:13:47,960
deployment. There is also here more here for

190
00:13:48,570 --> 00:13:51,302
creating a database, a postgres SQL database.

191
00:13:51,366 --> 00:13:54,826
Right? So we've got a to do application, as you

192
00:13:54,848 --> 00:13:58,406
can see by the name, right? And then this todo application requires

193
00:13:58,438 --> 00:14:01,994
a database. Yes. So we put

194
00:14:02,032 --> 00:14:05,390
here, this is how we deploy the database. This is how we deploy the application.

195
00:14:05,540 --> 00:14:09,662
Everything is here as code. But take a look at this. Oh yes,

196
00:14:09,716 --> 00:14:13,970
of course, my to do application requires a username and password to access

197
00:14:14,120 --> 00:14:17,214
this postgresql instance.

198
00:14:17,342 --> 00:14:20,820
So what you do, oh yes, of course,

199
00:14:21,270 --> 00:14:24,414
you create a Kubernetes secret,

200
00:14:24,542 --> 00:14:27,798
right? Because we already know Kubernetes and we know that

201
00:14:27,884 --> 00:14:31,558
we've got the concept of Kubernetes secret which is used for

202
00:14:31,724 --> 00:14:35,474
storing secrets. So let's create it. So you create a postsecret

203
00:14:35,602 --> 00:14:39,180
Yaml file. The problem is this one.

204
00:14:39,870 --> 00:14:43,338
The problem is that a Kubernetes secrets, as you can

205
00:14:43,344 --> 00:14:47,402
see here, is a Yaml file or a JSON file which

206
00:14:47,456 --> 00:14:51,690
has this data and then it has a pairs of key value key.

207
00:14:51,840 --> 00:14:55,246
For example, in this case it's username and the value and then password and the

208
00:14:55,268 --> 00:15:00,000
value. And you can see here, this is these

209
00:15:00,610 --> 00:15:03,870
characters here that would say, oh, this is the

210
00:15:04,020 --> 00:15:07,810
username and password. Yeah, it's weird but it could be.

211
00:15:07,880 --> 00:15:11,394
The problem is that this data,

212
00:15:11,592 --> 00:15:15,210
this content is stored

213
00:15:15,310 --> 00:15:19,846
in base 64. So a

214
00:15:19,868 --> 00:15:24,066
Kubernetes secrets is not created

215
00:15:24,258 --> 00:15:27,946
to be secret at all, right? Because base 64 is

216
00:15:27,968 --> 00:15:32,150
an encoding process and not an encryption

217
00:15:32,310 --> 00:15:36,582
process. So every time that we create a Kubernetes

218
00:15:36,646 --> 00:15:40,298
secret, what we are saving there is the base 64 of

219
00:15:40,304 --> 00:15:43,726
the secret. So anyone can just take this value, as you can

220
00:15:43,748 --> 00:15:47,470
see here, do basically four minutes minus the code and get the real

221
00:15:47,540 --> 00:15:51,294
value. So we want to use git apps, that's fine.

222
00:15:51,412 --> 00:15:55,166
Problem how we can store securely these secrets

223
00:15:55,198 --> 00:15:58,866
into git because now anyone with access to

224
00:15:58,968 --> 00:16:02,882
the GitHub repo will be able to

225
00:16:02,936 --> 00:16:06,514
get the secret because it's in base 64. And this

226
00:16:06,552 --> 00:16:10,166
is exactly what we are going to see now, how to protect

227
00:16:10,268 --> 00:16:14,278
these secrets in git. And let me tell you that this is the

228
00:16:14,364 --> 00:16:18,054
easiest part of the presentation. Okay. For this reason,

229
00:16:18,092 --> 00:16:21,258
it's the Barbie. So first project that I

230
00:16:21,264 --> 00:16:24,582
want to share with you, seal secrets.

231
00:16:24,646 --> 00:16:27,754
Okay, Seal Secrets is a project that uses a

232
00:16:27,792 --> 00:16:32,174
public key cryptography for

233
00:16:32,372 --> 00:16:35,502
encrypting the secrets. So these

234
00:16:35,556 --> 00:16:38,654
YAMl files before they are applied to

235
00:16:38,692 --> 00:16:42,094
the cluster. So basically as you can see here,

236
00:16:42,132 --> 00:16:45,650
it's a Kubernetes controller. So it's a piece of software running

237
00:16:45,720 --> 00:16:49,442
inside your Kubernetes cluster. Then how this works? Well,

238
00:16:49,496 --> 00:16:52,814
basically as we seen before, as a developers,

239
00:16:52,862 --> 00:16:56,594
we need to create a Kubernetes secret. So we create a Kubernetes

240
00:16:56,642 --> 00:17:00,454
secrets as we've done all the time. So just

241
00:17:00,492 --> 00:17:04,402
a secret. That's fine. Then you can see here that I've got the sealed

242
00:17:04,466 --> 00:17:08,170
secrets controller installed. Then I'm going to use this

243
00:17:08,240 --> 00:17:11,946
cube seal minus minus format Yaml because this is

244
00:17:11,968 --> 00:17:15,846
a YAml file and I want to introduce as a cube

245
00:17:15,878 --> 00:17:16,570
seal,

246
00:17:18,990 --> 00:17:22,954
the manifest, the secret without being

247
00:17:22,992 --> 00:17:26,446
encrypted. So that is the native secret. And then I want to have

248
00:17:26,468 --> 00:17:29,678
an output which is going to be the sealed secret. So this is going to

249
00:17:29,684 --> 00:17:33,230
be a new Yaml file where the

250
00:17:33,380 --> 00:17:37,266
data of the secret is using to be encrypted. So when

251
00:17:37,288 --> 00:17:41,534
I run this command, basically this command will connect to the Kubernetes

252
00:17:41,582 --> 00:17:45,094
cluster, it will connect to the sealed secrets controller and it will say

253
00:17:45,132 --> 00:17:48,422
hey, give me the public key to encrypt this

254
00:17:48,476 --> 00:17:52,294
data. Because remember that seals secrets has

255
00:17:52,332 --> 00:17:56,534
a public key inside but also private key used

256
00:17:56,572 --> 00:17:59,782
to decrypt. So it's going to return me the public key and say hey,

257
00:17:59,836 --> 00:18:03,500
this is the public key that you need to use to encrypt data.

258
00:18:04,270 --> 00:18:08,026
And then it will say okay, now I've got this yaml file, I've got

259
00:18:08,048 --> 00:18:11,822
also the public key. So I'm just going to combine both and

260
00:18:11,876 --> 00:18:15,246
create a new object, as you can see here, where it

261
00:18:15,268 --> 00:18:18,650
has a new field named encrypt

262
00:18:18,730 --> 00:18:21,690
data and the username and the password,

263
00:18:21,770 --> 00:18:25,150
now it's not encoded

264
00:18:25,230 --> 00:18:28,686
but it's encrypted. Okay, so now I've

265
00:18:28,718 --> 00:18:32,786
got a secret object that where nothing is encrypted and

266
00:18:32,808 --> 00:18:36,722
thanks of Kubeseal, I've got here a new manifest

267
00:18:36,866 --> 00:18:40,374
where the data is encrypted. After that point I

268
00:18:40,412 --> 00:18:43,330
can remove the original secret.

269
00:18:43,490 --> 00:18:45,670
The original secrets needs to be removed.

270
00:18:46,010 --> 00:18:49,366
Done. I use it for encrypting,

271
00:18:49,478 --> 00:18:53,654
I encrypted. Now I've got my secrets

272
00:18:53,702 --> 00:18:57,734
encrypted here in this object. These native

273
00:18:57,782 --> 00:19:01,126
Kubernetes secrets can be deleted. And this yaml

274
00:19:01,158 --> 00:19:04,430
file is the one that I can push to my git repository.

275
00:19:04,770 --> 00:19:07,738
Why? Because data is encrypted.

276
00:19:07,914 --> 00:19:11,278
So if you do not have the private key to decrypt this data,

277
00:19:11,444 --> 00:19:15,310
no worries, you can push it to git. No one will be able to

278
00:19:15,460 --> 00:19:19,410
check whether it's the real value of your secret

279
00:19:20,390 --> 00:19:25,362
after that. Okay, Argo CD will for example detect

280
00:19:25,426 --> 00:19:29,590
this change, detect this drift and it will decrypt

281
00:19:30,250 --> 00:19:33,826
this. But notice that this is happening inside the Kubernetes secret,

282
00:19:33,938 --> 00:19:38,122
sorry, the Kubernetes cluster, it will decrypt and

283
00:19:38,176 --> 00:19:42,614
finally it will materialize this encryption

284
00:19:42,662 --> 00:19:47,290
secret as a normal secret into Kubernetes.

285
00:19:47,870 --> 00:19:51,070
Okay, so seal secrets is used

286
00:19:51,220 --> 00:19:55,454
for storing secrets in git in

287
00:19:55,492 --> 00:19:59,534
the convenient way, in a secured way. But then when

288
00:19:59,572 --> 00:20:03,430
you apply these sealed secrets, these secured secrets

289
00:20:03,530 --> 00:20:07,410
into the cluster, we're going to decrypt it

290
00:20:07,480 --> 00:20:11,442
and create a native secret again.

291
00:20:11,576 --> 00:20:15,778
But, and I want to be clear about this, you are secure

292
00:20:15,874 --> 00:20:19,330
while you are into git, then into Kubernetes.

293
00:20:19,410 --> 00:20:22,966
All these other operations of decrypting happens inside the

294
00:20:22,988 --> 00:20:26,678
Kubernetes cluster. So developer will never know which is

295
00:20:26,684 --> 00:20:30,458
the real value. Then there is another project which is

296
00:20:30,464 --> 00:20:33,898
the external secrets project. External secrets project is more or

297
00:20:33,904 --> 00:20:36,966
less the same thing, more or less the same concept,

298
00:20:36,998 --> 00:20:41,934
which is a Kubernetes controller running. But it

299
00:20:41,972 --> 00:20:45,470
works slightly different because

300
00:20:45,540 --> 00:20:48,986
maybe you're saying, hey Alex, we are not using Kubernetes

301
00:20:49,018 --> 00:20:53,314
secrets at all. So we do not have this problem because we

302
00:20:53,352 --> 00:20:57,054
are using for example, hashicor vault for storing the secrets.

303
00:20:57,102 --> 00:21:00,786
So, okay, we are good. Yeah, that's true.

304
00:21:00,888 --> 00:21:04,382
But how you consume these secrets?

305
00:21:04,446 --> 00:21:08,626
Oh yeah, we consume them running some manual steps.

306
00:21:08,818 --> 00:21:12,034
Okay, yeah, you can do it, but you can automate it with external secrets.

307
00:21:12,082 --> 00:21:16,040
Basically external secrets, it's a controller that is running inside,

308
00:21:17,850 --> 00:21:21,814
sorry, inside Kubernetes cluster. This Kubernetes

309
00:21:21,862 --> 00:21:25,354
cluster might have inside or not any

310
00:21:25,392 --> 00:21:29,602
of these secrets management

311
00:21:29,686 --> 00:21:32,954
stores. In this case, for example, hash code vault.

312
00:21:33,082 --> 00:21:37,098
And basically in git, we are just storing

313
00:21:37,194 --> 00:21:40,926
the configuration, we are not storing the

314
00:21:40,948 --> 00:21:44,210
secret itself. So as you can see here, the first

315
00:21:44,280 --> 00:21:48,530
Yaml file that we're going to run here is configure

316
00:21:49,190 --> 00:21:54,962
external secrets controller and where

317
00:21:55,096 --> 00:21:58,614
the secrets are stored. You can see here, I say, hey, look,

318
00:21:58,652 --> 00:22:01,842
secret store, I'm just using vault

319
00:22:01,906 --> 00:22:05,174
for storing my secrets. And this is where the secrets are

320
00:22:05,212 --> 00:22:08,778
stored, in this location, in this path. Okay, so it's a

321
00:22:08,784 --> 00:22:12,474
Yaml file. You can see here that there is no secret at all.

322
00:22:12,592 --> 00:22:16,650
It's just a configuration. It's just a configuration of here is

323
00:22:16,720 --> 00:22:20,542
where are the secrets that I need for

324
00:22:20,596 --> 00:22:24,606
my application. And then we also need

325
00:22:24,628 --> 00:22:28,478
to create another Yaml file which basically

326
00:22:28,564 --> 00:22:32,458
says, look, external secrets.

327
00:22:32,634 --> 00:22:36,642
You have here a connection to this hashicorp vault. But the

328
00:22:36,696 --> 00:22:40,706
secret that I need is this one.

329
00:22:40,808 --> 00:22:44,798
You see here, I'm saying, hey, this is an external secret.

330
00:22:44,974 --> 00:22:48,158
And here it says the secret store ref, it says it's

331
00:22:48,174 --> 00:22:51,942
the ball back end. Remember that this is the object that we created here.

332
00:22:52,076 --> 00:22:55,654
Okay? So I'm saying you need to consume secrets from here. You set

333
00:22:55,692 --> 00:22:58,834
a refresh interval of 15 seconds. It means that every 15

334
00:22:58,892 --> 00:23:03,142
seconds it will check if there is a new secret

335
00:23:03,206 --> 00:23:06,986
store there. And then finally here, I'm saying, look, the path is

336
00:23:07,008 --> 00:23:10,414
positive SQl secret and I want to create this kind

337
00:23:10,452 --> 00:23:13,534
of object. So basically when I apply this,

338
00:23:13,652 --> 00:23:16,922
I will get a Kubernetes secret

339
00:23:16,986 --> 00:23:20,718
created inside. But again, the secret value

340
00:23:20,804 --> 00:23:24,402
is never stored in git. In external secrets, we are just

341
00:23:24,456 --> 00:23:27,954
storing the configuration of where is the

342
00:23:27,992 --> 00:23:31,954
secret and then this project will automatically pull

343
00:23:31,992 --> 00:23:35,662
the secret and create a kubernetes secret,

344
00:23:35,726 --> 00:23:39,334
a native Kubernetes secrets. Okay, just in case

345
00:23:39,372 --> 00:23:43,074
that you are using Hashicorp vault, let me tell you that there is a hashicor

346
00:23:43,122 --> 00:23:46,770
vault operator that does exactly the same thing as external secrets,

347
00:23:46,850 --> 00:23:50,390
but also it implements an automatic rolling update.

348
00:23:50,470 --> 00:23:54,262
So when a secret changes automatically the operator

349
00:23:54,406 --> 00:23:57,702
knows which pods are consuming these secrets

350
00:23:57,766 --> 00:24:00,394
and starts a rolling update.

351
00:24:00,522 --> 00:24:03,870
So let me show you these two projects

352
00:24:04,290 --> 00:24:07,806
I've got here. My kubernetes cluster running.

353
00:24:07,908 --> 00:24:11,966
Okay, I can do Kubectl get secrets and

354
00:24:11,988 --> 00:24:15,902
you see that yeah, I've got some secrets because they're coming by default.

355
00:24:15,966 --> 00:24:19,058
But you see that there is not my secret at all. Okay,

356
00:24:19,144 --> 00:24:22,900
now I'm going to show you seal secrets how sealed secrets works.

357
00:24:23,830 --> 00:24:29,154
Here you see that I've got a standard Kubernetes

358
00:24:29,202 --> 00:24:32,310
secrets, okay, I can do this postgres secret

359
00:24:32,730 --> 00:24:36,674
and you can see that it's just a secret, it's a native kubernetes

360
00:24:36,722 --> 00:24:40,182
secret. If I apply this kubernetes secret, okay,

361
00:24:40,236 --> 00:24:43,846
I will have this Kubernetes secrets applied into the cluster. But notice

362
00:24:43,878 --> 00:24:48,522
that if I push this yaml file to git, then everyone

363
00:24:48,656 --> 00:24:51,898
who has access to git will know this remain password

364
00:24:51,994 --> 00:24:55,706
because this is not encrypted is encoded.

365
00:24:55,898 --> 00:24:59,834
So what I need to do, I need to do remember Cube

366
00:24:59,882 --> 00:25:03,118
seal F Cube seal. Okay,

367
00:25:03,204 --> 00:25:06,414
notice I say minus minus format and I'm just checking,

368
00:25:06,462 --> 00:25:10,466
I'm just getting the content of postgresgate secret which is this one. And I

369
00:25:10,488 --> 00:25:14,318
want an output which is going to be a secret

370
00:25:14,414 --> 00:25:17,686
but encrypted. So I can do this. And now if

371
00:25:17,708 --> 00:25:20,546
I do a but of Postgresecret,

372
00:25:20,658 --> 00:25:24,658
you see that now the object is a sealsecret,

373
00:25:24,834 --> 00:25:28,298
okay? And the use password and the

374
00:25:28,304 --> 00:25:31,980
username are encrypted. So at this point

375
00:25:33,630 --> 00:25:38,326
these two files are equivalent but this is encoded

376
00:25:38,438 --> 00:25:42,186
and this is encrypted but they refers

377
00:25:42,218 --> 00:25:46,080
to the same. Then what you can do is just,

378
00:25:48,370 --> 00:25:51,534
what you can do is just delete this

379
00:25:51,572 --> 00:25:55,566
file or simply not push to git. So the

380
00:25:55,588 --> 00:25:59,038
object that you will push to git will be this one because it's

381
00:25:59,054 --> 00:26:02,926
encrypted. Now let me show you what happened when I apply this file.

382
00:26:02,958 --> 00:26:07,294
If I do Kubectl apply minus f postgresal

383
00:26:07,422 --> 00:26:10,962
secret. Okay, remember that this seal secret

384
00:26:11,026 --> 00:26:13,720
is encrypted when I apply it.

385
00:26:14,330 --> 00:26:18,310
Basically I'm applying this object to the Kubernetes cluster. Then the

386
00:26:18,380 --> 00:26:22,460
sealed controller or the secret seal controller will

387
00:26:24,270 --> 00:26:27,862
take this manifest, it will decrypt

388
00:26:27,926 --> 00:26:31,726
because the seal secret controller has the private key to decrypt it and

389
00:26:31,828 --> 00:26:35,406
then it will apply it. So if I know I do Cubecarl get

390
00:26:35,508 --> 00:26:36,510
secrets.

391
00:26:39,010 --> 00:26:41,150
Cubecarl get secrets.

392
00:26:42,290 --> 00:26:45,150
Okay, you see here that there is a secret.

393
00:26:45,490 --> 00:26:49,890
Okay? And if I do Cubecarl get secret,

394
00:26:50,230 --> 00:26:53,666
this secret minus o yaml, you can see

395
00:26:53,688 --> 00:26:56,866
that it's in a standard secret.

396
00:26:56,978 --> 00:27:00,450
So it's a Kubernetes secret. You see that now it's can encrypted.

397
00:27:00,530 --> 00:27:03,798
If you see the content here, this is the content of

398
00:27:03,804 --> 00:27:05,190
the original Yaml file.

399
00:27:06,970 --> 00:27:10,274
This is the secret that I decrypted into Kubernetes

400
00:27:10,322 --> 00:27:13,706
controller. And you see that the data is exactly the same. And if you

401
00:27:13,728 --> 00:27:17,638
see the owner references, you see that it comes from a sealed secret.

402
00:27:17,814 --> 00:27:20,240
Okay? So of course,

403
00:27:20,610 --> 00:27:24,266
now what we've got is everything encrypted

404
00:27:24,298 --> 00:27:28,074
in git, but not inside kubernetes.

405
00:27:28,202 --> 00:27:32,126
Now I can do kifcatl delete minus f of

406
00:27:32,148 --> 00:27:36,126
the postgres sql sealed secret. And you've

407
00:27:36,158 --> 00:27:39,090
got this bidirectional thing.

408
00:27:39,240 --> 00:27:41,810
Now if I do Kubectl get secret,

409
00:27:45,030 --> 00:27:49,294
you see that the secret is not here anymore. So we've got this bidirectional,

410
00:27:49,342 --> 00:27:52,866
we've got a sealed secret object in git. I applied

411
00:27:52,898 --> 00:27:56,674
this to Kubernetes cluster. Kubernetes cluster. Transform this seal secret

412
00:27:56,722 --> 00:28:00,266
into a Kubernetes secret and apply it. And to

413
00:28:00,288 --> 00:28:03,686
remove it, we can do the inverse. And it works. So he knows

414
00:28:03,718 --> 00:28:07,674
exactly, kubernetes knows exactly that this

415
00:28:07,712 --> 00:28:10,662
secret is a seal secret. And when I delete a seal secret,

416
00:28:10,726 --> 00:28:14,282
also needs to delete the native secret. Okay,

417
00:28:14,336 --> 00:28:18,334
I know that we are mixing with all these, with the things saying that

418
00:28:18,372 --> 00:28:21,166
hey, there is a secret, seal secret and so on, but I know that you

419
00:28:21,188 --> 00:28:24,882
get the point. Okay, now let me show you another

420
00:28:24,936 --> 00:28:27,966
example. In this case, external secrets.

421
00:28:28,158 --> 00:28:31,870
I've got here, I've got vault

422
00:28:32,030 --> 00:28:35,586
running. That's my instance of vault.

423
00:28:35,698 --> 00:28:41,382
And inside vault, I don't know if maybe

424
00:28:41,436 --> 00:28:43,942
locks. Let me check in vault locks now.

425
00:28:43,996 --> 00:28:47,530
Okay, well, I cannot show you now,

426
00:28:47,600 --> 00:28:52,010
but before the demo, I just created

427
00:28:54,110 --> 00:28:57,706
a new entry in vault. Okay, now let

428
00:28:57,728 --> 00:29:01,354
me go to here. This is the Yamls files.

429
00:29:01,402 --> 00:29:05,514
Okay, I'm going to show you first of all this cluster

430
00:29:05,642 --> 00:29:09,850
secret store where basically here I am configuring

431
00:29:09,930 --> 00:29:13,442
the connection to my vault instance. Just this,

432
00:29:13,496 --> 00:29:18,530
okay, I'm just configuring the

433
00:29:18,680 --> 00:29:21,906
external secret controller that, hey, there is a

434
00:29:21,928 --> 00:29:25,542
vault that I'm using to store

435
00:29:25,596 --> 00:29:28,870
secrets. So just keep in mind that I would like

436
00:29:28,940 --> 00:29:32,040
that you consume secrets from there. That's fine.

437
00:29:33,690 --> 00:29:37,126
Nothing is compromised. Okay, now let me

438
00:29:37,148 --> 00:29:42,182
show you the other file which is external

439
00:29:42,246 --> 00:29:44,620
secrets. Basically here I'm saying, look,

440
00:29:46,110 --> 00:29:48,170
I want you to use this connection,

441
00:29:48,990 --> 00:29:52,602
then you'll see that in vault

442
00:29:52,746 --> 00:29:56,250
there is a path with secrets foo.

443
00:29:56,410 --> 00:30:00,174
So you know that involved at the end, it's like a key value.

444
00:30:00,372 --> 00:30:03,486
There's a lot of more things, okay, but just to simplify it, it's a key

445
00:30:03,508 --> 00:30:07,538
value where we are storing in a place secrets in the correct

446
00:30:07,624 --> 00:30:11,314
way, right? Which are encrypted, protected and so on. And you set

447
00:30:11,352 --> 00:30:15,318
a key, which in this case is secret foo. And then

448
00:30:15,404 --> 00:30:19,206
inside this key, we can store several properties. And one

449
00:30:19,228 --> 00:30:24,546
of these property is named my value doesn't

450
00:30:24,578 --> 00:30:27,874
matter exactly everything. But what I want you to notice

451
00:30:27,922 --> 00:30:31,498
here is that the secret itself is not

452
00:30:31,664 --> 00:30:34,934
pushed into git. In this yaml file, there is no secret.

453
00:30:35,062 --> 00:30:39,002
It says where is the secret, but not what is the value

454
00:30:39,056 --> 00:30:42,906
of the secret. So you can clearly push

455
00:30:43,018 --> 00:30:46,174
these Yaml files to git. And then what's happened? One,

456
00:30:46,292 --> 00:30:50,190
when argo CD, for example, detects that there is

457
00:30:50,340 --> 00:30:54,334
this file or a change of this file, it will apply this, basically applying

458
00:30:54,382 --> 00:30:58,290
this, it will connect to the external secret

459
00:30:59,350 --> 00:31:03,326
controller. It will connect there and say, hey, external secret controller,

460
00:31:03,438 --> 00:31:05,750
go to the vault instance,

461
00:31:06,650 --> 00:31:10,086
take this value, my value from this key,

462
00:31:10,268 --> 00:31:14,338
and create a new secret.

463
00:31:14,434 --> 00:31:17,990
Name it example sync. So now if I do Kifcarl get secret,

464
00:31:19,690 --> 00:31:23,206
you see here that I've got example sync, which is a secret that I created

465
00:31:23,238 --> 00:31:26,890
26 seconds ago. So it's this one. And if I do give catal get secret

466
00:31:28,830 --> 00:31:30,570
minus o yaml.

467
00:31:31,790 --> 00:31:32,540
Okay,

468
00:31:35,170 --> 00:31:38,590
you can see that here, it's a secrets. Well, there is a lot of things,

469
00:31:38,660 --> 00:31:41,866
okay? But here you can see that I've

470
00:31:41,898 --> 00:31:47,422
got the secret that I store inside vault,

471
00:31:47,566 --> 00:31:51,650
of course, in base 64. Okay, so basically

472
00:31:51,800 --> 00:31:55,086
with these two examples

473
00:31:55,118 --> 00:31:58,386
that I'll show you now, with steel secrets,

474
00:31:58,498 --> 00:32:01,974
you are encrypting the secret and you can

475
00:32:02,012 --> 00:32:05,174
store it safely into git. In the case

476
00:32:05,212 --> 00:32:07,782
of external secrets, you are not encrypting nothing.

477
00:32:07,916 --> 00:32:11,418
The external secrets project assumes that the secret is in a

478
00:32:11,504 --> 00:32:14,746
place in this case, for example, hashicor Vault. And the only thing

479
00:32:14,768 --> 00:32:18,758
that you configures is where is the secret?

480
00:32:18,854 --> 00:32:22,126
And then automatically, when you apply where is

481
00:32:22,148 --> 00:32:25,402
the secret, it will create a native

482
00:32:25,466 --> 00:32:28,942
Kubernetes secret into the cluster, as you have seen here.

483
00:32:29,076 --> 00:32:32,126
Okay, so think that it's more or

484
00:32:32,148 --> 00:32:35,602
less clear, right? Basically, it's how to solve the problem of

485
00:32:35,656 --> 00:32:38,882
storing secrets in git. So, no,

486
00:32:39,016 --> 00:32:42,850
we are stored in a correct way.

487
00:32:43,000 --> 00:32:46,478
These two projects, depending on what you're doing, if you are using Kubernetes secrets,

488
00:32:46,494 --> 00:32:50,774
then seals secrets is the best way. If you are already using a

489
00:32:50,972 --> 00:32:54,486
secret management system, then external secrets is

490
00:32:54,508 --> 00:32:58,986
the project. But all

491
00:32:59,008 --> 00:33:02,474
this time I'm just saying. Hey, okay, we are good, right?

492
00:33:02,512 --> 00:33:08,410
Because now we are storing the secrets correctly encrypted into

493
00:33:08,560 --> 00:33:12,206
Kubernetes cluster. You've seen that I do Kubectarl get secrets and you see

494
00:33:12,228 --> 00:33:15,562
that I'm creating the secret. And in git they are never exposed.

495
00:33:15,706 --> 00:33:19,838
But what's happened about the secrets that are then

496
00:33:19,924 --> 00:33:23,326
stored into kubernetes? What's happened with them?

497
00:33:23,428 --> 00:33:24,580
Because they're there.

498
00:33:26,950 --> 00:33:30,162
Sorry. Let me tell you. The first

499
00:33:30,216 --> 00:33:33,982
secret ATCD is not encrypted.

500
00:33:34,126 --> 00:33:38,006
What does it mean? It means that ATCD is the database where

501
00:33:38,028 --> 00:33:40,978
you are storing the secrets into kubernetes.

502
00:33:41,074 --> 00:33:44,566
So when we do a kubectl apply of a secret or a seal secret or

503
00:33:44,588 --> 00:33:47,910
wherever or the controller creates a secret

504
00:33:48,070 --> 00:33:51,814
into the cluster. Cluster or Kubernetes

505
00:33:51,862 --> 00:33:55,050
cluster stores this secret into ATCD.

506
00:33:55,470 --> 00:33:59,126
ATCD is like a database where you can consume

507
00:33:59,238 --> 00:34:02,458
or you or Kubernetes cluster consumes the element.

508
00:34:02,634 --> 00:34:06,222
And okay, if ATCD is not encrypted means

509
00:34:06,276 --> 00:34:10,080
that any secret that you store there,

510
00:34:10,610 --> 00:34:14,018
if anyone has access to the ATCD, it will be

511
00:34:14,024 --> 00:34:17,730
able to get the secret. Or if he has access

512
00:34:17,880 --> 00:34:21,426
to the ATCD logs, it might have the

513
00:34:21,448 --> 00:34:24,578
secret. Maybe not. Maybe yes. Depending on how you implement the

514
00:34:24,584 --> 00:34:28,434
logs, if anyone has access to the ATCD

515
00:34:28,482 --> 00:34:31,606
backups, then he can get

516
00:34:31,628 --> 00:34:35,462
the access. Right. Because ATCD is a database with

517
00:34:35,596 --> 00:34:39,446
passwords in plain text there. So yeah,

518
00:34:39,548 --> 00:34:42,870
this was detected by people

519
00:34:42,940 --> 00:34:46,186
from Kubernetes and said oh yes, yeah, we see that this is not the

520
00:34:46,208 --> 00:34:50,042
best way. So we're going to create a new object which is an

521
00:34:50,176 --> 00:34:54,302
encryption configuration object that we're going to apply it. So when

522
00:34:54,356 --> 00:34:57,514
we go here and you apply a secret.

523
00:34:57,562 --> 00:35:01,098
So when you create a secret into the cluster, it will go to a phase

524
00:35:01,114 --> 00:35:05,154
of encryption configuration which basically will encrypt the secret and

525
00:35:05,192 --> 00:35:08,718
then store into ATCD encrypted.

526
00:35:08,894 --> 00:35:12,290
Okay, this is how it works. So now you will say,

527
00:35:12,360 --> 00:35:15,714
oh, we are safe, right? Because I've got a secret in git

528
00:35:15,762 --> 00:35:19,506
which is encrypted. Then the controller will create a Kubernetes secret.

529
00:35:19,618 --> 00:35:22,866
But then we will enable this encryption configuration.

530
00:35:22,978 --> 00:35:26,498
So the secret will be stored in ATCD encrypted,

531
00:35:26,674 --> 00:35:29,866
right. Well this is not entirely true because there is

532
00:35:29,888 --> 00:35:33,194
a problem. ATCD is

533
00:35:33,232 --> 00:35:37,190
where we store the encrypted data, the encrypted secret.

534
00:35:37,350 --> 00:35:41,230
But also in the ATCD we're storing the keys

535
00:35:41,650 --> 00:35:45,242
for decrypting the secret.

536
00:35:45,386 --> 00:35:48,910
So what happened if an attacker get access to ATCD

537
00:35:49,410 --> 00:35:53,550
basically, it will get ATCD, it will get the secret. It will get

538
00:35:53,620 --> 00:35:57,154
the private key to decrypt the secrets. So everything is

539
00:35:57,192 --> 00:36:00,338
there. I can decrypt the secret. Thank you

540
00:36:00,344 --> 00:36:03,726
very much. Right? Yes. You thought that it was everything encrypted,

541
00:36:03,758 --> 00:36:07,298
but it was not. Well, it was encrypted,

542
00:36:07,394 --> 00:36:10,454
but the private key was also there. So it's like

543
00:36:10,652 --> 00:36:14,694
not encrypted. If you are a serious hacker, you'll get it really

544
00:36:14,732 --> 00:36:18,890
quickly, right? To decrypt this data. So possible

545
00:36:18,960 --> 00:36:22,534
solutions. First of all, move ATCD

546
00:36:22,582 --> 00:36:26,140
outside of the cluster. This is something that people really don't know,

547
00:36:26,750 --> 00:36:30,454
is that you can move ATCD outside of the cluster.

548
00:36:30,502 --> 00:36:33,790
And what happened that if ATCD is outside of the cluster,

549
00:36:34,210 --> 00:36:37,594
means that you can start storing

550
00:36:37,642 --> 00:36:41,086
things in different places. So you can have one ETCD where you

551
00:36:41,108 --> 00:36:44,586
store the secret, another ETCD that where you store

552
00:36:44,628 --> 00:36:47,746
the private key. It's super complicated. No one use it.

553
00:36:47,768 --> 00:36:51,826
But I just mentioned it here because the solution that I recommend you

554
00:36:51,848 --> 00:36:54,638
is this one using the KMS plugin.

555
00:36:54,734 --> 00:36:58,790
Okay, what does it mean, this KMS plugin? It works in similar way as

556
00:36:58,860 --> 00:37:02,038
this, as the encryption configuration. But instead

557
00:37:02,124 --> 00:37:05,266
of encrypting the content inside the cluster,

558
00:37:05,378 --> 00:37:08,634
it relays on a third party system.

559
00:37:08,832 --> 00:37:12,486
So in this case, I've got a secret. So someone applied

560
00:37:12,518 --> 00:37:16,218
a secret into the cluster. Then automatically the cluster will

561
00:37:16,304 --> 00:37:19,882
take. This secret goes to the third

562
00:37:19,936 --> 00:37:23,306
party that you configure it, and the KMS plugin section,

563
00:37:23,338 --> 00:37:27,054
in this case, for example, Hashicor vault, it will go the secret. It will do

564
00:37:27,092 --> 00:37:31,374
here, to hashicor vault. Hashicor vault will encrypt the

565
00:37:31,412 --> 00:37:34,702
secret, and then it will store this secret into

566
00:37:34,756 --> 00:37:38,306
ATCD. Okay? Then when we want to apply

567
00:37:38,408 --> 00:37:41,778
this secret, when we need to consume the secret, it will be the reverse order.

568
00:37:41,864 --> 00:37:45,710
We're going to the ATCD, we're going to the ball ball will decrypt the

569
00:37:45,720 --> 00:37:49,110
data and just then give us the secret.

570
00:37:49,770 --> 00:37:53,366
Much better, right? Because now an attacker might need to

571
00:37:53,388 --> 00:37:57,938
compromise two systems, which is more difficult, right? It needs to compromise ATCD

572
00:37:58,034 --> 00:38:01,642
to get the secret. And then you need to compromise the

573
00:38:01,696 --> 00:38:04,826
vault, the cache vault for getting the private key and then

574
00:38:04,848 --> 00:38:08,582
decrypt it. So this is more a convenient way, more secured

575
00:38:08,646 --> 00:38:12,122
way when we are dealing with passwords

576
00:38:12,266 --> 00:38:15,678
or secrets. Sorry, but.

577
00:38:15,764 --> 00:38:20,106
Oh, yes, that's much more. Right? And probably you already know this, basically what's

578
00:38:20,138 --> 00:38:23,518
happened when you are encrypting ATCD.

579
00:38:23,614 --> 00:38:27,474
But then you need to consume these secrets. Okay. That we can

580
00:38:27,512 --> 00:38:31,410
inject these secrets into

581
00:38:31,480 --> 00:38:35,026
the pod, right? Because at the end our application is going to run

582
00:38:35,048 --> 00:38:38,790
into a pod and we need to inject this pod.

583
00:38:39,450 --> 00:38:42,678
Sorry, we need to run this pod and this pod requires a secret, so we

584
00:38:42,684 --> 00:38:45,810
need to inject this secret into the pod. ATC is encrypted,

585
00:38:45,890 --> 00:38:48,666
but when someone,

586
00:38:48,848 --> 00:38:52,070
for example, a pod request the secret,

587
00:38:52,230 --> 00:38:55,738
the secrets is decrypted. Basically.

588
00:38:55,824 --> 00:38:59,306
What does it mean is that if you're using an

589
00:38:59,328 --> 00:39:02,586
ambient variables, you're going to inject this secret as

590
00:39:02,608 --> 00:39:06,574
an embarrassment variable. So not encrypted. Anyone could just go there and

591
00:39:06,612 --> 00:39:10,766
say export and just get the secret. Or maybe sometimes

592
00:39:10,868 --> 00:39:14,378
in the monitoring tools you are printing, right? Or you're monitoring

593
00:39:14,394 --> 00:39:18,098
also the MBM variables. So, okay, you will have in

594
00:39:18,104 --> 00:39:22,558
your monitoring system the passwords or in the locks. Some systems

595
00:39:22,734 --> 00:39:26,718
locks them on variables. So you will

596
00:39:26,744 --> 00:39:30,006
get the password into the locks. Another option, it will

597
00:39:30,028 --> 00:39:33,238
be as a volume, it's much better because as a

598
00:39:33,244 --> 00:39:38,274
volume it means that you are mounting the secret into

599
00:39:38,332 --> 00:39:41,930
a file. In fact, it's an in memory file system.

600
00:39:42,080 --> 00:39:45,686
Okay, so you are materializing the secret as a file.

601
00:39:45,798 --> 00:39:48,634
So it's not an MBL member variable, it's much better.

602
00:39:48,752 --> 00:39:52,750
But in any case it's super easy to get them because

603
00:39:52,820 --> 00:39:55,966
you only need to do an FS tab. And when you do an

604
00:39:55,988 --> 00:40:00,158
FS tab, what you're getting there is

605
00:40:00,244 --> 00:40:03,906
the location of this in memory file system. So you go to the location of

606
00:40:03,928 --> 00:40:08,386
the memory file system and you can get the

607
00:40:08,408 --> 00:40:11,874
passwords. Okay, the third step, the most

608
00:40:11,912 --> 00:40:15,346
complicated one, is using the Kubernetes API. You know that from a pod you

609
00:40:15,368 --> 00:40:19,778
can consume elements from the Kubernetes

610
00:40:19,954 --> 00:40:23,606
API. So for example, I can say I'm a pod and instead of

611
00:40:23,628 --> 00:40:27,618
injecting the secret, what I could do is say, okay, I'm just going to

612
00:40:27,804 --> 00:40:31,974
create a connection, a rest connection to Kubernetes

613
00:40:32,022 --> 00:40:36,154
API, for example, and consume from there the

614
00:40:36,192 --> 00:40:39,254
secret. So I am not injecting the volume,

615
00:40:39,382 --> 00:40:42,714
sorry, I'm not injecting the secret as a volume or as an immune variable,

616
00:40:42,762 --> 00:40:46,686
but I'm consuming directly from the Kubernetes API, which is more and

617
00:40:46,708 --> 00:40:50,314
more and more secure. That's for true, right, because the secret

618
00:40:50,362 --> 00:40:53,778
goes from ATC encrypted to the memory space of

619
00:40:53,784 --> 00:40:56,866
the application, unencrypted. But you will need

620
00:40:56,888 --> 00:41:00,462
to write a lot, a lot of yaml

621
00:41:00,526 --> 00:41:04,034
files. So I have an idea basically,

622
00:41:04,232 --> 00:41:07,954
and this is what I suggest all the time, is using hashicor

623
00:41:08,002 --> 00:41:11,586
vault. If you're using hashicor vault or any secrets

624
00:41:11,618 --> 00:41:15,560
management system, you are consuming the

625
00:41:16,010 --> 00:41:19,610
secrets directly. So no need

626
00:41:19,680 --> 00:41:22,998
for creating kubernetes secrets Yaml files

627
00:41:23,094 --> 00:41:26,790
no need for configuring YAML files,

628
00:41:26,870 --> 00:41:30,458
no need for injecting secrets as a

629
00:41:30,464 --> 00:41:34,410
file, as an MBM variable, which are not the most secure way.

630
00:41:34,480 --> 00:41:40,154
The most secure way is doing a direct connection to the secret

631
00:41:40,202 --> 00:41:42,850
management system using for example, HTTPs.

632
00:41:43,190 --> 00:41:46,706
You go there, you consume the secret and

633
00:41:46,728 --> 00:41:49,774
you store the secret in the memory space of the pod.

634
00:41:49,902 --> 00:41:54,382
So the secret is always encrypted

635
00:41:54,446 --> 00:41:58,210
here, then it's decrypted and moved using HTTPs,

636
00:41:58,290 --> 00:42:01,430
so it's inarrowly encrypted.

637
00:42:01,850 --> 00:42:05,938
And then here the HTTPs protocol will decrypt

638
00:42:06,034 --> 00:42:09,530
and put this secret in the

639
00:42:09,600 --> 00:42:13,322
memory space of the application. So if an attacker get access

640
00:42:13,376 --> 00:42:17,126
to your pod, we'll see no MBM variables with secrets,

641
00:42:17,238 --> 00:42:21,054
no files with secrets. Of course he could dump the memory, right?

642
00:42:21,092 --> 00:42:25,162
But yeah, probably it's super impractical,

643
00:42:25,226 --> 00:42:29,150
right, to get the secret by inspecting the memory dump.

644
00:42:30,210 --> 00:42:33,742
Of course it has good and bad things. The bad thing,

645
00:42:33,796 --> 00:42:36,626
I would say that it's a new tool that you need to operate. So if

646
00:42:36,648 --> 00:42:39,586
you are not using hashicle vault, you need to learn hashicore vault. If you're not

647
00:42:39,608 --> 00:42:42,914
using any secret management system like

648
00:42:42,952 --> 00:42:46,266
having Amazon or Google or Azure,

649
00:42:46,318 --> 00:42:48,806
you need to learn it, you need to operate it, you need to understand how

650
00:42:48,828 --> 00:42:49,560
it works,

651
00:42:51,930 --> 00:42:55,414
you need to configure it correctly, securely and so on.

652
00:42:55,612 --> 00:42:59,142
Also it requires code changes, so your application

653
00:42:59,276 --> 00:43:03,686
needs to change. For example as an mgomon variable

654
00:43:03,798 --> 00:43:07,786
approach, probably your application doesn't need to change, but in this case you are

655
00:43:07,808 --> 00:43:11,562
doing. A direct call from your application to the secret managers

656
00:43:11,626 --> 00:43:15,374
store means that of course you

657
00:43:15,412 --> 00:43:19,098
need to change your code to consume

658
00:43:19,194 --> 00:43:22,766
this secret. But I will say that they are

659
00:43:22,788 --> 00:43:26,606
the best. Okay, these tools, especially Hashicorp vault,

660
00:43:26,718 --> 00:43:29,902
are the best tools for keeping your secrets

661
00:43:29,966 --> 00:43:33,358
secure. It also implements monitoring for attacks.

662
00:43:33,454 --> 00:43:36,898
It also lets you audit what's happening with your secrets.

663
00:43:36,994 --> 00:43:40,594
It gives you a lot of functionalities for secret

664
00:43:40,642 --> 00:43:44,022
rotations. And one of the best things that it has

665
00:43:44,076 --> 00:43:48,278
is the dynamic secrets. Because you know what the best secret

666
00:43:48,374 --> 00:43:52,346
is? Having no secret. Because if there is no secret, then there

667
00:43:52,368 --> 00:43:56,342
is nothing to hide. And this is exactly what dynamic

668
00:43:56,406 --> 00:44:00,154
secrets does. And Hashicor Vault does extremely

669
00:44:00,202 --> 00:44:03,294
good job. Basically a dynamic secret is that you

670
00:44:03,332 --> 00:44:06,510
configure vault to inject,

671
00:44:07,090 --> 00:44:11,386
for example, the password to access to the postgreSql

672
00:44:11,418 --> 00:44:15,214
database. It injected automatically to the postgresql

673
00:44:15,262 --> 00:44:19,250
instance. So the administrator of PostgreSQl will

674
00:44:19,320 --> 00:44:22,466
never know the password because the

675
00:44:22,488 --> 00:44:26,754
password is generated and injected automatically by hashicor

676
00:44:26,802 --> 00:44:30,498
Vault. What's happened? If you for example, put a rotation

677
00:44:30,594 --> 00:44:32,920
of 60, 60 minutes,

678
00:44:33,690 --> 00:44:37,658
then Hashicor vault will update the password of the

679
00:44:37,664 --> 00:44:41,098
PostgreSQL every 60 minutes. But it's even

680
00:44:41,184 --> 00:44:44,202
more interesting because remember that this

681
00:44:44,256 --> 00:44:48,026
password is inside hashicor vault means that

682
00:44:48,208 --> 00:44:51,570
our application, the application that needs to connect to this postgres

683
00:44:51,590 --> 00:44:55,370
SQL database, it will get the password directly from Hashicor vault,

684
00:44:55,450 --> 00:44:59,146
the same password, and then it will connect to that database.

685
00:44:59,338 --> 00:45:02,714
So you can see that no one knows the password,

686
00:45:02,762 --> 00:45:06,574
only Hashicor vault. And Hashicor vault will connect to the postgres

687
00:45:06,622 --> 00:45:09,874
SQl instance, to my application instance, it will inject this

688
00:45:09,912 --> 00:45:13,614
password. And if every 60 minutes we change this password, Hashicor vault

689
00:45:13,662 --> 00:45:16,658
will inject this new password to both instances,

690
00:45:16,834 --> 00:45:20,178
which means that we as operators

691
00:45:20,354 --> 00:45:23,960
will never know the password. So we do not need to have

692
00:45:24,330 --> 00:45:27,754
any concerns about YaMl files, about any

693
00:45:27,792 --> 00:45:31,734
developer publishing the secret. No, because the password

694
00:45:31,782 --> 00:45:35,210
is automatically, dynamically created.

695
00:45:35,950 --> 00:45:39,180
Let me show you some example about this.

696
00:45:40,050 --> 00:45:42,480
I'm going here. Okay,

697
00:45:44,370 --> 00:45:48,560
let me go for example, just to have something quickly,

698
00:45:51,410 --> 00:45:54,818
I will share with you the details of this rip. Okay,

699
00:45:54,904 --> 00:45:57,330
now let me create for example, a secret.

700
00:45:57,750 --> 00:46:00,980
Create secret. Okay,

701
00:46:01,670 --> 00:46:05,034
this is my secret. I've got my Kubernetes

702
00:46:05,102 --> 00:46:08,934
cluster encrypting ATCD content. So now

703
00:46:09,052 --> 00:46:13,862
my secret, this is my secret here.

704
00:46:13,916 --> 00:46:16,614
I just created this secret directly, but it could be a sealed secret. Okay,

705
00:46:16,652 --> 00:46:20,134
but just for the sake of simplicity, I just created a secret. Now this secret

706
00:46:20,182 --> 00:46:24,038
has been stored into the TCD encrypted.

707
00:46:24,214 --> 00:46:27,786
Yes, but now what happened when I want to use,

708
00:46:27,888 --> 00:46:31,946
I think that I got here. Yes, I need

709
00:46:31,968 --> 00:46:36,400
to inject it in some way into my application. And in this case I'm using

710
00:46:37,010 --> 00:46:40,554
a volume, not an MM variable. I'm just setting a volume.

711
00:46:40,602 --> 00:46:44,574
You can see here, I'm saying, hey, look, I want to create a new volume

712
00:46:44,702 --> 00:46:48,002
which is named my secret volume. And the mount path is my stuff,

713
00:46:48,056 --> 00:46:52,034
secret of stuff. And here I'm saying that

714
00:46:52,152 --> 00:46:55,474
in volume section and putting this name my secret volume,

715
00:46:55,522 --> 00:46:59,720
which is this one. Okay, I'm saying I want to create

716
00:47:00,570 --> 00:47:03,410
the secret from my secret.

717
00:47:03,490 --> 00:47:07,266
You see that the secret that I created here, it's my

718
00:47:07,308 --> 00:47:10,634
secret. Okay, so basically here I'm just

719
00:47:10,672 --> 00:47:14,202
saying, but into this directory, the content

720
00:47:14,256 --> 00:47:20,474
of my secret. Now I'm going to deploy it deployment

721
00:47:20,522 --> 00:47:21,230
sQl.

722
00:47:23,650 --> 00:47:27,166
I always say that if I get it €1 for every time

723
00:47:27,188 --> 00:47:30,634
that I wrote incorrectly. Chief cutout, probably now I will be retired.

724
00:47:30,762 --> 00:47:35,394
Okay, now I've got here

725
00:47:35,432 --> 00:47:38,900
my pot. Okay, it's just starting, wait a bit.

726
00:47:43,030 --> 00:47:46,870
Okay, now it's running. Now if I do cubecatal exact minus ti

727
00:47:47,770 --> 00:47:48,760
of this,

728
00:47:52,810 --> 00:47:56,614
basically I'm simulating that I'm an attacker, that I get

729
00:47:56,652 --> 00:48:01,110
access to the pod. I can go to my staff

730
00:48:03,790 --> 00:48:07,930
and see the secret stuff. And here

731
00:48:08,000 --> 00:48:12,206
you can see that there is two files, one that is named username, another one

732
00:48:12,228 --> 00:48:17,246
that is named password. And basically the

733
00:48:17,268 --> 00:48:20,942
name of the password is the key and the content is the value.

734
00:48:20,996 --> 00:48:24,306
So you can go here, I can do a cat of password and you can

735
00:48:24,328 --> 00:48:28,574
see here that I've got my password,

736
00:48:28,702 --> 00:48:32,210
okay, which if you remember it was the value,

737
00:48:32,280 --> 00:48:36,518
my password. So that's what I meant before

738
00:48:36,684 --> 00:48:40,290
that. You can store correctly your secret

739
00:48:40,370 --> 00:48:45,330
into git, you can store them correctly into kubernetes,

740
00:48:45,410 --> 00:48:49,494
cluster into etCD. But when you inject it into a

741
00:48:49,532 --> 00:48:53,354
pod, you see that it's in clear text and

742
00:48:53,392 --> 00:48:56,874
that's what I meant. Then use hashicor vault and

743
00:48:56,992 --> 00:49:00,250
use the dynamic secrets because the best secret is

744
00:49:00,320 --> 00:49:04,186
having no secret. And this is what I mean that I'm not running, I just

745
00:49:04,208 --> 00:49:07,566
here have the code because basically if I run it, you will

746
00:49:07,588 --> 00:49:11,550
see nothing. But what I want you to see here. Here is where I configure,

747
00:49:11,970 --> 00:49:16,058
you see here, this is where I configure the

748
00:49:16,084 --> 00:49:19,070
postgresql connection.

749
00:49:19,230 --> 00:49:21,646
Okay? You see that they say, okay, I want to connect to a postgres.

750
00:49:21,678 --> 00:49:25,046
The username is admin. Okay, this is for the sake of simplicity, nothing else.

751
00:49:25,148 --> 00:49:28,998
But you see here, credentials provider Db. So I'm

752
00:49:29,004 --> 00:49:32,200
just saying, okay, no,

753
00:49:32,970 --> 00:49:36,274
there is no password here. You see them say quarkus

754
00:49:36,322 --> 00:49:40,294
vault. I'm just saying, hey, just keep in mind that

755
00:49:40,332 --> 00:49:43,546
the password is not settled by the

756
00:49:43,568 --> 00:49:47,180
user. It's not set it by an environment variable, it's not set it by using

757
00:49:48,110 --> 00:49:51,840
a volume, it's here

758
00:49:52,530 --> 00:49:56,346
inside vault. So basically what I'm

759
00:49:56,378 --> 00:50:00,254
doing here is saying the password, it will never be provided by

760
00:50:00,292 --> 00:50:04,554
any human, it will be provided by Vault. So vault

761
00:50:04,602 --> 00:50:08,370
will create a password in the positive SQL database, vault will create a password,

762
00:50:09,590 --> 00:50:12,866
will inject the password or this application

763
00:50:12,968 --> 00:50:15,842
will consume the password from vault. Okay.

764
00:50:15,976 --> 00:50:18,914
And then that's the password. You see a password?

765
00:50:18,962 --> 00:50:22,114
No, there is no password. Any problem with Yaml files?

766
00:50:22,162 --> 00:50:25,858
No, because we do not need a Kubernetes secret yaml file because it's

767
00:50:25,874 --> 00:50:29,622
already done by vault automatically. And any

768
00:50:29,676 --> 00:50:32,710
problem on injecting the secrets?

769
00:50:32,790 --> 00:50:35,866
No, of course, as I said before,

770
00:50:35,968 --> 00:50:40,334
you need to change a bit the code

771
00:50:40,452 --> 00:50:45,230
to make it run. Then just let's

772
00:50:45,650 --> 00:50:50,366
wind down. Okay, basically we

773
00:50:50,388 --> 00:50:54,318
are covering three phases, git in ATCD

774
00:50:54,414 --> 00:50:57,410
and storing the secrets in runtime,

775
00:50:58,550 --> 00:51:02,078
all of them. I mean maybe you might use seal secrets,

776
00:51:02,094 --> 00:51:06,074
maybe external secrets. That's for the git for ATCD.

777
00:51:06,142 --> 00:51:11,090
We saw the key MS plugin, so encrypt

778
00:51:11,170 --> 00:51:15,074
your data outside. And then we've got the problem of how to inject

779
00:51:15,202 --> 00:51:19,878
the secrets into the memory space or

780
00:51:19,964 --> 00:51:23,930
as a file, as an emul variable, I recommend you memory space.

781
00:51:24,080 --> 00:51:27,194
So again, just to finish, there is no

782
00:51:27,232 --> 00:51:31,786
good or bad thing. I just explained the problems that you can find

783
00:51:31,888 --> 00:51:35,118
and possible solutions. If you want to inject secrets as

784
00:51:35,124 --> 00:51:38,846
an MBLM variable. If it worked this way all your time

785
00:51:38,948 --> 00:51:42,800
and you have never had any problem, then go for it.

786
00:51:43,170 --> 00:51:46,398
But if now you say oh yeah, it's a good thing maybe

787
00:51:46,564 --> 00:51:49,874
that we should encrypt things, then let's move to

788
00:51:49,912 --> 00:51:54,094
for example, files. Maybe you've been storing Kubernetes secrets with ATCD

789
00:51:54,142 --> 00:51:57,806
unencrypted and it was fine because you protected

790
00:51:57,838 --> 00:52:01,158
really well ATCD and so on, then go for it,

791
00:52:01,324 --> 00:52:05,286
it's fine. But if you are, as I said at the beginning, if you want

792
00:52:05,308 --> 00:52:08,822
to add another layer of protection, because notice that you can protect

793
00:52:08,876 --> 00:52:13,366
ATCD, but if this layer of protection is broken, then the passwords

794
00:52:13,398 --> 00:52:16,858
are in plain text. So maybe you want to add another

795
00:52:16,944 --> 00:52:21,206
layer. So let's add a new layer, right? A new layer

796
00:52:21,238 --> 00:52:24,734
that is like, okay, maybe someone get access to ATCD, then it will

797
00:52:24,772 --> 00:52:27,822
find the secrets encrypted and so on. Okay,

798
00:52:27,956 --> 00:52:31,758
what is really important as well make secret key rotation. One of

799
00:52:31,764 --> 00:52:35,614
the key points to maintain things safe is rotating

800
00:52:35,742 --> 00:52:39,486
the secrets. Rotating the keys. Tools like falcos

801
00:52:39,518 --> 00:52:43,758
tag rocks and sneak helps you a lot of preventing and detecting these threats.

802
00:52:43,934 --> 00:52:47,254
Remember, no secrets is the best secrets. I said that

803
00:52:47,292 --> 00:52:51,346
before. And you've seen, right. If you do not have any secret, then no worries

804
00:52:51,378 --> 00:52:54,454
of managing them. And keep

805
00:52:54,492 --> 00:52:58,774
in mind that there is not a one

806
00:52:58,892 --> 00:53:02,634
or there is no black or white, so there is a gray, right.

807
00:53:02,672 --> 00:53:05,990
And probably you might need to coexist

808
00:53:06,150 --> 00:53:10,174
both options. Secret management tools like hashicor vault and also

809
00:53:10,292 --> 00:53:13,854
native Kubernetes secrets. So for

810
00:53:13,892 --> 00:53:18,458
this thing I think that it's important to understand secrets

811
00:53:18,474 --> 00:53:22,446
management systems, but also kubernetes secrets. And that's all.

812
00:53:22,548 --> 00:53:26,674
If you want to learn more about it, you can just scan this QR code

813
00:53:26,872 --> 00:53:30,610
and this QR code you will be able to download it. This book for free.

814
00:53:30,760 --> 00:53:34,258
This not, but this, yes. And yeah, we're covering a bit of

815
00:53:34,264 --> 00:53:37,714
githubs and also how to secure the part of the

816
00:53:37,752 --> 00:53:40,930
Githubs links about. Yeah, here,

817
00:53:41,080 --> 00:53:44,034
this is the link of the presentation. This is the link of the code.

818
00:53:44,152 --> 00:53:47,546
Here are some links and that's all. Thanks you very

819
00:53:47,568 --> 00:53:50,582
much for coming to this session. Have you enjoyed, have you find it useful?

820
00:53:50,646 --> 00:53:54,106
And if there is any question, remember that you can find

821
00:53:54,288 --> 00:53:56,920
me in email or Twitter. Thank you very much.

