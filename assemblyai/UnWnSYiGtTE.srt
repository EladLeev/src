1
00:00:27,650 --> 00:00:31,410
Okay, welcome to my talk about queryable APIs with GraphQL.

2
00:00:31,490 --> 00:00:35,126
In this talk we are going to start off by explaining the

3
00:00:35,148 --> 00:00:38,886
use case or the example that we are using. During the talk we

4
00:00:38,908 --> 00:00:42,178
will then build this example using jaxrs.

5
00:00:42,354 --> 00:00:46,402
That should show us the problem of overfetching and underfetching.

6
00:00:46,466 --> 00:00:50,526
And then we will convert that application to a graphQl application to

7
00:00:50,548 --> 00:00:53,838
show how graphQl solves that. And then we will dive a

8
00:00:53,844 --> 00:00:57,374
little bit deeper into what we can do with graphql before

9
00:00:57,412 --> 00:01:01,134
we end with what's in the pipeline or what are we working on

10
00:01:01,172 --> 00:01:04,400
at the moment. Okay, so let's start with the use case

11
00:01:04,870 --> 00:01:08,514
to explain this example. So what we have is an application

12
00:01:08,632 --> 00:01:12,526
that's kind of like a gamification application or a reward system or scoring

13
00:01:12,558 --> 00:01:15,854
system that can score users based on some action

14
00:01:15,902 --> 00:01:19,638
that they've done. As an example, a travel system

15
00:01:19,724 --> 00:01:23,222
that you get points or miles if you fly to

16
00:01:23,276 --> 00:01:26,118
specific places. And that scores a person.

17
00:01:26,204 --> 00:01:29,986
So we have a person object, which is quite a big object and it contains

18
00:01:30,018 --> 00:01:33,306
quite a lot of fields and information about this person. And then we have

19
00:01:33,328 --> 00:01:36,486
a score object that can define a type of score

20
00:01:36,518 --> 00:01:39,958
and the value of that score. And then obviously we want to display

21
00:01:40,054 --> 00:01:44,442
some of these fields onto different uis

22
00:01:44,586 --> 00:01:48,814
depending on what the user is on. So let's start off by building this application

23
00:01:48,932 --> 00:01:52,426
in rest and we'll use Jax Rs to do that. So what I've

24
00:01:52,458 --> 00:01:56,350
done is I went to codecorequist IO

25
00:01:56,510 --> 00:01:59,262
and I started off with just these three extensions.

26
00:01:59,326 --> 00:02:03,074
But as I've built it I've added more extensions. This will

27
00:02:03,112 --> 00:02:06,486
help you to bootstrap can application. Now the

28
00:02:06,508 --> 00:02:10,022
high level design of this application is basically we have

29
00:02:10,076 --> 00:02:13,618
different data stores for people and score.

30
00:02:13,794 --> 00:02:17,286
So the person or people are being stored in

31
00:02:17,308 --> 00:02:21,014
a relational database and is started with a person service, which actually

32
00:02:21,052 --> 00:02:25,318
is JPA, to store and retrieve these entities.

33
00:02:25,494 --> 00:02:29,306
And then the score service is a flat file that gets stored on

34
00:02:29,328 --> 00:02:32,658
disk. And then both of these are fronted

35
00:02:32,694 --> 00:02:36,766
by a rest API that can then be consumed by

36
00:02:36,788 --> 00:02:40,314
the user. And then obviously the object model exists that defines

37
00:02:40,362 --> 00:02:43,342
person and score and everything that goes with it. It's actually quite a big object

38
00:02:43,396 --> 00:02:46,020
model. Okay, so let's get into it.

39
00:02:46,630 --> 00:02:50,066
I already have built the application,

40
00:02:50,168 --> 00:02:54,190
like I said. So a person service. Here's the rest API.

41
00:02:54,350 --> 00:02:58,418
You can see that this is a plain old Jackson rest API

42
00:02:58,594 --> 00:03:02,774
that injects the backend service and then exposes getting

43
00:03:02,812 --> 00:03:06,518
it by id by basically just passing that along and

44
00:03:06,604 --> 00:03:10,746
getting everybody by calling the back end service and similarly the

45
00:03:10,768 --> 00:03:13,946
score service. Go get

46
00:03:13,968 --> 00:03:17,420
the score off the score service, it just injects it and make it available

47
00:03:17,870 --> 00:03:21,038
via rest. So the application is already running in the

48
00:03:21,044 --> 00:03:25,194
background. So if you go to localhost

49
00:03:25,322 --> 00:03:29,626
80 80 Q dev on caucus, you get to the dev console.

50
00:03:29,738 --> 00:03:33,134
You can see all the extensions that I

51
00:03:33,172 --> 00:03:36,754
have. So we want to look at open API or

52
00:03:36,792 --> 00:03:40,446
specifically swagger UI so that we can see these rest endpoints that we've

53
00:03:40,478 --> 00:03:44,450
built. Okay, let's clear the log file so

54
00:03:44,600 --> 00:03:49,038
you can see I can go and get all people and

55
00:03:49,064 --> 00:03:52,758
that will return all the people in the database. And it is quite a

56
00:03:52,764 --> 00:03:56,646
lot of information. Like I said, there's a lot of information on person,

57
00:03:56,828 --> 00:04:00,650
but I can also then get a specific person, like person one.

58
00:04:00,800 --> 00:04:04,394
So after I've gotten this person with all the information which I

59
00:04:04,432 --> 00:04:08,074
maybe only want name and surname of, I can also get

60
00:04:08,272 --> 00:04:12,220
some id number which is what I can use to

61
00:04:12,670 --> 00:04:16,302
go and get the scores for this person because this is

62
00:04:16,356 --> 00:04:19,838
a separate system, like I said. So now I have the score. So I

63
00:04:19,844 --> 00:04:23,834
had to make two HTTP calls. Both returned

64
00:04:23,882 --> 00:04:27,282
too much data, but the first one didn't return

65
00:04:27,336 --> 00:04:31,186
all the data that I wanted. I had to filter out too much data and

66
00:04:31,208 --> 00:04:35,122
then made a subsequent call to get even more data that's too much,

67
00:04:35,256 --> 00:04:38,886
filter that out and combined a lot to actually display the page that

68
00:04:38,908 --> 00:04:42,230
I want. That brings us to the actual problem,

69
00:04:42,300 --> 00:04:46,006
the problem of over and under fetching. So overfetching is when I

70
00:04:46,028 --> 00:04:49,894
fetch way too much data and I don't want to use

71
00:04:49,932 --> 00:04:53,450
all of it and I want to actually define what exactly

72
00:04:53,520 --> 00:04:56,762
I'm interested in. The web page might want more data,

73
00:04:56,816 --> 00:05:00,234
but the mobile site might want less data because it has less

74
00:05:00,272 --> 00:05:04,154
screen space to actually display it on. And then under fetching is when

75
00:05:04,192 --> 00:05:07,806
I made a call, but there's not all the information in there that I

76
00:05:07,828 --> 00:05:11,246
need, and I have to make subsequent calls to get all the

77
00:05:11,268 --> 00:05:14,394
information that I need. So that brings us to GraphQL.

78
00:05:14,442 --> 00:05:18,674
We're going to take that application and convert it to a graphQl application.

79
00:05:18,872 --> 00:05:22,722
Before we do that, let's quickly just go through a little bit of history of

80
00:05:22,776 --> 00:05:26,510
GraphQL. It's developed and open source by Facebook.

81
00:05:26,670 --> 00:05:29,942
It's just a specification, you can find it there

82
00:05:29,996 --> 00:05:33,382
under that URL. It's been positioned as an alternative to

83
00:05:33,436 --> 00:05:36,454
rest, even though you can use the two together.

84
00:05:36,652 --> 00:05:40,198
It does declarative data fetching, which is solving the problem that I've

85
00:05:40,214 --> 00:05:44,282
just described. Facebook developed it because of the increased use

86
00:05:44,416 --> 00:05:48,202
mobile usage that they have on their platforms. And mobile is

87
00:05:48,256 --> 00:05:51,642
much more sensitive towards network traffic. It also

88
00:05:51,696 --> 00:05:55,358
allows a variety of different front end frameworks and

89
00:05:55,444 --> 00:05:58,894
a rapid feature development. Because the separation between

90
00:05:58,932 --> 00:06:03,326
your front end team and your back end team is much cleaner. Because I

91
00:06:03,348 --> 00:06:06,206
can do queries, I do not have to go to a back end team to

92
00:06:06,228 --> 00:06:09,794
say, I need this specific service, please build it for me so that I

93
00:06:09,832 --> 00:06:14,018
can build my front end. They've been doing this since 2012 and

94
00:06:14,104 --> 00:06:17,794
GraphQL has a specification has been available since 2015.

95
00:06:17,912 --> 00:06:21,058
Okay, so if we look at our high level design again, what we're

96
00:06:21,074 --> 00:06:24,486
going to do is we're going to remove, we're going to take this and

97
00:06:24,508 --> 00:06:27,710
this one and replace it with one API,

98
00:06:27,890 --> 00:06:31,066
person GraphQl API. Okay, so let's get into that.

99
00:06:31,088 --> 00:06:34,890
So we'll start off by just grabbing the person rest

100
00:06:34,960 --> 00:06:39,494
API and copying and pasting it to a different namespace.

101
00:06:39,622 --> 00:06:43,262
And now we'll start changing it. So we'll start off

102
00:06:43,316 --> 00:06:47,470
by renaming it to be person Graphql

103
00:06:47,970 --> 00:06:51,230
API. Let me just go bigger.

104
00:06:53,670 --> 00:06:57,870
And now we can actually remove all of this jacksory

105
00:06:57,950 --> 00:07:02,286
specific things. And we can say that this is a GraphQL

106
00:07:02,398 --> 00:07:06,322
API and we still want to inject person

107
00:07:06,376 --> 00:07:09,814
service because we still get the data from the backend service.

108
00:07:10,012 --> 00:07:13,942
And now we can say this is going to be a query, which means

109
00:07:13,996 --> 00:07:17,426
I'm fetching data. I don't have the

110
00:07:17,468 --> 00:07:20,842
concept of a path parameter. And this will also

111
00:07:20,896 --> 00:07:21,850
be a query.

112
00:07:25,070 --> 00:07:28,646
And that's it. I can obviously remove all the unused

113
00:07:28,678 --> 00:07:32,262
imports now. So I've now taken that service and made a graphql

114
00:07:32,326 --> 00:07:36,062
endpoint out of it. So let's go have a look at it.

115
00:07:36,196 --> 00:07:39,614
So back into my dev UI you will see that there's also

116
00:07:39,652 --> 00:07:44,250
a graphql UI which is similar to swagger UI. It's just a way that

117
00:07:44,340 --> 00:07:47,300
it's just a front red hat gives you access to your services.

118
00:07:48,310 --> 00:07:52,338
So the first thing that you'll notice is that it's got a built in

119
00:07:52,504 --> 00:07:56,434
schema with Jax Rs. You have to use something

120
00:07:56,632 --> 00:08:01,622
on top of Jax Rs like Openapi to actually create

121
00:08:01,676 --> 00:08:05,334
that schema. Now we have this built in

122
00:08:05,372 --> 00:08:09,270
schema. As you can see here you can traverse the schema

123
00:08:10,410 --> 00:08:14,380
and because of that you also have code inside. So here I can do

124
00:08:14,990 --> 00:08:18,570
people like we've done. But the difference now is that I can say

125
00:08:18,640 --> 00:08:22,878
what fields I'm interested in. So if I'm only interested in

126
00:08:22,964 --> 00:08:26,286
all the people's names, the payload obviously coming back from the

127
00:08:26,308 --> 00:08:29,902
server is much smaller because I filtered already out

128
00:08:29,956 --> 00:08:33,966
all the fields that I don't want. And similarly I can do get

129
00:08:33,988 --> 00:08:37,354
me person where

130
00:08:37,492 --> 00:08:40,674
Id is one. And now I can

131
00:08:40,712 --> 00:08:44,418
say what do I want back? I want names and let's say

132
00:08:44,584 --> 00:08:47,814
surname and then I only get that back.

133
00:08:47,852 --> 00:08:51,910
So you can already see that the overfetching problem is solved.

134
00:08:52,410 --> 00:08:56,326
So let's see if we can solve the underfetching problem. So what

135
00:08:56,348 --> 00:08:58,860
we'll do is we'll take the score service,

136
00:08:59,710 --> 00:09:02,540
no, not the school service, the actual rest service,

137
00:09:02,990 --> 00:09:06,042
and we'll just copy this part and

138
00:09:06,096 --> 00:09:07,740
paste it in here.

139
00:09:09,390 --> 00:09:13,280
Okay, so we still want to obviously inject the back end service

140
00:09:13,650 --> 00:09:17,550
because that's where we get our data from. But we want to change

141
00:09:17,700 --> 00:09:21,262
this rest input. Now the difference now is that we're not going to make this

142
00:09:21,316 --> 00:09:24,580
queryable. What we're going to do is we're going to say that

143
00:09:25,190 --> 00:09:28,606
if there is a query where the source,

144
00:09:28,718 --> 00:09:32,462
meaning the output of this query, the source

145
00:09:32,526 --> 00:09:33,700
is a person.

146
00:09:36,330 --> 00:09:39,846
So source person p then add a

147
00:09:39,868 --> 00:09:43,158
list of scores as a field to that person and then I

148
00:09:43,164 --> 00:09:46,840
can say p dot id number

149
00:09:47,710 --> 00:09:51,782
before I save. What you'll notice here is that there's no score

150
00:09:51,846 --> 00:09:54,860
service at the moment.

151
00:09:55,470 --> 00:09:59,580
But once I save and

152
00:09:59,890 --> 00:10:04,286
refresh you

153
00:10:04,308 --> 00:10:07,614
will see that there's now a scores field on this as

154
00:10:07,652 --> 00:10:11,194
a queryable field and then I can obviously go deeper into that graphql

155
00:10:11,242 --> 00:10:14,994
to find exactly what I want. So what I've done now is

156
00:10:15,112 --> 00:10:18,754
I've fixed both the over and under fetching problem with

157
00:10:18,792 --> 00:10:22,914
one call. I've got exactly the data that I want and

158
00:10:22,952 --> 00:10:25,410
that is what we are solving.

159
00:10:26,810 --> 00:10:33,526
What is happening in the background here is that when

160
00:10:33,548 --> 00:10:36,726
a query comes in we see that you want a person and we see

161
00:10:36,748 --> 00:10:40,950
that you also want that score. Now basically

162
00:10:41,020 --> 00:10:44,106
what's happening in the background is we make a call to this method and then

163
00:10:44,128 --> 00:10:47,946
we make a call to this method. The problem comes in with something like

164
00:10:48,048 --> 00:10:51,434
get people where you might have thousand people and

165
00:10:51,472 --> 00:10:55,390
we don't want to make 1000 method calls to this. That is just not efficient.

166
00:10:56,290 --> 00:11:00,974
We could make it a batch type scenario where we say actually send

167
00:11:01,012 --> 00:11:05,362
me in the list of people. So do

168
00:11:05,416 --> 00:11:08,834
this. So both get person and

169
00:11:08,872 --> 00:11:11,842
get people will now call this with a list. Even though get person,

170
00:11:11,896 --> 00:11:15,686
the list will be the size of one. And what we'll do

171
00:11:15,708 --> 00:11:21,430
now here is we'll say p stream map

172
00:11:23,130 --> 00:11:26,838
and then we say we want person gets

173
00:11:26,924 --> 00:11:31,260
id number and then we want to collect it

174
00:11:32,510 --> 00:11:38,522
in a collector to

175
00:11:38,576 --> 00:11:42,622
list. Right? So now I have a list

176
00:11:42,676 --> 00:11:46,446
of ids which

177
00:11:46,468 --> 00:11:50,206
I can much more efficiently call the

178
00:11:50,228 --> 00:11:54,530
back end service. Now again, before I click save here, let's actually

179
00:11:54,600 --> 00:11:57,250
do people again. Um,

180
00:12:01,590 --> 00:12:05,486
so, and then we'll say, give me the names and the

181
00:12:05,528 --> 00:12:08,790
surnames and scores,

182
00:12:09,370 --> 00:12:12,120
and then you'll see the problem, we'll just do name.

183
00:12:12,570 --> 00:12:15,926
Okay? So if I go to my log file now,

184
00:12:15,948 --> 00:12:19,478
you'll see this is the problem that I went and I got all the people,

185
00:12:19,564 --> 00:12:22,378
but then I called that method a few times and that's what we want to

186
00:12:22,384 --> 00:12:26,682
try and solve so that we don't have to do that. So this

187
00:12:26,736 --> 00:12:27,980
will solve that.

188
00:12:30,350 --> 00:12:33,570
So if I red hat call now, let's clear the lock

189
00:12:33,590 --> 00:12:34,160
from,

190
00:12:39,010 --> 00:12:42,458
you can see that now I made that call with all the ids,

191
00:12:42,474 --> 00:12:45,938
so it's a much more efficient call for the backend. Now that's called

192
00:12:46,024 --> 00:12:51,266
batching. In graphql you

193
00:12:51,288 --> 00:12:55,140
can actually call multiple requests. So as an example,

194
00:12:56,810 --> 00:13:04,182
let me just close this one as an example, let's go back to our

195
00:13:04,236 --> 00:13:07,606
person query. So this return

196
00:13:07,788 --> 00:13:11,546
one person, but maybe I want person one and two. So I can

197
00:13:11,568 --> 00:13:15,242
do something like this where I say person one will be this

198
00:13:15,376 --> 00:13:17,740
and then I also want person two.

199
00:13:19,230 --> 00:13:23,182
And maybe for person two I only

200
00:13:23,236 --> 00:13:26,442
want the name and the surname, not the scores.

201
00:13:26,586 --> 00:13:29,200
Maybe it's showing you your friends or whatever.

202
00:13:29,570 --> 00:13:34,622
So names and surname and

203
00:13:34,756 --> 00:13:37,890
again in one call I can combine these things

204
00:13:37,960 --> 00:13:41,266
and this doesn't have to be from the same entity like a person.

205
00:13:41,448 --> 00:13:45,460
So as an example, let's say that like I said, this could be a system

206
00:13:46,550 --> 00:13:50,294
that rewards you for traveling. And as an added benefit they

207
00:13:50,332 --> 00:13:54,518
will show you the exchange rate against

208
00:13:54,604 --> 00:13:58,746
your base currency of the country that you're going to. So for

209
00:13:58,768 --> 00:14:02,730
instance, we can add another

210
00:14:02,800 --> 00:14:06,470
source method. Let me do this. So we inject

211
00:14:06,550 --> 00:14:10,310
an exchange rate service

212
00:14:10,480 --> 00:14:15,914
and then we add an exchange rate field onto

213
00:14:15,962 --> 00:14:20,190
person. Similarly like we do with scores.

214
00:14:23,330 --> 00:14:26,846
And here you can see that apart from the

215
00:14:26,868 --> 00:14:30,798
source that you pass in, you can pass in even more queryable

216
00:14:30,974 --> 00:14:35,054
parameters in. So this should give us a exchange

217
00:14:35,102 --> 00:14:37,942
rate. The other thing that we want to do is we want to also show

218
00:14:37,996 --> 00:14:41,814
the weather. So let's add a

219
00:14:41,852 --> 00:14:45,442
weather API. So that means when I travel to London

220
00:14:45,586 --> 00:14:49,050
I can see the exchange rate and the weather of my destination.

221
00:14:50,350 --> 00:14:55,622
So I'm going to add a new API,

222
00:14:55,686 --> 00:14:59,226
the weather graphql API. And I'm just

223
00:14:59,248 --> 00:15:03,774
going to cut and paste it because it's not important how

224
00:15:03,812 --> 00:15:05,470
we pulled it necessarily.

225
00:15:08,770 --> 00:15:12,462
But you can see it's again just a graphql API with

226
00:15:12,516 --> 00:15:15,794
injecting a backend service. This is actually making an actual weather call

227
00:15:15,832 --> 00:15:19,150
to can API somewhere on the Internet

228
00:15:19,230 --> 00:15:23,730
that will give me the weather of a service. So back

229
00:15:23,800 --> 00:15:26,982
here I should now

230
00:15:27,036 --> 00:15:31,602
actually say, well, let's say person one travels

231
00:15:31,666 --> 00:15:35,014
is traveling to London. So here I want

232
00:15:35,052 --> 00:15:38,330
to just refresh so that my schema updates.

233
00:15:39,710 --> 00:15:47,180
So I want to get the exchange rate against

234
00:15:50,590 --> 00:15:53,934
the pound and I just want to get the rate.

235
00:15:54,132 --> 00:15:57,674
And then I also want to get weather, which is now separate API.

236
00:15:57,722 --> 00:15:59,920
It's not a field on person.

237
00:16:00,610 --> 00:16:03,986
And let's see, what do I need to

238
00:16:04,008 --> 00:16:07,220
pass in I think city and

239
00:16:08,150 --> 00:16:11,874
London, right. And then let's see,

240
00:16:11,912 --> 00:16:15,394
I want to return the description, the minimum and

241
00:16:15,432 --> 00:16:16,550
the maximum.

242
00:16:23,370 --> 00:16:26,934
Okay, so it took a bit longer because

243
00:16:26,972 --> 00:16:30,058
it's actually making a call out onto the Internet. But you can see I've got

244
00:16:30,064 --> 00:16:33,306
the weather, I've got the exchange rate and I've got the person. So I

245
00:16:33,328 --> 00:16:39,066
can combine any

246
00:16:39,088 --> 00:16:42,254
amount of graphQl endpoints into one

247
00:16:42,292 --> 00:16:45,200
request to get exactly the data that I want.

248
00:16:48,210 --> 00:16:51,594
Okay, so that brings us to the next point is asynchronous.

249
00:16:51,642 --> 00:16:55,790
So at the moment what is happening is that as the request

250
00:16:55,870 --> 00:16:59,650
comes into the server we go fetch person. We need person

251
00:16:59,720 --> 00:17:04,062
to be able to get exchange rate. So we can't do these two sequential

252
00:17:04,126 --> 00:17:08,120
because I need the base currency against which

253
00:17:08,970 --> 00:17:12,518
of this person to get the exchange rate. And that's why it's a

254
00:17:12,524 --> 00:17:16,550
source field. But something like weather doesn't need to wait for person

255
00:17:16,700 --> 00:17:20,662
because I just need to get the weather for London. So we could theoretically actually

256
00:17:20,716 --> 00:17:24,406
just call this and this concurrently. But at the moment it's

257
00:17:24,438 --> 00:17:27,914
been called sequential. Now the way in which we're going to change that

258
00:17:27,952 --> 00:17:31,886
so that we can do it concurrently is just

259
00:17:31,908 --> 00:17:34,190
to use asynchronousity.

260
00:17:35,090 --> 00:17:38,366
So we'll start off with the weather service. We'll basically say that

261
00:17:38,388 --> 00:17:43,562
this should be a completion

262
00:17:43,706 --> 00:17:46,590
stage of weather.

263
00:17:47,570 --> 00:17:51,662
Now the actual back end service is already actually asynchronous.

264
00:17:51,726 --> 00:17:54,340
So we can just do this.

265
00:17:56,410 --> 00:18:02,662
And then for person API we

266
00:18:02,716 --> 00:18:11,180
now want to do the same here config person.

267
00:18:14,350 --> 00:18:17,980
And for now we'll just do something like this.

268
00:18:23,810 --> 00:18:27,518
So that should allow us to actually call weather and

269
00:18:27,604 --> 00:18:31,114
person at the same time. Now to see that in action

270
00:18:31,162 --> 00:18:33,790
we need to also look at the log file.

271
00:18:35,090 --> 00:18:38,770
So this was the previous call. You can red hat. I got the person

272
00:18:38,840 --> 00:18:42,178
and then after I got the person I got the exchange rate and then I

273
00:18:42,184 --> 00:18:45,474
got that back. And only then I started getting the weather for London.

274
00:18:45,522 --> 00:18:49,494
And then I got the weather and then I got

275
00:18:49,532 --> 00:18:53,414
the scores. So let's clear this

276
00:18:53,612 --> 00:19:00,890
and do that call again and

277
00:19:00,960 --> 00:19:03,900
get an error. Let me just,

278
00:19:04,590 --> 00:19:07,610
I do get errors every now and then,

279
00:19:07,680 --> 00:19:12,186
and it's usually the hot reload. So I'm

280
00:19:12,218 --> 00:19:17,246
just restarting caucus in deaf mode and

281
00:19:17,268 --> 00:19:19,520
then we'll give that try again.

282
00:19:36,610 --> 00:19:39,998
Let's go. Okay, here we

283
00:19:40,004 --> 00:19:43,774
go. So back

284
00:19:43,812 --> 00:19:45,520
here, we'll do the call again.

285
00:19:46,930 --> 00:19:48,990
It's still getting an error.

286
00:19:50,630 --> 00:19:56,466
Oh, that's that error context. Not aware I

287
00:19:56,488 --> 00:20:00,322
can actually quickly fix it. There's a problem that this needs to be

288
00:20:00,376 --> 00:20:03,640
transactional for some reason. I'm not sure why,

289
00:20:04,810 --> 00:20:08,040
actually that could come out. We don't want to show that now.

290
00:20:09,610 --> 00:20:10,470
Um,

291
00:20:13,450 --> 00:20:16,806
so actually let's see if it works. Now, I'm not going to get

292
00:20:16,828 --> 00:20:20,058
into detail on why this is broken or not working.

293
00:20:20,144 --> 00:20:23,866
I'm not transactional. But anyway. Okay, so I got the data back and let's look

294
00:20:23,888 --> 00:20:27,530
at the log file now. And you can red

295
00:20:27,680 --> 00:20:31,550
hat. I'm getting the weather and the person and

296
00:20:31,620 --> 00:20:34,782
then the exchange rate. Then I got the weather and the exchange rate.

297
00:20:34,836 --> 00:20:37,760
So you can see that this is definitely a better,

298
00:20:39,670 --> 00:20:43,220
splitting the work up into two. A better way to do this.

299
00:20:44,150 --> 00:20:44,900
Now,

300
00:20:48,070 --> 00:20:51,314
what will happen if I basically say

301
00:20:51,352 --> 00:20:55,170
that I want to travel to London

302
00:20:55,250 --> 00:20:59,094
and New York? So I want to do this where

303
00:20:59,132 --> 00:21:03,382
I say that this is Great

304
00:21:03,436 --> 00:21:07,222
Britain pound

305
00:21:07,366 --> 00:21:11,050
and this will be then USD.

306
00:21:11,710 --> 00:21:15,580
So let's do USD here.

307
00:21:18,130 --> 00:21:21,214
And then I want the weather for both of those as well. So I want

308
00:21:21,252 --> 00:21:24,510
London's weather and then I want New York's weather.

309
00:21:25,410 --> 00:21:26,160
Right,

310
00:21:30,630 --> 00:21:37,314
New York. So now it

311
00:21:37,352 --> 00:21:40,882
should call person weather and

312
00:21:40,936 --> 00:21:44,350
weather concurrently.

313
00:21:44,510 --> 00:21:48,034
But what I also want to do is I want to call these two concurrently,

314
00:21:48,082 --> 00:21:51,766
because again, once I have person, the one doesn't have to wait for

315
00:21:51,788 --> 00:21:55,818
the other. So again, in person service,

316
00:21:55,984 --> 00:21:59,738
I can even change the exchange rate

317
00:21:59,824 --> 00:22:02,570
to be a complete completion stage.

318
00:22:03,310 --> 00:22:07,274
And that will allow then for me to call all the fields that I've

319
00:22:07,322 --> 00:22:11,470
added with a source to be returned

320
00:22:13,090 --> 00:22:16,720
concurrently. Right.

321
00:22:17,650 --> 00:22:21,310
So now let's look at the log file.

322
00:22:23,410 --> 00:22:27,138
You can see that it's getting the weathers at the same time as the person,

323
00:22:27,224 --> 00:22:30,226
and then it's getting the two exchange rate. The one is not waiting for the

324
00:22:30,248 --> 00:22:34,150
other, which is obviously a much better design

325
00:22:34,220 --> 00:22:37,046
in certain cases. Okay,

326
00:22:37,148 --> 00:22:41,394
so what we have looked at so far is how graphql solves

327
00:22:41,442 --> 00:22:44,746
over and under fetching by using a query and

328
00:22:44,768 --> 00:22:48,554
by using the source to add fields onto it. And we've looked

329
00:22:48,592 --> 00:22:52,490
at batch, multiple requests and asynchronous.

330
00:22:52,990 --> 00:22:56,934
So if I just recap batch basically before batch,

331
00:22:56,982 --> 00:23:00,494
or if you don't do batch, you can get in a situation where a

332
00:23:00,532 --> 00:23:03,854
source field in a collection is

333
00:23:03,892 --> 00:23:07,482
being called multiple times and that's not necessarily efficient.

334
00:23:07,626 --> 00:23:10,706
But then you can do something like that where it's all batched up

335
00:23:10,728 --> 00:23:14,206
in one call. And then with asynchronous,

336
00:23:14,238 --> 00:23:17,794
we started off by looking at, before we use any

337
00:23:17,912 --> 00:23:21,314
completion stage, everything was

338
00:23:21,352 --> 00:23:24,598
sequential. So we will get the person and then we'll get the exchange rate and

339
00:23:24,604 --> 00:23:26,680
then we'll get the weather before we return.

340
00:23:27,610 --> 00:23:32,326
If we change weather and person to be a

341
00:23:32,348 --> 00:23:36,194
completion state return, then we can call those two concurrent,

342
00:23:36,242 --> 00:23:39,894
and then we can go further to say that even the source fields,

343
00:23:39,942 --> 00:23:42,650
so these two fields can be called concurrent.

344
00:23:43,870 --> 00:23:46,620
So that's all going to depend on your use case.

345
00:23:49,010 --> 00:23:52,206
So let's dive a little bit deeper into graphql and see what

346
00:23:52,228 --> 00:23:55,630
else can we do with graphql. Okay,

347
00:23:55,780 --> 00:23:59,254
so we'll start off with errors and partial

348
00:23:59,322 --> 00:24:02,962
response. So I'm just going to revert back to just

349
00:24:03,016 --> 00:24:05,170
getting a person and scores.

350
00:24:07,990 --> 00:24:11,474
Red hat we'll do is we'll say, let's pretend that

351
00:24:11,512 --> 00:24:15,438
the score system, the one that provides this data, is down.

352
00:24:15,624 --> 00:24:19,400
So what we'll do is back in our API, we'll just

353
00:24:20,730 --> 00:24:22,390
here with scores,

354
00:24:24,110 --> 00:24:26,490
we will just throw a runtime exception,

355
00:24:27,550 --> 00:24:31,242
throw new

356
00:24:31,296 --> 00:24:34,666
runtime exception and

357
00:24:34,768 --> 00:24:39,414
we'll just say the score

358
00:24:39,542 --> 00:24:41,740
system down,

359
00:24:42,510 --> 00:24:47,070
right. So what I don't want to do is penalize

360
00:24:49,010 --> 00:24:52,866
the caller and give him nothing. So what

361
00:24:52,888 --> 00:24:56,594
we have here is partial results that I can at least return what I have,

362
00:24:56,632 --> 00:25:00,274
which is the person, but I do not have the

363
00:25:00,312 --> 00:25:03,906
score. So I return null there. So I could still kind

364
00:25:03,928 --> 00:25:07,314
of recover or show alternative in a front

365
00:25:07,352 --> 00:25:10,738
end case. And this error could be, there could be multiple errors.

366
00:25:10,754 --> 00:25:14,018
And you can see here that the message is not the one that I've typed

367
00:25:14,114 --> 00:25:17,366
in my code. It's not saying the school system is down, it's saying server

368
00:25:17,398 --> 00:25:20,854
error. And this is because I'm throwing a runtime exception.

369
00:25:20,902 --> 00:25:24,620
So by default, runtime exceptions will hide the message,

370
00:25:25,230 --> 00:25:28,954
mostly for security reasons, and then checked exceptions

371
00:25:29,002 --> 00:25:31,806
will actually spill it over the boundary. So you can see it. So if we

372
00:25:31,828 --> 00:25:35,854
change this, for instance, to be a

373
00:25:35,892 --> 00:25:39,890
new score not available exception,

374
00:25:40,950 --> 00:25:42,690
which we will then throw,

375
00:25:45,190 --> 00:25:48,626
this is now a checked exception. So now I

376
00:25:48,648 --> 00:25:52,558
will get the message there. Now both of checked and

377
00:25:52,584 --> 00:25:56,374
unchecked exceptions behavior is configurable, meaning that

378
00:25:56,412 --> 00:26:00,566
you can say that for this runtime exception I actually want to pass the

379
00:26:00,588 --> 00:26:04,286
message over the boundary. And for this checked exception I don't.

380
00:26:04,338 --> 00:26:07,926
So all of those combinations is configurable. But the default

381
00:26:07,958 --> 00:26:12,326
is basically a blanket rule, all runtime and all checked

382
00:26:12,358 --> 00:26:16,454
exceptions. So that's

383
00:26:16,502 --> 00:26:20,534
errors and partial responses. You also have normal errors,

384
00:26:20,582 --> 00:26:24,314
like if you put in something here that doesn't exist,

385
00:26:24,362 --> 00:26:27,438
although you can already see it here. If you do a query, you'll get a

386
00:26:27,444 --> 00:26:30,320
validation error that says that that's not a valid field,

387
00:26:30,770 --> 00:26:34,274
it's a normal validation. And beam validation also works.

388
00:26:34,392 --> 00:26:37,860
I'm not going to show that now because I don't have enough time.

389
00:26:39,270 --> 00:26:43,300
Next I want to show transformation and mapping. So up until now,

390
00:26:43,750 --> 00:26:47,320
let me just quickly fix this before I continue.

391
00:26:49,530 --> 00:26:55,014
Right, so now the system is back up and this

392
00:26:55,052 --> 00:26:57,080
will work again. Now I'm a save,

393
00:27:00,330 --> 00:27:04,058
the system is back up. Now. Up until now we've basically

394
00:27:04,144 --> 00:27:07,482
used the default mapping that graphql gives us out of the box

395
00:27:07,536 --> 00:27:11,150
to say that allowing is mapping to a

396
00:27:11,220 --> 00:27:15,306
big integer and a date is mapping

397
00:27:15,338 --> 00:27:18,590
this way. But you can actually control that.

398
00:27:18,660 --> 00:27:22,242
So we'll start off by looking at the schema here. So if you look at

399
00:27:22,296 --> 00:27:26,046
person, you'll see that our id is mapped as a big integer.

400
00:27:26,158 --> 00:27:29,762
Now that is because in our model a

401
00:27:29,816 --> 00:27:32,966
person, the id is marked as a

402
00:27:32,988 --> 00:27:36,262
long. Now you might not

403
00:27:36,316 --> 00:27:39,634
want to have it as a big integer

404
00:27:39,682 --> 00:27:43,560
in the schema and you can then do something like this where you would say

405
00:27:44,650 --> 00:27:48,170
to scalar and then you say

406
00:27:48,240 --> 00:27:50,540
which type you want this to map to.

407
00:27:51,230 --> 00:27:54,314
So in our case we say that this should map to an int.

408
00:27:54,512 --> 00:27:57,520
Now if I go and look at this again,

409
00:28:02,290 --> 00:28:05,120
the person id is now an Int.

410
00:28:05,730 --> 00:28:09,280
Okay, so this is a basic scholar to scarlet mapping that's available.

411
00:28:10,050 --> 00:28:14,066
Then we support JSon B out

412
00:28:14,088 --> 00:28:17,230
of the box, but also with our own annotations.

413
00:28:17,310 --> 00:28:20,594
So if you don't have JSoN B, then you don't have to use it.

414
00:28:20,632 --> 00:28:24,850
So let's quickly add birthday

415
00:28:24,930 --> 00:28:28,102
here. Let's see, when is this

416
00:28:28,236 --> 00:28:31,734
person one's birthday? So you'll see the date format is year,

417
00:28:31,772 --> 00:28:35,226
year, month, month, day. But I can then

418
00:28:35,248 --> 00:28:38,650
go change it either with JSON V date format,

419
00:28:39,070 --> 00:28:40,650
let's find the birthday,

420
00:28:42,750 --> 00:28:47,378
or with the built in profql

421
00:28:47,414 --> 00:28:50,462
one called date format, which is they act

422
00:28:50,516 --> 00:28:53,854
exactly the same. So this should change it to

423
00:28:53,892 --> 00:28:55,440
dayday, month, month, year.

424
00:29:02,690 --> 00:29:06,258
Right? So now I've done the date format, and then depending on the

425
00:29:06,264 --> 00:29:09,874
input on where you place it, I've placed mine on the

426
00:29:09,912 --> 00:29:13,566
field, which means that this applies on both inputs

427
00:29:13,598 --> 00:29:17,270
and output. But if you put it on the setter, it'll only apply

428
00:29:17,340 --> 00:29:20,070
on the input and on the getter only on the output.

429
00:29:20,490 --> 00:29:23,494
One of the more complex things that you can do is if you look here,

430
00:29:23,532 --> 00:29:27,706
you'll red hat. Email is

431
00:29:27,728 --> 00:29:31,900
actually a complex object here in this system.

432
00:29:32,590 --> 00:29:37,482
And you

433
00:29:37,536 --> 00:29:41,066
know that this can be represented as a string. So what

434
00:29:41,088 --> 00:29:44,686
you want to do is if I just show you this at the

435
00:29:44,708 --> 00:29:48,510
moment, if I want to see email, because it's a complex object,

436
00:29:48,580 --> 00:29:52,306
I need to actually get the value back, right. And I know that even

437
00:29:52,328 --> 00:29:55,982
though it's a complex object in graphQl, I want to represent it as a string.

438
00:29:56,126 --> 00:29:59,170
So what I can do is I can then here say

439
00:29:59,320 --> 00:30:03,250
add to scholar

440
00:30:03,830 --> 00:30:05,590
and then make it a string.

441
00:30:06,810 --> 00:30:10,840
Now, there's some default rules in how it determines how to do this.

442
00:30:11,930 --> 00:30:15,526
For marshalling to string, it will just use two string. So you

443
00:30:15,548 --> 00:30:19,558
need to make sure that your two string is implemented for creating

444
00:30:19,734 --> 00:30:22,330
an input from a string.

445
00:30:22,910 --> 00:30:26,282
It will go and see if there's a constructor or a

446
00:30:26,336 --> 00:30:30,222
set value or whatever the field is to

447
00:30:30,356 --> 00:30:32,000
reconstruct this object.

448
00:30:33,250 --> 00:30:36,798
Right. So now this will be invalid because that's not a

449
00:30:36,804 --> 00:30:39,840
complex object anymore. Wait, I didn't save,

450
00:30:40,870 --> 00:30:41,620
um,

451
00:30:45,510 --> 00:30:49,522
so you can see there already it says email and doesn't have a subfield because

452
00:30:49,576 --> 00:30:53,620
we've now made it a string. Right? So that's that,

453
00:30:55,130 --> 00:30:55,880
right.

454
00:30:57,610 --> 00:31:01,846
So we

455
00:31:01,868 --> 00:31:05,174
have looked at errors, we have looked

456
00:31:05,212 --> 00:31:08,870
at transformation and mapping. Next, I want to talk about mutations.

457
00:31:08,950 --> 00:31:12,502
Now, mutation. Up until now we've only query

458
00:31:12,566 --> 00:31:16,374
data. Mutations is basically the rest of the crud

459
00:31:16,422 --> 00:31:20,426
operations. When data is going to change, it mutates.

460
00:31:20,618 --> 00:31:24,126
So that's basically we

461
00:31:24,148 --> 00:31:27,486
want to add a person or delete a person or update a

462
00:31:27,508 --> 00:31:31,170
person. And that's very straightforward to do.

463
00:31:31,240 --> 00:31:35,794
Let's go to our graphql endpoint and

464
00:31:35,912 --> 00:31:39,634
add this. So it's basically just

465
00:31:39,672 --> 00:31:43,830
a new annotation to say mutation. It always also

466
00:31:43,900 --> 00:31:47,362
returns a person, which means the result of a mutation

467
00:31:47,426 --> 00:31:49,480
is also a queryable result.

468
00:31:51,210 --> 00:31:55,126
So as an example, let's see if this works. I'm going to

469
00:31:55,148 --> 00:31:58,860
create a person. This might not work and then

470
00:31:59,390 --> 00:32:01,100
I'll explain why not.

471
00:32:04,270 --> 00:32:07,510
Yeah, schema is not configured for mutations,

472
00:32:07,590 --> 00:32:09,420
so I'll just restart again.

473
00:32:11,550 --> 00:32:12,330
Um,

474
00:32:17,330 --> 00:32:20,720
the hot reload, for some reason, doesn't pick this up.

475
00:32:22,610 --> 00:32:26,882
It used to, but you'll see that the hot reload now

476
00:32:27,016 --> 00:32:31,234
did some clever footwork around class paths. And for some reason this

477
00:32:31,272 --> 00:32:34,854
isn't picked up. So that's something that we need to fix in caucus. It's hot

478
00:32:34,892 --> 00:32:35,830
reloading,

479
00:32:38,650 --> 00:32:42,582
but anyway, so you can see here, I'm basically, again just calling the back end

480
00:32:42,636 --> 00:32:46,690
person service with an object. So what I'll do now with mutations

481
00:32:46,770 --> 00:32:50,246
is I'm basically saying update the person and I

482
00:32:50,268 --> 00:32:53,526
give it a name. And because I didn't give it an id it will generate

483
00:32:53,558 --> 00:32:56,922
a new one because it's ot generated id. And then I'm asking

484
00:32:56,976 --> 00:33:00,702
back for this fields which I should only get name and id

485
00:33:00,756 --> 00:33:03,790
back because um,

486
00:33:07,410 --> 00:33:11,570
did I not save? So maybe the whole reload was working

487
00:33:11,640 --> 00:33:15,780
actually and I just didn't save.

488
00:33:18,710 --> 00:33:22,020
Yeah, so this is the other error that I knew about.

489
00:33:22,790 --> 00:33:26,246
So what's happening there is that I didn't set up my

490
00:33:26,268 --> 00:33:29,462
postgres properly. So when I insert the initial test

491
00:33:29,516 --> 00:33:33,122
data I didn't know what the next id is. So I get this duplication

492
00:33:33,186 --> 00:33:36,682
error and I didn't bother to fix it. But bottom

493
00:33:36,736 --> 00:33:39,578
line is this is how I can create a person.

494
00:33:39,664 --> 00:33:43,740
You can see now that I got the id from the

495
00:33:44,270 --> 00:33:47,466
database that's degenerated and

496
00:33:47,488 --> 00:33:51,290
then all of this is still set to null because I haven't

497
00:33:51,370 --> 00:33:54,574
created those yet. But again this is queryable what I

498
00:33:54,612 --> 00:33:57,920
ask. So I can now go and update that person.

499
00:34:00,290 --> 00:34:04,210
Now I'll pass in the id because I want to do an update

500
00:34:04,710 --> 00:34:09,010
and then those fields are populated.

501
00:34:09,990 --> 00:34:13,086
And similarly you can do a delete. I'm not going to show a delete,

502
00:34:13,118 --> 00:34:15,750
but you can do the rest of the crowd operations.

503
00:34:17,850 --> 00:34:23,698
Okay, what I want to show next is we'll

504
00:34:23,714 --> 00:34:26,938
quickly do introspection because that's quite fast. And then we'll go on

505
00:34:26,944 --> 00:34:30,570
to security. So introspection is an interesting concept

506
00:34:31,870 --> 00:34:36,534
where I can use graphql

507
00:34:36,662 --> 00:34:39,790
to query graphql's schema.

508
00:34:40,930 --> 00:34:45,306
And again this is because there is a strongly typed schema

509
00:34:45,338 --> 00:34:48,714
available and I can now query that schema

510
00:34:48,762 --> 00:34:52,910
with GraphQl. So I can say get me all the types,

511
00:34:53,910 --> 00:34:57,666
all the names of the types in the schema and then you can get all

512
00:34:57,688 --> 00:35:01,602
the names of the types and similarly you can query whatever

513
00:35:01,656 --> 00:35:04,610
you want about the actual schema document.

514
00:35:04,770 --> 00:35:08,520
That is quite an interesting feature that you have out of the box.

515
00:35:10,490 --> 00:35:12,680
Okay, so let's move on to security.

516
00:35:14,090 --> 00:35:17,446
What I'm going to do is security is

517
00:35:17,468 --> 00:35:20,694
not really part of the GraphQl specification.

518
00:35:20,742 --> 00:35:24,074
It's up to the runtime to implement this. And because we make this

519
00:35:24,112 --> 00:35:27,862
available over HTTP and because this is in Quarkus,

520
00:35:28,006 --> 00:35:31,326
the normal Quarkus security works. What I'm going

521
00:35:31,348 --> 00:35:34,894
to demo is just plain old JWT. So I

522
00:35:34,932 --> 00:35:38,110
have a keyclock server running in the background.

523
00:35:38,930 --> 00:35:43,710
And what I'm going to do is I'm going to say that this roles

524
00:35:43,790 --> 00:35:48,322
allowed roles allowed only

525
00:35:48,376 --> 00:35:50,340
allow employees to do this.

526
00:35:54,010 --> 00:35:58,070
I think it must be okay,

527
00:35:58,220 --> 00:36:02,134
which means if I now go and go back and do a

528
00:36:02,252 --> 00:36:05,480
person id one

529
00:36:07,310 --> 00:36:10,842
and names, I should get an error because

530
00:36:10,896 --> 00:36:14,694
I'm not authorized, right? So unauthorized

531
00:36:14,742 --> 00:36:18,422
exception. So what I'll do now, let me just do

532
00:36:18,576 --> 00:36:22,640
this to show,

533
00:36:23,170 --> 00:36:27,338
so I'll get a fresh token from keycloak

534
00:36:27,514 --> 00:36:31,134
here, and then I'll pass a request header

535
00:36:31,182 --> 00:36:38,930
in a better token, basically copy,

536
00:36:41,590 --> 00:36:45,222
and then I can get the data back. And again, any of the

537
00:36:45,276 --> 00:36:48,678
security models in caucus will work

538
00:36:48,764 --> 00:36:50,870
with GraphQl.

539
00:36:52,730 --> 00:36:56,122
Okay, let me remove this because this can get

540
00:36:56,176 --> 00:36:59,100
quite annoying. And remove this.

541
00:37:00,430 --> 00:37:04,870
So that's securing your endpoints.

542
00:37:04,950 --> 00:37:09,658
And by the way, I'm not going to show that, but you

543
00:37:09,664 --> 00:37:13,486
can add security or different role around this message and

544
00:37:13,508 --> 00:37:16,926
then you will get a partial result back if your user is

545
00:37:16,948 --> 00:37:19,918
not in that role. Okay,

546
00:37:20,004 --> 00:37:23,422
next I want to show context.

547
00:37:23,486 --> 00:37:27,902
Now, context allows you to inject

548
00:37:27,966 --> 00:37:32,226
the context of this query anywhere in

549
00:37:32,248 --> 00:37:35,702
your code. And this is useful if you look at our back end

550
00:37:35,756 --> 00:37:39,734
as an example, our person service and

551
00:37:39,772 --> 00:37:43,858
this service is making calls to a database.

552
00:37:44,034 --> 00:37:47,350
And I can now go and inject this context.

553
00:37:47,510 --> 00:37:51,050
And this context gives me all

554
00:37:51,120 --> 00:37:54,780
sorts of things like the actual request, the query, the name,

555
00:37:55,150 --> 00:37:59,120
the variables, and a whole lot more

556
00:38:00,130 --> 00:38:04,446
things about the original request. Which means at

557
00:38:04,468 --> 00:38:07,902
the moment when I do find person, the database still

558
00:38:07,956 --> 00:38:11,102
returns all the fields on that person.

559
00:38:11,156 --> 00:38:14,674
It's only after it came from the database that we filter out only

560
00:38:14,712 --> 00:38:18,050
the fields that should go over the network to the client.

561
00:38:18,630 --> 00:38:22,546
But this will allow you to inspect the original request and do

562
00:38:22,568 --> 00:38:25,686
a better query on the back end. So the one

563
00:38:25,708 --> 00:38:29,654
way is to do this, so inject it. The other way is

564
00:38:29,692 --> 00:38:33,910
to use events. Now there's quite a few events that gets fired

565
00:38:35,530 --> 00:38:39,098
both during startup. So as we build your schema, there's a

566
00:38:39,104 --> 00:38:42,854
bunch of events that allows you to take part in that building of the schema.

567
00:38:42,982 --> 00:38:46,474
And then there's events like this one where just before we

568
00:38:46,512 --> 00:38:50,378
execute, we will call this event

569
00:38:50,464 --> 00:38:53,834
and you can take part in that thing basically to say at observe.

570
00:38:53,882 --> 00:38:57,646
And then you can get the context. As you can see here,

571
00:38:57,828 --> 00:39:02,850
there's all sorts of hooks where you can hook into this execution.

572
00:39:04,070 --> 00:39:07,934
So let's see if this works. I might have to restart

573
00:39:07,982 --> 00:39:08,580
again,

574
00:39:13,190 --> 00:39:17,534
right? So let's

575
00:39:17,582 --> 00:39:18,680
just do this.

576
00:39:21,290 --> 00:39:24,774
So here you can see that I've got the context and

577
00:39:24,812 --> 00:39:28,570
I'm just printing out the query, but already I can see that only

578
00:39:28,640 --> 00:39:33,274
names has been asked, which means I can actually optimize my

579
00:39:33,312 --> 00:39:36,810
back end query. And that's the idea of the context.

580
00:39:38,770 --> 00:39:41,898
Okay, the next thing I want to show is custom execution.

581
00:39:41,994 --> 00:39:46,174
So up

582
00:39:46,212 --> 00:39:50,094
until now we basically allow execution based on

583
00:39:50,132 --> 00:39:53,646
this methods which will serve incoming traffic

584
00:39:53,678 --> 00:39:57,860
over HTTP. But you might be in a situation where you want to

585
00:39:58,470 --> 00:40:02,802
do a graphql query on startup or on

586
00:40:02,856 --> 00:40:06,340
some schedule or just programmatically for some other reason.

587
00:40:07,450 --> 00:40:11,414
In my example I have this use case that I'm saying

588
00:40:11,452 --> 00:40:15,046
that every morning I want to do a query to find all the scores so

589
00:40:15,068 --> 00:40:18,506
that I can send out a mail to send the leaderboard out as an

590
00:40:18,528 --> 00:40:24,474
example. So I have this leaderboard service which

591
00:40:24,512 --> 00:40:28,322
is running on a schedule. So what you can do is you can inject

592
00:40:28,486 --> 00:40:31,774
an execution service right this one

593
00:40:31,812 --> 00:40:35,262
here, and then that gives you access to the actual service that's being called.

594
00:40:35,316 --> 00:40:39,486
That's the same service that the

595
00:40:39,508 --> 00:40:42,786
web request will call. So the only difference now is

596
00:40:42,808 --> 00:40:46,900
that you build up your own query in here and then

597
00:40:47,830 --> 00:40:51,620
this should make the call. So to test that,

598
00:40:52,390 --> 00:40:55,586
in fact it should already run now because it'll run on startup.

599
00:40:55,618 --> 00:41:00,086
But let's clear the lock so you can actually in

600
00:41:00,108 --> 00:41:03,986
Dev Ui you can trigger a schedule so I can invoke

601
00:41:04,018 --> 00:41:07,420
it and then you can see there I have printed out

602
00:41:07,950 --> 00:41:10,490
what that execution service executed.

603
00:41:13,710 --> 00:41:16,950
Okay, so that is custom execution.

604
00:41:17,030 --> 00:41:20,762
We have quite a lot of integrations already with microprof on GraphQl

605
00:41:20,826 --> 00:41:25,002
JSONB. I've shown a little bit when we used the date format, but properties

606
00:41:25,066 --> 00:41:28,574
and hiding elements and all the other JSON B properties is

607
00:41:28,612 --> 00:41:32,074
supported security. I've shown how we've integrated that context.

608
00:41:32,122 --> 00:41:35,870
I've shown how we can pass this context along using context propagation.

609
00:41:35,950 --> 00:41:39,758
What I didn't show is beam validation. So you can mark either your pojos

610
00:41:39,854 --> 00:41:43,106
and or your method signatures with beam validation and that will

611
00:41:43,128 --> 00:41:47,570
apply, throw a normal error which could result in partial responses.

612
00:41:47,650 --> 00:41:51,254
We've also integrated with metrics and tracing and both of those

613
00:41:51,292 --> 00:41:55,014
you don't have to do anything but include the extension in

614
00:41:55,052 --> 00:41:59,414
your application. And then by default we will start emitting metrics

615
00:41:59,542 --> 00:42:03,398
and trace requests and then genetic support. Your methods

616
00:42:03,414 --> 00:42:06,874
can use genetics and that will work. That brings us to the last part of

617
00:42:06,912 --> 00:42:10,346
this, and that is what's in the pipeline. So what are we

618
00:42:10,368 --> 00:42:13,674
working on at the moment? So we are nearly ready with a client,

619
00:42:13,722 --> 00:42:16,858
or the client is actually already ready, but pulling them into caucus.

620
00:42:16,954 --> 00:42:20,574
So this is not the execution service injection like I've shown here.

621
00:42:20,612 --> 00:42:23,962
That gives you on the server side access to the execution service.

622
00:42:24,036 --> 00:42:27,346
This is a proper client which allows you to make calls from

623
00:42:27,368 --> 00:42:31,774
a client that will make a call over HTTP. There are two variants

624
00:42:31,822 --> 00:42:35,662
of this client that we're pulling. One is similar to the JAX

625
00:42:35,726 --> 00:42:39,154
Rs client that uses this. We call it the dynamic

626
00:42:39,202 --> 00:42:42,914
client and it allows this builder pattern to build a query

627
00:42:42,962 --> 00:42:46,230
up. And the other one is a typesave client, which is similar to

628
00:42:46,380 --> 00:42:50,026
rest client in microprofile. So that's a typesave one where

629
00:42:50,048 --> 00:42:53,370
you define the objects. Red hat will make the call. The other interesting

630
00:42:53,440 --> 00:42:57,334
thing we're working on is subscriptions, which is one of the outstanding

631
00:42:57,382 --> 00:43:01,482
features that the GraphQL specification has. So graphQl specification

632
00:43:01,546 --> 00:43:05,002
on a high level have queries, mutations, and then subscriptions.

633
00:43:05,066 --> 00:43:09,086
And subscriptions is basically it allows you to subscribe to

634
00:43:09,108 --> 00:43:12,654
a query, you get push notifications as this

635
00:43:12,692 --> 00:43:16,014
query, as data comes in that match that query. We are busy

636
00:43:16,062 --> 00:43:19,586
implementing it over websockets in caucus. Red Hat hopefully will

637
00:43:19,608 --> 00:43:23,106
be available pretty soon. And then one of the other things that's high on our

638
00:43:23,128 --> 00:43:26,546
priority list is to make paging and filtering easier. So at

639
00:43:26,568 --> 00:43:30,006
the moment, if you want to do paging of big payloads, you will have

640
00:43:30,028 --> 00:43:33,158
to code it in yourself with defining the page number

641
00:43:33,244 --> 00:43:36,882
and number of pages that you want to turn and so on as parameters.

642
00:43:36,946 --> 00:43:40,214
But we want to make that easier by just allowing like at

643
00:43:40,252 --> 00:43:43,926
paging or at filtering type annotation. And that is

644
00:43:43,948 --> 00:43:47,494
it for me. I know it was very fast.

645
00:43:47,612 --> 00:43:51,530
So what I've shown is made up of these two examples,

646
00:43:51,610 --> 00:43:55,022
and this examples contain even more things that I didn't show.

647
00:43:55,156 --> 00:43:58,126
But you can go and have a look there, reach out to me, find me

648
00:43:58,148 --> 00:44:00,798
on the Internet, and if you have any questions.

649
00:44:00,964 --> 00:44:03,100
And that's it. Thank you very much.

