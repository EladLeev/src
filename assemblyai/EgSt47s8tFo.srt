1
00:00:25,410 --> 00:00:28,806
You. Hi folks, thanks to be

2
00:00:28,828 --> 00:00:31,842
here for this talk about from imperative to reactive.

3
00:00:31,906 --> 00:00:35,910
I am Nicola Frankel. I've been working in it for 20

4
00:00:35,980 --> 00:00:40,114
years in technical roles and since a couple of years I'm a developer

5
00:00:40,162 --> 00:00:43,682
advocate. I must mention that I'm not a reactive guru,

6
00:00:43,826 --> 00:00:47,480
so this is not a deep dive. It's just like

7
00:00:48,250 --> 00:00:52,458
a gentle introduction. How you could migrate to reactive?

8
00:00:52,634 --> 00:00:56,602
I work for a company called Hazelcast. If you are a Java developer,

9
00:00:56,666 --> 00:01:00,414
you might have heard about Hazelcast. We have two products. The first one

10
00:01:00,452 --> 00:01:03,674
is an in memory data grid, and you can think about an in memory

11
00:01:03,722 --> 00:01:07,186
data grid as distributed data structures. So you

12
00:01:07,208 --> 00:01:11,214
can replicate or short your data over several

13
00:01:11,262 --> 00:01:14,686
nodes in the cluster. And the other one is Haslko's

14
00:01:14,718 --> 00:01:18,082
jet and it allows to do stream processing in memory.

15
00:01:18,146 --> 00:01:22,470
So very, very fast. Today I will talk boot

16
00:01:22,620 --> 00:01:26,902
reactive and reactive well, like officially started

17
00:01:27,036 --> 00:01:30,934
in 2014 with the reactive manifesto. And the reactive

18
00:01:30,982 --> 00:01:35,478
manifesto lets four properties of a system to be considered

19
00:01:35,574 --> 00:01:38,950
reactive. The first one must be responsive,

20
00:01:39,030 --> 00:01:43,802
so when you request the system, it responds

21
00:01:43,946 --> 00:01:47,454
as fast as possible. And well, you shouldn't wait too much

22
00:01:47,492 --> 00:01:50,654
until you get your response. The second, it must

23
00:01:50,692 --> 00:01:54,414
be resilient, so even if some components

24
00:01:54,542 --> 00:01:57,922
fail, it should still be working.

25
00:01:58,056 --> 00:02:01,522
The third one is it must be elastic. So if you

26
00:02:01,576 --> 00:02:05,118
increase the cloud, it will probably act

27
00:02:05,224 --> 00:02:09,014
slower but not stop working at all. And in my

28
00:02:09,052 --> 00:02:13,058
opinion, the most important characteristic is it's message driven.

29
00:02:13,154 --> 00:02:16,854
Meaning that it's only based by

30
00:02:16,972 --> 00:02:20,218
not directly calling an object,

31
00:02:20,304 --> 00:02:24,134
but by passing a message. So it's asynchronous.

32
00:02:24,262 --> 00:02:28,250
You send a message and you expect the

33
00:02:28,320 --> 00:02:32,106
response at some time, you just don't know how. Meaning it's

34
00:02:32,138 --> 00:02:35,854
not blocking. And the

35
00:02:35,892 --> 00:02:39,866
fun part is that it had in mind the actor

36
00:02:39,898 --> 00:02:43,794
model. The actor model has been popularized by the Lang or

37
00:02:43,832 --> 00:02:47,506
OTP platform. And the idea behind the platform is

38
00:02:47,528 --> 00:02:51,122
that you don't create object

39
00:02:51,256 --> 00:02:54,954
and make calls like direct method

40
00:02:55,022 --> 00:02:58,838
calls to the other object. You just get a reference on

41
00:02:58,924 --> 00:03:02,886
another object and you send messages and it's up

42
00:03:02,988 --> 00:03:06,534
to the actor that received the message to

43
00:03:06,572 --> 00:03:10,518
handle it. Of course, bit has a queue, a mailbox of messages,

44
00:03:10,614 --> 00:03:14,362
it can process them in order. But the most important fact

45
00:03:14,416 --> 00:03:18,570
is you don't access the states

46
00:03:18,720 --> 00:03:22,522
of another object. So every actor has its own

47
00:03:22,576 --> 00:03:26,670
state, it's strongly encapsulated, you just pass

48
00:03:26,740 --> 00:03:30,862
messages. And of course, if you need data, you expect data

49
00:03:30,996 --> 00:03:34,078
to be in the message or in the response

50
00:03:34,094 --> 00:03:38,078
to the message. And well, on the OTP platform it's

51
00:03:38,094 --> 00:03:41,780
the de facto standard because it's backed into the platform.

52
00:03:42,230 --> 00:03:46,518
But in the Java world it didn't work like this.

53
00:03:46,604 --> 00:03:50,658
Although the people behind the reactive manifesto were mainly

54
00:03:50,754 --> 00:03:54,374
working for on ACA or for

55
00:03:54,412 --> 00:03:57,810
lightband, the company behind hacka that models

56
00:03:57,890 --> 00:04:01,202
the actor system on the TVM,

57
00:04:01,266 --> 00:04:05,922
well it didn't work out so well. I mean ACA is still popular

58
00:04:06,066 --> 00:04:09,442
library, but it's right now not the most popular

59
00:04:09,506 --> 00:04:13,134
library. The stuff that the

60
00:04:13,172 --> 00:04:17,166
industry sets its eyes on is reactivestream and

61
00:04:17,188 --> 00:04:20,542
this is the definition of reactive stream. So I let you read,

62
00:04:20,596 --> 00:04:24,062
you can find the website just below the idea

63
00:04:24,116 --> 00:04:27,698
behind Reactivestream. We still have like this message

64
00:04:27,784 --> 00:04:30,930
queue, but we have a single event loop that's important,

65
00:04:31,000 --> 00:04:34,754
a single event loop that will process the messages and dispatch them

66
00:04:34,792 --> 00:04:38,230
to the correct event handler. And this event

67
00:04:38,300 --> 00:04:42,614
loop is run by a single threat, meaning that when

68
00:04:42,652 --> 00:04:46,342
it passes the message, what it does should never

69
00:04:46,476 --> 00:04:50,010
block. Because if you block this event loop until

70
00:04:50,160 --> 00:04:54,074
some long running process is done, then you are blocking all

71
00:04:54,112 --> 00:04:57,226
the messages, all the events that arrive in the

72
00:04:57,248 --> 00:05:00,986
queue and you are stopping your system. So that's

73
00:05:01,018 --> 00:05:04,446
very, very important. Non blocking is at the

74
00:05:04,468 --> 00:05:07,626
roots of reactive and reactive streams.

75
00:05:07,738 --> 00:05:11,130
There are probably good reasons to go reactives.

76
00:05:11,210 --> 00:05:14,962
There are not so good reasons. So I want

77
00:05:15,016 --> 00:05:18,270
just to mention two. The first one is scalability

78
00:05:18,430 --> 00:05:22,718
and the idea behind the proponents of reactive. For scalability

79
00:05:22,814 --> 00:05:26,614
say, hey, like now we normally in

80
00:05:26,652 --> 00:05:30,406
a normal Tomcat or jetty, when you

81
00:05:30,428 --> 00:05:33,698
receive a request, then the application server

82
00:05:33,794 --> 00:05:38,146
will spin on a thread and it will be the thread responsibility

83
00:05:38,258 --> 00:05:41,366
to handle the whole request response chain.

84
00:05:41,478 --> 00:05:44,998
And it works pretty well until you hit the limits.

85
00:05:45,094 --> 00:05:48,810
Might be 10,000, might be 1000, I don't know exactly.

86
00:05:48,880 --> 00:05:52,374
But at some point you will reach the limits and you cannot scale

87
00:05:52,422 --> 00:05:56,254
anymore. And proponents of reactive say, hey, in order

88
00:05:56,292 --> 00:05:59,898
to be web scale you need to be reactive. I think that's

89
00:05:59,914 --> 00:06:03,710
the wrong reason. The reason why this is the wrong reason is

90
00:06:03,860 --> 00:06:07,634
because most of our application don't need to be web scale. We are not

91
00:06:07,672 --> 00:06:11,506
Google, we are not Facebook, we are not Amazon. Of course

92
00:06:11,688 --> 00:06:15,346
I wish every one of your application was to

93
00:06:15,368 --> 00:06:18,854
be that successful. And at one point in time you

94
00:06:18,892 --> 00:06:22,466
might want to migrate to this model. But unless you've

95
00:06:22,498 --> 00:06:26,066
got this load, it's just like an additional

96
00:06:26,258 --> 00:06:29,818
craft on your application and on the next slide I will tell

97
00:06:29,824 --> 00:06:33,414
you about. Yeah, because also reactive has downside,

98
00:06:33,462 --> 00:06:37,706
I will let you know about them. So forget scalability. Like for

99
00:06:37,808 --> 00:06:41,378
most of our loads it's probably enough to have non reactive

100
00:06:41,414 --> 00:06:44,830
system. However, I think that there is quite good reason

101
00:06:44,900 --> 00:06:48,254
to go reactive. It's to be cloud friendly like if

102
00:06:48,292 --> 00:06:51,678
you have an on premise hardware, you are

103
00:06:51,684 --> 00:06:55,090
not optimizing your software, you are just

104
00:06:55,240 --> 00:06:58,738
probably over consuming resources. And that's fine. You don't care.

105
00:06:58,824 --> 00:07:02,366
You might waste cpu cycles, you might waste

106
00:07:02,398 --> 00:07:05,586
memory, you might even waste storage. That's not an issue.

107
00:07:05,688 --> 00:07:08,806
I mean the hardware has been bought, it's fine.

108
00:07:08,908 --> 00:07:12,502
Now if you want to migrate to the cloud, you will be paying for everything

109
00:07:12,636 --> 00:07:16,374
and you will be billed on cpu usage, memory consumption and

110
00:07:16,412 --> 00:07:20,762
storage usage. So the idea in then that

111
00:07:20,896 --> 00:07:24,694
if you block, you're just wasting cpu cycle,

112
00:07:24,822 --> 00:07:28,554
you shouldn't do that. So in order to optimize your

113
00:07:28,672 --> 00:07:32,078
monthly bill, then going reactive is a good idea

114
00:07:32,164 --> 00:07:36,046
in all cases. Whether you have good reasons or

115
00:07:36,068 --> 00:07:39,406
bad reasons, you are curious about reactive. You must consider

116
00:07:39,508 --> 00:07:42,442
also the downside, because as developers,

117
00:07:42,586 --> 00:07:45,330
as architects, well, we must make a trade off.

118
00:07:45,400 --> 00:07:48,834
So the first, like the biggest downside of reactive is

119
00:07:48,872 --> 00:07:52,402
to understand that hey, when I make a

120
00:07:52,456 --> 00:07:55,958
function call, I'm not actually calling the function,

121
00:07:56,044 --> 00:07:59,762
I'm just subscribing to the response

122
00:07:59,826 --> 00:08:03,062
that I will get later, or I hope I will get later.

123
00:08:03,196 --> 00:08:06,518
And that makes it hard to reason about.

124
00:08:06,684 --> 00:08:10,070
When you look at reactive code, you must replace

125
00:08:10,150 --> 00:08:13,318
all those function or method calls

126
00:08:13,494 --> 00:08:17,734
by subscribing. Of course real developers,

127
00:08:17,782 --> 00:08:21,938
they don't debug, they don't need debugging. But I'm not a real developer

128
00:08:22,054 --> 00:08:25,486
and I find myself very often in the need of

129
00:08:25,508 --> 00:08:28,874
debugging. And in that case, debugging reactive

130
00:08:28,922 --> 00:08:31,946
code is much harder because in normal

131
00:08:31,978 --> 00:08:35,982
code, when you have a single thread that handle the whole request

132
00:08:36,046 --> 00:08:39,506
response chain, you set a breakpoint and you can go back

133
00:08:39,608 --> 00:08:43,138
in time to see, hey, this was called with this object

134
00:08:43,224 --> 00:08:46,902
on the stack with this state. And I can understand why

135
00:08:46,956 --> 00:08:51,138
now I have this. But with reactive codes,

136
00:08:51,234 --> 00:08:54,886
well, the thread might have switched, you don't know, so you

137
00:08:54,908 --> 00:08:58,166
might lose important bits of data. Of course, the tools that are

138
00:08:58,188 --> 00:09:01,642
getting better and better now, it still might be an issue

139
00:09:01,696 --> 00:09:05,562
depending on your tools. The third point that I need to mention is

140
00:09:05,616 --> 00:09:08,150
now you need to learn specific APIs.

141
00:09:08,310 --> 00:09:11,758
It's not the GDK anymore, it's not the

142
00:09:11,764 --> 00:09:16,298
servlet API anymore. It's like dedicated API.

143
00:09:16,394 --> 00:09:19,626
And of course there are several reactive frameworks,

144
00:09:19,658 --> 00:09:22,490
several reactive APIs. They look similar,

145
00:09:22,660 --> 00:09:26,654
they probably don't use the same method names.

146
00:09:26,782 --> 00:09:29,986
And even if they might do the same, there might

147
00:09:30,008 --> 00:09:33,426
be some slightly different semantics from one to the

148
00:09:33,448 --> 00:09:37,554
other. So it might be a problem when I

149
00:09:37,592 --> 00:09:41,330
have a question. Generally I ask my favorite reactive guru

150
00:09:41,410 --> 00:09:44,006
and I tell him, hey, I want to do this and this, and this.

151
00:09:44,028 --> 00:09:47,000
And say, hey, you should use this method, okay?

152
00:09:48,090 --> 00:09:51,882
It's quite a dedicated world. And last but not least,

153
00:09:52,016 --> 00:09:54,822
if you want your application to be reactive,

154
00:09:54,966 --> 00:09:58,630
everything in the request response chain must be reactive.

155
00:09:58,710 --> 00:10:02,606
If in the middle anywhere you have a single blocking call,

156
00:10:02,708 --> 00:10:05,822
well, the chain is not reactive anymore. So we must be very,

157
00:10:05,876 --> 00:10:09,146
very careful about not introducing blocking

158
00:10:09,178 --> 00:10:12,846
API call in our application and in the demo,

159
00:10:12,948 --> 00:10:16,862
I will show you how we can do that. This is the reactive streams API.

160
00:10:16,926 --> 00:10:21,278
Right now, as you can see, it's quite simple. You have a publisher,

161
00:10:21,374 --> 00:10:24,706
publisher subscribes to a subscriber and

162
00:10:24,728 --> 00:10:28,870
the subscriber is the one that reacts. So basically,

163
00:10:29,020 --> 00:10:32,850
hey, you can react when you first subscribe, you can react

164
00:10:32,930 --> 00:10:36,726
when you get an item, you can react when you get an error. And finally,

165
00:10:36,828 --> 00:10:40,730
if the stream finishes, which most of the time we want it to be

166
00:10:40,800 --> 00:10:44,586
successfully, you can do something when we do that. And also,

167
00:10:44,688 --> 00:10:48,022
you can also see here the subscription,

168
00:10:48,086 --> 00:10:52,378
you can see the back pressure baked in. Like the subscription interface

169
00:10:52,474 --> 00:10:56,014
has a method called request. So you can ask for hey,

170
00:10:56,052 --> 00:10:59,822
I want x items. You process the subs and then you can

171
00:10:59,876 --> 00:11:03,354
a I want x more items. And so that's very good

172
00:11:03,412 --> 00:11:07,262
because it means that your subscriber is not overflown

173
00:11:07,326 --> 00:11:11,150
with too much data. So if you have a very fast producing

174
00:11:11,230 --> 00:11:15,086
publisher and a slow consuming subscriber, you can handle

175
00:11:15,118 --> 00:11:18,646
that well, you will need to deal with the data anyway,

176
00:11:18,748 --> 00:11:22,198
but you won't bring your subscriber to its knees. And finally,

177
00:11:22,284 --> 00:11:25,720
we have the processor, and because we will be

178
00:11:26,250 --> 00:11:29,654
subscribing, and we will be subscribing in

179
00:11:29,692 --> 00:11:33,466
steps, so every item in the chain will be subscribing to

180
00:11:33,488 --> 00:11:36,860
a parent. We need a way to chain them together.

181
00:11:37,230 --> 00:11:41,110
So we have the processor, which is both a publisher and a subscriber.

182
00:11:41,190 --> 00:11:45,722
Now, in the Java world, as I mentioned, there are several reactive

183
00:11:45,786 --> 00:11:49,402
frameworks. I want just to mention today, Project Reactor,

184
00:11:49,466 --> 00:11:53,390
we have erics, but I want to mention Project Reactor because

185
00:11:53,460 --> 00:11:56,946
I will be using it in demo and it's pretty popular as

186
00:11:56,968 --> 00:12:00,638
well, especially in the spring framework. And the demo is based on spring

187
00:12:00,654 --> 00:12:04,050
boot. So project Reactor just builds upon those

188
00:12:04,120 --> 00:12:07,842
four small building blocks and it adds more abstractions.

189
00:12:07,906 --> 00:12:12,210
For example, it provides from the publisher two different abstractions,

190
00:12:12,290 --> 00:12:15,606
the flux, which can produce zero till like

191
00:12:15,708 --> 00:12:19,514
store items, and the mono, which can produce zero or one

192
00:12:19,552 --> 00:12:23,510
item. Just to mention that bit has no dependency on spring.

193
00:12:23,590 --> 00:12:27,402
On the opposite, spring depends on Project Reactor. So you could

194
00:12:27,456 --> 00:12:30,586
use Project Reactor without spring with no issues.

195
00:12:30,688 --> 00:12:34,126
You might have heard also about the GDK nine

196
00:12:34,228 --> 00:12:37,626
flow class. And if you look at the GDK nine flow

197
00:12:37,658 --> 00:12:41,530
class, you will notice that it all has the same building blocks

198
00:12:41,610 --> 00:12:44,974
as I mentioned in reactive streams. So it has the publisher,

199
00:12:45,022 --> 00:12:47,918
it has the subscriber, the subscription and the processor.

200
00:12:48,014 --> 00:12:51,186
All are like nested interfaces of the

201
00:12:51,208 --> 00:12:54,530
flow class. And why? Well,

202
00:12:54,600 --> 00:12:58,086
project reactor probably was designed just around the

203
00:12:58,108 --> 00:13:01,702
time that GDK nine was going to happen, and so

204
00:13:01,756 --> 00:13:04,982
they provided their own. And now GDK nine

205
00:13:05,036 --> 00:13:08,722
now also has the same building blocks. So on the reactive

206
00:13:08,786 --> 00:13:12,010
stream site you will see this funny quote that

207
00:13:12,080 --> 00:13:16,166
hey, we will migrating and there will be a migration period

208
00:13:16,278 --> 00:13:19,674
and we will migrate to GdK nine flow at some point. Well,

209
00:13:19,712 --> 00:13:23,518
Gdk nine is 2017 and four years later

210
00:13:23,604 --> 00:13:27,022
we still have no usage of this flow class.

211
00:13:27,156 --> 00:13:30,858
Now if you want to bridge between the Tideca classes

212
00:13:30,954 --> 00:13:34,682
and reactive streams, you have this flow adapter class

213
00:13:34,756 --> 00:13:37,906
that lets you go back and forth. So it's an

214
00:13:37,928 --> 00:13:41,966
adapter class. So you can still work with that in the spring realm.

215
00:13:42,078 --> 00:13:45,266
Like the legacy way, the usual way. The way

216
00:13:45,288 --> 00:13:49,266
I learned if you wanted to do web application was to use spring

217
00:13:49,298 --> 00:13:53,286
framework webmdc. Now with version five we

218
00:13:53,308 --> 00:13:57,026
have a new component called Spring Webflox and this spring

219
00:13:57,058 --> 00:14:00,186
webflox uses reactive types and they are

220
00:14:00,208 --> 00:14:03,590
all located in this web reactive package.

221
00:14:03,750 --> 00:14:07,466
Now how can we like from a very pragmatic point of

222
00:14:07,488 --> 00:14:11,034
view, can we migrating our code? So with spring

223
00:14:11,082 --> 00:14:14,874
MVC, the usual way to configure

224
00:14:14,922 --> 00:14:18,974
your application was to create controllers and to annotate with a

225
00:14:19,012 --> 00:14:22,362
controller or rest controller. Then you have mappings.

226
00:14:22,426 --> 00:14:25,778
Then you probably use get mappings or post mappings or whatever.

227
00:14:25,864 --> 00:14:29,586
So the usual way. The first way was and patience in

228
00:14:29,608 --> 00:14:33,234
the previous year. I think with spring framework five

229
00:14:33,352 --> 00:14:37,062
there is something called Spring MVC FN so bit

230
00:14:37,116 --> 00:14:41,522
makes you able to write spring MVC configuration

231
00:14:41,666 --> 00:14:44,918
with a functional API. Why? Well,

232
00:14:45,084 --> 00:14:48,858
the reason is Spring Webflox. Actually spring Webflox started

233
00:14:49,024 --> 00:14:53,254
like a new API and if we look at the functional

234
00:14:53,302 --> 00:14:56,954
app of spring Webflox and spring MVC, it's exactly the

235
00:14:56,992 --> 00:15:00,494
same. Also, spring Webflox allows you to

236
00:15:00,532 --> 00:15:04,366
use annotations. So looking like having a

237
00:15:04,388 --> 00:15:08,618
cursory glance at codes from spring

238
00:15:08,714 --> 00:15:12,654
Web, you cannot know really very well until you

239
00:15:12,692 --> 00:15:15,854
look at it into the detail. If it will be managed

240
00:15:15,902 --> 00:15:19,502
by regular spring MVC blocking call like sevlette API

241
00:15:19,566 --> 00:15:22,834
or spring webflox reactive codes, anything is

242
00:15:22,872 --> 00:15:26,946
possible. I believe since most of us have been using spring

243
00:15:26,978 --> 00:15:30,342
MVC with annotations, that it's much

244
00:15:30,476 --> 00:15:34,194
easier to say we will use spring webflox with the functional

245
00:15:34,242 --> 00:15:37,702
app because at least you will know that you must be careful about

246
00:15:37,756 --> 00:15:40,810
it and then just start from there.

247
00:15:40,880 --> 00:15:44,682
So our migration pass will be hey, we will be using first

248
00:15:44,736 --> 00:15:48,026
spring MVC with annotation. That's our starting point.

249
00:15:48,128 --> 00:15:52,102
Then we will migrating to the functional way of using spring

250
00:15:52,166 --> 00:15:55,246
MVC and then it will be just a change of the package to

251
00:15:55,268 --> 00:15:59,098
use spring webflux. I've talked a lot, now let's

252
00:15:59,114 --> 00:16:02,826
do some demo. So now I am in intellij. I have

253
00:16:02,948 --> 00:16:06,462
created project from thought spring

254
00:16:06,526 --> 00:16:10,034
IO and looking at the palm and my head

255
00:16:10,072 --> 00:16:13,554
is just on top but here is the palm. We can see

256
00:16:13,592 --> 00:16:17,170
that. Well as I mentioned it

257
00:16:17,240 --> 00:16:21,586
inherits from spring bootstart apparent. I'm using

258
00:16:21,768 --> 00:16:25,814
not the latest JDk but the latest at the time I created the

259
00:16:25,852 --> 00:16:30,246
project I'm using Springboot starter data GPA. I'm using Springboot

260
00:16:30,278 --> 00:16:34,202
starter web. I will be using also some caching. So because

261
00:16:34,336 --> 00:16:38,154
I am using Springboot starter data GPA I have

262
00:16:38,192 --> 00:16:41,978
a database. So in that case the database is h two which is not a

263
00:16:41,984 --> 00:16:45,610
really great id because this is for demo purpose.

264
00:16:45,690 --> 00:16:49,406
I'm just storing my data in memory. So adding caching in

265
00:16:49,428 --> 00:16:53,600
memory on top of that might not be so a great id. But anyway

266
00:16:54,610 --> 00:16:58,066
it's just for the purpose of the demo I want to add some

267
00:16:58,088 --> 00:17:01,554
caching and the idea would be like to show

268
00:17:01,592 --> 00:17:05,226
you that yeah, we are going away from spring MVC

269
00:17:05,278 --> 00:17:09,570
and at some point we will lose the automatically

270
00:17:09,650 --> 00:17:13,938
configured caching. We will need to add it explicitly.

271
00:17:14,034 --> 00:17:18,054
So I think it's interesting because it's not only unicorns and rainbows,

272
00:17:18,102 --> 00:17:21,882
we need to tackle some problems. And how does it work?

273
00:17:21,936 --> 00:17:25,942
Well, I have this data SQL,

274
00:17:26,006 --> 00:17:29,722
so when I start the application, this file will be read

275
00:17:29,776 --> 00:17:35,598
by spring boot and so it will execute those

276
00:17:35,764 --> 00:17:39,310
statements. And so when I start I will already have

277
00:17:39,460 --> 00:17:43,154
some degree of data into

278
00:17:43,272 --> 00:17:46,638
my application and I have a person controller.

279
00:17:46,734 --> 00:17:50,654
I can ask for all persons that are in the database.

280
00:17:50,782 --> 00:17:54,338
I can ask for a single person and

281
00:17:54,424 --> 00:17:57,730
a person is just a regular entity.

282
00:17:57,810 --> 00:18:01,334
It has like four fields. So nothing mind blowing on this

283
00:18:01,372 --> 00:18:04,950
site. And I'm using the spring data

284
00:18:05,020 --> 00:18:08,266
GPA repository, meaning that I

285
00:18:08,288 --> 00:18:12,154
don't need to write all the sql by myself at

286
00:18:12,192 --> 00:18:16,266
runtime. Spring will do that for me. So I

287
00:18:16,288 --> 00:18:19,370
can query easily, find all and find by id.

288
00:18:19,520 --> 00:18:22,702
It's done for me. So let's start

289
00:18:22,756 --> 00:18:27,642
it and we see spring starting. So here it's

290
00:18:27,706 --> 00:18:31,360
my starting point. I'm using spring MVc and

291
00:18:31,810 --> 00:18:35,378
yes, has Elkata started as well? And something interesting,

292
00:18:35,544 --> 00:18:39,922
I have configured the hibernate statistics because

293
00:18:39,976 --> 00:18:43,262
I want to show you how you can easily cache

294
00:18:43,326 --> 00:18:46,646
your data from the database. So I

295
00:18:46,668 --> 00:18:49,986
will be curling this application curl,

296
00:18:50,178 --> 00:18:54,310
HTTP localhost

297
00:18:54,810 --> 00:18:59,130
80 80 and person and

298
00:18:59,280 --> 00:19:03,482
one. Now I receive my data, which is

299
00:19:03,616 --> 00:19:07,274
Joe Delton. And here in this I

300
00:19:07,312 --> 00:19:10,766
can see that hey, the cache was of course empty and

301
00:19:10,788 --> 00:19:14,862
so there was one cache miss and I did one cache put.

302
00:19:14,916 --> 00:19:17,600
So if I redo it,

303
00:19:18,130 --> 00:19:21,726
if I pass the same query now the cache is hot

304
00:19:21,908 --> 00:19:25,534
and I have a cache bit and so I have no interaction

305
00:19:25,582 --> 00:19:29,394
with the database at all, which is really, really good. And if I

306
00:19:29,432 --> 00:19:30,500
query everything,

307
00:19:33,350 --> 00:19:37,026
every one of those entities will be put in the cache.

308
00:19:37,138 --> 00:19:40,262
So that now here you can see

309
00:19:40,316 --> 00:19:44,306
I have five puts. Now if I query

310
00:19:44,418 --> 00:19:48,380
the second one, which I didn't query individually before,

311
00:19:50,510 --> 00:19:54,186
I have a hit. That's the first step,

312
00:19:54,288 --> 00:19:58,330
that's my starting point. It works and I'm happy about it.

313
00:19:58,480 --> 00:20:02,154
Now the second step is actually to move to,

314
00:20:02,192 --> 00:20:05,870
as I mentioned before, to web MVC FN.

315
00:20:06,450 --> 00:20:09,674
So I will do that. I have everything in git

316
00:20:09,802 --> 00:20:13,462
because it's much easier. I don't need to mistype.

317
00:20:13,626 --> 00:20:17,922
And here you can see that I didn't remove that much

318
00:20:17,976 --> 00:20:21,454
configuration. Now I don't have a controller,

319
00:20:21,502 --> 00:20:24,610
I have something called boot, that's how I called it.

320
00:20:24,680 --> 00:20:28,038
And it's not a controller anymore, it's configuration class.

321
00:20:28,204 --> 00:20:32,040
And my get mappings, I've moved them to

322
00:20:33,210 --> 00:20:36,594
a router function that are annotated with bin.

323
00:20:36,642 --> 00:20:40,182
So every router function will contribute

324
00:20:40,246 --> 00:20:44,810
to the whole roads of the application. And here

325
00:20:44,960 --> 00:20:48,394
you can use this function that

326
00:20:48,432 --> 00:20:52,266
is provided to you by rotor functions and you

327
00:20:52,288 --> 00:20:55,806
say hey, I want to use the get method and the mapping is person.

328
00:20:55,988 --> 00:20:59,498
And then here you pass a function and that's

329
00:20:59,514 --> 00:21:02,970
the reason why it's called functional web Mvc

330
00:21:03,050 --> 00:21:07,138
fn is because here you pass a function that

331
00:21:07,304 --> 00:21:10,926
accepts a request and that returns a response.

332
00:21:11,038 --> 00:21:14,900
And you can think about a web server like a function.

333
00:21:15,290 --> 00:21:18,902
It accepts like data and

334
00:21:18,956 --> 00:21:22,246
it returns other data. It accepts data in

335
00:21:22,268 --> 00:21:26,150
the form of a HTTP request and bit returns data

336
00:21:26,220 --> 00:21:30,426
in the form of HTTP response. And here this

337
00:21:30,608 --> 00:21:33,834
function is not executed, we pass

338
00:21:33,872 --> 00:21:38,010
it by reference. And so when

339
00:21:38,080 --> 00:21:41,310
we will be actually like calling,

340
00:21:41,380 --> 00:21:45,134
so I will run the server, when we be

341
00:21:45,172 --> 00:21:48,206
actually calling this person pass,

342
00:21:48,388 --> 00:21:51,790
then it's at the time that this function will be executed.

343
00:21:52,450 --> 00:21:55,746
When you query everything, it's quite easy, you just need

344
00:21:55,768 --> 00:21:59,154
to return okay, and then in the body of the

345
00:21:59,192 --> 00:22:02,674
response you will put all the entities that

346
00:22:02,712 --> 00:22:07,026
we found before when you query a single parameter.

347
00:22:07,138 --> 00:22:10,710
What we need to do first is to get, well, the id.

348
00:22:10,860 --> 00:22:14,610
And so for that reason, again, we don't have annotations,

349
00:22:14,770 --> 00:22:18,770
we don't have path params. Now we explicitly

350
00:22:18,850 --> 00:22:22,858
say a request path variable and we bind this

351
00:22:22,944 --> 00:22:25,340
id to this one.

352
00:22:26,510 --> 00:22:30,070
Does it work? Well, let's check. So right now

353
00:22:30,240 --> 00:22:34,234
I'm using the gold old flavor spring web MVC.

354
00:22:34,362 --> 00:22:37,482
The only difference is how I configure

355
00:22:37,546 --> 00:22:41,146
my controller, my routes. Before I used controllers,

356
00:22:41,178 --> 00:22:42,910
now I'm using routes,

357
00:22:44,690 --> 00:22:47,826
so it should do the same. And of course, since I

358
00:22:47,848 --> 00:22:51,026
restarted the gvm, well, the cache and

359
00:22:51,048 --> 00:22:54,434
the database have been emptied. So now I have one miss and one

360
00:22:54,472 --> 00:22:57,240
put. And now if I do it again,

361
00:22:58,570 --> 00:23:02,646
whoops, I have one

362
00:23:02,668 --> 00:23:05,080
bit, so it still works the same.

363
00:23:05,450 --> 00:23:08,230
That's pretty good. What would be the next step?

364
00:23:08,300 --> 00:23:11,782
Well, the next step is when you use like functional API

365
00:23:11,846 --> 00:23:15,802
in general, what we want to do is to move this

366
00:23:15,856 --> 00:23:19,274
code in a dedicated handler class. So let's do

367
00:23:19,312 --> 00:23:23,482
that. So on one side we will have our

368
00:23:23,616 --> 00:23:27,680
roots, and on the other side we will have

369
00:23:28,130 --> 00:23:31,882
the routes themselves. So the routes

370
00:23:32,026 --> 00:23:35,266
and what the routes do takes a bit

371
00:23:35,288 --> 00:23:36,100
of time.

372
00:23:45,050 --> 00:23:48,630
So here I have created this person

373
00:23:48,700 --> 00:23:52,102
handler and I'm just copy pasting the code,

374
00:23:52,156 --> 00:23:56,086
the previous code here, okay body, here, okay body.

375
00:23:56,188 --> 00:24:00,014
And with the request pass variable. And now my routes

376
00:24:00,162 --> 00:24:03,450
looks pretty much cleaner.

377
00:24:03,790 --> 00:24:07,978
Of course, it can be very, very boring to have

378
00:24:08,064 --> 00:24:10,738
one bean per route.

379
00:24:10,854 --> 00:24:15,130
So the next step is to move all those routes

380
00:24:15,210 --> 00:24:20,606
together into a single function so

381
00:24:20,628 --> 00:24:25,106
that you can write code like this. I will have here

382
00:24:25,288 --> 00:24:29,122
the parent, the parent path. And here I have like

383
00:24:29,176 --> 00:24:32,354
hey, at the roots of the person I

384
00:24:32,392 --> 00:24:37,426
will get all. And here if I get the id, so personid,

385
00:24:37,538 --> 00:24:40,678
I will get one. Just let's try bit very quickly

386
00:24:40,764 --> 00:24:42,120
to see how it works.

387
00:24:48,650 --> 00:24:51,974
I don't want to be too fast. I was too

388
00:24:52,012 --> 00:24:55,494
fast. Yes, bit still works.

389
00:24:55,612 --> 00:24:58,502
And normally same here, I have one put,

390
00:24:58,556 --> 00:25:02,590
I have one miss. That's the all. And if I redo it again,

391
00:25:02,740 --> 00:25:06,334
I have one hit. So it still

392
00:25:06,372 --> 00:25:10,174
works as expected. Again. So far

393
00:25:10,292 --> 00:25:14,382
we didn't do anything regarding reactive.

394
00:25:14,446 --> 00:25:18,302
What we just did is change our coding style

395
00:25:18,366 --> 00:25:22,110
from annotation based to functional.

396
00:25:22,190 --> 00:25:25,514
And yes, I agree, we still have a couple of annotations,

397
00:25:25,662 --> 00:25:29,526
but here you can see that from

398
00:25:29,628 --> 00:25:32,600
the routing, we removed most of it.

399
00:25:33,210 --> 00:25:36,374
Now comes the biggest challenge. How do we

400
00:25:36,492 --> 00:25:40,442
migrate now to reactive? It's very easy at this

401
00:25:40,496 --> 00:25:45,270
point. What we can do is just add an additional dependency

402
00:25:45,430 --> 00:25:51,770
and remove the spring MVC dependency.

403
00:25:53,870 --> 00:25:57,374
So if I have a look at the palm. What I

404
00:25:57,412 --> 00:26:01,066
do is I removed the spring

405
00:26:01,098 --> 00:26:04,478
boot starter web and I replaced it with Springboot starter

406
00:26:04,494 --> 00:26:07,906
webflox. And that's all, that's the only thing

407
00:26:07,928 --> 00:26:11,266
that we did. And on the coding side,

408
00:26:11,368 --> 00:26:15,542
what we had to do is just to

409
00:26:15,596 --> 00:26:19,634
change the package, the name of the primitives,

410
00:26:19,762 --> 00:26:23,126
they are exactly the same. So here we

411
00:26:23,148 --> 00:26:26,194
are using router function, server request, server response,

412
00:26:26,242 --> 00:26:29,290
router functions root serverresponse. Okay,

413
00:26:29,440 --> 00:26:33,930
the code is exactly the same. There is slight

414
00:26:34,350 --> 00:26:38,186
change as well. And I mentioned before that when

415
00:26:38,208 --> 00:26:42,142
you are writing reactive code, you are just not just

416
00:26:42,196 --> 00:26:46,814
calling a function that you will get the

417
00:26:46,852 --> 00:26:50,254
response you are subscribing here. We must

418
00:26:50,292 --> 00:26:53,946
understand that our repository is not reactive

419
00:26:54,058 --> 00:26:57,634
yet, so it still returns data as soon as you call

420
00:26:57,672 --> 00:27:01,470
it. And so we have reactive code that calls

421
00:27:01,550 --> 00:27:05,074
non reactive code. So in order to bridge between those two

422
00:27:05,112 --> 00:27:08,822
renas, there must be a change. We change

423
00:27:08,876 --> 00:27:12,870
from body to body value. And now we can put our like

424
00:27:12,940 --> 00:27:16,040
blocking code here. Let's start this.

425
00:27:22,270 --> 00:27:27,526
And normally it should start quite easily.

426
00:27:27,718 --> 00:27:31,402
And again, let's not be too fast. I will query

427
00:27:31,466 --> 00:27:35,200
one for once. Yes, it still works.

428
00:27:35,650 --> 00:27:40,250
And again, I still have all my hibernate

429
00:27:40,330 --> 00:27:44,142
GPA cache integration. So when I query

430
00:27:44,286 --> 00:27:47,620
twice the same entity, I've got it.

431
00:27:47,990 --> 00:27:51,300
So it's nice, I'm happy about it right now.

432
00:27:53,190 --> 00:27:57,240
But you must remember that what I told you before is

433
00:27:57,930 --> 00:28:02,022
if in your reactive chain you have part

434
00:28:02,156 --> 00:28:05,474
of the chain that is non reactive, well, your whole chain

435
00:28:05,522 --> 00:28:08,986
is not reactive. Your whole chain is blocking. And in

436
00:28:09,008 --> 00:28:12,326
that case we moved from spring

437
00:28:12,438 --> 00:28:17,110
webmbc to spring webflox

438
00:28:17,270 --> 00:28:20,634
and we kept the same data access pattern.

439
00:28:20,682 --> 00:28:24,778
So we are still using GPA, still using hibernate,

440
00:28:24,874 --> 00:28:28,474
still using Gdbc under the COVID And Gdbc

441
00:28:28,522 --> 00:28:32,474
right now is blocking. So only part of our

442
00:28:32,532 --> 00:28:36,626
application is reactive, which means that our application is

443
00:28:36,648 --> 00:28:39,794
not reactive at all. So the next step would

444
00:28:39,832 --> 00:28:44,130
be actually to move away from GPA in a hibernate

445
00:28:44,470 --> 00:28:47,938
towards, well, in the springwheel.

446
00:28:48,034 --> 00:28:52,114
There is a project called r two Dbc. And r two Dbc

447
00:28:52,242 --> 00:28:56,534
aims to replace GDbc in order to be

448
00:28:56,652 --> 00:29:00,682
reactive. So let's do that. And here we have a lot

449
00:29:00,736 --> 00:29:02,140
more changes actually.

450
00:29:06,030 --> 00:29:09,900
So the first thing that we might notice here

451
00:29:10,670 --> 00:29:14,346
is there is no starter and there is no spring

452
00:29:14,378 --> 00:29:17,322
boot starter. So I'm using spring data, r two Dbc.

453
00:29:17,386 --> 00:29:20,622
And well, hoping for the best, I had

454
00:29:20,676 --> 00:29:23,614
to remove the hibernate integration. Well,

455
00:29:23,652 --> 00:29:26,834
I could keep it, but actually it doesn't help us because

456
00:29:26,872 --> 00:29:30,354
now it's no more hibernate. And I replace h

457
00:29:30,392 --> 00:29:34,114
two with r two dbc h two which gives me the way

458
00:29:34,312 --> 00:29:37,446
I still have the same h two. Plus I have

459
00:29:37,548 --> 00:29:41,270
the reactive driver on top of it just as before I had

460
00:29:41,340 --> 00:29:44,614
the h two runtime plus the Gtbc driver on top

461
00:29:44,652 --> 00:29:48,460
of it on the

462
00:29:48,830 --> 00:29:53,034
side of the application. Now something very important,

463
00:29:53,232 --> 00:29:56,746
I need to initialize everything myself. I need

464
00:29:56,768 --> 00:30:00,554
to create the schema because before spring data GPA plus

465
00:30:00,592 --> 00:30:03,902
hibernates created that for me. Now I

466
00:30:03,956 --> 00:30:07,566
have to do that by myself. So here

467
00:30:07,748 --> 00:30:13,042
you can see that I had to create the schema and

468
00:30:13,096 --> 00:30:16,546
I need to call it. So before everything I

469
00:30:16,568 --> 00:30:19,794
have something in my application that says okay,

470
00:30:19,912 --> 00:30:23,134
before everything, hey, I will get a handle

471
00:30:23,182 --> 00:30:26,350
on the schema SQl and then I will get a

472
00:30:26,360 --> 00:30:29,862
handle on the data SQL and then I need to pass

473
00:30:29,916 --> 00:30:34,066
them in order. So I have this database client which normally

474
00:30:34,178 --> 00:30:37,074
is a non blocking database client,

475
00:30:37,122 --> 00:30:41,098
which is good. But now I need to block because

476
00:30:41,184 --> 00:30:45,050
I need to execute them in order and I need to make sure that

477
00:30:45,200 --> 00:30:48,970
those scripts, they are executed before the application really

478
00:30:49,040 --> 00:30:52,554
starts. Otherwise I might receive requests when the database

479
00:30:52,602 --> 00:30:54,800
is not ready. So not great.

480
00:30:56,050 --> 00:30:59,582
Otherwise you will be very happy to know that on the person

481
00:30:59,636 --> 00:31:03,602
repository side the only thing that I had to do was

482
00:31:03,656 --> 00:31:07,266
to change the parent. So instead of a

483
00:31:07,288 --> 00:31:11,150
GPA repository, I can use a reactive sorting repository

484
00:31:11,310 --> 00:31:14,606
and still I have spring data r two Dbc

485
00:31:14,638 --> 00:31:18,470
that handles everything for me. And on the class

486
00:31:18,540 --> 00:31:22,040
side now we can see that actually

487
00:31:22,730 --> 00:31:26,102
what we return when we call repository get

488
00:31:26,156 --> 00:31:30,186
all or find by id is

489
00:31:30,368 --> 00:31:34,378
the types that I told about it

490
00:31:34,544 --> 00:31:37,754
before. Like now I have a flux and

491
00:31:37,792 --> 00:31:41,550
here I have a mono. Now everything is reactive from

492
00:31:41,620 --> 00:31:45,738
beginning to end. Now I don't

493
00:31:45,834 --> 00:31:49,406
call body value, I call a body because actually I need

494
00:31:49,428 --> 00:31:53,490
to subscribe and I need to transform this into a publisher.

495
00:31:53,990 --> 00:31:56,340
Let's see how if this still works.

496
00:32:01,510 --> 00:32:05,640
Bit too fast.

497
00:32:06,090 --> 00:32:09,734
Yeah, really too fast. It needs to compile because

498
00:32:09,772 --> 00:32:11,590
I have added new dependencies.

499
00:32:15,690 --> 00:32:21,130
Yes, it still works bit.

500
00:32:21,200 --> 00:32:23,610
Here I lost the caching.

501
00:32:24,030 --> 00:32:28,262
I lost the caching because before I had caching configured

502
00:32:28,326 --> 00:32:31,718
through hibernate and now I don't have hibernate

503
00:32:31,734 --> 00:32:35,483
anymore. So I've lost the caching which is not really,

504
00:32:35,983 --> 00:32:36,960
really super great.

505
00:32:38,370 --> 00:32:42,078
Okay, let's forget the caching for now

506
00:32:42,164 --> 00:32:44,180
and let's continue our work.

507
00:32:45,190 --> 00:32:49,298
As I mentioned, the really hard part in the reactive application

508
00:32:49,464 --> 00:32:53,006
is making sure that you have no blocking calls in your cloud

509
00:32:53,038 --> 00:32:56,614
chain. So of course if you have a thread that

510
00:32:56,652 --> 00:33:00,726
calls a web service,

511
00:33:00,908 --> 00:33:04,642
you don't care. It must be like executed on this thread

512
00:33:04,706 --> 00:33:07,846
and then the rest of the application can run its life.

513
00:33:08,028 --> 00:33:11,786
But you shouldn't have blocking calls where it's not supposed to

514
00:33:11,808 --> 00:33:15,594
be blocking. So here, in order to make sure of

515
00:33:15,632 --> 00:33:19,034
that, we will add one more dependency which is

516
00:33:19,072 --> 00:33:22,926
called blockhound, and blockhounds is an agent, so you

517
00:33:22,948 --> 00:33:27,082
can install it at the start of your application in development

518
00:33:27,226 --> 00:33:30,682
and it will actually throw a runtime

519
00:33:30,746 --> 00:33:34,000
exception every time it sees that

520
00:33:34,310 --> 00:33:37,842
it detects that you had a blocking call where

521
00:33:37,896 --> 00:33:41,234
it was not supposed to block. So let's start it again

522
00:33:41,272 --> 00:33:44,340
and just make sure that we didn't do anything bad.

523
00:33:45,270 --> 00:33:48,742
It's just to make sure that now our code is really really

524
00:33:48,796 --> 00:33:52,610
non blocking. Of course you can trust me, but as developers

525
00:33:52,690 --> 00:33:56,610
we shouldn't trust, we should just check by ourselves.

526
00:33:56,770 --> 00:34:03,684
So let's check it and

527
00:34:03,882 --> 00:34:07,412
let's curl it again and it still works. So that's pretty

528
00:34:07,466 --> 00:34:11,156
good. I'm app about it. I'm sure that

529
00:34:11,258 --> 00:34:14,696
none of my code is blocking right now, so I

530
00:34:14,718 --> 00:34:18,228
did a pretty good job. I can pat myself on the shoulder.

531
00:34:18,324 --> 00:34:22,276
Now I just want to show you a trick that my colleague

532
00:34:22,468 --> 00:34:26,248
showed me is instead of having this command line runner,

533
00:34:26,344 --> 00:34:29,880
there is primitive provided you by spring

534
00:34:29,960 --> 00:34:33,816
that allows you to do that in a more like reactive

535
00:34:33,848 --> 00:34:37,824
way. You have a connection factory and you can

536
00:34:38,022 --> 00:34:41,932
return a connection factory initializer. So bit doesn't

537
00:34:41,996 --> 00:34:46,224
change a lot, it's just that you don't need to write the code yourself.

538
00:34:46,422 --> 00:34:50,016
The populators, they will be handled for you by spring,

539
00:34:50,048 --> 00:34:53,556
which is pretty good. Now I want

540
00:34:53,578 --> 00:34:55,860
to add a new feature.

541
00:34:56,440 --> 00:34:59,952
Before when I queried

542
00:35:00,016 --> 00:35:03,956
for a nonexisting entity, what happened is it returned

543
00:35:03,988 --> 00:35:07,876
me nothing. Now I want it to return a dedicated HTTP

544
00:35:07,908 --> 00:35:11,944
status. So this is an additional feature and fits

545
00:35:11,982 --> 00:35:15,048
HTTP status. In that case will be not found.

546
00:35:15,134 --> 00:35:18,316
We can decide whether it's a good id or not good id, but it

547
00:35:18,338 --> 00:35:22,504
allows me to show you some nice reactive codes

548
00:35:22,632 --> 00:35:26,184
and in normal imperative code what you would do is you would

549
00:35:26,242 --> 00:35:29,840
say hey, like repository find by Id

550
00:35:29,990 --> 00:35:33,744
if it's null, return four, or four if

551
00:35:33,782 --> 00:35:36,656
it's not null, return what I found.

552
00:35:36,838 --> 00:35:40,332
Now we are subscribing so we cannot do those if

553
00:35:40,406 --> 00:35:44,464
l stuff what we need to do. And that's what I meant previously

554
00:35:44,512 --> 00:35:47,716
by you must really know the API is we

555
00:35:47,738 --> 00:35:51,940
have a dedicated function. So here we have repository

556
00:35:52,020 --> 00:35:56,200
find by Id. This returns a mono of person. As I mentioned before,

557
00:35:56,270 --> 00:36:00,328
mono of person can be like inside there can be

558
00:36:00,494 --> 00:36:04,152
nothing or a person. And so

559
00:36:04,286 --> 00:36:07,630
when it will be time to retrieve the value,

560
00:36:08,240 --> 00:36:12,424
if it can be nothing or it can be a person. If it's

561
00:36:12,552 --> 00:36:16,248
nothing then we need to return a new result.

562
00:36:16,354 --> 00:36:20,284
And this new result is accessed by switching if empty

563
00:36:20,332 --> 00:36:23,680
and then this result will be a mono of

564
00:36:23,750 --> 00:36:26,720
error of this supplier.

565
00:36:27,780 --> 00:36:32,084
So if we now run this code must

566
00:36:32,122 --> 00:36:33,750
probably ask for a new computer.

567
00:36:35,480 --> 00:36:39,268
Yes, now I'm asking for an entity that is not

568
00:36:39,354 --> 00:36:42,936
in the database. It tells me four or four and if

569
00:36:42,958 --> 00:36:46,564
I ask for an entity that is existing database it returns

570
00:36:46,612 --> 00:36:51,000
me the correct entity. Now we are nearing completion.

571
00:36:52,220 --> 00:36:55,696
There is just one single stuff. We lost the cache.

572
00:36:55,748 --> 00:36:59,064
As I mentioned, we lost the cache and well in most cases

573
00:36:59,112 --> 00:37:02,780
we would like to get the same functionality and caching

574
00:37:03,280 --> 00:37:06,832
can be very useful. So the last step is to

575
00:37:06,886 --> 00:37:10,176
repeat the cache. So what we

576
00:37:10,198 --> 00:37:14,112
will be doing is well it's a spring application so

577
00:37:14,166 --> 00:37:18,156
we will add a service layer. So between the repository

578
00:37:18,348 --> 00:37:22,096
and the route or the handler.

579
00:37:22,128 --> 00:37:26,116
In that case we will have this caching service. So how does it

580
00:37:26,138 --> 00:37:29,700
work here? Instead of using

581
00:37:29,770 --> 00:37:32,904
the repository directly, my person handler will be using

582
00:37:32,942 --> 00:37:36,324
the caching service. The service will just be a stupid

583
00:37:36,372 --> 00:37:40,536
proxy, but it's not that stupid because it

584
00:37:40,558 --> 00:37:43,700
will a get the entity

585
00:37:43,780 --> 00:37:47,288
from the cache and bit will check if it's null. If it's null,

586
00:37:47,384 --> 00:37:50,780
well it will do the request and if it's not

587
00:37:50,850 --> 00:37:54,076
null then it will return it. So let's see

588
00:37:54,098 --> 00:37:57,692
how it works now. And for

589
00:37:57,746 --> 00:38:01,056
find all we don't check in the cache, we just put in the

590
00:38:01,078 --> 00:38:04,400
cache when we did the query, just like Hibernate did before

591
00:38:04,470 --> 00:38:08,892
for us. So we are just doing manually what hibernates

592
00:38:08,956 --> 00:38:12,930
and hibernate integration with hazelcast did for us before.

593
00:38:13,460 --> 00:38:15,430
Now let's call the first one.

594
00:38:16,840 --> 00:38:20,630
Oh, I have an error. What happened?

595
00:38:21,100 --> 00:38:24,584
Well what happened is actually I

596
00:38:24,622 --> 00:38:28,564
told you about blockhounds that it was like looking for blocking

597
00:38:28,612 --> 00:38:32,900
calls in places where you shouldn't be blocking. And that's

598
00:38:32,980 --> 00:38:36,588
actually exactly what happened here. So first

599
00:38:36,674 --> 00:38:40,364
we are happy because it detected an issue and

600
00:38:40,402 --> 00:38:44,012
we know that before our code was non blocking. That's really

601
00:38:44,066 --> 00:38:48,272
good. And why? Well, everything here

602
00:38:48,326 --> 00:38:52,224
is blocking. Here we see caching service. The first call is

603
00:38:52,262 --> 00:38:56,720
blocking cache get doesn't return something

604
00:38:56,790 --> 00:39:00,564
that is non blocking it return a person. And that's not

605
00:39:00,602 --> 00:39:04,992
what we want to do. What we want to do is to have everything asynchronous,

606
00:39:05,136 --> 00:39:08,516
nothing blocking. So we will migrate to

607
00:39:08,538 --> 00:39:11,976
the real way to do caching and this is how we

608
00:39:11,998 --> 00:39:16,170
should do it. And as you can see, it might be a bit

609
00:39:16,620 --> 00:39:21,944
hard, especially when you are not used to a

610
00:39:21,982 --> 00:39:25,644
reactive API. Here I will just move

611
00:39:25,682 --> 00:39:28,110
it like this so it's better seen.

612
00:39:31,840 --> 00:39:35,500
So I will use the asynchronous

613
00:39:36,000 --> 00:39:39,680
API from hazel costs and I will wrap it

614
00:39:39,750 --> 00:39:44,156
into a supplier anyway and this returns a completion stage.

615
00:39:44,268 --> 00:39:48,428
And so I need to bridge from the reactive,

616
00:39:48,524 --> 00:39:52,596
well one of the reactive ways to well one of

617
00:39:52,618 --> 00:39:55,860
the ways to do reactive on the TDK to

618
00:39:56,010 --> 00:39:59,460
project reactor and there is this from completion stage.

619
00:39:59,800 --> 00:40:03,488
Now if there is something inside that means that the cache

620
00:40:03,584 --> 00:40:06,856
was hot, I got a result. So I will log it, I will say,

621
00:40:06,878 --> 00:40:10,552
hey, I've been found in cache. Now if nothing was found,

622
00:40:10,686 --> 00:40:14,556
I will switch to empty and I

623
00:40:14,578 --> 00:40:18,300
will do the database call. And then if everything

624
00:40:18,370 --> 00:40:21,916
is fine I will probably find the entity in the

625
00:40:21,938 --> 00:40:25,116
database. So I will put it asynchronously in the

626
00:40:25,138 --> 00:40:29,324
cache and it will be the end. Now let's

627
00:40:29,372 --> 00:40:33,744
start this and

628
00:40:33,782 --> 00:40:37,888
let's check how it works. Yes, it works.

629
00:40:38,054 --> 00:40:41,536
Now I'm sure that my code is reactive because

630
00:40:41,558 --> 00:40:44,708
I have black hound installed. Before it told me hey, you did a

631
00:40:44,714 --> 00:40:48,084
big boo boo. Now it doesn't tell me anything anymore so it's fine.

632
00:40:48,122 --> 00:40:52,404
And here I can have the same, I will check

633
00:40:52,602 --> 00:40:56,136
one again and I can check the log and it tells me hey,

634
00:40:56,238 --> 00:40:59,976
like previously, id one was set in cache, now id one is

635
00:40:59,998 --> 00:41:03,352
found in cache so I don't need to go to the database. Now if I

636
00:41:03,406 --> 00:41:07,710
do the request on everything and I call id two,

637
00:41:09,040 --> 00:41:11,950
it should tell me it's found in the cache. Perfect.

638
00:41:12,400 --> 00:41:15,916
Pretty good. So now demo is finished and the

639
00:41:15,938 --> 00:41:19,564
wrap up is the following. First, if you need to migrate your

640
00:41:19,602 --> 00:41:23,452
spring boot application, I would advise you to migrating to functional APIs.

641
00:41:23,516 --> 00:41:27,504
First, don't try to use the annotations with reactive engine.

642
00:41:27,622 --> 00:41:31,540
You might run into problems, you might confuse this

643
00:41:31,610 --> 00:41:35,636
reactive. Is this blocking? I don't know. So just change away your

644
00:41:35,658 --> 00:41:39,108
code entirely. Remember, when you want your application

645
00:41:39,194 --> 00:41:42,452
to be reactive, your whole call chain must be reactive. Your whole

646
00:41:42,506 --> 00:41:46,596
request response chain must be reactive. And you might introduce some blocking

647
00:41:46,628 --> 00:41:50,388
calls. So in order to be sure about it, of course you have code reviews,

648
00:41:50,484 --> 00:41:54,644
but the best way to do that, like 100% solid

649
00:41:54,692 --> 00:41:58,524
way is to use blockhound. If you want to migrating to reactive. It's more work,

650
00:41:58,562 --> 00:42:02,376
but it's not impossible. If you are using Kotlin, I would really really advise

651
00:42:02,408 --> 00:42:05,756
you to look at coroutines. So if you want to check the

652
00:42:05,778 --> 00:42:09,500
next slide, I will have the link to the repository.

653
00:42:09,580 --> 00:42:12,816
I have a dedicated Kotlin branch. Have a look.

654
00:42:12,918 --> 00:42:16,716
And most importantly, you are engineers, you are developers.

655
00:42:16,828 --> 00:42:20,124
So you make like decisions based on trade offs.

656
00:42:20,172 --> 00:42:22,908
Don't use reactive Eco overdo.

657
00:42:23,004 --> 00:42:26,256
Thanks a lot for your attention. You can read my blog, you can follow me

658
00:42:26,278 --> 00:42:30,384
on Twitter. As I mentioned, you can have a look at the repository on

659
00:42:30,422 --> 00:42:34,168
GitHub and and though the talk was not about Hazelcast, if you

660
00:42:34,174 --> 00:42:37,992
are interested about Hazelcast, you can join our slack or you can train

661
00:42:38,046 --> 00:42:40,710
yourself for free. Thanks a lot again and have a good day.

