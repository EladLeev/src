1
00:00:19,850 --> 00:00:23,310
Hey folks, welcome to this session. Thank you so much for tuning in.

2
00:00:23,460 --> 00:00:27,186
I've been a part of Con 40 before, but not the Golang edition, so I'm

3
00:00:27,218 --> 00:00:31,126
delighted to be speaking at this wonderful go conference. My name

4
00:00:31,148 --> 00:00:35,058
is Abhishek Gupta. I work on a bunch of things, but databases

5
00:00:35,154 --> 00:00:38,550
go and open source in general happen to be the key focus

6
00:00:38,620 --> 00:00:41,814
areas in my role here as a developer advocate

7
00:00:41,862 --> 00:00:45,274
at AWS. My social media activity is

8
00:00:45,312 --> 00:00:49,002
kind of lukewarm, I would say, but I'm fairly active on GitHub because

9
00:00:49,056 --> 00:00:52,718
that's where I keep pushing all my stuff that I'm building. But don't hesitate to

10
00:00:52,724 --> 00:00:55,806
connect with me if you have questions or just want to chat about tech in

11
00:00:55,828 --> 00:00:56,400
general.

12
00:00:59,410 --> 00:01:03,294
Now this talk is geared towards folks who are looking to get started with

13
00:01:03,332 --> 00:01:06,974
Redis and go. Or perhaps you're already experienced

14
00:01:07,022 --> 00:01:10,178
with both these topics and in that case this might be

15
00:01:10,184 --> 00:01:13,666
a good refresher. Now I have a very, very simple agenda for

16
00:01:13,688 --> 00:01:17,286
you. I'll start off by setting the context about redis and

17
00:01:17,308 --> 00:01:21,078
go in general, followed by some hands on stuff

18
00:01:21,164 --> 00:01:24,486
and wrap up with some gotchas and things you

19
00:01:24,508 --> 00:01:28,086
should watch out for. Now, I cannot possibly go over

20
00:01:28,188 --> 00:01:31,894
or cover everything in a single talk, so I'll leave you with some resources

21
00:01:31,942 --> 00:01:34,998
at the end as well. And by the end of this presentation,

22
00:01:35,094 --> 00:01:38,154
you should have a fairly good overview of Go

23
00:01:38,192 --> 00:01:41,386
and Redis. And this includes things like

24
00:01:41,488 --> 00:01:44,814
the client options you've got. How can you

25
00:01:44,852 --> 00:01:48,350
implement common use cases and patterns? And as you start

26
00:01:48,420 --> 00:01:52,126
your journey with Redis and go, hopefully some of the tips and tricks will come

27
00:01:52,148 --> 00:01:56,034
in handy and try and help you simplify that learning curve and

28
00:01:56,152 --> 00:01:58,450
help reduce some of that friction.

29
00:02:00,310 --> 00:02:04,658
As you might have guessed already, I love Redis and I've been a

30
00:02:04,744 --> 00:02:08,614
fan and a redis user since a few years, but I'm not the only

31
00:02:08,652 --> 00:02:12,210
one out there. Redis is not brand new anymore,

32
00:02:12,290 --> 00:02:15,714
but I still like to refer it to it as relatively

33
00:02:15,762 --> 00:02:19,574
young because it was first open source in 2009, so that makes it

34
00:02:19,612 --> 00:02:23,002
around 14 years old now. But I'm pretty confident that there

35
00:02:23,056 --> 00:02:26,458
are a lot of innovations we are going to witness in the years to come.

36
00:02:26,544 --> 00:02:30,346
As far as Redis is concerned now, since it was released, it did

37
00:02:30,368 --> 00:02:33,466
not take Redis too long to win the hearts and minds of the developer

38
00:02:33,498 --> 00:02:37,514
community. As you can see, as per DB Engine's statistics,

39
00:02:37,642 --> 00:02:40,714
Redis has been actually topping the charts since 2013.

40
00:02:40,762 --> 00:02:45,154
That's just four years after its release and on

41
00:02:45,192 --> 00:02:48,386
the stack overflow annual survey. It's been voted one

42
00:02:48,408 --> 00:02:52,466
of the most loved databases for many years in a row now.

43
00:02:52,568 --> 00:02:55,926
And I also remember seeing something like Redis being one of

44
00:02:55,948 --> 00:02:59,746
the most pulled docker images on Docker hub

45
00:02:59,778 --> 00:03:02,610
as well. So all in all, pretty popular.

46
00:03:02,770 --> 00:03:04,520
And I also love Go.

47
00:03:05,770 --> 00:03:10,060
And in many ways, so far, I've seen that Go has become this

48
00:03:10,510 --> 00:03:14,470
lingua franca, or language of the cloud, so to speak. It powers

49
00:03:14,550 --> 00:03:18,634
many, many cloud native projects. Apparently 75% of

50
00:03:18,672 --> 00:03:22,378
CNCF projects are written in Go. And if you're using perhaps

51
00:03:22,474 --> 00:03:25,770
Docker or Kubernetes, Prometheus, terraform,

52
00:03:25,850 --> 00:03:28,654
you're actually using Go indirectly and the power of Go.

53
00:03:28,772 --> 00:03:32,302
And in fact, there are many, many databases that have been written in go,

54
00:03:32,436 --> 00:03:35,770
like influxdb or etCD and vitas etc.

55
00:03:35,930 --> 00:03:39,342
And it is not just that Go caters to,

56
00:03:39,476 --> 00:03:42,994
excuse me, go caters to a wide variety of

57
00:03:43,032 --> 00:03:47,282
general purpose use cases as well, be it web apps or APIs

58
00:03:47,426 --> 00:03:51,026
or data processing pipelines. Think about infrastructure

59
00:03:51,058 --> 00:03:54,134
as code, SRE DevOps solutions, and also

60
00:03:54,172 --> 00:03:58,026
building Clis. In fact, that happens to be one of the very, very popular use

61
00:03:58,048 --> 00:04:01,574
cases for Go. And no wonder Go has become a very popular

62
00:04:01,622 --> 00:04:05,594
language. Again, pointing to this, I love

63
00:04:05,632 --> 00:04:08,842
referring to stack overflow. Now, as you might

64
00:04:08,896 --> 00:04:12,494
think, go is down at the bottom,

65
00:04:12,692 --> 00:04:16,602
but if you notice carefully, it is the only statically

66
00:04:16,666 --> 00:04:20,346
typed language in that list after rust. And of course there's c sharp,

67
00:04:20,378 --> 00:04:24,094
but that's down the list. And in fact, this is from 2022.

68
00:04:24,132 --> 00:04:27,666
If you look at data from 2021 down

69
00:04:27,688 --> 00:04:31,202
to 2018, you will notice that Go has actually

70
00:04:31,256 --> 00:04:34,526
maintained its top five spot pretty consistently.

71
00:04:34,718 --> 00:04:38,590
Now, with that, let's talk about redis and go. They have

72
00:04:38,600 --> 00:04:42,182
a few things in common, but in my experience, one of the things which really,

73
00:04:42,236 --> 00:04:45,074
really stands out to me is the simplicity.

74
00:04:45,202 --> 00:04:48,774
Now, Redis is a key value store, but the values can

75
00:04:48,812 --> 00:04:52,394
be any data structure that you sort of

76
00:04:52,432 --> 00:04:56,662
see here. These are all data structures that we use as developers

77
00:04:56,726 --> 00:05:00,478
day in, day out. Think of lists or a set, or a map or a

78
00:05:00,484 --> 00:05:04,334
sorted set. So that kind of gives you the feeling that

79
00:05:04,372 --> 00:05:08,382
redis is just this simple extension of these

80
00:05:08,516 --> 00:05:12,206
core programming languages constructs that we use day

81
00:05:12,228 --> 00:05:15,794
to day. And with go, it actually comes

82
00:05:15,832 --> 00:05:19,394
in various forms. This ranges from the

83
00:05:19,432 --> 00:05:23,326
excellent yet simple go tooling or the comprehensive

84
00:05:23,438 --> 00:05:26,786
standard library, easy to use concurrency.

85
00:05:26,898 --> 00:05:30,898
And sometimes it's

86
00:05:30,914 --> 00:05:34,280
not about what is there, but what is not there.

87
00:05:35,850 --> 00:05:40,586
And it's this notion of not bloating go with

88
00:05:40,688 --> 00:05:43,738
unnecessary language features. Just to cite an example,

89
00:05:43,824 --> 00:05:47,398
it took a while for go generics to be added

90
00:05:47,414 --> 00:05:50,586
to the language. Now, I'm not trying to trick you or trying to sell you

91
00:05:50,608 --> 00:05:54,666
into thinking that go is simple, or for that matter, any programming

92
00:05:54,698 --> 00:05:58,094
language is simple, right? That's not the case. But with go,

93
00:05:58,132 --> 00:06:01,886
the goal is really to be able to give you simple components to

94
00:06:01,988 --> 00:06:05,774
help build complex things and hide the complexity

95
00:06:05,822 --> 00:06:08,558
of the language itself behind a simple facade.

96
00:06:08,654 --> 00:06:11,906
And there are folks who have actually explained this in

97
00:06:11,928 --> 00:06:15,026
a much better fashion and in much greater detail.

98
00:06:15,128 --> 00:06:18,706
And I would really encourage you to watch this talk by Rob pike,

99
00:06:18,738 --> 00:06:22,774
one of the co creators of Go. It is from 2015, but very

100
00:06:22,812 --> 00:06:26,866
much applicable and to the essence and spirit

101
00:06:26,898 --> 00:06:28,140
of go, so to speak.

102
00:06:30,510 --> 00:06:34,490
All right, so let's quickly get a very, very high level

103
00:06:34,640 --> 00:06:38,282
view of redis, or rather an introduction to redis before

104
00:06:38,336 --> 00:06:41,414
we move on. So at its very core,

105
00:06:41,462 --> 00:06:45,086
like I alluded to earlier, redis is nothing but a key value store,

106
00:06:45,188 --> 00:06:48,702
where the key can be a string, or even a binary for that matter.

107
00:06:48,836 --> 00:06:52,302
But the important thing to note is that as far as the value

108
00:06:52,356 --> 00:06:56,002
is concerned, you can choose from a variety of data structures. Now, these are data

109
00:06:56,056 --> 00:06:59,486
structures like strings, hashes, lists and sets

110
00:06:59,518 --> 00:07:02,802
and sorted sets and so on and so forth. And by the way,

111
00:07:02,856 --> 00:07:06,522
contrary to popular opinion, redis is not just a cache.

112
00:07:06,606 --> 00:07:10,246
In fact, it's a solid messaging platform as well. And you can

113
00:07:10,268 --> 00:07:14,306
configure redis to be highly available by setting up primary replica

114
00:07:14,338 --> 00:07:17,766
replication that's asynchronous in nature. Or perhaps take

115
00:07:17,788 --> 00:07:21,046
it a step further with something like a redis cluster topology.

116
00:07:21,238 --> 00:07:24,234
And Redis is primarily an in memory system,

117
00:07:24,352 --> 00:07:27,866
but you can configure it to be persistent or rather persist that

118
00:07:27,888 --> 00:07:31,446
data to disk as well. And there are solutions like Amazon

119
00:07:31,478 --> 00:07:35,102
Memorydb that can actually take it a lot further by

120
00:07:35,156 --> 00:07:39,242
actually making it possible to use redis as a persistent primary

121
00:07:39,306 --> 00:07:43,434
database. Now, since Redis is open source and wildly

122
00:07:43,482 --> 00:07:46,962
widely popular, you can actually get offerings from pretty much any

123
00:07:47,016 --> 00:07:50,350
cloud provider, big or small, or perhaps even run it on kubernetes,

124
00:07:50,430 --> 00:07:54,434
on cloud, on prem, or even in hybrid mode. The bottom line is that with

125
00:07:54,472 --> 00:07:57,742
redis, if you want to put it in production, you can be rest assured

126
00:07:57,806 --> 00:08:01,526
that there will not be any dearth of options for you if you were

127
00:08:01,548 --> 00:08:03,720
to choose to run and operate it.

128
00:08:05,290 --> 00:08:08,390
Now, what you see here is a list of code data structures.

129
00:08:08,810 --> 00:08:12,154
So the common one is string, which is really

130
00:08:12,192 --> 00:08:15,722
simple at first, but actually quite powerful. It can be used

131
00:08:15,776 --> 00:08:19,334
for something as simple as storing a key value pair, to implementing

132
00:08:19,382 --> 00:08:23,118
advanced patterns like distributed locking or rate limiting and

133
00:08:23,124 --> 00:08:27,262
even session storage and so on and so forth. Now, a hash is

134
00:08:27,316 --> 00:08:30,686
very very similar to a map in Java or a

135
00:08:30,708 --> 00:08:34,442
dictionary in Python. And it is used to store object

136
00:08:34,516 --> 00:08:37,858
like structures. Perhaps you have a user profile or a customer

137
00:08:37,944 --> 00:08:41,314
information, things like that. Well,

138
00:08:41,352 --> 00:08:45,874
a set behaves as promised. It helps you maintain a unique set of items

139
00:08:46,002 --> 00:08:49,398
with the ability to list them, to count them,

140
00:08:49,564 --> 00:08:53,046
execute operations like union intersection and so on. So it's very,

141
00:08:53,068 --> 00:08:56,898
very close to the mathematical version. And sorted

142
00:08:56,994 --> 00:09:00,746
sets are like this big brother to set, and they make it possible for

143
00:09:00,768 --> 00:09:05,014
you to implement things like leaderboard, which is a very useful

144
00:09:05,142 --> 00:09:08,474
sort of solution in areas like gaming. So for example,

145
00:09:08,672 --> 00:09:12,506
you can store player scores in a sorted set. And when

146
00:09:12,528 --> 00:09:15,674
you need to get the top ten players, you can simply invoke

147
00:09:15,722 --> 00:09:19,038
the specific sorted set and the specific

148
00:09:19,124 --> 00:09:23,006
command and get that data. And the beauty is that all the sorting happens

149
00:09:23,108 --> 00:09:26,098
on the database side. So there is no client side logic which you need to

150
00:09:26,104 --> 00:09:29,454
apply here. And lists,

151
00:09:29,502 --> 00:09:32,626
right. They are a very, very versatile data structure as well,

152
00:09:32,648 --> 00:09:35,060
and you can use them to store many, many things,

153
00:09:35,430 --> 00:09:39,720
but using it as a worker queue is a very common

154
00:09:40,090 --> 00:09:43,666
use case and a pattern. And there are popular open source solutions

155
00:09:43,698 --> 00:09:47,810
like perhaps you have often used them as well, like sidekick or celery,

156
00:09:47,970 --> 00:09:51,514
that already support redis as a back end for job

157
00:09:51,552 --> 00:09:55,350
queuing solutions. Redis streams, they were added

158
00:09:55,430 --> 00:09:58,746
in redis five, if I remember correctly, and that can be

159
00:09:58,768 --> 00:10:02,806
used for streaming use cases. And there is also ephemeral

160
00:10:02,838 --> 00:10:06,062
messaging with pub sub. It's a broadcast, it's a

161
00:10:06,116 --> 00:10:09,754
publish and subscribe mechanism where you can send messages

162
00:10:09,802 --> 00:10:13,418
to channels and their consumers which receive from those channels.

163
00:10:13,514 --> 00:10:16,830
There's this geospatial data structure as well,

164
00:10:16,900 --> 00:10:20,766
and a really, really cool data structure, data structure called hyperlog

165
00:10:20,798 --> 00:10:24,146
log, which is can alternative to a traditional set.

166
00:10:24,248 --> 00:10:28,374
And it can store millions of items while actually optimizing for

167
00:10:28,412 --> 00:10:32,582
data storage. And you can count the number of unique items with

168
00:10:32,716 --> 00:10:35,990
really high accuracy. And like I mentioned earlier,

169
00:10:36,410 --> 00:10:39,962
Redis just feels like an extension with all these data

170
00:10:40,016 --> 00:10:43,530
structures. It just feels like an extension to everyday

171
00:10:44,350 --> 00:10:48,006
programming language constructs which we as developers

172
00:10:48,198 --> 00:10:49,580
use day in, day out.

173
00:10:53,810 --> 00:10:57,450
Moving on. So Redis has a relatively

174
00:10:57,530 --> 00:11:00,958
simple protocol, but you can always use it from a

175
00:11:00,964 --> 00:11:04,478
terminal perhaps. But to build something useful you need to have clients.

176
00:11:04,574 --> 00:11:08,306
And Redis has a very, very rich ecosystem of

177
00:11:08,328 --> 00:11:12,020
clients. And that applies to go as well. So let's explore that.

178
00:11:12,950 --> 00:11:16,958
Now, what you see here is a bunch of selected

179
00:11:17,054 --> 00:11:20,566
go clients. There are others as well, but these are the key ones.

180
00:11:20,748 --> 00:11:24,530
So what I'm going to actually talk about is, or rather use heavily

181
00:11:24,610 --> 00:11:28,406
in my sort of demos and

182
00:11:28,508 --> 00:11:32,170
discussion today is Goredis. So Goredis is by far

183
00:11:32,240 --> 00:11:35,526
the most popular client out there, the go client for Redis

184
00:11:35,558 --> 00:11:39,018
out there, and it has what you'd expect from a good client. It has

185
00:11:39,184 --> 00:11:42,666
good features, decent documentation, a very, very active

186
00:11:42,698 --> 00:11:44,640
community. And to be honest,

187
00:11:46,130 --> 00:11:50,234
Redis was already super popular and widely

188
00:11:50,282 --> 00:11:54,538
used, and it recently actually moved under the official Redis GitHub

189
00:11:54,634 --> 00:11:57,970
organization, which is just an icing on the cake, to be honest with you.

190
00:11:58,040 --> 00:12:01,698
So like I said, I'll be using this client for

191
00:12:01,864 --> 00:12:05,138
most part of this presentation, so I'll not spend a ton of time on this.

192
00:12:05,224 --> 00:12:09,254
So moving on to another client named Readygo, which is

193
00:12:09,372 --> 00:12:13,394
fairly stable, fairly tenured client in the go ecosystem,

194
00:12:13,522 --> 00:12:16,726
which supports all the standard redis stuff, as you

195
00:12:16,748 --> 00:12:20,746
might expect, the redis data types, the features such as transactions and

196
00:12:20,768 --> 00:12:24,486
pipelining, and it is actually used in other Redis

197
00:12:24,518 --> 00:12:28,614
go client library as well, like Redisarch or Redis time series

198
00:12:28,662 --> 00:12:33,018
go client. But that being said, the API

199
00:12:33,114 --> 00:12:36,590
for this particular client is a bit too flexible,

200
00:12:37,810 --> 00:12:40,910
at least in my personal opinion. Now some may like it,

201
00:12:41,060 --> 00:12:44,366
but for me it does not feel like a good

202
00:12:44,388 --> 00:12:47,554
fit when I'm using a typesafe language like go. Right? And like I said,

203
00:12:47,592 --> 00:12:51,806
it's just my personal opinion. But apart from this, the biggest drawback

204
00:12:51,838 --> 00:12:55,666
to me is the fact that this client does not support

205
00:12:55,768 --> 00:12:59,238
the redis cluster topology, right? So that's a

206
00:12:59,244 --> 00:13:02,722
big let down to me. And then there is another client

207
00:13:02,786 --> 00:13:05,670
called Ruidus. I hope I'm pronouncing this correctly.

208
00:13:06,170 --> 00:13:09,386
Forgive me if I'm not. So this is, I'd say

209
00:13:09,408 --> 00:13:13,482
it's a relatively new client, again at the time of recording this talk,

210
00:13:13,616 --> 00:13:17,286
but quickly, it's very very quickly evolving as well. So it supports

211
00:13:17,318 --> 00:13:20,838
the RSP three protocol features

212
00:13:20,854 --> 00:13:24,298
like client side caching, and supports a variety of redis modules

213
00:13:24,314 --> 00:13:27,786
as well. And as far as the API is concerned, this client

214
00:13:27,818 --> 00:13:31,390
adopts a very very interesting approach. So it provides this do

215
00:13:31,460 --> 00:13:34,978
function which is very very similar to the Readygo client which you just looked at.

216
00:13:35,064 --> 00:13:38,654
But the way it allows you to create commands

217
00:13:38,782 --> 00:13:42,734
is via this builder pattern, so this helps retain

218
00:13:42,782 --> 00:13:46,126
the strong typing, unlike the readygo

219
00:13:46,158 --> 00:13:49,814
client which you just saw. And to be honest with you, I haven't used this

220
00:13:49,852 --> 00:13:53,286
client a lot, but it looks like it's packed with a lot

221
00:13:53,308 --> 00:13:56,822
of useful features, so I can't really complain too much now.

222
00:13:56,956 --> 00:14:00,442
But for those who are looking to sort of dive deeper into

223
00:14:00,496 --> 00:14:03,994
perhaps the performance numbers and things of that nature, go to its

224
00:14:04,032 --> 00:14:07,174
website. There is a benchmark comparison with the Redis library,

225
00:14:07,302 --> 00:14:10,300
which you might actually find pretty interesting.

226
00:14:11,550 --> 00:14:14,826
Now let's take a look from a holistic

227
00:14:14,858 --> 00:14:18,286
ecosystem perspective, right, not just from a go point of view.

228
00:14:18,388 --> 00:14:21,998
Now, for folks who are not actually using go with redis, or maybe

229
00:14:22,084 --> 00:14:26,062
are not aware of it, the popularity of the redis driver

230
00:14:26,126 --> 00:14:30,462
might actually come in as a surprise to you. So Java workloads

231
00:14:30,526 --> 00:14:35,454
are a huge chunk of the redis ecosystem, and Jedis

232
00:14:35,502 --> 00:14:38,966
is the bread and butter client when it comes to Java application. But I was

233
00:14:39,068 --> 00:14:42,358
actually very, very surprised to see

234
00:14:42,444 --> 00:14:45,842
redison, this client called Java client redison, topping the charts.

235
00:14:45,986 --> 00:14:50,518
And it is followed by the node client and then Python

236
00:14:50,614 --> 00:14:53,580
and back to Java. And again,

237
00:14:54,270 --> 00:14:58,410
the point is sort of not

238
00:14:58,480 --> 00:15:02,042
to do chest thumping based on GitHub starts. I mean, they matter

239
00:15:02,096 --> 00:15:05,502
to an extent, but this is meant to give you a sense of things,

240
00:15:05,556 --> 00:15:08,926
right? And of course, another thing to

241
00:15:08,948 --> 00:15:12,714
note here is I was looking at repositories with more than 10,000 stars.

242
00:15:12,762 --> 00:15:16,334
So when I was prepping for this, the PHP redis

243
00:15:16,382 --> 00:15:19,522
client was very, very close. Actually it had around 9.6 thousand,

244
00:15:19,576 --> 00:15:22,722
9.6k stars. So that's that.

245
00:15:22,776 --> 00:15:25,890
In terms of the ecosystem and where go stands,

246
00:15:26,230 --> 00:15:29,486
as of now, it's very close to the redis

247
00:15:29,518 --> 00:15:33,266
and Java client. So anyway, let's switch

248
00:15:33,298 --> 00:15:37,362
gears and move back from stars to the ground reality,

249
00:15:37,426 --> 00:15:41,142
as they say. It's time to see some code now. So I'm going to switch

250
00:15:41,206 --> 00:15:43,740
to the ide. Okay,

251
00:15:44,430 --> 00:15:47,574
so let me start off with the basics.

252
00:15:47,622 --> 00:15:51,082
So what you're looking at is some sample and demo code

253
00:15:51,136 --> 00:15:54,346
here. So I'm going to walk you through this code and I'll keep this fairly

254
00:15:54,378 --> 00:15:57,646
high level and fairly quick because I have to move

255
00:15:57,668 --> 00:16:01,534
on to some of the use cases as well, and patterns. All right,

256
00:16:01,572 --> 00:16:04,922
so first off, if you look at this, I hope this is

257
00:16:04,996 --> 00:16:08,930
big enough. If you look at this init function, we need to

258
00:16:09,000 --> 00:16:12,434
obviously connect to redis, right? So we have init function for that

259
00:16:12,472 --> 00:16:16,418
where we use the new client function

260
00:16:16,504 --> 00:16:19,080
to connect to a local redis server here.

261
00:16:19,930 --> 00:16:23,334
Now this is actually not going to establish the connection, and that is why

262
00:16:23,372 --> 00:16:26,626
we ping, we issue a ping command,

263
00:16:26,658 --> 00:16:30,166
which is a first class redis command, to make sure that we are indeed connected.

264
00:16:30,198 --> 00:16:34,166
This is a good practice, it's not Mandatory, but it's

265
00:16:34,198 --> 00:16:38,010
good to fail fast, as they say. Now let's take a look

266
00:16:38,080 --> 00:16:41,502
at how to work with strings. So here,

267
00:16:41,556 --> 00:16:45,760
as you can see, I'm doing a very, very simple set.

268
00:16:46,850 --> 00:16:50,026
I'm just using this set function and setting

269
00:16:50,058 --> 00:16:53,986
this key to a particular value and then using

270
00:16:54,088 --> 00:16:57,940
the get function to extract that same value.

271
00:16:58,310 --> 00:17:01,822
But you can also set a TTL

272
00:17:01,886 --> 00:17:05,010
or expiry. Right, so here the TTL was zero,

273
00:17:05,080 --> 00:17:08,758
which means that this key is never going to expire. You'll have to

274
00:17:08,764 --> 00:17:12,630
delete it yourself. But if I were to set a TTL, perhaps a

275
00:17:12,700 --> 00:17:15,320
two second TTL in this case,

276
00:17:16,490 --> 00:17:20,074
and after perhaps 3 seconds, if I were to try and

277
00:17:20,112 --> 00:17:24,374
search for this key, I will not find this because Redis

278
00:17:24,422 --> 00:17:27,962
is going to automatically delete this key after

279
00:17:28,016 --> 00:17:31,786
its expiry time. So it applies to any key in redis for that

280
00:17:31,808 --> 00:17:34,858
matter. Okay. All right, so that's it in

281
00:17:34,864 --> 00:17:37,790
terms of strings. Like I said, I'm moving quick here, very, very high level.

282
00:17:37,860 --> 00:17:41,534
Just giving you a sense of how to work with the client. Just give me

283
00:17:41,572 --> 00:17:45,298
a second while I wrapped up. All right, so moving on to

284
00:17:45,384 --> 00:17:49,506
the hash. Now, as you can see, I'm using h set

285
00:17:49,688 --> 00:17:53,202
to set a bunch of key value

286
00:17:53,256 --> 00:17:56,802
pairs, right? So this is the name of my set,

287
00:17:56,856 --> 00:18:00,322
the name of the key, and I am adding these key value attributes,

288
00:18:00,386 --> 00:18:04,070
the name of the website, the URL of the website, the date.

289
00:18:04,140 --> 00:18:08,102
Right. So edge set is actually very flexible. It can take key value

290
00:18:08,156 --> 00:18:11,546
pairs like what you can see here. It can take a string slice, it can

291
00:18:11,568 --> 00:18:15,114
take a map built, it can actually

292
00:18:15,312 --> 00:18:18,826
take in a struct as an input as well. So if you

293
00:18:18,848 --> 00:18:22,794
see here, if I were to scroll down real quick, I have declared

294
00:18:22,842 --> 00:18:25,258
this Conf 42 struct.

295
00:18:25,434 --> 00:18:29,054
And notice this redis tags which I'm using. Right.

296
00:18:29,092 --> 00:18:32,794
So internally, the go Redis library uses this to map

297
00:18:32,842 --> 00:18:36,154
to the name and attributes of the hash which it creates and deals

298
00:18:36,202 --> 00:18:40,066
with. So I can then create an instance of this struct like I

299
00:18:40,088 --> 00:18:43,266
did here, and then pass it on to this edge set method. So this

300
00:18:43,288 --> 00:18:47,126
is a MUch easier, simpler, and a natural way of representing your

301
00:18:47,148 --> 00:18:50,790
objects and then sort of letting the library

302
00:18:51,290 --> 00:18:54,822
deal with the hash level, doing the et set

303
00:18:54,876 --> 00:18:58,506
and the get, and then populating your structs accordingly. Right. So it's much more

304
00:18:58,528 --> 00:19:02,026
convenient than using a random set

305
00:19:02,048 --> 00:19:05,786
of key value attributes, which is kind of static, to be honest with

306
00:19:05,808 --> 00:19:08,954
you. Moving on, let's look

307
00:19:08,992 --> 00:19:12,378
at how to use a set again. As you might expect.

308
00:19:12,464 --> 00:19:16,480
Right, no surprises here. I'm using an s add function

309
00:19:17,090 --> 00:19:20,046
to add a bunch of, this is the name of my set Con 42,

310
00:19:20,068 --> 00:19:23,530
and I'm adding a bunch of tags

311
00:19:23,690 --> 00:19:27,154
to this set. In this case, I have duplicates here as well.

312
00:19:27,352 --> 00:19:31,442
So if I were to then use the scard function

313
00:19:31,576 --> 00:19:35,282
to print out. How many tags are there for conf fourty

314
00:19:35,336 --> 00:19:39,298
two, it will give me the result, it will only give me the unique

315
00:19:39,474 --> 00:19:42,198
number. Of course, in this case it will be nine. And if I want to

316
00:19:42,204 --> 00:19:46,546
check, hey, is this sre tag included

317
00:19:46,578 --> 00:19:49,802
for conf fourty two? And in this case it's not. So it's going to return

318
00:19:49,856 --> 00:19:53,340
false and so on and so forth. Right? So sets very,

319
00:19:54,270 --> 00:19:57,466
again very simple to work with conceptually from a

320
00:19:57,488 --> 00:20:00,146
client library as well. And pipeline,

321
00:20:00,198 --> 00:20:03,626
pipeline is again one of my other favorites in addition

322
00:20:03,658 --> 00:20:09,534
to sharded pub sub and few others. Because from

323
00:20:09,572 --> 00:20:13,514
a conceptual point of view, redis is primarily

324
00:20:13,562 --> 00:20:16,782
a request response system. You give it a command like

325
00:20:16,836 --> 00:20:20,434
set get, and it gives you back a response, right? So there is this back

326
00:20:20,472 --> 00:20:23,874
and forth going on, but there are use cases where you might

327
00:20:23,912 --> 00:20:27,734
not use it. Perhaps you want to bulk load some data, and using

328
00:20:27,772 --> 00:20:31,880
the pipeline feature you can actually send it multiple commands. Think of it as

329
00:20:33,290 --> 00:20:37,074
batching, right? And you can send a bunch of commands

330
00:20:37,202 --> 00:20:40,886
in one go, and you can get the response in a single request.

331
00:20:40,918 --> 00:20:44,006
So aws, you can see here, I'm using a redis pipeline.

332
00:20:44,038 --> 00:20:48,140
I've got a redis pipeline object from the client object here.

333
00:20:48,670 --> 00:20:52,506
And then what I'm doing is inserting 1

334
00:20:52,528 --> 00:20:56,286
million keys. And then all I do is execute the

335
00:20:56,308 --> 00:21:00,142
pipeline. Now this is a very, very important step. If you do not invoke the

336
00:21:00,196 --> 00:21:03,338
exec function, your pipeline will not get executed and you'll

337
00:21:03,354 --> 00:21:06,546
be wondering like what the heck happened? So make

338
00:21:06,568 --> 00:21:09,906
sure you call the exec function and yeah, that's it. And I would

339
00:21:09,928 --> 00:21:14,210
encourage you to actually try it out. Try how it works by

340
00:21:14,280 --> 00:21:18,638
using say, client set right

341
00:21:18,744 --> 00:21:22,726
versus a pipeline to insert in this case 1

342
00:21:22,748 --> 00:21:26,214
million items, or maybe even more, and just compare the time it

343
00:21:26,252 --> 00:21:30,406
actually takes, right? You'll be surprised with the speed and efficiency

344
00:21:30,598 --> 00:21:33,434
of pipeline here.

345
00:21:33,552 --> 00:21:37,114
And other one I want to talk to you about is you saw how to

346
00:21:37,152 --> 00:21:41,006
use a set, okay? Now there's this data structure I

347
00:21:41,028 --> 00:21:44,366
mentioned earlier very briefly called hyper log,

348
00:21:44,548 --> 00:21:48,062
and it's this sets on steroids, so to speak,

349
00:21:48,116 --> 00:21:51,386
okay? So it is a very, very efficient and enhanced version

350
00:21:51,418 --> 00:21:55,050
of set, because what it can do is it can store a

351
00:21:55,060 --> 00:21:58,946
lot of data, much, much more than set, with almost

352
00:21:59,048 --> 00:22:02,674
a finite storage, right? So if you were to

353
00:22:02,712 --> 00:22:05,666
run this code, and I'm not showing it to you, just in the essence of

354
00:22:05,688 --> 00:22:09,446
time, but if you were to perhaps add 1

355
00:22:09,548 --> 00:22:12,534
million, perhaps there is a use case you have, right?

356
00:22:12,572 --> 00:22:16,118
You want to track the number of unique views and

357
00:22:16,124 --> 00:22:19,894
you're tracking ips, right? So if I were to add ips to a

358
00:22:19,932 --> 00:22:23,734
set and do the same thing to a hyperlog log using this PF

359
00:22:23,782 --> 00:22:26,842
add commands and if you were to inspect within

360
00:22:26,896 --> 00:22:30,586
redis as to how much space these keys take, you will see

361
00:22:30,768 --> 00:22:34,446
a huge amount of difference when I can. My tests with the

362
00:22:34,468 --> 00:22:37,902
set, it took around 50 mb of memory, approximately 50

363
00:22:37,956 --> 00:22:41,982
mb with the hyperlog log. It was, I think it was around

364
00:22:42,116 --> 00:22:45,122
zero point mb or something like that, right?

365
00:22:45,176 --> 00:22:48,386
You can try this out, try adding 1

366
00:22:48,408 --> 00:22:52,414
million entries. I'm using a faker library just to generate

367
00:22:52,462 --> 00:22:56,740
random fake IP addresses. Run this for yourself and see

368
00:22:57,750 --> 00:23:01,302
the kind of memory usage which you notice in your application.

369
00:23:01,436 --> 00:23:05,106
Okay, now moving on, let me show you some things in action.

370
00:23:05,138 --> 00:23:08,022
So a couple of use cases which I want to demonstrate to you.

371
00:23:08,156 --> 00:23:11,538
The first one is this use case around worker queues and I told

372
00:23:11,564 --> 00:23:15,386
you lists and how they make that possible. So I'm going to run an application

373
00:23:15,488 --> 00:23:19,546
to see that in action. Okay? Now before that I'm going to start a

374
00:23:19,568 --> 00:23:22,970
redis server here. First I'm going to use docker

375
00:23:23,050 --> 00:23:27,040
to make it very simple here. Excuse me.

376
00:23:29,650 --> 00:23:31,840
So just give me a second.

377
00:23:33,670 --> 00:23:37,410
All right, so I'm being to start

378
00:23:37,480 --> 00:23:41,394
this server again. All right, so my redis server here

379
00:23:41,432 --> 00:23:45,006
is up and running in docker nice and quick. Now another thing I'm

380
00:23:45,038 --> 00:23:48,190
going to do is start a mock SMTP server,

381
00:23:48,270 --> 00:23:52,178
right? Because the application I'm trying to show you is a very, very typical

382
00:23:52,354 --> 00:23:55,670
simple web application. Well it's not a web application

383
00:23:55,740 --> 00:23:59,254
but a use case of a web application where someone registers and

384
00:23:59,292 --> 00:24:02,726
then they suddenly get a welcome email, right?

385
00:24:02,748 --> 00:24:06,746
So that's what I'm trying to display here. So let me start off another

386
00:24:06,928 --> 00:24:10,326
container here for the fake SMTP server.

387
00:24:10,358 --> 00:24:14,250
Excuse me, this is not what I want to run. Let me copy over

388
00:24:14,320 --> 00:24:17,626
a lot of copy paste going on. In the interest of time, don't worry

389
00:24:17,658 --> 00:24:21,194
about this, it should be up and running pretty soon. So I have my SMTP

390
00:24:21,242 --> 00:24:25,330
server running. Now what I'm going to do is run my worker

391
00:24:25,750 --> 00:24:31,682
application, okay? So let

392
00:24:31,736 --> 00:24:35,122
me hop over again and make sure I am in the

393
00:24:35,176 --> 00:24:38,482
right folder and then run

394
00:24:38,536 --> 00:24:41,886
this command go run in the worker folder.

395
00:24:41,918 --> 00:24:45,766
Worker go. So what you will see here is a worker has

396
00:24:45,788 --> 00:24:49,666
started and it has published its unique id. I've just given a unique id

397
00:24:49,788 --> 00:24:53,162
for each random unique id for each worker. You'll see why I've done that

398
00:24:53,296 --> 00:24:57,270
pretty soon. And I'm going to run the producer

399
00:24:57,430 --> 00:25:01,962
application as well here side by side. So run

400
00:25:02,016 --> 00:25:05,914
producer, producer co. So what it's going to do is just randomly

401
00:25:05,962 --> 00:25:09,374
submit data here and I'm going to show you the code as well. So that

402
00:25:09,412 --> 00:25:12,706
gives you more clarity. But what's happening right now is my producer is

403
00:25:12,728 --> 00:25:16,542
generating data within redis

404
00:25:16,606 --> 00:25:20,226
and my worker applications are actually working. Okay,

405
00:25:20,328 --> 00:25:23,534
what are they doing? They're sending emails. They are sending emails to the SMTP

406
00:25:23,582 --> 00:25:27,110
server. So let's quickly switch over and take a look

407
00:25:27,180 --> 00:25:30,982
at that server. Just give me a second real

408
00:25:31,036 --> 00:25:32,920
quick while I make this happen.

409
00:25:35,050 --> 00:25:38,454
Yeah. All right, we have this server here

410
00:25:38,492 --> 00:25:42,214
and if you see this is my SMTP mail server

411
00:25:42,262 --> 00:25:45,354
and you will see a bunch of emails flying back and forth. Okay,

412
00:25:45,392 --> 00:25:49,370
so this is what our worker application

413
00:25:49,440 --> 00:25:52,750
is doing and if you notice here it says processed by this particular

414
00:25:52,820 --> 00:25:56,542
worker. So right now we just have one instance of the worker running.

415
00:25:56,596 --> 00:26:00,314
So all you will see is this particular worker instance,

416
00:26:00,362 --> 00:26:03,634
right. This particular message. Okay, that's all well and good.

417
00:26:03,672 --> 00:26:07,586
Now let's add another worker instance. So that's the

418
00:26:07,608 --> 00:26:11,374
magic of the list data structure,

419
00:26:11,422 --> 00:26:15,442
right? Scaling out horizontally. So it's very simple. I'm going to run another

420
00:26:15,496 --> 00:26:18,950
instance here. So go run another

421
00:26:19,020 --> 00:26:23,318
worker. And there you go. So now this has a different id

422
00:26:23,404 --> 00:26:26,886
notice it ends with 1119, starts with two a.

423
00:26:26,908 --> 00:26:30,502
So what's going to happen is now everything is going to happen automatically.

424
00:26:30,566 --> 00:26:34,426
These worker instances are going to distribute the tasks of

425
00:26:34,448 --> 00:26:37,894
sending emails amongst themselves, right? So now you have a balance.

426
00:26:37,942 --> 00:26:41,510
You have two workers crunching all these new users

427
00:26:41,670 --> 00:26:45,662
who are registering on your website. So let's go back to the email

428
00:26:45,716 --> 00:26:49,626
client which we were using and just refresh it and you'll

429
00:26:49,658 --> 00:26:52,778
notice that there are different workers. So if you see this is the second worker

430
00:26:52,794 --> 00:26:56,046
which we had started and if I were

431
00:26:56,068 --> 00:26:59,666
to show you perhaps another one, this is the same worker and

432
00:26:59,768 --> 00:27:02,814
yeah, this is the first one which we had, right. If you notice closely.

433
00:27:02,862 --> 00:27:06,486
So like I said, work distribution, this can be

434
00:27:06,508 --> 00:27:09,958
used in many use cases. Of course I showed you a very simple one of

435
00:27:10,044 --> 00:27:13,858
website users registering and then this asynchronous

436
00:27:13,954 --> 00:27:17,650
process starting where these notification

437
00:27:17,730 --> 00:27:21,466
emails are sent out. Right now let's look inside redis what

438
00:27:21,488 --> 00:27:24,874
is happening and also take a look at the code. So I'm going to go

439
00:27:24,912 --> 00:27:28,502
back to my terminal here and fire up the redis

440
00:27:28,646 --> 00:27:32,606
cli real quick to

441
00:27:32,628 --> 00:27:36,154
log into my local redis instance. And let's

442
00:27:36,202 --> 00:27:39,258
take a look at this key called celery.

443
00:27:39,354 --> 00:27:42,494
Okay, so there is this key called celery and let's look at

444
00:27:42,532 --> 00:27:46,510
what type it is. Right. So I'm going to type celery.

445
00:27:47,190 --> 00:27:50,702
So it's of type list. Now actually what's happening is behind the scenes,

446
00:27:50,766 --> 00:27:53,890
the application which I'm using, it's this go library

447
00:27:54,550 --> 00:27:58,434
which is using the celery protocol to do all this magic. Okay. And internally

448
00:27:58,482 --> 00:28:02,034
it creates a list called salary, and that's where all my jobs

449
00:28:02,082 --> 00:28:04,200
go. Okay, so this is the list.

450
00:28:05,530 --> 00:28:09,270
What's the length of this list? Right, so 139,

451
00:28:09,340 --> 00:28:12,586
there are around 139 tasks at this moment. Now this is

452
00:28:12,608 --> 00:28:16,426
going to change very, very quickly. And these are the number of tasks which are

453
00:28:16,448 --> 00:28:20,634
there in the list. And that's what our worker applications are actually processing.

454
00:28:20,682 --> 00:28:24,398
So, cool. Let's take a look at one of the

455
00:28:24,484 --> 00:28:28,794
items. So I can use a list command l range. And perhaps

456
00:28:28,842 --> 00:28:32,814
let take a look at the

457
00:28:32,852 --> 00:28:36,386
first item here. The first item, the task in the list. So this

458
00:28:36,408 --> 00:28:39,966
is the body which you see, it's actually JSon encoded.

459
00:28:39,998 --> 00:28:43,986
Okay, so let's make this simple for ourselves and decode this.

460
00:28:44,008 --> 00:28:48,226
I'm going to open another terminal here. So going

461
00:28:48,248 --> 00:28:51,686
to do is throw in this and I'm going to do a base

462
00:28:51,788 --> 00:28:55,734
64 decoding. And this is just to show you right, as to what's going

463
00:28:55,772 --> 00:28:59,494
on behind the scenes here. So if you see, this is the JSON

464
00:28:59,542 --> 00:29:03,098
payload, this is the celery compatible payload, which is being sort

465
00:29:03,104 --> 00:29:07,340
of shared back and forth, right? So this is the name

466
00:29:08,830 --> 00:29:12,790
of our user here that the producer application is sending.

467
00:29:12,870 --> 00:29:15,726
And at the end of the day, the worker is actually churning this data and

468
00:29:15,748 --> 00:29:19,502
sending emails, fake emails in this case, of course. Right? So with that said,

469
00:29:19,556 --> 00:29:23,394
let me actually show you the application itself very quickly.

470
00:29:23,512 --> 00:29:26,434
So here is the worker which we have.

471
00:29:26,472 --> 00:29:29,522
So if I were to quickly show you

472
00:29:29,576 --> 00:29:32,434
the important stuff here, right,

473
00:29:32,552 --> 00:29:36,610
so the most important part here is this salary client

474
00:29:36,690 --> 00:29:41,494
object and how I register the

475
00:29:41,532 --> 00:29:45,474
function and to a specific named task

476
00:29:45,522 --> 00:29:50,018
here. Right? So this is all going to shape the salary message.

477
00:29:50,124 --> 00:29:53,546
And the function which I'm being here is the send email and

478
00:29:53,568 --> 00:29:57,174
it's just using the SMTP libraries to send emails.

479
00:29:57,222 --> 00:30:00,686
Very simple, nothing magical going on here. And if I were to look at the

480
00:30:00,708 --> 00:30:04,266
producer application here. So all it's doing is sending

481
00:30:04,378 --> 00:30:05,310
messages,

482
00:30:07,490 --> 00:30:09,310
in this case email addresses,

483
00:30:10,210 --> 00:30:13,718
to the same task, and that's why the worker

484
00:30:13,754 --> 00:30:17,438
is picking it up. Right. And just fyi, this is the library which I'm

485
00:30:17,454 --> 00:30:19,986
using. It's called go celery. Right.

486
00:30:20,088 --> 00:30:23,700
So yeah, just a very quick example of

487
00:30:25,670 --> 00:30:28,786
how the list capabilities are actually abstracted

488
00:30:28,818 --> 00:30:32,274
behind the scenes here. We are not using the native list commands directly,

489
00:30:32,322 --> 00:30:36,274
but we are using this library instead, which uses redis lists

490
00:30:36,322 --> 00:30:39,746
behind the scenes to do all this magic and task distribution

491
00:30:39,778 --> 00:30:43,402
and all the good stuff. Right. So let me close this and move

492
00:30:43,456 --> 00:30:47,322
on to another example. I'm going to show you an application of the

493
00:30:47,376 --> 00:30:50,540
pub sub capabilities. So at a very, very simple level,

494
00:30:50,910 --> 00:30:54,262
pub sub is about broadcasting messages. So you publish

495
00:30:54,326 --> 00:30:57,774
messages to a channel, and there are consumers which subscribe to that

496
00:30:57,812 --> 00:31:01,486
channel and receive messages as long as they're online and as long as they are

497
00:31:01,508 --> 00:31:04,926
subscribed to that channel. Now this is very

498
00:31:04,948 --> 00:31:08,434
powerful, but it can actually be combined with this technology called real

499
00:31:08,472 --> 00:31:12,558
time technology called websocket to create much, much more powerful solutions.

500
00:31:12,654 --> 00:31:16,098
And it also actually helps overcome some of the limitations which

501
00:31:16,184 --> 00:31:19,278
WebSocket has because it's a very, very stateful protocol.

502
00:31:19,374 --> 00:31:22,642
Now, I've built a very, very simple, yet canonical

503
00:31:22,786 --> 00:31:26,322
chat example, very simple chat server.

504
00:31:26,386 --> 00:31:30,026
So let's see how that works before we go into the code. So I'm going

505
00:31:30,048 --> 00:31:35,174
to quickly go into another directory

506
00:31:35,222 --> 00:31:37,500
here and start off this application,

507
00:31:38,590 --> 00:31:40,220
my chat server here,

508
00:31:41,790 --> 00:31:45,854
and you will see that my

509
00:31:45,892 --> 00:31:49,626
chat application has started and let's connect to it and exchange

510
00:31:49,658 --> 00:31:53,618
a few messages like you would do in a typical chat application.

511
00:31:53,704 --> 00:31:56,734
Now, what I'm going to do is a Websocket client,

512
00:31:56,782 --> 00:32:00,386
a command line websocket client called AWS can,

513
00:32:00,568 --> 00:32:03,780
and I'm connecting to my server as this

514
00:32:04,870 --> 00:32:08,318
user one. Right, it's a sample user. Okay,

515
00:32:08,424 --> 00:32:11,762
so this user is connected.

516
00:32:11,826 --> 00:32:15,238
Now what I'm going to do is connect another user, but this time I'm going

517
00:32:15,244 --> 00:32:18,346
to change the name and call it user two. Now, these users can

518
00:32:18,368 --> 00:32:22,042
exchange messages over by using the combination of WebSocket and

519
00:32:22,096 --> 00:32:25,020
redis pops up. So I say, hello there,

520
00:32:26,990 --> 00:32:30,874
this will go off. Hi, how are you? It doesn't matter

521
00:32:30,912 --> 00:32:34,286
what you're typing, this is just for demo and so on and so

522
00:32:34,308 --> 00:32:37,390
forth. And I can keep on adding users to this.

523
00:32:37,460 --> 00:32:41,054
And this is being to ensure that all the users get all these

524
00:32:41,092 --> 00:32:44,334
messages. So another user called as user three,

525
00:32:44,452 --> 00:32:48,418
like hey there. Yeah, so you kind

526
00:32:48,424 --> 00:32:52,158
of get a sense of where this is going. Okay, now I'm

527
00:32:52,174 --> 00:32:56,002
going to show you the code. Just focus on the key parts like

528
00:32:56,056 --> 00:32:59,366
I did before. So let me close this and this and

529
00:32:59,468 --> 00:33:03,318
go over to my chat application. So there are a few things which you

530
00:33:03,324 --> 00:33:07,158
should note here. Of course, this is, like I

531
00:33:07,164 --> 00:33:11,178
said, very small application. But again, we are making connections to the

532
00:33:11,184 --> 00:33:14,714
redis client, so on and so forth, setting up our routes here.

533
00:33:14,752 --> 00:33:18,698
But the important thing is, let me scroll down

534
00:33:18,784 --> 00:33:22,842
here real quick, the part where we create the websocket connection.

535
00:33:22,906 --> 00:33:27,086
Now minded, let me just scroll up a bit. I'm using this

536
00:33:27,268 --> 00:33:31,150
client called WebSocket, part of the larger gorilla

537
00:33:31,730 --> 00:33:34,718
system of libraries, group of libraries.

538
00:33:34,894 --> 00:33:38,526
So I'm using this websocket client, I create this Websocket

539
00:33:38,558 --> 00:33:42,574
connection, and what I do is associate that username

540
00:33:42,622 --> 00:33:46,190
which I had entered with the actual connection object itself.

541
00:33:46,280 --> 00:33:49,794
Right? So this is a Websocket connection

542
00:33:49,842 --> 00:33:52,966
here. And when a message comes in via that

543
00:33:52,988 --> 00:33:56,150
websocket connection, when that user sends hi. Hey. Hello.

544
00:33:56,300 --> 00:33:59,526
What I actually do is publish messages,

545
00:33:59,638 --> 00:34:02,954
that particular message, to a redis channel. Okay? So I'm using

546
00:34:02,992 --> 00:34:06,522
this function called publish here.

547
00:34:06,656 --> 00:34:10,566
And then what happens is when a message is actually received

548
00:34:10,598 --> 00:34:14,686
on that channel, I have this broadcaster function which

549
00:34:14,708 --> 00:34:17,950
is running within a go routine. So what it does is whenever a

550
00:34:18,020 --> 00:34:21,454
message is received on this channel, it broadcasts it

551
00:34:21,492 --> 00:34:25,394
to all the connected users and it does it through that

552
00:34:25,592 --> 00:34:28,754
websocket object, that session object which we have, right?

553
00:34:28,792 --> 00:34:32,610
So it kind of goes over that map where I had initially stored

554
00:34:33,190 --> 00:34:37,150
that mapping of user and websocket connection, and it simply broadcasts,

555
00:34:37,230 --> 00:34:39,640
right again, like you see,

556
00:34:40,490 --> 00:34:44,246
we are combining websockets and redis channel to overcome some of

557
00:34:44,268 --> 00:34:47,638
the constraints of WebSocket and making this sort

558
00:34:47,644 --> 00:34:50,822
of simplified but useful chat application. This is fully functional,

559
00:34:50,886 --> 00:34:53,130
by the way, and if someone were to exit,

560
00:34:54,750 --> 00:34:59,050
that user is going to be deleted from the actual map

561
00:34:59,390 --> 00:35:02,626
within the code, and everything is going to work as expected.

562
00:35:02,678 --> 00:35:06,382
So of course you can try this out. But like I said, very, very simple

563
00:35:06,436 --> 00:35:10,282
example to demonstrate a couple of very, very common patterns and use cases.

564
00:35:10,426 --> 00:35:14,238
One of the worker queue pattern and the other of a

565
00:35:14,244 --> 00:35:17,678
pub sub real time applications combining

566
00:35:17,774 --> 00:35:21,106
pubsub and websocket. So we only have so

567
00:35:21,128 --> 00:35:24,626
much time. I did not cover a lot of things, to be very frank with

568
00:35:24,648 --> 00:35:28,854
you, things like geospatial or redis streams. But I hope

569
00:35:28,892 --> 00:35:33,110
you have a fair idea of the concept of redis data structures.

570
00:35:34,090 --> 00:35:38,250
How do you use some of these commands, the sets,

571
00:35:39,070 --> 00:35:42,506
the string, the set, the list and so on and so forth within

572
00:35:42,608 --> 00:35:46,042
the Godadis client. So with that,

573
00:35:46,096 --> 00:35:49,322
let's move on to the next part of this

574
00:35:49,456 --> 00:35:52,370
talk. All right, back to the presentation.

575
00:35:52,550 --> 00:35:55,710
Now let's go over some of the most common

576
00:35:55,780 --> 00:35:59,326
things you should watch out for when working with redis, especially when

577
00:35:59,348 --> 00:36:02,766
you're getting started. Now, there are actually great resources around this

578
00:36:02,788 --> 00:36:06,706
topic, and I happen to write a blog post which I will share at the

579
00:36:06,728 --> 00:36:10,322
end of this presentation. Now, in order to do anything else

580
00:36:10,376 --> 00:36:14,194
you first need to connect to the redis server. Kind of obvious,

581
00:36:14,312 --> 00:36:17,518
but believe it or not, sometimes that can be challenging.

582
00:36:17,614 --> 00:36:21,506
So let's take a look at a couple of low hanging fruits

583
00:36:21,698 --> 00:36:25,286
in this area. And this first one is kind of

584
00:36:25,308 --> 00:36:28,658
obvious. Now I'm going to call it out anyway because this is one

585
00:36:28,684 --> 00:36:32,662
of the most common getting started mistakes which I often see folks

586
00:36:32,726 --> 00:36:36,026
make. Now, the connection mode that you use in

587
00:36:36,048 --> 00:36:39,802
your client application will depend on whether you're using a

588
00:36:39,856 --> 00:36:43,534
standalone redis setup or a redis cluster, or perhaps even

589
00:36:43,572 --> 00:36:46,830
redis sentinel if you're using it. For example,

590
00:36:46,900 --> 00:36:50,590
if you're using the go redis client, you will need to

591
00:36:50,660 --> 00:36:54,334
either use the new cluster client or the new client

592
00:36:54,382 --> 00:36:57,662
function depending upon the topology. Now most Redis

593
00:36:57,726 --> 00:37:01,202
clients draw a clear distinction between these

594
00:37:01,336 --> 00:37:05,140
types of connections which you're making, but interestingly enough,

595
00:37:05,750 --> 00:37:09,362
the goer redis client has this option of a universal

596
00:37:09,426 --> 00:37:13,286
client which is a built flexible right. It gives you that

597
00:37:13,308 --> 00:37:16,774
flexibility of using one function to choose and connect

598
00:37:16,812 --> 00:37:20,726
to any redis topology out there. And this

599
00:37:20,748 --> 00:37:24,534
is actually available in the go redis v nine, if I remember correctly.

600
00:37:24,582 --> 00:37:28,122
Right, so v nine onwards. And if you don't use

601
00:37:28,176 --> 00:37:31,980
the right mode of connection, obviously you'll get an error. But sometimes,

602
00:37:32,930 --> 00:37:36,538
depending upon which redis instance you're

603
00:37:36,554 --> 00:37:39,566
using, which provider and so on and so forth, the root cause actually might be

604
00:37:39,588 --> 00:37:42,486
hidden. It might be hidden behind a generic error.

605
00:37:42,538 --> 00:37:46,306
So you have to be watchful to

606
00:37:46,328 --> 00:37:49,780
avoid frustrations and those challenges in getting started.

607
00:37:50,310 --> 00:37:53,586
And now this is also something which trips up folks all the

608
00:37:53,608 --> 00:37:57,174
time, especially when they are working with redis on cloud,

609
00:37:57,372 --> 00:38:01,398
which is very common to be honest with you. Now say for example,

610
00:38:01,564 --> 00:38:05,682
the example here which you see is with Amazon elasticache

611
00:38:05,826 --> 00:38:09,082
where your redis nodes are

612
00:38:09,136 --> 00:38:12,326
in a VPC. Now if you have a client application deployed

613
00:38:12,358 --> 00:38:16,262
to a compute service like AWS lambda

614
00:38:16,326 --> 00:38:20,246
or Kubernetes cluster in eks or can ecs

615
00:38:20,278 --> 00:38:23,326
and so on and so forth, you need to make sure that you have the

616
00:38:23,348 --> 00:38:27,226
right configuration in terms of the VPC and the security groups.

617
00:38:27,258 --> 00:38:29,520
And of course this might depend,

618
00:38:30,770 --> 00:38:34,382
this is going to vary depending upon the compute platform which you're ultimately using.

619
00:38:34,436 --> 00:38:38,210
But something to bear in mind, and like Samantha rightly said,

620
00:38:38,360 --> 00:38:41,826
you need to read the please, please read the documentation for

621
00:38:41,848 --> 00:38:45,086
your specific provider once you're setting all these

622
00:38:45,128 --> 00:38:47,990
things up, including of course AWS.

623
00:38:49,930 --> 00:38:54,086
Redis is actually wicked fast and a single server which actually

624
00:38:54,268 --> 00:38:58,070
it's going to actually take you pretty far in your journey.

625
00:38:58,490 --> 00:39:02,566
But also know that Redis is primarily an in memory

626
00:39:02,598 --> 00:39:06,586
system. I've alluded to that before. So you will actually want a

627
00:39:06,608 --> 00:39:10,394
bigger machine with more ram and memory if you want to handle more

628
00:39:10,432 --> 00:39:14,174
data. And at the same time, it's important to

629
00:39:14,212 --> 00:39:17,710
know that Redis is a single threaded system.

630
00:39:17,780 --> 00:39:21,546
So what that means is you cannot throw more cpu cores

631
00:39:21,578 --> 00:39:24,834
at it. It's probably not going to benefit you

632
00:39:24,872 --> 00:39:28,994
a lot. So that's where you'll have to think about scaling. And as

633
00:39:29,112 --> 00:39:33,330
is the case with most systems, you can either scale redis up

634
00:39:33,480 --> 00:39:36,614
or out, right? Up, down and in and out, right?

635
00:39:36,652 --> 00:39:39,830
That's the way scaling up and down is.

636
00:39:39,980 --> 00:39:43,222
I would say relatively simpler. Not simple,

637
00:39:43,276 --> 00:39:46,998
relatively simpler. But you need to put a lot of thought into

638
00:39:47,164 --> 00:39:50,074
scaling out horizontally scaling in and out,

639
00:39:50,192 --> 00:39:53,366
especially if it's for a stateful system like a database,

640
00:39:53,398 --> 00:39:56,154
like redis, for example. So you have to be very,

641
00:39:56,192 --> 00:39:59,798
very clear about the type of workload you're

642
00:39:59,814 --> 00:40:03,166
optimizing for. So perhaps you are looking to

643
00:40:03,188 --> 00:40:06,538
solve a problem where you have a lot of reads,

644
00:40:06,634 --> 00:40:10,046
so you can choose to add more replica nodes to

645
00:40:10,148 --> 00:40:14,034
the existing primary redis node. Or perhaps you want to increase write

646
00:40:14,072 --> 00:40:18,066
capacity. Your applications have a lot of it's write

647
00:40:18,248 --> 00:40:22,162
heavy workload, so you will find yourself getting

648
00:40:22,216 --> 00:40:26,146
limited by the primary replica node. And you should opt for a redis

649
00:40:26,258 --> 00:40:30,166
cluster based setup instead. So you can increase the number of

650
00:40:30,268 --> 00:40:33,622
shards in your cluster. And this is because

651
00:40:33,756 --> 00:40:37,698
the primary nodes can only the primary nodes can

652
00:40:37,724 --> 00:40:41,482
accept writes and each shard can only have one

653
00:40:41,616 --> 00:40:45,034
primary node. But overall, once you have

654
00:40:45,072 --> 00:40:48,838
this setup, this has the added benefit of increasing the overall

655
00:40:48,934 --> 00:40:52,426
high availability of your redis setup

656
00:40:52,458 --> 00:40:56,490
in general. And what you see here is an illustration

657
00:40:56,570 --> 00:41:00,574
from elasticache documentation, but this is applicable to

658
00:41:00,692 --> 00:41:03,634
any setup, whether in the cloud or on prem. Doesn't really matter,

659
00:41:03,672 --> 00:41:07,026
right from a conceptual perspective. And once you

660
00:41:07,048 --> 00:41:10,590
have scaled out your please, please don't

661
00:41:10,670 --> 00:41:14,206
actually forget to make use of those replicas

662
00:41:14,398 --> 00:41:18,262
in your code. That's what matters at the end. And I'm calling this out because

663
00:41:18,396 --> 00:41:22,546
the default behavior in most redis cluster clients,

664
00:41:22,658 --> 00:41:26,294
including the Redis CLI and the go client as well, is to

665
00:41:26,332 --> 00:41:30,202
redirect all the reads to the primary node. Now, if you have

666
00:41:30,256 --> 00:41:33,866
added read replicas to scale traffic with

667
00:41:33,888 --> 00:41:37,546
the default mode, they're actually going to sit idle, believe it

668
00:41:37,568 --> 00:41:42,014
or not. So you need to make sure that you switch to

669
00:41:42,052 --> 00:41:45,854
a mode called the read only mode, wherein it's going to

670
00:41:45,892 --> 00:41:49,818
ensure that the read replicas handle

671
00:41:49,994 --> 00:41:53,690
all the read requests and they are not just passive participants.

672
00:41:53,770 --> 00:41:57,202
Okay, so in the go redis client. You can set this using

673
00:41:57,256 --> 00:42:00,754
this attribute called read only. You just need to set it to

674
00:42:00,792 --> 00:42:05,060
true. Or you can also use this attribute called

675
00:42:05,590 --> 00:42:09,046
route by latency, or randomly routing it to

676
00:42:09,068 --> 00:42:12,422
any node and activating these is going to also

677
00:42:12,476 --> 00:42:15,926
activate the read only mode. So be careful about that and make sure

678
00:42:15,948 --> 00:42:19,734
that you use these or activate

679
00:42:19,782 --> 00:42:23,370
these configuration options. Now, instead of using

680
00:42:23,440 --> 00:42:27,450
consistent hashing like a lot of other distributed systems and databases,

681
00:42:27,790 --> 00:42:31,174
redis actually uses this concept of a hash

682
00:42:31,222 --> 00:42:35,022
slot. Now, there are 16,384

683
00:42:35,076 --> 00:42:38,910
hash slots in total, and a range of hash slots is assigned to each

684
00:42:38,980 --> 00:42:42,542
primary node in your cluster, and each

685
00:42:42,596 --> 00:42:45,754
key belongs to a specific hash slot, and thereby

686
00:42:45,802 --> 00:42:49,298
assigned to actual to a particular node inside

687
00:42:49,384 --> 00:42:52,766
of your cluster. But the thing to know is that multi

688
00:42:52,798 --> 00:42:56,206
key operations executed on a redis cluster

689
00:42:56,318 --> 00:42:59,730
cannot work if they belong to different hash slots,

690
00:42:59,890 --> 00:43:03,074
but you're not completely at the mercy of the redis

691
00:43:03,122 --> 00:43:07,174
cluster. Here it is actually possible to influence the key placement by

692
00:43:07,212 --> 00:43:10,890
using something called hashtags. Of course, we know hashtags

693
00:43:12,110 --> 00:43:14,810
from our social media applications,

694
00:43:15,150 --> 00:43:19,286
but you can ensure that specific keys go to the same hash

695
00:43:19,318 --> 00:43:23,198
slot. So, for example, if you're using storing customer

696
00:43:23,284 --> 00:43:26,622
data with id

697
00:43:26,676 --> 00:43:31,070
42 in a set, storing orders

698
00:43:31,890 --> 00:43:35,874
for a customer in a set, and you have

699
00:43:36,072 --> 00:43:39,602
perhaps the customer profile information in another

700
00:43:39,736 --> 00:43:43,394
hash called customer 42 profile, you can actually use

701
00:43:43,432 --> 00:43:47,970
these curly braces to define which is the specific substring

702
00:43:48,130 --> 00:43:51,366
which your client application uses for the

703
00:43:51,388 --> 00:43:54,914
hashing, right, to allocate to that specific hash

704
00:43:54,962 --> 00:43:59,958
slot. In this case, our keys are customer 42,

705
00:44:00,044 --> 00:44:03,622
right? So we can be confident of the fact that the profile

706
00:44:03,686 --> 00:44:07,338
and the orders for a specific customer are going to land up in

707
00:44:07,344 --> 00:44:11,002
the same hash lot, right? So something to definitely bear in mind

708
00:44:11,056 --> 00:44:14,620
and also apply to your client application code

709
00:44:15,790 --> 00:44:19,246
sharded pops up. This is actually one of my favorite ones, to be honest with

710
00:44:19,268 --> 00:44:22,846
you. My favorite features this was, again,

711
00:44:23,028 --> 00:44:26,014
relatively, I wouldn't say recent, but relatively recent,

712
00:44:26,062 --> 00:44:29,806
because this was introduced in redis seven and it actually helps scale

713
00:44:29,838 --> 00:44:33,662
your traditional pub sub even further. But you'd actually be surprised

714
00:44:33,806 --> 00:44:37,426
by the fact that many folks actually don't know this. And I would

715
00:44:37,448 --> 00:44:41,174
really, really encourage you to check out the documentation that covers this very, very well.

716
00:44:41,292 --> 00:44:45,126
And the usage is very similar. If you have used pubsub in your

717
00:44:45,148 --> 00:44:49,078
client application before, it's very similar to the original subscribe and

718
00:44:49,244 --> 00:44:52,938
publish methods or functions, with the exception that you can now

719
00:44:53,024 --> 00:44:56,714
use those hashtags, right, those braces to

720
00:44:56,752 --> 00:45:01,226
the channel name in order to make sure that you can influence the shard placement

721
00:45:01,418 --> 00:45:05,358
so something definitely, like I said earlier, something to be mindful of

722
00:45:05,444 --> 00:45:08,926
and make sure that you're using the

723
00:45:08,948 --> 00:45:11,790
sharded pub sub in your Redis cluster topology.

724
00:45:13,090 --> 00:45:16,462
Now, there are cases where you need to actually execute bulk operations

725
00:45:16,526 --> 00:45:19,934
on multiple keys across your clusters. Now, the redis

726
00:45:19,982 --> 00:45:23,250
client has a handful of utilities here as well. For example,

727
00:45:23,320 --> 00:45:26,898
as you see this, for each shard function on the

728
00:45:26,904 --> 00:45:30,294
cluster client. And the key thing to note here is the fact that this is

729
00:45:30,332 --> 00:45:34,150
concurrent. This is all going to happen concurrently, so the library actually takes

730
00:45:34,220 --> 00:45:37,734
care of fanning whatever operation you

731
00:45:37,772 --> 00:45:41,590
specify. It fans it out to multiple go routines. Definitely helps with scalability

732
00:45:41,670 --> 00:45:44,966
there. And you can also use this for each primary node,

733
00:45:44,998 --> 00:45:48,298
so there is a function for that too. I think I've forgotten to mention that,

734
00:45:48,304 --> 00:45:49,210
I apologize.

735
00:45:50,750 --> 00:45:53,994
Anyway, so I think we have covered a few

736
00:45:54,032 --> 00:45:57,326
scenarios so far, but in the interest of time, I'm going to pause. There are

737
00:45:57,348 --> 00:46:00,606
a lot more, but I'm going to pause here, like I said, for time

738
00:46:00,708 --> 00:46:04,414
and sort of try and wrap up things. But before

739
00:46:04,452 --> 00:46:07,586
I do that, here are a few resources which

740
00:46:07,608 --> 00:46:11,374
you might find interesting. A link to the GitHub repo

741
00:46:11,422 --> 00:46:14,626
for the redis client I mentioned this before, as well

742
00:46:14,648 --> 00:46:18,070
as the Discord channel where you can interact with the core maintainers,

743
00:46:18,570 --> 00:46:22,120
ask questions, exchange ideas with the community members,

744
00:46:22,570 --> 00:46:26,706
and the documentation. The Redis I actually find the redis documentation

745
00:46:26,898 --> 00:46:30,266
to be very helpful in general. So something which you should

746
00:46:30,368 --> 00:46:33,974
sort of follow very closely once you're building anything with redis.

747
00:46:34,102 --> 00:46:38,566
And in case you're using redis on AWS,

748
00:46:38,758 --> 00:46:42,234
you might perhaps find some of these blog posts

749
00:46:42,282 --> 00:46:46,030
pretty helpful as well in terms of using your best practices and

750
00:46:46,100 --> 00:46:49,146
optimizing your client applications to the fullest

751
00:46:49,338 --> 00:46:52,926
possible. And while I am at it,

752
00:46:52,948 --> 00:46:56,366
while I'm sharing all these resources, I might as well do

753
00:46:56,388 --> 00:47:00,114
a bit of self promotion because I've put a fair bit of content out there.

754
00:47:00,232 --> 00:47:03,954
Perhaps when you see this in future there'll be more. And all these

755
00:47:03,992 --> 00:47:07,314
blog posts and content which I've put out, they all have

756
00:47:07,512 --> 00:47:11,302
individual GitHub repos. You can sort of try everything step by step,

757
00:47:11,356 --> 00:47:15,170
whether you're getting started or you're

758
00:47:15,330 --> 00:47:18,170
interested in learning about good practices.

759
00:47:19,070 --> 00:47:22,646
If you want to build practical solutions or try out advanced

760
00:47:22,678 --> 00:47:26,410
use cases, give it a go and give me feedback.

761
00:47:27,630 --> 00:47:31,398
I would love to hear more and whether there is something specific

762
00:47:31,504 --> 00:47:35,546
you'd like me to cover around redis and go. So please don't hesitate

763
00:47:35,578 --> 00:47:38,846
to reach out to me. All right,

764
00:47:38,948 --> 00:47:42,734
that's that. I really, really hope you found this useful I

765
00:47:42,772 --> 00:47:46,890
would love to have your feedback. It should only take a minute,

766
00:47:46,970 --> 00:47:50,606
I promise. So all you need to do is take out your phone,

767
00:47:50,788 --> 00:47:54,558
scan this QR code, or you can use the link directly here as well.

768
00:47:54,644 --> 00:47:58,402
And once you finish submitting your feedback, you should get a download

769
00:47:58,466 --> 00:48:02,166
link to this presentation as well. So your feedback is actually going to

770
00:48:02,188 --> 00:48:05,894
generally help me improve my content and at the end of the day understand your

771
00:48:05,932 --> 00:48:09,302
needs better. So with that, I'm going to wrap this up.

772
00:48:09,356 --> 00:48:12,786
Thank you once again for tuning in and enjoy the rest of your conference.

