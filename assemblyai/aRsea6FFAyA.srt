1
00:00:19,850 --> 00:00:23,338
Hello gophers and all those who are interested in Goa.

2
00:00:23,434 --> 00:00:26,982
Today I am going to talk about how to concentrate on business

3
00:00:27,036 --> 00:00:31,138
logic by hiding transaction management and using a repository

4
00:00:31,234 --> 00:00:34,518
and unit of work pattern. Small piece of information.

5
00:00:34,684 --> 00:00:38,250
You can find the presentation using QR code at the bottom

6
00:00:38,320 --> 00:00:41,706
left of the slide. All QR code in

7
00:00:41,728 --> 00:00:44,874
the slides are links. Let's continue.

8
00:00:45,072 --> 00:00:49,290
I work at Avita, one of the most popular classifieds in the world.

9
00:00:49,440 --> 00:00:52,730
Our main language is Golang. We use it for more than

10
00:00:52,800 --> 00:00:56,686
a thousand microservices. We use Golang almost

11
00:00:56,788 --> 00:00:59,840
everywhere in cloud and network service,

12
00:01:00,370 --> 00:01:03,742
command line interface DevOps and web development

13
00:01:03,886 --> 00:01:07,582
and we can handle about 300 million visits

14
00:01:07,646 --> 00:01:10,818
per month. That's cool, but we write the application

15
00:01:10,904 --> 00:01:13,730
with business logic, not a benchmark.

16
00:01:14,470 --> 00:01:18,354
My team and I work on smartphone reselling.

17
00:01:18,482 --> 00:01:22,214
That complex domain includes more than 20 states where

18
00:01:22,252 --> 00:01:25,650
phone cases from a seller to a buyer through verification,

19
00:01:25,810 --> 00:01:29,750
repair, adding of warranty and delivery. Nevertheless,

20
00:01:29,830 --> 00:01:32,906
I will use another domain as an example on the

21
00:01:32,928 --> 00:01:36,060
slide, the all known domain of the shop.

22
00:01:36,910 --> 00:01:40,870
Unfortunately, we cannot directly use approach from other languages

23
00:01:40,950 --> 00:01:44,554
in Go because of the error handling. The small

24
00:01:44,592 --> 00:01:48,394
disclaimer here is the most of the year handling in the slide

25
00:01:48,442 --> 00:01:52,174
is hidden instead of full error processing. I will

26
00:01:52,212 --> 00:01:56,674
hide if with checking from the slide then

27
00:01:56,792 --> 00:02:00,366
Go is not conventionally object oriented language.

28
00:02:00,478 --> 00:02:03,950
Go has unique insign into interfaces,

29
00:02:04,110 --> 00:02:07,246
no inheritance, no protected access modification

30
00:02:07,358 --> 00:02:10,806
and others. Also Go is young

31
00:02:10,988 --> 00:02:15,154
programming language and there are no ready libraries

32
00:02:15,202 --> 00:02:19,206
to build an enterprise application. Despite these reasons

33
00:02:19,238 --> 00:02:22,954
and the difference between Go and other languages, we can use some

34
00:02:22,992 --> 00:02:26,214
concepts from them. Let's see the repository pattern

35
00:02:26,262 --> 00:02:29,978
in Golem. The repository has a simple interface and

36
00:02:30,064 --> 00:02:33,454
hides saving, getting and mapping data from

37
00:02:33,492 --> 00:02:37,774
the database that help us to concentrate on business

38
00:02:37,972 --> 00:02:41,962
domain instead of database. We don't add validation

39
00:02:42,026 --> 00:02:46,050
of usernames, product count in an order

40
00:02:46,200 --> 00:02:49,714
or other business rules because the implementation of

41
00:02:49,752 --> 00:02:54,210
the concrete repository is not a part of the domain.

42
00:02:55,130 --> 00:02:58,886
The repository should work with only one model. If we

43
00:02:58,908 --> 00:03:02,662
add several models to the repository, we create a

44
00:03:02,716 --> 00:03:06,898
super repository which is difficult to modify,

45
00:03:07,074 --> 00:03:09,370
extend and testing.

46
00:03:10,030 --> 00:03:13,674
The sequence diagram for any repository looks like

47
00:03:13,712 --> 00:03:17,670
that. When we call the repositories method,

48
00:03:17,830 --> 00:03:21,146
we convert data from domain

49
00:03:21,178 --> 00:03:25,082
view to database or vice versa. Then we receive

50
00:03:25,146 --> 00:03:27,946
or save data in the database.

51
00:03:28,138 --> 00:03:31,758
However, the repository can use data

52
00:03:31,924 --> 00:03:35,090
mapper pattern if we have a complex model

53
00:03:35,240 --> 00:03:39,150
and the repository will work with a data mapper

54
00:03:39,230 --> 00:03:42,370
instead of direct calling the database.

55
00:03:43,190 --> 00:03:46,440
The description is simple, but what is inside?

56
00:03:47,450 --> 00:03:51,554
We little modify the repository interface

57
00:03:51,602 --> 00:03:55,494
to our model and that's still simple. Then suppose we

58
00:03:55,532 --> 00:04:00,058
have a user with username password and data data and

59
00:04:00,144 --> 00:04:03,802
each user have profile information about avatar first

60
00:04:03,856 --> 00:04:07,366
and last names, et cetera and Zed's

61
00:04:07,398 --> 00:04:10,478
knowledge belongs to a user model. However,

62
00:04:10,564 --> 00:04:15,050
we store this data in database as two different tables.

63
00:04:15,210 --> 00:04:18,974
The repository includes machinery to hide the difference and

64
00:04:19,012 --> 00:04:23,150
help us think more about the domain, not the database.

65
00:04:23,990 --> 00:04:28,094
On the left side of the slide you can see domain

66
00:04:28,142 --> 00:04:31,986
view of the model and on the right side you can see

67
00:04:32,088 --> 00:04:35,814
database view of the model and you

68
00:04:35,852 --> 00:04:39,270
see that's different and repository help us

69
00:04:39,340 --> 00:04:42,040
to hide it.

70
00:04:42,810 --> 00:04:46,422
Let's see an example. This is getting model I use

71
00:04:46,476 --> 00:04:50,410
SQlix to review the code of data mapping from

72
00:04:50,480 --> 00:04:54,090
a database. When the app receives data after

73
00:04:54,160 --> 00:04:58,134
receiving, we have a database view in the user

74
00:04:58,182 --> 00:05:02,222
row and profile row. Then we convert data in

75
00:05:02,276 --> 00:05:06,554
a domain view as a single model user with a nested

76
00:05:06,602 --> 00:05:10,666
profile model. In the save method, we convert

77
00:05:10,698 --> 00:05:13,998
the data view in the database and then save data.

78
00:05:14,164 --> 00:05:17,582
I use an insert and update in one query

79
00:05:17,646 --> 00:05:21,662
to place it in one slide. Then we use two tables

80
00:05:21,726 --> 00:05:25,714
and we need to add transactions to prevent corrupting

81
00:05:25,762 --> 00:05:29,222
data if a problem happens in gap between two

82
00:05:29,276 --> 00:05:33,062
updates. Comments leads Disclaimer I

83
00:05:33,196 --> 00:05:36,486
simplify models to a few fields in the

84
00:05:36,508 --> 00:05:40,362
next slides to feed code on a slide now

85
00:05:40,416 --> 00:05:44,042
we have a user repository. Next our business tell us

86
00:05:44,096 --> 00:05:47,834
to register a user. We create the message

87
00:05:47,952 --> 00:05:51,434
register, add validation method

88
00:05:51,562 --> 00:05:55,630
and save a model with the registry.

89
00:05:56,850 --> 00:06:00,686
Then the product tell us that we must notify the

90
00:06:00,708 --> 00:06:04,510
new user about registration. For that purpose.

91
00:06:04,590 --> 00:06:08,020
We publish a message in queue about that.

92
00:06:08,390 --> 00:06:11,586
However, we can catch an issue when

93
00:06:11,608 --> 00:06:15,750
the queue goes down. We save data in the database and

94
00:06:15,900 --> 00:06:19,960
load the message. This situation is unacceptable for us.

95
00:06:20,890 --> 00:06:24,534
Let's cover saving data and publishing with a

96
00:06:24,572 --> 00:06:28,374
transaction to prevent it. These are just two lines.

97
00:06:28,502 --> 00:06:31,674
The first one is to begin the

98
00:06:31,712 --> 00:06:35,146
transaction and other one to commit. But we

99
00:06:35,168 --> 00:06:38,810
should explicitly pass the transaction to the

100
00:06:38,880 --> 00:06:41,630
repository and publish method.

101
00:06:43,010 --> 00:06:46,286
Passing the transaction in the repository complexity the

102
00:06:46,308 --> 00:06:49,710
code with additional knowledge. They say knowledge is power.

103
00:06:49,860 --> 00:06:53,342
However in this case additional knowledge is not about

104
00:06:53,396 --> 00:06:57,250
power, it's just complication for complication sake.

105
00:06:58,310 --> 00:07:02,142
And we change our repository interface by adding knowledge

106
00:07:02,206 --> 00:07:06,874
about the database transaction. That makes our repository nonel.

107
00:07:06,942 --> 00:07:10,374
But we get atomic registration. It's not a big

108
00:07:10,412 --> 00:07:14,182
deal. We now have a registration but the app

109
00:07:14,236 --> 00:07:17,910
can just create a user. Businesses want to sell

110
00:07:17,980 --> 00:07:22,178
goods and we already matter. And easy making new

111
00:07:22,204 --> 00:07:25,290
repository with getting and saving methods.

112
00:07:25,870 --> 00:07:28,966
Then we create a new use case with validation,

113
00:07:29,078 --> 00:07:32,606
saving and message publication in a

114
00:07:32,628 --> 00:07:36,074
transaction. And now we see our elegant solution

115
00:07:36,122 --> 00:07:40,062
with transaction registration and buying while

116
00:07:40,116 --> 00:07:44,302
the developers are daydreaming, being perfectly

117
00:07:44,366 --> 00:07:48,082
contempt with the result of their work, business comes

118
00:07:48,136 --> 00:07:51,854
to them and demands a new scenario to increase the conversion

119
00:07:51,902 --> 00:07:56,450
of new users into our customers. Throw purchase

120
00:07:56,530 --> 00:08:00,310
without completed registration. That is technique when

121
00:08:00,380 --> 00:08:04,950
users can buy things on the site without authorization

122
00:08:05,290 --> 00:08:09,560
and by just typing email or phone number only.

123
00:08:10,650 --> 00:08:14,666
Let's see on the hides. An attentive listener may have

124
00:08:14,768 --> 00:08:17,580
already noticed the issue in the code.

125
00:08:18,030 --> 00:08:22,570
The solution is the same as for the two previous scenarios.

126
00:08:22,730 --> 00:08:26,494
We add control, transaction control and passing the

127
00:08:26,532 --> 00:08:29,770
transaction in the use cases in. Additionally,

128
00:08:29,850 --> 00:08:33,758
we complicate transaction control inside the use cases.

129
00:08:33,934 --> 00:08:37,566
The two lines are changed to if else to decide

130
00:08:37,678 --> 00:08:41,554
whether the flow is on the top level or it

131
00:08:41,592 --> 00:08:45,380
was called something else and it's not good.

132
00:08:45,930 --> 00:08:50,502
But as we know, with great business logics comes

133
00:08:50,636 --> 00:08:54,210
great legacy. Let me briefly

134
00:08:54,370 --> 00:08:58,122
recap what we have here. First, we have

135
00:08:58,176 --> 00:09:01,754
nested transaction use cases and that's cool.

136
00:09:01,952 --> 00:09:05,366
However, the transaction spread everywhere.

137
00:09:05,558 --> 00:09:09,114
That forces us to duplicate the routine code to

138
00:09:09,152 --> 00:09:12,670
control them. Duplication adds an increased

139
00:09:13,330 --> 00:09:17,246
chance of making mistakes. Also, if we want

140
00:09:17,268 --> 00:09:21,658
to change the database, we must change the app in many places.

141
00:09:21,834 --> 00:09:25,422
Now I won't rephrase our issues to our wishes.

142
00:09:25,566 --> 00:09:29,762
The first one is an EDL repository for

143
00:09:29,816 --> 00:09:32,914
simple work with the database. Second,

144
00:09:33,032 --> 00:09:36,626
the use cases are transactional and nested.

145
00:09:36,738 --> 00:09:40,342
I want to save different models in the single scenario without

146
00:09:40,396 --> 00:09:44,326
thinking about how to open close the transaction and

147
00:09:44,508 --> 00:09:47,834
rollback it on error. The third is

148
00:09:47,872 --> 00:09:49,770
supporting nested use cases.

149
00:09:51,230 --> 00:09:54,678
Now I won't rephrase our issues in our wishes.

150
00:09:54,774 --> 00:09:58,298
The first one is an EDEL repository for simple

151
00:09:58,384 --> 00:10:02,302
work with the database. Second, the use cases arent

152
00:10:02,356 --> 00:10:06,218
transactional and nested. I want to save different models

153
00:10:06,314 --> 00:10:09,374
in a single scenario without thinking about how to

154
00:10:09,412 --> 00:10:13,390
open close the transaction and roll back it on error.

155
00:10:13,750 --> 00:10:17,522
Also, I want to hide transaction control and

156
00:10:17,576 --> 00:10:21,170
finally I want to replace the database easily.

157
00:10:21,510 --> 00:10:25,050
We already have some wishes done as nested transactional

158
00:10:25,150 --> 00:10:28,598
use cases, but we need to get the others.

159
00:10:28,764 --> 00:10:31,320
Let's try to hide transaction control.

160
00:10:31,850 --> 00:10:35,382
The simple solution is using closure, but where

161
00:10:35,436 --> 00:10:39,510
should we place it? We can add closure in the repository.

162
00:10:39,670 --> 00:10:43,622
We call our scenario in the transaction, get the user

163
00:10:43,686 --> 00:10:47,114
and the order as a result and

164
00:10:47,152 --> 00:10:50,782
then save them. However, I hoped that

165
00:10:50,836 --> 00:10:53,790
you will be skeptical about this solution.

166
00:10:54,290 --> 00:10:57,866
First, we still should pass transactions in the repository,

167
00:10:57,978 --> 00:11:00,874
in this case in the order repository.

168
00:11:01,002 --> 00:11:04,462
Another problem is that for each new scenario

169
00:11:04,526 --> 00:11:08,574
we need to code a new closure with new range of models.

170
00:11:08,702 --> 00:11:11,842
And the last problem is that over time our

171
00:11:11,896 --> 00:11:16,562
scenario will became more complex and the user repository

172
00:11:16,706 --> 00:11:21,602
would be smarty and it would know about almost everywhere

173
00:11:21,746 --> 00:11:24,614
a model in the app. As a result,

174
00:11:24,732 --> 00:11:28,522
we would need much more time to extend and

175
00:11:28,576 --> 00:11:32,490
test our apps functionally. However,

176
00:11:32,560 --> 00:11:36,794
we can move the closer to a separate function and see the result at

177
00:11:36,832 --> 00:11:40,234
first sight with transaction is just a copy code from the

178
00:11:40,272 --> 00:11:43,706
use case. Take a look at transaction control pros in

179
00:11:43,728 --> 00:11:46,618
the closer and register scenario.

180
00:11:46,794 --> 00:11:49,934
Let's simplify our scenario. With closure we

181
00:11:49,972 --> 00:11:53,490
replace it lines onto and decrease the

182
00:11:53,560 --> 00:11:57,266
chance of create a bug. The code is

183
00:11:57,288 --> 00:12:01,186
entirely placed on the slide and looks better than it was

184
00:12:01,288 --> 00:12:04,942
and I hope you agree with me. However, our code

185
00:12:05,016 --> 00:12:08,274
is still bound with the SqLix Tx transaction.

186
00:12:08,402 --> 00:12:11,574
As a result, we can only change the database by

187
00:12:11,612 --> 00:12:15,094
rewriting all use cases and somebody can make

188
00:12:15,132 --> 00:12:18,890
mistakes by handling control of a transaction.

189
00:12:19,230 --> 00:12:22,874
Next, I want to hide passing the transaction in

190
00:12:22,912 --> 00:12:26,442
the repository. To do that, we can use the

191
00:12:26,496 --> 00:12:30,674
factory method in the repository which enrichs

192
00:12:30,822 --> 00:12:35,178
our repository with a transaction, the factory method

193
00:12:35,354 --> 00:12:40,250
getting the transaction and save it in our repository

194
00:12:40,410 --> 00:12:43,822
and then we can use the saved

195
00:12:43,966 --> 00:12:46,830
transaction in our methods.

196
00:12:46,990 --> 00:12:51,406
The code in the getting and save methods will change slightly.

197
00:12:51,518 --> 00:12:55,422
We replace one if condition on the

198
00:12:55,496 --> 00:12:59,046
single line. Nevertheless, I am eager to

199
00:12:59,068 --> 00:13:02,662
see how our use case would look after

200
00:13:02,796 --> 00:13:06,530
updates. We call this transaction

201
00:13:06,690 --> 00:13:09,994
repository method and then the use case is not

202
00:13:10,032 --> 00:13:13,594
changed. Is that better than it was?

203
00:13:13,792 --> 00:13:17,370
Unfortunately no. We add time dependency colon.

204
00:13:19,070 --> 00:13:23,706
We must call repository methods only after factory method

205
00:13:23,818 --> 00:13:27,182
and I don't think it's cool. Could we use

206
00:13:27,236 --> 00:13:31,070
reflection in this case to remove the time dependency.

207
00:13:31,730 --> 00:13:35,706
Let's use a function with repositories as argument

208
00:13:35,818 --> 00:13:39,854
in this transaction. We pass it in our closer,

209
00:13:39,902 --> 00:13:42,994
then the reflection retrieves a list

210
00:13:43,032 --> 00:13:46,802
of repositories and calls the method

211
00:13:46,866 --> 00:13:49,480
with transaction to enrich them.

212
00:13:49,850 --> 00:13:53,286
As a result, we remove an argument with a

213
00:13:53,308 --> 00:13:56,278
transaction in repository method. However,

214
00:13:56,444 --> 00:14:00,362
reflection is not a golden way and we still

215
00:14:00,416 --> 00:14:03,594
should pass the transaction in the use cases and the

216
00:14:03,632 --> 00:14:07,302
queue. Also, explicit passing spreads knowledge

217
00:14:07,366 --> 00:14:11,662
about the database through the application and

218
00:14:11,796 --> 00:14:15,374
where we can to store a transaction. Let's see how other

219
00:14:15,412 --> 00:14:18,320
languages solve this issue.

220
00:14:18,850 --> 00:14:23,070
In Python, the passing depends on a library.

221
00:14:23,750 --> 00:14:27,422
In SQL alchemy, we cases the transaction explicitly

222
00:14:27,486 --> 00:14:30,674
as a function argument and we already have

223
00:14:30,712 --> 00:14:33,550
it. Solution in Django,

224
00:14:33,630 --> 00:14:37,386
transactions are stored in a global variable because Django

225
00:14:37,438 --> 00:14:40,194
processes one request in one thread.

226
00:14:40,322 --> 00:14:44,070
PHP uses the same approaches because it does not have

227
00:14:44,140 --> 00:14:47,390
multi threads processing at all. Unfortunately,

228
00:14:47,570 --> 00:14:51,098
it's not our solution at all and

229
00:14:51,184 --> 00:14:54,922
fortunately go can work with multiple threads by

230
00:14:54,976 --> 00:14:58,842
Go routines. More enterprise languages such as

231
00:14:58,896 --> 00:15:02,894
Java or C sharp use thread local storage that

232
00:15:02,932 --> 00:15:07,150
is similar to the global variable but limited by a single thread.

233
00:15:07,570 --> 00:15:11,578
But where to store a transaction in go passing

234
00:15:11,674 --> 00:15:15,458
as an arent is not our solution. We want to

235
00:15:15,464 --> 00:15:18,834
hides a transaction to provide high coupling use

236
00:15:18,872 --> 00:15:22,818
cases with a database. We have Gorotine and

237
00:15:22,904 --> 00:15:27,638
God doesn't support built in Gorotin local

238
00:15:27,724 --> 00:15:31,234
storage. Could we create a similar solution

239
00:15:31,282 --> 00:15:35,080
by Gorotine Id? And the answer is probably no.

240
00:15:35,610 --> 00:15:39,474
Golang does not allow us to get a gorotine id directly.

241
00:15:39,602 --> 00:15:43,534
Go experts don't recommend using Gorotine

242
00:15:43,682 --> 00:15:47,562
because it contradicts Golang Way and they

243
00:15:47,616 --> 00:15:51,434
want to prevent building applications that associated

244
00:15:51,562 --> 00:15:55,342
all consumption with a single gorotine. And now we should

245
00:15:55,396 --> 00:15:59,514
use hacks to get an id. Also, new language

246
00:15:59,562 --> 00:16:03,234
updates can break the hacks and no one

247
00:16:03,272 --> 00:16:06,286
can guarantee the stability of the solution.

248
00:16:06,478 --> 00:16:10,574
However, some libraries implementations Gortin

249
00:16:10,702 --> 00:16:14,210
local storage but all of them arent built on the

250
00:16:14,280 --> 00:16:18,070
hacks and most arent not my intended.

251
00:16:18,970 --> 00:16:22,454
Fortunately we are not in 2016 and we

252
00:16:22,492 --> 00:16:26,518
have the context package that can be used

253
00:16:26,604 --> 00:16:30,266
to store the transaction. However, there are

254
00:16:30,288 --> 00:16:34,182
opinions that storing something more than primitive types

255
00:16:34,246 --> 00:16:36,460
in a context is a bad idea.

256
00:16:39,470 --> 00:16:43,550
That means should we reinvent the wheel?

257
00:16:44,370 --> 00:16:48,186
Fortunately not some experts articles

258
00:16:48,378 --> 00:16:52,346
there is an exception for the specific

259
00:16:52,468 --> 00:16:56,562
values to be scoped to the request and destroyed after

260
00:16:56,616 --> 00:16:59,666
request. That gives us the ability to

261
00:16:59,688 --> 00:17:03,170
use context to store a transaction inside

262
00:17:03,320 --> 00:17:06,390
the context. Excellent. We have a place

263
00:17:06,460 --> 00:17:09,890
for our transaction. Let's look at our closer.

264
00:17:09,970 --> 00:17:13,990
That's not so bad. We check a transaction in the context.

265
00:17:14,890 --> 00:17:18,522
If not, we create and put a new transaction in

266
00:17:18,576 --> 00:17:22,278
context. In the use cases, we replace the transaction

267
00:17:22,374 --> 00:17:26,122
with a new context. Then we add

268
00:17:26,176 --> 00:17:30,222
getting a transaction from the context in the repository to work

269
00:17:30,276 --> 00:17:33,680
with the database. Also, we create a

270
00:17:35,170 --> 00:17:38,494
TR interface to replace direct

271
00:17:38,612 --> 00:17:42,910
database connection on a transaction and vice versa.

272
00:17:44,070 --> 00:17:48,286
Now we have a simple repository interface without the explicit

273
00:17:48,318 --> 00:17:52,430
transaction argument and nested transactional use cases,

274
00:17:52,590 --> 00:17:56,474
we can forgot about transaction control by using transaction

275
00:17:56,542 --> 00:18:00,070
closure in. Additionally, we concentrate on working

276
00:18:00,140 --> 00:18:04,274
with database in closure and repository

277
00:18:04,402 --> 00:18:07,782
and can replace that database without changing use

278
00:18:07,836 --> 00:18:11,478
cases. However, we have a problem with closure,

279
00:18:11,654 --> 00:18:15,386
which is difficult to test because we cannot create a mock or

280
00:18:15,408 --> 00:18:18,710
stop for a function and a global variable

281
00:18:18,870 --> 00:18:22,414
works with a database. Also, we need to

282
00:18:22,452 --> 00:18:26,046
rewrite use cases to add a new closure or replace the

283
00:18:26,068 --> 00:18:29,662
current one. Let's fix it. We must

284
00:18:29,716 --> 00:18:33,534
convert with transaction closure in a structure

285
00:18:33,582 --> 00:18:36,878
with an interface. The structure allows

286
00:18:36,974 --> 00:18:40,962
us to create a mock and path that database as an arent instead

287
00:18:41,016 --> 00:18:45,022
of global variable. Let's name the interface manage

288
00:18:45,176 --> 00:18:49,234
to do function calls, do with settings with default settings

289
00:18:49,282 --> 00:18:53,062
and do with settings. Control a transaction as with

290
00:18:53,116 --> 00:18:56,786
transaction with additional features such as nested

291
00:18:56,818 --> 00:18:59,894
transaction readonly transaction timeout,

292
00:19:00,022 --> 00:19:04,534
et cetera. Then we introduce a generic

293
00:19:04,662 --> 00:19:07,846
general interface transaction which can commit

294
00:19:07,878 --> 00:19:11,246
rollback, show the transaction status and return

295
00:19:11,348 --> 00:19:15,194
an actual transaction. Also we have the interface

296
00:19:15,242 --> 00:19:18,378
to create nested transactions if a database supports

297
00:19:18,394 --> 00:19:22,202
them. Also we adding the settings

298
00:19:22,266 --> 00:19:26,450
interface store standard configurations for different databases.

299
00:19:26,790 --> 00:19:30,942
We implementations new settings for each database transaction

300
00:19:31,006 --> 00:19:34,910
because different database have their configurations and

301
00:19:35,000 --> 00:19:38,614
abilities. We cases settings in

302
00:19:38,652 --> 00:19:41,922
specific interface to configuration the transaction

303
00:19:42,066 --> 00:19:46,054
in a factory. It's time to see what we have

304
00:19:46,092 --> 00:19:49,862
in the use case. Manager replaces this transaction

305
00:19:49,926 --> 00:19:53,274
and visually everything changes. However, we can

306
00:19:53,312 --> 00:19:57,158
mock manager or our staff for testing

307
00:19:57,334 --> 00:20:00,942
in Java. We can hides the transaction from the use case by

308
00:20:00,996 --> 00:20:04,430
annotation or XML configuration.

309
00:20:05,010 --> 00:20:08,782
We can do the same in go by reflection code

310
00:20:08,836 --> 00:20:12,910
generation. Some tricks with generic or just decorator

311
00:20:13,750 --> 00:20:17,474
a simple decorator on the slide, but we should create a new

312
00:20:17,512 --> 00:20:21,090
decorator for each use case. It's not hard

313
00:20:21,160 --> 00:20:24,546
but it's so boring. Let's try to

314
00:20:24,568 --> 00:20:28,534
use generic decorator. To get

315
00:20:28,572 --> 00:20:32,274
generic decorator, we should use trick. The trick

316
00:20:32,322 --> 00:20:35,590
consists of using the structure for

317
00:20:35,660 --> 00:20:39,382
arguments of the use case and naming the method

318
00:20:39,446 --> 00:20:41,770
identical in all use cases.

319
00:20:42,830 --> 00:20:46,010
In our case we use the name handle.

320
00:20:46,750 --> 00:20:51,470
Then we create an interface which match our

321
00:20:51,540 --> 00:20:55,578
use cases. The structure gives us the ability

322
00:20:55,674 --> 00:20:59,598
to create the generic interface which can work with any

323
00:20:59,684 --> 00:21:03,678
use cases. After that we implement

324
00:21:03,854 --> 00:21:08,210
a decorator by using the interface and generic.

325
00:21:09,430 --> 00:21:12,558
The decorator is not idiot generic,

326
00:21:12,654 --> 00:21:15,854
but we can easily implement it

327
00:21:15,992 --> 00:21:20,950
and remove routine code. Writing the

328
00:21:21,020 --> 00:21:24,790
using of the decorator is simple and

329
00:21:24,940 --> 00:21:26,790
presented on the slide.

330
00:21:27,710 --> 00:21:31,546
Then we can simplify getting a transaction from the context in

331
00:21:31,568 --> 00:21:34,794
their repository. Let's create an

332
00:21:34,832 --> 00:21:38,470
interface to extract the transaction. The default

333
00:21:38,550 --> 00:21:42,794
method returns a transaction with the default context

334
00:21:42,842 --> 00:21:46,446
k and thereby k returns a

335
00:21:46,468 --> 00:21:50,078
custom k. It is

336
00:21:50,244 --> 00:21:55,182
necessary when the repository process two transactions simultaneously,

337
00:21:55,326 --> 00:21:59,298
but be careful with that. Also, when we create

338
00:21:59,384 --> 00:22:03,342
context manager, we set the default k to have the ability

339
00:22:03,406 --> 00:22:07,270
to change the k without changing code in the repository.

340
00:22:07,690 --> 00:22:11,058
However, we should cast transaction in the transaction

341
00:22:11,154 --> 00:22:15,074
structure of the database to work with it and casting

342
00:22:15,202 --> 00:22:19,290
is not safe. We can create an interface for each

343
00:22:19,360 --> 00:22:23,146
database to skip casting in the repository. In the

344
00:22:23,168 --> 00:22:26,874
first iteration, the saving methods look like that.

345
00:22:27,072 --> 00:22:30,986
Let's use SQL context manager in the repository.

346
00:22:31,178 --> 00:22:34,650
This simplifies the code a bit and reduces

347
00:22:34,730 --> 00:22:39,114
the chance of error. Let me briefly recap

348
00:22:39,242 --> 00:22:43,090
what we have. We kept the transaction interface simple

349
00:22:43,160 --> 00:22:46,994
by hiding the transaction in the context. We get

350
00:22:47,032 --> 00:22:50,722
transaction operation nested use cases and

351
00:22:50,776 --> 00:22:54,270
hiding transaction by the transaction manager.

352
00:22:54,430 --> 00:22:58,194
And also we can migrate to another database without changing

353
00:22:58,242 --> 00:23:01,926
use cases. And finally, the solution does

354
00:23:01,948 --> 00:23:03,990
not create a problem with testing,

355
00:23:04,890 --> 00:23:08,970
but what did it cost? Fortunately not

356
00:23:09,040 --> 00:23:12,954
everything. The solution works only on the Go

357
00:23:13,072 --> 00:23:16,906
1.13 version which was

358
00:23:17,008 --> 00:23:20,254
released in the 2019. It was not

359
00:23:20,292 --> 00:23:23,722
so long ago. Nevertheless, Go is updated

360
00:23:23,786 --> 00:23:28,030
by a minor version and I hope you have already updated or

361
00:23:28,100 --> 00:23:31,214
it is not problem for you.

362
00:23:31,412 --> 00:23:34,606
Also there are a few ready transaction adaptations

363
00:23:34,718 --> 00:23:37,662
such as SQL, SQL leaks, Gorm,

364
00:23:37,726 --> 00:23:41,026
Mongo and Redis, but you can write

365
00:23:41,128 --> 00:23:45,890
new adaptations by 70 code offlines.

366
00:23:46,570 --> 00:23:49,874
The next disadvantage is losing performance.

367
00:23:50,002 --> 00:23:53,654
The first benchmark shows that the difference with and

368
00:23:53,692 --> 00:23:57,800
without the solution is about 3.4%.

369
00:23:58,110 --> 00:24:02,314
The result was impressive but the reason was SQL mock the

370
00:24:02,352 --> 00:24:05,446
library for mocking SQL requests.

371
00:24:05,638 --> 00:24:08,650
SQL mock consumes a lot of resources.

372
00:24:09,230 --> 00:24:12,574
Therefore I decided to rewrite the benchmark on

373
00:24:12,612 --> 00:24:16,414
SQL Lite in memory. The result was more natural and

374
00:24:16,452 --> 00:24:19,758
the difference is about 18%. However,

375
00:24:19,844 --> 00:24:23,554
most applications which I have seen use database that

376
00:24:23,592 --> 00:24:27,458
store data on disk or are dedicated on another

377
00:24:27,544 --> 00:24:30,898
server. For that reason I

378
00:24:31,064 --> 00:24:34,546
wrote benchmark with MySQL on the

379
00:24:34,568 --> 00:24:38,418
same server. The file system has added overhead

380
00:24:38,514 --> 00:24:41,638
and the solution takes the same amount of the time as

381
00:24:41,724 --> 00:24:44,850
code. Without the transaction manager,

382
00:24:45,010 --> 00:24:48,994
the network would consume significantly more time than the file

383
00:24:49,042 --> 00:24:53,002
systems which mean the overhead of the

384
00:24:53,056 --> 00:24:56,742
solution would be minor. The other disadvantage

385
00:24:56,806 --> 00:25:00,314
is that we should pass context everywhere. I hope you

386
00:25:00,352 --> 00:25:04,030
already use context in applications to store request id

387
00:25:04,100 --> 00:25:07,614
or other data for login or to cancel a request if a

388
00:25:07,652 --> 00:25:11,434
user closes a connection. Therefore passing context

389
00:25:11,482 --> 00:25:14,962
is acceptable for you. The last and most

390
00:25:15,016 --> 00:25:18,530
considerable drawback is that we cannot do a long business

391
00:25:18,600 --> 00:25:22,242
transaction because the transaction in the database takes

392
00:25:22,296 --> 00:25:25,562
a connection and limited database resources.

393
00:25:25,726 --> 00:25:29,890
That can happen when we call external services thoroughly.

394
00:25:30,050 --> 00:25:33,750
The simple solution is to request all data before

395
00:25:33,820 --> 00:25:37,302
the transaction, but we lose the ability to simple

396
00:25:37,356 --> 00:25:40,300
insert a use case into another.

397
00:25:41,630 --> 00:25:45,706
And another solution is the unit of work pattern which I

398
00:25:45,728 --> 00:25:50,226
will discuss later. Now we can see and repeat the drawbacks.

399
00:25:50,278 --> 00:25:54,014
The first is a limitation of the

400
00:25:54,052 --> 00:25:57,600
Golang version when the solution can work.

401
00:25:58,050 --> 00:26:01,230
The next one is that there are only five

402
00:26:01,300 --> 00:26:05,386
adapters but there are more than five database drivers

403
00:26:05,418 --> 00:26:08,914
and orms in go. However, only 70 new

404
00:26:08,952 --> 00:26:12,642
hides can solve it. Third one,

405
00:26:12,696 --> 00:26:16,246
the solution consumes about 17% more than

406
00:26:16,428 --> 00:26:19,830
without it or five microseconds.

407
00:26:20,170 --> 00:26:24,214
Next one is passing context everywhere. And finally,

408
00:26:24,332 --> 00:26:28,146
the solution does not support long business transactions,

409
00:26:28,258 --> 00:26:31,100
but the unit of work pattern can solve it.

410
00:26:31,870 --> 00:26:35,306
Let's take a look at what was and what is

411
00:26:35,328 --> 00:26:39,206
now in the code. We remove the storing connection

412
00:26:39,318 --> 00:26:43,418
of the database with the repository interface by hiding

413
00:26:43,514 --> 00:26:46,778
a transaction in context in a repository,

414
00:26:46,874 --> 00:26:50,926
we replace checking an existing transaction with

415
00:26:51,108 --> 00:26:54,674
context manager code is shorter than it was and

416
00:26:54,712 --> 00:26:57,650
now it's harder for us to make mistakes.

417
00:26:58,310 --> 00:27:02,222
Then we can skip a massive block of database infrastructure

418
00:27:02,286 --> 00:27:05,782
to focus on business actions in

419
00:27:05,836 --> 00:27:09,154
use case. The chart on the slide

420
00:27:09,202 --> 00:27:12,902
shows the dependence of the number of additional lines on the

421
00:27:12,956 --> 00:27:17,110
number of nested scenarios. The red line presents data

422
00:27:17,180 --> 00:27:20,870
without the solution. The green lines is for the solution.

423
00:27:21,030 --> 00:27:25,034
The cross point is 1.8 when road code

424
00:27:25,152 --> 00:27:28,890
loses in comparison to the solution

425
00:27:29,390 --> 00:27:33,360
regarding the amount of additional code in a use case.

426
00:27:33,890 --> 00:27:37,454
In addition, not only the count of code is

427
00:27:37,492 --> 00:27:41,038
growing when adding nesting use cases, the chance

428
00:27:41,124 --> 00:27:45,074
of making bugs and cognitive load on

429
00:27:45,112 --> 00:27:48,834
developers is increasing too. Nevertheless, I give

430
00:27:48,872 --> 00:27:52,242
you a tool and you decide whether to use it

431
00:27:52,296 --> 00:27:56,338
or not. The link to the library is in

432
00:27:56,344 --> 00:27:59,814
the last slide. Now I want to go back

433
00:27:59,852 --> 00:28:03,254
to the long transaction drawback. I mentioned that

434
00:28:03,292 --> 00:28:06,406
the unit of fork could solve it. The interface of

435
00:28:06,428 --> 00:28:10,566
the pattern for Golang on the slide. Let's describe

436
00:28:10,678 --> 00:28:14,362
each method. Register new

437
00:28:14,496 --> 00:28:18,582
marks a model as new, register dirty marks

438
00:28:18,646 --> 00:28:23,082
a model as dirty or updated. Register clean marks

439
00:28:23,146 --> 00:28:27,166
a model as clean of getting from database without changes

440
00:28:27,348 --> 00:28:30,830
and register delete marks model

441
00:28:30,900 --> 00:28:35,774
as deleted. Then comet saves

442
00:28:35,822 --> 00:28:39,726
data atomically in a database in one transaction

443
00:28:39,838 --> 00:28:43,986
and finally roll back reset state

444
00:28:44,168 --> 00:28:47,442
to initial or previous success commit

445
00:28:47,586 --> 00:28:51,014
okay, we know what each method does,

446
00:28:51,132 --> 00:28:54,054
but how and when can we use it?

447
00:28:54,172 --> 00:28:56,760
Let's see the definition to catch it.

448
00:28:57,390 --> 00:29:00,874
Martin Fowler defines a pattern as maintaining a list

449
00:29:00,912 --> 00:29:04,586
of objects affected by a business transaction and

450
00:29:04,688 --> 00:29:08,026
coordinating the writing out of changes and

451
00:29:08,128 --> 00:29:11,120
the resolution of concurrency problems.

452
00:29:11,490 --> 00:29:15,322
The first fun fact about the definition I mentioned concurrency

453
00:29:15,386 --> 00:29:18,842
problems which are situated with the database,

454
00:29:18,986 --> 00:29:22,714
but they are resolved by pessimistic or optimistic

455
00:29:22,762 --> 00:29:26,770
lock and it's not a part of the unit of work. The second

456
00:29:26,840 --> 00:29:30,302
one, in the original book pattern of enterprise

457
00:29:30,366 --> 00:29:33,890
application architecture, where the pattern was written,

458
00:29:34,310 --> 00:29:37,570
there is no rollback method.

459
00:29:38,870 --> 00:29:42,038
Let's understand what does pattern give us first,

460
00:29:42,204 --> 00:29:45,554
that gives batch changes in the database,

461
00:29:45,682 --> 00:29:49,178
which can be significantly faster than sending each change

462
00:29:49,264 --> 00:29:52,730
individually. We can optimize insert by

463
00:29:52,800 --> 00:29:56,698
insert into values with multiple rows and

464
00:29:56,784 --> 00:30:00,554
other commands by removing network overhead on

465
00:30:00,592 --> 00:30:04,458
each command sending. Also, we can only update

466
00:30:04,554 --> 00:30:08,382
the changed data even if we change the

467
00:30:08,436 --> 00:30:10,560
model several times.

468
00:30:11,170 --> 00:30:15,218
The second, a business transaction can be long and

469
00:30:15,304 --> 00:30:18,530
not depend on the database transaction.

470
00:30:18,870 --> 00:30:22,770
And the last one, our update is atomic.

471
00:30:23,350 --> 00:30:26,934
What are disadvantages? First, we can't use a

472
00:30:26,972 --> 00:30:30,418
pessimistic log. Sorry, we can, but we lose

473
00:30:30,434 --> 00:30:33,954
the ability of a long business transaction because the optimistic

474
00:30:34,002 --> 00:30:37,666
log uses database transactions. Second is

475
00:30:37,788 --> 00:30:40,810
complexity. At the first view,

476
00:30:40,880 --> 00:30:45,082
the pattern interface is simple, but the implementation is

477
00:30:45,136 --> 00:30:48,470
not let's present the UML class diagram

478
00:30:48,550 --> 00:30:51,710
of the pattern. The first block is our pattern.

479
00:30:52,050 --> 00:30:56,174
The next block is the identity map pattern which stores our

480
00:30:56,212 --> 00:30:59,466
models after they are registered in the sum

481
00:30:59,498 --> 00:31:02,822
state, new, clean, dirty or deleted.

482
00:31:02,986 --> 00:31:07,234
Further, we have classes to work with. Database transaction I

483
00:31:07,272 --> 00:31:11,054
prefer to replace it with an interface to unchain

484
00:31:11,102 --> 00:31:14,754
from the database. The interface help us to

485
00:31:14,792 --> 00:31:17,510
use the transaction management which we wrote.

486
00:31:18,250 --> 00:31:22,022
The next part of the pattern is mapper register which

487
00:31:22,076 --> 00:31:26,354
returns a suitable data mapper for a model. And data mapper

488
00:31:26,402 --> 00:31:29,974
is a pattern which maps data from models to database

489
00:31:30,022 --> 00:31:33,594
view and vice versa. Some implementations of data

490
00:31:33,712 --> 00:31:37,082
Maple in other languages use reflection to work

491
00:31:37,136 --> 00:31:40,838
with any model and they support configuration

492
00:31:40,934 --> 00:31:45,258
by YAML, XML annotations and

493
00:31:45,344 --> 00:31:49,546
ETCA. Additionally, if you want to implement the pattern,

494
00:31:49,658 --> 00:31:53,150
you should remember a problem with Avito increment

495
00:31:53,230 --> 00:31:56,978
identifiers. The application can get

496
00:31:57,064 --> 00:32:01,026
the identifiers only after the saving data in

497
00:32:01,048 --> 00:32:04,622
the database. You can use generic identifiers

498
00:32:04,686 --> 00:32:08,070
on the app site as a simple solution,

499
00:32:08,650 --> 00:32:12,610
we finish with depicting the UML

500
00:32:12,690 --> 00:32:16,534
cases diagram. Next, let's see the

501
00:32:16,572 --> 00:32:20,774
example. Order and product are our models

502
00:32:20,822 --> 00:32:24,860
and the pattern coordinates the saving of their changes.

503
00:32:25,230 --> 00:32:28,406
Order function is our business transaction.

504
00:32:28,598 --> 00:32:32,302
We check if the user exists in the external service.

505
00:32:32,436 --> 00:32:35,502
Then we create a new order and mark it as

506
00:32:35,556 --> 00:32:39,470
new. After that we get and marks product as clean.

507
00:32:39,620 --> 00:32:43,662
Then we write off the product from our warehouse

508
00:32:43,806 --> 00:32:47,166
and mark it as dirty or updated.

509
00:32:47,278 --> 00:32:51,810
And finally we commit changes to save it in the database.

510
00:32:52,150 --> 00:32:55,702
On the slide you see the sequence diagram. For our

511
00:32:55,756 --> 00:32:59,686
use case we get mark, change and save data.

512
00:32:59,788 --> 00:33:02,914
However, the most interesting part is hidden

513
00:33:02,962 --> 00:33:06,840
in the commit call because all magic happens there.

514
00:33:07,210 --> 00:33:10,314
When we call the commit we create a

515
00:33:10,352 --> 00:33:14,374
database transaction. Then we get the data mapper

516
00:33:14,422 --> 00:33:17,594
for a model. In our use case it

517
00:33:17,632 --> 00:33:22,186
is the order. After that the code execute

518
00:33:22,378 --> 00:33:25,722
batch changes in database.

519
00:33:25,866 --> 00:33:28,750
Finally we commit the transaction.

520
00:33:29,250 --> 00:33:33,454
I hope I have explained the unit of fork pattern and

521
00:33:33,572 --> 00:33:35,410
shown its complexity.

522
00:33:36,150 --> 00:33:39,534
Fortunately, we can simplify it to the interface.

523
00:33:39,582 --> 00:33:44,002
On the slide we remove identity map mapper, register and

524
00:33:44,136 --> 00:33:47,798
data mapper patterns. The implementation still

525
00:33:47,884 --> 00:33:51,058
has a long business transaction and atomic update,

526
00:33:51,154 --> 00:33:54,902
but this is bad updates because we work

527
00:33:54,956 --> 00:33:58,438
with a callback function and in. Additionally,

528
00:33:58,534 --> 00:34:02,042
the model will be updated multiple times instead

529
00:34:02,096 --> 00:34:06,010
of once. That means if we add three

530
00:34:06,080 --> 00:34:09,482
commas updating the same model, we send

531
00:34:09,616 --> 00:34:12,314
three queries in a database.

532
00:34:12,442 --> 00:34:16,494
However, the original implementation optimized that.

533
00:34:16,692 --> 00:34:19,886
Nevertheless, the implementations even fits in

534
00:34:19,908 --> 00:34:24,082
two slides. We use callback function as

535
00:34:24,136 --> 00:34:27,842
comments, register methods save comments in

536
00:34:27,896 --> 00:34:31,810
list. The comment is

537
00:34:31,880 --> 00:34:35,498
a part of the data mapper which we simplify

538
00:34:35,694 --> 00:34:40,166
when our business transaction is finished, we call

539
00:34:40,268 --> 00:34:43,830
all comments in the comment method.

540
00:34:44,490 --> 00:34:47,978
Also, we can replace comments on queries or

541
00:34:48,064 --> 00:34:52,138
operations of some databases, so we

542
00:34:52,224 --> 00:34:55,962
return batch updates. Then we add the

543
00:34:56,016 --> 00:34:59,958
interface DB runner to send queries to

544
00:35:00,064 --> 00:35:03,280
a database as batch data.

545
00:35:04,290 --> 00:35:08,046
However, the model will still be updated multiple times instead of

546
00:35:08,068 --> 00:35:12,058
just once and we have a problem with after increment

547
00:35:12,154 --> 00:35:15,778
entities. The next step is a complete

548
00:35:15,864 --> 00:35:18,926
unit of work pattern with blackjack, an identity

549
00:35:19,038 --> 00:35:22,974
map, a fully implemented data mapper and a mapper

550
00:35:23,022 --> 00:35:26,134
registry. Unfortunately, there is

551
00:35:26,172 --> 00:35:29,942
no ready library where we need to add only

552
00:35:29,996 --> 00:35:33,320
the data mapper for our mobile. However,

553
00:35:33,770 --> 00:35:37,400
the library with the name works tries to solve that problem

554
00:35:37,770 --> 00:35:41,794
for SQL databases. Also you can help the go

555
00:35:41,852 --> 00:35:45,286
community and implement the universal unit

556
00:35:45,318 --> 00:35:49,226
of work pattern. In conclusion, I want to remember

557
00:35:49,328 --> 00:35:53,134
what we have passed. The first is a repository. It is

558
00:35:53,172 --> 00:35:57,434
used if your application grows and data in the application standing

559
00:35:57,482 --> 00:36:01,342
differs from the database view. Then we use

560
00:36:01,396 --> 00:36:05,146
the transaction manager to have nested transaction use cases

561
00:36:05,258 --> 00:36:08,640
and hides knowledge about transaction in them.

562
00:36:09,250 --> 00:36:13,610
And finally, if you want a long business transaction,

563
00:36:13,770 --> 00:36:16,950
the unit of war is your solution.

564
00:36:17,770 --> 00:36:20,934
Thank you for your attention. The source code of

565
00:36:20,972 --> 00:36:24,758
examples and libraries access by second

566
00:36:24,844 --> 00:36:28,198
link and please press the like button

567
00:36:28,284 --> 00:36:31,350
if the presentation was helpful for you or

568
00:36:31,420 --> 00:36:35,142
write comments if I missed something and

569
00:36:35,276 --> 00:36:39,170
simple writing of business logic. Good luck.

