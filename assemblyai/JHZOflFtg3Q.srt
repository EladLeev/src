1
00:00:29,480 --> 00:00:32,712
My name is Gabriel, and although

2
00:00:32,776 --> 00:00:36,172
this session recording from home

3
00:00:36,226 --> 00:00:40,860
remotely, I like to travel. This is one of my hobbies.

4
00:00:41,360 --> 00:00:44,904
And usually when I travel I'm

5
00:00:44,952 --> 00:00:48,764
using two documents. First one is on the left

6
00:00:48,802 --> 00:00:52,380
side, my passport, and the right

7
00:00:52,450 --> 00:00:54,900
one is the flight ticket.

8
00:00:55,960 --> 00:01:01,300
And let's talk about the difference between those documents because

9
00:01:01,450 --> 00:01:04,628
they are probably both allow me

10
00:01:04,714 --> 00:01:08,456
to get on a plane and travel. But I have different

11
00:01:08,558 --> 00:01:11,912
roles. The passport is a form

12
00:01:11,966 --> 00:01:16,164
of my identity. I declare, I verify my identity

13
00:01:16,212 --> 00:01:19,804
with a passport, but I cannot go on a flight, only with

14
00:01:19,842 --> 00:01:23,036
a passport. I need to authorize myself

15
00:01:23,138 --> 00:01:27,244
to a flight. A passport also, for example, is something that

16
00:01:27,282 --> 00:01:30,750
I'm renewing once for ten years.

17
00:01:31,140 --> 00:01:34,912
But flight ticket is something that I get

18
00:01:34,966 --> 00:01:38,370
again and again for every flight that I'm going to.

19
00:01:38,740 --> 00:01:41,808
The details on both documents are different.

20
00:01:41,974 --> 00:01:45,088
One is the details that verify my identity,

21
00:01:45,184 --> 00:01:49,380
like a biometric image picture or

22
00:01:49,450 --> 00:01:53,492
my birth date. The other is the particular

23
00:01:53,626 --> 00:01:57,930
details that allow me to go on the flight, like the seat number

24
00:01:59,260 --> 00:02:02,356
and the passport is something I'm

25
00:02:02,388 --> 00:02:05,736
using. Once in the airport, the flight ticket is

26
00:02:05,758 --> 00:02:08,776
something that I'm using again and again. I'm showing it in the check in,

27
00:02:08,798 --> 00:02:12,396
and then I'm showing when I check the luggage, then in the security,

28
00:02:12,498 --> 00:02:16,316
then in the gate. And if someone start fighting me on

29
00:02:16,338 --> 00:02:19,756
my seat, I'm taking my flight ticket out and tell

30
00:02:19,778 --> 00:02:22,812
him hey, one a is my seat,

31
00:02:22,956 --> 00:02:26,156
right? So others are many difference between passport

32
00:02:26,188 --> 00:02:29,984
and flight ticket. But what is matter for Javascript or

33
00:02:30,022 --> 00:02:34,004
software? It's matter because there are two terms in

34
00:02:34,042 --> 00:02:37,824
access control that usually confuse

35
00:02:37,872 --> 00:02:40,820
developer authentication and authorization.

36
00:02:41,240 --> 00:02:45,024
Access control is a term, is a general term to describe

37
00:02:45,152 --> 00:02:49,112
who allowed access to our application. Every application

38
00:02:49,246 --> 00:02:52,884
has some level of access. It could be node JS

39
00:02:52,932 --> 00:02:56,170
applications. And this is what we are going to talk about today.

40
00:02:56,540 --> 00:02:59,952
Authentication is the step where our users verify

41
00:03:00,036 --> 00:03:03,368
their identity, right? Same as they do in password,

42
00:03:03,544 --> 00:03:07,116
in passport, yeah, they do it with password, but password is

43
00:03:07,138 --> 00:03:10,168
not that safe. So there are features like biometrics,

44
00:03:10,264 --> 00:03:13,500
multifactor authentication. But authentication

45
00:03:13,580 --> 00:03:17,628
happened once and then we maintained session, but authorization,

46
00:03:17,804 --> 00:03:21,344
the determination of the user permitio to

47
00:03:21,382 --> 00:03:25,872
know if a particular user that already authenticate themselves is authorized

48
00:03:25,936 --> 00:03:29,252
to do an action in our software. It is

49
00:03:29,306 --> 00:03:32,976
something that happened again and again require

50
00:03:33,088 --> 00:03:36,536
permitio model, right. We need to understand

51
00:03:36,638 --> 00:03:40,932
what a user can or cannot do. It has evolved

52
00:03:40,996 --> 00:03:44,840
much more data than authentication session include.

53
00:03:45,180 --> 00:03:49,004
It's not something to revoke because it exists or

54
00:03:49,042 --> 00:03:52,652
valid only for one time that we are checking for

55
00:03:52,706 --> 00:03:56,424
permitio. So the difference between authentication

56
00:03:56,472 --> 00:04:00,140
and authorization are similar to passport and flight ticket.

57
00:04:00,880 --> 00:04:04,312
But authentication has also many advanced features.

58
00:04:04,376 --> 00:04:07,692
It's not as simple as it seems like multifactor authentication.

59
00:04:07,756 --> 00:04:10,736
We want to make sure that the user that just put a password is the

60
00:04:10,758 --> 00:04:15,088
real user. So we are trying like maybe sms or authentication

61
00:04:15,184 --> 00:04:18,724
app. We want also to let user use their

62
00:04:18,842 --> 00:04:21,940
own identity. So we give them like social,

63
00:04:22,090 --> 00:04:25,060
they log in with their Google account or GitHub.

64
00:04:25,400 --> 00:04:29,252
We might want to let them use biometric or passwordless

65
00:04:29,316 --> 00:04:33,336
mechanism to authenticate. We also need to manage all

66
00:04:33,358 --> 00:04:36,644
our users, right? We need some identity provider

67
00:04:36,692 --> 00:04:40,444
to manage identities. We also need to manage the

68
00:04:40,482 --> 00:04:44,392
sessions, manage the registration of the user, all the flows,

69
00:04:44,456 --> 00:04:47,880
the login flows, the sign up flow. We need to verify

70
00:04:47,960 --> 00:04:51,584
account. And there are many, many features in

71
00:04:51,622 --> 00:04:55,104
authentication. So authentication is not that

72
00:04:55,142 --> 00:04:58,432
simple, right? But for developers it's simple because

73
00:04:58,486 --> 00:05:02,316
there are many, many software as a service providers

74
00:05:02,428 --> 00:05:06,224
that let you feel all that advanced feature

75
00:05:06,352 --> 00:05:10,052
as a service. To implement, for example clerk into

76
00:05:10,106 --> 00:05:14,372
your Nodejs or JavaScript app, you need only three

77
00:05:14,426 --> 00:05:17,876
lines of code, four lines of code, and then all the advanced

78
00:05:17,908 --> 00:05:21,480
authentication feature is implemented into your app.

79
00:05:21,630 --> 00:05:25,448
But in authorization, which is not simple

80
00:05:25,614 --> 00:05:28,796
than authentication, and we'll go through it and you'll see

81
00:05:28,818 --> 00:05:32,620
that authorization also require some features,

82
00:05:32,960 --> 00:05:36,028
right? We still work really hard.

83
00:05:36,194 --> 00:05:39,948
It's still the old way of trying to code everything

84
00:05:40,034 --> 00:05:43,696
in authorization ourselves. Burn a lot

85
00:05:43,718 --> 00:05:46,976
of time my name is Gabriel and today

86
00:05:47,078 --> 00:05:51,136
I'm going to talk about how can we do better

87
00:05:51,238 --> 00:05:55,332
authorization in Javascript application short

88
00:05:55,386 --> 00:05:59,076
about intro about myself I am in

89
00:05:59,098 --> 00:06:02,896
software development for many years, JavaScript considered

90
00:06:02,928 --> 00:06:06,244
as my others language. Every time that I just need

91
00:06:06,282 --> 00:06:09,896
to sketch something on a paper, I'm doing it in

92
00:06:09,918 --> 00:06:13,384
JavaScript. But I'm also a big

93
00:06:13,422 --> 00:06:16,664
fan of front end and security and this is

94
00:06:16,702 --> 00:06:20,564
how I got to everything related to access control in applications.

95
00:06:20,692 --> 00:06:23,796
And now I'm leading the developer relation in permitio.

96
00:06:23,908 --> 00:06:27,116
Permit IO is a startup that do authorization as a

97
00:06:27,138 --> 00:06:30,444
service and today I'm going to share with

98
00:06:30,482 --> 00:06:34,016
you a lot of learns that I learned along my career about

99
00:06:34,118 --> 00:06:36,770
having better authorization on application.

100
00:06:37,380 --> 00:06:40,816
But before we dive into authorization, let's try

101
00:06:40,838 --> 00:06:44,116
to understand what happened maybe

102
00:06:44,218 --> 00:06:48,240
started ten years ago that let developers

103
00:06:48,320 --> 00:06:51,956
create simplest authentication using providers like we

104
00:06:51,978 --> 00:06:55,632
saw like OSO or clerk. Two innovations

105
00:06:55,776 --> 00:06:59,252
happened a couple of years ago. The first is auth.

106
00:06:59,316 --> 00:07:02,872
OAuth is a protocol that allowed to

107
00:07:02,926 --> 00:07:06,520
decouple the authentication server from

108
00:07:06,590 --> 00:07:10,104
any kind of application. Here we can see in the center API,

109
00:07:10,152 --> 00:07:13,372
gateway and also API services. Could be any

110
00:07:13,426 --> 00:07:17,260
kind of language or technology for any of them.

111
00:07:17,410 --> 00:07:20,932
We can once connect the authentication server

112
00:07:21,096 --> 00:07:24,396
which in their turn return a token.

113
00:07:24,588 --> 00:07:29,116
The base of OAuth is creating token based authentication

114
00:07:29,308 --> 00:07:33,056
instead of managing sessions. And every time that we

115
00:07:33,078 --> 00:07:36,772
need to know if a user authenticated, we are calling

116
00:07:36,826 --> 00:07:40,788
a session directory and check if session exists. We are using

117
00:07:40,874 --> 00:07:44,960
token token that we can validate and we can do it in a decentralized

118
00:07:45,040 --> 00:07:48,584
way. So every application that needs to do

119
00:07:48,622 --> 00:07:52,712
authentication can call the auth server to make

120
00:07:52,766 --> 00:07:56,552
authentication flow with the user and then by use

121
00:07:56,606 --> 00:08:00,264
token verify the identity of the user.

122
00:08:00,392 --> 00:08:04,190
Another thing that came to public

123
00:08:04,560 --> 00:08:08,220
lately, or maybe it's not lately anymore, it's like I think already

124
00:08:08,290 --> 00:08:11,512
ten years, is JWT Json web token.

125
00:08:11,576 --> 00:08:15,456
This is a format of token that specially work well in

126
00:08:15,478 --> 00:08:18,864
web that can be verified without calling the

127
00:08:18,902 --> 00:08:22,192
authentication server. So in the architecture we see here,

128
00:08:22,246 --> 00:08:26,304
the user is made the authentication against the OAuth server

129
00:08:26,432 --> 00:08:29,830
and then each API, microservice or application

130
00:08:30,200 --> 00:08:33,568
can probably verify their authentication

131
00:08:33,744 --> 00:08:37,348
with this architecture service provider like cloud service

132
00:08:37,434 --> 00:08:41,064
provider. Or if you just develop a platform, you can do it

133
00:08:41,102 --> 00:08:44,244
yourself. You can create auth server

134
00:08:44,292 --> 00:08:48,480
that creating centralized authentication and decentralized

135
00:08:48,580 --> 00:08:53,240
authentication in one and a secure way using JWt.

136
00:08:53,400 --> 00:08:56,600
That's in general the way that all the authentication

137
00:08:56,680 --> 00:09:00,220
service provider works. But how is go is authorization.

138
00:09:00,560 --> 00:09:03,964
So the most simple form of authorization is the if statement

139
00:09:04,012 --> 00:09:07,628
that we see here, right? We can ask if a user

140
00:09:07,644 --> 00:09:11,360
is admin and only then allow them to delete something.

141
00:09:11,510 --> 00:09:14,848
It's a fan code because the user delete themselves. We don't

142
00:09:14,864 --> 00:09:18,816
want to allow admin delete themselves, but that's a demonstration.

143
00:09:18,928 --> 00:09:22,772
How can we code authorization? Probably this

144
00:09:22,826 --> 00:09:26,356
way is not the smartest way to do. First, every time

145
00:09:26,378 --> 00:09:30,104
we are changing something, we need to change the code and

146
00:09:30,142 --> 00:09:33,704
we involve the code in the logic that we need to do so.

147
00:09:33,742 --> 00:09:38,068
It's also hard to read. So a more clean way to code authorization

148
00:09:38,244 --> 00:09:41,832
is using middleware. Here we can see an example of

149
00:09:41,966 --> 00:09:46,028
express middleware. It's a piece of JavaScript code

150
00:09:46,194 --> 00:09:49,784
for delete endpoint of a user.

151
00:09:49,912 --> 00:09:53,856
And instead of mixing the business logic of checking if

152
00:09:53,878 --> 00:09:57,760
a user is admin with the

153
00:09:57,910 --> 00:10:01,584
function itself, we are taking it out into a middleware. And then

154
00:10:01,622 --> 00:10:04,436
we check if a user can remove something.

155
00:10:04,618 --> 00:10:08,800
This is better than just ask if a user is admin.

156
00:10:08,960 --> 00:10:12,404
But it's not easy because for example we

157
00:10:12,442 --> 00:10:15,956
need more permitio models than just asking for

158
00:10:15,978 --> 00:10:20,136
a user role. We can see here in example that we

159
00:10:20,318 --> 00:10:25,060
need more granular level of permitio

160
00:10:25,220 --> 00:10:28,944
to make sure a user is allowed to do some action.

161
00:10:29,092 --> 00:10:33,416
This level of granularity, this level of granularity

162
00:10:33,528 --> 00:10:37,180
can change. It could be like role, as we saw

163
00:10:37,250 --> 00:10:41,144
in the middle of role required, but can also be based on

164
00:10:41,202 --> 00:10:45,120
attributes of a user or maybe data from a different

165
00:10:45,270 --> 00:10:48,592
service. Well, data from a different

166
00:10:48,646 --> 00:10:52,784
service is also not that good, because sometimes it's not part of

167
00:10:52,822 --> 00:10:56,844
the request itself. So middlewares,

168
00:10:56,892 --> 00:11:00,404
as we can see in the code here in the right hand side, we are

169
00:11:00,442 --> 00:11:03,424
trying to know what is the tier of the user.

170
00:11:03,552 --> 00:11:07,288
This tier of the user is not something which is part of the

171
00:11:07,374 --> 00:11:11,304
request itself. It's something that we need to go to ask

172
00:11:11,422 --> 00:11:14,276
somewhere in the middle of the business logic.

173
00:11:14,388 --> 00:11:17,720
So no matter how we will make our

174
00:11:17,790 --> 00:11:21,356
middleware granular, sometimes we will have a

175
00:11:21,378 --> 00:11:25,036
need where we need to do authorization decision in

176
00:11:25,058 --> 00:11:28,204
the middle of the code, right? I think we already

177
00:11:28,242 --> 00:11:31,776
saw enough code to understand that the way we

178
00:11:31,798 --> 00:11:35,228
are coding authorization, it may be work, but it's

179
00:11:35,244 --> 00:11:38,636
not that clean. Because the requirement of authorization

180
00:11:38,748 --> 00:11:42,096
with permissions model with roles, or maybe more

181
00:11:42,118 --> 00:11:45,104
granular permitio models and endpoint,

182
00:11:45,152 --> 00:11:48,564
and maybe more granular level of permission enforcement on

183
00:11:48,602 --> 00:11:51,712
endpoint. It's getting complex and complex.

184
00:11:51,856 --> 00:11:55,750
For example, we can see that users getting

185
00:11:56,860 --> 00:12:00,820
decisions that need only for partial

186
00:12:00,900 --> 00:12:04,344
authorization and not for the whole scope of the function.

187
00:12:04,542 --> 00:12:07,940
And this code is getting dirtier and dirtier.

188
00:12:08,100 --> 00:12:12,408
But clean code is not the only problem of the way we are doing authorization

189
00:12:12,504 --> 00:12:16,472
today. Sometimes we need a different environment

190
00:12:16,536 --> 00:12:20,916
with different permitio, right? We do continuous integration,

191
00:12:21,048 --> 00:12:24,240
we want to create, test, and we want maybe

192
00:12:24,310 --> 00:12:27,696
the admin in the staging environment to be allowed to do

193
00:12:27,718 --> 00:12:31,548
what super admin allowed in production.

194
00:12:31,724 --> 00:12:35,104
How can we separate these policies,

195
00:12:35,232 --> 00:12:38,564
these permissions between environments? It's not

196
00:12:38,602 --> 00:12:41,924
only staging in production, it could be different

197
00:12:42,042 --> 00:12:46,824
tenant environment, it could be different customer

198
00:12:46,942 --> 00:12:50,936
environment. So as you can see, having policy

199
00:12:51,118 --> 00:12:54,756
or having enforcement or having decision,

200
00:12:54,948 --> 00:12:58,776
mostly, most accurately having decision of authorization in

201
00:12:58,798 --> 00:13:02,444
the code. It's something that can be complex when your

202
00:13:02,482 --> 00:13:06,556
application getting complex. And also the real fact is

203
00:13:06,658 --> 00:13:10,412
we love javascript, but sometimes we need to do a different app,

204
00:13:10,466 --> 00:13:14,236
we need to do a data application. So we are using Python

205
00:13:14,348 --> 00:13:18,108
and we want to keep the same logic across our applications,

206
00:13:18,204 --> 00:13:21,916
across our stack. And also let's

207
00:13:21,948 --> 00:13:25,908
go a bit back to the clean code thing.

208
00:13:26,074 --> 00:13:30,624
Authorization decision is something that could cost performance.

209
00:13:30,752 --> 00:13:34,276
And when we need to debug those performance, when we

210
00:13:34,298 --> 00:13:38,148
need to get the audit of what the authorization

211
00:13:38,244 --> 00:13:42,250
decision does, it's something that can get

212
00:13:42,620 --> 00:13:46,184
a hell of decision in case we are doing it

213
00:13:46,222 --> 00:13:49,964
in just coding the decision logic as part of

214
00:13:50,002 --> 00:13:53,548
our application. Right? Oso, the problem

215
00:13:53,714 --> 00:13:57,484
of creating permitio and authorization as part of

216
00:13:57,522 --> 00:14:00,812
application is clear. Let's see from the

217
00:14:00,866 --> 00:14:04,480
examples we saw what we can do to make sure that

218
00:14:04,550 --> 00:14:08,668
authorization service. Let's say that we are now creating an authorization

219
00:14:08,764 --> 00:14:12,320
microservice, a dedicated one. What it has to be

220
00:14:12,470 --> 00:14:16,400
first, and for the last thing, we want it to be declarative.

221
00:14:16,560 --> 00:14:20,340
The way that we are coding complex imperative code

222
00:14:20,410 --> 00:14:24,004
to get authorization decision. It's something that hard

223
00:14:24,042 --> 00:14:27,092
to read and also hard to manage and audit.

224
00:14:27,236 --> 00:14:30,452
We want it also to be generic,

225
00:14:30,596 --> 00:14:34,420
right? We don't want it to be in a level of roles

226
00:14:34,500 --> 00:14:38,264
or attributes. We want it to have to

227
00:14:38,302 --> 00:14:41,564
support any kind of permitio models that we want.

228
00:14:41,682 --> 00:14:45,804
Permitio decision could be simple as if is admin, but could

229
00:14:45,842 --> 00:14:49,320
be complex as if is admin and a paid user

230
00:14:49,400 --> 00:14:53,004
and own the document. We want it also

231
00:14:53,042 --> 00:14:56,204
to be unified in one place, so we can run it in multiple

232
00:14:56,252 --> 00:14:59,936
application, we can manage it for multiple environments. We want

233
00:14:59,958 --> 00:15:03,904
it to be agnostic to the language that we are using. And because we

234
00:15:03,942 --> 00:15:07,204
want it to be agnostic, we want it to decoupled from the code. So every

235
00:15:07,242 --> 00:15:11,172
time we need to change, every time a PM come and wants us to change

236
00:15:11,306 --> 00:15:14,688
authorization decision, we don't

237
00:15:14,704 --> 00:15:17,608
want to change the application code, we want to decouple it.

238
00:15:17,694 --> 00:15:21,864
And we also want it to be easy to audit, because access control is

239
00:15:21,902 --> 00:15:25,896
something that can create very high level security

240
00:15:25,998 --> 00:15:29,912
vulnerabilities. So we really want it to be easy to audit

241
00:15:29,976 --> 00:15:32,460
when we are getting maybe wrong decision.

242
00:15:33,280 --> 00:15:38,568
So what is the way to build this authorization microservice?

243
00:15:38,744 --> 00:15:42,172
So let's start with a simple five steps.

244
00:15:42,316 --> 00:15:45,280
Maybe not simple, but I'll try to make it simple.

245
00:15:45,430 --> 00:15:48,672
The first is model. Before we are doing

246
00:15:48,726 --> 00:15:52,530
authorization, we need to model the permission model.

247
00:15:53,060 --> 00:15:55,988
What do you mean? What does that mean?

248
00:15:56,154 --> 00:15:59,716
Authentication is something that can create out there.

249
00:15:59,818 --> 00:16:03,632
We decide who are giving us identities, we decide

250
00:16:03,696 --> 00:16:07,224
how do we authenticate users. But authorization is something

251
00:16:07,262 --> 00:16:10,024
that driven by our application needs,

252
00:16:10,222 --> 00:16:13,720
and hence we need to model what our application need.

253
00:16:13,870 --> 00:16:17,080
What is the easiest way to model is think about

254
00:16:17,150 --> 00:16:20,872
three principle. In our application, we'll always have three

255
00:16:20,926 --> 00:16:24,520
principles when we want to get a decision, a user

256
00:16:24,680 --> 00:16:27,896
or other principle, maybe a service, an action,

257
00:16:28,008 --> 00:16:31,676
what they want to do, and a resource, the resource that they want to do

258
00:16:31,698 --> 00:16:35,408
on. So for example, a permission decision is. Is a

259
00:16:35,414 --> 00:16:38,268
monkey allowed to eat a banana? A monkey is the user,

260
00:16:38,364 --> 00:16:41,264
eat is the action and banana is the resource. Yeah,

261
00:16:41,302 --> 00:16:44,944
but in a real world it's. Of course if an admin

262
00:16:45,072 --> 00:16:48,784
allowed to delete a document, or if an admin allowed

263
00:16:48,832 --> 00:16:52,420
to delete a document created today or if an

264
00:16:52,490 --> 00:16:55,796
admin allowed to delete a

265
00:16:55,818 --> 00:16:58,528
document that they are not owning.

266
00:16:58,704 --> 00:17:02,596
Right? Oso every authenticate authorization decision

267
00:17:02,788 --> 00:17:06,664
is happening with these three principles so that help us to

268
00:17:06,702 --> 00:17:09,900
model all our authorization rules.

269
00:17:10,400 --> 00:17:14,364
Second point is the level of authorization application

270
00:17:14,482 --> 00:17:18,248
stack built usually from let's say UI

271
00:17:18,344 --> 00:17:21,756
or gateway, right the way that we are existing to

272
00:17:21,778 --> 00:17:25,616
the user, the application logic and the

273
00:17:25,638 --> 00:17:29,116
data itself, the database in application logic,

274
00:17:29,148 --> 00:17:32,448
which is the main part of our code. We want to do enforcement. We want

275
00:17:32,454 --> 00:17:35,804
to have a simple function that get these three principles,

276
00:17:35,852 --> 00:17:39,328
user action and resource and return. True or false. We don't

277
00:17:39,344 --> 00:17:42,544
want to do the decision in the application logic.

278
00:17:42,672 --> 00:17:46,340
We want us to do the logic of the decision in a different service

279
00:17:46,490 --> 00:17:50,692
and in the application itself only enforce the permission.

280
00:17:50,836 --> 00:17:54,116
We also sometimes need to do feature toggling in the UI

281
00:17:54,148 --> 00:17:57,656
or the gateway to make sure that users are

282
00:17:57,678 --> 00:18:01,790
not getting the resources or not allowing to do

283
00:18:02,560 --> 00:18:06,124
or to see what they need to see. And we

284
00:18:06,162 --> 00:18:10,060
also sometimes want on the data itself do data filtering. So to not return

285
00:18:10,130 --> 00:18:13,330
the user something that they are not supposed to get.

286
00:18:14,100 --> 00:18:18,012
So we know what is the principles, how this enforcement

287
00:18:18,076 --> 00:18:22,076
function signature should look like accepting these three principles

288
00:18:22,108 --> 00:18:25,990
and returning either data filtering or true or false result.

289
00:18:26,520 --> 00:18:30,068
And then we need to design a permission model. Why it is important

290
00:18:30,154 --> 00:18:34,230
to design a permitio model because that help us to

291
00:18:35,400 --> 00:18:38,504
create a good picture of how the

292
00:18:38,542 --> 00:18:41,930
authorization policies looks in our application.

293
00:18:42,460 --> 00:18:45,496
Let's talk about four common permission model,

294
00:18:45,678 --> 00:18:49,256
why and when and where use each. First is the

295
00:18:49,278 --> 00:18:52,860
access control list. Access control list is a very old one. I consider

296
00:18:52,930 --> 00:18:56,716
it as an end of life model. It's usually used in system

297
00:18:56,818 --> 00:19:00,952
and firewalls and switches, et cetera. It's maintain

298
00:19:01,096 --> 00:19:05,330
a list, a long list of users and

299
00:19:06,100 --> 00:19:09,824
the list, let's say title is an action and a resource or only

300
00:19:09,862 --> 00:19:13,680
a resource. And the users that appear in the list are actually

301
00:19:13,750 --> 00:19:17,684
the one that allowed to do something. In this kind

302
00:19:17,722 --> 00:19:22,176
of permission model it's hard to scale because we need to maintain all those lists

303
00:19:22,288 --> 00:19:26,068
and we need to use data that is saved in

304
00:19:26,074 --> 00:19:29,656
the list. If for example, we want to get the role of a

305
00:19:29,678 --> 00:19:33,016
user, or we want to get a decision based on a

306
00:19:33,038 --> 00:19:37,272
user that assigning to some list,

307
00:19:37,406 --> 00:19:41,404
but it's not appearing the list is in a different system. It's really

308
00:19:41,442 --> 00:19:45,790
hard. So ACL is not fit for modern application.

309
00:19:46,720 --> 00:19:50,472
RbaC role based access control is like the generic

310
00:19:50,536 --> 00:19:53,676
name for authorization. Why? Because it's

311
00:19:53,708 --> 00:19:57,648
very simple to assign users roles. We can take a user and tell

312
00:19:57,734 --> 00:20:01,452
this user is admin, this user is a moderator

313
00:20:01,596 --> 00:20:04,804
and then we can easily assign permissions for

314
00:20:04,842 --> 00:20:09,104
particular resources and actions of these roles,

315
00:20:09,232 --> 00:20:13,044
right? So if we want to give a nice user experience for

316
00:20:13,082 --> 00:20:16,292
our application admin, we will use RBaC because

317
00:20:16,346 --> 00:20:19,444
then we can extend hey, if you want your users

318
00:20:19,492 --> 00:20:22,692
to be able to do a particular action on a resource,

319
00:20:22,836 --> 00:20:26,356
just assign them the role. While arbac

320
00:20:26,388 --> 00:20:30,052
is easy to define and also to use and audit, because every decision

321
00:20:30,116 --> 00:20:33,884
we make we can easily get here, hey this got this decision because they

322
00:20:33,922 --> 00:20:37,372
are role. It's hard to inspect into resource, right?

323
00:20:37,426 --> 00:20:40,892
If for example, we want to allow users to do something only

324
00:20:40,946 --> 00:20:43,020
on their own resources,

325
00:20:43,920 --> 00:20:47,424
we don't have the granular level to do that. Because as we can see

326
00:20:47,462 --> 00:20:51,004
here, the granularity of RBAC is only in the resource

327
00:20:51,052 --> 00:20:53,650
level, not in the resource instance level.

328
00:20:54,100 --> 00:20:57,680
Also, others is no resource. Also there is scalability

329
00:20:57,760 --> 00:21:01,412
is limited because if we need, for example to have more

330
00:21:01,466 --> 00:21:04,864
roles or more granular way on looking on users,

331
00:21:04,912 --> 00:21:08,200
it's getting hard. IBAc on the other hand,

332
00:21:08,270 --> 00:21:12,052
is the most complex way to model policies

333
00:21:12,196 --> 00:21:16,244
yet. It's important to understand that it might be complex,

334
00:21:16,372 --> 00:21:19,864
but it still gives our users a very easy way

335
00:21:19,902 --> 00:21:23,880
to define policy rules. If you have a way to define policy rules,

336
00:21:23,960 --> 00:21:27,324
then you can take attribute of the users and the

337
00:21:27,362 --> 00:21:31,172
resource, right? In software, everything probably has attributes,

338
00:21:31,256 --> 00:21:35,052
user as attributes like name, role, job description,

339
00:21:35,116 --> 00:21:37,728
address, city, whatever it is,

340
00:21:37,894 --> 00:21:41,856
resources as attributes. And then we can create policy

341
00:21:41,958 --> 00:21:45,364
roles that consider set of attributes together with

342
00:21:45,402 --> 00:21:48,576
an action and decide if a user is allowed

343
00:21:48,608 --> 00:21:51,972
or not allowed to do something. While ABAC is the

344
00:21:52,026 --> 00:21:56,000
most granular policy level, it's hard when

345
00:21:56,090 --> 00:21:59,384
we, for example, need relationships. So for example, if we

346
00:21:59,422 --> 00:22:03,160
think about Google Drive, Google Drive has account

347
00:22:03,310 --> 00:22:07,620
in account, there are folders, in folders, there are documents.

348
00:22:07,780 --> 00:22:11,252
A document belong to a user's not user,

349
00:22:11,316 --> 00:22:14,556
not because an attribute, a document because it's a

350
00:22:14,578 --> 00:22:17,804
part of a folder. So we need to find a way

351
00:22:17,922 --> 00:22:21,580
to propagate or derive policy rules

352
00:22:21,660 --> 00:22:25,484
based on relationships in application. So to solve

353
00:22:25,532 --> 00:22:29,484
this level of granularity in resource instances

354
00:22:29,612 --> 00:22:32,960
and derivation of permissions, there is a model

355
00:22:33,030 --> 00:22:36,624
called relationship back substance based access control

356
00:22:36,742 --> 00:22:40,544
reback where we can create a graph

357
00:22:40,592 --> 00:22:44,532
database of connections between things and make

358
00:22:44,586 --> 00:22:47,816
our policy rules based on this graph and say

359
00:22:47,918 --> 00:22:51,352
if there is a tuple a relationship between

360
00:22:51,486 --> 00:22:55,848
resources, then we can take the granular level

361
00:22:55,934 --> 00:22:59,832
of resource instances and create policy rule

362
00:22:59,896 --> 00:23:03,452
based on them. So now we

363
00:23:03,586 --> 00:23:06,348
understand the first point model,

364
00:23:06,434 --> 00:23:10,284
our application permission. We have in mind the

365
00:23:10,322 --> 00:23:13,804
model that we need. Maybe it's RBaC maybe RBaC with RebaC,

366
00:23:13,852 --> 00:23:17,472
maybe RBaC with ABAC. We understand who are

367
00:23:17,526 --> 00:23:21,200
our users, what are our resources and what are the policy

368
00:23:21,270 --> 00:23:25,616
rules that we need to create. We draw it nicely on a whiteboard

369
00:23:25,728 --> 00:23:29,524
and we want to author it, right? So we want to have like

370
00:23:29,642 --> 00:23:33,568
authorization microservice with all these policy rules.

371
00:23:33,664 --> 00:23:37,352
So one way is of course do it imperative as we did

372
00:23:37,486 --> 00:23:41,416
before, like create code that do it. But then

373
00:23:41,518 --> 00:23:44,984
it means we are coupling ourselves again to application

374
00:23:45,102 --> 00:23:49,580
code. So how about the idea of

375
00:23:49,650 --> 00:23:53,688
create contracts for creating policies?

376
00:23:53,864 --> 00:23:57,864
What if for creating, let's say Arbac policies or arbac

377
00:23:57,912 --> 00:24:01,804
rules. We have a new language that dedicated for

378
00:24:01,842 --> 00:24:05,676
that. And this is one of the things that I want to introduce

379
00:24:05,708 --> 00:24:09,216
you today. Policy languages. Policy languages is

380
00:24:09,238 --> 00:24:12,864
a trend that coming by for the last years. Every couple

381
00:24:12,902 --> 00:24:16,316
of months you see a new policy language release. This language

382
00:24:16,348 --> 00:24:19,664
is not a real programming language, it's more a configuration language.

383
00:24:19,712 --> 00:24:23,204
It's not a language usual. It's not a language that you need to learn from

384
00:24:23,242 --> 00:24:26,324
scratch, but to know how to use that.

385
00:24:26,442 --> 00:24:30,516
There are also policy languages that based on Yaml or Json.

386
00:24:30,548 --> 00:24:33,976
So you donts need to learn a new syntax. Today we are going to

387
00:24:33,998 --> 00:24:37,572
talk about, I'm going to mention three policy language.

388
00:24:37,636 --> 00:24:41,084
The first one is the most famous one,

389
00:24:41,202 --> 00:24:45,388
open policy agent. Open policy agent is a decision engine.

390
00:24:45,554 --> 00:24:49,116
Like think about a compiler that we can run

391
00:24:49,218 --> 00:24:52,812
a policy program and get a decision if it's allowed or not.

392
00:24:52,946 --> 00:24:57,188
Open policy agent has a language called Oprigo

393
00:24:57,304 --> 00:25:01,084
where you can declare your own policies and then enforce

394
00:25:01,132 --> 00:25:04,736
them by the decision that happened in the open policy agent.

395
00:25:04,918 --> 00:25:08,148
There is also a language called Cedar. Cedar is a

396
00:25:08,154 --> 00:25:11,696
language released by AWS as an open source. This is the language

397
00:25:11,728 --> 00:25:16,792
that we are going to demonstrate today. And there are type

398
00:25:16,846 --> 00:25:20,596
of languages for Openfga, for Google Zanzibar.

399
00:25:20,628 --> 00:25:23,960
Google Zanzibar will not expand on it too much,

400
00:25:24,030 --> 00:25:27,160
but we mentioned relationship based access control.

401
00:25:27,310 --> 00:25:31,340
And sometimes relationship based access control require much

402
00:25:31,410 --> 00:25:35,704
more sophisticated policy engines

403
00:25:35,752 --> 00:25:39,516
for that. So if you need a specific case of relationship

404
00:25:39,618 --> 00:25:43,084
based access control, let's say that you have tons of resources

405
00:25:43,132 --> 00:25:46,464
and instances and millions of users, you might need this

406
00:25:46,502 --> 00:25:50,172
language. But let's dive for the cedar language.

407
00:25:50,316 --> 00:25:53,708
Here we can see, and sorry it looks small in the

408
00:25:53,894 --> 00:25:58,276
left side here we can see three examples of

409
00:25:58,378 --> 00:26:01,700
rules that declared in cedar language. Let's focus

410
00:26:01,770 --> 00:26:05,604
on the one in the middle so

411
00:26:05,642 --> 00:26:09,816
we can see that we are declaring a rule of permit. Permit means

412
00:26:09,918 --> 00:26:13,656
a user is allowed to do something. And as you can see, one of

413
00:26:13,678 --> 00:26:17,096
the things in cedar is that we are declaring policy

414
00:26:17,198 --> 00:26:20,936
with the three principles of authorization, the user,

415
00:26:21,048 --> 00:26:24,364
the action, and the resource. So we say here like

416
00:26:24,402 --> 00:26:28,604
an ABAC policy, that said, a user is permitted to

417
00:26:28,642 --> 00:26:31,964
do update, list, create task, update task,

418
00:26:32,012 --> 00:26:35,420
or delete task on a resource, any resource

419
00:26:35,500 --> 00:26:39,056
or any users only when this user is one

420
00:26:39,078 --> 00:26:42,736
of the resource editors, right? So see how in

421
00:26:42,758 --> 00:26:46,596
what a clean way we can describe a

422
00:26:46,618 --> 00:26:49,844
policy rule. Let's see on the left hand

423
00:26:49,882 --> 00:26:52,944
side, which is a most sophisticated ABAC rule.

424
00:26:52,992 --> 00:26:56,964
And we say if a resource as owner and

425
00:26:57,002 --> 00:27:00,488
the owner is a principal, then we allowed something in

426
00:27:00,494 --> 00:27:04,996
the left hand side. In the left hand side in the small letters

427
00:27:05,108 --> 00:27:08,688
is an RBAC policy. Like we say, only a user with the role

428
00:27:08,724 --> 00:27:12,092
admin is allowed to do something. Now we can

429
00:27:12,146 --> 00:27:15,724
have one policy repository where we create

430
00:27:15,842 --> 00:27:18,972
all our authorization rules, okay?

431
00:27:19,106 --> 00:27:22,588
And all our application use the same authorization rule.

432
00:27:22,684 --> 00:27:26,844
All what we need to do is call the cedar agent that loaded

433
00:27:26,892 --> 00:27:30,476
with these rules and make an authorization

434
00:27:30,588 --> 00:27:34,050
decisions or authorization enforcement based on it.

435
00:27:39,320 --> 00:27:43,348
Another option of course is to have your authorization service

436
00:27:43,434 --> 00:27:47,144
with some UI. Here is what we built in permitio to

437
00:27:47,182 --> 00:27:50,360
manage policies and then you can just let your

438
00:27:50,430 --> 00:27:54,324
product manager or whatever it is to edit the policies

439
00:27:54,452 --> 00:27:57,944
without even knows the code. We are using our

440
00:27:57,982 --> 00:28:01,324
UI to create and configure policies and

441
00:28:01,362 --> 00:28:05,256
then all these policies

442
00:28:05,368 --> 00:28:09,404
is created or generated as policy as code. And then you

443
00:28:09,442 --> 00:28:13,020
can use the UI for what? Easy to config

444
00:28:13,100 --> 00:28:17,120
and use the code for the most invest use cases.

445
00:28:17,460 --> 00:28:20,860
So we understand how we author the policies,

446
00:28:21,020 --> 00:28:24,836
but how we check that these policies is what we mean. So there

447
00:28:24,858 --> 00:28:29,024
are agents. Agent is like a decision maker

448
00:28:29,152 --> 00:28:32,336
where we are passing three principles,

449
00:28:32,448 --> 00:28:35,924
a particular user, an action description and a

450
00:28:35,962 --> 00:28:39,816
resource, or maybe attributes of a resource, and this agent

451
00:28:39,918 --> 00:28:44,436
returning a result. True or false allowed or not allowed.

452
00:28:44,628 --> 00:28:47,880
Right? So once we have an agent,

453
00:28:48,030 --> 00:28:52,376
we're starting to form a complete authorization

454
00:28:52,488 --> 00:28:55,896
service. We have a policy repository

455
00:28:56,008 --> 00:28:59,276
where we author all the policy. Then we have the

456
00:28:59,298 --> 00:29:03,128
agent where we can get the queries. And then what we

457
00:29:03,154 --> 00:29:06,576
left is to enforce, right? So we can enforce it by

458
00:29:06,678 --> 00:29:10,016
calling the policy agent. Here we can see

459
00:29:10,038 --> 00:29:13,836
that we are calling the Cedar agent in an HTTP interface.

460
00:29:13,948 --> 00:29:17,348
As you can see, we are passing the principal action and a

461
00:29:17,354 --> 00:29:21,252
resource from our request to the cedar agent.

462
00:29:21,386 --> 00:29:24,992
And the context is also something that we can use to expand

463
00:29:25,056 --> 00:29:28,568
the data that we are passing with the policy

464
00:29:28,654 --> 00:29:32,008
enforcement request. And in this case or

465
00:29:32,094 --> 00:29:35,768
with this example, we are not writing the

466
00:29:35,854 --> 00:29:39,832
decision logic in our application anymore. We are keeping

467
00:29:39,896 --> 00:29:43,992
our application logic only in enforcing permitio

468
00:29:44,056 --> 00:29:47,756
and think about this is great. We actually decouple the policy from

469
00:29:47,778 --> 00:29:51,724
the code. We have a unified place for our policy.

470
00:29:51,922 --> 00:29:55,376
We can make it generic to the language because we can do

471
00:29:55,398 --> 00:29:58,924
it in an HTTP API or some other RPC

472
00:29:58,972 --> 00:30:02,108
forms. It's easy to audit because all the decision

473
00:30:02,204 --> 00:30:05,444
happen in this agent. So if we need to audit something

474
00:30:05,482 --> 00:30:09,492
we're just going and see what happened in the decision and

475
00:30:09,546 --> 00:30:12,804
it's declarative. So if someone want to understand what

476
00:30:12,842 --> 00:30:16,032
happened or how our policy configured,

477
00:30:16,176 --> 00:30:19,610
it's easy to see just by looking at the code.

478
00:30:19,980 --> 00:30:23,512
Great right? So we are enforcing policy. But not only that,

479
00:30:23,646 --> 00:30:26,904
there is a nice framework called Castle for Front end

480
00:30:27,022 --> 00:30:31,976
where we can load all our authorization,

481
00:30:32,168 --> 00:30:35,980
all our policy decision that we need for our front

482
00:30:36,050 --> 00:30:39,624
end from our cedar agent and then cedar

483
00:30:39,672 --> 00:30:43,840
agent and then we can in the front end feature toggle

484
00:30:44,740 --> 00:30:48,016
everything we need when we

485
00:30:48,038 --> 00:30:51,312
need to audit. It's easy to see because all

486
00:30:51,366 --> 00:30:55,300
the cedar agents and all the policy engine are

487
00:30:55,370 --> 00:30:59,092
probably auditing what happened when we got the

488
00:30:59,146 --> 00:31:02,800
authorization decision. So we understand the framework

489
00:31:02,880 --> 00:31:05,540
and let's see in practical how is that tools like.

490
00:31:05,690 --> 00:31:10,196
So let's say that we want to have now authorization microservice

491
00:31:10,228 --> 00:31:13,992
that we can easily use. So authorization include control

492
00:31:14,046 --> 00:31:17,944
plane as we describe where we author the policy and

493
00:31:17,982 --> 00:31:21,884
a data plane where we get the decision and the application when

494
00:31:21,922 --> 00:31:25,160
we do the enforcement. And on the other side the data sources.

495
00:31:25,240 --> 00:31:28,604
We need to enrich our policy with data

496
00:31:28,722 --> 00:31:33,360
to make better decision. Right? Policy decision maybe

497
00:31:33,430 --> 00:31:36,480
need data from external sources.

498
00:31:37,700 --> 00:31:40,540
How we do all that not from scratch.

499
00:31:40,620 --> 00:31:44,832
We can use OPal. Opal is an open source tool that

500
00:31:44,886 --> 00:31:48,724
lets you with one docker compose file spin up

501
00:31:48,842 --> 00:31:51,892
in minutes everything we saw before.

502
00:31:52,026 --> 00:31:57,192
Create a complete microservice that

503
00:31:57,246 --> 00:32:01,000
can help you with do authorization in

504
00:32:01,070 --> 00:32:04,484
all your application using one interface

505
00:32:04,612 --> 00:32:08,296
with audit. Here you can see the QR code. The QR code will lead

506
00:32:08,318 --> 00:32:12,240
you to a GitHub repository of Opal

507
00:32:12,340 --> 00:32:16,024
that actually you can see others. Everything related to OPA

508
00:32:16,072 --> 00:32:19,752
and how to spin it up. We'll also do a demo soon. And Opal,

509
00:32:19,816 --> 00:32:24,288
as you can see here is a complete authorization service

510
00:32:24,454 --> 00:32:28,444
that you need for all your application. OPA include Opal client

511
00:32:28,492 --> 00:32:33,056
and Opal server. The server is probably the policy

512
00:32:33,158 --> 00:32:37,044
store. It's actually connected to a git repository where

513
00:32:37,082 --> 00:32:41,510
you store all your policy. You can also separate it to environment and

514
00:32:42,600 --> 00:32:46,516
maybe even application. Also you configure. You can configure

515
00:32:46,548 --> 00:32:49,992
in Opal what is the sources that your data need.

516
00:32:50,126 --> 00:32:53,976
And then the Opal client is running

517
00:32:54,078 --> 00:32:59,000
as a sidecar in your application or for

518
00:32:59,070 --> 00:33:02,492
multiple applications. And those applications can

519
00:33:02,546 --> 00:33:06,360
get decisions that based on the logic that exists

520
00:33:06,440 --> 00:33:09,644
in the central part. If you see at Hopeal, this is

521
00:33:09,682 --> 00:33:13,316
actually giving you the same as JWT and OOH

522
00:33:13,368 --> 00:33:17,548
server bring to authentication. You have one server

523
00:33:17,644 --> 00:33:21,468
to configure all the policy needed like OSO server.

524
00:33:21,564 --> 00:33:24,656
And you have instead of making the

525
00:33:24,678 --> 00:33:28,064
calls to the configuration themselves, you are calling the

526
00:33:28,102 --> 00:33:32,036
sidecar like verifying JWT that's sitting close to

527
00:33:32,058 --> 00:33:35,572
the application, maybe even as a binary and making

528
00:33:35,706 --> 00:33:37,400
very fast decision.

529
00:33:38,460 --> 00:33:40,890
Now it's a good time for a demo.

530
00:33:42,300 --> 00:33:45,848
So here is the code that I want to discuss

531
00:33:45,934 --> 00:33:49,304
about. First let's talk about the Opal Docker

532
00:33:49,352 --> 00:33:53,208
compose. This repository exists on GitHub.

533
00:33:53,304 --> 00:34:00,316
I'll share a link later. And actually

534
00:34:00,498 --> 00:34:03,612
the first part of this repository is Docker compose

535
00:34:03,676 --> 00:34:08,048
that has Opal and also some

536
00:34:08,214 --> 00:34:11,756
infrastructure that we create running it locally.

537
00:34:11,868 --> 00:34:15,616
Let's start from the bottom where we are loading opal. So we are loading

538
00:34:15,648 --> 00:34:19,460
the OPA server image. Remember opal server is actually

539
00:34:19,610 --> 00:34:23,364
where we are storing the policy and configuring the data.

540
00:34:23,482 --> 00:34:27,256
So as you can see here, I'm saying the policies sit in

541
00:34:27,278 --> 00:34:30,536
this git repository. This git repository is actually a

542
00:34:30,558 --> 00:34:33,800
mock repository that I'm launching in another

543
00:34:33,870 --> 00:34:37,400
docker container here. And I also say I need data

544
00:34:37,470 --> 00:34:41,356
from external resource. This external resource can be let's say your

545
00:34:41,538 --> 00:34:45,484
CRM system or

546
00:34:45,522 --> 00:34:49,144
CRM service. Also here I'm just mocking

547
00:34:49,192 --> 00:34:52,988
it from an NginX server. But I'm configuring

548
00:34:53,084 --> 00:34:57,104
the policy configuration and then I spin up

549
00:34:57,142 --> 00:35:01,164
the Opal client, the decision agent. I actually wrap decider

550
00:35:01,212 --> 00:35:04,992
agent with the Opal client. The nice thing is that in production

551
00:35:05,056 --> 00:35:08,900
you can scale this OPA client again and again for every

552
00:35:08,970 --> 00:35:12,484
application that you need and you will always get the

553
00:35:12,522 --> 00:35:16,624
same decision. Let's see now how our applications

554
00:35:16,672 --> 00:35:20,330
look like. So I have here a simple nodejs application.

555
00:35:21,340 --> 00:35:24,996
This application has route for like let's say a blog.

556
00:35:25,108 --> 00:35:28,404
There is article we can create, article we can update,

557
00:35:28,452 --> 00:35:31,772
we can get it, we can delete it. And we have

558
00:35:31,826 --> 00:35:35,356
a middleware. But a difference than a middleware that we

559
00:35:35,378 --> 00:35:39,208
saw in the beginning that can dirt our code. This middleware

560
00:35:39,304 --> 00:35:43,200
actually always do the same logic. No matter how

561
00:35:43,270 --> 00:35:47,324
complex is the decision, we need to do it only enforce

562
00:35:47,372 --> 00:35:50,656
it by this tree principle, right? So we can see

563
00:35:50,678 --> 00:35:54,464
here we call the opal client that actually is the

564
00:35:54,502 --> 00:35:58,084
cedar agent. And even if we for example need

565
00:35:58,122 --> 00:36:02,052
to do this authorization in the middle of the code, we are not

566
00:36:02,106 --> 00:36:06,244
dirting the business logic, we are just doing the

567
00:36:06,282 --> 00:36:09,690
same authorization function again and again.

568
00:36:10,220 --> 00:36:13,592
So let's see how it is work. So I already run

569
00:36:13,646 --> 00:36:17,464
opal here. Opal is getting the git. As you can

570
00:36:17,502 --> 00:36:21,192
see here is pulling the policy git from

571
00:36:21,246 --> 00:36:25,384
our repository and let's see how our rules

572
00:36:25,432 --> 00:36:28,028
looks like. So here is the folder of the policy.

573
00:36:28,194 --> 00:36:31,568
First we have an admin policy. The admin policy

574
00:36:31,654 --> 00:36:36,210
said that every user with the role admin actually

575
00:36:36,900 --> 00:36:40,332
can do anything on the system. The user

576
00:36:40,396 --> 00:36:44,148
policy said that a user can do only get

577
00:36:44,234 --> 00:36:47,316
right? Think about it like anonymous user. So a

578
00:36:47,338 --> 00:36:51,492
user with no role can do only

579
00:36:51,546 --> 00:36:57,384
the get action writer can do more

580
00:36:57,422 --> 00:37:00,692
actions than that. For example, a writer

581
00:37:00,756 --> 00:37:03,690
can do post and put.

582
00:37:04,780 --> 00:37:09,252
Of course it will also derive the user attribute

583
00:37:09,396 --> 00:37:12,872
and writer can also post and put

584
00:37:13,006 --> 00:37:16,136
permitio. Now I already ran this node

585
00:37:16,168 --> 00:37:19,932
JS application. Let's try to do something

586
00:37:20,066 --> 00:37:21,340
in a user.

587
00:37:24,100 --> 00:37:28,348
So I'm trying here to post an article as a user.

588
00:37:28,444 --> 00:37:32,524
And as you can imagine, I'll not be able to do that. Access denied.

589
00:37:32,652 --> 00:37:36,596
But what happened if I'll try to do the same one as a

590
00:37:36,618 --> 00:37:40,470
writer? Okay, so here

591
00:37:43,160 --> 00:37:48,524
I'm doing as a writer. I can see that the article created,

592
00:37:48,672 --> 00:37:52,216
right? So all the decision happened not in

593
00:37:52,238 --> 00:37:56,648
the application, happened as a result of the policy.

594
00:37:56,734 --> 00:38:00,828
Cedar of the cedar policy. The nice thing is

595
00:38:00,914 --> 00:38:04,508
that if I want to change my policy, so for example,

596
00:38:04,594 --> 00:38:08,590
I want now to do ABAC, okay, I want

597
00:38:08,960 --> 00:38:12,560
the writer, I want them to be allowed to write

598
00:38:12,630 --> 00:38:15,580
article and publish it immediately.

599
00:38:15,740 --> 00:38:19,120
Only if, let's say they are senior in the system.

600
00:38:19,190 --> 00:38:22,912
If they have lot of karma. If they don't have this

601
00:38:22,966 --> 00:38:27,316
karma, I don't want them to

602
00:38:27,338 --> 00:38:31,184
be allowed to publish published articles.

603
00:38:31,312 --> 00:38:35,172
So in a traditional way, I should

604
00:38:35,306 --> 00:38:38,888
go to my application and write

605
00:38:38,974 --> 00:38:42,504
this policy logic in a policy as code way.

606
00:38:42,622 --> 00:38:46,296
I'm just having to change the policy

607
00:38:46,398 --> 00:38:50,408
here. So as you can see, I limit the permission.

608
00:38:50,504 --> 00:38:53,932
I limit the permission to do post and put of

609
00:38:53,986 --> 00:38:57,228
writers into writers with more than 1000

610
00:38:57,314 --> 00:39:01,116
karma. But that's valid only

611
00:39:01,218 --> 00:39:05,180
if the article is published. If the article is not published,

612
00:39:05,260 --> 00:39:08,928
I'm still allowed them to do it. Okay,

613
00:39:09,094 --> 00:39:12,432
where is karma getting from? So if you remember,

614
00:39:12,566 --> 00:39:15,964
we have here this data json. This data json.

615
00:39:16,012 --> 00:39:19,136
Think about it as an identity provider,

616
00:39:19,248 --> 00:39:23,296
which is something also that we are connecting to the authorization microservice.

617
00:39:23,408 --> 00:39:26,696
So the admin will be allowed to do everything. It's not part

618
00:39:26,718 --> 00:39:31,268
of the ABAC, but the writer, the senior writer

619
00:39:31,364 --> 00:39:35,512
will be able to do the publish. True, because he had

620
00:39:35,566 --> 00:39:39,320
more karma than the writer that has only 800

621
00:39:39,390 --> 00:39:43,144
karma now we change the writer cedar

622
00:39:43,192 --> 00:39:46,990
file and what we need to do is just

623
00:39:47,440 --> 00:39:50,964
commit this file into the git repository,

624
00:39:51,112 --> 00:39:55,040
right? Let's do this way git commit

625
00:39:55,540 --> 00:39:59,724
minus a minus m abac

626
00:39:59,852 --> 00:40:02,956
policy. Now I committed

627
00:40:02,988 --> 00:40:05,410
the file and as you can see here,

628
00:40:07,140 --> 00:40:10,900
as soon the opal will get an update

629
00:40:12,200 --> 00:40:19,476
that a new change is happened to

630
00:40:19,498 --> 00:40:22,824
the policies code soon. We can see

631
00:40:22,862 --> 00:40:26,328
that it takes a bit of time to update sometimes,

632
00:40:26,494 --> 00:40:30,712
but it's still really fast because you don't need all the software development

633
00:40:30,776 --> 00:40:34,156
CI CD to make it. And as you can see here it

634
00:40:34,178 --> 00:40:37,420
got a notification of a new policy that updated.

635
00:40:37,760 --> 00:40:41,640
If I'll try now to do this call

636
00:40:41,810 --> 00:40:45,008
in the same of writer, what will happen? The access

637
00:40:45,094 --> 00:40:48,464
will be denied because this writer has not

638
00:40:48,502 --> 00:40:52,210
enough karma. But if I'll do the same but

639
00:40:52,580 --> 00:40:56,500
with the senior writer user

640
00:40:58,840 --> 00:41:02,544
the article will create it. It's amazing. I haven't

641
00:41:02,592 --> 00:41:06,264
changed any kind of user data or any

642
00:41:06,302 --> 00:41:10,484
kind of application code and the authorization microservice

643
00:41:10,532 --> 00:41:14,120
did everything for me. And also remember there are not much

644
00:41:14,190 --> 00:41:17,364
than just implement like the Opal

645
00:41:17,412 --> 00:41:20,636
SDK application. And one of the

646
00:41:20,658 --> 00:41:24,396
most amazing thing I also have here a

647
00:41:24,418 --> 00:41:27,992
python application that actually consume

648
00:41:28,136 --> 00:41:31,730
the exact same authorization service.

649
00:41:32,180 --> 00:41:36,576
So we can take one authorization microservice and

650
00:41:36,678 --> 00:41:40,304
ship everything into all of

651
00:41:40,342 --> 00:41:43,500
our application. Isn't that amazing?

652
00:41:43,670 --> 00:41:47,396
So Opal probably can help you reach

653
00:41:47,498 --> 00:41:51,360
in open source everything you have with authentication

654
00:41:51,440 --> 00:41:54,708
provider for authorization using policy

655
00:41:54,794 --> 00:41:58,490
as code and in the most advanced way you can see

656
00:41:58,860 --> 00:42:02,148
permitio. In the other end is the commercial

657
00:42:02,244 --> 00:42:05,496
tool on top of Opal. I'll not

658
00:42:05,598 --> 00:42:09,316
stick on it too because as I say it's a commercial tool but I'm really

659
00:42:09,358 --> 00:42:12,492
inviting you to try it. It has also

660
00:42:12,546 --> 00:42:16,812
the option to edit all the policies in the UI and

661
00:42:16,866 --> 00:42:20,652
scale it and store it and much more feature than

662
00:42:20,706 --> 00:42:24,924
Opal offer. But to start Opal is definitely enough

663
00:42:25,122 --> 00:42:29,244
and I really want to ask you to give

664
00:42:29,282 --> 00:42:33,004
a star for Opal. OPal is an open source OSO you can

665
00:42:33,042 --> 00:42:36,596
support also in contribution, but the first basic support for

666
00:42:36,618 --> 00:42:39,556
open source is of course giving it a start,

667
00:42:39,738 --> 00:42:43,428
giving our more power to continue maintain it to continue

668
00:42:43,594 --> 00:42:46,708
the way for a better access control

669
00:42:46,874 --> 00:42:50,756
for all the application out there. Thank you

670
00:42:50,778 --> 00:42:51,090
very much.

