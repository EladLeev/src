1
00:01:34,260 --> 00:01:37,764
Hello everyone, welcome to my talk. My topic

2
00:01:37,812 --> 00:01:42,196
today is on event streaming and processing with Apache Pulsar.

3
00:01:42,308 --> 00:01:46,240
And again, I'm very happy to be back at Conf 42,

4
00:01:46,310 --> 00:01:49,616
cloud native 2022. This is my

5
00:01:49,638 --> 00:01:54,364
second year joining this conference, so thank you to all of the organizers,

6
00:01:54,412 --> 00:01:58,172
especially to mark for your help. My name is Mary Grygleski.

7
00:01:58,236 --> 00:02:01,680
I'm a streaming developer advocate at

8
00:02:01,750 --> 00:02:04,896
data stacks, and here's

9
00:02:04,928 --> 00:02:07,990
my Twitter handle if you'd like to get a hold of me.

10
00:02:09,240 --> 00:02:12,856
So who is Mary? I'm a senior developer advocate at

11
00:02:12,878 --> 00:02:15,210
Datastax with the streaming team.

12
00:02:15,820 --> 00:02:19,716
As such, Datastax is a company that specializes

13
00:02:19,748 --> 00:02:23,504
in data management and also in NoSQL

14
00:02:23,572 --> 00:02:26,984
database as well as cloud native database.

15
00:02:27,112 --> 00:02:30,984
As a service managed platform, we specialize

16
00:02:31,032 --> 00:02:35,310
in big data. We can handle data in

17
00:02:35,620 --> 00:02:39,584
really huge volumes of so

18
00:02:39,622 --> 00:02:43,296
that's about me. And before this I was at IBM for about three

19
00:02:43,318 --> 00:02:47,088
and a half years with the Java and then websphere team.

20
00:02:47,254 --> 00:02:51,300
So my specialty is in Java cloud native

21
00:02:52,360 --> 00:02:56,000
data DevOps and now moving into more streaming.

22
00:02:56,080 --> 00:02:59,350
And I also work on some reactive stuff in the past.

23
00:03:00,460 --> 00:03:04,228
I'm also a very active community builder.

24
00:03:04,324 --> 00:03:07,704
I'm the president of the Chicago Java users group

25
00:03:07,902 --> 00:03:11,636
as well as the co organizer for several

26
00:03:11,748 --> 00:03:14,990
IBM sponsored meetups in the Chicago area.

27
00:03:16,080 --> 00:03:19,912
And before this too, I was a developer

28
00:03:19,976 --> 00:03:24,360
for over 25 years in various capacity.

29
00:03:24,520 --> 00:03:28,124
But primarily I was really heads down into doing engineering

30
00:03:28,172 --> 00:03:32,476
work development, and then I moved more into technical architecture.

31
00:03:32,668 --> 00:03:36,716
But I've involved, so to speak, in it department,

32
00:03:36,908 --> 00:03:40,208
working in the trenches, doing design integration,

33
00:03:40,304 --> 00:03:44,164
testing, development, deployment and

34
00:03:44,202 --> 00:03:48,064
all kinds of stuff. And when it kind of get into DevOps,

35
00:03:48,112 --> 00:03:52,116
I also got my hands dirty into that. And here are several ways of

36
00:03:52,138 --> 00:03:55,044
how you can stay in touch with me. My Twitter handle,

37
00:03:55,172 --> 00:03:58,744
my LinkedIn profile. I also have a Twitch streams as well as

38
00:03:58,782 --> 00:04:02,200
a discord channel. But I will share this with you towards

39
00:04:02,270 --> 00:04:03,980
the end of this presentation.

40
00:04:05,360 --> 00:04:09,628
So here's today's agenda about

41
00:04:09,714 --> 00:04:13,448
event streaming and event processing using Apache Pulsar.

42
00:04:13,544 --> 00:04:17,148
But first, let's start out with some fundamentals,

43
00:04:17,244 --> 00:04:21,532
talking about what is event streaming, what is event processing,

44
00:04:21,676 --> 00:04:25,468
what is complex event processing, and then event driven

45
00:04:25,564 --> 00:04:28,508
versus message driven type of messaging.

46
00:04:28,604 --> 00:04:32,372
There are some subtle differences in there. Two, very often

47
00:04:32,426 --> 00:04:35,488
two we hear today about events streaming.

48
00:04:35,584 --> 00:04:38,352
All of these things all kind of bundle up altogether.

49
00:04:38,496 --> 00:04:42,100
It's all about asynchronous processing, concurrency,

50
00:04:42,260 --> 00:04:45,992
scalability, especially in the cloud native world too. It makes

51
00:04:46,046 --> 00:04:50,170
the problem even more challenging than before.

52
00:04:50,620 --> 00:04:54,536
Okay, so after this introduction, I'll get into a

53
00:04:54,558 --> 00:04:58,516
bit talking about event processing, the semantics pub sub

54
00:04:58,638 --> 00:05:01,896
queuing these are like typical semantics.

55
00:05:02,088 --> 00:05:05,640
And then why event streaming, right? Why do we want to do this?

56
00:05:05,730 --> 00:05:09,596
And then I'll give you a bit of an intro to Apache Pulsar,

57
00:05:09,708 --> 00:05:12,992
and also Apache pulsar depends very

58
00:05:13,046 --> 00:05:16,620
heavily on Apache bookkeeper

59
00:05:16,700 --> 00:05:20,532
as well as Apache zookeeper. So I'll give you some

60
00:05:20,666 --> 00:05:24,080
kind of background information to that. And then essentially

61
00:05:24,160 --> 00:05:28,390
two, Apache Pulsar is meant, in my opinion, it's really

62
00:05:28,760 --> 00:05:32,552
meant to extend what we have today. For example,

63
00:05:32,606 --> 00:05:36,216
like Kafka. Kafka does its job perfectly well, but there are

64
00:05:36,238 --> 00:05:39,352
certain limitations. So this is where pulsar can

65
00:05:39,486 --> 00:05:43,012
come in and augment the situation, make it

66
00:05:43,086 --> 00:05:46,332
even better. So with this, let me start

67
00:05:46,386 --> 00:05:49,804
this talk, okay, the many facets of

68
00:05:49,842 --> 00:05:53,292
computing events. So first of all,

69
00:05:53,346 --> 00:05:56,396
right, what is an event? And also bear with me too,

70
00:05:56,418 --> 00:05:59,824
if you are coming in here already knowing some of these,

71
00:05:59,862 --> 00:06:03,100
but I have to assume that not everybody has this background.

72
00:06:03,180 --> 00:06:06,256
So I want to go over some basics. So what is

73
00:06:06,278 --> 00:06:09,844
an event like, generically speaking? So for me,

74
00:06:09,882 --> 00:06:13,684
I looked up the dictionary miriamwebster.com right

75
00:06:13,722 --> 00:06:17,764
away. First of all, something like really common to any

76
00:06:17,802 --> 00:06:21,000
kind of scenarios for events, they are really about

77
00:06:21,070 --> 00:06:24,184
something just happens, an occurrence. Now,

78
00:06:24,222 --> 00:06:27,236
as I kind of paged through that list of interpretation,

79
00:06:27,428 --> 00:06:31,640
number four really caught my attention. It's essentially talking about

80
00:06:31,790 --> 00:06:35,864
events being the fundamental entity of observed

81
00:06:35,992 --> 00:06:39,532
physical reality represented by a

82
00:06:39,586 --> 00:06:43,484
point designated. So what is this point? This point is

83
00:06:43,522 --> 00:06:47,164
designated by three coordinates of place. So the

84
00:06:47,202 --> 00:06:51,232
XYZ coordinate coordinates, and then also

85
00:06:51,286 --> 00:06:55,660
one of time. So in the spacetime continuum

86
00:06:55,820 --> 00:06:58,956
and postulated by the theory of relativity,

87
00:06:59,068 --> 00:07:03,044
so it essentially do in computing. And that's how we look

88
00:07:03,082 --> 00:07:06,324
at events. Events is essentially an

89
00:07:06,362 --> 00:07:09,716
occurrence that happens in time and is represented by

90
00:07:09,738 --> 00:07:13,524
the point that's actually then by the three places,

91
00:07:13,572 --> 00:07:16,728
right? The three coordinates of

92
00:07:16,814 --> 00:07:19,896
place, so XYZ, and then in time, too.

93
00:07:19,998 --> 00:07:24,460
So I feel that it's really an exciting topic.

94
00:07:24,800 --> 00:07:28,108
It gets more into the abstract, but also, too, if you

95
00:07:28,114 --> 00:07:32,030
think about it, events actually are more

96
00:07:32,560 --> 00:07:36,172
attuned to what human beings are in computing.

97
00:07:36,236 --> 00:07:40,128
I think when we all first learning about computers, we're kind of

98
00:07:40,294 --> 00:07:43,936
looking at things very mechanical, so to

99
00:07:43,958 --> 00:07:47,164
speak, right? We define data, we flatten

100
00:07:47,212 --> 00:07:50,692
out whatever it is, or maybe like flatten out comes

101
00:07:50,746 --> 00:07:54,980
structure, right? We kind of assign that kind of properties

102
00:07:56,360 --> 00:07:59,604
to your objects and then trying to make sense out of it and then do

103
00:07:59,642 --> 00:08:02,992
the computing. It's actually a bit kind of awkward

104
00:08:03,056 --> 00:08:06,296
if you think about it, right? All of these processing we used to

105
00:08:06,318 --> 00:08:10,532
do would be synchronous, right? It's blocking. If you issue a request,

106
00:08:10,596 --> 00:08:14,176
for example, like in HTTP, even in web interaction,

107
00:08:14,228 --> 00:08:17,832
HTTP protocol is a stateless protocol.

108
00:08:17,896 --> 00:08:21,880
So you issue a request and the request essentially

109
00:08:21,960 --> 00:08:25,116
has to wait. You send a request over, you have to wait for

110
00:08:25,138 --> 00:08:29,340
the response to come back before you can proceed. So it's a very blocking,

111
00:08:29,420 --> 00:08:33,036
very time consuming type of protocol, and it doesn't

112
00:08:33,068 --> 00:08:36,704
really mimic what human beings do. We do well,

113
00:08:36,742 --> 00:08:40,180
do we actually wait even like talking on the phone?

114
00:08:40,250 --> 00:08:43,732
And as you can see, talking on the phone. Real time

115
00:08:43,786 --> 00:08:47,744
communication actually isn't all new. If you think about it, our telephone

116
00:08:47,792 --> 00:08:51,588
systems is essentially real time communication. But think of the

117
00:08:51,594 --> 00:08:55,624
fact that if we do it synchronously, wouldn't it be seem kind of

118
00:08:55,662 --> 00:08:59,144
awkward, like if we call someone, I guess it's probably like

119
00:08:59,182 --> 00:09:03,192
the old walkie talkie, right? When you talk about something, only one person

120
00:09:03,246 --> 00:09:07,164
can talk, and when you're done, you say over. And then

121
00:09:07,202 --> 00:09:11,580
the other, your sender, receiver, or both

122
00:09:11,650 --> 00:09:14,796
persons in the conversation will have to kind of take turns to speak.

123
00:09:14,898 --> 00:09:18,368
So it's a bit kind of like less kind of natural. But again,

124
00:09:18,454 --> 00:09:22,560
this is events. We want events to essentially help with human

125
00:09:22,630 --> 00:09:25,520
conditions and make things happen a lot faster.

126
00:09:26,180 --> 00:09:29,824
So, first of all, what is event streaming processing? It is

127
00:09:29,862 --> 00:09:33,764
really the practice, right, of taking action on a series of

128
00:09:33,802 --> 00:09:37,300
data points that originate from a system

129
00:09:37,370 --> 00:09:40,700
that continuously creates data. So I know it's

130
00:09:40,720 --> 00:09:44,356
like a mouthful, but events essentially refers

131
00:09:44,388 --> 00:09:48,440
to each data point in the system. So if we represent

132
00:09:48,780 --> 00:09:52,564
the stream, right. The stream then basically offers to an ongoing

133
00:09:52,612 --> 00:09:56,012
delivery of those events. So stream can be,

134
00:09:56,146 --> 00:09:59,516
if you represent in a straight line, it can be

135
00:09:59,538 --> 00:10:03,836
many events that are represented by dots that happen in time.

136
00:10:04,018 --> 00:10:07,692
So this is essentially how you can represent events.

137
00:10:07,836 --> 00:10:11,328
And a series of events can also be referred to as a

138
00:10:11,334 --> 00:10:14,992
streaming data or data streams. How about

139
00:10:15,046 --> 00:10:19,076
complex event processing? So, complex event processing, CEP is

140
00:10:19,098 --> 00:10:22,576
a set of techniques for capturing and analyzing

141
00:10:22,608 --> 00:10:26,976
the streams of data as they arrive to identify opportunities

142
00:10:27,088 --> 00:10:30,404
or threats in real time. So we find that,

143
00:10:30,442 --> 00:10:34,308
for example, some kind of security scanning,

144
00:10:34,404 --> 00:10:38,836
monitoring, they are really kind of involves complex event processing.

145
00:10:38,948 --> 00:10:42,216
If something happens, it triggers comes alarm, that type of

146
00:10:42,238 --> 00:10:45,736
scenario. So CEP enables systems and applications

147
00:10:45,768 --> 00:10:49,144
to respond two events to trends and then patterns

148
00:10:49,192 --> 00:10:53,208
in the data as they happen. So that's complex event processing,

149
00:10:53,304 --> 00:10:56,880
essentially. I think we deal with this every single day in our lives.

150
00:10:56,950 --> 00:10:58,930
So we want two do that in computer.

151
00:10:59,780 --> 00:11:03,612
Okay. And now event driven versus message driven

152
00:11:03,676 --> 00:11:07,372
messaging. Event driven, right. This interpretation

153
00:11:07,436 --> 00:11:11,788
I take is actually from Lightbend, the company that makes ACA,

154
00:11:11,964 --> 00:11:15,396
the reactive framework, ACA, reactive systems that

155
00:11:15,418 --> 00:11:19,300
abide by the reactive manifesto. So that's event

156
00:11:19,370 --> 00:11:23,124
driven. What it says is sender emits messages

157
00:11:23,172 --> 00:11:27,316
and interested subscribers can subscribe to the messages. So that's

158
00:11:27,348 --> 00:11:31,144
event driven. Now there's also message driven, but as such

159
00:11:31,182 --> 00:11:35,276
too. Let's go back. Event driven. Think of it more like what we call

160
00:11:35,378 --> 00:11:38,760
publish, subscribe or producer consumer type of systems.

161
00:11:38,920 --> 00:11:42,524
So the sender basically sends the messages without having to

162
00:11:42,562 --> 00:11:46,776
worry about who's going to receive it. It's up to those. The subscribers

163
00:11:46,808 --> 00:11:50,316
who are interested in it will need to subscribe two the messages.

164
00:11:50,428 --> 00:11:54,208
And that's how it works. Now for message driven, it's not the same.

165
00:11:54,294 --> 00:11:57,728
It's basically sender and receiver. They already

166
00:11:57,814 --> 00:12:01,696
have to know they are known to each other beforehand.

167
00:12:01,808 --> 00:12:05,728
So the address needs to be known. So that's message driven

168
00:12:05,824 --> 00:12:09,572
messaging. And usually message driven is really about like two

169
00:12:09,626 --> 00:12:13,400
parties that are communicating with each other.

170
00:12:13,470 --> 00:12:17,112
So they know each other, who they are. So as you can see, these are

171
00:12:17,166 --> 00:12:21,364
differences between the two event driven and message driven

172
00:12:21,412 --> 00:12:25,108
messaging. And now if we look into it,

173
00:12:25,134 --> 00:12:28,652
right, what happens then before event taking

174
00:12:28,706 --> 00:12:32,748
an event approach? I mean, think of it in today's IT system,

175
00:12:32,834 --> 00:12:36,184
in IT department, right? There's still a lot of batch processing

176
00:12:36,232 --> 00:12:38,992
happening. And essentially this is just what happening,

177
00:12:39,046 --> 00:12:42,288
right? We collect all of the data and then kind

178
00:12:42,294 --> 00:12:45,324
of group them all together and then batch them up essentially,

179
00:12:45,452 --> 00:12:49,004
and then have the processing going on perhaps

180
00:12:49,052 --> 00:12:52,672
in the middle of the night when nothing else is happening. So then you don't

181
00:12:52,816 --> 00:12:56,756
take away processing capability in your system to

182
00:12:56,778 --> 00:13:00,336
kind of crunch through all of these heavy data set. So that's

183
00:13:00,368 --> 00:13:03,672
what happened, right? Especially in the 90s, in the early

184
00:13:03,726 --> 00:13:08,212
two thousand s, a lot more batch processing. But as systems

185
00:13:08,276 --> 00:13:11,640
becoming more sophisticated, then we're seeing more and more event

186
00:13:11,710 --> 00:13:15,356
driven type of systems that comes into play. Now don't get me

187
00:13:15,378 --> 00:13:19,240
wrong, batch processing still has its place and it's still very relevant,

188
00:13:19,320 --> 00:13:23,710
especially if you are in IT department that are dealing with

189
00:13:24,880 --> 00:13:28,744
kind of like system of records, like you're processing something

190
00:13:28,802 --> 00:13:31,984
that can be done in batch, I believe too,

191
00:13:32,022 --> 00:13:35,644
even a lot of machine learning processing also being done in batch.

192
00:13:35,692 --> 00:13:40,052
The reason is that the data set is just too big. It's hard to all

193
00:13:40,106 --> 00:13:44,052
processing them all in real time. But then this is the

194
00:13:44,106 --> 00:13:47,584
reason why we want to develop systems

195
00:13:47,632 --> 00:13:50,720
and capability such as Apache Pulsar

196
00:13:50,800 --> 00:13:54,650
is targeting for really the big data set. And that's what it is.

197
00:13:55,260 --> 00:13:59,284
Now let's take a look then into event messaging, some semantics

198
00:13:59,332 --> 00:14:02,612
and patterns. So streaming, right? So streaming.

199
00:14:02,676 --> 00:14:05,964
This is what we are kind of all about. And my job

200
00:14:06,002 --> 00:14:09,352
is essentially about advocating for streaming. So streaming,

201
00:14:09,416 --> 00:14:12,792
when we talk about streaming, is really referring to the pub sub, the publish

202
00:14:12,856 --> 00:14:16,920
subscribe type of a paradigm, right? So publishing client

203
00:14:17,000 --> 00:14:20,704
will sends the data, and then in a pub

204
00:14:20,742 --> 00:14:24,528
sub system there's also always like a middle person, the agent

205
00:14:24,614 --> 00:14:27,888
in the middle called a broker. The broker is the one that's kind of

206
00:14:27,894 --> 00:14:31,316
like mediate and everything. So it receives the messages from the

207
00:14:31,338 --> 00:14:34,852
publisher, publisher sends the data and broker gets

208
00:14:34,906 --> 00:14:38,672
it. And then based on a lot of different types of configuration

209
00:14:38,736 --> 00:14:42,536
parameters, the broker will deliver the messages to those who

210
00:14:42,558 --> 00:14:46,404
are interested in the messages. So it requires subscriber

211
00:14:46,452 --> 00:14:49,544
to subscribe to it. So the subscribing client will

212
00:14:49,582 --> 00:14:53,492
receive the data, but the subscribing client will have to initiate

213
00:14:53,556 --> 00:14:57,132
and subscribe to the topics, right? So very often in a

214
00:14:57,186 --> 00:15:01,096
pubsub system, we're talking about using topics like Kafka

215
00:15:01,128 --> 00:15:04,588
is using topics, Pulsar has it. And even IoT messaging such

216
00:15:04,594 --> 00:15:08,372
as MQTT, also is a pub sub system that has topics.

217
00:15:08,536 --> 00:15:12,016
Topics essentially just label so that you group all

218
00:15:12,038 --> 00:15:15,584
of these messaging together. And then essentially those who are interested will

219
00:15:15,622 --> 00:15:18,900
have to subscribe to that topic to receive it.

220
00:15:18,970 --> 00:15:22,624
Message queueing so what is message queuing? So, message queues

221
00:15:22,672 --> 00:15:26,736
is a form of asynchronous service to service communication

222
00:15:26,848 --> 00:15:30,848
used in serverless and microservices architectures.

223
00:15:31,024 --> 00:15:34,324
Messages are stored in the queues until they are processed

224
00:15:34,372 --> 00:15:37,624
and deleted. So essentially, first in, first out type

225
00:15:37,662 --> 00:15:41,284
of principle applies. And the messages are only intended

226
00:15:41,412 --> 00:15:45,000
for one single customer or consumer.

227
00:15:45,160 --> 00:15:48,892
So only process only once. And message queues can be used

228
00:15:48,946 --> 00:15:52,808
to decouple the heavyweight processing, to buffer

229
00:15:52,904 --> 00:15:56,428
or both work, and to smooth out any kind

230
00:15:56,434 --> 00:15:59,724
of spiky workload. So as you can see, the queuing helps

231
00:15:59,772 --> 00:16:03,324
too, in kind of offloading some of these heavier processing.

232
00:16:03,372 --> 00:16:05,410
So that's what message queueing is.

233
00:16:06,420 --> 00:16:10,544
So about event streaming. So why event streaming, right at this point

234
00:16:10,582 --> 00:16:13,972
in time? Right? So earlier I talked about event streaming is because

235
00:16:14,026 --> 00:16:17,488
it really mimics more of the human behaviors,

236
00:16:17,584 --> 00:16:21,136
a lot more natural to us, but it's also at the same time much harder

237
00:16:21,168 --> 00:16:24,804
to do because now we are talking, bringing into concurrency,

238
00:16:24,932 --> 00:16:28,488
bringing into events that are happening at different times.

239
00:16:28,574 --> 00:16:31,796
It doesn't happen yet, and you have subscriber waiting

240
00:16:31,828 --> 00:16:35,292
for it. So it kind of involves a lot more computing. Well,

241
00:16:35,346 --> 00:16:39,404
kind of managing the computing at the back end too. So it's more

242
00:16:39,442 --> 00:16:42,700
complicated, but you reap the rewards, the benefits

243
00:16:42,850 --> 00:16:46,044
of it being real time. So that's what it is.

244
00:16:46,082 --> 00:16:49,632
So what's driving this change? Right. So if you look into it, we use

245
00:16:49,686 --> 00:16:53,184
real time data to enhance customer experience and

246
00:16:53,222 --> 00:16:55,888
create a competitive advantage for your business.

247
00:16:55,974 --> 00:16:59,184
So on a high level, that's what it is. Marketing people, we like

248
00:16:59,222 --> 00:17:01,990
to talk about advocating for real time.

249
00:17:02,440 --> 00:17:05,716
Essentially two things happen right away. If you are

250
00:17:05,738 --> 00:17:09,044
at a football game, you want to know the statistics of a player right

251
00:17:09,082 --> 00:17:12,604
away. It can be streams, that data can be streamed immediately,

252
00:17:12,672 --> 00:17:16,136
analyzed and output for you. Within seconds you

253
00:17:16,158 --> 00:17:20,024
can get that kind of a data. So that's kind of like some advantage of

254
00:17:20,062 --> 00:17:23,740
that. And then there's also data pipelines. Two, right.

255
00:17:23,810 --> 00:17:27,512
That's actually very useful to build AI and ML

256
00:17:27,576 --> 00:17:31,212
machine learning, smart models from time

257
00:17:31,266 --> 00:17:35,144
series event streams, for example. So that's kind of data pipeline

258
00:17:35,192 --> 00:17:38,816
is another good usages of event streaming or

259
00:17:38,838 --> 00:17:42,512
kind of like how event streaming can help with building data

260
00:17:42,566 --> 00:17:46,256
pipelines and then also kind

261
00:17:46,278 --> 00:17:49,764
of one important aspect of event streaming is it

262
00:17:49,802 --> 00:17:53,700
allows for scalability elasticity to happen

263
00:17:53,770 --> 00:17:56,820
a lot more in a more flexible way.

264
00:17:56,970 --> 00:18:00,084
It helps to meet the demands of large volumes of data

265
00:18:00,202 --> 00:18:04,356
generated by application operating at the edge Iot systems.

266
00:18:04,388 --> 00:18:08,552
For example, if you use like a pub sub kind of broker, you can actually

267
00:18:08,606 --> 00:18:12,484
have like a billion, or not even billion, maybe like petabytes

268
00:18:12,532 --> 00:18:16,536
of data within. Well, I guess maybe I'm exaggerating, but there's

269
00:18:16,568 --> 00:18:19,932
been actually benchmark being done to like 100

270
00:18:20,066 --> 00:18:24,236
billion messages being published with

271
00:18:24,258 --> 00:18:28,076
the topics too, like that. So things like that, right. It's really the scalability

272
00:18:28,188 --> 00:18:31,644
aspect that it helps, especially in today's cloud native

273
00:18:31,692 --> 00:18:35,084
world. Now then, why event streaming?

274
00:18:35,132 --> 00:18:38,816
So let's talk a bit about it. We want to watch for events with

275
00:18:38,838 --> 00:18:42,416
the system or application, and you want to also subscribe

276
00:18:42,448 --> 00:18:46,116
to topics to see certain event types, right? And then you

277
00:18:46,138 --> 00:18:49,892
want to make decisions on data in real time, not after the event.

278
00:18:49,946 --> 00:18:53,248
You want things to happen, you want to see the data, you want to see

279
00:18:53,274 --> 00:18:56,648
it being transformed and churn out some useful data for you.

280
00:18:56,734 --> 00:19:00,584
The real time aspect is what is kind of the

281
00:19:00,622 --> 00:19:04,056
core of why we want to do event streaming. We wanted to

282
00:19:04,078 --> 00:19:07,692
be able to ingest high frequency of messages, but with very

283
00:19:07,746 --> 00:19:11,356
low latency. Right. There's not much of a gap in between when you

284
00:19:11,378 --> 00:19:15,164
receive your messages and then being able to process and output it to

285
00:19:15,282 --> 00:19:18,592
some format, for example. So essentially it's the real time

286
00:19:18,646 --> 00:19:22,240
aspect. And now comes Apache Pulsar.

287
00:19:22,740 --> 00:19:26,128
So what is Apache Pulsar? Right. So as such,

288
00:19:26,214 --> 00:19:29,752
Apache is Apache Software foundation. It is open source,

289
00:19:29,836 --> 00:19:33,156
governed by the Apache Software foundation. There's like proper

290
00:19:33,258 --> 00:19:36,916
top level project. It was actually open source by

291
00:19:36,938 --> 00:19:40,992
Yahoo. It was first developed by Yahoo back in 2016,

292
00:19:41,056 --> 00:19:44,096
2000, and actually 15 or 14 that time frame.

293
00:19:44,208 --> 00:19:48,212
Then Yahoo contributed two Apache Software foundation

294
00:19:48,276 --> 00:19:51,476
in 2016, and then in 2018,

295
00:19:51,588 --> 00:19:54,856
within less than two years, in fact, it already became a

296
00:19:54,878 --> 00:19:58,156
top level project. The reason is that it's really built in

297
00:19:58,178 --> 00:20:01,772
a lot of the capability of doing cloud native that is really

298
00:20:01,826 --> 00:20:05,164
more lacking in most of the other systems, in fact all of the other

299
00:20:05,202 --> 00:20:08,976
systems. So that's where it kind of comes out kind of outstanding in

300
00:20:08,998 --> 00:20:12,812
that regard. It is again cloud native

301
00:20:12,876 --> 00:20:16,892
design. It's cluster based, multi tenancy, and the client

302
00:20:16,956 --> 00:20:20,580
API surprisingly isn't like way too complicated or anything.

303
00:20:20,730 --> 00:20:23,920
It supports Java, C sharp, Python,

304
00:20:24,000 --> 00:20:26,820
Go, JavaScript among others.

305
00:20:26,970 --> 00:20:30,864
Scala too, for example, if you want JVM languages, it's also supported.

306
00:20:30,912 --> 00:20:34,024
There are others ones too, so you can check the website.

307
00:20:34,222 --> 00:20:38,132
And basically the key of it is that pulsar separates

308
00:20:38,196 --> 00:20:42,072
out the compute and the storage. And that's what makes it a lot

309
00:20:42,126 --> 00:20:46,620
more easier from the scalability kind of perspective.

310
00:20:47,200 --> 00:20:50,296
And another thing to pulsar being a pub sub broker,

311
00:20:50,408 --> 00:20:54,024
it has built in already, like guaranteed message delivery

312
00:20:54,152 --> 00:20:58,256
mechanism in there too. So if a message successfully reaches a

313
00:20:58,278 --> 00:21:01,852
pulsar broker, it will be delivered to its intended

314
00:21:01,916 --> 00:21:05,200
target, right? So depending on the message level, for example,

315
00:21:05,270 --> 00:21:08,768
quality of service, it can be quality of service level zero,

316
00:21:08,854 --> 00:21:11,270
it's fire and forget then. In that case,

317
00:21:11,640 --> 00:21:15,280
the broker isn't held accountable for kind of guaranteeing messages

318
00:21:15,360 --> 00:21:20,016
delivery. And then you can have QoS one, which is like one or more delivery,

319
00:21:20,128 --> 00:21:23,784
or QoS two, which is exactly one. So that's a lot more

320
00:21:23,822 --> 00:21:27,316
precise with QoS two. So all of these are being supported

321
00:21:27,348 --> 00:21:30,712
by pulsar too. And then as such,

322
00:21:30,766 --> 00:21:33,088
two, pulsar is very lightweight,

323
00:21:33,204 --> 00:21:37,080
serverless, has a very lightweight serverless functions

324
00:21:37,160 --> 00:21:40,524
framework too. It's called pulsar functions, and it

325
00:21:40,562 --> 00:21:44,376
creates complex processing logic within a pulsar cluster.

326
00:21:44,488 --> 00:21:47,708
For example, if you're building data pipeline, you want

327
00:21:47,714 --> 00:21:50,784
to fetch the data and you want to do some work of

328
00:21:50,822 --> 00:21:54,480
transforming your data or mediating it or whatever you need to be doing.

329
00:21:54,630 --> 00:21:58,728
So you can leverages on pulsar functions to help you to transform and mediate

330
00:21:58,764 --> 00:22:02,390
all of these messages too. So it kind of

331
00:22:03,400 --> 00:22:06,676
comes in very handy. It has already command line that helps you

332
00:22:06,698 --> 00:22:09,888
to deploy, build your function, and then deploy

333
00:22:09,984 --> 00:22:13,208
eventually kind of get it running right, or you can kind

334
00:22:13,214 --> 00:22:16,664
of do it using the console. For example, I work for data sachs now,

335
00:22:16,702 --> 00:22:21,188
so we also have Astra streaming, which is the commercial version,

336
00:22:21,364 --> 00:22:24,324
Astradb is the commercial managed database,

337
00:22:24,372 --> 00:22:27,896
Cassandra database, and Astra streaming is attributed

338
00:22:27,928 --> 00:22:32,184
two the streaming that Apache pulsar enables Cassandra

339
00:22:32,232 --> 00:22:35,804
to have. So then you really enable more of the real time

340
00:22:35,922 --> 00:22:39,516
processing aspect, right? So you can actually use pulsar functions

341
00:22:39,548 --> 00:22:43,344
to do data transformation as well. Okay, that's just

342
00:22:43,382 --> 00:22:47,344
an example. And then they're also like the storage offloads too, are also

343
00:22:47,382 --> 00:22:51,436
like tiered storage offloads. What it means

344
00:22:51,478 --> 00:22:54,736
is that it offloads data from hot and warm

345
00:22:54,768 --> 00:22:58,144
storage to cold and long term storage when the data is bring

346
00:22:58,192 --> 00:23:02,164
out. So when it's kind of fresh, maybe you still keep it in

347
00:23:02,202 --> 00:23:05,592
hot or warm storage or in memory as well.

348
00:23:05,646 --> 00:23:08,884
Or essentially two I wanted to bring out is the bookkeeper.

349
00:23:09,012 --> 00:23:12,276
And so basically it knows, it has built in capability

350
00:23:12,388 --> 00:23:16,124
to recognize that if some data is kind of aging out, not being

351
00:23:16,162 --> 00:23:19,630
used as much, then we may as well write it,

352
00:23:20,000 --> 00:23:23,912
store it into persistent long term storage and cold storage,

353
00:23:23,976 --> 00:23:27,164
kind of like that. So essentially Pulsar has this built

354
00:23:27,202 --> 00:23:30,240
in to handle the tier storage offloads.

355
00:23:30,740 --> 00:23:34,720
So again, what is pulsar? Right, let's give a bit of

356
00:23:34,870 --> 00:23:38,844
some detail about it. So it's a unified distributed

357
00:23:38,892 --> 00:23:42,164
messaging and streaming platform. So what does it mean?

358
00:23:42,202 --> 00:23:45,600
Right, so basically too, it supports messaging.

359
00:23:45,760 --> 00:23:49,764
It supports messaging not only pops up, but also the queuing too.

360
00:23:49,882 --> 00:23:53,700
Not only the messaging itself, but it does transformation and mediation

361
00:23:53,780 --> 00:23:57,828
through pulsar function and things of that nature. Right? So it's

362
00:23:57,844 --> 00:24:01,224
really a truly distributed messaging platform that's suited for

363
00:24:01,262 --> 00:24:05,436
today's cloud native world. It's open source, right? Again, it kind

364
00:24:05,458 --> 00:24:09,832
of came out from Yahoo, now part of Apache

365
00:24:09,896 --> 00:24:13,384
Software foundation, and in fact one of the fastest growing

366
00:24:13,512 --> 00:24:17,024
projects with a lot more committers has, you can see over on these

367
00:24:17,062 --> 00:24:20,800
graphs, right? So GitHub stars has increased since

368
00:24:20,870 --> 00:24:24,300
is becoming like 2018,

369
00:24:24,380 --> 00:24:27,856
when it kind of became top level. You can see too,

370
00:24:27,878 --> 00:24:30,624
it's like kind of a bring kind of jump,

371
00:24:30,672 --> 00:24:34,084
2 June 2021 and so are

372
00:24:34,122 --> 00:24:37,648
the number of contributors and monthly active contributors.

373
00:24:37,744 --> 00:24:41,068
Actually, we kind of overcome that in June

374
00:24:41,104 --> 00:24:44,936
of 2021, overcome that of Kafka too. So as

375
00:24:44,958 --> 00:24:47,320
you can see, it's gaining popularity.

376
00:24:47,980 --> 00:24:51,352
And again, cloud native ready. Kubernetes ready.

377
00:24:51,406 --> 00:24:55,224
There's also a Cassandra, or actually I should say Cassandra

378
00:24:55,272 --> 00:24:58,764
is more like the, sorry, that's kubernetes for

379
00:24:58,802 --> 00:25:02,236
Cassandra. But the thing is too, is that Pulsar is almost

380
00:25:02,338 --> 00:25:06,204
like it's basically already to work with kubernetes and

381
00:25:06,242 --> 00:25:09,724
with Cassandra too. And it supports multi cloud and hybrid

382
00:25:09,772 --> 00:25:12,976
cloud. And in fact, I will share with you a link to how you can

383
00:25:12,998 --> 00:25:16,476
actually quickly test out pulsar through the Astra

384
00:25:16,508 --> 00:25:19,904
streaming too shortly. So four reasons why

385
00:25:19,942 --> 00:25:23,216
Pulsar is essential to the modern data stacks.

386
00:25:23,248 --> 00:25:26,836
Right? Okay, so we'll look at that after we kind of show you a

387
00:25:26,858 --> 00:25:30,196
bit of information too. Who else is using pulsar? Look at

388
00:25:30,218 --> 00:25:32,852
these companies, right? Comcast, Yahoo. Overstock,

389
00:25:32,916 --> 00:25:35,652
Splunk, General Motors, iterable,

390
00:25:35,796 --> 00:25:39,400
Cargill, Verizon, Tencent, Shopin,

391
00:25:40,060 --> 00:25:43,816
Nutanix, all of these. So these are like major players too.

392
00:25:43,918 --> 00:25:47,532
Pretty major players. Right? And then also sorry

393
00:25:47,586 --> 00:25:50,924
for this kind of more marketing slides. Two, I know

394
00:25:50,962 --> 00:25:54,492
I'm talking to developers, but I hope you appreciate that too. The fact

395
00:25:54,546 --> 00:25:58,092
is that there's been some comparison. Two, it really lowest

396
00:25:58,156 --> 00:26:02,124
or three year cost compared to Kafka too because of its capability.

397
00:26:02,252 --> 00:26:06,892
So it's higher performing savings for high complexity

398
00:26:06,956 --> 00:26:10,316
scenarios and savings for higher data volume scenarios.

399
00:26:10,348 --> 00:26:13,936
Two, and again, some brief

400
00:26:13,968 --> 00:26:17,204
history of Apache Pulsar, but essentially I already talk about

401
00:26:17,242 --> 00:26:20,320
it so I won't kind of go through all of it. Again, it's cloud native,

402
00:26:20,400 --> 00:26:24,024
distributed unified messaging and streaming platform has been open

403
00:26:24,062 --> 00:26:27,124
source as Apache top level project since October

404
00:26:27,172 --> 00:26:31,124
of 2018. And we just seeing the trends, it keeps growing

405
00:26:31,172 --> 00:26:34,488
too. And as you can see, it also has the lock

406
00:26:34,504 --> 00:26:37,772
four j two fixed back in December too.

407
00:26:37,826 --> 00:26:41,336
As soon as that came up, the community already delivered a patch

408
00:26:41,368 --> 00:26:45,084
for that quickly. So now let's kind of

409
00:26:45,202 --> 00:26:48,508
go a little into more of the pulsar. It is different,

410
00:26:48,594 --> 00:26:51,888
right? So why is it different? Right. So here it is. I just want to

411
00:26:51,894 --> 00:26:54,976
point out to you, there's a producer, so client application

412
00:26:55,078 --> 00:26:58,584
sending messages to topic managed by the broker.

413
00:26:58,732 --> 00:27:02,228
It's up to the consumer. The ones that are interested in

414
00:27:02,314 --> 00:27:05,940
consuming the messages, I'm interested in that I need to subscribe

415
00:27:06,600 --> 00:27:10,484
to the topic of where I know the

416
00:27:10,522 --> 00:27:13,736
producer is going to essentially send the messages. Two.

417
00:27:13,838 --> 00:27:17,576
So consumers subscribe to the topics and basically then there's the

418
00:27:17,598 --> 00:27:21,636
broker. The broker essentially is a stateless process that handles incoming

419
00:27:21,668 --> 00:27:24,504
messages and message dispatching,

420
00:27:24,632 --> 00:27:28,536
communicates with the pulsar configuration store and store messages

421
00:27:28,568 --> 00:27:32,856
in the bookkeeper instances. So the broker itself actually interacts

422
00:27:32,888 --> 00:27:36,992
with the bookkeeper as well. So what is bookkeeper? Right. So again,

423
00:27:37,126 --> 00:27:40,908
pulsar is unique in the sense that it doesn't

424
00:27:41,004 --> 00:27:44,704
want its compute side to

425
00:27:44,742 --> 00:27:48,016
kind of be worried about doing bookkeeping, as we

426
00:27:48,038 --> 00:27:51,296
all know, right. As human beings we're doing accounting. Do we

427
00:27:51,318 --> 00:27:54,788
like accounting? Most of us don't because it's crunching through a

428
00:27:54,794 --> 00:27:58,592
lot of numbers and all of these things. So it's kind of tedious,

429
00:27:58,656 --> 00:28:02,232
right? A lot of these tedious work, but yet they are utter importance too.

430
00:28:02,286 --> 00:28:05,736
So Apache has a project called bookkeeper. Essentially it

431
00:28:05,758 --> 00:28:09,048
does electronic ledger and journals and all of these things.

432
00:28:09,214 --> 00:28:12,836
If you are accounting kind of enthusiasts or you're

433
00:28:12,868 --> 00:28:16,124
familiar with it, then you're familiar with those terms. Essentially it's just

434
00:28:16,162 --> 00:28:19,128
bookkeeping being electronic, going digital.

435
00:28:19,224 --> 00:28:23,592
And that's what pulsar leverages on for is logging,

436
00:28:23,736 --> 00:28:27,132
storing all of these things, right? And so as you can see,

437
00:28:27,266 --> 00:28:31,292
bookie itself has different segments in the storage

438
00:28:31,356 --> 00:28:35,164
kind of for better organization and managing and faster

439
00:28:35,212 --> 00:28:38,924
retrieval and all of these things too. So broker is the one that's serving,

440
00:28:38,972 --> 00:28:42,848
but it also interacts with the bookkeeper. Now there's also zookeeper

441
00:28:43,024 --> 00:28:47,200
I bet comes of you or most of you probably already know of zookeeper.

442
00:28:47,360 --> 00:28:50,596
That's actually, it's more like it manages the cluster, right?

443
00:28:50,618 --> 00:28:54,164
The metadata, the coordinating tasks

444
00:28:54,212 --> 00:28:58,184
between different pulsar clusters. So as such, right? The name zookeeper is

445
00:28:58,222 --> 00:29:01,912
basically to keep order in the zoo. So as you can imagine, right,

446
00:29:01,966 --> 00:29:06,296
this whole how cloud native thing can become very confusing.

447
00:29:06,328 --> 00:29:10,300
So zookeeper comes in, manages all of these metadata,

448
00:29:10,640 --> 00:29:14,056
handle all the coordination, making sure nobody steps on each other's

449
00:29:14,088 --> 00:29:17,760
toes essentially. So that's essentially pulsar component.

450
00:29:18,180 --> 00:29:21,264
Just wanted to highlight too the design principle of

451
00:29:21,302 --> 00:29:24,976
pulsar. It has adopted a

452
00:29:24,998 --> 00:29:28,400
tiered architecture design kind of approach, right?

453
00:29:28,470 --> 00:29:32,080
And it's a traditional multi node architecture.

454
00:29:32,160 --> 00:29:36,048
So as you can see, we already looked at producer consumer.

455
00:29:36,144 --> 00:29:39,568
They interact with the broker, producer sends message to the broker,

456
00:29:39,664 --> 00:29:43,104
consumer is interested in it, will subscribe to the topic,

457
00:29:43,152 --> 00:29:46,376
right. It's actually, I should say producer sends messages to

458
00:29:46,398 --> 00:29:49,444
the topic and basically it's the broker that kind of manages,

459
00:29:49,492 --> 00:29:53,368
right. But essentially too, broker also will have to acknowledge back

460
00:29:53,534 --> 00:29:56,350
on the network kind of layer too.

461
00:29:56,960 --> 00:30:00,652
Okay. So as you can see too, topics too can be partitioned off

462
00:30:00,706 --> 00:30:04,536
too, as you can see. So broker has different topics bring partitioned

463
00:30:04,568 --> 00:30:08,172
off. And essentially too, this distributed architecture

464
00:30:08,236 --> 00:30:11,200
supports like horizontal scaling really well.

465
00:30:11,350 --> 00:30:14,972
And partition topics, two abstraction, mass complexity

466
00:30:15,036 --> 00:30:18,304
for consumers, right? So consumer don't have to worry about it.

467
00:30:18,342 --> 00:30:22,308
It's the broker that manages all of these topics are partitioned too.

468
00:30:22,394 --> 00:30:26,720
So common challenges, right? What are some of those? So essentially

469
00:30:26,800 --> 00:30:30,576
if you look into it, why using Apache

470
00:30:30,608 --> 00:30:34,532
pulsar? If you look at it, traditional scaling will require partitioning,

471
00:30:34,596 --> 00:30:38,548
rebalancing all of these things and having pulsar

472
00:30:38,644 --> 00:30:42,632
actually separate up the compute and the storage, it helps the

473
00:30:42,686 --> 00:30:46,196
scalability and rebalancing much more like cleaner

474
00:30:46,228 --> 00:30:49,484
than it would be if you have a component that

475
00:30:49,522 --> 00:30:53,304
kind of combines both compute and logging, right? So if you need to rebalance,

476
00:30:53,352 --> 00:30:56,728
how do you do it? It's quite a messy situation, but if you

477
00:30:56,754 --> 00:31:00,016
separate out the concern, they each takes care of things kind of

478
00:31:00,038 --> 00:31:03,424
independently, but yet they are all tied together too

479
00:31:03,462 --> 00:31:06,844
through the broker. So tightly complex persistence

480
00:31:06,892 --> 00:31:10,564
and message service capabilities impose high costs on

481
00:31:10,602 --> 00:31:14,160
historical data. The trade offs to support partition topics

482
00:31:14,240 --> 00:31:17,936
came at the expense of messaging semantics needed for use comes

483
00:31:18,048 --> 00:31:24,196
such has queueing. So as you can see too, basically if

484
00:31:24,218 --> 00:31:27,752
you don't kind of have separate out this

485
00:31:27,806 --> 00:31:31,252
concern, then basically two, the messaging semantics

486
00:31:31,316 --> 00:31:34,536
will have to kind of take care of use comes

487
00:31:34,568 --> 00:31:37,550
such as like queuing essentially that's what it is.

488
00:31:38,640 --> 00:31:42,044
Okay, let's take another look too

489
00:31:42,082 --> 00:31:44,936
into this tiered architecture design of pulsar,

490
00:31:45,048 --> 00:31:48,604
multi node architecture. And so what's the big deal, right? So essentially it's

491
00:31:48,652 --> 00:31:52,028
fast, it's low impact, it's horizontal, it supports

492
00:31:52,044 --> 00:31:56,012
horizontal scaling and reduce the capex and opex

493
00:31:56,076 --> 00:31:59,796
too, which is like capital expenditure and operation expenditure at

494
00:31:59,818 --> 00:32:03,652
your company. So broker is stateless and it has built

495
00:32:03,706 --> 00:32:07,472
in cloud balancing and the scaling is pretty instantaneous.

496
00:32:07,616 --> 00:32:10,896
And essentially disaster recovery is zero impact.

497
00:32:11,008 --> 00:32:14,664
So anytime you need to have recovery of these things,

498
00:32:14,782 --> 00:32:18,056
it pretty much can kind of scale up and down and takes care

499
00:32:18,078 --> 00:32:21,770
of thing itself. If it is disaster recovery, you need to

500
00:32:22,220 --> 00:32:25,404
duplicate certain setups and stuff. So that

501
00:32:25,442 --> 00:32:28,556
one too, because of the nature of the design of the

502
00:32:28,578 --> 00:32:32,328
multi tiered architecture and separation of compute

503
00:32:32,424 --> 00:32:36,216
and storage, it's actually make it a lot more flexible,

504
00:32:36,328 --> 00:32:40,028
more dynamic in that sense. Now let's get into bookkeeper a

505
00:32:40,034 --> 00:32:43,712
little bit. So bookkeeper again is the bookkeeper very

506
00:32:43,766 --> 00:32:48,160
scalable and is wall based. So this is the right archive.

507
00:32:50,600 --> 00:32:54,084
But this is a protocol that helps with the writing of

508
00:32:54,122 --> 00:32:57,396
all of these log records too. And it kind

509
00:32:57,418 --> 00:33:00,636
of helps with the ordering as well. So fault tolerant

510
00:33:00,688 --> 00:33:02,810
and low latency storage services,

511
00:33:03,260 --> 00:33:07,608
tunable consistency for message replication, the ensemble size,

512
00:33:07,774 --> 00:33:11,016
write quorum, act quorum, all of these things, right? So you

513
00:33:11,038 --> 00:33:14,980
can tune that too in bookkeeper. So has, you can see

514
00:33:15,070 --> 00:33:19,224
if you kind of lump all these into pulsar

515
00:33:19,272 --> 00:33:22,824
to do it, it will be overburdening pulsar. So that's why pulsar doesn't

516
00:33:22,872 --> 00:33:26,456
concern itself with things like that with bookkeeping, because pulsar

517
00:33:26,488 --> 00:33:30,156
is a lot larger. Well I shouldn't say larger, but has its own fish to

518
00:33:30,178 --> 00:33:33,388
fry. That's important to handle. All of the brokers,

519
00:33:33,484 --> 00:33:36,560
all of the messaging guarantee, all of them. So I don't want to

520
00:33:36,630 --> 00:33:40,912
overburn myself and having to worry about bookkeeper. I let bookkeeper

521
00:33:40,976 --> 00:33:44,212
do it, the bookkeeper. So as you can see,

522
00:33:44,266 --> 00:33:47,552
right, they're also journaling in bookkeeper.

523
00:33:47,616 --> 00:33:51,568
And it's essentially too, it enables like fast write is guaranteed

524
00:33:51,744 --> 00:33:55,236
through the journals and then ledgers, two electronic ledgers

525
00:33:55,268 --> 00:33:59,380
are basically segment centric data persistence via

526
00:33:59,460 --> 00:34:03,764
ledgers too. So as you can see, it goes very deep into bookkeeper.

527
00:34:03,812 --> 00:34:07,536
It is a library, a project of its own under Apache.

528
00:34:07,588 --> 00:34:11,212
So you can always look that up for more details as well, if you'd like.

529
00:34:11,266 --> 00:34:15,112
But for this particular presentation, I won't go into all the deep details,

530
00:34:15,176 --> 00:34:18,964
not just yet. Okay, so essentially

531
00:34:19,032 --> 00:34:22,864
then we look into the capability of Apache pulsar. So what problems is

532
00:34:22,902 --> 00:34:26,284
it kind of trying to solve? So essentially too, it solves

533
00:34:26,332 --> 00:34:30,084
also the problem of bolt on, because it represents the next

534
00:34:30,122 --> 00:34:33,476
generation of enterprise messaging. So think of

535
00:34:33,498 --> 00:34:36,896
it more like not coming in as a disruptor.

536
00:34:37,088 --> 00:34:40,212
Well, disruptor in a sense, but it doesn't really disrupt you.

537
00:34:40,266 --> 00:34:44,116
Meaning that if I'm on Prem, just keep going on Prem, I don't

538
00:34:44,148 --> 00:34:48,040
worry about it. Just essentially pop

539
00:34:48,110 --> 00:34:51,624
in pulsar, right. It's like a big giant bolt on.

540
00:34:51,662 --> 00:34:55,268
Just kind of like nail it in and it can work too.

541
00:34:55,294 --> 00:34:59,292
You can configure, obviously, and then you can get your whole thing running

542
00:34:59,426 --> 00:35:03,448
has is right. For example, this picture in here, you've got Kafka JMs

543
00:35:03,544 --> 00:35:07,324
Java messaging service, rabbit MQ. All of these are a bit

544
00:35:07,362 --> 00:35:11,040
of an older messaging now, but you have it

545
00:35:11,190 --> 00:35:14,464
in your company, you don't want to quickly change it again.

546
00:35:14,502 --> 00:35:17,808
It costs a lot of time and money too, so you want to keep using

547
00:35:17,894 --> 00:35:21,616
because it contains very important business knowledge. That will

548
00:35:21,638 --> 00:35:25,188
be hard if you try to migrate. So you can keep those. And in the

549
00:35:25,194 --> 00:35:28,304
meantime, kind of drop in pulsar. And pulsar

550
00:35:28,352 --> 00:35:31,624
is non disruptive like this. You just plug it in and then it fills.

551
00:35:31,662 --> 00:35:34,724
Get to work. Why? Because it is actually a unified

552
00:35:34,772 --> 00:35:38,004
solution. It comes in, has like an ambassador,

553
00:35:38,132 --> 00:35:41,236
like unifying everything. A unified solution for pubsub

554
00:35:41,268 --> 00:35:44,824
up for streaming, for messaging. Right. For queueing

555
00:35:44,952 --> 00:35:48,792
and also for the messaging, mediation and enrichment,

556
00:35:48,856 --> 00:35:52,572
the transformation, all of these. If you think of this

557
00:35:52,626 --> 00:35:56,028
kind of capability, I don't think there will be another project

558
00:35:56,114 --> 00:35:58,896
out there, a library out there that can support all of these.

559
00:35:58,998 --> 00:36:03,372
All capabilities of pub sub queueing, streaming, message mediation

560
00:36:03,436 --> 00:36:06,720
and enrichment. And then out of the box

561
00:36:06,790 --> 00:36:10,512
capability include. Right. So think of the fact that you can run

562
00:36:10,566 --> 00:36:14,228
on prem or hybrid georeplication. That's a big

563
00:36:14,314 --> 00:36:17,476
kind of thing of pulsar as well, messaging that you

564
00:36:17,498 --> 00:36:21,332
want to do replication across geographical area. It already

565
00:36:21,386 --> 00:36:24,724
has a lot of the very useful kind of even like user

566
00:36:24,772 --> 00:36:28,744
level capability built into. And we'll take a look at

567
00:36:28,782 --> 00:36:31,780
the next couple of slides. So georeplication,

568
00:36:31,940 --> 00:36:35,660
multiregion support, right? So you can have multiple regions too,

569
00:36:35,810 --> 00:36:39,336
maybe even within a geo area. It has kind of fine grained

570
00:36:39,368 --> 00:36:42,520
support too. For each area you can have different countries,

571
00:36:42,680 --> 00:36:46,044
let's say a huge enterprise corporation, you have

572
00:36:46,082 --> 00:36:49,504
different kind of rules and everything. So you go to different regions, they have different

573
00:36:49,542 --> 00:36:53,644
rules, and basically it's a matter of configuration within pulsar.

574
00:36:53,772 --> 00:36:57,404
And there's also like if you get into data lake, data mining,

575
00:36:57,452 --> 00:37:00,448
all of these two is also supported and much, much more.

576
00:37:00,614 --> 00:37:04,292
And it's only where the tip of the iceberg, right? The project is still

577
00:37:04,346 --> 00:37:07,844
quite not that old yet. There's still a lot of things being

578
00:37:07,882 --> 00:37:11,508
planned for it. Okay, so basically

579
00:37:11,594 --> 00:37:15,252
it unifies for all events, it's a unifying

580
00:37:15,316 --> 00:37:18,936
platform for all events in the enterprise. So essentially it's like the

581
00:37:18,958 --> 00:37:22,824
same kind of picture, but in this particular case, you can have this already on

582
00:37:22,862 --> 00:37:26,364
prem too, and Pulsar will help you do

583
00:37:26,402 --> 00:37:28,940
a job with very minimal disruption.

584
00:37:29,520 --> 00:37:33,324
Okay, here's another picture too. So unified infrastructure with

585
00:37:33,362 --> 00:37:36,748
built in geo replication. So as you can see, multi cloud,

586
00:37:36,834 --> 00:37:40,000
hybrid cloud, multi region in here.

587
00:37:40,150 --> 00:37:44,320
And if you look into right hand side too, if you have a company,

588
00:37:44,470 --> 00:37:48,524
a lot of large corporations, two can have systems

589
00:37:48,572 --> 00:37:52,064
that know very complicated. It's got really

590
00:37:52,102 --> 00:37:56,630
like a zoo, right? You look at this example, you get almost

591
00:37:57,320 --> 00:38:00,668
all software that you can think of, right? Oracle for database,

592
00:38:00,784 --> 00:38:04,116
traditional RDBMs, postgres, Mysql.

593
00:38:04,148 --> 00:38:08,520
Then you have cloud messaging, Amazon SMS and confluent.

594
00:38:08,860 --> 00:38:12,644
And then there's also programs, different types of programs, python,

595
00:38:12,692 --> 00:38:16,584
Golang, Java, Javascript, all of these things, no SQL

596
00:38:16,632 --> 00:38:19,084
database, right, Cassandra for example,

597
00:38:19,282 --> 00:38:22,588
MongoDB and Redis and whatever you want, right?

598
00:38:22,674 --> 00:38:26,540
So all of these can coexist. Don't kind of get rid of things,

599
00:38:26,610 --> 00:38:30,908
just keep running. Pulsar will come in and enable and augment

600
00:38:31,004 --> 00:38:34,972
everything. That's what the goal, the benefits of Pulsar

601
00:38:35,036 --> 00:38:38,944
is. So if you take a look into it too, it gives this universal

602
00:38:38,992 --> 00:38:42,992
upstream connectivity and also universal downstream connectivity

603
00:38:43,056 --> 00:38:46,692
as well. So if you look below in here too, you can also connect to

604
00:38:46,746 --> 00:38:49,488
streams, analytics and processing like flink,

605
00:38:49,664 --> 00:38:54,024
spark, data bricks, all of these other things too as

606
00:38:54,062 --> 00:38:57,652
such. And there's data lakes and warehouses like Amazon

607
00:38:57,716 --> 00:39:01,416
S three, Snowflake and Hadoop for example.

608
00:39:01,598 --> 00:39:04,628
And then if you're traditional messaging, Java, JMS,

609
00:39:04,724 --> 00:39:08,856
Kafka and MQ, it also has the compatibility layer

610
00:39:08,888 --> 00:39:12,556
that's kind of built to talk with them too. So it is

611
00:39:12,658 --> 00:39:16,332
really like positioned itself very well. So how is it?

612
00:39:16,386 --> 00:39:19,452
Pulsar is different, right? So it's a next generation architecture,

613
00:39:19,516 --> 00:39:23,052
provides a distributed tiered architecture. It separates

614
00:39:23,116 --> 00:39:26,924
compute from storage and zookeeper holds metadata for the cluster.

615
00:39:27,052 --> 00:39:31,344
Stateless broker basically handles producers and consumers.

616
00:39:31,392 --> 00:39:34,560
And storage is handled by Apache bookkeeper.

617
00:39:34,640 --> 00:39:38,230
So that's something we already talked about in a couple of slides back.

618
00:39:38,840 --> 00:39:42,436
Now this is like a rich ecosystem of connectors and clients. There are plenty

619
00:39:42,468 --> 00:39:45,928
of connectors too, and a really common one. For example, you can

620
00:39:46,014 --> 00:39:51,080
build data pipelines and send data into a sync. It can be elasticsearch,

621
00:39:51,660 --> 00:39:54,660
it can be MongoDB, Hadoop,

622
00:39:54,740 --> 00:39:58,316
Haskell, Cassandra, Clickhouse, all of

623
00:39:58,338 --> 00:40:02,520
these flume, all of these. So possibilities

624
00:40:02,600 --> 00:40:05,816
are limitless, I should say. No limit.

625
00:40:06,008 --> 00:40:09,800
Okay, so pulsar features rapid patching, zero downtime

626
00:40:09,960 --> 00:40:14,220
multi tenant, right? So essentially too you can have soft isolation via

627
00:40:14,300 --> 00:40:17,724
read write IO separation, independent storage

628
00:40:17,772 --> 00:40:21,664
quotas and message flow control and throttling mechanisms.

629
00:40:21,712 --> 00:40:25,936
Too hard isolation, two you can do via physically separate

630
00:40:25,968 --> 00:40:29,264
brokers and bookies for tenants too. So very flexible

631
00:40:29,312 --> 00:40:33,748
in terms of the multi tenancy type of capability. There's also IAM,

632
00:40:33,844 --> 00:40:37,124
the identity and access management that are pluggable

633
00:40:37,172 --> 00:40:40,632
authentication supporting TLS, SSL's next

634
00:40:40,686 --> 00:40:44,660
generation of version of SSH. That's TLS,

635
00:40:44,820 --> 00:40:46,680
Jot, JWT,

636
00:40:48,220 --> 00:40:51,668
authentic or Athens and then Kerp Rose

637
00:40:51,764 --> 00:40:55,464
and role based authorization provide control at the cluster tenant

638
00:40:55,512 --> 00:40:58,784
message broke producer and consumer level too.

639
00:40:58,902 --> 00:41:01,484
There's also provides you end to end encryption,

640
00:41:01,612 --> 00:41:05,104
intransit kind of TLS encryption and

641
00:41:05,142 --> 00:41:08,588
application managed content encryption too. So you can kind of be

642
00:41:08,694 --> 00:41:12,644
best assured your data will be safe. So key

643
00:41:12,682 --> 00:41:16,608
differentiator number one, separation between compute and storage.

644
00:41:16,704 --> 00:41:20,084
Like I kind of talked about it already. So that's why your

645
00:41:20,122 --> 00:41:23,656
scaling can be independent, you don't interfere with each other.

646
00:41:23,758 --> 00:41:27,332
Storage is handled by Apache bookkeeper, segment centric

647
00:41:27,396 --> 00:41:31,684
message storage management, fast and low impact horizontal scaling

648
00:41:31,732 --> 00:41:36,272
capability. The next thing is about native georeplication.

649
00:41:36,356 --> 00:41:40,680
You can have hands off real time message replication across data centers.

650
00:41:40,760 --> 00:41:44,444
So which is real nice, right? So meaning that you can know data

651
00:41:44,482 --> 00:41:47,760
center in Europe, in North America, all of these places,

652
00:41:48,180 --> 00:41:51,596
it handles all of the georeplication for you. And it's

653
00:41:51,628 --> 00:41:54,972
basically it helps you to meet your data compliance requirements

654
00:41:55,036 --> 00:41:58,592
across geo regions as well. So that's kind of a really

655
00:41:58,646 --> 00:42:02,544
big plus in there. Now there's also multi

656
00:42:02,592 --> 00:42:05,860
tenancy too. As I kind of talk about, it's like an apartment building,

657
00:42:05,930 --> 00:42:09,524
right? You have independent unit, they are isolated from one another,

658
00:42:09,642 --> 00:42:13,616
but they all kind of being handled by pulsar too. So likewise

659
00:42:13,728 --> 00:42:16,936
it's in a company, you can have a pulsar cluster then in it

660
00:42:16,958 --> 00:42:20,664
too, you can separate out according to function. You can have a tenant for

661
00:42:20,702 --> 00:42:25,408
finance and then another tenant for marketing, another one for product, for engineering.

662
00:42:25,524 --> 00:42:29,688
Within each they have different namespace that handles different functionality,

663
00:42:29,864 --> 00:42:32,716
as you can see in here. You can have a namespace that's kind of a

664
00:42:32,738 --> 00:42:36,732
microservice that actually handles message topics and everything.

665
00:42:36,866 --> 00:42:40,288
Then there's also marketing, right? You can have different kind

666
00:42:40,294 --> 00:42:43,244
of a namespace for handling like campaign manager,

667
00:42:43,292 --> 00:42:46,716
lead generation, all of these good stuff. And then there's

668
00:42:46,748 --> 00:42:50,356
also then finance, right? Fraud detection, for example. So all

669
00:42:50,378 --> 00:42:54,116
of these things too, as you can see, right? It's already kind

670
00:42:54,138 --> 00:42:57,840
of built in and it's not too complicated.

671
00:42:57,920 --> 00:43:01,032
Some things are just by configuration, then your system

672
00:43:01,086 --> 00:43:04,520
is up and then can handle all of these kind of

673
00:43:04,590 --> 00:43:08,170
capability that otherwise you have to write yourself, right?

674
00:43:09,020 --> 00:43:13,208
Number four, so flexible message

675
00:43:13,294 --> 00:43:16,456
processing model. So as you can see, right, pops up kind

676
00:43:16,478 --> 00:43:20,204
of model. Or you can do queuing too. But the thing is interesting too,

677
00:43:20,242 --> 00:43:24,280
as you can see in the topic pops up. You can have exclusive

678
00:43:24,360 --> 00:43:28,144
in terms of subscription, exclusive subscription in which a

679
00:43:28,182 --> 00:43:32,000
consumer can. And the topic are kind of tied very tightly together.

680
00:43:32,070 --> 00:43:35,616
It's exclusively for that consumer. And then another one will

681
00:43:35,638 --> 00:43:39,068
be a failover type of scenario. You can have more

682
00:43:39,094 --> 00:43:42,788
than one consumer, but only one is the primary. So if

683
00:43:42,874 --> 00:43:46,356
something fails, then the other consumer will kind

684
00:43:46,378 --> 00:43:49,956
of step in to take charge essentially to receive the

685
00:43:49,978 --> 00:43:53,228
messages. And then there's also like shared subscriptions.

686
00:43:53,264 --> 00:43:56,776
So shared is kind of a very important concept, especially in

687
00:43:56,798 --> 00:44:00,888
a cloud native environment. You can share the subscription and basically

688
00:44:01,054 --> 00:44:04,616
it's part of it. Also for cost computing, right? If you kind of use any

689
00:44:04,638 --> 00:44:08,088
resources, you'll be count by how much cycles

690
00:44:08,184 --> 00:44:11,624
cpu cycle you're using. But if you use a shared subscription,

691
00:44:11,672 --> 00:44:15,132
you actually are saving cost in terms of the cloud native cost

692
00:44:15,186 --> 00:44:18,572
too. And then there's also the special kind of key is called

693
00:44:18,626 --> 00:44:22,156
key shared. So everything is kind of essentially represented

694
00:44:22,188 --> 00:44:25,280
by the key too. That's key shared, okay.

695
00:44:25,430 --> 00:44:29,116
And basically it's good fit for bring use cases as well. And Kafka

696
00:44:29,148 --> 00:44:32,368
has challenges in that. So why pulsar? Right? So a

697
00:44:32,374 --> 00:44:36,048
bit, kind of wanting to kind of like two talk a

698
00:44:36,054 --> 00:44:39,292
bit too about why is it better than kafka?

699
00:44:39,356 --> 00:44:42,632
I wouldn't say it's like all better. Sometimes it depends on what your

700
00:44:42,686 --> 00:44:46,296
scenario is, right? If you are in a situation you don't need all of

701
00:44:46,318 --> 00:44:49,720
these fancier geore applications and giant

702
00:44:50,620 --> 00:44:54,264
kind of setup, then maybe it may not apply to you.

703
00:44:54,302 --> 00:44:57,884
But if you are interested to read about it, there's this link in here,

704
00:44:58,002 --> 00:45:01,576
and under confluent there's a topic written about Kafka

705
00:45:01,608 --> 00:45:05,384
versus Pulsar. And then another one is Kafka versus

706
00:45:05,432 --> 00:45:08,524
Apache Pulsar event streams comparison and then

707
00:45:08,562 --> 00:45:11,920
the features myths explore too. So when you should consider

708
00:45:11,990 --> 00:45:15,676
Pulsar, if you need both queues like rapid MQ and streams processing

709
00:45:15,708 --> 00:45:19,228
like Kafka, or you need easy geo applications,

710
00:45:19,404 --> 00:45:22,668
multitenancy is a must and you want to secure the access for

711
00:45:22,694 --> 00:45:26,116
each of your teams. And then you also want to persist all of your

712
00:45:26,138 --> 00:45:30,304
messages for a long time and you don't want to offload them to another storage.

713
00:45:30,432 --> 00:45:33,816
And essentially too performant is critical for you. And your

714
00:45:33,838 --> 00:45:37,592
benchmarks have shown that pulsar provides lower latency and higher

715
00:45:37,646 --> 00:45:41,684
throughput. So essentially too, yeah, you can guarantee the performance

716
00:45:41,732 --> 00:45:45,836
to be quite well. And if you run on prem and you don't have experience

717
00:45:45,938 --> 00:45:48,556
setting up Kafka, but you have Hadoop experience,

718
00:45:48,738 --> 00:45:51,820
these might be reasons why you want to use Kafka.

719
00:45:52,560 --> 00:45:55,260
So data stacks, flavors of Kafka,

720
00:45:56,640 --> 00:46:00,748
I'm sorry, of Pulsar. So I'll go real, real quickly. So data stacks

721
00:46:00,764 --> 00:46:04,476
is essentially taking pulsar ten times further. We have added

722
00:46:04,508 --> 00:46:07,744
our special sauce, so to speak, right? So all of these things

723
00:46:07,782 --> 00:46:11,488
are already there. And it's binary compatibility with JMS,

724
00:46:11,584 --> 00:46:14,916
MQ and Apache Kafka. We have libraries that helps you

725
00:46:14,938 --> 00:46:18,672
two for legacy kind of systems like transformation,

726
00:46:18,736 --> 00:46:22,104
we have that migration for you two. So think of us

727
00:46:22,142 --> 00:46:26,360
more like we enable you to be even more productive.

728
00:46:27,660 --> 00:46:31,844
So Pulsar meets you where you are. So again, I mentioned already Astra

729
00:46:31,892 --> 00:46:35,852
streaming that has managed Pulsar, there's Luna streaming, it's basically

730
00:46:35,986 --> 00:46:39,676
the open source, but we also provide or give you the options of

731
00:46:39,698 --> 00:46:42,220
processing enterprise support Pulsar,

732
00:46:43,360 --> 00:46:46,616
enterprise support that will support Pulsar. And then there's

733
00:46:46,648 --> 00:46:49,776
also the pure. If you want to go all open source, you can kind

734
00:46:49,798 --> 00:46:52,960
of use the open source version. It's all community driven

735
00:46:53,780 --> 00:46:56,880
comparing against Kafka. So some of these

736
00:46:56,950 --> 00:47:00,444
pain points, I just want to highlight a few, right? So basically Kafka

737
00:47:00,492 --> 00:47:03,600
doesn't have the separation of the compute and the storage.

738
00:47:03,760 --> 00:47:07,472
So it is, when you start off is maybe more straightforward.

739
00:47:07,536 --> 00:47:10,832
You know, how many topics, how many partitions, number of brokers

740
00:47:10,896 --> 00:47:14,116
you plan out ahead of time is there, and it's fine.

741
00:47:14,218 --> 00:47:17,208
However, if there's a need for you two, keep growing your system,

742
00:47:17,294 --> 00:47:20,744
then it may become a little bit more difficult because what

743
00:47:20,782 --> 00:47:24,340
do you do now? You already have defined a number of topics and partitions.

744
00:47:24,420 --> 00:47:27,564
If you want to do that, it's a bit harder to do. You can

745
00:47:27,602 --> 00:47:30,940
do it, but it just requires a lot more work, right?

746
00:47:31,090 --> 00:47:35,240
And essentially too, if you look into it, cluster rebalancing

747
00:47:35,320 --> 00:47:38,944
can impact the performance of connected producers and consumers too.

748
00:47:39,062 --> 00:47:43,260
And over here too, it talks about. Yeah, there's geo replication mechanism

749
00:47:43,420 --> 00:47:46,684
too, by for example, this library called mirror maker,

750
00:47:46,812 --> 00:47:50,756
but it's not very ideal at this point. And companies like Uber have

751
00:47:50,778 --> 00:47:54,436
also created their own solution to overcome these kind

752
00:47:54,458 --> 00:47:57,872
of issues. Two, so overall you can look at Pulsar

753
00:47:57,936 --> 00:48:01,780
as an extension of augmenting what Kafka

754
00:48:03,180 --> 00:48:05,370
augmenting it essentially, right.

755
00:48:06,860 --> 00:48:10,916
So partition centric versus segment centric. I think I already showed

756
00:48:10,948 --> 00:48:14,664
this to you. As you can see, it compares Kafka, which over here, right,

757
00:48:14,702 --> 00:48:18,220
the partition. Everything Kafka manages is storage too.

758
00:48:18,290 --> 00:48:22,750
So all log segments are replicated in order

759
00:48:23,200 --> 00:48:26,576
across brokers too, and then otherwise too, if you look

760
00:48:26,598 --> 00:48:29,964
into pulsar, right, bookkeeper, as you can see, bookkeeper handles

761
00:48:30,012 --> 00:48:33,564
all of these magic essentially for you, for the ledgers,

762
00:48:33,612 --> 00:48:37,644
for the journaling bookkeeper. It comes

763
00:48:37,692 --> 00:48:42,684
easier if you try to replicate, do any kind of multiplying

764
00:48:42,732 --> 00:48:46,212
and things like that too. And essentially it's built more

765
00:48:46,266 --> 00:48:50,192
for kind of like the scalability and it needs to rebalance.

766
00:48:50,256 --> 00:48:53,832
Right? That's another thing you need to rebalance if you need to grow your system,

767
00:48:53,966 --> 00:48:58,040
have more cluster, more nodes. And it actually grows nicely because

768
00:48:58,110 --> 00:49:01,944
pulsar already has built in that it knows to kind of rebalance all

769
00:49:01,982 --> 00:49:05,064
of these topics, how it is being partitioned,

770
00:49:05,112 --> 00:49:08,764
for example, and things like that. All right,

771
00:49:08,802 --> 00:49:12,808
architecture advantage, right? So compute and storage separation,

772
00:49:12,904 --> 00:49:16,744
we already talked about it. And segment oriented log messaging.

773
00:49:16,792 --> 00:49:18,210
Two over here.

774
00:49:20,020 --> 00:49:22,850
So where to go from here and let's keep in touch.

775
00:49:23,220 --> 00:49:26,864
Okay, so here, I think I'm running out of time now, two, kind of

776
00:49:26,902 --> 00:49:30,160
do some demo, but otherwise too, I wanted to bring to your attention.

777
00:49:30,240 --> 00:49:33,216
Right, these are the resources. Pulsar,

778
00:49:33,328 --> 00:49:37,984
apache.org, bookkeeper apache.org, zookeeper apache.org.

779
00:49:38,032 --> 00:49:41,332
You can read up on all of the details. And then at Datastax we offer

780
00:49:41,386 --> 00:49:45,364
Astra streaming over here or lunar streams, right. Lunar streaming essentially

781
00:49:45,412 --> 00:49:48,552
is all free unless you want to purchase the enterprise support too.

782
00:49:48,606 --> 00:49:52,244
So again, data stacks is very much about open source

783
00:49:52,292 --> 00:49:56,152
too. We are strong supporter. We have fills working on Cassandra

784
00:49:56,216 --> 00:49:59,740
and Pulsar committers and pmcs.

785
00:50:00,240 --> 00:50:03,676
And please follow my Twitch stream every Wednesday at 02:00

786
00:50:03,698 --> 00:50:07,464
p.m. Us central time. I have my twitch stream that

787
00:50:07,522 --> 00:50:10,972
these days I'm going into talking more about event streaming

788
00:50:11,036 --> 00:50:14,876
and pulsar. I've been with Datastax

789
00:50:14,908 --> 00:50:17,904
for a little over a month so I haven't got as deep yet. But I

790
00:50:17,942 --> 00:50:21,148
will. And then I also have other topics too,

791
00:50:21,174 --> 00:50:25,190
like developers chat for example last week at Devnexis and things like that.

792
00:50:25,640 --> 00:50:29,184
And please join us at the hood. This is all new. We are efforts

793
00:50:29,232 --> 00:50:32,816
of starting off a website called Apache Pulsar

794
00:50:32,848 --> 00:50:36,404
Neighborhood is over here. Or like there are meetups

795
00:50:36,452 --> 00:50:39,896
two on meetup.com meetup group so please follow us two over

796
00:50:39,918 --> 00:50:43,144
there apache pulsar neighborhood and with that I

797
00:50:43,182 --> 00:50:46,356
want to thank you all. Thank you for listening

798
00:50:46,388 --> 00:50:50,104
to my talk and please I welcome you. Please stay

799
00:50:50,302 --> 00:50:53,572
connected with me. Join my discord server.

800
00:50:53,716 --> 00:50:57,232
I'll be happy to talk about anything right? And also

801
00:50:57,286 --> 00:51:00,496
follow me on Twitter and also my LinkedIn handle is right here

802
00:51:00,598 --> 00:51:01,790
with that. Thank you very much.

