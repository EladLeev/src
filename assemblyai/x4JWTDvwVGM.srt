1
00:00:00,410 --> 00:00:06,174
Jamaica real

2
00:00:06,212 --> 00:00:10,618
time feedback into the behavior of your distributed systems and observing

3
00:00:10,714 --> 00:00:14,094
changes options errors in real time

4
00:00:14,212 --> 00:00:17,914
allows you to not only experiment with confidence, but respond

5
00:00:18,042 --> 00:00:20,480
instantly to get things working again.

6
00:00:24,610 --> 00:00:47,498
Code hello

7
00:00:47,584 --> 00:00:52,330
and welcome everyone to the Talk platform freedom with microfrontend.

8
00:00:52,490 --> 00:00:56,922
So this talk will take you through a list of microfrontend strategies,

9
00:00:57,066 --> 00:01:00,602
a new framework that was built on top of microfrontend,

10
00:01:00,746 --> 00:01:04,674
and how this new framework helped in building an application

11
00:01:04,872 --> 00:01:07,966
that can run on various distributed systems.

12
00:01:08,078 --> 00:01:11,620
So before getting into the topic, let me introduce myself.

13
00:01:12,310 --> 00:01:15,714
I'm Saravana Balaji Srinivasan. I work as a senior software

14
00:01:15,762 --> 00:01:19,766
engineer at Red Hat with the role full stack developer mainly on

15
00:01:19,788 --> 00:01:23,846
JavaScript technologies. I work in the areas where we build

16
00:01:24,028 --> 00:01:27,170
tools for business automation products,

17
00:01:27,340 --> 00:01:30,838
serverless workflow specifications, et cetera.

18
00:01:30,934 --> 00:01:34,842
So yeah, that's about me getting

19
00:01:34,896 --> 00:01:38,294
back to the topic. So this talk I wish to deliver

20
00:01:38,342 --> 00:01:42,206
in such a way like sharing my experience and

21
00:01:42,228 --> 00:01:46,762
the learnings we at Red Hat had while implementing microfrontend

22
00:01:46,826 --> 00:01:49,646
strategies for one of our use case.

23
00:01:49,828 --> 00:01:53,218
So to start with, maybe let me start with

24
00:01:53,304 --> 00:01:56,914
the red hat story. So sometime back we at Red

25
00:01:56,952 --> 00:02:00,846
Hat had a certain use case where we had to migrate

26
00:02:00,878 --> 00:02:05,666
one of our legacy product called JBPM,

27
00:02:05,698 --> 00:02:09,414
which is a business automation product. We had to

28
00:02:09,452 --> 00:02:13,190
migrate the product that can accommodate

29
00:02:14,330 --> 00:02:18,374
some of the latest technologies and it must accommodate the future technologies as

30
00:02:18,412 --> 00:02:22,286
well. So that's when we were thinking of microfrontend

31
00:02:22,418 --> 00:02:25,818
strategies. We had some sort of learning, sort of it,

32
00:02:25,904 --> 00:02:29,466
and then we came up with a new framework on top of

33
00:02:29,488 --> 00:02:33,898
microfrontend, which we named it as the multiplying architecture.

34
00:02:33,994 --> 00:02:38,810
And this multiplying architecture helped in solving

35
00:02:38,890 --> 00:02:42,910
some of the problems that we had. And finally it helped us

36
00:02:43,060 --> 00:02:47,042
to achieve the goal that we had. So the upcoming slides will

37
00:02:47,096 --> 00:02:50,546
take you through the list of learnings that we had out of the

38
00:02:50,568 --> 00:02:54,466
microfin ten and the new framework. And so yeah,

39
00:02:54,648 --> 00:02:56,660
that's the talk is going to be about.

40
00:02:59,690 --> 00:03:03,238
So firstly, I would like to break my topic, the platform

41
00:03:03,324 --> 00:03:06,754
freedom with microfin tens and so on. I would like to emphasize

42
00:03:06,802 --> 00:03:10,786
what I mean by the term platform here and the list of platforms

43
00:03:10,818 --> 00:03:14,106
that we were targeting for our use case. So we all

44
00:03:14,128 --> 00:03:17,494
know that web technology is totally dominating the software development

45
00:03:17,542 --> 00:03:21,158
at this point. So where the developer or the company

46
00:03:21,344 --> 00:03:24,800
who wish to build an application for their use case,

47
00:03:25,570 --> 00:03:28,522
web technology is considered as their default choice,

48
00:03:28,586 --> 00:03:32,394
right? So this is because web technology has stronger

49
00:03:32,442 --> 00:03:35,406
foundation, stronger standards,

50
00:03:35,518 --> 00:03:39,182
patterns, techniques, architectures, et cetera.

51
00:03:39,326 --> 00:03:43,186
And also web technologies are rich in ecosystem. So when

52
00:03:43,208 --> 00:03:46,850
we speak about ecosystem, we cannot ignore javascript,

53
00:03:47,670 --> 00:03:51,682
though it has initially started as a scripting language. Now we can find javascript

54
00:03:51,746 --> 00:03:55,602
everywhere. So over the period of time it has grown

55
00:03:55,666 --> 00:03:58,760
fastly. So that's the power of JavaScript at this point.

56
00:03:59,070 --> 00:04:02,374
And after the introduction of typescript,

57
00:04:02,502 --> 00:04:05,850
people like me who started a career as

58
00:04:05,920 --> 00:04:09,722
a backend developer on Java technology started

59
00:04:09,776 --> 00:04:14,026
liking typescript after learning started liking

60
00:04:14,138 --> 00:04:17,710
web technology after learning typescript because

61
00:04:17,860 --> 00:04:20,240
my code is totally type safe, right?

62
00:04:21,810 --> 00:04:25,154
And also I could emphasize that browser is

63
00:04:25,192 --> 00:04:28,334
everywhere at this point. You can find browser

64
00:04:28,382 --> 00:04:31,570
on your laptop, mission, mobile servers,

65
00:04:32,150 --> 00:04:35,620
et cetera, right? So now browser is just

66
00:04:36,490 --> 00:04:40,182
not only a tool to access your Internet or

67
00:04:40,236 --> 00:04:43,814
to access your guis, it has become more than that.

68
00:04:43,932 --> 00:04:47,510
So when I say browser is everywhere,

69
00:04:47,930 --> 00:04:52,822
one can run the web components anywhere,

70
00:04:52,886 --> 00:04:57,286
wherever you have the browsers, right? So these are the list of platforms

71
00:04:57,318 --> 00:05:01,260
that we were targeting. We wanted our

72
00:05:02,130 --> 00:05:05,630
web components to run on visual studio code

73
00:05:05,700 --> 00:05:08,986
as an extension and browser as an extension.

74
00:05:09,098 --> 00:05:12,654
Say for example, if you have GitHub, sorry,

75
00:05:12,772 --> 00:05:16,594
Chrome as a browser, my web component must run

76
00:05:16,632 --> 00:05:21,646
as a chrome extension, and in case of Firefox, it must run as a Firefox

77
00:05:21,678 --> 00:05:25,234
extension. And my same set of web

78
00:05:25,272 --> 00:05:29,654
components must run on GitHub as well as an extension. And finally

79
00:05:29,772 --> 00:05:33,318
we had web application as an option as well. So the

80
00:05:33,404 --> 00:05:38,230
reason for choosing these platforms is that the

81
00:05:38,300 --> 00:05:42,086
web components that we had were tooling

82
00:05:42,118 --> 00:05:45,402
components. These tools are going to be used

83
00:05:45,456 --> 00:05:48,666
by the developers who are going to build an application out

84
00:05:48,688 --> 00:05:52,526
of the business products that we have. And these

85
00:05:52,548 --> 00:05:56,800
are going to mainly used by the developers. And developers mostly use

86
00:05:57,410 --> 00:06:01,226
these four platforms, right? So that's

87
00:06:01,258 --> 00:06:05,250
why we were targeting these main four platforms.

88
00:06:07,590 --> 00:06:10,370
So while having this use case in mind,

89
00:06:10,440 --> 00:06:13,710
we were thinking about various architecture that were existing,

90
00:06:13,790 --> 00:06:17,426
starting from evolutionary architecture, and then the microservice,

91
00:06:17,538 --> 00:06:20,840
which is pathbreaker on the back end world

92
00:06:21,450 --> 00:06:24,934
that allows breaking a bigger monolith back end

93
00:06:24,972 --> 00:06:28,518
application into a smaller microservices and without

94
00:06:28,604 --> 00:06:32,098
being dependent on each service, and then

95
00:06:32,124 --> 00:06:35,020
code the serverless, which is a buzzing word at this point,

96
00:06:35,470 --> 00:06:39,306
which is another way called as back end as a service. You don't have

97
00:06:39,328 --> 00:06:43,840
to own an entire server, you can just have

98
00:06:44,290 --> 00:06:47,422
your back end logics run as a function and

99
00:06:47,476 --> 00:06:50,734
you can just pay for the number of hits that

100
00:06:50,772 --> 00:06:54,766
your function gets. So you don't have to own an entire server.

101
00:06:54,878 --> 00:06:58,610
So then comes the microfrontend, which is

102
00:06:58,680 --> 00:07:02,180
something that we are going to discuss elaborately in this talk.

103
00:07:02,870 --> 00:07:06,100
So I don't want to go and answer

104
00:07:06,570 --> 00:07:09,350
the question, what are microfrontends?

105
00:07:10,890 --> 00:07:14,998
You might have gotten enough answers for this question

106
00:07:15,164 --> 00:07:19,206
in lot of talks, right? So you

107
00:07:19,228 --> 00:07:22,406
might have seen images like this with a

108
00:07:22,588 --> 00:07:25,834
lot, I mean tall pillars and that

109
00:07:25,872 --> 00:07:29,530
represents monolith application, blah blah blah, et cetera.

110
00:07:30,510 --> 00:07:33,658
So let me just conclude

111
00:07:33,674 --> 00:07:36,270
with the quote by Cam Jackson.

112
00:07:37,090 --> 00:07:41,018
A micro frontend is an architectural style

113
00:07:41,114 --> 00:07:45,166
where independently deliverable frontend applications

114
00:07:45,278 --> 00:07:48,500
are composed into a greater whole.

115
00:07:49,270 --> 00:07:52,594
Simply the goal of microfrontends is

116
00:07:52,632 --> 00:07:55,650
to decouple your monolith application.

117
00:07:55,800 --> 00:08:00,006
So when you have a monolith chunk of application which

118
00:08:00,028 --> 00:08:03,670
is tightly coupled, and you work with one

119
00:08:03,820 --> 00:08:07,174
big vast team, you are

120
00:08:07,212 --> 00:08:10,586
obviously bound to lot of issues,

121
00:08:10,688 --> 00:08:14,234
bugs, and addressing all these bugs and issues will

122
00:08:14,272 --> 00:08:17,754
be very difficult. And the downtime of an bonolith application is

123
00:08:17,792 --> 00:08:21,598
also quite high. So definitely this has to be

124
00:08:21,684 --> 00:08:25,130
broken down into smaller microfrontends.

125
00:08:25,290 --> 00:08:28,654
So there is an idiom in English where they

126
00:08:28,692 --> 00:08:31,978
say don't put all your eggs in one basket.

127
00:08:32,074 --> 00:08:35,746
So definitely this applies for the microfrontend as well. You don't have

128
00:08:35,768 --> 00:08:39,646
to put all your code in one bigger chunk

129
00:08:39,678 --> 00:08:44,066
of monolithic application. You can diversify your application.

130
00:08:44,248 --> 00:08:48,150
So diversification is just not only applicable for your money,

131
00:08:48,220 --> 00:08:52,246
so it also applies for the technology as well. You can

132
00:08:52,428 --> 00:08:56,114
diversify your application into smaller microfrontends

133
00:08:56,162 --> 00:08:59,990
and you can make it independent. And each microfrontend

134
00:09:00,070 --> 00:09:04,026
can be accessed or developed by

135
00:09:04,208 --> 00:09:06,780
a separate autonomous team.

136
00:09:08,590 --> 00:09:11,994
So this diagram will give you an example of

137
00:09:12,032 --> 00:09:15,760
how microfrontend application looks like.

138
00:09:16,290 --> 00:09:19,742
So as I mentioned earlier in my previous slide, I work for a team

139
00:09:19,876 --> 00:09:23,646
where we build tools for various products. This is

140
00:09:23,668 --> 00:09:27,566
one such tool which is called as DMN, which handles

141
00:09:27,678 --> 00:09:31,058
business law rules, and it represents the

142
00:09:31,064 --> 00:09:35,380
business rules in a graphical manner. So considering this

143
00:09:35,910 --> 00:09:39,186
view, a header component can be broken down into a

144
00:09:39,208 --> 00:09:42,902
separate microfrontend. You may think here the header looks

145
00:09:42,956 --> 00:09:46,566
very small, why would that qualifies as

146
00:09:46,588 --> 00:09:50,626
a separate microfrontend? So decoupling

147
00:09:50,658 --> 00:09:54,458
a micro frontend or breaking your UI into a smaller micro frontend is definitely

148
00:09:54,544 --> 00:09:57,834
depends on the organization decision as well, or the team

149
00:09:57,872 --> 00:10:01,338
decision as well, whether you definitely want to break that particular

150
00:10:01,424 --> 00:10:03,758
component as a micro frontend or not.

151
00:10:03,924 --> 00:10:07,726
But on the other side, consider if you

152
00:10:07,748 --> 00:10:11,706
have an ecommerce kind of an application where header itself may contain

153
00:10:11,738 --> 00:10:15,554
a huge chunk of react components or

154
00:10:15,752 --> 00:10:20,222
any framework, right? So starting with your profile section,

155
00:10:20,286 --> 00:10:23,602
your company logo, search bar,

156
00:10:23,736 --> 00:10:27,326
drop downs and sub drop downs, too many components,

157
00:10:27,358 --> 00:10:30,814
right? So this definitely qualifies for separate microfrontend

158
00:10:30,862 --> 00:10:34,182
and could be made in by a separate team. So coming back to this view

159
00:10:34,236 --> 00:10:38,450
here, so as I mentioned, this header couldn't qualify as a separate microfrontend

160
00:10:38,530 --> 00:10:42,514
and the editor at the bottom which represents the graph definitely

161
00:10:42,572 --> 00:10:45,962
could maintain as a separate microfrontend and

162
00:10:46,096 --> 00:10:49,386
could be maintained by a separate team. And there is a navigation bar at the

163
00:10:49,408 --> 00:10:53,010
left could be maintained as a separate microfrontend. All these microfrontend ends

164
00:10:53,030 --> 00:10:56,734
are contained inside one container application which takes

165
00:10:56,772 --> 00:10:58,270
the major decisions.

166
00:11:00,130 --> 00:11:04,190
So while speaking about the Maya microfin

167
00:11:05,010 --> 00:11:07,390
or speaking about decoupling,

168
00:11:08,130 --> 00:11:11,522
microfrontend is not the only option

169
00:11:11,576 --> 00:11:15,154
that we have to decouple a monolith application. There are

170
00:11:15,192 --> 00:11:18,566
other strategies or techniques as well. So one such

171
00:11:18,668 --> 00:11:22,694
as modular monolith where your front

172
00:11:22,732 --> 00:11:25,906
end could be broken down into smaller uis and libraries

173
00:11:25,938 --> 00:11:29,766
could be shared among this, but still these uis are tightly coupled

174
00:11:29,798 --> 00:11:32,780
among them contained inside one single application.

175
00:11:33,230 --> 00:11:37,180
And there is another strategy which is called as integrated application,

176
00:11:38,830 --> 00:11:42,266
though here the uis

177
00:11:42,298 --> 00:11:45,674
could be broken down into smaller applications and the libraries

178
00:11:45,722 --> 00:11:49,914
could be shared between the applications. But this follows

179
00:11:50,042 --> 00:11:53,214
a build time composition and finally

180
00:11:53,332 --> 00:11:57,114
we have the strategy that we are discussing which is microfrontend

181
00:11:57,162 --> 00:12:01,402
where the UI applications

182
00:12:01,556 --> 00:12:04,798
pages are broken down into smaller applications

183
00:12:04,894 --> 00:12:09,298
and this microfrontend end follows runtime composition.

184
00:12:09,394 --> 00:12:13,682
So we will see what this built time composition

185
00:12:13,746 --> 00:12:17,318
or runtime composition elaborately in

186
00:12:17,324 --> 00:12:18,550
the upcoming slides.

187
00:12:21,290 --> 00:12:24,646
So again, this slide will give you an idea how micro

188
00:12:24,678 --> 00:12:28,534
frontend looks like and how microservice looks like and how they are differs.

189
00:12:28,582 --> 00:12:31,914
So the first one shows you how a monolith application looks

190
00:12:31,952 --> 00:12:34,758
like. You have your front end, you have your back end, and that back end

191
00:12:34,784 --> 00:12:38,526
connected to the data source. The request from the frontend passes through the

192
00:12:38,548 --> 00:12:42,382
back end and that backend fetches the data from the

193
00:12:42,436 --> 00:12:46,462
data source and passes on to the front end. When it comes to the microservice,

194
00:12:46,526 --> 00:12:50,274
your back end is broken down into smaller microservices. And there

195
00:12:50,312 --> 00:12:53,694
comes another layer between the front end and microservices

196
00:12:53,742 --> 00:12:57,170
which is called as the gateway API which takes

197
00:12:57,240 --> 00:13:00,326
the decision of routing the request from the frontend to the

198
00:13:00,348 --> 00:13:04,082
corresponding microservice, which can handle that particular request.

199
00:13:04,226 --> 00:13:07,430
After the introduction of microfrontend, the frontend applications

200
00:13:07,500 --> 00:13:11,318
is broken down into smaller pieces and that communicates to the API

201
00:13:11,414 --> 00:13:16,090
and that API routes your request to the microservice.

202
00:13:18,430 --> 00:13:21,710
So we will see another interesting

203
00:13:21,780 --> 00:13:25,870
strategy of the micro frontend which is called as BFF.

204
00:13:26,210 --> 00:13:30,240
Yes, you heard me right. Actually it is not abbreviated as

205
00:13:30,690 --> 00:13:33,818
best friend forever, but it is a

206
00:13:33,844 --> 00:13:37,342
best friend for the micro frontend. The actual abbreviation

207
00:13:37,406 --> 00:13:40,722
for BFF is backend for

208
00:13:40,776 --> 00:13:44,382
frontend. So this BFF ensures seamless

209
00:13:44,446 --> 00:13:47,522
user interaction between the microservices and

210
00:13:47,576 --> 00:13:51,806
microservice and the micro

211
00:13:51,838 --> 00:13:55,714
frontend and the backend microservice irrespective

212
00:13:55,762 --> 00:13:59,014
of the platform, wherever it is running on. So if you closely look at this

213
00:13:59,052 --> 00:14:03,178
diagram, each micro frontend is connected to its own

214
00:14:03,344 --> 00:14:07,462
BFF, and that BFF connects to the microservice.

215
00:14:07,526 --> 00:14:10,698
So there is no direct communication from the micro frontend to the

216
00:14:10,784 --> 00:14:15,146
back end. So all the communication happens between via

217
00:14:15,338 --> 00:14:20,522
the BFF. And this BFF is responsible of handling

218
00:14:20,586 --> 00:14:24,346
the request and response. It also converts

219
00:14:24,378 --> 00:14:28,902
a response from the backend and it presents it to the microfrontend

220
00:14:29,066 --> 00:14:32,706
in such a way that it can understand. And if you closely look

221
00:14:32,728 --> 00:14:35,794
at this diagram and there is no communication between

222
00:14:35,832 --> 00:14:39,826
the microfrontend as well, all the communication between the microfrontend

223
00:14:39,858 --> 00:14:43,270
ends happens only inside the container, application only,

224
00:14:43,340 --> 00:14:46,230
or the way you can call it as app shell.

225
00:14:48,830 --> 00:14:52,006
So while discussing about the microfrontend strategies,

226
00:14:52,198 --> 00:14:55,594
yeah, you have your microfrontend ends created and you

227
00:14:55,632 --> 00:14:58,902
have your teams working on each of your microfrontends.

228
00:14:59,046 --> 00:15:01,260
They are independently working fine,

229
00:15:01,870 --> 00:15:05,278
but all the microfrontend has to be integrated on the

230
00:15:05,284 --> 00:15:08,846
container application and it has to be presented to the user, right?

231
00:15:08,948 --> 00:15:12,414
So while thinking of integration strategies, there are two

232
00:15:12,452 --> 00:15:16,246
main strategies that exist. One is runtime integration.

233
00:15:16,298 --> 00:15:19,794
The other one is built time integration. We have seen this makes in

234
00:15:19,832 --> 00:15:23,426
one of our previous slides as well. So let me start with

235
00:15:23,448 --> 00:15:26,982
this runtime integration. So imagine if a team

236
00:15:27,036 --> 00:15:30,434
a building a component c and they deploys

237
00:15:30,482 --> 00:15:33,618
it so that component could be accessed in this URL,

238
00:15:33,794 --> 00:15:37,394
the domain name thecomponentname js

239
00:15:37,442 --> 00:15:41,814
because this component is deployed as bundle whenever

240
00:15:41,862 --> 00:15:45,242
the user tries to access the website,

241
00:15:45,376 --> 00:15:48,586
the container application takes the whole control and

242
00:15:48,608 --> 00:15:52,250
it loads the component c and it will decide when this particular

243
00:15:52,320 --> 00:15:55,786
component has to be rendered. So this strategy

244
00:15:55,818 --> 00:15:59,440
is kind of widely used across the people or developers who

245
00:16:00,290 --> 00:16:03,738
implement micro frontend, but it has its own pros and cons.

246
00:16:03,844 --> 00:16:07,566
The pro is being the teams

247
00:16:07,598 --> 00:16:11,266
can deploy their components at any point, they don't have

248
00:16:11,288 --> 00:16:14,974
to depend on other teams. And the downside

249
00:16:15,022 --> 00:16:18,706
of this application integration strategy is the setup

250
00:16:18,818 --> 00:16:21,922
time or setting up. This integration

251
00:16:21,986 --> 00:16:24,150
strategy is far more complicated.

252
00:16:25,450 --> 00:16:28,662
So coming to the next integration strategy that we have,

253
00:16:28,796 --> 00:16:32,362
that is built time integration. So in this case, again,

254
00:16:32,416 --> 00:16:35,606
considering a scenario where a team a builds

255
00:16:35,638 --> 00:16:39,930
a component so that component is shipped as an NPM package,

256
00:16:41,650 --> 00:16:45,920
this strategy, this NPM registry comes as a boon for us to

257
00:16:46,530 --> 00:16:49,626
contain all our components as a package.

258
00:16:49,738 --> 00:16:53,562
So the other team who wants to use that particular component,

259
00:16:53,706 --> 00:16:57,634
they can install that particular component as a dependency to

260
00:16:57,672 --> 00:17:01,538
their micro front end and they can just use it

261
00:17:01,704 --> 00:17:05,314
again. This looks easy to set up and understand,

262
00:17:05,432 --> 00:17:09,254
but the downside of this strategy is every

263
00:17:09,292 --> 00:17:13,174
time when you implement there is a change in the

264
00:17:13,372 --> 00:17:16,774
package that you build, the entire application has to be

265
00:17:16,812 --> 00:17:21,370
rebuilt again. Or if you want to introduce new dependency

266
00:17:21,870 --> 00:17:25,018
or new package or new component, the entire application has to

267
00:17:25,024 --> 00:17:28,220
be rebuilt again. So that rebuild time is again quite high.

268
00:17:29,710 --> 00:17:33,194
So there were other concerns associated with the micro frontend strategies.

269
00:17:33,242 --> 00:17:36,190
One such thing is styling.

270
00:17:38,130 --> 00:17:41,770
Imagine if you have various micro frontend ends

271
00:17:41,850 --> 00:17:45,840
when you apply one particular style for micro frontend

272
00:17:46,290 --> 00:17:49,922
that could override the styles on the other micro frontend as well,

273
00:17:49,976 --> 00:17:53,060
when you unify all the microfrontends on one container application.

274
00:17:53,430 --> 00:17:56,782
Yes, of course this could be resolved

275
00:17:56,926 --> 00:18:00,546
by using iframes, where each

276
00:18:00,568 --> 00:18:04,950
microfrontend can be rendered on the browser inside an iframe.

277
00:18:05,290 --> 00:18:08,882
So that this iframe totally isolates your micro frontend. So that

278
00:18:08,956 --> 00:18:12,634
changes on, I mean, style changes on one micro frontend will not

279
00:18:12,672 --> 00:18:15,962
affect the other one. But there are other

280
00:18:16,016 --> 00:18:20,246
concerns with using of these iframes

281
00:18:20,278 --> 00:18:23,546
as well, being micro,

282
00:18:23,578 --> 00:18:27,262
I mean, iframes is not something new or

283
00:18:27,316 --> 00:18:30,186
something. So it's a very age old approach.

284
00:18:30,298 --> 00:18:33,600
And at this point, at this evolution of technology,

285
00:18:34,290 --> 00:18:37,294
I feel that nobody will prefer to use iframes.

286
00:18:37,342 --> 00:18:40,562
Definitely developers across would

287
00:18:40,616 --> 00:18:43,874
prefer to use or to render the microfrontend and see just inside

288
00:18:43,912 --> 00:18:46,290
a dev or any other tags that they wish.

289
00:18:47,770 --> 00:18:51,510
So that's when after coming across

290
00:18:51,580 --> 00:18:55,826
or thinking about all these concerns that we had across the microfrontend

291
00:18:55,858 --> 00:18:59,146
and strategies, we were thinking of coming up with a

292
00:18:59,168 --> 00:19:03,226
new architecture. So these

293
00:19:03,248 --> 00:19:06,460
were the requirements that we were thinking about.

294
00:19:07,070 --> 00:19:11,094
We had actually starting with the multiple

295
00:19:11,142 --> 00:19:14,878
distributions. So the web components that we have

296
00:19:15,044 --> 00:19:18,826
must run on various distributions, like it has to run on vs

297
00:19:18,858 --> 00:19:22,010
code as an extension, GitHub as an extension,

298
00:19:22,170 --> 00:19:26,050
browsers as an extension, and finally as a web app.

299
00:19:26,200 --> 00:19:29,218
And this has to happen with minimal code changes.

300
00:19:29,384 --> 00:19:33,266
And there should be a bridge to the future tech stacks as well.

301
00:19:33,368 --> 00:19:37,154
So in case at present I

302
00:19:37,192 --> 00:19:40,486
use react framework for my web components, in future if there

303
00:19:40,508 --> 00:19:44,050
are some other frameworks, for instance, if I have to use Vue,

304
00:19:44,210 --> 00:19:47,766
I must be able to easily change that

305
00:19:47,788 --> 00:19:51,670
framework as well. So my micro frontend

306
00:19:51,740 --> 00:19:55,210
strategies, Maya, must accommodate any new technology

307
00:19:55,280 --> 00:19:59,366
that I wish to migrate. So that's

308
00:19:59,398 --> 00:20:03,102
when we introduced a new framework called the

309
00:20:03,156 --> 00:20:04,830
multiplying architecture.

310
00:20:06,210 --> 00:20:10,718
So before understanding multiplying architecture, let me understand

311
00:20:10,804 --> 00:20:12,910
what is software architecture?

312
00:20:13,750 --> 00:20:17,022
So according to Ralph Johnson, a software architecture

313
00:20:17,086 --> 00:20:20,402
is about the important stuff, whatever that is.

314
00:20:20,536 --> 00:20:24,174
So what is that important stuff? So it is abstraction.

315
00:20:24,222 --> 00:20:28,134
So basically we wanted to abstract our

316
00:20:28,172 --> 00:20:32,626
web components and we wanted to present to the various platforms

317
00:20:32,738 --> 00:20:36,582
that we have. So abstraction is being considered as

318
00:20:36,636 --> 00:20:40,938
the utmost priority for our use case to

319
00:20:41,024 --> 00:20:44,534
migrate or to deploy

320
00:20:44,582 --> 00:20:48,102
our applications on the platforms that I demonstrated

321
00:20:48,166 --> 00:20:49,690
showed you in the previous slides.

322
00:20:51,410 --> 00:20:55,178
So these are the core elements,

323
00:20:55,274 --> 00:20:59,546
or the core components that we built as part of the multiplying architecture,

324
00:20:59,658 --> 00:21:02,714
one as being channel, envelope,

325
00:21:02,842 --> 00:21:06,446
view and editor. So the channel is being considered

326
00:21:06,478 --> 00:21:09,906
as the platforms that we were discussing so far. And view

327
00:21:10,008 --> 00:21:13,934
are obviously the web components that are built on react

328
00:21:13,982 --> 00:21:17,570
js and envelope is something that communicates,

329
00:21:18,150 --> 00:21:21,862
that enables a communication between the channel and view

330
00:21:21,996 --> 00:21:25,830
in order to pass data, et cetera. And editor,

331
00:21:26,650 --> 00:21:30,198
the editors that we were discussing, it could be the DMN

332
00:21:30,214 --> 00:21:34,358
editors that I showed in previous slide, or there were other few editors

333
00:21:34,534 --> 00:21:36,700
that we were using for products.

334
00:21:38,270 --> 00:21:41,646
So we wanted our editors or the

335
00:21:41,668 --> 00:21:45,182
tools to run on the web like this.

336
00:21:45,236 --> 00:21:48,670
So if you look at this screenshot,

337
00:21:49,410 --> 00:21:53,722
the BPMN editor is wrapped inside the envelope instance,

338
00:21:53,866 --> 00:21:56,740
that envelop instance is wrapped inside the channel.

339
00:21:58,070 --> 00:22:01,822
And the same editor must run the same set of web components,

340
00:22:01,886 --> 00:22:05,666
must run on the browser as

341
00:22:05,688 --> 00:22:09,606
an extension like this, on the GitHub as an

342
00:22:09,628 --> 00:22:13,046
extension like this, and finally

343
00:22:13,148 --> 00:22:15,640
vs. Code as an extension like this.

344
00:22:17,050 --> 00:22:20,822
So this is how the envelope

345
00:22:20,966 --> 00:22:24,266
enables the community between the channel and the view.

346
00:22:24,368 --> 00:22:28,010
So if you see here, there is no iframes users.

347
00:22:28,080 --> 00:22:32,350
So we are rendering our components

348
00:22:33,250 --> 00:22:36,640
of the micro frontend ends via div

349
00:22:37,090 --> 00:22:40,730
instead of iframes. And also these envelope,

350
00:22:40,810 --> 00:22:44,000
channel and editor are contained inside,

351
00:22:45,170 --> 00:22:48,980
I mean the envelope view and editors are contained inside the channel.

352
00:22:50,630 --> 00:22:55,070
So the advantage of envelope is the context isolation.

353
00:22:55,150 --> 00:22:58,646
So my microfrontend are

354
00:22:58,668 --> 00:23:02,674
totally isolated and there is a better communication

355
00:23:02,722 --> 00:23:06,166
established between the channel and the view.

356
00:23:06,348 --> 00:23:10,106
And this creates an autonomous team as well. And each

357
00:23:10,128 --> 00:23:13,754
team could have its own release cycles. And this

358
00:23:13,792 --> 00:23:17,290
entire micro, I mean, multiplying architecture are built on top of

359
00:23:17,360 --> 00:23:19,930
typescript, so it is totally type safe.

360
00:23:21,330 --> 00:23:25,150
So let's see, microfiber multiplying architecture in practice.

361
00:23:29,320 --> 00:23:32,804
So let me take you through the code base

362
00:23:32,842 --> 00:23:36,964
that I have. I'll be sharing this URL with you where

363
00:23:37,002 --> 00:23:40,996
you can access these examples. So here I have a folder called examples,

364
00:23:41,028 --> 00:23:43,400
which contains a list of microfrontends.

365
00:23:45,020 --> 00:23:48,228
I have some basic examples, like to do

366
00:23:48,254 --> 00:23:51,724
list ping pong example, and there's another called

367
00:23:51,842 --> 00:23:55,368
base 64 to PNG, which converts your image

368
00:23:55,384 --> 00:23:58,940
to a PNG. So these are individual

369
00:23:59,010 --> 00:24:02,204
microfrontends. And these microfrontends I wanted to run on

370
00:24:02,242 --> 00:24:05,292
various platforms. Here let me take the classical

371
00:24:05,356 --> 00:24:08,896
example of to do list so this is the

372
00:24:08,918 --> 00:24:12,304
micro, I mean to do list view is the micro frontend and I want this

373
00:24:12,342 --> 00:24:16,290
micro front end to be running on the channel vs code

374
00:24:17,480 --> 00:24:21,716
as an extension and it has to run inside the

375
00:24:21,738 --> 00:24:25,296
web application as well. So here if you see there is a web folder

376
00:24:25,328 --> 00:24:28,856
called which is again a different microfin and you

377
00:24:28,878 --> 00:24:32,968
will see a federated page for the

378
00:24:33,054 --> 00:24:36,376
to do list as well. So this web app containing all the examples that I

379
00:24:36,398 --> 00:24:40,520
have here to do list ping pong or base 64 et cetera.

380
00:24:40,860 --> 00:24:44,156
But at this point we'll just take one example and see how it

381
00:24:44,178 --> 00:24:47,676
is implemented. So firstly we'll start with how this multiplying architecture is

382
00:24:47,698 --> 00:24:51,308
implemented. So this multiplying architecture follows a separate, I mean

383
00:24:51,394 --> 00:24:54,576
dedicated folder structure. Let me start with the dependencies what are

384
00:24:54,598 --> 00:24:58,144
that you need to install. So firstly these

385
00:24:58,182 --> 00:25:00,610
are the two packages that you must use.

386
00:25:00,980 --> 00:25:04,464
So these are available as part of this

387
00:25:04,582 --> 00:25:09,408
key tools core. So at this point here I'm

388
00:25:09,424 --> 00:25:13,728
not mentioning the version here because the core

389
00:25:13,824 --> 00:25:18,096
implementing of this envelope is residing on the same repository. So I have used workspace

390
00:25:18,128 --> 00:25:22,068
here. But if you are trying this multiplying

391
00:25:22,084 --> 00:25:25,768
architecture you may see the exact release of

392
00:25:25,774 --> 00:25:30,076
the version number, the recent release of the version number that you can see on

393
00:25:30,098 --> 00:25:33,772
the NPM registry. So these

394
00:25:33,826 --> 00:25:37,484
two dependencies that you may need. One is envelope and

395
00:25:37,522 --> 00:25:41,036
envelope bus. These two enables the communication

396
00:25:41,068 --> 00:25:44,850
between the channel and the view.

397
00:25:46,580 --> 00:25:50,140
And if you go inside the SLC folder

398
00:25:50,220 --> 00:25:52,640
you may see three folders,

399
00:25:52,980 --> 00:25:56,404
predominantly main folders, that is API embedded and

400
00:25:56,442 --> 00:25:58,340
enveloped, starting with API.

401
00:25:59,560 --> 00:26:03,296
So this todo list API

402
00:26:03,328 --> 00:26:06,788
so this contains list of abstracted methods

403
00:26:06,964 --> 00:26:11,784
that are exposed to the external world and

404
00:26:11,982 --> 00:26:15,876
channel API file this file contains a list of abstracted

405
00:26:15,908 --> 00:26:19,564
methods which are exposed by the channel and consumed by

406
00:26:19,602 --> 00:26:23,192
the envelope. So using these methods, the communication

407
00:26:23,256 --> 00:26:26,812
between the channel and the envelope happens whatever the message that

408
00:26:26,866 --> 00:26:30,572
channel has to communicate to the envelope or happens inside

409
00:26:30,706 --> 00:26:34,556
these methods. So here this file contains only the abstracted

410
00:26:34,588 --> 00:26:39,036
method, but the definition of these methods are provided

411
00:26:39,068 --> 00:26:43,372
inside the channel. We will be seeing that as well. So there is again

412
00:26:43,526 --> 00:26:47,380
another file envelope API which contains an abstracted method

413
00:26:47,720 --> 00:26:51,524
which are exposed by the envelope and that are consumed by the

414
00:26:51,642 --> 00:26:55,076
channel. So there is

415
00:26:55,098 --> 00:26:59,416
another folder called embedded. So this is considered as a starting point

416
00:26:59,598 --> 00:27:03,530
that triggers the view. And if you see here

417
00:27:04,300 --> 00:27:08,644
you will see a react component embedded to do list envelope.

418
00:27:08,692 --> 00:27:12,296
So you will see what this embedded to do list envelope

419
00:27:12,328 --> 00:27:16,670
contains. So it is actually imported from

420
00:27:18,000 --> 00:27:21,452
this folder envelope which contains envelope

421
00:27:21,596 --> 00:27:25,520
to do list envelope TSX again which is a react component

422
00:27:26,900 --> 00:27:31,308
here, this view, I mean to do list envelope view contains

423
00:27:31,404 --> 00:27:35,024
your JSX code for the to do list application which

424
00:27:35,062 --> 00:27:38,372
contains all HTML content and the CSS content

425
00:27:38,426 --> 00:27:41,456
and the react code, all the use callbacks,

426
00:27:41,488 --> 00:27:45,444
use state, et cetera. Yeah, it is a functional component. Again, so this

427
00:27:45,482 --> 00:27:49,124
view is rendered inside the envelope, and this envelope is

428
00:27:49,162 --> 00:27:52,856
called inside the embedded to do list. So this embedded to

429
00:27:52,878 --> 00:27:56,376
do list envelope will be called inside the

430
00:27:56,398 --> 00:27:59,836
channel. So that is something we'll be seeing here. So now let's go

431
00:27:59,858 --> 00:28:03,576
to the channel vs code extension.

432
00:28:03,768 --> 00:28:10,524
So to implement, yeah, in our case we had to

433
00:28:10,562 --> 00:28:13,904
render our web components on the

434
00:28:13,942 --> 00:28:17,136
Vs code. So we were making some sort

435
00:28:17,158 --> 00:28:20,508
of configurations for the vs code extension.

436
00:28:20,604 --> 00:28:23,952
So if you are also trying the same, you may have to first learn

437
00:28:24,006 --> 00:28:27,504
how to create an extension on the vs code. So this folder

438
00:28:27,552 --> 00:28:31,124
structure, some of the files here

439
00:28:31,322 --> 00:28:35,156
deals with the configuration for the Vs code extension. So starting with

440
00:28:35,178 --> 00:28:38,616
this extension ts, which will initiate the

441
00:28:38,638 --> 00:28:41,896
extension and some

442
00:28:41,918 --> 00:28:45,336
of its dependencies as well. And if

443
00:28:45,358 --> 00:28:49,172
you see this index ts here, this todo list envelope

444
00:28:49,236 --> 00:28:52,380
view envelope is initiated here. This will trigger

445
00:28:53,120 --> 00:28:56,504
the react components that we saw in the multiplier.

446
00:28:56,552 --> 00:28:59,756
I mean micro front end, right? So if you see here

447
00:28:59,778 --> 00:29:01,520
in the package JSOn,

448
00:29:03,700 --> 00:29:07,324
the micro frontend is added as the dependency here. So let's

449
00:29:07,372 --> 00:29:11,072
take the easier example of web

450
00:29:11,126 --> 00:29:15,124
application. Maybe you will get an idea about how this really looks.

451
00:29:15,242 --> 00:29:18,548
So again,

452
00:29:18,714 --> 00:29:22,436
we'll show you how here the microfrontend end

453
00:29:22,458 --> 00:29:25,892
is added as a dependency here, installed as a dependency here.

454
00:29:26,026 --> 00:29:30,292
And I created a separate page

455
00:29:30,426 --> 00:29:34,280
for to do list which calls

456
00:29:35,820 --> 00:29:38,924
the embedded to do list which I showed in my

457
00:29:39,122 --> 00:29:42,510
other file. So this is imported from

458
00:29:46,180 --> 00:29:49,456
key tools example todo list view, which was

459
00:29:49,478 --> 00:29:53,012
the microfrontend that we were discussing so far. And this page

460
00:29:53,066 --> 00:29:56,516
is called inside the app TSX where I

461
00:29:56,538 --> 00:30:00,208
have provided various navigations because this web app contains

462
00:30:00,304 --> 00:30:04,368
their applications examples as well. So I've provided

463
00:30:04,544 --> 00:30:08,136
separate navigations for each of the examples that I have here.

464
00:30:08,318 --> 00:30:11,624
And all this API app is contained. I mean

465
00:30:11,662 --> 00:30:14,952
this is the root of the my react application. So let me

466
00:30:15,006 --> 00:30:21,930
start this application and

467
00:30:22,000 --> 00:30:22,620
see.

468
00:30:26,990 --> 00:30:31,418
So yeah, I'm starting this application on

469
00:30:31,424 --> 00:30:51,044
the close 9000 to

470
00:30:51,082 --> 00:30:54,404
load. It's coming

471
00:30:54,442 --> 00:30:55,430
up now. Yeah,

472
00:30:58,120 --> 00:31:01,188
so as I mentioned, so this web app contains a list of all

473
00:31:01,194 --> 00:31:04,924
the examples that I have in this repository. So let me go to

474
00:31:04,962 --> 00:31:08,904
this to do list view that we were discussing.

475
00:31:08,952 --> 00:31:12,670
Maybe I'll just create list

476
00:31:13,120 --> 00:31:18,460
conf 42 Javascript conference

477
00:31:19,520 --> 00:31:21,790
2022.

478
00:31:23,360 --> 00:31:27,164
So I created this note, maybe I can just mark it as complete, or maybe

479
00:31:27,202 --> 00:31:30,948
I can unmark it. Also I can remove so just simple example

480
00:31:31,034 --> 00:31:32,310
of todo list.

481
00:31:36,040 --> 00:31:40,064
This is how it works. So the same set of micro

482
00:31:40,112 --> 00:31:43,960
frontend component or react components were used on

483
00:31:44,110 --> 00:31:47,690
vs code as an extension on the web app as an extension as well.

484
00:31:48,060 --> 00:31:50,840
So let me jump back to the slide.

485
00:31:55,400 --> 00:31:59,192
So so far we have

486
00:31:59,246 --> 00:32:02,696
seen the multiplying architecture in

487
00:32:02,718 --> 00:32:08,132
practice. So after implementing

488
00:32:08,196 --> 00:32:12,084
all this channel view envelope or multiplying architecture

489
00:32:12,132 --> 00:32:16,284
or microfrontend strategies, all these things still we were having some sort

490
00:32:16,322 --> 00:32:19,848
of issues while integrating all the microfrontend

491
00:32:19,944 --> 00:32:23,490
components into one container application,

492
00:32:26,820 --> 00:32:31,420
these were the issues that we were facing. So the main highlighted

493
00:32:31,580 --> 00:32:35,316
issue that we were facing across both the strategies are the

494
00:32:35,338 --> 00:32:39,092
duplication of libraries that we're loading. Say for example,

495
00:32:39,226 --> 00:32:42,710
if I have three microfrontends for my application,

496
00:32:43,400 --> 00:32:47,140
and each of the microfrontend has react as a dependency

497
00:32:48,840 --> 00:32:50,340
in its microfrontend.

498
00:32:52,680 --> 00:32:55,980
When I integrate all the microfrontends, three instances

499
00:32:56,000 --> 00:32:58,848
of react application react dependency is created.

500
00:32:58,964 --> 00:33:02,904
So if you just think about it's like duplicating

501
00:33:02,952 --> 00:33:06,376
of one dependency, though it is commonly

502
00:33:06,408 --> 00:33:09,640
used across the microfrontend, three instances are created.

503
00:33:09,720 --> 00:33:13,356
So imagine if you have more number of dependencies that are kind

504
00:33:13,378 --> 00:33:17,036
of duplicately created across the

505
00:33:17,058 --> 00:33:20,704
microfrontend, either the bundle size or the size of your application

506
00:33:20,902 --> 00:33:22,690
will become too high.

507
00:33:24,200 --> 00:33:28,004
To overcome this issue, Federated modules came

508
00:33:28,042 --> 00:33:31,364
to our rescue. So you might have heard about this

509
00:33:31,402 --> 00:33:35,380
term federated modules. This was introduced in the webpack in its

510
00:33:35,450 --> 00:33:39,540
fifth version. So this gave us solution

511
00:33:39,620 --> 00:33:43,668
to share dependencies across the microfrontends.

512
00:33:43,764 --> 00:33:47,652
And this also allowed us to implement the runtime integration

513
00:33:47,716 --> 00:33:51,704
as well. So here, this is how the webpack configuration

514
00:33:51,752 --> 00:33:55,144
looks like implementing the modules Federation.

515
00:33:55,272 --> 00:33:59,384
So initially the module Federated has to be imported from the package.

516
00:33:59,512 --> 00:34:03,296
And here on the plugins you must create an instance for

517
00:34:03,318 --> 00:34:07,052
the module Federation which must contain list of routes

518
00:34:07,116 --> 00:34:10,656
for the number of microfrontends that

519
00:34:10,678 --> 00:34:14,416
you have. And these routes will be rendered on

520
00:34:14,438 --> 00:34:18,032
the browser only when it is called, the particular microfrontend

521
00:34:18,096 --> 00:34:22,112
is called. And if you see here on the line number 23, the dependencies

522
00:34:22,176 --> 00:34:25,716
are shared among all these microfrontends so that there

523
00:34:25,738 --> 00:34:30,072
won't be duplicate instance of dependency also

524
00:34:30,206 --> 00:34:33,876
on the react side of it. So this is how each microfrontend

525
00:34:33,908 --> 00:34:38,296
will be rendered. On the view we

526
00:34:38,318 --> 00:34:41,560
are making use of the lazy imports from the react,

527
00:34:42,700 --> 00:34:46,332
we are importing the microfrontends only when it is needed.

528
00:34:46,466 --> 00:34:50,076
And here we have created routes and we

529
00:34:50,098 --> 00:34:54,290
are just navigating to the respective microfrontend and whenever it is called.

530
00:34:56,020 --> 00:34:59,840
So finally, after implementing the microfrontend

531
00:35:00,180 --> 00:35:03,676
I mean the multiplying architecture. With the microfrontend strategies, along with

532
00:35:03,718 --> 00:35:07,396
the federated modules, we were able to achieve these

533
00:35:07,498 --> 00:35:12,084
end results that we wanted, the multiple distributions with

534
00:35:12,122 --> 00:35:15,524
the minimal code changes, and also we were able to

535
00:35:15,562 --> 00:35:18,760
achieve the bridge between the tech stacks.

536
00:35:20,620 --> 00:35:24,324
So these were the achievements that we may make out of the multiplying architecture.

537
00:35:24,372 --> 00:35:28,772
We were able to implement the microservice architecture,

538
00:35:28,916 --> 00:35:32,164
and we were able to take the advantage of runtime

539
00:35:32,212 --> 00:35:36,324
integration, and we created the autonomous team. There was no duplication

540
00:35:36,372 --> 00:35:39,860
of libraries between the micro front ends.

541
00:35:40,020 --> 00:35:45,312
And yeah, we were able to develop

542
00:35:45,366 --> 00:35:47,650
a bridge between the text tags as well.

543
00:35:49,140 --> 00:35:52,720
So you can find the code base that I was showing here in this URL.

544
00:35:53,540 --> 00:35:56,750
In case. If you have any questions, please feel free to shoot it out.

