1
00:00:00,410 --> 00:00:06,174
Jamaica real

2
00:00:06,212 --> 00:00:09,934
time feedback into the behavior of your distributed systems and

3
00:00:09,972 --> 00:00:13,614
observing changes exceptions. Errors in real

4
00:00:13,652 --> 00:00:16,746
time allows you to not only experiment with confidence,

5
00:00:16,858 --> 00:00:20,480
but respond instantly to get things working again.

6
00:00:24,610 --> 00:00:47,690
Close everyone.

7
00:00:47,840 --> 00:00:51,854
Welcome to the stock. We are going to be talking about promises and

8
00:00:51,892 --> 00:00:55,818
some functional programming alternatives for asynchronous operations

9
00:00:55,994 --> 00:00:59,818
like task taskeither, remove data or futures.

10
00:00:59,994 --> 00:01:03,558
But first, let me introduce myself. My name is Natalie

11
00:01:03,594 --> 00:01:07,314
Rocha. I am from Kito, Ecuador. I am a software developer at

12
00:01:07,352 --> 00:01:10,466
stack builders, and I also like to play the

13
00:01:10,488 --> 00:01:14,226
guitar a lot, and we run a

14
00:01:14,328 --> 00:01:18,146
business here for planning social events.

15
00:01:18,258 --> 00:01:21,462
Yeah, that's something you can know about myself.

16
00:01:21,596 --> 00:01:26,450
But let's dig into what asynchronous computations

17
00:01:26,530 --> 00:01:28,540
or operations are. Right?

18
00:01:30,990 --> 00:01:34,650
As you know, JavaScript is by default a synchronous

19
00:01:36,030 --> 00:01:39,450
language. Let's say it's single threaded. All right?

20
00:01:39,600 --> 00:01:43,390
So this means that instructions can run one after the other

21
00:01:43,460 --> 00:01:47,166
and not in parallel. So if we

22
00:01:47,188 --> 00:01:50,810
want to interact with external data, like reading files,

23
00:01:50,890 --> 00:01:54,670
or fetching data from third party APIs,

24
00:01:54,750 --> 00:01:58,674
or executing time operations, when the

25
00:01:58,712 --> 00:02:02,414
interpreter reaches these sort of tasks,

26
00:02:02,542 --> 00:02:06,022
it actually blocks everything else that

27
00:02:06,076 --> 00:02:09,960
can be executed until that operation is

28
00:02:10,410 --> 00:02:13,974
fetched or returned, or succeeds or

29
00:02:14,012 --> 00:02:18,262
fails. Right? These are called synchronous

30
00:02:18,326 --> 00:02:21,382
operations. So to solve this issue, for blocking

31
00:02:21,446 --> 00:02:25,898
that thread, we can use asynchronous code,

32
00:02:26,064 --> 00:02:29,722
right? Think of it as code that can

33
00:02:29,776 --> 00:02:33,294
start now, that you can ask for something and

34
00:02:33,492 --> 00:02:37,066
JavaScript interpreter can solve

35
00:02:37,098 --> 00:02:40,800
it later, right? So when Javascript is running

36
00:02:41,170 --> 00:02:45,422
asynchronously, instructions are not necessarily executed

37
00:02:45,486 --> 00:02:48,606
one after the other as synchronous

38
00:02:48,638 --> 00:02:52,178
operations, right? Some of

39
00:02:52,184 --> 00:02:56,098
the examples of how to handle or create asynchronous code

40
00:02:56,264 --> 00:02:59,810
can be callbacks, promises, or a simple

41
00:02:59,880 --> 00:03:03,570
weight. We are going to be centering ourselves

42
00:03:03,650 --> 00:03:07,042
in promises. Here we have some of the main characteristics

43
00:03:07,106 --> 00:03:10,214
of promises. And first of all,

44
00:03:10,252 --> 00:03:13,322
promises solve the callback hell, right?

45
00:03:13,376 --> 00:03:17,034
So callbacks are just functions that

46
00:03:17,232 --> 00:03:20,574
are passed into other functions. So for example, if you wanted

47
00:03:20,612 --> 00:03:24,218
to resolve an asynchronous operation,

48
00:03:24,314 --> 00:03:28,062
one after the other, you had to call one

49
00:03:28,116 --> 00:03:31,550
function. Then inside that function you call another function and then another

50
00:03:31,620 --> 00:03:34,734
one. So as you can see in this graphic,

51
00:03:34,862 --> 00:03:37,234
this is what you ended up with,

52
00:03:37,432 --> 00:03:40,450
right? Promises are declarative,

53
00:03:41,030 --> 00:03:45,414
which means that we write code that describes what

54
00:03:45,452 --> 00:03:49,142
we want the computation to do instead

55
00:03:49,196 --> 00:03:52,994
of telling it the flow or exactly adding

56
00:03:53,042 --> 00:03:56,726
the steps that we want the

57
00:03:56,748 --> 00:04:00,486
computer to run, right? So it's

58
00:04:00,518 --> 00:04:03,946
a more functional approach. After that,

59
00:04:04,048 --> 00:04:08,230
it has control flow, which means that we can tell when an operation

60
00:04:08,310 --> 00:04:12,106
succeeds, do this, or when it fails. We can error

61
00:04:12,138 --> 00:04:16,094
handle in another way. So it has

62
00:04:16,132 --> 00:04:20,094
control flow when we are computing right.

63
00:04:20,212 --> 00:04:24,158
Another thing is that it has railway oriented programming.

64
00:04:24,254 --> 00:04:27,982
So this means that we basically have a couple of rails.

65
00:04:28,046 --> 00:04:31,634
The left one can be the error rail and

66
00:04:31,672 --> 00:04:35,422
the right one can be the succeed rail. Okay?

67
00:04:35,496 --> 00:04:39,442
So when any kind of computation is in the succeed

68
00:04:39,506 --> 00:04:43,334
rail, it can actually jump into the other one.

69
00:04:43,532 --> 00:04:46,802
It changes the rails to go into the failed rail

70
00:04:46,866 --> 00:04:50,714
because that promise failed. That is

71
00:04:50,752 --> 00:04:53,914
sort of how it works. And they

72
00:04:53,952 --> 00:04:58,074
are also fun to programming, so they

73
00:04:58,112 --> 00:05:01,662
are really simple to think about it, they are really simple

74
00:05:01,716 --> 00:05:05,134
to get it running. As soon as you start

75
00:05:05,172 --> 00:05:09,082
programming, you can make a fetch to an API can,

76
00:05:09,146 --> 00:05:13,170
whatever, catch whatever else. So yeah,

77
00:05:13,320 --> 00:05:15,620
the promises are really great,

78
00:05:16,950 --> 00:05:20,354
but as good as promises are,

79
00:05:20,472 --> 00:05:24,580
there are some things that can be better and some others that

80
00:05:24,970 --> 00:05:28,230
we might forget to handle or things

81
00:05:28,300 --> 00:05:31,398
that kind of happen without the

82
00:05:31,404 --> 00:05:35,080
developer knows. So that can cause

83
00:05:36,010 --> 00:05:40,120
errors in our applications, for example,

84
00:05:41,130 --> 00:05:44,350
egate evaluation, error types and checkered

85
00:05:44,370 --> 00:05:48,186
exceptions and others. We're going to be checking more of this in

86
00:05:48,208 --> 00:05:52,110
the demo. Right, but first let me explain a little bit about

87
00:05:52,180 --> 00:05:56,910
functional programming, just in case you don't have much

88
00:05:56,980 --> 00:06:00,478
concept of it or how does it works.

89
00:06:00,644 --> 00:06:03,998
I'm going to be explaining just a

90
00:06:04,004 --> 00:06:08,866
little bit of what it is, because it can

91
00:06:08,888 --> 00:06:12,530
be a little bit hard to get into it at first because it is actually

92
00:06:12,600 --> 00:06:16,126
more like a mindset. You have to start thinking in

93
00:06:16,168 --> 00:06:20,310
a functional way. But just to give you some

94
00:06:20,380 --> 00:06:23,734
idea of what it is, let's explain it a little bit,

95
00:06:23,772 --> 00:06:27,846
right? I mean, functional programming, as I said before, is a

96
00:06:27,868 --> 00:06:31,094
mindset, but technically is

97
00:06:31,132 --> 00:06:34,258
a programming paradigm, right? So is

98
00:06:34,284 --> 00:06:37,558
the process of building software by composing functions,

99
00:06:37,654 --> 00:06:41,546
avoiding shared states, mutable data and side effects.

100
00:06:41,658 --> 00:06:45,950
Okay, another characteristics and principles of functional programming

101
00:06:46,290 --> 00:06:49,918
are, for example, that it is declarative. So again,

102
00:06:50,004 --> 00:06:53,634
we have to tell the computer what we want and

103
00:06:53,672 --> 00:06:57,134
not necessarily add every specific instructions,

104
00:06:57,262 --> 00:07:00,546
like in imperative programming, of how we want

105
00:07:00,568 --> 00:07:04,034
the program to be running, right? So it's more

106
00:07:04,072 --> 00:07:08,006
like when you define a mathematical function,

107
00:07:08,188 --> 00:07:11,894
you create a function to describe what you

108
00:07:11,932 --> 00:07:15,894
want the result to be. Some other

109
00:07:15,932 --> 00:07:19,210
principles are the immutability.

110
00:07:20,030 --> 00:07:25,542
It specifies that basically you cannot transform

111
00:07:25,606 --> 00:07:29,958
things. Like for example, you define a variable

112
00:07:30,134 --> 00:07:33,974
to be zero, then in other part of the program you decide

113
00:07:34,022 --> 00:07:37,514
that that one is going to be one. Then that is going to be transformed

114
00:07:37,562 --> 00:07:40,638
into arrive, then into a string, because those are things that

115
00:07:40,644 --> 00:07:44,530
we can actually do in JavaScript. But in functional programming,

116
00:07:45,270 --> 00:07:48,660
immutability has to be present.

117
00:07:49,270 --> 00:07:52,878
We also have pure functions, which means that if we define

118
00:07:52,894 --> 00:07:56,406
a function that sums one value plus the

119
00:07:56,428 --> 00:08:00,102
other. The result is going to be exactly the same every time

120
00:08:00,156 --> 00:08:03,638
we sum that value plus the

121
00:08:03,644 --> 00:08:06,550
other. Those are pure functions.

122
00:08:07,390 --> 00:08:10,410
Also, functions are first class citizens that we can pass.

123
00:08:10,480 --> 00:08:14,470
Functions are as parameters to other functions

124
00:08:14,550 --> 00:08:18,294
or higher order functions. So these are concepts

125
00:08:18,422 --> 00:08:21,758
that are present in functional programming. You can dig a

126
00:08:21,764 --> 00:08:25,050
little bit on it, but it's a really cool paradigm.

127
00:08:25,130 --> 00:08:27,946
And Javascript is a multi paradigm language,

128
00:08:28,058 --> 00:08:30,320
so we can apply it to it.

129
00:08:31,810 --> 00:08:35,778
Awesome. Now that we sort of know what functional programming is,

130
00:08:35,944 --> 00:08:40,206
if you didn't, here are some functional alternatives

131
00:08:40,238 --> 00:08:43,810
to promises. We have tasks, task eater.

132
00:08:44,230 --> 00:08:48,098
These couple of options come from the FPTs

133
00:08:48,194 --> 00:08:50,870
library, functional programming typescript.

134
00:08:51,450 --> 00:08:54,520
It's a really cool library that has many

135
00:08:55,370 --> 00:08:58,934
modules that can help you program in a very functional

136
00:08:58,982 --> 00:09:03,158
way. Your code. We also have futures.

137
00:09:03,254 --> 00:09:06,746
They come from the library. Flutter that we are

138
00:09:06,768 --> 00:09:10,742
going to be checking remote data also comes from FPTs.

139
00:09:10,886 --> 00:09:14,890
And we also have this alternative that is effects

140
00:09:15,250 --> 00:09:18,750
that we are going to be talking about a little bit later in the demo.

141
00:09:18,820 --> 00:09:22,170
Cool. So let's jump into the demo to check the functional

142
00:09:22,250 --> 00:09:23,950
alternatives to promises.

143
00:09:25,810 --> 00:09:29,982
Okay, so for the demo, I have created several examples

144
00:09:30,046 --> 00:09:33,650
that explain the alternatives and the difference

145
00:09:33,720 --> 00:09:38,170
with the promises. So let's start with lateness.

146
00:09:38,350 --> 00:09:42,130
For this example, we are going to be using FPTS

147
00:09:42,290 --> 00:09:45,490
task. So what is a task?

148
00:09:45,650 --> 00:09:49,610
A task is basically a promise that can never fail,

149
00:09:52,030 --> 00:09:55,354
which means that it doesn't need like error handling or

150
00:09:55,392 --> 00:09:58,730
stop, because it's always going to be resolved

151
00:09:59,150 --> 00:10:03,374
and succeed. So why

152
00:10:03,412 --> 00:10:07,354
to use a task? I think the main benefit

153
00:10:07,402 --> 00:10:10,798
or the main concept of a

154
00:10:10,804 --> 00:10:14,338
task is that it is lazy. Lazy means

155
00:10:14,424 --> 00:10:18,098
that the task is going to be run only when

156
00:10:18,184 --> 00:10:22,514
it is needed to be run. Like when

157
00:10:22,552 --> 00:10:26,130
we call it or when we, I don't know, we use a use effect

158
00:10:26,200 --> 00:10:29,878
or stuff like that. But they are always lazy. We can create them

159
00:10:29,964 --> 00:10:33,922
anywhere in our code. We can define that promise

160
00:10:34,066 --> 00:10:37,560
anywhere in the code and it is never going to be called it

161
00:10:37,950 --> 00:10:41,194
unless we do it. And that is the main

162
00:10:41,232 --> 00:10:44,266
difference with a promise. Right? Why?

163
00:10:44,448 --> 00:10:49,030
Let's check this code here. If we define catch

164
00:10:49,190 --> 00:10:53,006
that returns a promise that can be resolved and we can

165
00:10:53,028 --> 00:10:56,366
get the data from that promise if we call

166
00:10:56,388 --> 00:11:00,030
it like this, even though we are supposedly saving

167
00:11:00,100 --> 00:11:03,362
it into a constant, this promise is going to be

168
00:11:03,416 --> 00:11:06,814
called as soon as we load

169
00:11:06,862 --> 00:11:10,526
the application. Let's check it. So here, I don't

170
00:11:10,558 --> 00:11:13,762
have it called. If I save this, as you can see,

171
00:11:13,816 --> 00:11:17,000
it is called as soon as we load the application.

172
00:11:22,410 --> 00:11:26,246
Why this happens like that? This is

173
00:11:26,268 --> 00:11:29,914
because the promises have eager evaluation which

174
00:11:29,952 --> 00:11:32,678
is exactly the opposite to lazy evaluation.

175
00:11:32,854 --> 00:11:37,510
Eager evaluation means that whatever thing you create is executed

176
00:11:37,590 --> 00:11:41,390
or run it as soon as it is created.

177
00:11:41,970 --> 00:11:46,462
That's one of the first main difference between

178
00:11:46,516 --> 00:11:50,206
a promise and a task. So here we can

179
00:11:50,228 --> 00:11:53,794
check a little bit on how a task is

180
00:11:53,832 --> 00:11:56,946
defined. As you

181
00:11:56,968 --> 00:12:00,610
can see, it has exactly the same code

182
00:12:00,760 --> 00:12:04,354
as the promise that we have up here.

183
00:12:04,472 --> 00:12:08,326
Well, the only difference is basically the repository or the

184
00:12:08,348 --> 00:12:11,126
GitHub user that we are calling. Right?

185
00:12:11,308 --> 00:12:14,070
And here we do the same like then,

186
00:12:14,140 --> 00:12:17,866
and we get the data. We can also do this,

187
00:12:17,888 --> 00:12:21,260
but I will explain that later.

188
00:12:22,270 --> 00:12:26,042
So as you can see, there is not much difference. The main

189
00:12:26,096 --> 00:12:30,206
difference is this part, which is exactly what

190
00:12:30,228 --> 00:12:34,926
makes a task lazy. If we remove this should

191
00:12:34,948 --> 00:12:39,050
be like that. As you can see, the type fails

192
00:12:39,130 --> 00:12:43,486
because a task cannot be running

193
00:12:43,588 --> 00:12:48,094
immediately as a promise. So here it's going to say it cannot be a promise.

194
00:12:48,222 --> 00:12:51,806
So the concept is exactly that a task

195
00:12:51,838 --> 00:12:54,842
is a promise that is lazy and can never fail.

196
00:12:55,006 --> 00:12:58,886
Okay, awesome. So if

197
00:12:58,908 --> 00:13:02,566
I want to call the task, you can do it with no problem

198
00:13:02,748 --> 00:13:06,454
and you can map it,

199
00:13:06,492 --> 00:13:10,098
you can get the data as exactly the same as a promise.

200
00:13:10,274 --> 00:13:13,818
But the benefit is that it's not going to be called

201
00:13:13,904 --> 00:13:17,274
immediately. So we can call it in a use effect. Or in

202
00:13:17,312 --> 00:13:20,850
this case, I just created this small function that is going to be runted

203
00:13:20,870 --> 00:13:24,750
with this button here. So if I run the task,

204
00:13:25,170 --> 00:13:28,766
the task is going to be called only when I decide to

205
00:13:28,788 --> 00:13:32,490
call it. Okay, awesome. That's the first

206
00:13:32,580 --> 00:13:35,300
example. Let's move to.

207
00:13:36,310 --> 00:13:38,606
I would like to show you composable.

208
00:13:38,798 --> 00:13:42,910
Composable means that we can combine functions,

209
00:13:42,990 --> 00:13:47,170
simple functions, to create a more complicated one,

210
00:13:47,240 --> 00:13:50,678
or function that can resolve something

211
00:13:50,764 --> 00:13:54,070
or care, transform some data that we have into

212
00:13:54,220 --> 00:13:56,760
something that we actually needed.

213
00:13:57,470 --> 00:14:00,746
So for this case, let's check the

214
00:14:00,768 --> 00:14:03,340
difference between composing if it's possible,

215
00:14:04,430 --> 00:14:07,930
in a promise, and a task.

216
00:14:08,510 --> 00:14:12,380
So first of all, as we said before,

217
00:14:12,990 --> 00:14:16,846
promises have bigger evaluation. So as soon

218
00:14:16,868 --> 00:14:18,640
as I call this promise here,

219
00:14:22,390 --> 00:14:26,098
I can't actually compose the

220
00:14:26,184 --> 00:14:29,714
functions, or I can't actually use

221
00:14:29,752 --> 00:14:33,940
the data, or I can actually use the data before

222
00:14:34,630 --> 00:14:38,358
this has been retrieved. So here, let's check.

223
00:14:38,524 --> 00:14:41,814
In a normal promise, I fetch right,

224
00:14:41,932 --> 00:14:45,622
then I get the Json, and here,

225
00:14:45,676 --> 00:14:49,242
finally, when I call it, I get the data, and only

226
00:14:49,296 --> 00:14:53,062
once I get the data, I can start making things like filter

227
00:14:53,206 --> 00:14:57,210
or mapping or things that I need to do,

228
00:14:57,360 --> 00:15:00,442
right? So let's check the difference

229
00:15:00,496 --> 00:15:01,610
with the task.

230
00:15:04,190 --> 00:15:07,290
Cool. Here we are creating the task. As you can see,

231
00:15:07,360 --> 00:15:10,830
it's exactly the same as the promise as we explained it before. But the difference

232
00:15:10,900 --> 00:15:13,826
is that it's going to be lazy. So we are not calling this,

233
00:15:14,008 --> 00:15:17,906
and let's check this difference without getting the

234
00:15:17,928 --> 00:15:21,426
data, as you saw here before in the promise, without getting the

235
00:15:21,448 --> 00:15:25,310
data here, I can start composing the functions.

236
00:15:25,390 --> 00:15:29,118
So for example here I use a pipe.

237
00:15:29,214 --> 00:15:33,202
Add pipe is a utility function in FPTs

238
00:15:33,266 --> 00:15:37,158
that helps me with composition. So what it does is exactly

239
00:15:37,244 --> 00:15:41,034
that, to work as a pipe, I get the data that

240
00:15:41,072 --> 00:15:44,022
is running into another pipe,

241
00:15:44,086 --> 00:15:47,606
which is going to map something, filter, transform,

242
00:15:47,718 --> 00:15:51,306
reduce. I can compose and combine as many functions

243
00:15:51,338 --> 00:15:55,342
as I want in order to handle the data,

244
00:15:55,476 --> 00:15:59,166
right? So here what I'm doing is starting with a task which

245
00:15:59,188 --> 00:16:02,560
is here, but I'm not calling it yet.

246
00:16:03,670 --> 00:16:07,970
I am just saying that I'm going to use that task and

247
00:16:08,040 --> 00:16:11,874
I want to map that task. This map is

248
00:16:11,912 --> 00:16:15,766
more or less, you can think of it like

249
00:16:15,948 --> 00:16:19,686
then in a promise for

250
00:16:19,708 --> 00:16:23,558
the task. It's not exactly that bad. It's when you actually

251
00:16:23,644 --> 00:16:27,030
resolve the task that you are passing here,

252
00:16:27,100 --> 00:16:30,826
and then we can start making whatever we want without

253
00:16:30,928 --> 00:16:35,018
calling the task first. So here what I'm doing is calling

254
00:16:35,104 --> 00:16:38,726
a filter to get only the Javascript repositories.

255
00:16:38,918 --> 00:16:42,206
Then I'm converting it to

256
00:16:42,228 --> 00:16:45,310
a map to get only the names of those

257
00:16:45,380 --> 00:16:48,906
repositories. And then I can set task

258
00:16:48,938 --> 00:16:52,522
repos, I can console log, I can create an alert, whatever I want.

259
00:16:52,596 --> 00:16:57,220
What I'm doing right now is just using

260
00:16:58,390 --> 00:17:01,746
react user state to save that data here. So as

261
00:17:01,768 --> 00:17:04,878
you can see, even though I do not

262
00:17:04,984 --> 00:17:10,898
have called the task yet, I can start manipulating

263
00:17:10,994 --> 00:17:14,198
or creating composition of that data, which give us a

264
00:17:14,204 --> 00:17:17,720
lot of advantage when programming, and it is also more

265
00:17:18,670 --> 00:17:22,730
referentially transparent. So I'm going to explain that a little bit later.

266
00:17:22,880 --> 00:17:25,340
By the way, as you can see here,

267
00:17:26,750 --> 00:17:30,750
if I call the pipe here, here at the end

268
00:17:30,900 --> 00:17:34,974
of that composition is where I

269
00:17:35,092 --> 00:17:38,734
call that task. Not inside, not before, after.

270
00:17:38,852 --> 00:17:42,510
So I created here a function that is going to call that task,

271
00:17:43,330 --> 00:17:47,086
and that is exactly what this thing is doing here. So let me

272
00:17:47,108 --> 00:17:50,622
show you here in the code, as you can see the promise, run it immediately.

273
00:17:50,766 --> 00:17:54,730
It does the things that it has to do. And if I run the task,

274
00:17:54,910 --> 00:17:58,694
it runs the composition, the pipe that we

275
00:17:58,732 --> 00:18:02,040
created, and that should be it.

276
00:18:02,890 --> 00:18:06,274
Okay, let's continue with referential transparency.

277
00:18:06,402 --> 00:18:09,578
I talked a little bit about this before, but let's check it

278
00:18:09,584 --> 00:18:13,020
in the code to notice the difference.

279
00:18:13,550 --> 00:18:16,940
I created a couple of functions here.

280
00:18:17,870 --> 00:18:21,286
As you can see, we are creating an array

281
00:18:21,478 --> 00:18:25,166
or a tuple of promises so just the,

282
00:18:25,188 --> 00:18:28,474
no science, just create an array, I create a new promise

283
00:18:28,522 --> 00:18:31,646
that is going to do something. Basically what it does is going to

284
00:18:31,668 --> 00:18:35,650
resolve into can array of the promises that were called

285
00:18:35,720 --> 00:18:39,090
here. So just call the promise here

286
00:18:39,160 --> 00:18:40,980
and here and that's it.

287
00:18:42,070 --> 00:18:45,858
So if I call this right,

288
00:18:46,024 --> 00:18:48,694
as you can hear it says, as you can see here,

289
00:18:48,812 --> 00:18:52,102
it returns me exactly that. I just run the promise number

290
00:18:52,156 --> 00:18:55,400
one and the promise number two and that's it.

291
00:18:55,930 --> 00:19:00,130
But this code seems a little bit repetitive.

292
00:19:00,290 --> 00:19:04,602
So what we can do is just create a promise and then create

293
00:19:04,656 --> 00:19:08,438
a functions that return a promise and then call it into the arrive,

294
00:19:08,614 --> 00:19:12,382
as you can see here. Right. So what

295
00:19:12,436 --> 00:19:16,720
I am doing here is creating a promise. I create it and

296
00:19:17,730 --> 00:19:21,246
insert the promises that I want to run in here,

297
00:19:21,428 --> 00:19:24,340
which should return to the same thing,

298
00:19:24,870 --> 00:19:29,102
right? But it doesn't, as you can see here, it returns

299
00:19:29,166 --> 00:19:32,958
only the first promise. Why? Again, because of bigger evaluation.

300
00:19:33,054 --> 00:19:37,510
It is not lazy and it is not referential transparent,

301
00:19:37,850 --> 00:19:41,574
because when we refactor this function

302
00:19:41,692 --> 00:19:45,286
into something that should have had returned it the

303
00:19:45,308 --> 00:19:49,010
same, it didn't. So it loses the referential transparent

304
00:19:49,090 --> 00:19:52,314
that we think into functional programming, which is

305
00:19:52,352 --> 00:19:56,410
if I create a function that something shouldnt

306
00:19:56,480 --> 00:20:00,494
return a thing, but it doesn't, it returns another thing,

307
00:20:00,612 --> 00:20:04,750
which means that it's less referential transparent

308
00:20:06,050 --> 00:20:09,646
indifference with a task. So a task, as you

309
00:20:09,668 --> 00:20:12,886
can see here, we are doing exactly the same as the promise.

310
00:20:13,018 --> 00:20:16,978
We create a task here, we create

311
00:20:17,144 --> 00:20:19,794
the array of tasks we call it,

312
00:20:19,912 --> 00:20:23,758
and when we run it, it actually returns,

313
00:20:23,854 --> 00:20:27,990
run it one and two. That is referential transparency.

314
00:20:28,970 --> 00:20:32,870
Awesome. Okay, let's continue with short circuit.

315
00:20:35,210 --> 00:20:38,486
This is something that we have all the time in

316
00:20:38,668 --> 00:20:42,060
Javascript. So we create an EV that says

317
00:20:42,910 --> 00:20:46,586
x or x is equal to one or

318
00:20:46,688 --> 00:20:50,158
y is equal to two. So the

319
00:20:50,164 --> 00:20:54,110
short circuit is that if one fulfills

320
00:20:55,330 --> 00:20:59,066
the condition, it passes, it fulfills

321
00:20:59,098 --> 00:21:02,646
the other one, it passes. If it doesn't fulfill both conditions

322
00:21:02,698 --> 00:21:06,706
then it shorts circuits and it doesn't continue with

323
00:21:06,728 --> 00:21:10,146
the process. That is it. So let's see

324
00:21:10,168 --> 00:21:13,300
the difference on how promises and tasks handle this.

325
00:21:13,990 --> 00:21:17,234
First of all, let's check how the promise was defined.

326
00:21:17,282 --> 00:21:21,158
I have it here. What I'm doing here is just creating a simple promise that

327
00:21:21,164 --> 00:21:24,150
is going to delay the printing.

328
00:21:25,850 --> 00:21:29,706
And here what I am doing is a promise all which what

329
00:21:29,728 --> 00:21:33,302
is supposed to do is to receive all the promises

330
00:21:33,366 --> 00:21:36,060
into an array and solve them all.

331
00:21:36,750 --> 00:21:40,318
If they succeed, then we console, if they

332
00:21:40,404 --> 00:21:44,030
fail then we error. So here

333
00:21:44,100 --> 00:21:47,406
I have an arrive with many delayed promises and one that is

334
00:21:47,428 --> 00:21:50,880
going to be rejected. So what we might expect is that

335
00:21:52,610 --> 00:21:56,310
if one or two succeeded and this one shorts, it quotes,

336
00:21:56,410 --> 00:22:00,414
then this couple of promises shouldn't

337
00:22:00,462 --> 00:22:04,222
run. But let's check how it actually handles

338
00:22:04,286 --> 00:22:07,778
this. If I run the promise, as you can see,

339
00:22:07,864 --> 00:22:11,606
it shorts it quoted the one that failed, but it

340
00:22:11,628 --> 00:22:15,080
actually evaluated all the other ones that we had there.

341
00:22:15,850 --> 00:22:19,190
And yeah, that is because the promises

342
00:22:19,270 --> 00:22:22,300
actually doesn't have a way to run in a sequential form.

343
00:22:23,630 --> 00:22:26,874
Only if we run them with then.

344
00:22:26,992 --> 00:22:30,862
So we might have had to run it to wrote this

345
00:22:30,916 --> 00:22:34,426
with the delay, then another delay,

346
00:22:34,538 --> 00:22:38,814
then short seed quit and that would have stopped the

347
00:22:38,852 --> 00:22:39,710
performance.

348
00:22:41,810 --> 00:22:45,170
But let's see the difference with a task

349
00:22:46,230 --> 00:22:49,602
here is the same. I just created a delay task that

350
00:22:49,656 --> 00:22:53,426
is going to, let's see, I'm going

351
00:22:53,448 --> 00:22:57,286
to show the taskeither later, but what it's going to do here basically is

352
00:22:57,308 --> 00:23:01,126
to evaluate into something that is going to be

353
00:23:01,148 --> 00:23:04,962
print in certain amount of milliseconds, otherwise print

354
00:23:05,026 --> 00:23:08,214
errors. And here the same, I create the

355
00:23:08,252 --> 00:23:12,262
array of tasks because I can actually create array

356
00:23:12,326 --> 00:23:16,298
of tasks here. If I created the promises before, well they

357
00:23:16,384 --> 00:23:19,642
might have run it immediately. But here I can actually create

358
00:23:19,696 --> 00:23:23,040
this whatever I want into my code and then call it here.

359
00:23:23,490 --> 00:23:26,634
So when I click on the result, the pipe

360
00:23:26,682 --> 00:23:30,880
is going to receive the task array, which is the one that we have here.

361
00:23:31,570 --> 00:23:35,374
Then we can sequence it. Because remember, when we have tasks,

362
00:23:35,422 --> 00:23:39,506
we can actually compose the function before we

363
00:23:39,528 --> 00:23:43,998
actually run it. So I can sequence these tasks,

364
00:23:44,174 --> 00:23:46,918
then I can map them into console log.

365
00:23:47,084 --> 00:23:50,566
And if they fail, this is the either.

366
00:23:50,668 --> 00:23:54,466
If they fail, I can console log as anger.

367
00:23:54,658 --> 00:23:57,720
Okay, so let's see how it works.

368
00:23:59,210 --> 00:24:02,282
Run the task and it's evaluating the first one.

369
00:24:02,416 --> 00:24:05,900
And as you can see, once it evaluates in the second one,

370
00:24:06,590 --> 00:24:09,914
it immediately failed. And as you can see, the other

371
00:24:09,952 --> 00:24:11,500
ones were not run.

372
00:24:12,770 --> 00:24:16,734
So that's another cool difference that you can actually create

373
00:24:16,772 --> 00:24:20,030
a sequence, you can traverse, you can do anything you want,

374
00:24:20,100 --> 00:24:23,954
you can run in parallel with the task, which is

375
00:24:24,152 --> 00:24:28,260
really cool. Awesome. Let's continue with another

376
00:24:29,270 --> 00:24:32,306
feature that I think is one of

377
00:24:32,328 --> 00:24:36,142
the best. It is the

378
00:24:36,216 --> 00:24:39,398
errors handling here we are going

379
00:24:39,404 --> 00:24:42,774
to be using not only a task, but a taskeither.

380
00:24:42,972 --> 00:24:46,294
This is an algebraic data type. I'm not going

381
00:24:46,332 --> 00:24:48,380
to go that much into that,

382
00:24:48,910 --> 00:24:52,394
but adts are really awesome.

383
00:24:52,512 --> 00:24:56,506
I strongly suggest you to check them, but taskeither is one of

384
00:24:56,528 --> 00:25:00,266
them. Let's see why and how it works. As you can

385
00:25:00,288 --> 00:25:04,142
see here, we are using taskeither same

386
00:25:04,196 --> 00:25:07,920
library, fpts, and we are also using an taskeither

387
00:25:08,530 --> 00:25:12,474
let me explain a little bit about the taskeither. The taskeither

388
00:25:12,612 --> 00:25:16,130
in fpts is the way that we can handle the errors.

389
00:25:17,510 --> 00:25:21,294
It is a much more strict way of error

390
00:25:21,342 --> 00:25:25,274
handling. Also it's more explicit,

391
00:25:25,342 --> 00:25:29,366
more readable. And basically what it says is that it has

392
00:25:29,548 --> 00:25:33,158
a couple of possibilities. It can either be left,

393
00:25:33,324 --> 00:25:36,818
which is for failed operations,

394
00:25:36,994 --> 00:25:40,666
and it can be right, which is for the

395
00:25:40,768 --> 00:25:43,994
successful ones, and that's the way

396
00:25:44,112 --> 00:25:47,242
it can be handled. Also the types and stuff are

397
00:25:47,296 --> 00:25:49,660
really clear on how to use them.

398
00:25:50,290 --> 00:25:54,142
And another cool thing is that,

399
00:25:54,196 --> 00:25:57,614
well, I will show you this. Let me see if I can

400
00:25:57,652 --> 00:26:01,134
actually, let's run

401
00:26:01,172 --> 00:26:05,490
it here, actually console log what

402
00:26:05,560 --> 00:26:09,300
a response, this response is looking like

403
00:26:11,510 --> 00:26:13,010
into the browser.

404
00:26:15,910 --> 00:26:19,670
Let's see. So what I am defining here is just the user state,

405
00:26:19,740 --> 00:26:22,838
which has a type of either. So as you

406
00:26:22,844 --> 00:26:26,886
can see, either has the possibility for

407
00:26:26,908 --> 00:26:30,646
us to let the developer know what is

408
00:26:30,668 --> 00:26:34,202
going to be the error, what type is going to the error have,

409
00:26:34,336 --> 00:26:38,186
and what type is going to be successful. So the error is

410
00:26:38,208 --> 00:26:41,486
just going to be error. It can be an HTTP error, it can be any

411
00:26:41,508 --> 00:26:45,214
error that you define it. And here I'm defining that. I'm going

412
00:26:45,252 --> 00:26:49,390
to retrieve an array of GitHub repositories.

413
00:26:50,370 --> 00:26:53,650
So let's see if I can show you how it works.

414
00:26:53,720 --> 00:26:57,540
Here. It's an object.

415
00:26:58,070 --> 00:27:01,314
As you can see, the response is not what we might

416
00:27:01,352 --> 00:27:04,290
expect, like an empty are right immediately.

417
00:27:04,630 --> 00:27:08,294
What it does is to create this tag that says

418
00:27:08,332 --> 00:27:11,590
that it's right. If this left is going to be left,

419
00:27:11,660 --> 00:27:16,326
and then it has the value right. Now it

420
00:27:16,348 --> 00:27:20,106
has the value in the right. That is an empty Ari, which is

421
00:27:20,128 --> 00:27:22,410
the one that we defined it here for default.

422
00:27:23,230 --> 00:27:26,982
That is one of the main difference. So it actually obligates

423
00:27:27,046 --> 00:27:30,638
you to tell if the

424
00:27:30,644 --> 00:27:35,486
operation or whatever you are creating is either an error or a

425
00:27:35,508 --> 00:27:39,790
successful type and task. Either is

426
00:27:39,940 --> 00:27:43,166
the computations of the task, which is what we

427
00:27:43,188 --> 00:27:46,450
just checked before, and an either, which is what I'll explain

428
00:27:46,520 --> 00:27:50,254
it now. So task either is a promise that can actually fail

429
00:27:50,302 --> 00:27:53,860
and that you can handle the errors with either.

430
00:27:55,450 --> 00:27:58,934
Awesome. After that explanation, let's check

431
00:27:58,972 --> 00:28:02,662
a little bit on the difference of how promises actually

432
00:28:02,716 --> 00:28:06,680
handle the errors and how the task can handle it.

433
00:28:08,250 --> 00:28:11,642
Here we have a promise, as you can see, nothing new. We create

434
00:28:11,696 --> 00:28:15,050
a promise and that's it. But what happens if this

435
00:28:15,120 --> 00:28:18,826
fails? We can actually let it pass and

436
00:28:18,928 --> 00:28:24,074
do nothing, and we can actually omit

437
00:28:24,202 --> 00:28:28,398
completely the catch and

438
00:28:28,564 --> 00:28:31,710
that would make the program. Let's see how it works.

439
00:28:31,860 --> 00:28:35,234
If I run the program with failure, it actually

440
00:28:35,432 --> 00:28:39,310
runs here, the error, but it doesn't show anything to the user.

441
00:28:39,390 --> 00:28:42,866
Or I don't know, if you don't have an

442
00:28:42,888 --> 00:28:46,306
error boundary or something, it can make the application explode

443
00:28:46,418 --> 00:28:49,720
in the browser and stuff like that. Right?

444
00:28:51,130 --> 00:28:54,454
But we can also add a catch, which is a good

445
00:28:54,492 --> 00:28:57,670
practice for the promises. But let's see the difference

446
00:28:57,740 --> 00:29:01,162
here. If I write a catch here, let's see what type

447
00:29:01,216 --> 00:29:04,522
the errors gives me. You can see it's can

448
00:29:04,576 --> 00:29:08,186
any. So an error can be of any kind that

449
00:29:08,208 --> 00:29:11,820
you want. That is why when you

450
00:29:12,670 --> 00:29:16,880
control something into react or anything that you are building,

451
00:29:17,330 --> 00:29:20,446
you can do whatever you want with the error. But as you don't know what

452
00:29:20,468 --> 00:29:22,400
it is, what type it is,

453
00:29:25,670 --> 00:29:29,246
it can always be confusing for the developer either to handle

454
00:29:29,278 --> 00:29:32,900
it or to know what kind of error is actually getting

455
00:29:33,590 --> 00:29:36,946
for me to handle. Right? So that is also one of the

456
00:29:36,968 --> 00:29:40,342
disadvantages that the promises might have. But again,

457
00:29:40,396 --> 00:29:43,720
they are awesome and it could work for sure.

458
00:29:44,810 --> 00:29:49,674
But let's check the difference with

459
00:29:49,712 --> 00:29:53,500
a task, right? So here I am defining the same

460
00:29:54,990 --> 00:29:58,620
task, I am getting the

461
00:30:00,350 --> 00:30:04,378
something. Also really cool is that for example in the promise

462
00:30:04,474 --> 00:30:08,122
again, I actually have to define it like success promise,

463
00:30:08,186 --> 00:30:11,966
failed promise, run it all again. But for example, in the task I

464
00:30:11,988 --> 00:30:15,534
can actually define either successful or failed

465
00:30:15,582 --> 00:30:19,314
one and I can pass it here as

466
00:30:19,352 --> 00:30:23,490
a parameter, it's just a function into another

467
00:30:23,560 --> 00:30:28,230
function as a parameter, which is, as I told you before, a functional programming

468
00:30:30,090 --> 00:30:34,280
practice. Cool. So if I run the task here

469
00:30:36,810 --> 00:30:40,214
with a task, either just these ones that we

470
00:30:40,252 --> 00:30:43,862
created here, because this catch can either be an error

471
00:30:43,926 --> 00:30:46,780
on a response or a response, the same here,

472
00:30:47,710 --> 00:30:50,446
what is going to happen is that at first we are going to receive the

473
00:30:50,468 --> 00:30:53,082
request, then we are going to can,

474
00:30:53,226 --> 00:30:56,414
this is another kind of composition that we can do

475
00:30:56,612 --> 00:31:00,240
to chain different asynchronous operations here.

476
00:31:00,690 --> 00:31:05,170
So what I'm doing here is chaining and trying catch

477
00:31:06,790 --> 00:31:09,570
the resolution of the data, right?

478
00:31:09,640 --> 00:31:13,438
So if the request succeeded, then I'm

479
00:31:13,454 --> 00:31:17,698
going to go ahead and get the JSON, return the JSON

480
00:31:17,794 --> 00:31:20,966
to the developer to do whatever the developer wants to do,

481
00:31:21,068 --> 00:31:25,030
and otherwise I'm going to have to return an error,

482
00:31:25,370 --> 00:31:29,370
right? If I try to return like the typical,

483
00:31:30,750 --> 00:31:33,900
I don't know, console log something,

484
00:31:35,550 --> 00:31:39,178
this is immediately going to fail. Because we are defining that

485
00:31:39,184 --> 00:31:42,662
the task either has to be either an errors or a response.

486
00:31:42,726 --> 00:31:46,590
So we are forcing the developer to know that here we have to actually

487
00:31:46,660 --> 00:31:49,982
return that type of error. And the same,

488
00:31:50,036 --> 00:31:53,966
when we actually run the task and receive the data, we can actually handle

489
00:31:53,998 --> 00:31:55,940
it like that. Right?

490
00:31:56,710 --> 00:31:59,380
So let's see how it works.

491
00:32:00,390 --> 00:32:04,514
If I run the successful task, it actually run

492
00:32:04,552 --> 00:32:07,698
it like this, just normal.

493
00:32:07,874 --> 00:32:11,730
If I run the failure task, I present the error,

494
00:32:11,890 --> 00:32:15,122
right? So let's see how we presented the error

495
00:32:15,186 --> 00:32:19,100
here. Let me check. Here it is

496
00:32:20,270 --> 00:32:23,530
as we are defining the response,

497
00:32:26,110 --> 00:32:28,940
which is an taskeither,

498
00:32:29,310 --> 00:32:33,022
right. We actually don't have

499
00:32:33,076 --> 00:32:35,520
a way to say,

500
00:32:37,410 --> 00:32:41,182
I don't know, like map immediately into

501
00:32:41,236 --> 00:32:44,082
that taskeither. You know what I mean?

502
00:32:44,136 --> 00:32:47,746
Like for example, here in the success promise, we are going

503
00:32:47,768 --> 00:32:51,410
to be able to map immediately into the promise response

504
00:32:52,070 --> 00:32:56,286
map. And then we do it because the data is

505
00:32:56,408 --> 00:32:58,920
what we got and then we do things,

506
00:32:59,290 --> 00:33:02,870
right. But in the case of can taskeither,

507
00:33:03,020 --> 00:33:06,806
we can't map into can taskeither because can taskeither is either a

508
00:33:06,828 --> 00:33:10,474
left or a right. What we have to do is to fold it.

509
00:33:10,592 --> 00:33:14,330
To fold it means that we can actually control what happens

510
00:33:14,480 --> 00:33:19,050
when something turned it out to be an error and

511
00:33:19,200 --> 00:33:22,750
what happens when something turn it out to be successful.

512
00:33:23,570 --> 00:33:27,082
As you can see, there are a couple of arrow

513
00:33:27,146 --> 00:33:30,960
functions that I define here. So let me remove this.

514
00:33:31,330 --> 00:33:34,766
If I actually default, we're going to see the

515
00:33:34,788 --> 00:33:38,306
typed much clearer, clearer. So as you can see, we have

516
00:33:38,328 --> 00:33:42,146
the on left we're going to have an arrow function that receives an

517
00:33:42,168 --> 00:33:45,926
error and you can return a react node or whatever you

518
00:33:45,948 --> 00:33:49,814
want. And on the right we have that.

519
00:33:49,852 --> 00:33:54,290
We are getting a GitHub repo array

520
00:33:54,450 --> 00:33:58,054
and we have to return a react node or whatever you

521
00:33:58,092 --> 00:34:01,466
want to return there. Right? So this

522
00:34:01,488 --> 00:34:04,854
is something really cool that we can do with the ether

523
00:34:04,982 --> 00:34:08,794
and tasks either. And here as we actually are getting

524
00:34:08,832 --> 00:34:12,654
the GitHub repo now I can map what we

525
00:34:12,772 --> 00:34:16,478
might have to do with the promises is actually here

526
00:34:16,564 --> 00:34:20,990
in the catch, we might have wanted to set

527
00:34:21,060 --> 00:34:24,514
error to something. Sorry about

528
00:34:24,552 --> 00:34:27,874
that. To set the error to something,

529
00:34:28,072 --> 00:34:31,762
I don't know, like it failed and

530
00:34:31,816 --> 00:34:36,098
stuff like that. The same might happen in

531
00:34:36,104 --> 00:34:40,014
the case of the loading. In the case, if it's not initialized,

532
00:34:40,142 --> 00:34:44,278
we might have to set here all the user states

533
00:34:44,364 --> 00:34:47,734
to handle those possible cases. Instead, here we

534
00:34:47,772 --> 00:34:50,970
already have them thanks to the taskeither.

535
00:34:51,120 --> 00:34:54,426
Right. So that is something really cool that we can

536
00:34:54,448 --> 00:34:57,974
control and is also not useful. Not only useful,

537
00:34:58,022 --> 00:35:01,520
but also restricts the developer on how to handle things.

538
00:35:02,610 --> 00:35:06,334
Right. But as I said before, how do

539
00:35:06,372 --> 00:35:10,126
I show the clients that my request is in

540
00:35:10,148 --> 00:35:12,560
the pending state, in the loading state?

541
00:35:14,550 --> 00:35:18,706
That can be kind of tricky and it has many different

542
00:35:18,888 --> 00:35:22,510
or many challenges,

543
00:35:22,670 --> 00:35:25,290
not only in the promises, but also in the tasks.

544
00:35:25,470 --> 00:35:29,314
But I wanted to show you remote

545
00:35:29,362 --> 00:35:35,414
data, which is here as

546
00:35:35,452 --> 00:35:38,238
an alternative to use task eaters.

547
00:35:38,354 --> 00:35:42,362
Okay, so let's see how it works around

548
00:35:42,416 --> 00:35:45,146
here to remote data. And that's it.

549
00:35:45,248 --> 00:35:47,718
So this is a different library,

550
00:35:47,894 --> 00:35:52,046
remote data. TS is a library that is completely compatible with

551
00:35:52,148 --> 00:35:53,310
fpts.

552
00:35:56,050 --> 00:35:59,018
So we can continue to use that functional approach.

553
00:35:59,114 --> 00:36:02,842
And what it does is to have

554
00:36:02,996 --> 00:36:07,090
this remote data type which divides

555
00:36:07,430 --> 00:36:11,186
the request or whatever asynchronous operation that we are

556
00:36:11,208 --> 00:36:15,206
doing into four different types or states. The first

557
00:36:15,228 --> 00:36:19,190
one is initial, which means that it hasn't been

558
00:36:19,260 --> 00:36:22,834
called or anything. The second one is pending,

559
00:36:22,962 --> 00:36:26,978
which means that it's actually started, but it's loading.

560
00:36:27,154 --> 00:36:30,266
The other one is failure, which is failure, and success,

561
00:36:30,448 --> 00:36:34,154
which is success. Right. So this is really cool,

562
00:36:34,192 --> 00:36:37,946
because what we can actually do is not only set our

563
00:36:37,968 --> 00:36:41,674
response into a taskeither, but into a remote data.

564
00:36:41,792 --> 00:36:45,022
So response now is not can taskeither,

565
00:36:45,076 --> 00:36:48,046
that can be a left or a right, but is a remote data that can

566
00:36:48,068 --> 00:36:51,280
be in all of those states, right?

567
00:36:51,650 --> 00:36:55,022
So the first state or the default one shouldnt be initial

568
00:36:55,086 --> 00:36:59,150
because we haven't run the operation

569
00:36:59,230 --> 00:37:02,754
yet, right. So when we define the

570
00:37:02,792 --> 00:37:06,102
task, this is exactly the same. We define the task either

571
00:37:06,156 --> 00:37:09,510
that can be an error or a response. And here

572
00:37:09,580 --> 00:37:13,350
is where we can do like when it's initial.

573
00:37:14,810 --> 00:37:17,946
If it's not initial, then it can actually be in

574
00:37:17,968 --> 00:37:21,580
these different states. So we make the request and

575
00:37:22,350 --> 00:37:25,990
I am adding here like can artificial loading,

576
00:37:26,150 --> 00:37:28,650
just to show how it might load.

577
00:37:29,710 --> 00:37:33,742
The other one is a can that

578
00:37:33,876 --> 00:37:37,070
creates me the try catch to get the data

579
00:37:37,220 --> 00:37:40,814
as we did before. And the last one is a catch,

580
00:37:41,012 --> 00:37:44,606
which actually returns me. If it is

581
00:37:44,628 --> 00:37:48,686
an error, I can set the response to be remote

582
00:37:48,718 --> 00:37:52,734
data failure. And if it is a success, the response

583
00:37:52,782 --> 00:37:55,700
should be a success. Remote data,

584
00:37:56,150 --> 00:37:59,894
that's it. As you can see, we are piping this. Then we can call it,

585
00:37:59,932 --> 00:38:03,894
we'll run it here and that should be it. So it's awesome. So when

586
00:38:03,932 --> 00:38:09,706
we get the response, check it out how it looks in the code here.

587
00:38:09,888 --> 00:38:13,706
You remember that before the taskeither, we folded. We can do exactly the

588
00:38:13,728 --> 00:38:17,418
same here. Instead of folding the taskeither, we fold the remote data.

589
00:38:17,584 --> 00:38:21,162
So let me check how it looks.

590
00:38:21,296 --> 00:38:25,266
We try to fold here. As you can see, it says uninitial.

591
00:38:25,318 --> 00:38:29,002
What happens on pending, what happens on failure,

592
00:38:29,066 --> 00:38:32,426
on success. So it's exactly the same concept.

593
00:38:32,538 --> 00:38:35,934
On initial, I'm going to show can alert, that says

594
00:38:35,972 --> 00:38:40,180
not collect. On pending, I'm going to show the loading on

595
00:38:40,790 --> 00:38:43,394
errors. This on response this,

596
00:38:43,592 --> 00:38:47,234
and this is awesome because again we restrict the developer to handle

597
00:38:47,282 --> 00:38:51,160
all the cases and also it's a lot more specific

598
00:38:51,610 --> 00:38:55,158
for the user. Right? Check how it works here.

599
00:38:55,244 --> 00:38:59,160
I'm going to make my network connection a little bit

600
00:39:00,490 --> 00:39:04,058
slow to check how the pending works. And if I run, as you

601
00:39:04,064 --> 00:39:07,910
can see, it does not call it yet. Then it says loading

602
00:39:08,070 --> 00:39:10,938
takes a little bit and then we have the success,

603
00:39:11,104 --> 00:39:14,762
which is awesome. If we make it fail,

604
00:39:14,906 --> 00:39:18,910
I don't know. For example, let's try to call something that actually doesn't exist.

605
00:39:20,210 --> 00:39:23,442
We are going to get the invalid Json, which is exactly what

606
00:39:23,496 --> 00:39:26,690
we wanted, right? So that is something that

607
00:39:26,760 --> 00:39:30,450
I wanted to show, which is really

608
00:39:30,520 --> 00:39:34,654
code about remote data and how fpts and functional

609
00:39:34,702 --> 00:39:38,134
approach can help us not only to improve the

610
00:39:38,172 --> 00:39:42,680
promises, but also to get a lot more functionalities and

611
00:39:43,130 --> 00:39:46,646
possibilities to handle our code in a

612
00:39:46,668 --> 00:39:50,234
more functional way. Right? Finally,

613
00:39:50,352 --> 00:39:53,898
what I would like to show is something

614
00:39:53,984 --> 00:39:57,402
about another cool library that we have for

615
00:39:57,456 --> 00:40:01,070
functional programming, asynchronous operations,

616
00:40:01,410 --> 00:40:03,120
which is future,

617
00:40:04,210 --> 00:40:08,110
right? So to make it short, basically futures

618
00:40:08,690 --> 00:40:12,802
doesn't have taskeither or tasks or stuff like that, but it actually

619
00:40:12,856 --> 00:40:16,178
has futures. A future is

620
00:40:16,344 --> 00:40:20,014
what we can define as a lazy prompt in flutter,

621
00:40:20,142 --> 00:40:24,590
right? It has exactly the same advantages

622
00:40:24,670 --> 00:40:27,634
of a task either of functional programming.

623
00:40:27,682 --> 00:40:31,990
You can compose it, it's lazy and everything, but it

624
00:40:32,060 --> 00:40:35,414
also has can awesome feature, which is that it is

625
00:40:35,452 --> 00:40:39,034
also cancellable, which means that you

626
00:40:39,072 --> 00:40:43,206
can actually call a promise and cancel

627
00:40:43,238 --> 00:40:47,146
it, or unsubscribe or finish it whenever you

628
00:40:47,168 --> 00:40:50,746
need it. This is super useful for systems like

629
00:40:50,848 --> 00:40:54,778
react or view or something that is reactive. Because let's

630
00:40:54,794 --> 00:40:58,206
say that someone clicked into run this promise and

631
00:40:58,228 --> 00:41:02,046
then click it another place that doesn't need that promise. If we run it

632
00:41:02,068 --> 00:41:06,290
in the normal way, that promise will run until

633
00:41:06,360 --> 00:41:09,714
it finishes. But here we can actually cancel it

634
00:41:09,752 --> 00:41:12,500
when it's needed. So let's see how it works.

635
00:41:14,550 --> 00:41:16,760
First let's check a little bit in the code.

636
00:41:19,450 --> 00:41:24,722
So long story short, the same we define

637
00:41:24,866 --> 00:41:27,942
the future instance, which is this one.

638
00:41:28,076 --> 00:41:31,686
Here we create the future and the same as the

639
00:41:31,708 --> 00:41:34,758
task. Either it can be an error or a succeed.

640
00:41:34,854 --> 00:41:37,930
So here to make it sure, what I did is just to define a future

641
00:41:38,000 --> 00:41:41,870
instance that is going to return something if errors or string

642
00:41:42,930 --> 00:41:46,718
if succeeds. This is just the timeout that is

643
00:41:46,724 --> 00:41:50,094
going to wait 3 seconds and return that my future was

644
00:41:50,212 --> 00:41:53,870
fulfilled. And here is can awesome function,

645
00:41:53,940 --> 00:41:57,570
which is the one that allow us to cancel whatever we were

646
00:41:57,640 --> 00:42:01,982
running. So I just added here a console log and we clear the timeout.

647
00:42:02,126 --> 00:42:06,338
Right. This is what is going to be called when we unsubscribe

648
00:42:06,514 --> 00:42:08,870
this future instance.

649
00:42:09,850 --> 00:42:13,014
So how do we run a

650
00:42:13,052 --> 00:42:16,582
future? The only way to run it

651
00:42:16,636 --> 00:42:20,670
or to do it is like calling it. You remember in taskeither

652
00:42:20,770 --> 00:42:24,486
what we did was just call the computations

653
00:42:24,598 --> 00:42:28,090
of the pipe that we created. But here we have

654
00:42:28,240 --> 00:42:32,126
this function that receives a future. And if you can

655
00:42:32,148 --> 00:42:34,910
pipe it again into a fork,

656
00:42:36,050 --> 00:42:39,662
this fork is going to allow us to send the same

657
00:42:39,716 --> 00:42:43,120
data as the taskeither. What happens when something is

658
00:42:43,810 --> 00:42:46,862
unsuccessful and when something succeeded?

659
00:42:47,006 --> 00:42:50,820
Right. That is it. What I'm telling here is that the future

660
00:42:52,390 --> 00:42:55,734
I want to console log if it failed, and I

661
00:42:55,772 --> 00:42:59,586
want to set the answer into my user

662
00:42:59,618 --> 00:43:03,766
state here into whatever the

663
00:43:03,788 --> 00:43:07,958
future succeeded to. Okay. And the final

664
00:43:08,044 --> 00:43:11,834
function that I have here, this actually has nothing

665
00:43:11,872 --> 00:43:14,986
to do with the cancellation itself, just a button that helps me

666
00:43:15,008 --> 00:43:18,940
to call the cancel. But let's see, let's see what type

667
00:43:20,050 --> 00:43:23,162
this one returns, which is the fork.

668
00:43:23,306 --> 00:43:26,926
Right. It returns a

669
00:43:26,948 --> 00:43:30,954
cancel. So it means that by default

670
00:43:31,082 --> 00:43:34,926
whenever we call future, it returns

671
00:43:34,958 --> 00:43:39,186
me a cancel. A cancel is a function that calls the

672
00:43:39,288 --> 00:43:43,074
uncancelled callback or whatever you want to call it that is

673
00:43:43,112 --> 00:43:45,730
going to stop my prompts to be resolved.

674
00:43:46,150 --> 00:43:49,430
So what I did here is just to create another

675
00:43:49,500 --> 00:43:52,806
function that is going to be called by a button. If the

676
00:43:52,828 --> 00:43:56,022
cancel exists, then call the cancel. Oh,

677
00:43:56,076 --> 00:44:00,600
sorry. Then call the cancel function.

678
00:44:02,350 --> 00:44:06,570
The cancel function, as you can see what it is, is just this set cancel

679
00:44:08,990 --> 00:44:13,200
that I am using here. I am going to show you why

680
00:44:13,570 --> 00:44:16,974
this is because let's run it

681
00:44:17,012 --> 00:44:20,366
here to explain that if

682
00:44:20,388 --> 00:44:24,266
I run the future with this button,

683
00:44:24,388 --> 00:44:27,410
it is going to start and

684
00:44:27,480 --> 00:44:31,266
it's going to be fulfilling. So what this button did, let's check it

685
00:44:31,288 --> 00:44:34,450
out. If I run the future, it is actually

686
00:44:34,520 --> 00:44:38,134
going to set the cancel and run the future, which is this

687
00:44:38,172 --> 00:44:41,702
function that returns the cancel. Right. So what I'm doing here

688
00:44:41,756 --> 00:44:45,206
is actually creating or saving the

689
00:44:45,228 --> 00:44:49,560
cancel function that was returned from the future into

690
00:44:51,850 --> 00:44:55,190
this cancel user state, which is of typed cancel.

691
00:44:55,350 --> 00:44:57,866
That is why we have to do it like that. I know it can be

692
00:44:57,888 --> 00:45:01,210
a little confusing at first, but it's the only way that I can subscribe

693
00:45:01,290 --> 00:45:04,366
into that future and I can cancel it later.

694
00:45:04,548 --> 00:45:08,846
Right? So if I run the future again and

695
00:45:08,868 --> 00:45:13,006
I cancel it, it immediately gets canceled and it doesn't returns

696
00:45:13,038 --> 00:45:16,354
me the promise that I

697
00:45:16,472 --> 00:45:20,482
ran it. So this cancel basically does that just

698
00:45:20,536 --> 00:45:23,714
clear the timeouts or whatever catch that we might have

699
00:45:23,752 --> 00:45:27,622
done and that's it. So it's really

700
00:45:27,676 --> 00:45:31,206
useful for anything that you

701
00:45:31,228 --> 00:45:34,966
might want to cancel. Whenever the

702
00:45:34,988 --> 00:45:38,538
user is moving from one place to another, clicking one button and another

703
00:45:38,624 --> 00:45:42,458
one, it's really useful to have this

704
00:45:42,544 --> 00:45:46,154
cancel feature. Okay, awesome. And that was

705
00:45:46,192 --> 00:45:49,782
it. So I will also like to mention other topics

706
00:45:49,846 --> 00:45:51,020
that you can check.

707
00:45:52,110 --> 00:45:55,466
Effects is library. It's an open source

708
00:45:55,498 --> 00:45:58,942
library that allows you to build software in a

709
00:45:58,996 --> 00:46:02,766
purely functional manner. And it's awesome. It's sort

710
00:46:02,788 --> 00:46:06,420
of the competitor of future, but yeah,

711
00:46:06,870 --> 00:46:10,382
once you get the concept and the mindset of functional programming,

712
00:46:10,446 --> 00:46:13,650
it's going to be easier for you to use any of this.

713
00:46:13,800 --> 00:46:17,334
Also rxJs, which can also help

714
00:46:17,372 --> 00:46:21,126
you handle the premises in a more

715
00:46:21,228 --> 00:46:24,600
observable way and in a more reactive way.

716
00:46:25,610 --> 00:46:29,446
ADTs algebraic data typed are the basic concepts

717
00:46:29,478 --> 00:46:33,260
of functional programming, and it's going to help you understand a lot more

718
00:46:33,630 --> 00:46:35,580
how this whole thing works.

719
00:46:37,550 --> 00:46:41,198
Functional programming itself, there's a lot to learn

720
00:46:41,364 --> 00:46:45,902
there and you can always start checking things

721
00:46:45,956 --> 00:46:49,534
with fpts. I would recommend for the front end

722
00:46:49,572 --> 00:46:52,634
and you can always use it for backend applications

723
00:46:52,682 --> 00:46:56,314
with node, which is awesome for creating

724
00:46:56,362 --> 00:46:59,634
needleworks and validations. For example,

725
00:46:59,672 --> 00:47:02,862
you can create simple and easy validations

726
00:47:02,926 --> 00:47:07,266
with ioTs. Just going to help you have type safety

727
00:47:07,378 --> 00:47:10,360
and validations immediately. It's really cool.

728
00:47:11,850 --> 00:47:15,590
And besides that, just to jump into some conclusions,

729
00:47:17,050 --> 00:47:20,474
I can say that promises are great,

730
00:47:20,592 --> 00:47:22,730
but they can always be improved.

731
00:47:23,870 --> 00:47:27,014
Functionet programming is a mindset,

732
00:47:27,062 --> 00:47:30,730
a paradigm that can help you to have cleaner, more testable,

733
00:47:30,810 --> 00:47:34,078
more control, and more readable code over all

734
00:47:34,164 --> 00:47:37,280
your application. Please give it a try.

735
00:47:39,010 --> 00:47:42,506
I know that the learning curve can be a little bit

736
00:47:42,548 --> 00:47:46,654
high, but it's worth it. It's worth it to have different approaches

737
00:47:46,702 --> 00:47:50,420
on how you can write your applications. Besides that,

738
00:47:51,030 --> 00:47:55,334
use these libraries with caution because as

739
00:47:55,372 --> 00:47:59,666
everything you can start implementing

740
00:47:59,698 --> 00:48:03,266
them without the good practices or making them an overhead

741
00:48:03,298 --> 00:48:07,126
can overkill into your application. So please use

742
00:48:07,148 --> 00:48:10,362
them with caution. Try not to overload everything into

743
00:48:10,416 --> 00:48:13,900
one application. Just decide what is better to your needs.

744
00:48:15,870 --> 00:48:19,434
Also, something that I found with these libraries is

745
00:48:19,472 --> 00:48:22,800
that documentation can be a little bit hard

746
00:48:23,330 --> 00:48:27,166
and sometimes a little bit to understand and

747
00:48:27,188 --> 00:48:30,734
to find in some cases. But the good

748
00:48:30,772 --> 00:48:35,954
part is that they are all really well typed and

749
00:48:36,152 --> 00:48:39,780
it helps you a lot when coding because the types can

750
00:48:40,550 --> 00:48:44,114
self explain the functions and how they work by

751
00:48:44,152 --> 00:48:48,182
themselves. So when you style the application, I'm sorry, when you

752
00:48:48,316 --> 00:48:51,526
install the library, you're going to have the help of the

753
00:48:51,548 --> 00:48:54,886
types and also some inside documentation that you have there.

754
00:48:54,988 --> 00:48:58,326
But it's always better to have first a

755
00:48:58,348 --> 00:49:01,666
clear idea of what functional programming is the basics

756
00:49:01,778 --> 00:49:05,078
and then start using them. And last

757
00:49:05,164 --> 00:49:09,046
but not least, enjoy programming. And thank you

758
00:49:09,068 --> 00:49:11,340
very much for watching this talk.

