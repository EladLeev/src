1
00:00:20,170 --> 00:00:23,710
Hi. So this talk is about secure building blocks. So secure building

2
00:00:23,780 --> 00:00:27,426
blocks, nothing. But it's a model block which can provide end to end solutions.

3
00:00:27,458 --> 00:00:31,154
In an embryo system or any system, it can be secure boot, secure update,

4
00:00:31,202 --> 00:00:35,158
secure communication, secure process, or secure storage. So it

5
00:00:35,164 --> 00:00:38,226
was our goal to build something can be plugged in,

6
00:00:38,268 --> 00:00:41,866
placed in your code very easily. It can be

7
00:00:42,048 --> 00:00:45,610
get into the existing stack and IoT can be fast

8
00:00:45,680 --> 00:00:50,060
secure, and it can update very fast based on your security

9
00:00:50,670 --> 00:00:54,106
vulnerabilities. Maybe today this cryptographic algorithm is safe. Tomorrow it will

10
00:00:54,128 --> 00:00:57,246
not be same. So how much fast we can update the code. Okay, we need

11
00:00:57,268 --> 00:01:00,318
to have updated in your code.

12
00:01:00,404 --> 00:01:02,590
So we are looking into all these aspects.

13
00:01:03,570 --> 00:01:06,766
We wanted to select a language. Okay, now step was

14
00:01:06,868 --> 00:01:10,670
we selected our secure building block. Obviously, it's an open source software development.

15
00:01:10,750 --> 00:01:14,146
We wanted to go for a language. Which language should we choose? So we had

16
00:01:14,168 --> 00:01:17,726
multiple options in our head. Maybe c, C plus, plus rust.

17
00:01:17,918 --> 00:01:20,982
Go kpython. We have multiple options,

18
00:01:21,036 --> 00:01:24,422
but of course, we have boiled down to two or three options.

19
00:01:24,476 --> 00:01:28,166
C rust, because they were systems level language which can have

20
00:01:28,188 --> 00:01:32,074
high performance because they don't have GC in it. Before you

21
00:01:32,112 --> 00:01:35,274
get into the rust world, right. You have to justify yourself.

22
00:01:35,312 --> 00:01:38,490
Why are you using rust? Because there's so much of stack available CNC.

23
00:01:38,910 --> 00:01:42,598
So justify yourself and everybody, because so legacy

24
00:01:42,614 --> 00:01:45,966
of code is available. You just can't go and change it. So we did

25
00:01:45,988 --> 00:01:48,590
some evaluation from our side. We also saw some papers.

26
00:01:48,930 --> 00:01:52,474
Okay, so why rust? For embedded system development and by extension,

27
00:01:52,522 --> 00:01:56,318
automative software security. So embedded

28
00:01:56,334 --> 00:01:59,182
system is one thing that can come where automotive,

29
00:01:59,246 --> 00:02:02,706
Iot, medical, anything can come there. Okay. Embedded system is a

30
00:02:02,728 --> 00:02:06,054
very vast thing. So rust can go in everywhere. So how

31
00:02:06,092 --> 00:02:09,174
can by extension, give automative security? Automotive is

32
00:02:09,212 --> 00:02:13,190
one of the important aspect area where security

33
00:02:13,260 --> 00:02:16,934
is very important, where any little here

34
00:02:16,972 --> 00:02:20,218
and there could lead to very high disaster. It can be space technology,

35
00:02:20,304 --> 00:02:27,226
it can be anything. So we wanted to see is

36
00:02:27,248 --> 00:02:31,198
it compiler is reliable? Is it certified? This is so many options when

37
00:02:31,204 --> 00:02:35,338
you go for a new language. Getting into the automotive

38
00:02:35,514 --> 00:02:39,200
world where tried and tested software is already running in your field,

39
00:02:42,530 --> 00:02:45,620
we have taken rust. But what is about, what is it about?

40
00:02:46,070 --> 00:02:49,630
It has fast. It is very fast because there's no gc.

41
00:02:49,790 --> 00:02:54,370
There's no gc. Obviously, the performance is very high, then low memory usage.

42
00:02:54,710 --> 00:02:58,434
There's no runtime or vm, and it compiles onto a machine

43
00:02:58,482 --> 00:03:00,680
code. Okay. So obviously,

44
00:03:01,930 --> 00:03:05,382
there's no bytecode available directly. You're going to get a

45
00:03:05,436 --> 00:03:09,174
hex file, which is binary which can edit it run on your which

46
00:03:09,212 --> 00:03:12,746
can edit run on your controller as a bare metal code.

47
00:03:12,928 --> 00:03:15,926
And it also has a memory and concurrency safety.

48
00:03:16,038 --> 00:03:19,322
No use of free dangling pointer, null pointer and data

49
00:03:19,456 --> 00:03:22,746
races and all. So this is one of the very good

50
00:03:22,768 --> 00:03:25,914
thing in automotive when you have a PLS concurrency kind of concept

51
00:03:25,962 --> 00:03:29,066
which is available directly, but the name is a PLS concurrency.

52
00:03:29,098 --> 00:03:32,574
It's very useful in your they can use it. Okay.

53
00:03:32,692 --> 00:03:36,594
And the powerful type system, this is the one thing what rust people

54
00:03:36,712 --> 00:03:40,242
like. The type system is so great that you can have your custom

55
00:03:40,296 --> 00:03:43,762
types and that custom types can be matched from your match

56
00:03:43,816 --> 00:03:47,654
statement or can be handled error. So which will help you to

57
00:03:47,852 --> 00:03:50,502
help you to have a clear flow of data in your code.

58
00:03:50,556 --> 00:03:54,690
Okay. If something is not happening, come on. Pattern matching,

59
00:03:54,770 --> 00:03:58,274
error handling, safe multithreading, all these are powerful

60
00:03:58,322 --> 00:04:02,086
type system, which combination makes it superb.

61
00:04:02,278 --> 00:04:05,882
Along with that we have excellent tooling. We have a ruster, one single tool,

62
00:04:05,936 --> 00:04:09,082
one single compiler. Not like multiple single things.

63
00:04:09,136 --> 00:04:11,180
And documenting is so nice, so good.

64
00:04:12,270 --> 00:04:15,966
The community is built such a way that seeing the drawbacks of

65
00:04:16,148 --> 00:04:19,566
few previous legacy of code data or get documentation should be

66
00:04:19,588 --> 00:04:23,530
must. Because today whatever code you write tomorrow you have to be able to

67
00:04:23,700 --> 00:04:27,262
identify what exactly I wrote. If you're not unable to identify,

68
00:04:27,326 --> 00:04:31,474
then the loss of time to read from the beginning utilised build

69
00:04:31,512 --> 00:04:35,170
system dependency management. All these are reasons

70
00:04:38,470 --> 00:04:41,854
along with it, it gives a modern general purpose language

71
00:04:41,982 --> 00:04:46,038
program language that also has these many features. So then

72
00:04:46,124 --> 00:04:50,614
it has the necessary ingredients to produce a safe, reliable performance systems

73
00:04:50,662 --> 00:04:54,294
code. So you have a safe reliable

74
00:04:54,422 --> 00:04:58,186
performance code. So what does you want still

75
00:04:58,208 --> 00:05:02,082
you're not stopping. Okay, we got from our answers

76
00:05:02,166 --> 00:05:05,806
looking into the rust thing and we will see what is available. What data do

77
00:05:05,828 --> 00:05:09,406
we have? Can existing code base.

78
00:05:09,588 --> 00:05:13,990
So chromium security we went through a couple of projects

79
00:05:14,090 --> 00:05:17,486
and there are so many available online. We tested

80
00:05:17,518 --> 00:05:20,798
ourselves some we read okay, the problem safety,

81
00:05:20,974 --> 00:05:24,446
the memory safety. So around 70% of high severity bugs

82
00:05:24,478 --> 00:05:27,778
are memory save bugs. So memory save bugs are the highest bugs.

83
00:05:27,874 --> 00:05:31,894
So 2021 memory unsafety Apple's operating system

84
00:05:32,012 --> 00:05:35,122
14 had 60.4% of memory vulnerabilities.

85
00:05:35,186 --> 00:05:38,842
13 had 59.4%. Twelve had 66.3%.

86
00:05:38,896 --> 00:05:42,060
Eleven had 60.5%. This is a very huge number.

87
00:05:42,750 --> 00:05:46,214
Android developers blog the queue the hardening

88
00:05:46,262 --> 00:05:50,194
enhancements use after free integer

89
00:05:50,262 --> 00:05:54,670
overflows out of bone reads writes

90
00:05:55,010 --> 00:05:59,118
compares 90% of vulnerabilities with OB being the most

91
00:05:59,284 --> 00:06:02,666
common. These are the things which is not properly managed

92
00:06:02,698 --> 00:06:06,802
in the existing code base. Okay then

93
00:06:06,856 --> 00:06:10,642
also we saw the project zero. The memory corruption issues are the root cause

94
00:06:10,696 --> 00:06:14,094
of 68% understood cvs.

95
00:06:14,142 --> 00:06:17,526
So we know that the memory safety issue has become one of

96
00:06:17,548 --> 00:06:21,458
the important factor in our security software development.

97
00:06:21,554 --> 00:06:24,834
So we have to completely eradicate that. Okay, so we were unable

98
00:06:24,882 --> 00:06:28,522
to completely eradicate memory safety issue from

99
00:06:28,656 --> 00:06:32,426
any existing language. Maybe c or c plus plus or

100
00:06:32,608 --> 00:06:36,874
go python we don't think

101
00:06:36,912 --> 00:06:40,586
could actually completely remove it. So rust is a

102
00:06:40,608 --> 00:06:44,698
language which will make you write a memory safe code. If you know Rust,

103
00:06:44,794 --> 00:06:48,366
Iot means the code. Whatever is going to compile, it's for

104
00:06:48,388 --> 00:06:51,200
sure is memory safe as a guarantee Iot gives you.

105
00:06:51,650 --> 00:06:55,598
Then we saw what exactly it is providing

106
00:06:55,694 --> 00:06:59,106
the safe memory management and powerful type system. These are the two

107
00:06:59,128 --> 00:07:03,026
things, the two combination which is giving you everything in

108
00:07:03,048 --> 00:07:06,726
can automotive security or software development. So what

109
00:07:06,748 --> 00:07:10,342
does it give? It gives three main things. Safety by construction zero cost

110
00:07:10,396 --> 00:07:13,702
abstraction compile time checks okay,

111
00:07:13,836 --> 00:07:17,666
so what does safety by construction means pointers are checked

112
00:07:17,698 --> 00:07:21,126
compile time. So all the pointers, unless you don't put in

113
00:07:21,148 --> 00:07:24,714
unsafe blocks, everything is safe. You can't just go and access some

114
00:07:24,752 --> 00:07:28,614
location and write something into it. Thread or task safety

115
00:07:28,662 --> 00:07:32,234
from types no hidden states zero cost

116
00:07:32,272 --> 00:07:35,838
abstraction efficient zero cost centrix so if you can also define a

117
00:07:35,844 --> 00:07:39,246
marker traits which will not take any memory no GC at

118
00:07:39,268 --> 00:07:43,294
runtime safe and unsafe rust compile

119
00:07:43,342 --> 00:07:47,086
time checks so compile time safety analysis so unless

120
00:07:47,118 --> 00:07:50,802
you don't have a dynamic dispatch, you're going to make every single

121
00:07:50,936 --> 00:07:54,542
code. Compile time check trace based conditional APIs,

122
00:07:54,686 --> 00:07:59,366
control allocation and dispatch. So these things makes

123
00:07:59,548 --> 00:08:03,634
safe performance and fine grain

124
00:08:03,682 --> 00:08:06,918
control of a system. This powerful thing will help you to

125
00:08:06,924 --> 00:08:10,140
have a memory safe code. Can you stop it?

126
00:08:10,590 --> 00:08:14,054
With rust? Safety guarantees plus powerful

127
00:08:14,102 --> 00:08:17,462
type system embedded systems program can write complex

128
00:08:17,526 --> 00:08:20,986
software that's safe. Now you can write a complex software which

129
00:08:21,008 --> 00:08:24,486
is safe from rust. How can rust help in automated systems

130
00:08:24,518 --> 00:08:28,106
or cybersecurity? So we saw that rust can give you a safe

131
00:08:28,138 --> 00:08:32,174
and perform high performance code which can help

132
00:08:32,212 --> 00:08:35,922
you write a complex code. Now we can write a complex embedded system code,

133
00:08:35,976 --> 00:08:39,026
but how does it help in our automotive software security?

134
00:08:39,208 --> 00:08:42,562
Then we have something called as

135
00:08:42,696 --> 00:08:46,434
some more points we have the rust greatly helps

136
00:08:46,482 --> 00:08:50,306
functional safety. So rust guarantees memory

137
00:08:50,338 --> 00:08:53,874
and concurrency. So memory corruption vulnerabilities

138
00:08:53,922 --> 00:08:57,366
are impossible apart from compiler or a hardware malfunction. So there

139
00:08:57,388 --> 00:09:00,586
is no possible that you are going to have memory corruption issues in

140
00:09:00,608 --> 00:09:04,486
rust. If it's happening, it's because of compiler or some hardware

141
00:09:04,518 --> 00:09:07,834
malfunctions. Okay, all shared mutable state

142
00:09:07,872 --> 00:09:11,690
is unsafe, so anything which is mutable state

143
00:09:11,760 --> 00:09:15,442
is unsafe. No race around conditions due to sentencing

144
00:09:15,526 --> 00:09:19,086
traits. So if you just go into the threads part of

145
00:09:19,108 --> 00:09:22,462
rust where you can see how you are trying to

146
00:09:22,516 --> 00:09:25,858
access a variable inside automix where you're going to

147
00:09:25,864 --> 00:09:29,026
lock it, other thread will unable to access it the way it is

148
00:09:29,048 --> 00:09:32,818
designed. Send and sync if a

149
00:09:32,984 --> 00:09:36,158
type implements a send, then you can pass the utility to

150
00:09:36,184 --> 00:09:39,622
it. If it implements a sync then you can share it.

151
00:09:39,756 --> 00:09:43,160
Okay, so everything is completely types and traits here,

152
00:09:43,530 --> 00:09:47,858
which will make the whole code very clean and understandable

153
00:09:47,954 --> 00:09:51,050
and very safe. Exploit by default.

154
00:09:51,470 --> 00:09:55,130
Pub mute clone result propagation casting are beneficial.

155
00:09:55,550 --> 00:09:59,034
And also we have some formal verification tooling called

156
00:09:59,232 --> 00:10:02,398
any risti, miri et cetera which will

157
00:10:02,484 --> 00:10:06,106
help you to test your code like functional

158
00:10:06,138 --> 00:10:09,422
basis, model basis, system basis. We can test

159
00:10:09,476 --> 00:10:13,454
it step by step. Also you don't have to follow the Misla C

160
00:10:13,492 --> 00:10:17,186
standard. What you actually follow in c, right? Because any

161
00:10:17,208 --> 00:10:20,626
code you write is memory safe and IoT is compiler will

162
00:10:20,648 --> 00:10:24,354
make sure that everything is followed. Because you're trying

163
00:10:24,392 --> 00:10:27,726
to write your own memory management in rust,

164
00:10:27,758 --> 00:10:31,106
which is not there in any other language, you're basically managing

165
00:10:31,138 --> 00:10:34,774
the whole memory. You're trying to access the stack memory, you're not trying to access

166
00:10:34,812 --> 00:10:37,974
any heap memory. Here the soundness compiler can verify

167
00:10:38,022 --> 00:10:42,694
the absence of undefined behavior. The compiler can actually verify

168
00:10:42,742 --> 00:10:46,442
the absence of undefined behavior. That's the main thing

169
00:10:46,496 --> 00:10:49,974
which all these factors along with that, we are also

170
00:10:50,032 --> 00:10:54,474
having some compiler releasing October which will make rust

171
00:10:54,522 --> 00:10:58,014
a suitable software for embedded software development and

172
00:10:58,052 --> 00:11:01,870
a security team. We take it as our main building block.

173
00:11:02,550 --> 00:11:05,998
Our first 70% of issue memory safety is solved

174
00:11:06,014 --> 00:11:09,154
by one language. So we take rust as our

175
00:11:09,192 --> 00:11:11,934
main code, main software,

176
00:11:12,062 --> 00:11:15,618
main language for a software development. Now let's

177
00:11:15,634 --> 00:11:19,334
get into SBB. So SBB stands for secure building

178
00:11:19,372 --> 00:11:23,666
blocks. So as I told, there can be multiple

179
00:11:23,778 --> 00:11:27,494
existing code available. It can be can automotive. You just need

180
00:11:27,532 --> 00:11:31,254
to have linking codes or modules

181
00:11:31,302 --> 00:11:35,386
in between those code so that you don't have to change the whole entire

182
00:11:35,568 --> 00:11:39,242
code list. Wherever security is required, go place it

183
00:11:39,296 --> 00:11:42,586
there. That is when our secure boot will come, which will help to

184
00:11:42,608 --> 00:11:46,286
securely boot your firmware or update your firmware. Then you

185
00:11:46,308 --> 00:11:49,806
have something called trusted firmware, where you sign the firmware and you

186
00:11:49,828 --> 00:11:53,202
tell that okay, this is a genuine firmware. What I'm sending it to you and

187
00:11:53,256 --> 00:11:56,910
the verifier will verify it. And you have a trusted

188
00:11:57,070 --> 00:12:00,798
identity, secure authentication. So we're

189
00:12:00,814 --> 00:12:04,706
going to have electric curve cryptography, and our code

190
00:12:04,728 --> 00:12:08,298
is designed such a way that example today this curve

191
00:12:08,334 --> 00:12:12,246
is broken. Tomorrow we're going to have some different curve. So it'll help to

192
00:12:12,428 --> 00:12:16,054
also have post quantum cryptography algorithms also in our system,

193
00:12:16,252 --> 00:12:17,830
such a way it is designed,

194
00:12:19,290 --> 00:12:22,938
then we have secure update. So once the code is

195
00:12:23,104 --> 00:12:26,970
firmware is verified. So if you have any update available

196
00:12:27,040 --> 00:12:30,118
from Phota, when you do phota, so you're going to get the firmware,

197
00:12:30,214 --> 00:12:33,654
it'll be in some location. How do you verify it and how do you update

198
00:12:33,702 --> 00:12:37,246
it is about one aspect. Then you have a cloud available. There is

199
00:12:37,268 --> 00:12:40,574
some data available in Kona. How do you communicate securely from

200
00:12:40,612 --> 00:12:44,206
a device and a middle device? And if

201
00:12:44,228 --> 00:12:48,050
you want to process some data, how do you process it securely within the system,

202
00:12:48,200 --> 00:12:51,362
or you want to store it in somewhere? Securely, how do you store data?

203
00:12:51,496 --> 00:12:55,162
So all these are the small, small blocks,

204
00:12:55,246 --> 00:12:59,378
building blocks of our building blocks,

205
00:12:59,394 --> 00:13:02,434
which will help you to make the whole system secure.

206
00:13:02,562 --> 00:13:06,594
It can be trusted secure authentication rust boot secure

207
00:13:06,642 --> 00:13:10,690
update trusted firmware secure communication secure storage

208
00:13:10,770 --> 00:13:14,010
secure process okay. And everything

209
00:13:14,080 --> 00:13:17,610
is modular. So modeler building blocks to simplify security

210
00:13:17,760 --> 00:13:21,046
development lifecycle, what is it? So what do you benefit

211
00:13:21,078 --> 00:13:24,894
from that? The benefit what you get is faster, go to market and

212
00:13:24,932 --> 00:13:27,360
also you can also keep on updating your code.

213
00:13:27,810 --> 00:13:30,986
Impact reduced operational risk independence

214
00:13:31,018 --> 00:13:34,530
from vendor locking reduced trusted computing base

215
00:13:34,680 --> 00:13:38,590
guaranteed memory data race safety

216
00:13:38,670 --> 00:13:42,610
minimize integral complexity and boot time avoid vendor lock in.

217
00:13:42,760 --> 00:13:46,234
These are some of the benefits. What you get when you have a SBB.

218
00:13:46,302 --> 00:13:49,698
So this project is completely open source. You can find in my GitHub

219
00:13:49,714 --> 00:13:53,494
page Ishwan Singham it's just my full name.

220
00:13:53,692 --> 00:13:57,986
You can also scan my QR code. My first slide

221
00:13:58,098 --> 00:14:01,578
slides will be given, I think I believe. So you can find this project is

222
00:14:01,584 --> 00:14:04,940
completely open source. So now we have built something called as

223
00:14:05,630 --> 00:14:09,340
secure authentication secure bootcup update. These are blocks already available.

224
00:14:10,510 --> 00:14:13,674
The reason why we make open source is because we

225
00:14:13,712 --> 00:14:17,694
need more contributions to it, so that many people can put their own ideas and

226
00:14:17,732 --> 00:14:21,438
build a software collab. And we're going to make a very strong software out of

227
00:14:21,444 --> 00:14:24,558
it. Next Iot security. So if

228
00:14:24,564 --> 00:14:27,966
you see the architecture of your system, right, so you have a hardware layer

229
00:14:27,998 --> 00:14:31,198
here. This is the MCU and this is for a Linux machine.

230
00:14:31,294 --> 00:14:35,034
Basically this is for MPU microprocessor. This is for microcontroller.

231
00:14:35,102 --> 00:14:38,934
So if you have microprocessor then this architecture will follow

232
00:14:39,052 --> 00:14:42,342
controller. We have can architecture. So whatever

233
00:14:42,396 --> 00:14:46,520
is a white thing is basically secure security component security

234
00:14:47,210 --> 00:14:50,938
accelerators are available here on the hardware. Hardware can be anything.

235
00:14:51,104 --> 00:14:54,506
Then you have a trusted execution environment abstraction layer which

236
00:14:54,528 --> 00:14:57,702
will help you to talk to this hardware,

237
00:14:57,766 --> 00:15:01,274
cryptocurrency accelerators, et cetera. And then you have your

238
00:15:01,312 --> 00:15:04,794
firmware upgrade and secure boot, which is in your green layer, what we have developed

239
00:15:04,842 --> 00:15:08,666
as a developer right now. And then we have our crypto

240
00:15:08,698 --> 00:15:12,830
cell library, secure storage, key storage,

241
00:15:13,330 --> 00:15:17,566
certificate management. All this comes in the ABU layer on

242
00:15:17,588 --> 00:15:21,170
that application sets. These are the bare metal things. What we

243
00:15:21,240 --> 00:15:25,140
going to do on MCU, on MPU, the same thing,

244
00:15:25,670 --> 00:15:29,606
trusted execution environment, abstraction layer. Here you're going to have

245
00:15:29,628 --> 00:15:32,758
your kernel and drivers above the hardware. Then you have a

246
00:15:32,764 --> 00:15:35,798
networking stack, secure transport layer, and then application.

247
00:15:35,964 --> 00:15:40,646
Those are typically you're going to have your blocks

248
00:15:40,678 --> 00:15:45,078
designed on your hardware. Then we have our opensource

249
00:15:45,094 --> 00:15:48,214
signature. The key component of secure software

250
00:15:48,262 --> 00:15:51,230
development is distance signatures hashing.

251
00:15:51,810 --> 00:15:55,722
So we follow something called asymmetric as symmetric cryptography,

252
00:15:55,786 --> 00:15:59,582
where you're going to have private key and public key, which is

253
00:15:59,716 --> 00:16:02,778
different. Different. So private key is with the

254
00:16:02,804 --> 00:16:06,660
person who is signing the firmware, maybe a person who is

255
00:16:07,110 --> 00:16:10,766
producing the firmware, a developer has a private key controller

256
00:16:10,798 --> 00:16:14,834
will have, or the device, which is client device is

257
00:16:14,872 --> 00:16:18,660
in the field will have a public key. The private key is used to sign

258
00:16:19,030 --> 00:16:22,546
a digest of firmware image. Okay. Private key is very confidential.

259
00:16:22,578 --> 00:16:26,550
By the way. Public key is used to verify the signed digest

260
00:16:26,890 --> 00:16:30,278
can be shared publicly, Iot can be shared. Anybody has public key can

261
00:16:30,284 --> 00:16:34,246
be shared and whoever has public key can verify it. But private

262
00:16:34,278 --> 00:16:37,706
key is confidential. If you lose it, then it's gone. So data is

263
00:16:37,728 --> 00:16:41,914
something, it can be firmware data. You take a hash of it

264
00:16:42,032 --> 00:16:44,734
and you're going to get digest from it. So what is digest? Digest is something

265
00:16:44,772 --> 00:16:48,350
of fixed value or a fixed data bytes.

266
00:16:48,690 --> 00:16:52,846
Then you're going to encrypt it. Then you're going to use a private key and

267
00:16:52,868 --> 00:16:55,354
you're going to get a signature out of it. Okay,

268
00:16:55,492 --> 00:16:59,122
so data, you're going to hash Iot,

269
00:16:59,256 --> 00:17:03,186
you're going to get a fixed size and you're going to encrypt it

270
00:17:03,368 --> 00:17:06,622
along with the private key and you're going to get a fixed size signature.

271
00:17:06,766 --> 00:17:10,518
So basically it's like a piece of paper. You're signing it on a

272
00:17:10,524 --> 00:17:13,798
piece of paper. If you sign, it becomes a document or it becomes your property,

273
00:17:13,884 --> 00:17:17,590
something like that. The signature is out of your data,

274
00:17:17,740 --> 00:17:22,146
which you are producing uniquely for a particular firm

275
00:17:22,178 --> 00:17:25,320
or data not booting time. How do you verify it?

276
00:17:25,690 --> 00:17:29,418
Okay, the signature, whatever you have signed, will be available

277
00:17:29,504 --> 00:17:32,378
on your firmware or on a piece of paper. Okay,

278
00:17:32,464 --> 00:17:36,062
so how do you verify with the data. So now in a booting time,

279
00:17:36,116 --> 00:17:39,306
the firmware, again, the boot are going to hash

280
00:17:39,338 --> 00:17:42,240
it and you're going to get the digest of it,

281
00:17:42,610 --> 00:17:46,206
and you're going to take the public key and decrypt Iot and

282
00:17:46,228 --> 00:17:49,506
you're going to get the digest of it. So you're going to get these two

283
00:17:49,528 --> 00:17:52,878
digest and to compare it. If it compares

284
00:17:52,894 --> 00:17:56,654
successful, then you're going to get the booting, you're going to verify

285
00:17:56,702 --> 00:18:00,626
it, and you're going to go for next step. Okay, that's how private

286
00:18:00,658 --> 00:18:03,958
key and public key. Private key, I'm going to sign it. Public key, I'm going

287
00:18:03,964 --> 00:18:07,906
to verify it. Hashing is required because to get a fixed length

288
00:18:07,938 --> 00:18:11,420
of data for digest, then we have,

289
00:18:11,790 --> 00:18:15,898
this is a flow typically. So ROM code is something

290
00:18:16,064 --> 00:18:19,530
which serves as a load of all trust. Okay. ROm code is a

291
00:18:19,680 --> 00:18:23,350
code which is immutable, immutable code stored

292
00:18:23,430 --> 00:18:27,434
in some form of onboard non volatile memory. It is flashed during

293
00:18:27,472 --> 00:18:30,794
manufacturing time. ROM code is the first piece of code to execute.

294
00:18:30,842 --> 00:18:33,758
So ROM code is the first piece of code that executes which will do the

295
00:18:33,764 --> 00:18:37,890
signature verification of a bootloader, which is just first stage bootloader.

296
00:18:38,230 --> 00:18:41,762
Our trust of anchor is public key embedded within the ROM code.

297
00:18:41,816 --> 00:18:45,038
So we have public key in our Romcode which is our trust of

298
00:18:45,064 --> 00:18:48,520
anchor. Rom code serves as root of trust.

299
00:18:49,530 --> 00:18:53,094
In practice. It is stored safely in something like a one time

300
00:18:53,132 --> 00:18:57,126
programmable fuse. So it is inside your one

301
00:18:57,148 --> 00:18:59,638
time programmable fuse in what is called OTP.

302
00:18:59,814 --> 00:19:03,340
Integrity of trust of anchor is important,

303
00:19:03,950 --> 00:19:07,180
not confidentiality. Integrity is important. Okay,

304
00:19:07,630 --> 00:19:10,906
so next we're going to have the next public key and then

305
00:19:10,928 --> 00:19:14,138
a verification. The kernel verified, the digest will be verified,

306
00:19:14,234 --> 00:19:18,110
hash verification. Then it goes to boot. This is how the control flows.

307
00:19:18,450 --> 00:19:22,400
Every component is verified using distance signature and public key.

308
00:19:22,770 --> 00:19:27,086
Next is, yeah, next comes our rust boot.

309
00:19:27,198 --> 00:19:30,786
So this talk is mainly focused on how

310
00:19:30,808 --> 00:19:34,254
do you boot a firmware, how do you sign a firmware, how do you verify

311
00:19:34,302 --> 00:19:37,458
it and how do you update the firmware? Okay, these are the things what we're

312
00:19:37,474 --> 00:19:41,414
going to cover in our session and

313
00:19:41,532 --> 00:19:45,382
the remaining secure communication, secure process. Secure storage is a different

314
00:19:45,436 --> 00:19:48,582
topic itself. So boot itself is one topic.

315
00:19:48,726 --> 00:19:51,910
So we're going to take introduction of secure boot

316
00:19:51,990 --> 00:19:56,470
and what are our goals and what are the features we're offering architecture,

317
00:19:56,550 --> 00:20:00,326
what's the flow of booting sequences?

318
00:20:00,438 --> 00:20:04,094
So all is we're going to see, you can actually

319
00:20:04,132 --> 00:20:07,914
scan this QR code and you can get the rust

320
00:20:07,962 --> 00:20:11,806
book. It's open source book we have written. So if

321
00:20:11,828 --> 00:20:15,298
you want to have a bootloader for your MCU, then you can

322
00:20:15,464 --> 00:20:18,866
read this book, follow instructions, and you can have a support for

323
00:20:18,888 --> 00:20:22,494
your controller, basically. Okay, so what is rust?

324
00:20:22,542 --> 00:20:26,046
Boot? Rust boot is a standalone bootloader written entirely

325
00:20:26,078 --> 00:20:30,786
in rust, designed to run anything from microcontroller

326
00:20:30,818 --> 00:20:34,374
to system on chip. It can be used to boot into bare metal or

327
00:20:34,412 --> 00:20:37,746
lux. It's a test definition of rust boot. It's a secure bootloader,

328
00:20:37,778 --> 00:20:41,630
basically, rust boot, just a secure bootloader,

329
00:20:41,650 --> 00:20:45,274
nothing more. Boot order help to boot how it is different

330
00:20:45,312 --> 00:20:47,450
from other boot order. We're going to discuss IoT, we're going to see it.

331
00:20:47,520 --> 00:20:50,130
It's very small, tiny, high performance,

332
00:20:50,310 --> 00:20:54,286
et cetera, et cetera. Okay, so what are our goals when

333
00:20:54,308 --> 00:20:58,602
I'm building a bootloader compiles with key requirements

334
00:20:58,666 --> 00:21:01,998
of IETF suit standard. So whenever you design a

335
00:21:02,004 --> 00:21:05,650
bootloader, right, you don't need to have a whole network stack.

336
00:21:06,230 --> 00:21:09,426
The flashing Uart stacks all the protocols in it,

337
00:21:09,448 --> 00:21:13,666
because you're not building OS, you're just building a first stage of bootloader which

338
00:21:13,688 --> 00:21:16,498
has capability of verifying the next stage.

339
00:21:16,594 --> 00:21:19,682
Okay, so you are going to have the network stage,

340
00:21:19,746 --> 00:21:23,560
network, network layer, everything. This should be in your

341
00:21:23,930 --> 00:21:27,846
application like code or your firmware. Bootloader should

342
00:21:27,868 --> 00:21:31,338
not have all this headache. So if you

343
00:21:31,424 --> 00:21:35,046
increase the size of your bootloader,

344
00:21:35,078 --> 00:21:38,186
you're going to increase the attack surface size means you're going to

345
00:21:38,208 --> 00:21:41,386
adding more and more features to it. If you're going to add

346
00:21:41,408 --> 00:21:45,066
a USB feature or you're going to add some URL feature

347
00:21:45,098 --> 00:21:48,446
or some protocol feature, network feature, attacker gets

348
00:21:48,548 --> 00:21:51,822
hundred ways to go into it. So we're going to minimize it.

349
00:21:51,956 --> 00:21:55,746
Required peripherals, we're going to use it. We will

350
00:21:55,768 --> 00:21:58,050
not even use UART unless it's necessary.

351
00:21:59,350 --> 00:22:02,962
There's IoT going to be any protocol interface from external world

352
00:22:03,016 --> 00:22:07,026
to tamper it. Unless you go into memory using a JTAG or something like

353
00:22:07,048 --> 00:22:11,670
that, there's no way possible you're going to get access to it. Reliable updates.

354
00:22:12,250 --> 00:22:15,138
Also, your bootload should be updatable.

355
00:22:15,314 --> 00:22:19,382
See, today you have an electrical free two to six

356
00:22:19,436 --> 00:22:22,906
mist, two to six. Tomorrow IoT can break. How do you

357
00:22:22,928 --> 00:22:26,506
make sure that your bootloader is updated? Hardware can stay for

358
00:22:26,528 --> 00:22:29,562
hundreds of years, but your software has to be updated every single time.

359
00:22:29,616 --> 00:22:33,466
How do you make it so? Our goal is to also have a reliable

360
00:22:33,498 --> 00:22:36,522
updates. Predictability or performance?

361
00:22:36,666 --> 00:22:40,618
Performance is fine. Okay, this is very fast every single day of performance,

362
00:22:40,714 --> 00:22:44,110
but how much predictable it is today, it is behaving like this tomorrow. Also,

363
00:22:44,260 --> 00:22:47,426
are you making sure it is behaving like this every single day? So how

364
00:22:47,448 --> 00:22:50,610
do you make sure it. That's called predictability.

365
00:22:51,270 --> 00:22:54,834
Zero dynamic memory allocation. So how do you

366
00:22:54,952 --> 00:22:58,134
make sure that your bootloader is having no

367
00:22:58,172 --> 00:23:01,490
heap in it? Okay, we don't want any dynamic memory allocation

368
00:23:01,570 --> 00:23:05,382
in your bootloader. That's the fourth point. Fifth point is

369
00:23:05,436 --> 00:23:09,398
the most important point, which is memory safety and type state programming.

370
00:23:09,574 --> 00:23:13,210
This is completely offered from our rust itself.

371
00:23:13,360 --> 00:23:17,558
Okay. So there are some features like predictability or performance,

372
00:23:17,734 --> 00:23:20,874
zero dynamic memory location and rust safety and

373
00:23:20,912 --> 00:23:24,478
type state programming. All these are features are directly available

374
00:23:24,564 --> 00:23:28,094
from rust. The top two features are available

375
00:23:28,212 --> 00:23:32,046
from maybe first feature is available the way you design the

376
00:23:32,068 --> 00:23:36,290
software. Second is how much model you're going to make to get a lab updates.

377
00:23:36,790 --> 00:23:40,494
Then we go into our features. Okay, this is what goals

378
00:23:40,542 --> 00:23:43,694
we have. So whatever features, whatever we have offered.

379
00:23:43,822 --> 00:23:47,586
So currently our Rust bootler offers support for ARM,

380
00:23:47,618 --> 00:23:51,922
Cortex M and Cortex a MCUs or Meg architectures.

381
00:23:52,066 --> 00:23:55,666
So we support different family controllers like STM microchip,

382
00:23:55,698 --> 00:23:59,238
NRF. Many people have added support for us

383
00:23:59,244 --> 00:24:02,822
as opensource project support for multi slot partitioning

384
00:24:02,886 --> 00:24:06,918
of flash memory. This allows to implement boot update approach for bare metal

385
00:24:07,014 --> 00:24:10,394
firmware. So you're going to have a flash, you're going to make IoT partition

386
00:24:10,442 --> 00:24:14,510
the flash, which I'm going to go in detail in the coming things

387
00:24:14,580 --> 00:24:18,910
where you're going to have boot partition update partition and SAP partition

388
00:24:19,490 --> 00:24:22,746
support for Arc 64 Linux supporting.

389
00:24:22,778 --> 00:24:25,826
So we have also support for Arc 64. Right now it's the only architecture what

390
00:24:25,848 --> 00:24:29,486
we have. Cortex support elliptic cryptography

391
00:24:29,518 --> 00:24:33,506
for integrity and authenticity verification. Crypto credits. We are

392
00:24:33,528 --> 00:24:37,374
going to also add postponed crypto to it. Tiny hardware

393
00:24:37,422 --> 00:24:40,806
abstraction layer for non volatile memory flash access. So I told you

394
00:24:40,828 --> 00:24:44,326
we're going to have very tiny ha layer, flash layer so that we're going to

395
00:24:44,348 --> 00:24:48,358
make our bootloader very less memory. That going

396
00:24:48,364 --> 00:24:52,454
to have high performance anti roll up protection over version

397
00:24:52,582 --> 00:24:54,540
numbering. So if there is any,

398
00:24:55,310 --> 00:24:58,970
while booting the firmware, if there is any power gone,

399
00:24:59,120 --> 00:25:02,758
we're going to roll back to the previous firmware or authentication failed.

400
00:25:02,774 --> 00:25:05,358
We're going to roll back. So we're going to have a rollback facility also in

401
00:25:05,364 --> 00:25:08,270
our firmware fully memory safe bootloader.

402
00:25:08,610 --> 00:25:12,074
Core bootloader implemented with safe passes and firmware update logic.

403
00:25:12,122 --> 00:25:15,358
So it's all about how we've designed. So we have a lot of,

404
00:25:15,444 --> 00:25:18,546
it's not only rust which is giving offering the safety, of course,

405
00:25:18,568 --> 00:25:21,938
it offers 70%. The rest 30% you have to offer it. So how are

406
00:25:21,944 --> 00:25:25,858
you making sure so you're going to use passes and firmware update logic.

407
00:25:26,034 --> 00:25:29,270
The power interruptible firmware updates along with the

408
00:25:29,340 --> 00:25:33,250
assurance of fallback ability. So power interruptible

409
00:25:33,330 --> 00:25:36,546
rollback is available. Switch to rust based signing

410
00:25:36,578 --> 00:25:40,598
tool. The key features firmware signing improve

411
00:25:40,694 --> 00:25:44,314
scalability and security. So we have written our own firmware signing tool which

412
00:25:44,352 --> 00:25:48,300
will help you to produce trusted firmware. And we are also using

413
00:25:49,630 --> 00:25:54,414
trusted authentication also there. So everything is written from

414
00:25:54,452 --> 00:25:57,738
scratch. Support for external flash devices.

415
00:25:57,914 --> 00:26:01,450
Apart from this we also support something called as trusted execution.

416
00:26:01,530 --> 00:26:06,594
We have also given support for Arm trust zone thing

417
00:26:06,632 --> 00:26:10,946
and which the pr is on the way. So we

418
00:26:11,048 --> 00:26:14,906
support various families of controllers like as I told NXP,

419
00:26:15,038 --> 00:26:16,070
STM,

420
00:26:17,610 --> 00:26:20,934
NRF, RPI and

421
00:26:20,972 --> 00:26:24,614
ESP, things like that. Also we are adding support and we

422
00:26:24,652 --> 00:26:27,640
also have the Cortex architectures like M Zero, M four, M seven,

423
00:26:28,090 --> 00:26:31,558
et cetera, like that. So every single architecture we're

424
00:26:31,574 --> 00:26:35,226
trying to cover it. If you want, feel free. If you have

425
00:26:35,328 --> 00:26:38,666
to add support for your controller board, also you can go from

426
00:26:38,688 --> 00:26:42,314
our rust board book and you can follow the steps and you can add to

427
00:26:42,352 --> 00:26:46,106
it. Then we have architecture. So in our architecture

428
00:26:46,138 --> 00:26:49,646
we have two main stages. One is called pre handover stage, other is called

429
00:26:49,668 --> 00:26:53,390
as post handover stage. The design is based on a simple idea.

430
00:26:53,460 --> 00:26:57,198
A bootloader handles only a bare essentials and offloads

431
00:26:57,214 --> 00:26:59,970
the rest of the system that is better suited for a job.

432
00:27:00,040 --> 00:27:03,234
So any bare essential requirements only

433
00:27:03,272 --> 00:27:07,218
will be in our bootloader rest. All things will be given to your

434
00:27:07,384 --> 00:27:10,998
controller. Okay, there are two main things here. One is the

435
00:27:11,084 --> 00:27:14,562
pre handover stage, other is a post handover stage. In the pre handover

436
00:27:14,626 --> 00:27:18,380
stage we're going to have the bootrom. So basically boot ROM is a

437
00:27:18,750 --> 00:27:22,250
guy which is a bootloader available on your rom

438
00:27:23,630 --> 00:27:27,126
which will give the handle to the bootloader. Some other intermediate

439
00:27:27,158 --> 00:27:30,406
stage bootloader executes and hands over to our rust boot.

440
00:27:30,518 --> 00:27:33,546
This is a stage where rust boot has full execution

441
00:27:33,578 --> 00:27:37,434
control. So pre handover stage is where the boot ROM

442
00:27:37,482 --> 00:27:41,134
give control to your rust bootloader and then you have your post

443
00:27:41,172 --> 00:27:44,926
handover stage where firmware has begun execution and has counted

444
00:27:44,958 --> 00:27:48,226
execution control. The firmware uses a couple of rust boot dependencies to

445
00:27:48,248 --> 00:27:55,170
trigger and confirm updates. So pre handover stage is when the

446
00:27:55,240 --> 00:27:58,470
boot ROM will give control to your rust boot. And rust boot has a complete

447
00:27:58,540 --> 00:28:03,586
control. And a post handover stage is where the bootloader

448
00:28:03,618 --> 00:28:07,080
will give control to your firmware. So this is how the flow works.

449
00:28:08,090 --> 00:28:11,862
Let's get into her pre handover stage. So pre handover stage,

450
00:28:11,926 --> 00:28:15,286
we have a couple of things here. So we have a rust boot core

451
00:28:15,318 --> 00:28:19,558
bootloader. It has an embedded public key. So embedded

452
00:28:19,574 --> 00:28:23,274
in software or in hardware, it depends on the architecture. So if you have a

453
00:28:23,472 --> 00:28:27,290
crypto accelerator similar, we can keep there. If you don't have any cryptographic

454
00:28:27,450 --> 00:28:31,086
hardware, then you can keep embedded in your software itself. There are two

455
00:28:31,108 --> 00:28:34,338
ways available. Yeah, so this is your

456
00:28:34,504 --> 00:28:37,794
hardware MCU or MPU. On that you have your

457
00:28:37,912 --> 00:28:41,886
ha layer, which is your hardware abstraction layer. So we're going to have only bare

458
00:28:41,918 --> 00:28:45,090
minimum things.

459
00:28:45,240 --> 00:28:49,154
We're going to extract it, maybe Uart, GPIo, flash and crypto

460
00:28:49,282 --> 00:28:52,886
peripherals. Okay. Only these things. We're going to make it

461
00:28:52,908 --> 00:28:56,614
available. We're going to make the code as small as possible. The next

462
00:28:56,652 --> 00:29:00,226
is rust crypto. So basically optional software

463
00:29:00,258 --> 00:29:03,850
based crypto library. So if you want, if you have a hardware available,

464
00:29:03,920 --> 00:29:07,014
go for it. If you don't have, you can use the rust crypto

465
00:29:07,062 --> 00:29:10,586
layer, which is a third party layer which is proven and

466
00:29:10,608 --> 00:29:13,150
we're going to take IoT we're going to take and we're going to use it

467
00:29:13,300 --> 00:29:16,634
which will help to your verification of your firmware.

468
00:29:16,762 --> 00:29:20,362
This is your, basically a pre handover stage where rust

469
00:29:20,426 --> 00:29:24,226
boot will have a complete control. Okay. Then we

470
00:29:24,248 --> 00:29:27,602
have our post handover stage where your

471
00:29:27,656 --> 00:29:30,894
application will have a control over it. So secure

472
00:29:30,942 --> 00:29:34,686
element hardware is here. Linux or bare metal. So bare metal

473
00:29:34,718 --> 00:29:38,098
firmware is here. You have your networking stack available here

474
00:29:38,184 --> 00:29:42,086
and there are some respite APIs. So now the

475
00:29:42,108 --> 00:29:46,134
control is gone to your firmware. But there are some APIs using which

476
00:29:46,172 --> 00:29:49,518
you can talk to your bootloader. Rust boot provides a tiny

477
00:29:49,554 --> 00:29:52,938
API to trigger and confirm updates. So if you have any

478
00:29:53,104 --> 00:29:57,046
update available, how do you confirm it? It's available in your Rust boot

479
00:29:57,078 --> 00:30:00,714
API. Then you can download your download and install your

480
00:30:00,752 --> 00:30:04,094
app and trigger update. This is basically in your pre

481
00:30:04,132 --> 00:30:07,534
handover stage you're going to have the rust boot complete control.

482
00:30:07,652 --> 00:30:10,800
In post handover stage you're going to have the firmware complete control.

483
00:30:12,930 --> 00:30:16,494
So basically signing means what exactly signing means.

484
00:30:16,692 --> 00:30:19,906
So you're going to have the firmware here and you're going to put two to

485
00:30:19,928 --> 00:30:23,870
six header over it. So how do you do it? So you have your image.

486
00:30:23,950 --> 00:30:27,634
So this is your two to six bed header. What you want

487
00:30:27,672 --> 00:30:30,866
to attach it to your firmware. So you have your firmware. You're going to attach

488
00:30:30,898 --> 00:30:34,358
a two to six byte header which will make a signed firmware. So how do

489
00:30:34,364 --> 00:30:38,770
you make a signed firmware? This is a technique, so you have your firmware.

490
00:30:38,930 --> 00:30:42,270
So magic and eos are basically header and footer. What are you

491
00:30:42,280 --> 00:30:45,242
going to add? Iot can be anything. So we are adding rust and boot here

492
00:30:45,376 --> 00:30:49,338
just like that. Then you have image size. How big is your image? Then you

493
00:30:49,344 --> 00:30:52,586
have a type length value. So for next piece of thing,

494
00:30:52,608 --> 00:30:55,270
what is the type, what is the length and what is the value? And we're

495
00:30:55,770 --> 00:30:58,574
going to have some padding, and we're going to have type length value again,

496
00:30:58,612 --> 00:31:01,818
which is type length value for a next field, which is a timestamp. The timestamp

497
00:31:01,834 --> 00:31:05,626
is nothing but of at what time you are compiling

498
00:31:05,658 --> 00:31:09,490
your code. Then you have something called type length value for image type.

499
00:31:09,640 --> 00:31:12,046
So what is the image type you are having? It is a boot image update

500
00:31:12,078 --> 00:31:15,630
image. So that information will be given here. Then again you have padding.

501
00:31:15,790 --> 00:31:19,634
Then again you have type length value. Okay, so now till

502
00:31:19,682 --> 00:31:23,526
here we have information of our firmware. So we're going to take all this

503
00:31:23,548 --> 00:31:26,614
information and we're going to produce a digest of it.

504
00:31:26,652 --> 00:31:28,698
You're going to hash it and you're going to get a digest of it,

505
00:31:28,704 --> 00:31:36,438
which is two to six bytes. And this we're

506
00:31:36,454 --> 00:31:39,894
going to have fixed shard digest,

507
00:31:39,942 --> 00:31:43,802
which is, which we're going to store here. Then we're going to have a TLB

508
00:31:43,866 --> 00:31:47,566
and whatever public key is embedded in your bootloader. We're going

509
00:31:47,588 --> 00:31:51,390
to take the digest of that also here. So we're going to do everything verification.

510
00:31:51,730 --> 00:31:55,118
And now we have can Elv. We're going to take

511
00:31:55,204 --> 00:31:58,466
everything and we're going to make a signature out of it. We're going to take

512
00:31:58,488 --> 00:32:01,906
can elliptic curve, and you're going to do

513
00:32:01,928 --> 00:32:05,086
some manual operation. You're going to get a unique number which is called a signature,

514
00:32:05,198 --> 00:32:08,406
and that will be stored here. And all this thing is called

515
00:32:08,428 --> 00:32:12,114
a header, which is responsible for a name of a signed firmware.

516
00:32:12,162 --> 00:32:15,750
We take this and attach to a firmware. We call it a signed firmware.

517
00:32:16,570 --> 00:32:20,226
Okay, so this is your signed firmware. This will be sitting

518
00:32:20,258 --> 00:32:23,706
in your boot partition. So we're going to take the signed firmware and

519
00:32:23,728 --> 00:32:27,354
we're going to put in our boot partition. Rush boot is a bootloader which

520
00:32:27,392 --> 00:32:30,806
will go and check every single byte of every single byte

521
00:32:30,838 --> 00:32:34,234
of your header. If it is verifies, then only

522
00:32:34,272 --> 00:32:37,386
the control will be passed here. Else the bootloader will be here. So rushboard

523
00:32:37,418 --> 00:32:40,542
will go and check every single thing. So this firmware will be sitting in your

524
00:32:40,596 --> 00:32:43,694
boot partition. This will go and check every single thing. If everything

525
00:32:43,732 --> 00:32:47,010
is verified. Okay then go ahead. The controller is going to boot firmware.

526
00:32:47,350 --> 00:32:50,942
And next if you have an update available. So now boot partition,

527
00:32:51,006 --> 00:32:55,326
boot firmware has a capacity to download

528
00:32:55,358 --> 00:32:58,610
a firmware. So we are offloading all the network stack in our boot partition.

529
00:32:58,690 --> 00:33:02,694
So now this boot partition will update the example.

530
00:33:02,732 --> 00:33:06,386
You have an update available. So it's going to download and keep the update

531
00:33:06,418 --> 00:33:09,698
here. Now the trigger again, the control is given back to

532
00:33:09,724 --> 00:33:13,334
bootloader. So bootloader will now go and verify

533
00:33:13,382 --> 00:33:17,238
the update partitions firmware. If it is verified and valid,

534
00:33:17,334 --> 00:33:20,934
then it's going to swap the firmware. The boot going to come here, the update

535
00:33:20,982 --> 00:33:24,334
going to come here and boot going to go here and start the boot form

536
00:33:24,372 --> 00:33:27,486
execution. This is how the cycle goes on. If you have update, swap it and

537
00:33:27,508 --> 00:33:30,842
get it. So bootloader's job is to verify

538
00:33:30,906 --> 00:33:34,366
the boot firmware. If any update is available, then boot firmware will

539
00:33:34,388 --> 00:33:37,806
give control again to bootloader and again so the cycle

540
00:33:37,838 --> 00:33:41,006
goes on. So boot firmware, update firmware. Then again, next update firmware,

541
00:33:41,038 --> 00:33:44,938
next update firmware. The swap foundation is used to just swapping your firmware.

542
00:33:45,134 --> 00:33:49,058
This is your flow basically. So let's

543
00:33:49,074 --> 00:33:52,818
go into flowchart. So whenever the bootloader

544
00:33:52,834 --> 00:33:56,102
start, right, it's going to open the partitions, okay.

545
00:33:56,156 --> 00:33:59,506
If it is initially it will be false,

546
00:33:59,538 --> 00:34:02,518
right? So Iot means it's only the boot partition.

547
00:34:02,614 --> 00:34:06,186
Then go and check for any update. If it

548
00:34:06,208 --> 00:34:09,562
is not there false, then go boot in new state. Then again

549
00:34:09,616 --> 00:34:13,006
check it, then verify the integrity. Or if it is

550
00:34:13,028 --> 00:34:16,286
false then panic it. Or if it is true then Abraham available.

551
00:34:16,388 --> 00:34:20,062
Then jump to rust boot open all partitions. Okay.

552
00:34:20,116 --> 00:34:23,274
Then verify authenticity integrity. Then if it is false,

553
00:34:23,322 --> 00:34:26,766
panic again. So this is basically a flow where actually the rust

554
00:34:26,798 --> 00:34:29,860
bootloader will follow some steps which is there here.

555
00:34:30,390 --> 00:34:33,586
So at the end if it is booting is there.

556
00:34:33,688 --> 00:34:37,134
So if there is any rollback available trigger

557
00:34:37,182 --> 00:34:41,154
here, there's a complete flow of your rust bootloader which will be followed

558
00:34:41,202 --> 00:34:44,198
in your complete process. So if you have an update available,

559
00:34:44,364 --> 00:34:47,926
go for update and come back. So we have some of a couple of

560
00:34:47,948 --> 00:34:51,546
flags here called as ff called new state and 70 called

561
00:34:51,568 --> 00:34:55,718
updating state and 10 called testing state and zero called SS

562
00:34:55,734 --> 00:34:59,718
state. So there is a flag what we'll be monitoring. So based on that flag,

563
00:34:59,814 --> 00:35:03,546
the bootloader will be verifying it. Okay, so if

564
00:35:03,568 --> 00:35:07,374
you have a boot, boot it. If you update, update it. If you have some

565
00:35:07,412 --> 00:35:11,534
other thing, just go and discard it. This is what the flow is about.

566
00:35:11,732 --> 00:35:15,570
So today's talk is mainly focused on rust boot

567
00:35:15,910 --> 00:35:19,298
and how do you sign the firmware and from where do you

568
00:35:19,304 --> 00:35:23,042
sign it and how the execution goes. So this is all about

569
00:35:23,096 --> 00:35:26,754
today's talk. So maybe next we can go ahead next

570
00:35:26,792 --> 00:35:29,810
talk, we can go ahead with the secure execution,

571
00:35:29,890 --> 00:35:32,806
secure process, and secure communication. Yeah.

572
00:35:32,908 --> 00:35:36,694
So thank you. So thank you for your time. So you can always reach

573
00:35:36,732 --> 00:35:40,134
out to me via my LinkedIn. You can scan this QR code and

574
00:35:40,172 --> 00:35:43,882
you can always reach out to me for anything. So this

575
00:35:43,936 --> 00:35:47,562
SBB is can open source project. As I told, it's available in

576
00:35:47,616 --> 00:35:50,742
my GitHub page. You can find my GitHub page in my LinkedIn

577
00:35:50,886 --> 00:35:54,450
or yeah, my GitHub name is just Yashwanth

578
00:35:54,470 --> 00:35:57,786
Singh M with no spaces. If you type this, you're going to get my GitHub

579
00:35:57,818 --> 00:36:01,178
page. So I work on multiple projects.

580
00:36:01,274 --> 00:36:05,034
I work on multiple projects. I work on a simple level language.

581
00:36:05,082 --> 00:36:08,160
I work on RTL coding, rust C.

582
00:36:08,770 --> 00:36:11,918
I mainly work on some low level coding stuff,

583
00:36:12,084 --> 00:36:16,006
but I also have experience in high

584
00:36:16,028 --> 00:36:20,278
level coding, but I have restricted myself for low level coding. So there

585
00:36:20,284 --> 00:36:23,830
are a couple of projects which I work in freedom.

586
00:36:24,970 --> 00:36:28,386
Everything is available as open source, may have different sensors. So rust

587
00:36:28,418 --> 00:36:31,750
is what we're exploring from past two years. I have a lot of projects available

588
00:36:31,820 --> 00:36:35,686
in C, so please do go and check it. This is my page

589
00:36:35,708 --> 00:36:37,940
and you can find my GitHub from that. Thank you.

