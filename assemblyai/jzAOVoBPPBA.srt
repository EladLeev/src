1
00:00:27,330 --> 00:00:31,014
Hey everyone, thanks for stopping by. Welcome to my talk

2
00:00:31,132 --> 00:00:35,170
go from Kubernetes Yaml engineer to software engineer

3
00:00:35,250 --> 00:00:39,350
with CDKs, the cloud development kit for Kubernetes.

4
00:00:40,010 --> 00:00:43,586
My name is Robert and I'm a senior solutions architect

5
00:00:43,618 --> 00:00:47,106
at AWS. Also, I hate

6
00:00:47,138 --> 00:00:50,606
Yaml. There's simply too much Yaml in my life.

7
00:00:50,708 --> 00:00:54,320
And I think you know why. The moment you're trying to

8
00:00:54,770 --> 00:00:58,894
design some infrastructure, define it, deploy it,

9
00:00:59,012 --> 00:01:02,738
you get in touch with Yaml. And there

10
00:01:02,744 --> 00:01:06,546
were quite a few times in my professional life where I

11
00:01:06,568 --> 00:01:10,002
could swear that yaml, it really

12
00:01:10,056 --> 00:01:14,274
stands for yelling at my laptop. So to

13
00:01:14,312 --> 00:01:18,338
get into that mood, let's engineer some yaml,

14
00:01:18,434 --> 00:01:22,120
shall we? Here we have a very simple application.

15
00:01:22,570 --> 00:01:26,214
It's an HTTP Echo server, and we

16
00:01:26,252 --> 00:01:30,090
want to set this up as a container on our Kubernetes cluster.

17
00:01:30,510 --> 00:01:33,994
And of course we're using YAml because that's like

18
00:01:34,032 --> 00:01:37,434
the native thing you're doing when

19
00:01:37,472 --> 00:01:40,650
you are creating Kubernetes manifests.

20
00:01:40,990 --> 00:01:44,842
So let's look at that. First of all, we need a deployment,

21
00:01:44,906 --> 00:01:48,446
right? And the deployment tells us what kind of

22
00:01:48,468 --> 00:01:52,266
container we want to run, what image it is, what kind of ports

23
00:01:52,298 --> 00:01:55,540
it has, and so on. Then we need a service.

24
00:01:55,910 --> 00:01:59,410
The service is our entry door to

25
00:01:59,480 --> 00:02:02,980
our small echo server. Finally,

26
00:02:03,350 --> 00:02:06,846
we also need an ingress because this thing

27
00:02:06,888 --> 00:02:10,454
is so great, we want to expose that to the whole world, right? So we

28
00:02:10,492 --> 00:02:13,800
define an ingress object and already

29
00:02:14,410 --> 00:02:18,182
we see all the problems that we have with Kubernetes

30
00:02:18,246 --> 00:02:22,218
Yaml. There's a lot of repetition. You have this

31
00:02:22,304 --> 00:02:25,898
app, Echo label everywhere, there's a

32
00:02:25,904 --> 00:02:29,322
lot of repeated values. This port

33
00:02:29,376 --> 00:02:33,274
value is everywhere. And the hardest

34
00:02:33,322 --> 00:02:37,006
thing of all, we need to name things and we have

35
00:02:37,028 --> 00:02:40,894
to make sure that we're using the same names at

36
00:02:40,932 --> 00:02:44,580
every place where it really counts, like here, for the name of the service.

37
00:02:45,270 --> 00:02:48,626
So we wrote 45 lines of

38
00:02:48,648 --> 00:02:52,594
Yaml here and we're already seeing some

39
00:02:52,632 --> 00:02:56,194
problems. When you're writing your Kubernetes

40
00:02:56,242 --> 00:02:59,670
manifests with YAml. With yamls,

41
00:03:01,450 --> 00:03:03,640
there's a lot of copy paste going on.

42
00:03:04,170 --> 00:03:08,214
Now that's often because to

43
00:03:08,252 --> 00:03:11,814
make a single change, actually, you often have to make multiple

44
00:03:11,862 --> 00:03:15,340
changes at different locations. So everything works together.

45
00:03:15,790 --> 00:03:19,354
Now, you do this either manually and hope for the best,

46
00:03:19,472 --> 00:03:23,354
or you have some special tooling for that, like a templating

47
00:03:23,482 --> 00:03:27,294
engine. All this setup makes it really hard to

48
00:03:27,332 --> 00:03:31,146
share. And maybe you need a special package manager

49
00:03:31,178 --> 00:03:34,818
to actually do that, like helm. All in all,

50
00:03:34,984 --> 00:03:38,626
that creates a very high cognitive load for

51
00:03:38,648 --> 00:03:42,834
engineers. I have to think about a lot of things and

52
00:03:42,872 --> 00:03:46,774
some of them are not really important for me.

53
00:03:46,972 --> 00:03:50,214
But is there a different way to do it? Let's look

54
00:03:50,252 --> 00:03:54,194
at the CDK's approach. And the CDK's approach

55
00:03:54,242 --> 00:03:57,702
is to write infrastructure as

56
00:03:57,756 --> 00:04:01,154
actual code, like in general purpose

57
00:04:01,202 --> 00:04:04,666
languages. What does CDK's do for

58
00:04:04,688 --> 00:04:08,666
me? Well, in a nutshell, it takes some code that

59
00:04:08,688 --> 00:04:12,486
we see on the left, then it has a nice CLI command

60
00:04:12,598 --> 00:04:16,894
SDK synth, and then it turns that code

61
00:04:17,092 --> 00:04:20,686
in all the yaml that I need to actually deploy the

62
00:04:20,708 --> 00:04:23,540
application. The great thing is,

63
00:04:24,310 --> 00:04:28,260
I didn't have to write that thing on the right,

64
00:04:28,790 --> 00:04:32,146
but rhymed. So what are cdks for?

65
00:04:32,168 --> 00:04:36,118
Kubernetes. So CDK for kubernetes, which by the

66
00:04:36,124 --> 00:04:39,110
way stands for cloud development kit,

67
00:04:39,450 --> 00:04:42,786
it's an open source multi language software and development

68
00:04:42,818 --> 00:04:45,480
framework. I guess you figured that out.

69
00:04:45,930 --> 00:04:50,390
And it helps you to model your Kubernetes resources as reusable

70
00:04:50,470 --> 00:04:54,314
components. So you write code and

71
00:04:54,352 --> 00:04:56,810
from that code you go to config.

72
00:04:57,150 --> 00:05:00,506
And then instead of doing the

73
00:05:00,528 --> 00:05:05,040
copy pastey thing that we did before, well now

74
00:05:05,490 --> 00:05:08,974
instead we can apply some engineering best

75
00:05:09,012 --> 00:05:11,280
practices, which is great.

76
00:05:11,890 --> 00:05:14,926
Also, Sydneykates can be run anywhere,

77
00:05:15,038 --> 00:05:18,690
so it's not really dependent on some special

78
00:05:18,760 --> 00:05:21,986
version of some Kubernetes cluster. You can run

79
00:05:22,008 --> 00:05:25,730
it locally and in the end it generates plain

80
00:05:25,810 --> 00:05:29,490
vanilla Kubernetes manifests in Yaml,

81
00:05:29,650 --> 00:05:33,910
and you can deploy them in any cluster, on any cloud or locally.

82
00:05:34,250 --> 00:05:37,474
And you can write all of that stuff in

83
00:05:37,532 --> 00:05:41,210
Python, in typescript, in Java or in go.

84
00:05:41,360 --> 00:05:44,858
So you can pick your favorite language. Now,

85
00:05:44,944 --> 00:05:48,330
CDKS is not the only CDK,

86
00:05:48,910 --> 00:05:52,734
actually there's a family of CDKs for

87
00:05:52,772 --> 00:05:56,190
you to use, and we see all of them here.

88
00:05:56,340 --> 00:05:59,646
So there is the AWS CDK, that was the

89
00:05:59,668 --> 00:06:03,234
first. And as the name implies, this is

90
00:06:03,272 --> 00:06:06,850
about defining infrastructure on AWS.

91
00:06:07,350 --> 00:06:10,660
Then we have cdks, that's what we're talking about today.

92
00:06:11,030 --> 00:06:15,810
And then there's also CDKTF. And CDKTf

93
00:06:16,410 --> 00:06:19,526
works the same way you write code, but the output of

94
00:06:19,548 --> 00:06:22,934
that is actually a terraform file that

95
00:06:22,972 --> 00:06:26,086
you can apply for all of those things.

96
00:06:26,268 --> 00:06:29,670
You need libraries. So ideally

97
00:06:29,750 --> 00:06:33,146
you find that other people had similar

98
00:06:33,248 --> 00:06:36,010
needs when they created their architectures.

99
00:06:36,430 --> 00:06:40,498
And in the best case, they created libraries

100
00:06:40,614 --> 00:06:44,494
out of those architectures. And you can

101
00:06:44,532 --> 00:06:48,062
find them on the construct hub, which is under

102
00:06:48,196 --> 00:06:52,298
constructs dev. So the construct hub

103
00:06:52,474 --> 00:06:57,010
is a place where you can find additional premade architectures

104
00:06:57,910 --> 00:07:01,090
and other things for the different CDKs

105
00:07:01,750 --> 00:07:05,330
case. Now, how does it feel like to actually

106
00:07:05,400 --> 00:07:07,330
work with cdKs?

107
00:07:08,310 --> 00:07:11,650
Let me walk you through a complete lifecycle

108
00:07:12,170 --> 00:07:15,800
first of all, we need to initialize our project.

109
00:07:16,170 --> 00:07:19,914
So you need to install the CDK CLI and

110
00:07:19,952 --> 00:07:23,850
you can do that via NPM. The next thing is to

111
00:07:23,920 --> 00:07:27,514
initialize your project. For that, CDKs has

112
00:07:27,552 --> 00:07:30,954
a handy command in it, and then you need to

113
00:07:30,992 --> 00:07:34,766
import all the Kubernetes API objects that you actually want

114
00:07:34,788 --> 00:07:38,574
to use when you model your infrastructure. And that's what you're doing with

115
00:07:38,612 --> 00:07:42,382
import. So let's have a closer look at those two

116
00:07:42,436 --> 00:07:46,206
commands. The init command is to scaffold

117
00:07:46,238 --> 00:07:49,826
a base project so you have everything ready to go and can

118
00:07:49,848 --> 00:07:53,634
just focus on writing your infrastructure. As you can see

119
00:07:53,672 --> 00:07:56,962
here, init takes an argument about what kind

120
00:07:57,016 --> 00:08:01,074
of language you want to write. So you can pick between typescript, go Java

121
00:08:01,122 --> 00:08:04,630
and Python, and that creates a new CDKs project.

122
00:08:04,700 --> 00:08:08,838
From a template on the right side you see how it basically

123
00:08:08,924 --> 00:08:12,666
looks like if you do typescript. And by the way, everything we see

124
00:08:12,688 --> 00:08:16,694
today will be typescript. Please don't judge me, I'm a typescript

125
00:08:16,742 --> 00:08:19,900
guy. Now the other command is import.

126
00:08:20,510 --> 00:08:24,000
And import is important, ha ha,

127
00:08:24,450 --> 00:08:28,270
because this command helps you to get all

128
00:08:28,340 --> 00:08:31,706
the Kubernetes resources or all the Kubernetes

129
00:08:31,818 --> 00:08:35,410
API objects as code.

130
00:08:35,480 --> 00:08:38,914
So basically as classes. So what we can see here

131
00:08:38,952 --> 00:08:42,926
is that one typical command is to say import Kates,

132
00:08:43,038 --> 00:08:47,674
add a version, and that basically tells cdkates

133
00:08:47,742 --> 00:08:51,682
to import a certain version of the Kubernetes

134
00:08:51,746 --> 00:08:55,126
base API. And then what you will get is what

135
00:08:55,148 --> 00:08:58,906
you see on the bottom right, which is a

136
00:08:58,928 --> 00:09:02,426
file, typescript file or whatever you're using,

137
00:09:02,608 --> 00:09:05,914
where all the API objects, the typical ones,

138
00:09:05,952 --> 00:09:08,570
you know like deployments, pods,

139
00:09:09,390 --> 00:09:12,446
ingress service, they are all defined here. So now

140
00:09:12,468 --> 00:09:16,158
you can use them in your code. This thing has a nice trick though.

141
00:09:16,244 --> 00:09:20,510
You can also give it custom resource definitions

142
00:09:21,010 --> 00:09:25,294
and it will turn those resources, those API

143
00:09:25,342 --> 00:09:28,740
objects into classes as well. So here's an example.

144
00:09:29,190 --> 00:09:32,594
If you're using the Jenkins operator, you can have

145
00:09:32,632 --> 00:09:35,542
the custom resource definition of Jenkins available.

146
00:09:35,676 --> 00:09:39,350
Suddenly you can deploy Jenkins instances

147
00:09:39,690 --> 00:09:43,446
with cdks, which is great. The next thing you have

148
00:09:43,468 --> 00:09:47,922
to do is to actually model your Kubernetes

149
00:09:47,986 --> 00:09:51,446
resources or manifest as code. So we have this bare bones

150
00:09:51,478 --> 00:09:55,814
project now, but we actually need to put in some kubernetes

151
00:09:55,862 --> 00:09:58,650
stuff for it to produce something.

152
00:09:58,800 --> 00:10:01,920
So this is what we're going to do right now.

153
00:10:02,530 --> 00:10:06,400
And the way it looks is roughly like this.

154
00:10:07,010 --> 00:10:10,286
The main code file that you typically have in a

155
00:10:10,308 --> 00:10:13,570
CDKs application is

156
00:10:13,640 --> 00:10:17,266
looking something like this. You have a

157
00:10:17,448 --> 00:10:20,770
main class, the chart class that you extend,

158
00:10:21,430 --> 00:10:25,300
and the chart class essentially is representing one

159
00:10:25,610 --> 00:10:29,302
kubernetes manifest. So this class essentially will turn

160
00:10:29,356 --> 00:10:34,214
into one YAML file in the end. And then within

161
00:10:34,412 --> 00:10:39,610
that chart you are adding your actual resources

162
00:10:40,190 --> 00:10:43,466
and you're doing that with classes, or we

163
00:10:43,488 --> 00:10:46,570
call them constructs in CDK speech.

164
00:10:46,990 --> 00:10:50,114
And here for example, you can see that we have added

165
00:10:50,182 --> 00:10:54,474
a deployment and that deployment has a configuration

166
00:10:54,522 --> 00:10:58,206
about containers. And once we did that we are

167
00:10:58,228 --> 00:11:01,406
almost good to go. The last thing we do have

168
00:11:01,428 --> 00:11:05,380
to do is instantiate an app class that's like

169
00:11:05,750 --> 00:11:10,146
the high level thing of

170
00:11:10,248 --> 00:11:13,586
CDK's apps where everything lives under. And then

171
00:11:13,608 --> 00:11:17,622
we instantiate the chart that we have written above and

172
00:11:17,676 --> 00:11:21,606
basically add it to that application and

173
00:11:21,628 --> 00:11:25,094
then we're basically done. The cool thing about that

174
00:11:25,132 --> 00:11:28,678
is that as we're writing

175
00:11:28,854 --> 00:11:31,020
our infrastructure in code now,

176
00:11:31,710 --> 00:11:34,822
suddenly we get all the benefits from writing

177
00:11:34,966 --> 00:11:36,650
general purpose languages.

178
00:11:38,590 --> 00:11:42,686
We get code completion for example. So we're starting to

179
00:11:42,708 --> 00:11:46,606
write objects or classes and we get

180
00:11:46,788 --> 00:11:49,934
some smart proposals on what we could actually put in there.

181
00:11:50,052 --> 00:11:52,750
So configuring things is much easier.

182
00:11:53,430 --> 00:11:56,958
Also we get inline documentation.

183
00:11:57,134 --> 00:12:01,122
So here we can see that the moment I pick the

184
00:12:01,256 --> 00:12:04,786
selector as a property I want

185
00:12:04,808 --> 00:12:08,754
to define it also shows me the documentation

186
00:12:08,802 --> 00:12:12,582
for that. And at this point you realize that

187
00:12:12,636 --> 00:12:16,226
yay, your config is typed now and that's

188
00:12:16,258 --> 00:12:20,582
awesome because there's less looking up of documentation

189
00:12:20,646 --> 00:12:24,474
online and more help in your ide to

190
00:12:24,512 --> 00:12:28,218
get stuff done. Now let's actually write that

191
00:12:28,304 --> 00:12:31,534
HTTP echo server with cdkates. How does

192
00:12:31,572 --> 00:12:35,338
that look like? Well, to some extent

193
00:12:35,514 --> 00:12:39,498
it still looks a lot like what we did in Yaml,

194
00:12:39,674 --> 00:12:42,946
but there are some benefits. So have a look at

195
00:12:42,968 --> 00:12:46,818
that. First of all, we are

196
00:12:46,904 --> 00:12:51,060
using the Kube deployment class over here,

197
00:12:51,830 --> 00:12:56,026
and this is essentially your vanilla deployment

198
00:12:56,158 --> 00:12:59,590
definition deployments object, API object,

199
00:12:59,660 --> 00:13:03,526
however you want to call it from the Kubernetes base API. And you

200
00:13:03,548 --> 00:13:08,026
see that we have to define a lot of the same things as

201
00:13:08,048 --> 00:13:11,834
you would with a yaml as we go along. Of course

202
00:13:11,952 --> 00:13:15,340
there's also a Kube service class

203
00:13:15,950 --> 00:13:19,514
and there's our ingress class. So so

204
00:13:19,552 --> 00:13:22,320
far so good, not too much new,

205
00:13:22,850 --> 00:13:26,766
but there are already some benefits we gain here.

206
00:13:26,948 --> 00:13:30,542
We are in a programming language now, so we can

207
00:13:30,596 --> 00:13:34,914
practice things like do not repeat yourself. So the port and

208
00:13:34,952 --> 00:13:38,094
the labels that we might need in different places,

209
00:13:38,222 --> 00:13:42,370
well now essentially we can pull them out

210
00:13:42,520 --> 00:13:46,550
and we can only define them once and reference them. So that already

211
00:13:46,620 --> 00:13:48,200
cleans it up a little bit.

212
00:13:49,690 --> 00:13:52,600
Also about the naming is hard things.

213
00:13:54,490 --> 00:13:58,246
This is easier now because we see here that this

214
00:13:58,348 --> 00:14:01,994
service class we actually didn't give the service a

215
00:14:02,032 --> 00:14:05,434
real name, it will just generate one for

216
00:14:05,472 --> 00:14:09,146
us. It will make sure that it's a unique name so

217
00:14:09,168 --> 00:14:13,342
there's no collision. And when we need the service name somewhere else,

218
00:14:13,476 --> 00:14:17,278
we can just reference it by saying, hey, service name,

219
00:14:17,364 --> 00:14:21,386
give me the name of that service. So naming

220
00:14:21,418 --> 00:14:25,342
is easier now because some of that cdks

221
00:14:25,406 --> 00:14:29,234
is doing for us. Now that we have defined our

222
00:14:29,272 --> 00:14:32,642
infrastructure. We can go ahead and

223
00:14:32,776 --> 00:14:36,806
create the Kubernetes manifests, the dreaded yaml out

224
00:14:36,828 --> 00:14:40,786
of that. And we do that with a synth command.

225
00:14:40,898 --> 00:14:45,090
So calling CDK synth will take those manifests

226
00:14:45,250 --> 00:14:48,374
and create them for all those charts

227
00:14:48,422 --> 00:14:52,330
in your app. And this is absolutely

228
00:14:52,480 --> 00:14:56,982
plain vanilla. Kubernetes Yaml manifests.

229
00:14:57,046 --> 00:14:59,580
There's nothing specific about them.

230
00:15:00,130 --> 00:15:03,694
You can put them in any other tool

231
00:15:03,812 --> 00:15:07,242
or process you have which works with Kubernetes

232
00:15:07,306 --> 00:15:11,146
manifests. It will work because there's

233
00:15:11,178 --> 00:15:15,140
essentially no trace that cdkates created that.

234
00:15:15,510 --> 00:15:19,394
And that's good because now we actually want to deploy that stuff.

235
00:15:19,432 --> 00:15:22,834
So it runs in kubernetes. And the way we can

236
00:15:22,872 --> 00:15:26,566
do that now really depends on how we are

237
00:15:26,748 --> 00:15:30,758
operating in our company. So in

238
00:15:30,764 --> 00:15:34,200
the simplest way, you can just call Kubectl, apply.

239
00:15:34,650 --> 00:15:38,850
The manifest will be found in the disk directory

240
00:15:39,010 --> 00:15:41,020
of the CDKS project.

241
00:15:41,710 --> 00:15:45,386
And you're good to go. And kubernetes will work on

242
00:15:45,408 --> 00:15:48,938
that manifest and deploy it. But of course,

243
00:15:49,104 --> 00:15:52,682
as I said before, you can use any tool that works with a Kubernetes

244
00:15:52,746 --> 00:15:56,734
manifest. So if you are one of those fancy kids

245
00:15:56,852 --> 00:16:01,274
who are already doing git ops. So you're checking in your manifests

246
00:16:01,322 --> 00:16:05,822
into git. And then your Kubernetes cluster is continuously

247
00:16:05,886 --> 00:16:09,938
pulling that and applying that. Well, you can do that too.

248
00:16:10,024 --> 00:16:13,262
Now that you have the output, you have that manifest.

249
00:16:13,406 --> 00:16:16,870
Just check it into your git. And your Gitops process

250
00:16:17,020 --> 00:16:20,518
should just work. Now we did all of that

251
00:16:20,684 --> 00:16:24,598
and we feel pretty good about it. So we're thinking,

252
00:16:24,684 --> 00:16:27,240
hey, what we just built,

253
00:16:27,630 --> 00:16:30,842
that's a great thing. Everybody should be able to use

254
00:16:30,896 --> 00:16:34,362
that. So let's package that as our own

255
00:16:34,416 --> 00:16:38,026
class, as our own construct and make

256
00:16:38,048 --> 00:16:41,950
it available to everyone else. How are we doing that?

257
00:16:42,100 --> 00:16:46,026
Well, because we are working in a normal programming

258
00:16:46,058 --> 00:16:49,850
language. We can also use normal package managers

259
00:16:50,010 --> 00:16:52,110
and package repositories,

260
00:16:52,690 --> 00:16:56,834
artifact repositories, or however you want to call them and

261
00:16:56,952 --> 00:17:00,690
put our code there to share it. And that of course, could be

262
00:17:00,760 --> 00:17:04,354
privately. So we're only sharing this internally at our company with

263
00:17:04,392 --> 00:17:08,034
our team. Or it could also be publicly as a software

264
00:17:08,082 --> 00:17:11,906
package. And then somewhere

265
00:17:12,018 --> 00:17:15,910
someone might find your cool construct.

266
00:17:16,650 --> 00:17:20,422
And part of this construct of your own construct

267
00:17:20,486 --> 00:17:23,866
library is this cool echo server deployment that

268
00:17:23,888 --> 00:17:28,358
we just saw. We just packaged that as its own class, its own construct,

269
00:17:28,534 --> 00:17:32,430
and then somebody else can use that and have an echo server and

270
00:17:32,500 --> 00:17:36,782
they had to do even less work on that because you

271
00:17:36,836 --> 00:17:40,720
obviously built in best practices and all that good stuff

272
00:17:41,090 --> 00:17:45,474
right? Now we saw that with

273
00:17:45,512 --> 00:17:50,162
a programming language we get some benefits for making

274
00:17:50,216 --> 00:17:53,134
the code easier, making the configuration clearer,

275
00:17:53,262 --> 00:17:56,662
removing repetition. But we

276
00:17:56,716 --> 00:18:00,134
haven't yet used one

277
00:18:00,172 --> 00:18:03,986
of the main benefits of programming, which is abstractions,

278
00:18:04,098 --> 00:18:07,206
so abstracting things to make

279
00:18:07,228 --> 00:18:11,770
it even easier and to remove undifferentiated stuff

280
00:18:11,920 --> 00:18:16,518
that we don't care about really. And this is where cdks

281
00:18:16,614 --> 00:18:20,766
plus comes in. And CDKs plus is

282
00:18:20,868 --> 00:18:23,870
another library that builds on top of cdks.

283
00:18:24,450 --> 00:18:27,934
And to explain what it really does, I have to

284
00:18:27,972 --> 00:18:31,726
talk about construct levels. Now as I

285
00:18:31,748 --> 00:18:35,410
explained, constructs are essentially those

286
00:18:35,480 --> 00:18:39,454
classes that represent the infrastructure,

287
00:18:39,582 --> 00:18:43,266
the Kubernetes API objects. Now we talk

288
00:18:43,288 --> 00:18:46,600
about levels, and levels means that

289
00:18:47,130 --> 00:18:51,270
these constructs can have different levels

290
00:18:51,690 --> 00:18:54,982
of sophistication. So the question is

291
00:18:55,036 --> 00:18:59,526
how much smarts, how much intelligence

292
00:18:59,638 --> 00:19:03,082
is built into them. The lowest level,

293
00:19:03,136 --> 00:19:06,490
level zero, is really just a representation of a

294
00:19:06,560 --> 00:19:09,894
bare bones Kubernetes API object with like common

295
00:19:09,952 --> 00:19:13,486
functionality because all API objects in Kubernetes kind of

296
00:19:13,508 --> 00:19:17,038
look the same. And that's really not super interesting

297
00:19:17,124 --> 00:19:20,542
for you because you don't think about

298
00:19:20,596 --> 00:19:24,082
that too much. The level after that,

299
00:19:24,216 --> 00:19:28,290
these are the actual Kubernetes

300
00:19:29,350 --> 00:19:32,866
API objects that you use like the deployment, the service,

301
00:19:32,968 --> 00:19:36,694
the pod and so on. And these are automatically generated for

302
00:19:36,732 --> 00:19:40,710
you based on the version of

303
00:19:40,860 --> 00:19:44,134
Kubernetes that you referenced when you did

304
00:19:44,172 --> 00:19:46,806
that CDK's import command for example.

305
00:19:46,908 --> 00:19:51,174
Or they are generated from that CID Yaml

306
00:19:51,222 --> 00:19:54,090
file that you gave to the import command.

307
00:19:54,750 --> 00:19:59,100
Now where it gets really interesting is on level two

308
00:19:59,470 --> 00:20:02,986
because these are handcrafted high level APIs,

309
00:20:03,098 --> 00:20:06,606
high level constructs that do a lot under the

310
00:20:06,628 --> 00:20:10,174
hood for you so that it's much easier to

311
00:20:10,212 --> 00:20:15,022
define your Kubernetes resources. And CDKs

312
00:20:15,166 --> 00:20:19,090
is the library that is bringing a lot of those high level

313
00:20:19,160 --> 00:20:23,058
constructs. So going back to

314
00:20:23,144 --> 00:20:27,110
our HTTP Echo server, we can now look at

315
00:20:27,180 --> 00:20:30,870
how we would define it with CDKs plus

316
00:20:31,020 --> 00:20:33,350
instead of just cdks.

317
00:20:34,010 --> 00:20:37,720
And this is all it takes, that's the whole thing.

318
00:20:38,270 --> 00:20:41,882
CDKs plus has a special

319
00:20:42,016 --> 00:20:45,482
deployment construct and this

320
00:20:45,536 --> 00:20:49,274
deployments construct does a lot of things for

321
00:20:49,312 --> 00:20:52,654
you under the hood. So you just have to define your

322
00:20:52,692 --> 00:20:57,360
container because obviously you have it. Couldn't know that and

323
00:20:58,370 --> 00:21:01,834
then if you actually want to expose

324
00:21:01,882 --> 00:21:06,098
that via an ingress, you don't even have to create the ingress class.

325
00:21:06,184 --> 00:21:09,540
You don't even have to instantiate the ingress class for that.

326
00:21:09,990 --> 00:21:13,694
There's a handy helper method called expose

327
00:21:13,742 --> 00:21:17,766
via ingress, and it does exactly what

328
00:21:17,788 --> 00:21:21,042
it says. Expose this deployments

329
00:21:21,106 --> 00:21:25,014
via ingress, give it a few parameters and

330
00:21:25,052 --> 00:21:29,034
you're basically done. So now, before, I think we had like

331
00:21:29,152 --> 00:21:32,330
40 ish lines of code, or Yaml.

332
00:21:32,910 --> 00:21:36,486
Now we're down to 13. And we're

333
00:21:36,518 --> 00:21:40,942
also getting some really cool benefits here, because this

334
00:21:40,996 --> 00:21:45,120
part here is speaking to us, right? It says,

335
00:21:45,890 --> 00:21:48,750
expose the deployment via ingress.

336
00:21:49,330 --> 00:21:52,218
We understand the intent of that.

337
00:21:52,404 --> 00:21:55,918
It's not just a bag of objects

338
00:21:56,094 --> 00:22:00,674
that somehow relate, because there's the same port number

339
00:22:00,792 --> 00:22:03,220
and the same service name or whatever.

340
00:22:04,310 --> 00:22:07,974
We can see a little story here. We know what the engineer wanted

341
00:22:08,012 --> 00:22:12,134
to do. So we're starting to write for humans and not for

342
00:22:12,172 --> 00:22:15,922
machines. And that's an aspect of CDK

343
00:22:15,986 --> 00:22:18,300
in general that I find very interesting,

344
00:22:19,390 --> 00:22:22,874
because it has a lot to do with the

345
00:22:22,912 --> 00:22:27,162
idea of clean code, right? That's a concept that was

346
00:22:27,216 --> 00:22:30,746
made popular in the book of the same name. And the

347
00:22:30,768 --> 00:22:34,094
idea of clean code is that you write code that is

348
00:22:34,212 --> 00:22:37,790
easy to be understood by everyone in the team.

349
00:22:37,940 --> 00:22:41,870
It can be enhanced by any developer, even by new developers,

350
00:22:42,390 --> 00:22:46,530
and to make things, if things are understandable,

351
00:22:47,270 --> 00:22:50,946
it makes it easy to maintain that code, improve that code and so

352
00:22:50,968 --> 00:22:54,414
on. So with those speaking functions,

353
00:22:54,462 --> 00:22:58,326
with those high level abstractions, we make

354
00:22:58,348 --> 00:23:02,326
it easier to understand the code, we make it easier to understand

355
00:23:02,508 --> 00:23:05,880
the infrastructure we are defining with that code.

356
00:23:06,330 --> 00:23:10,186
To give you an example, going back to the

357
00:23:10,288 --> 00:23:13,578
deployment definition we just did

358
00:23:13,744 --> 00:23:16,986
with cdkates, we can

359
00:23:17,008 --> 00:23:20,374
read that story out of that text, right? We said,

360
00:23:20,512 --> 00:23:24,794
hey, create a deployment and then call expose via

361
00:23:24,842 --> 00:23:28,558
ingress. That's the story. As a human,

362
00:23:28,644 --> 00:23:31,694
that's easier to read. Now,

363
00:23:31,812 --> 00:23:34,100
what happens in the background, of course,

364
00:23:34,950 --> 00:23:36,740
is a lot of stuff, right?

365
00:23:37,590 --> 00:23:41,214
So in the Kubernetes API

366
00:23:41,262 --> 00:23:44,878
object world behind that one class,

367
00:23:44,984 --> 00:23:48,978
that one construct we created, there's a deployment

368
00:23:49,154 --> 00:23:51,590
definition that has been created.

369
00:23:52,090 --> 00:23:56,342
That deployment somehow is

370
00:23:56,476 --> 00:24:00,394
using this port because we

371
00:24:00,592 --> 00:24:04,410
need to define it for the container. That deployment

372
00:24:05,150 --> 00:24:08,694
needs to basically know which ports belong to it. So there's

373
00:24:08,822 --> 00:24:12,118
this label that must match with the pods. We don't

374
00:24:12,134 --> 00:24:15,374
see any of that here at all. This is all hidden from

375
00:24:15,412 --> 00:24:18,766
us. When you have defined this once, you know what I

376
00:24:18,788 --> 00:24:22,334
mean? Because this is like doing it the same way every time. You can only

377
00:24:22,372 --> 00:24:25,360
mess it up. Basically, it doesn't get better.

378
00:24:26,450 --> 00:24:29,730
And CDKS is hiding that relationship

379
00:24:29,880 --> 00:24:33,620
completely from you. It just manages it for you so that it works,

380
00:24:34,790 --> 00:24:37,926
we also need to create that ingress now. We don't need to

381
00:24:37,948 --> 00:24:44,002
create it by hand, we're just calling this expose via ingress method

382
00:24:44,066 --> 00:24:48,058
here. So that's done for us. And again, the ingress is

383
00:24:48,144 --> 00:24:50,860
somehow needing that port.

384
00:24:51,550 --> 00:24:55,830
And the ingress has a service, right? If you remember, the ingress

385
00:24:55,910 --> 00:24:59,690
points to a service object and the service object also

386
00:24:59,760 --> 00:25:03,578
kind of needs the port. And it's pointing to the same labels

387
00:25:03,674 --> 00:25:07,310
because it needs to know which ports belong to the service object.

388
00:25:07,380 --> 00:25:10,958
And now you basically know why.

389
00:25:11,124 --> 00:25:14,526
Maybe you need a graph database to understand what's

390
00:25:14,558 --> 00:25:18,354
happening in kubernetes, but the gist here is

391
00:25:18,392 --> 00:25:21,570
that cdks is doing all of that

392
00:25:21,640 --> 00:25:25,302
under the hood for you. And instead

393
00:25:25,356 --> 00:25:29,442
of reading that because that's essentially

394
00:25:29,586 --> 00:25:33,254
the yaml, you read that story over here

395
00:25:33,372 --> 00:25:37,078
in code, and it's much easier for someone to review

396
00:25:37,164 --> 00:25:41,020
that and understand what the engineer intended to do,

397
00:25:41,550 --> 00:25:45,434
which is really cool. And you can take this further and

398
00:25:45,472 --> 00:25:49,274
of course build your own constructs, put together whatever you

399
00:25:49,312 --> 00:25:52,906
want pre configured, just expose a few values

400
00:25:52,938 --> 00:25:56,282
that are really needed and everything else is happening under the hood.

401
00:25:56,346 --> 00:26:00,078
You can build in your security best practices from your security

402
00:26:00,164 --> 00:26:04,114
guys. So your CISO is happy you can put

403
00:26:04,152 --> 00:26:08,258
in anything and then just release a very cool

404
00:26:08,344 --> 00:26:12,254
high level, super smart construct that makes it easier to deploy

405
00:26:12,302 --> 00:26:15,458
stuff on kubernetes. So to sum

406
00:26:15,474 --> 00:26:19,670
it up, why should I code my infrastructure?

407
00:26:20,090 --> 00:26:23,794
Well, the reason is that the moment you're using general purpose

408
00:26:23,842 --> 00:26:27,346
languages, you can employ software engineering

409
00:26:27,378 --> 00:26:30,826
best practices like clean code, do not

410
00:26:30,848 --> 00:26:34,394
repeat yourself, and so on. You can also

411
00:26:34,592 --> 00:26:38,074
use a familiar programming language. So instead of

412
00:26:38,112 --> 00:26:41,958
working with some form of configuration language that

413
00:26:42,064 --> 00:26:45,262
as time progressed became more and more like a

414
00:26:45,316 --> 00:26:48,720
real programming language because it had to do so many things,

415
00:26:49,250 --> 00:26:52,946
you just say, well, just use a normal programming languages that

416
00:26:52,968 --> 00:26:56,562
I know, like Python or typescript. The moment

417
00:26:56,616 --> 00:27:00,402
you're using a programming languages, you get great

418
00:27:00,456 --> 00:27:05,138
ide in tool support, because that's what these

419
00:27:05,224 --> 00:27:09,266
ides do, right? They're working best with programming languages,

420
00:27:09,378 --> 00:27:12,470
even out of the box without any cool add ons.

421
00:27:13,450 --> 00:27:16,322
And then you can build those powerful abstractions,

422
00:27:16,386 --> 00:27:19,690
or you can use those powerful abstractions from CDks.

423
00:27:20,350 --> 00:27:24,294
And as mentioned before, you can use that for your own developer

424
00:27:24,342 --> 00:27:27,734
platform. You can extend the existing

425
00:27:27,782 --> 00:27:31,066
abstractions or you can build your own, and then you can

426
00:27:31,088 --> 00:27:34,654
share them internally or externally and make it easier for people to

427
00:27:34,692 --> 00:27:38,362
use kubernetes. Now there might be a few reasons

428
00:27:38,426 --> 00:27:42,618
why you do not want to use cdks and programming languages.

429
00:27:42,794 --> 00:27:46,690
And one of the reasons might be that you're saying, hey, but I'm totally fine

430
00:27:46,760 --> 00:27:50,034
with my existing tools and I like

431
00:27:50,072 --> 00:27:54,020
my mountain of Yaml, it's a great friend for me.

432
00:27:55,370 --> 00:27:58,594
One thing I can say here is that you can actually mix

433
00:27:58,642 --> 00:28:02,658
and match. So with cdks

434
00:28:02,754 --> 00:28:06,866
you can also import existing kubernetes manifests

435
00:28:06,898 --> 00:28:11,238
in YaML and then sprinkle some new deployments,

436
00:28:11,334 --> 00:28:15,418
some new API objects in with

437
00:28:15,584 --> 00:28:19,386
cdks. So it's not an all or nothing thing.

438
00:28:19,488 --> 00:28:23,514
If you have a new smaller project that you need to deploy in Kubernetes,

439
00:28:23,642 --> 00:28:27,102
you could try out cdks now. You might also

440
00:28:27,156 --> 00:28:30,640
just don't like coding, which is fine because

441
00:28:31,010 --> 00:28:34,340
the coding is great until it's not right. Things break.

442
00:28:35,510 --> 00:28:39,454
You have a dynamic processing

443
00:28:39,502 --> 00:28:43,762
flow control flow, so things

444
00:28:43,816 --> 00:28:47,510
can get complicated. Typically I don't see that

445
00:28:47,580 --> 00:28:51,186
with CDK. Typically the code is pretty readable because it's

446
00:28:51,218 --> 00:28:54,722
just do this resource, this resource, this resource.

447
00:28:54,786 --> 00:28:58,714
So it's just reading it from top to bottom.

448
00:28:58,832 --> 00:29:00,540
So that's fine. But yeah,

449
00:29:01,950 --> 00:29:05,846
it can have some downsides. And if you're the author

450
00:29:05,878 --> 00:29:09,206
of a helm chart, meaning you are building helm

451
00:29:09,238 --> 00:29:13,100
charts, you are creating them. Then also

452
00:29:13,630 --> 00:29:17,200
cdks is currently not helping you so much

453
00:29:18,210 --> 00:29:21,562
because it cannot create helm charts.

454
00:29:21,706 --> 00:29:25,540
You can deploy helps charts with it, that's absolutely no problem.

455
00:29:26,710 --> 00:29:30,034
If you're referencing a helm chart and say I want

456
00:29:30,072 --> 00:29:33,470
this deployments with these parameters, you can do that in cdks,

457
00:29:33,630 --> 00:29:37,654
but it's not a helm chart creator for

458
00:29:37,692 --> 00:29:42,694
that case. Not yet at least. So I

459
00:29:42,732 --> 00:29:46,294
hope you got an idea on why cdks can

460
00:29:46,332 --> 00:29:49,834
be really great to now

461
00:29:49,872 --> 00:29:53,434
do code instead of configuration to

462
00:29:53,472 --> 00:29:57,274
manage Kubernetes or manage at least

463
00:29:57,312 --> 00:30:00,826
Kubernetes deployments and other objects. Here are

464
00:30:00,848 --> 00:30:04,522
some resources for you on how you can get started with cdks.

465
00:30:04,666 --> 00:30:08,510
So there's of course the project website CDks IO.

466
00:30:08,930 --> 00:30:12,670
We already talked about the constructs hub. So there you find

467
00:30:12,820 --> 00:30:16,110
community shared constructs that already

468
00:30:16,180 --> 00:30:19,962
do things like building complete infrastructures,

469
00:30:20,106 --> 00:30:23,460
pre defining things for you. So that's really cool.

470
00:30:23,830 --> 00:30:26,280
And then you can also interact with the community.

471
00:30:27,130 --> 00:30:30,642
So cdks is a CNCF sandbox

472
00:30:30,706 --> 00:30:34,146
project and there's a slack under CDK

473
00:30:34,258 --> 00:30:38,194
dev. And also finally there's the CDK

474
00:30:38,242 --> 00:30:41,850
day, which is a completely community driven

475
00:30:42,190 --> 00:30:45,706
event for the whole CDK ecosystem that's happening

476
00:30:45,888 --> 00:30:50,178
once a year, but you can always get the recordings

477
00:30:50,374 --> 00:30:54,094
and there all the cdks and also other cool

478
00:30:54,132 --> 00:30:58,078
new tools are shown from the community. And what fancy stuff

479
00:30:58,164 --> 00:31:01,374
you can do with them. So definitely check

480
00:31:01,412 --> 00:31:05,410
that out. Now if you liked that presentation,

481
00:31:06,870 --> 00:31:10,594
I would ask you to kindly give me some

482
00:31:10,632 --> 00:31:14,306
feedback on that session and also

483
00:31:14,488 --> 00:31:18,562
give us some feedback on some potential new cdks

484
00:31:18,626 --> 00:31:22,514
features. So if you follow the link under the QR

485
00:31:22,562 --> 00:31:25,846
code you'll find a small survey about

486
00:31:25,868 --> 00:31:29,706
the session. But on the second page we're asking you

487
00:31:29,888 --> 00:31:33,978
something about how you are using kubernetes and

488
00:31:34,064 --> 00:31:37,434
if you would like or if you are interested in

489
00:31:37,472 --> 00:31:41,420
some new cdks features that are coming up in the near future.

490
00:31:41,730 --> 00:31:45,338
And to spoil it here. It has a lot to do with helm

491
00:31:45,434 --> 00:31:48,174
so it would be super amazing,

492
00:31:48,292 --> 00:31:52,282
especially if you are a helm user. So chart creator

493
00:31:52,346 --> 00:31:55,794
or chart user or both if you would take the

494
00:31:55,832 --> 00:31:59,282
survey because that will help us to figure out how we can make

495
00:31:59,336 --> 00:32:02,980
cdks better for the helm world.

496
00:32:03,750 --> 00:32:07,366
So that's it from me. Thanks a

497
00:32:07,388 --> 00:32:11,014
lot for watching that talk. If you have any questions

498
00:32:11,132 --> 00:32:14,514
you can find me on Twitter or on LinkedIn.

499
00:32:14,642 --> 00:32:17,522
And if you ever try out CDK's,

500
00:32:17,586 --> 00:32:21,446
which I hope you will do after this talk, I would love to

501
00:32:21,468 --> 00:32:24,978
hear about it and get your feedback

502
00:32:25,074 --> 00:32:28,374
on the user experience. So have

503
00:32:28,412 --> 00:32:32,554
a good time and and yeah, start slaying

504
00:32:32,602 --> 00:32:34,940
that Yaml dragon. See you then.

