1
00:00:25,330 --> 00:00:29,334
You. Hello. Thank you for being here

2
00:00:29,532 --> 00:00:33,574
today. These I will talk about Vuejs form validation with veevalidate V

3
00:00:33,612 --> 00:00:37,382
four, so let's get to it. First, a little bit about

4
00:00:37,436 --> 00:00:41,554
me I am Abdelrahman Awad frontend engineer at Octopods.

5
00:00:41,682 --> 00:00:46,098
I created and maintained Vvalidate for vjs since 2016.

6
00:00:46,194 --> 00:00:49,846
I write about JavaScript typescript vuejs on

7
00:00:49,868 --> 00:00:53,102
my blog, locerit.com, so check it out

8
00:00:53,156 --> 00:00:56,510
if you are interested in that type of content. Also,

9
00:00:56,580 --> 00:00:59,390
you can give me a follow at logarithm on Twitter.

10
00:01:00,770 --> 00:01:04,242
So forms are hard, but what makes

11
00:01:04,296 --> 00:01:07,570
these so there are various pain points

12
00:01:07,640 --> 00:01:11,902
when it comes to forms manifesting as friction

13
00:01:12,046 --> 00:01:15,662
in a lot of areas, and I have identified

14
00:01:15,726 --> 00:01:18,790
the most painful areas to be these ones,

15
00:01:18,860 --> 00:01:22,294
or at least the most common ones that we run into.

16
00:01:22,492 --> 00:01:25,730
And this is also as seen in other libraries.

17
00:01:25,890 --> 00:01:29,740
So most libraries try to address these issues

18
00:01:31,150 --> 00:01:34,554
for the developer. So let's start

19
00:01:34,592 --> 00:01:38,234
with value tracking. So value tracking is really complicated because

20
00:01:38,352 --> 00:01:41,962
it depends on how you express and declare your forms.

21
00:01:42,026 --> 00:01:45,694
If you are using native HTML elements and you don't really

22
00:01:45,732 --> 00:01:48,974
have Javascript going on here, then value tracking is done

23
00:01:49,012 --> 00:01:52,814
automatically for you because that's native HTML behavior when

24
00:01:52,852 --> 00:01:56,402
it submits the form to some back end server using

25
00:01:56,456 --> 00:02:01,102
full page reloads. But if you have Javascript forms

26
00:02:01,166 --> 00:02:04,866
then it becomes a lot more involved because you need to have two

27
00:02:04,888 --> 00:02:08,534
way bindings between your inputs and your data models in

28
00:02:08,572 --> 00:02:10,790
memory and keep them synced.

29
00:02:11,370 --> 00:02:15,122
This can be tricky and there is a lot of caveats

30
00:02:15,186 --> 00:02:18,854
here. For example, the field types like checkboxes,

31
00:02:18,902 --> 00:02:22,940
radio buttons and file inputs, so each

32
00:02:23,550 --> 00:02:26,986
really file type really has its own quirks that you need

33
00:02:27,008 --> 00:02:30,830
to makes into account when tracking your form values.

34
00:02:32,210 --> 00:02:35,610
The other pinpoint is validation error messages.

35
00:02:35,770 --> 00:02:39,166
So with validation it can be really simple or it can

36
00:02:39,188 --> 00:02:42,574
be really complicated again based on your needs. For example,

37
00:02:42,612 --> 00:02:46,382
you can have synchronous validation, or you can have a pipeline of asynchronous

38
00:02:46,446 --> 00:02:49,186
validations building on top of each other,

39
00:02:49,368 --> 00:02:52,994
so managing this can be really difficult.

40
00:02:53,192 --> 00:02:56,306
Also the way and the style of you expressing

41
00:02:56,338 --> 00:03:00,006
your validation intent. Is it global validations that

42
00:03:00,028 --> 00:03:04,162
you call upon using some kind of friendly string formats

43
00:03:04,306 --> 00:03:07,898
like Laravel or other frameworks? Or is

44
00:03:07,904 --> 00:03:11,734
it explicit functions, explicit Javascript functions

45
00:03:11,782 --> 00:03:15,210
that you import and pass around explicitly to make everything

46
00:03:15,280 --> 00:03:18,554
clear? So it really depends on your

47
00:03:18,592 --> 00:03:22,606
use case. Also error messages it can be really hard to

48
00:03:22,788 --> 00:03:26,254
normalize the generation of error messages because

49
00:03:26,452 --> 00:03:29,614
error messages are complicated and

50
00:03:29,652 --> 00:03:32,958
it begins how you phrase them. So if you

51
00:03:33,044 --> 00:03:37,314
include the field name in the error message like this field or these

52
00:03:37,432 --> 00:03:41,266
email field is required, or this name field is required. You have

53
00:03:41,288 --> 00:03:44,974
an issue here because you have to include the field name in the

54
00:03:45,032 --> 00:03:46,200
generated message.

55
00:03:47,930 --> 00:03:51,346
But if you avoid that and use simpler

56
00:03:51,378 --> 00:03:55,142
messages like this field is required, this field must be a valid email.

57
00:03:55,276 --> 00:03:59,334
Then you escape this. But there is localization,

58
00:03:59,462 --> 00:04:03,226
and not all of languages agree that you can be

59
00:04:03,328 --> 00:04:07,706
neutral about fields. So it

60
00:04:07,728 --> 00:04:11,486
is really complicated. There is also the

61
00:04:11,508 --> 00:04:15,194
UI and UX aspect, and forms

62
00:04:15,242 --> 00:04:18,154
are tedious. Users hate filling out forms,

63
00:04:18,202 --> 00:04:21,966
and you as a form filler, really you hate this, and as a

64
00:04:21,988 --> 00:04:26,226
developer, you probably hate them as well. So the

65
00:04:26,248 --> 00:04:30,226
issue with forms here is if they are

66
00:04:30,328 --> 00:04:34,018
repetitive and you might be asking a lot for information

67
00:04:34,104 --> 00:04:37,778
here. So if the experience is really poor

68
00:04:37,874 --> 00:04:41,314
or really frustrating, the user won't bother

69
00:04:41,362 --> 00:04:45,494
and you will be testing their patience. So depending on how much

70
00:04:45,612 --> 00:04:49,266
fun the interaction with your form is, the user

71
00:04:49,298 --> 00:04:52,874
may choose to fill out the form or lose patience and maybe

72
00:04:52,912 --> 00:04:56,380
decide it's not worth it to go through this.

73
00:04:57,390 --> 00:05:00,446
And this defeats the whole purpose of having a form, right?

74
00:05:00,548 --> 00:05:03,274
You only have it to collect some values.

75
00:05:03,322 --> 00:05:07,390
And yeah, there is also organization.

76
00:05:08,690 --> 00:05:12,586
So let's say you are building a really complex admin dashboard

77
00:05:12,618 --> 00:05:16,386
application, and this admin dashboard application has

78
00:05:16,408 --> 00:05:20,110
a lot of cruds and a lot of crud forms and crud pages.

79
00:05:20,190 --> 00:05:22,850
And these forms usually exist in two modes,

80
00:05:23,270 --> 00:05:26,658
create and edit. So in that case,

81
00:05:26,744 --> 00:05:30,514
how are you going to organize all these validation rules, all of these fields,

82
00:05:30,562 --> 00:05:34,230
all of these forms and messages? That's a lot of

83
00:05:34,300 --> 00:05:37,858
stuff to organize. So the validation library should give you

84
00:05:37,884 --> 00:05:41,562
at least some kind of units of organization that allow you to do

85
00:05:41,616 --> 00:05:45,900
something like that. There is also the debugging and developer experience.

86
00:05:46,910 --> 00:05:51,102
Most validation libraries don't really have any

87
00:05:51,156 --> 00:05:55,962
debugging tools, and this can be really frustrating

88
00:05:56,026 --> 00:06:00,206
and can send you in a wild goose chase when

89
00:06:00,228 --> 00:06:03,746
you have this form that isn't submitting and you can't really figure out why

90
00:06:03,768 --> 00:06:07,406
it's not submitting. So having the binding

91
00:06:07,438 --> 00:06:09,220
tools is really beneficial here.

92
00:06:10,390 --> 00:06:14,034
So veevalidate tries to address some of these issues,

93
00:06:14,152 --> 00:06:17,542
but let's talk more about it first. Vvalidate is currently

94
00:06:17,596 --> 00:06:20,918
these most popular VueJs forms validation library at

95
00:06:21,004 --> 00:06:25,026
around 1.4 million downloads per month and 8.6k stars

96
00:06:25,058 --> 00:06:29,034
on GitHub. So with that out of the way, let's talk about

97
00:06:29,072 --> 00:06:32,262
the goals. The goal of veevalidate

98
00:06:32,326 --> 00:06:36,540
V to solve these pain points and

99
00:06:37,150 --> 00:06:40,538
using the word solve can be a

100
00:06:40,544 --> 00:06:44,474
lot of claim here. So at least it will reduce

101
00:06:44,522 --> 00:06:47,920
the friction that you encounter with these pain points,

102
00:06:48,610 --> 00:06:52,414
but it does a really good job at reducing that friction, and we'll see

103
00:06:52,452 --> 00:06:56,100
a lot of examples on each of these points. Also,

104
00:06:56,550 --> 00:07:00,542
it tries to offer a progressive API to match the Vuejs ideology.

105
00:07:00,606 --> 00:07:04,386
So Vuejs has this ideology or mantra of it being

106
00:07:04,568 --> 00:07:08,086
the progressive JavaScript framework, and it really does a good job

107
00:07:08,108 --> 00:07:12,114
of doing so. So what does it mean? It means vuejs

108
00:07:12,242 --> 00:07:15,734
caters to those who are using it

109
00:07:15,772 --> 00:07:20,730
as an enhancement layer for their application.

110
00:07:20,880 --> 00:07:24,406
So for those who just want to sprinkle

111
00:07:24,518 --> 00:07:27,946
some Javascript into their application to

112
00:07:27,968 --> 00:07:32,302
make some widgets interactive and some aspects of their

113
00:07:32,436 --> 00:07:36,110
page interactive without having to do everything in JavaScript,

114
00:07:38,130 --> 00:07:42,606
Vuejs really offers a really good job for

115
00:07:42,708 --> 00:07:46,754
that use case because you can import it from the CDN and integrate it

116
00:07:46,872 --> 00:07:50,354
right into your application with really

117
00:07:50,392 --> 00:07:53,714
minimum effort and really minimum setup. You don't really have to set

118
00:07:53,752 --> 00:07:57,382
up webpack or a really complicated front end stuff to get it working.

119
00:07:57,516 --> 00:08:00,742
On the other hand, you have these who want to build

120
00:08:00,796 --> 00:08:05,106
a fully working single page application that uses Vuejs

121
00:08:05,138 --> 00:08:10,774
for routing, state management and rendering. So everything for

122
00:08:10,812 --> 00:08:14,602
these developers scales well to

123
00:08:14,656 --> 00:08:17,180
match their needs.

124
00:08:17,710 --> 00:08:21,354
So yeah, veevalidate v

125
00:08:21,402 --> 00:08:25,182
tries to follow that guideline to be really easy

126
00:08:25,236 --> 00:08:28,734
to integrate with minimum effort, almost like

127
00:08:28,772 --> 00:08:32,266
a search and replace manner, but also catering

128
00:08:32,298 --> 00:08:35,906
for those who want to do more and want to do a lot of

129
00:08:36,008 --> 00:08:39,730
and get a lot of benefit out of the tool

130
00:08:39,800 --> 00:08:43,540
that they are using. There is also the

131
00:08:43,990 --> 00:08:47,702
composition first design approach. The composition API is

132
00:08:47,756 --> 00:08:52,306
similar to the react hooks API, which allows

133
00:08:52,338 --> 00:08:56,214
you as a developer to integrate third party logic into

134
00:08:56,252 --> 00:08:59,574
your own components. Also first party logic of course,

135
00:08:59,612 --> 00:09:03,286
but it allows you to integrate some kind of logic into your

136
00:09:03,308 --> 00:09:06,470
own components in a really reusable manner.

137
00:09:07,130 --> 00:09:11,966
So vvalid doubles down on that and you will see in

138
00:09:11,988 --> 00:09:15,950
a few minutes how it does. So first

139
00:09:16,020 --> 00:09:19,246
let's talk about the building blocks. So this is the

140
00:09:19,268 --> 00:09:24,042
most basic form you have. You have a form element and an input element.

141
00:09:24,186 --> 00:09:27,614
So let's say we want to convert this form to a veevalidate v

142
00:09:27,662 --> 00:09:31,154
form. All you have to do is remove the form element and use the form

143
00:09:31,192 --> 00:09:35,070
components. Notice the difference is the uppercase forms

144
00:09:35,240 --> 00:09:38,742
component. The first letter is uppercase and

145
00:09:38,876 --> 00:09:42,374
the input element was removed and we added the field

146
00:09:42,492 --> 00:09:46,006
component instead. And that's it.

147
00:09:46,108 --> 00:09:48,890
So it's almost assertion replace API.

148
00:09:50,030 --> 00:09:53,962
But of course there are a lot more to it than that.

149
00:09:54,016 --> 00:09:57,926
But this is the basic way to get veevalidate

150
00:09:57,958 --> 00:10:02,042
into your project and having the same exact render output

151
00:10:02,186 --> 00:10:06,670
as the previous native forum.

152
00:10:07,650 --> 00:10:11,482
So let's talk about the first pain point. Value tracking

153
00:10:11,626 --> 00:10:15,474
this typical forum usually have this three sections inside it

154
00:10:15,512 --> 00:10:18,942
has state binding, state declaration and value retrieval.

155
00:10:19,086 --> 00:10:23,410
So the state binding section contains the

156
00:10:23,560 --> 00:10:27,342
markup for your elements and it is two way binded

157
00:10:27,406 --> 00:10:31,240
to your state declaration or one way binded depending on your needs.

158
00:10:31,850 --> 00:10:35,286
There is also the value retrieval section where you retrieve the

159
00:10:35,308 --> 00:10:38,882
values that you have declared so you can send them to the server.

160
00:10:38,946 --> 00:10:42,266
The problem with this is there is some friction here, and it can be too

161
00:10:42,288 --> 00:10:45,626
much friction if you have really large forms. Let's say

162
00:10:45,648 --> 00:10:49,062
you want to add a field. If you added this field, you may forget

163
00:10:49,126 --> 00:10:53,262
to bind it to your state, or you may forget to retrieve it before

164
00:10:53,316 --> 00:10:57,246
sending it to the API. And that means the

165
00:10:57,268 --> 00:11:00,926
form may be missing some data or maybe not working as

166
00:11:00,948 --> 00:11:04,366
you have expected. And this

167
00:11:04,388 --> 00:11:06,560
is a friction I'm talking about here.

168
00:11:07,650 --> 00:11:11,538
So vvaldi tries to reduce it or completely

169
00:11:11,624 --> 00:11:15,266
eliminate it by reducing it to a single section. So you only have

170
00:11:15,288 --> 00:11:18,662
to declare your fields and give it a name. That name

171
00:11:18,716 --> 00:11:22,406
can act as a field path in the model tree. So for

172
00:11:22,428 --> 00:11:25,762
example here we replaced all the inputs with the field component

173
00:11:25,906 --> 00:11:29,354
and veevalidate v automatically create the models for

174
00:11:29,392 --> 00:11:33,754
them and bind the elements, the input elements to

175
00:11:33,792 --> 00:11:37,050
these models. Another thing is another

176
00:11:37,120 --> 00:11:41,278
added benefits is you can use JavaScript object

177
00:11:41,364 --> 00:11:45,274
syntax or array syntax to express nested

178
00:11:45,322 --> 00:11:49,386
fields. So we have the links fields

179
00:11:49,418 --> 00:11:52,638
here, we have links of these zero and links of one.

180
00:11:52,724 --> 00:11:56,610
And when vvalid sees it, it understands that

181
00:11:56,760 --> 00:12:00,946
you want to create a field, a field element that

182
00:12:00,968 --> 00:12:04,322
is tracked in the first element of an array called

183
00:12:04,376 --> 00:12:08,546
links, and you want to create another field that is tracked in the second element

184
00:12:08,658 --> 00:12:11,474
of the array called links of links.

185
00:12:11,522 --> 00:12:15,362
So it creates that these for you. It reverses

186
00:12:15,506 --> 00:12:19,378
the names into default into a form tree generates

187
00:12:19,474 --> 00:12:23,482
for you, and retrieves it for you automatically when you try to submit that form.

188
00:12:23,536 --> 00:12:26,474
And really that reduces a lot of effort here.

189
00:12:26,512 --> 00:12:30,154
So if you need to add a field, you just throw it in in the

190
00:12:30,192 --> 00:12:33,546
forms and you are done. So let's

191
00:12:33,578 --> 00:12:36,718
talk about the most important aspect, and it's in the name of

192
00:12:36,724 --> 00:12:40,602
the library validation. So we developers

193
00:12:40,666 --> 00:12:43,310
come from different backgrounds.

194
00:12:43,970 --> 00:12:47,530
Me myself, I was a backend engineer, library backend engineer,

195
00:12:47,690 --> 00:12:51,662
then a node JS backend engineer, then switched

196
00:12:51,726 --> 00:12:56,214
over to front end. So with

197
00:12:56,252 --> 00:12:59,414
this I have a lot of experience of

198
00:12:59,452 --> 00:13:03,298
how each ecosystem expresses their validations,

199
00:13:03,474 --> 00:13:07,458
and that really gives me ideas on how

200
00:13:07,564 --> 00:13:11,354
and the best way for each use case.

201
00:13:11,472 --> 00:13:14,986
For example, you always need to have a baseline. So having a

202
00:13:15,008 --> 00:13:19,418
Javascript functions as the baseline really

203
00:13:19,504 --> 00:13:22,382
makes sense and it's a must have.

204
00:13:22,516 --> 00:13:27,134
So having JavaScript functions act

205
00:13:27,172 --> 00:13:31,742
as form validations opens the door for using third

206
00:13:31,796 --> 00:13:35,358
party libraries, form validations, js and custom functions.

207
00:13:35,454 --> 00:13:39,998
So it's really important to have it also integrations

208
00:13:40,094 --> 00:13:43,726
with other frameworks or inspiration from other frameworks.

209
00:13:43,758 --> 00:13:47,922
For example, there is the back end inspired string expression

210
00:13:48,066 --> 00:13:51,762
that inspired with larvae validation syntax.

211
00:13:51,906 --> 00:13:56,166
Larvae validation syntax is very easy, very compact and

212
00:13:56,348 --> 00:14:00,282
easily maintainable, and because of their

213
00:14:00,336 --> 00:14:04,090
global nature, so they need to be defined globally. That makes them

214
00:14:04,160 --> 00:14:07,814
really useful in applications

215
00:14:07,862 --> 00:14:11,326
when you have a lot of forums, so admin dashboards for example,

216
00:14:11,508 --> 00:14:14,974
and in these forums you really need

217
00:14:15,012 --> 00:14:19,274
to call upon validations rules

218
00:14:19,322 --> 00:14:22,702
without having to worry about declaring them each time you need to use them.

219
00:14:22,756 --> 00:14:26,654
So this really makes sense here. There is

220
00:14:26,692 --> 00:14:30,770
also the schema validators that you can use to build really

221
00:14:30,840 --> 00:14:34,302
complex and really dynamic validation schemas using yup

222
00:14:34,366 --> 00:14:38,454
and Zod and many others. You can use them to make, for example,

223
00:14:38,572 --> 00:14:42,182
a field is required when another field in the forms is bigger than

224
00:14:42,236 --> 00:14:46,294
five. So you really can really make these arbitrary conditions and

225
00:14:46,412 --> 00:14:49,946
you can pretty much build whatever dynamic schemas that

226
00:14:49,968 --> 00:14:54,186
you want to validate your forms. So let's see what each one looks like.

227
00:14:54,368 --> 00:14:58,010
With Javascript functions it's really straightforward. You create a function,

228
00:14:58,080 --> 00:15:01,614
that function receives a value. Then you can either

229
00:15:01,652 --> 00:15:05,118
return a boolean like true, and if you

230
00:15:05,124 --> 00:15:09,418
return true, that means that the field is valid.

231
00:15:09,594 --> 00:15:13,326
Otherwise you can return a string and that says this

232
00:15:13,348 --> 00:15:16,546
is the error message for that field. This field is invalid and this is the

233
00:15:16,568 --> 00:15:20,194
error message. It's really straightforward and all you have to do is pass it

234
00:15:20,232 --> 00:15:24,830
to the rules property of the field component field

235
00:15:24,920 --> 00:15:28,994
validation with larvae rules is similar, but it uses strings.

236
00:15:29,122 --> 00:15:34,194
So you grab the companion

237
00:15:34,242 --> 00:15:38,246
library called add v validity rules, and you

238
00:15:38,348 --> 00:15:41,494
basically grab the rules that you will need and you define them in your

239
00:15:41,532 --> 00:15:45,286
application. Note that you only have to do this once, so you don't

240
00:15:45,318 --> 00:15:48,566
really need to do this in each component. You can do it at the entry

241
00:15:48,598 --> 00:15:51,820
point of your application and not worry about it again.

242
00:15:52,190 --> 00:15:55,978
And once you define them, you can call upon them using string.

243
00:15:56,074 --> 00:15:59,546
So in the rules property you can pass a string that's

244
00:15:59,578 --> 00:16:03,374
expressed as required pipe email. So this is a required email

245
00:16:03,492 --> 00:16:07,262
field. You can use these up schemas

246
00:16:07,326 --> 00:16:09,730
to validate your fields.

247
00:16:10,070 --> 00:16:13,826
So in this example right here,

248
00:16:14,008 --> 00:16:17,734
we grab the string schema from yep, and use it to build

249
00:16:17,772 --> 00:16:20,822
up a required email schema. And we pass that

250
00:16:20,876 --> 00:16:24,422
schema to the field, same property rules and

251
00:16:24,476 --> 00:16:28,634
veevalidate v first class support for it and will understand that you want

252
00:16:28,672 --> 00:16:31,850
to do schema validation using this schema.

253
00:16:32,750 --> 00:16:36,618
Another thing that's really exciting here is you can use

254
00:16:36,704 --> 00:16:40,810
these schemas, specifically object schemas,

255
00:16:41,150 --> 00:16:44,686
to specify a validation schema for the entire forum. So you

256
00:16:44,708 --> 00:16:48,782
no longer have to specify a validation rule for each field. And this really

257
00:16:48,836 --> 00:16:52,750
makes it much more easier to reason

258
00:16:52,820 --> 00:16:56,386
about the validation rules of that forum. So you don't have to

259
00:16:56,408 --> 00:17:00,100
go back and forth between the script and the template a lot.

260
00:17:00,950 --> 00:17:04,686
And this reduces this friction as well. So there is some friction

261
00:17:04,718 --> 00:17:08,034
here, but you can completely eliminate it by using validation

262
00:17:08,082 --> 00:17:12,070
schemas. Then you define your schema object.

263
00:17:12,140 --> 00:17:16,018
For example these we have an object schema that contains

264
00:17:16,034 --> 00:17:19,882
an email that is a required email, a name field

265
00:17:19,936 --> 00:17:23,706
that is a required string, and another

266
00:17:23,808 --> 00:17:28,060
string called password that is required and must be

267
00:17:28,510 --> 00:17:32,720
minimum six characters long. And this

268
00:17:33,090 --> 00:17:36,554
will allow veevalidate v use these schema for your fields.

269
00:17:36,602 --> 00:17:40,382
It will validate each field according to the schema and it will

270
00:17:40,516 --> 00:17:43,886
automatically assign the error messages properly according

271
00:17:43,918 --> 00:17:47,426
to that schema. So this makes it really easy to

272
00:17:47,448 --> 00:17:50,606
maintain such forms and makes it really pleasant

273
00:17:50,638 --> 00:17:54,402
to use them. So let's talk about the

274
00:17:54,456 --> 00:17:56,310
progressive integration aspect.

275
00:17:58,330 --> 00:18:01,954
Right here we have this basic form, really basic

276
00:18:02,002 --> 00:18:06,774
form that uses the

277
00:18:06,812 --> 00:18:10,186
full page reload to submit the data, which is the native way

278
00:18:10,208 --> 00:18:13,782
to submit your forms. So this form submits

279
00:18:13,846 --> 00:18:17,002
via a post method these four

280
00:18:17,056 --> 00:18:21,602
fields to the action endpoint register.

281
00:18:21,766 --> 00:18:25,566
And typically you have this in your back end application, or in your

282
00:18:25,588 --> 00:18:29,406
back end rendered application can be laravel, can be

283
00:18:29,508 --> 00:18:33,410
rails, or it can be plain old php or plain old

284
00:18:33,480 --> 00:18:37,282
whatever. So this

285
00:18:37,336 --> 00:18:40,386
forum typically behaves like this. You submit the

286
00:18:40,408 --> 00:18:43,566
forum and it performs a full page reload.

287
00:18:43,598 --> 00:18:46,886
The server validates and redirects you back to the form if there

288
00:18:46,908 --> 00:18:51,174
are any errors. Otherwise it will move

289
00:18:51,212 --> 00:18:53,800
on to the next page, log you in or whatever.

290
00:18:54,730 --> 00:18:58,614
But let's say you want to add some sprinkle some Javascript here to

291
00:18:58,732 --> 00:19:02,406
spice it up a little bit. For example, you want to prevent submission

292
00:19:02,438 --> 00:19:05,786
if the form is invalid and submit using exactly

293
00:19:05,888 --> 00:19:09,786
the same flow if everything is valid. So you

294
00:19:09,808 --> 00:19:13,306
can do that using search and replace. It can be as easily as

295
00:19:13,328 --> 00:19:16,778
this. So you remove the form elements and use the form components.

296
00:19:16,874 --> 00:19:19,946
You remove the input elements and use the field components.

297
00:19:20,058 --> 00:19:24,698
And we also add the error message component that we use to display errors.

298
00:19:24,874 --> 00:19:28,866
Each error message component can have a name which is the same name of

299
00:19:28,888 --> 00:19:31,970
the field that it will display the error message for.

300
00:19:32,120 --> 00:19:35,310
So it needs to match the field names.

301
00:19:35,470 --> 00:19:39,894
Also we need to provide the validation schema and in

302
00:19:39,932 --> 00:19:43,800
any of the ways that we saw before, or you can provide

303
00:19:44,250 --> 00:19:47,806
for each field its own rules, it doesn't really matter. But validation

304
00:19:47,858 --> 00:19:50,934
schemas, I really recommend using them whenever

305
00:19:50,982 --> 00:19:54,714
you can. But right here we do. So what

306
00:19:54,752 --> 00:19:58,742
veevalidate will do here is it will automatically identify

307
00:19:58,806 --> 00:20:02,394
that you don't have a validation submission

308
00:20:02,442 --> 00:20:05,962
function, so you don't really want to hijack

309
00:20:06,106 --> 00:20:09,182
the form submit event, right?

310
00:20:09,316 --> 00:20:12,554
And what it will do is when the user submits

311
00:20:12,602 --> 00:20:16,034
a form, it will validate the forms and it will

312
00:20:16,072 --> 00:20:19,266
render any error messages and then it

313
00:20:19,288 --> 00:20:23,202
will branch off. If the form is valid, it will perform

314
00:20:23,256 --> 00:20:26,834
a full page reload and submit the form normally, just as

315
00:20:26,872 --> 00:20:30,294
if you had no Javascript at all, similar to

316
00:20:30,332 --> 00:20:34,278
the same behavior we had before. Nothing extra here. But if the

317
00:20:34,284 --> 00:20:38,102
form turns out to be invalid, then it will prevent the submission

318
00:20:38,166 --> 00:20:40,966
and display these error messages.

319
00:20:41,078 --> 00:20:44,346
So it did really what you want and it kind of

320
00:20:44,368 --> 00:20:47,882
understood your intention here.

321
00:20:48,016 --> 00:20:51,950
If you have a submit handler here, it will then

322
00:20:52,020 --> 00:20:56,942
act as it will only execute that handler when

323
00:20:56,996 --> 00:21:00,750
the form is valid, and it will prevent submission in either case because

324
00:21:00,820 --> 00:21:04,526
it then assumes yes, you really want to hijack

325
00:21:04,558 --> 00:21:06,900
the submission here. So we will do that.

326
00:21:08,390 --> 00:21:12,002
So let's talk about UI nux, and we will cover

327
00:21:12,056 --> 00:21:15,586
through a couple of examples really quickly. Right here we

328
00:21:15,608 --> 00:21:17,570
have form interaction flags.

329
00:21:18,710 --> 00:21:21,926
You can do a lot more than this example, but this is just a

330
00:21:21,948 --> 00:21:25,606
taste of what veevalidate really has to offer. So let's say you

331
00:21:25,628 --> 00:21:29,066
want to disable the submit button until the form is

332
00:21:29,088 --> 00:21:32,646
valid. You can do this by accessing the valid meta

333
00:21:32,678 --> 00:21:36,582
flag, or you can display

334
00:21:36,646 --> 00:21:41,750
the submission progress by checking the submitting flag.

335
00:21:41,830 --> 00:21:46,026
And this flag is true whenever the form is being validated and submitted,

336
00:21:46,138 --> 00:21:49,534
and will turn to false once it's done. So you can really use it to

337
00:21:49,572 --> 00:21:53,658
spill some spinners or change some text, or disable your inputs

338
00:21:53,674 --> 00:21:57,330
if you really want to. So it's really nice to use,

339
00:21:57,480 --> 00:22:01,550
you can do a lot more. There are a lot of meta flags like touched

340
00:22:01,630 --> 00:22:05,060
dirty and validated, and many others.

341
00:22:06,170 --> 00:22:09,446
So yeah, you can really build whatever experience and

342
00:22:09,468 --> 00:22:13,654
craft whatever experience you really want. Check the documentation for more information about

343
00:22:13,692 --> 00:22:17,462
what else is available here. Another example

344
00:22:17,516 --> 00:22:20,886
here is handling invalid submissions. This is a fairly

345
00:22:21,078 --> 00:22:24,730
new addition to the library, so a lot of users really wanted

346
00:22:24,800 --> 00:22:28,714
to do something extra when the user submits the form

347
00:22:28,752 --> 00:22:32,490
and turns out invalid, which is really useful if you have this long form

348
00:22:32,560 --> 00:22:36,046
and you really want to scroll the user to the input that they

349
00:22:36,068 --> 00:22:39,706
cannot see so the user may be trying to submit the form, but they don't

350
00:22:39,738 --> 00:22:43,674
understand exactly what's going on. So it can be really useful

351
00:22:43,722 --> 00:22:47,650
to just scroll them. Yeah, here is these field that has an issues

352
00:22:47,720 --> 00:22:51,042
please fix it so we can really

353
00:22:51,096 --> 00:22:54,974
do that. Using this simple example we grab the first error key and

354
00:22:55,032 --> 00:22:58,280
that can happen to be the field name and then

355
00:22:59,530 --> 00:23:02,998
you can build your form for that to be

356
00:23:03,084 --> 00:23:07,014
correct and then query that

357
00:23:07,052 --> 00:23:10,586
input, grab it and scroll it into view and you are done.

358
00:23:10,768 --> 00:23:14,554
So three liners really improve the experience of really wrong forms or

359
00:23:14,592 --> 00:23:18,970
multistep forms if you have them. So yeah,

360
00:23:19,120 --> 00:23:22,406
you can do a lot more with veevalidate v terms of your IU

361
00:23:22,438 --> 00:23:25,550
nux, but this is just a couple of examples.

362
00:23:25,970 --> 00:23:29,386
So form generators form generators

363
00:23:29,418 --> 00:23:32,986
are really complicated, but using vvalidate

364
00:23:33,018 --> 00:23:36,142
you can really get away with a very basic form

365
00:23:36,196 --> 00:23:39,746
generator. Vvalidate itself doesn't offer any form generator for

366
00:23:39,768 --> 00:23:43,122
you out of the box, but you have all the tools to build your own.

367
00:23:43,256 --> 00:23:47,286
But if you don't really know what is a form generator, it is basically

368
00:23:47,388 --> 00:23:50,994
a component or a function or something that accepts

369
00:23:51,042 --> 00:23:55,062
a JSON object or a JavaScript object and generates your

370
00:23:55,116 --> 00:23:59,194
fields and forms based on that object. They can be dynamic and

371
00:23:59,232 --> 00:24:02,742
it makes it really easy to retrieve your forms from the API,

372
00:24:02,806 --> 00:24:06,694
for example, and they are really useful and really reduce,

373
00:24:06,822 --> 00:24:10,446
they can really boost your productivity when

374
00:24:10,468 --> 00:24:12,190
working with a lot of forms.

375
00:24:13,490 --> 00:24:16,234
So right here in this tutorial,

376
00:24:16,282 --> 00:24:20,026
it's only eight lines long if you leave out the schema

377
00:24:20,138 --> 00:24:24,166
fields definition and yeah, this is the most basic

378
00:24:24,298 --> 00:24:27,922
form generator. Of course you can expand upon it more to

379
00:24:27,976 --> 00:24:31,362
include more complicated inputs like selects custom

380
00:24:31,416 --> 00:24:35,346
components and more. And there is actually a tutorial in the documentation covering

381
00:24:35,378 --> 00:24:38,822
that you can also use

382
00:24:38,876 --> 00:24:42,482
specialized libraries that have first part support with vvalidate.

383
00:24:42,546 --> 00:24:46,630
Again, because of the composition API that we will come to just a minute.

384
00:24:47,050 --> 00:24:50,694
Vvalidate can be integrated with other libraries

385
00:24:50,742 --> 00:24:54,214
and one such library is forms view late and form view late

386
00:24:54,262 --> 00:24:57,466
really takes it to the next level with

387
00:24:57,488 --> 00:24:58,570
form generated.

388
00:25:00,350 --> 00:25:03,886
It's completely UI agnostic, so it doesn't really care what you want to

389
00:25:03,908 --> 00:25:07,754
render. You can render custom components or you can render a native HTML

390
00:25:07,802 --> 00:25:11,226
element with formvalate.

391
00:25:11,258 --> 00:25:15,074
You can then render your inputs, integrate them with vvalidate without really

392
00:25:15,112 --> 00:25:18,306
a lot of work. So you only

393
00:25:18,328 --> 00:25:22,002
have to declare your fields and if you really need

394
00:25:22,056 --> 00:25:25,806
this kind of functionality. So form generation and validation

395
00:25:25,918 --> 00:25:29,862
to your application, this can be really useful and

396
00:25:29,916 --> 00:25:33,366
it will take care of the hard and heavy lifting for

397
00:25:33,388 --> 00:25:37,480
you. So you only have to care about the actual application logic because

398
00:25:37,950 --> 00:25:40,220
most of the things are done for you.

399
00:25:41,710 --> 00:25:45,626
Speaking of the composition API. So the

400
00:25:45,648 --> 00:25:49,574
composition API again allows you to integrate the vvalidate

401
00:25:49,622 --> 00:25:53,006
features into your own components. And you

402
00:25:53,028 --> 00:25:56,522
can think of vvalidate as this central API

403
00:25:56,586 --> 00:26:00,234
that has two outlets, the composition API

404
00:26:00,282 --> 00:26:03,726
outlet and the components API outlet. You have seen the components

405
00:26:03,758 --> 00:26:07,762
API so far and the components API is actually the same.

406
00:26:07,816 --> 00:26:11,426
They both offer the same feature sets and actually the

407
00:26:11,448 --> 00:26:14,830
components API is built using the

408
00:26:14,920 --> 00:26:18,262
composition API. This means

409
00:26:18,316 --> 00:26:22,310
that you can mix and match between them. They are not mutually exclusive.

410
00:26:22,890 --> 00:26:26,054
You can use the components API along with

411
00:26:26,092 --> 00:26:29,318
the composition API. So if you want

412
00:26:29,324 --> 00:26:32,854
to build custom field components with validation, value tracking,

413
00:26:32,902 --> 00:26:36,554
and all of the features I showcased, you can use a function called use

414
00:26:36,592 --> 00:26:40,278
field for forms components, you can use a function called use form.

415
00:26:40,464 --> 00:26:44,654
This is an example for such a basic input component called

416
00:26:44,692 --> 00:26:48,014
input text. And this components all

417
00:26:48,052 --> 00:26:51,642
it does, it just imports use field from veevalidate,

418
00:26:51,706 --> 00:26:55,306
calls it and basses the field name to it, which will

419
00:26:55,348 --> 00:26:58,814
be appropriate most likely. And it grabs

420
00:26:58,862 --> 00:27:02,402
two things, the value and the error message. The value is the internal model

421
00:27:02,456 --> 00:27:05,782
that veevalidate creates for you, so you can actually bind it to your

422
00:27:05,836 --> 00:27:09,730
actual input and it will automatically be validated

423
00:27:09,810 --> 00:27:13,798
whenever that value changes. Veevalidate will populate the

424
00:27:13,804 --> 00:27:17,962
error message with any information or the

425
00:27:18,016 --> 00:27:22,022
proper error message. Forms, custom forms,

426
00:27:22,086 --> 00:27:25,866
it is similar. You grab the use form function, you can

427
00:27:25,888 --> 00:27:29,366
pass the validation schema to it and other configuration

428
00:27:29,558 --> 00:27:33,134
properties. You can grab a handle submit function from it

429
00:27:33,252 --> 00:27:36,734
and there are a lot of stuff you can grab from it. But for this

430
00:27:36,772 --> 00:27:40,714
example we are only grabbing the handle submit which creates submission

431
00:27:40,762 --> 00:27:44,194
handlers for you. These submission handlers you can

432
00:27:44,232 --> 00:27:47,730
bind to your listeners, so you can listen for a form

433
00:27:47,800 --> 00:27:52,354
submit event and trigger the submit function for

434
00:27:52,392 --> 00:27:55,666
it. You can use it on bottom clicks, you can

435
00:27:55,688 --> 00:27:59,094
really use it in any kind of events, and you can even call

436
00:27:59,132 --> 00:28:03,014
it manually in your javascript and they all behave the same. They will

437
00:28:03,052 --> 00:28:06,150
validate the form and these executor callback if everything

438
00:28:06,220 --> 00:28:09,642
is valid. Otherwise they will just validate the form and

439
00:28:09,696 --> 00:28:11,500
won't do anything extra.

440
00:28:15,150 --> 00:28:18,410
Let's check an example from before and after.

441
00:28:18,480 --> 00:28:21,526
So before we used the components API,

442
00:28:21,638 --> 00:28:25,242
which was a little bit verbose because we had to use the field component

443
00:28:25,306 --> 00:28:29,034
and the error message components and we have a bunch of fields. So this became

444
00:28:29,082 --> 00:28:32,926
repetitive really quickly. But if we use a composition API to

445
00:28:32,948 --> 00:28:36,738
build our own input text component, we can then really

446
00:28:36,824 --> 00:28:40,674
express our forms in terms of one liners. So one liner name,

447
00:28:40,712 --> 00:28:44,066
one liner email and one liner password and that's it, we are

448
00:28:44,088 --> 00:28:47,438
done. We get value tracking error

449
00:28:47,454 --> 00:28:51,174
messages for those elements and we get the rendering as well.

450
00:28:51,292 --> 00:28:54,962
And this is really the main benefit of using the composition API.

451
00:28:55,026 --> 00:28:59,170
You should use it to build your own components and not veevalidate v JavaScript values.

452
00:28:59,250 --> 00:29:02,682
If you really want to just validate JavaScript values then you are better

453
00:29:02,736 --> 00:29:06,758
off using other libraries. This is the main goal

454
00:29:06,774 --> 00:29:10,118
of the composition by veevalidate help you build

455
00:29:10,224 --> 00:29:13,966
your own custom components and custom forms. In this

456
00:29:13,988 --> 00:29:17,918
example, notice that we use the form components with our

457
00:29:18,004 --> 00:29:21,022
custom input text component. Again,

458
00:29:21,076 --> 00:29:24,658
this is because it's all built on the composition API, meaning you

459
00:29:24,664 --> 00:29:28,386
can mix them and they will work seamlessly together. You can do

460
00:29:28,408 --> 00:29:32,162
the opposite as well. So let's check this

461
00:29:32,216 --> 00:29:35,750
last thing, which is the Vuejs diff tools plugin

462
00:29:38,170 --> 00:29:45,474
right here. We have this really nice forum and

463
00:29:45,512 --> 00:29:49,650
we have the view diff tools. Normally you have the view diff tools.

464
00:29:50,070 --> 00:29:53,446
View diff tools offers inspectors that allow you to

465
00:29:53,468 --> 00:29:56,726
view the components these in different ways.

466
00:29:56,908 --> 00:30:00,342
So the default one is called components. But once

467
00:30:00,396 --> 00:30:04,602
you use any kind of vvalidate stuff, either the composition API or

468
00:30:04,736 --> 00:30:08,646
the components, you will see a new inspector called veevalidate

469
00:30:08,758 --> 00:30:13,340
v. You click on it, you will notice that it renders a completely different view.

470
00:30:13,790 --> 00:30:18,098
It shows you the nodes

471
00:30:18,134 --> 00:30:21,674
in terms of not components but in terms of fields and forms.

472
00:30:21,722 --> 00:30:25,614
So right here, this is a form node, this is a name node and

473
00:30:25,732 --> 00:30:29,374
I'm calling them nodes because each component can contain multiple

474
00:30:29,422 --> 00:30:34,526
fields or multiple forms. So it's not really accurate

475
00:30:34,558 --> 00:30:37,598
to call each one components. So they are just nodes.

476
00:30:37,774 --> 00:30:41,734
So each node can have a summary of their state like

477
00:30:41,772 --> 00:30:45,590
you can see down here. And yeah,

478
00:30:45,660 --> 00:30:48,934
form of course have more states, so of course they

479
00:30:48,972 --> 00:30:52,594
have more stuff to show. But yeah, you get access to initial

480
00:30:52,642 --> 00:30:56,460
values, current values, errors and any other meta information.

481
00:30:56,830 --> 00:31:00,138
At a glance you get these tags called form field

482
00:31:00,224 --> 00:31:04,058
that tells you which node is which. So this is a form node, this is

483
00:31:04,224 --> 00:31:07,422
field node and so on. They are in

484
00:31:07,476 --> 00:31:10,974
red. So notice once I start filling out these

485
00:31:11,172 --> 00:31:14,750
element they turn to green.

486
00:31:14,820 --> 00:31:18,434
This is really neat because vvalid now tells you

487
00:31:18,632 --> 00:31:22,654
what each component validity

488
00:31:22,702 --> 00:31:26,802
is just at a glance without you having to really dig deep and see

489
00:31:26,936 --> 00:31:31,234
why is these field is not valid, right? So yeah,

490
00:31:31,272 --> 00:31:35,814
just simple color change can tell you a lot. So here

491
00:31:35,932 --> 00:31:39,766
right now we can tell that this form isn't valid because it's red

492
00:31:39,948 --> 00:31:43,026
and it isn't valid because this field is the only one that's invalid,

493
00:31:43,058 --> 00:31:46,426
so makes complete sense. And if we try to

494
00:31:46,448 --> 00:31:50,154
submit it, this does this little shaking, which is a small

495
00:31:50,192 --> 00:31:53,754
validations that we have here, but we show an error message here. If we

496
00:31:53,792 --> 00:31:57,646
click on the confirm password node, notice that we have the error here

497
00:31:57,748 --> 00:32:01,246
and the valid flag is turned to false. And if we

498
00:32:01,268 --> 00:32:05,546
go to the form in the errors object, we have passwords

499
00:32:05,578 --> 00:32:09,226
do not match for the confirmed password field. So let's

500
00:32:09,258 --> 00:32:12,386
try filling it out. And these

501
00:32:12,408 --> 00:32:16,274
errors are empty. The hover form is valid, it is green. Same thing

502
00:32:16,312 --> 00:32:20,318
for the confirmed buster field. If we try to submit it, everything submits

503
00:32:20,414 --> 00:32:24,262
and it works nicely. You can have do a lot of other

504
00:32:24,316 --> 00:32:27,990
actions to debug your state. For example, you can clear the forms

505
00:32:28,140 --> 00:32:31,846
so you can clear individual inputs. So let's click on

506
00:32:31,868 --> 00:32:35,306
the buzzer field. You can clear it by clicking on this icon and yeah,

507
00:32:35,328 --> 00:32:38,940
it is cleared and you can force validate it.

508
00:32:40,350 --> 00:32:44,074
You can click on the form node and clear it and

509
00:32:44,112 --> 00:32:47,514
also forms validations and forms validation it. So this is really

510
00:32:47,552 --> 00:32:50,846
nice and allows you at a glance to figure out what's wrong. So if you

511
00:32:50,868 --> 00:32:54,446
have this form that isn't submitting, you can check the

512
00:32:54,468 --> 00:32:58,066
errors and figure out why it's not submitting. Maybe it has some field that

513
00:32:58,088 --> 00:33:01,170
you forgot to show, or maybe you forgot a rule.

514
00:33:01,510 --> 00:33:03,700
So yeah,

515
00:33:05,590 --> 00:33:09,154
that's all for this talk. So there is of course a lot

516
00:33:09,192 --> 00:33:13,460
more that we didn't cover because there is a lot of API and

517
00:33:14,950 --> 00:33:18,146
components that makes it really useful for you.

518
00:33:18,168 --> 00:33:20,990
For example array fields, multifaceted step forms,

519
00:33:21,070 --> 00:33:24,182
localization libraries, integrations,

520
00:33:24,326 --> 00:33:27,850
which is libraries like quasar, beautify,

521
00:33:28,190 --> 00:33:31,546
toolwind, the headless UI and more. Check out the

522
00:33:31,568 --> 00:33:35,354
documentation, there is a lot of information each of them and leave

523
00:33:35,392 --> 00:33:38,940
your feedback. So thank you for

524
00:33:39,310 --> 00:33:41,400
attending this talk and see you around.

