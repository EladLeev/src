1
00:00:34,450 --> 00:00:38,822
Welcome to evolute, migrate and aibased containerization here@the.com.

2
00:00:38,876 --> 00:00:42,422
42 Cloud Native 2023 we're going to talk about

3
00:00:42,476 --> 00:00:46,450
how to automate any software from its source environment

4
00:00:46,530 --> 00:00:49,640
over to the destination in a matter of minutes.

5
00:00:50,050 --> 00:00:53,982
It's so very important as your CTO comes to you

6
00:00:54,036 --> 00:00:57,454
and asks you to move across cloud environments, or maybe

7
00:00:57,572 --> 00:01:01,498
you're a developer and you're responsible for a complex application or hundreds

8
00:01:01,514 --> 00:01:05,710
of applications, and you need to ensure that they reach their destination.

9
00:01:06,210 --> 00:01:09,666
With Aibased containerization, we're able to ensure that

10
00:01:09,688 --> 00:01:12,946
we get the most native artifact in

11
00:01:12,968 --> 00:01:16,866
the destination and be able to do that with Razorsharp

12
00:01:16,898 --> 00:01:20,166
precision. So we'll talk about how AI is able

13
00:01:20,188 --> 00:01:23,798
to achieve that capability and how we're able to ensure that

14
00:01:23,884 --> 00:01:27,762
whether you're trying to modernize migrate or transform

15
00:01:27,826 --> 00:01:31,222
that software, we can ensure that it is successful.

16
00:01:31,286 --> 00:01:35,402
So we'll go through an overview of evolution migrate. We'll also

17
00:01:35,456 --> 00:01:38,950
talk about the BCD framework and our software capabilities.

18
00:01:39,030 --> 00:01:42,558
We'll delve into a demo and we'll finish off with a

19
00:01:42,564 --> 00:01:46,398
couple of scalability patterns to ensure that we really understand

20
00:01:46,564 --> 00:01:50,026
the rate at which we can take these artifacts

21
00:01:50,058 --> 00:01:53,610
and move them to their most production oriented

22
00:01:53,690 --> 00:01:57,198
scalability pattern, as we conclude

23
00:01:57,294 --> 00:02:00,818
for today. So in order to know where we're going,

24
00:02:00,904 --> 00:02:04,446
we must know where we've come from. And it's really interesting to see the developments

25
00:02:04,478 --> 00:02:07,766
that have been in this space, and it really does help to shape context for

26
00:02:07,788 --> 00:02:11,222
us. We're really excited that we were able to

27
00:02:11,356 --> 00:02:14,870
introduce the first containerization capability in 2016.

28
00:02:15,850 --> 00:02:19,926
Since the beginning, we really created the capability to

29
00:02:19,948 --> 00:02:23,830
move software into this artifact in a very native

30
00:02:23,910 --> 00:02:27,466
way. So we're super excited about the patents that show that. And what

31
00:02:27,488 --> 00:02:30,874
that really boils down to is that we were not only the first, but also

32
00:02:30,912 --> 00:02:34,526
one of the most comprehensive abilities today to be able to achieve this

33
00:02:34,548 --> 00:02:37,806
capability. We saw in about 2000 Andor 17 that

34
00:02:37,828 --> 00:02:41,662
Google was able to introduce the capability to also

35
00:02:41,716 --> 00:02:45,586
do containerization, and we've seen a couple of developments since then.

36
00:02:45,688 --> 00:02:49,022
We began developing our Aibased containerization

37
00:02:49,166 --> 00:02:53,678
around 2018. We also saw the purchase

38
00:02:53,774 --> 00:02:58,246
and acquisition of companies like Mellistrada in the space in

39
00:02:58,268 --> 00:03:02,166
2018 as well. We've seen in about 2019 that

40
00:03:02,348 --> 00:03:05,238
companies like Docker created the MTE program,

41
00:03:05,404 --> 00:03:09,146
and this was really an amligation of a

42
00:03:09,168 --> 00:03:13,146
number of different consulting firms coming together and ensuring that

43
00:03:13,248 --> 00:03:16,610
enterprises were reaching their destinations. In 2000 Andor

44
00:03:16,620 --> 00:03:19,766
20, we saw app two containers being released,

45
00:03:19,878 --> 00:03:23,274
which was really focused on Greenville software, and Amazon

46
00:03:23,322 --> 00:03:27,722
has continued to launch these things and mature

47
00:03:27,786 --> 00:03:31,754
them. We've also seen around this time that we were able to launch

48
00:03:31,882 --> 00:03:35,730
our Aibased containerization capabilities and have really been working

49
00:03:35,800 --> 00:03:39,266
with a number of leading companies to get that

50
00:03:39,368 --> 00:03:43,310
to its highest peak. We've also seen Azure

51
00:03:43,390 --> 00:03:47,986
migrate around 2021, introduce its containerization capabilities,

52
00:03:48,098 --> 00:03:52,086
and we've also seen open source projects that are able to

53
00:03:52,268 --> 00:03:56,146
really introduce their ability to evaluate core

54
00:03:56,178 --> 00:03:59,594
software and create images such as the conveyor project and

55
00:03:59,632 --> 00:04:03,062
so many developments in space. And we're super excited.

56
00:04:03,206 --> 00:04:07,162
Again, we do believe that we've created one of the most

57
00:04:07,216 --> 00:04:10,810
comprehensive abilities, so we've been able to do graphical as well as obviously

58
00:04:10,880 --> 00:04:14,334
non graphical software. And really what this means is that

59
00:04:14,372 --> 00:04:17,966
for the ecosystem, we're able to really accelerate the

60
00:04:17,988 --> 00:04:21,546
rate at which software can reach these cloud data formats. So let's

61
00:04:21,578 --> 00:04:25,394
get a little bit more into BCD. BCD is

62
00:04:25,432 --> 00:04:28,862
binary configuration data, and what this framework

63
00:04:28,926 --> 00:04:32,882
really says is that if we can look at

64
00:04:32,936 --> 00:04:36,742
a software artifact in its source environment and

65
00:04:36,876 --> 00:04:41,474
put any component into either binary

66
00:04:41,602 --> 00:04:45,206
configuration or data, what that means is

67
00:04:45,228 --> 00:04:49,320
that we can make that software artifact more portable across the cloud.

68
00:04:49,930 --> 00:04:53,770
In order to understand how this data based or

69
00:04:53,920 --> 00:04:58,026
Aibased approach works, we really have to understand the premise of

70
00:04:58,048 --> 00:05:01,766
it. We'll reserve a little bit of this deeper

71
00:05:01,798 --> 00:05:05,120
dive for later on, but just let's talk about it at a high level.

72
00:05:06,130 --> 00:05:09,018
For our input coming into the software,

73
00:05:09,194 --> 00:05:12,874
we need to understand a breadcrumb. And if you're familiar

74
00:05:13,002 --> 00:05:17,122
with the irobot analogy, if we ask

75
00:05:17,176 --> 00:05:20,946
the right question, then we will get to the right solution. And in

76
00:05:20,968 --> 00:05:25,026
this case we just need a breadcrumb. We just need an input that gives us

77
00:05:25,048 --> 00:05:28,214
a reference to the software. So in this

78
00:05:28,252 --> 00:05:30,678
case, that input is either the application,

79
00:05:30,764 --> 00:05:34,610
binary, a package, a file, really anything that references

80
00:05:34,690 --> 00:05:38,098
that unique piece of software. Now obviously we can provide you a list of the

81
00:05:38,124 --> 00:05:40,570
software that's running on that environment,

82
00:05:40,990 --> 00:05:45,046
but this allows us to ensure that we understand the input.

83
00:05:45,238 --> 00:05:49,270
Now again, we're going to introduce how you can use BCD,

84
00:05:49,430 --> 00:05:52,974
not only through the evolute migrate software, but in your own

85
00:05:53,092 --> 00:05:56,782
modernization or containerization capabilities. We believe

86
00:05:56,836 --> 00:06:00,842
that this removes a lot of the overhead

87
00:06:00,906 --> 00:06:04,686
when you're cognitively thinking about how do I take this software from

88
00:06:04,788 --> 00:06:08,514
point a to point b? While most will go into

89
00:06:08,552 --> 00:06:11,666
that software and try to understand all the intricacies, and if you have to do

90
00:06:11,688 --> 00:06:14,846
that, over 100 applications that have been created

91
00:06:14,878 --> 00:06:18,726
over many years, this becomes very complex. And even

92
00:06:18,748 --> 00:06:21,698
if you're a new software developer or a new startup,

93
00:06:21,794 --> 00:06:25,602
moving your software into a cloud environment

94
00:06:25,666 --> 00:06:28,982
or cross cloud environments, maybe into an on premise environment,

95
00:06:29,126 --> 00:06:32,646
being able to ensure that software gets there successfully.

96
00:06:32,758 --> 00:06:36,330
You also need to understand how the enterprises

97
00:06:36,990 --> 00:06:40,314
cloud environment works. And so really ensuring that you

98
00:06:40,352 --> 00:06:43,694
understand how to mobilize your software via BCD is

99
00:06:43,732 --> 00:06:47,662
also something that's very important as a part of this

100
00:06:47,716 --> 00:06:51,994
talk. And so again, we'll talk through how you can better containers

101
00:06:52,042 --> 00:06:56,034
your software. Just understanding this model going back

102
00:06:56,072 --> 00:06:59,422
to the input execution output.

103
00:06:59,566 --> 00:07:02,914
So our input being again an application binary or

104
00:07:02,952 --> 00:07:06,626
file and the execution in this case we'll be

105
00:07:06,648 --> 00:07:10,802
seeing evolution migrate as we move into our demo. But again BCD

106
00:07:10,866 --> 00:07:14,358
binary configuration data, really looking at how

107
00:07:14,444 --> 00:07:17,894
you can analyze your software and put it into

108
00:07:17,932 --> 00:07:22,086
these buckets and then allow that to move will really help you to automate

109
00:07:22,118 --> 00:07:25,322
your software capabilities. And the output is very clear.

110
00:07:25,456 --> 00:07:28,950
We can move into really any type of form factor.

111
00:07:29,030 --> 00:07:32,734
Obviously we could do vm to vm. We can go

112
00:07:32,772 --> 00:07:35,950
from core code base into a container.

113
00:07:36,690 --> 00:07:40,634
In this case we'll talk about being able to go from vm to container.

114
00:07:40,762 --> 00:07:45,246
And that really is the precedent for being able to go into serverless

115
00:07:45,358 --> 00:07:49,026
lambda. Really all of these technologies that

116
00:07:49,128 --> 00:07:53,214
are new and cutting edge are based on the container

117
00:07:53,262 --> 00:07:57,026
technology. And so being able to do that in a Kubernetes environment,

118
00:07:57,138 --> 00:08:01,000
whether you're across a public cloud such as Google Cloud,

119
00:08:01,530 --> 00:08:05,426
AWS or Azure, it's all based on your ability

120
00:08:05,538 --> 00:08:09,202
to leveraging evolute migrate and or the VCD framework.

121
00:08:09,266 --> 00:08:12,838
So it really makes for an exciting execution once you get the hang

122
00:08:12,854 --> 00:08:16,362
of it. We can talk about this all day, but it's always exciting to really

123
00:08:16,416 --> 00:08:20,506
get into a demo just to see the software at work. Now what

124
00:08:20,528 --> 00:08:24,922
you'll see is we're actually going to be running evolutes migrate.

125
00:08:25,066 --> 00:08:28,606
This is our command line for this is Chrysalis. Chrysalis is

126
00:08:28,628 --> 00:08:32,366
the stage where you move from a pupa to a butterfly in

127
00:08:32,388 --> 00:08:36,366
that evolution process. So that's our software's

128
00:08:36,398 --> 00:08:39,474
name. We actually are going to execute this

129
00:08:39,592 --> 00:08:43,262
and we'll see that it will connect to the source environment.

130
00:08:43,406 --> 00:08:46,754
It will be able to pull that application, transform it

131
00:08:46,872 --> 00:08:50,246
and create the containers artifact. So again, we'll connect to our

132
00:08:50,268 --> 00:08:53,958
guest apps. We'll tell it to only give us the base artifact since we're going

133
00:08:53,964 --> 00:08:57,026
to run through this interactively and we'll ensure that we're

134
00:08:57,058 --> 00:09:00,346
able to see the execution of it in

135
00:09:00,368 --> 00:09:04,506
real time. So let's dive in and what

136
00:09:04,528 --> 00:09:08,646
we'll do is we'll start off with our target applications

137
00:09:08,758 --> 00:09:12,394
and we'll just see our ability to execute

138
00:09:12,522 --> 00:09:18,570
with this so

139
00:09:18,640 --> 00:09:24,278
we can see that input here is glassfish.

140
00:09:24,374 --> 00:09:27,662
And here we're able to see that we

141
00:09:27,716 --> 00:09:32,394
are going to take a middleware application. We'll start to run our Chrysalis

142
00:09:32,442 --> 00:09:36,154
software and we'll point to our destination

143
00:09:36,202 --> 00:09:40,274
guest apps. Excuse me, source guest apps. We'll specify our

144
00:09:40,312 --> 00:09:43,538
privileged user. We'll go ahead

145
00:09:43,624 --> 00:09:47,730
and specify how to access that environment.

146
00:09:49,350 --> 00:09:53,318
And in my environment, that's the local environment. So we'll go ahead Andor

147
00:09:53,404 --> 00:09:57,670
just use the root user Andor specific keys.

148
00:09:58,090 --> 00:10:01,942
We'll also specify our staging, we'll specify our

149
00:10:01,996 --> 00:10:05,718
target applications. And we'll go from here so we

150
00:10:05,724 --> 00:10:09,814
can quickly see that we're getting connectivity. What's happening right now is it's connecting

151
00:10:09,862 --> 00:10:13,498
to the actual guest apps and it's actually comparing the

152
00:10:13,504 --> 00:10:16,780
source and destination to see the deterministic path that must take place.

153
00:10:18,930 --> 00:10:22,414
We like to talk about OSI, which we'll talk about how we create those

154
00:10:22,452 --> 00:10:26,762
translation maps here soon. But you can see that it begins to evaluate

155
00:10:26,906 --> 00:10:29,838
everything about the software. It creates the beginning and the end.

156
00:10:29,924 --> 00:10:33,394
And it also starts to parse and be able to determine which

157
00:10:33,432 --> 00:10:37,586
pieces of this software is binary configuration Andor data.

158
00:10:37,768 --> 00:10:40,946
The reason that's important is because that's going to allow us to create unique container

159
00:10:40,978 --> 00:10:44,946
artifacts and make that software custom as well as Razorsharp.

160
00:10:44,978 --> 00:10:48,790
So there you have it. We have our container image

161
00:10:49,290 --> 00:10:52,770
and now we're actually able to copy this.

162
00:10:52,860 --> 00:10:59,482
Let's go ahead and we'll do a docker run and

163
00:10:59,536 --> 00:11:03,274
we'll get into this environment. So here

164
00:11:03,312 --> 00:11:05,020
we can see that.

165
00:11:07,230 --> 00:11:11,242
We'll go over to the guest app system and see the actual glassfish

166
00:11:11,386 --> 00:11:14,346
source. This is how it existed in the virtual machine. So we can just copy

167
00:11:14,378 --> 00:11:18,178
that. We'll actually look at, we know that we have

168
00:11:18,184 --> 00:11:21,762
a database. So we'll just go ahead, start our database. We also

169
00:11:21,816 --> 00:11:25,618
see that we have a domain. So this is the application service

170
00:11:25,784 --> 00:11:27,540
and we'll kick that off.

171
00:11:40,300 --> 00:11:43,992
And that's successful. And so this

172
00:11:44,046 --> 00:11:48,024
application has pet clinic. This is a demonstration app

173
00:11:48,062 --> 00:11:52,364
that's running in the environment. So we can go ahead and query this on

174
00:11:52,402 --> 00:11:54,940
the container environment that we just created.

175
00:11:59,200 --> 00:12:03,004
And we can see that the software is running

176
00:12:03,042 --> 00:12:06,264
and functioning as it should. Pretty cool,

177
00:12:06,322 --> 00:12:06,930
right?

178
00:12:09,880 --> 00:12:13,620
So this is exciting. Just this ability to quickly transform.

179
00:12:14,200 --> 00:12:17,316
We'll actually go a little bit deeper and

180
00:12:17,338 --> 00:12:19,540
let's look at the actual docker file.

181
00:12:22,620 --> 00:12:25,916
And again, this foundation allows us to easily bring it

182
00:12:25,938 --> 00:12:29,596
into a Kubernetes environment. But we just wanted the

183
00:12:29,618 --> 00:12:33,132
actual base of this. And we can see that the software was able

184
00:12:33,186 --> 00:12:36,636
to really see the destination was in an Amazon

185
00:12:36,668 --> 00:12:40,812
Linux environment, as well as be able to determine its packages

186
00:12:40,876 --> 00:12:44,460
and dependencies and everything needed to be able to run this software.

187
00:12:44,540 --> 00:12:48,132
So very exciting, this ability to have a very

188
00:12:48,186 --> 00:12:52,132
lightweight container image and capable of achieving this type

189
00:12:52,186 --> 00:12:54,500
of containerization and distribution.

190
00:12:56,840 --> 00:12:59,990
So in order to really understand this,

191
00:13:00,520 --> 00:13:03,988
we really need to delve deeper into how were we able to achieve

192
00:13:04,004 --> 00:13:07,848
this and how was AI used in a way that can achieve this.

193
00:13:08,014 --> 00:13:11,904
And what we're going to do is delve deeper into BCD

194
00:13:11,972 --> 00:13:16,188
binary configuration data to understand how the algorithm worked,

195
00:13:16,274 --> 00:13:19,804
to componentize, categorize, classify and

196
00:13:19,842 --> 00:13:23,196
ensure that the containerization would be successful. So again,

197
00:13:23,298 --> 00:13:26,956
the first step that occurs is that we need to understand where our software begins

198
00:13:26,988 --> 00:13:30,396
and ends. So what that amounts

199
00:13:30,428 --> 00:13:34,064
to is really that we needed to create a cluster for that

200
00:13:34,102 --> 00:13:37,868
software and understand its interdependencies and intra

201
00:13:37,964 --> 00:13:41,572
dependencies. If you may. What are those components that are running

202
00:13:41,626 --> 00:13:45,204
within the software, what are those components that are running outside of the software and

203
00:13:45,242 --> 00:13:47,270
what are their relationships between them?

204
00:13:48,520 --> 00:13:52,264
We were able to do this classification and once we

205
00:13:52,302 --> 00:13:56,504
had this particular understanding of the software, this allowed us to

206
00:13:56,622 --> 00:14:00,676
create the appropriate containers image and a three tier or multi

207
00:14:00,708 --> 00:14:04,268
tier type of application, which we'll talk about the actual

208
00:14:04,354 --> 00:14:08,440
BCD framework and evolution migrate would be able to understand those relationships.

209
00:14:08,520 --> 00:14:12,188
And so understanding the actual classification of

210
00:14:12,194 --> 00:14:15,596
the software is very important. We were able

211
00:14:15,618 --> 00:14:19,328
to do this via the effective technique of k meets clustering, creating a

212
00:14:19,334 --> 00:14:22,512
cluster of the application of what belonged inside of it and what belonged outside

213
00:14:22,566 --> 00:14:26,224
of it, and really use this type of machine learning to

214
00:14:26,262 --> 00:14:29,444
achieve that capability. Now that we

215
00:14:29,482 --> 00:14:33,396
understand the application and its inter

216
00:14:33,578 --> 00:14:37,892
and intra dependencies, we are actually able to now create

217
00:14:38,026 --> 00:14:41,636
the container artifact. And so we leverage decision trees.

218
00:14:41,668 --> 00:14:45,672
We really start off at about seven or eight base paths, but through the

219
00:14:45,806 --> 00:14:49,124
number of different options through operating system capabilities,

220
00:14:49,252 --> 00:14:53,108
through the actual frameworks, dependencies, the destinations

221
00:14:53,284 --> 00:14:57,164
Andor the sources that we're coming from, there typically is about 3100

222
00:14:57,202 --> 00:15:00,888
paths that the software can take deterministically. So we can't

223
00:15:00,904 --> 00:15:04,136
run this software in a way that it's undeterministic.

224
00:15:04,328 --> 00:15:07,984
We have to ensure that the software will reach its destination per

225
00:15:08,022 --> 00:15:11,920
execution Andor so again, we were able to leverage

226
00:15:13,300 --> 00:15:16,864
the decision trees to ensure that it was able to reach that

227
00:15:16,902 --> 00:15:20,804
path. Now there does come a point where something new comes

228
00:15:20,842 --> 00:15:24,688
up and we are able to get it into the destination

229
00:15:24,864 --> 00:15:28,772
as optimistically as possible. And we really haven't come across

230
00:15:28,826 --> 00:15:33,684
a scenario based on our understanding of the world as it exists in

231
00:15:33,722 --> 00:15:37,476
a way that we weren't able to create a deterministic output. So we're super excited

232
00:15:37,508 --> 00:15:40,936
that the 99 percentile of software has worked. We saved the 1% for

233
00:15:41,038 --> 00:15:45,052
what we may not have experienced yet, although we've implemented this in

234
00:15:45,106 --> 00:15:48,396
many different enterprises and many different capabilities. So we believe this will work

235
00:15:48,498 --> 00:15:51,740
in your environment as well. So once again,

236
00:15:51,890 --> 00:15:55,612
getting that ability to see how BCD works. Andor really starting

237
00:15:55,666 --> 00:15:58,976
to think about when you look at a software, are you looking at it in

238
00:15:58,998 --> 00:16:02,336
terms of all the intricacies and components? Are you looking at it in

239
00:16:02,358 --> 00:16:06,124
terms of what are the pieces of applications, what are the pieces

240
00:16:06,172 --> 00:16:09,376
of containerization, what are the pieces of unique data and

241
00:16:09,478 --> 00:16:12,756
where do I need to bring those in order to be successful will help

242
00:16:12,778 --> 00:16:16,516
you to be able to achieve this at scale. As we

243
00:16:16,538 --> 00:16:20,516
move into our runtime, it becomes very important that we separate our

244
00:16:20,538 --> 00:16:23,624
build from our run because we need to be able to move

245
00:16:23,662 --> 00:16:27,176
to any specific destination and we were able to do this.

246
00:16:27,278 --> 00:16:30,964
Andor in doing so, again, we can run in any cloud environment,

247
00:16:31,092 --> 00:16:34,744
we can come from any source environment. We've seen some exciting

248
00:16:34,792 --> 00:16:38,044
source environments and some very legacy ones as well. We'll talk about

249
00:16:38,082 --> 00:16:42,508
that. But the point being is that we can really do anything

250
00:16:42,594 --> 00:16:45,744
new or anything old. And so it gets exciting to really

251
00:16:45,782 --> 00:16:49,520
see this work across a very large majority of software.

252
00:16:50,500 --> 00:16:54,556
So this also allows us to understand those dependent

253
00:16:54,588 --> 00:16:57,536
relationships. Andor so certain services need to start before,

254
00:16:57,718 --> 00:17:01,204
as well as what components need to be separate. We're able to achieve that in

255
00:17:01,242 --> 00:17:04,500
the destination runtime, to go a little bit further into that.

256
00:17:04,570 --> 00:17:08,340
Again, that classification, configuration and containerization,

257
00:17:08,760 --> 00:17:11,828
those steps in the software are very unique.

258
00:17:12,004 --> 00:17:15,704
And as we gather our input and really are able

259
00:17:15,742 --> 00:17:19,160
to understand the breadcrumb artifact that we have,

260
00:17:19,310 --> 00:17:22,970
we really are able to classify that software. And again,

261
00:17:23,500 --> 00:17:27,980
our ability to provide a list of software as it exists is very straightforward because

262
00:17:28,050 --> 00:17:31,772
of this capability. And so you can really just go and select it

263
00:17:31,906 --> 00:17:35,376
as you leverage our more polished Clis and

264
00:17:35,398 --> 00:17:39,328
UIs. That ability to now that we have

265
00:17:39,414 --> 00:17:42,624
the understanding of the application, once again we're able

266
00:17:42,662 --> 00:17:45,856
to really evaluate what software language is it

267
00:17:45,878 --> 00:17:49,404
using, what is actually the libraries and dependencies,

268
00:17:49,532 --> 00:17:53,456
what are the static and dynamic variables, where is the storage,

269
00:17:53,488 --> 00:17:56,544
is it local, is it remote? And where does it belong at the destination?

270
00:17:56,592 --> 00:17:59,696
And so you've seen a very simple use of the Clive, but there's

271
00:17:59,728 --> 00:18:03,096
a lot more configuration options that can be used to ensure that you

272
00:18:03,118 --> 00:18:06,520
reach your destination in a SQL execution.

273
00:18:07,180 --> 00:18:10,472
Andor sometimes we're using this iteratively so that we can understand

274
00:18:10,526 --> 00:18:14,056
the software ourselves. So this is great for dev and tests and really understanding

275
00:18:14,088 --> 00:18:18,124
those intricates very quickly in your environment. Other times

276
00:18:18,322 --> 00:18:22,140
we are really just wanting to have a very fast

277
00:18:22,290 --> 00:18:26,092
modernization. And whether you're doing the just migrating,

278
00:18:26,156 --> 00:18:30,016
moving over from one cloud to another, modernizing, where you're actually

279
00:18:30,118 --> 00:18:33,856
using that containers artifact to achieve new technical capabilities or

280
00:18:33,878 --> 00:18:37,444
you're transforming, you're using the software to be

281
00:18:37,482 --> 00:18:40,964
able to reach new business capabilities. All of that is

282
00:18:41,002 --> 00:18:44,752
possible within this migration or modernization,

283
00:18:44,816 --> 00:18:48,452
or rather transformation. And the reason that is, is because once

284
00:18:48,506 --> 00:18:52,884
I transform now, if we can imagine much like chat GBT,

285
00:18:53,012 --> 00:18:56,452
where its inputs are able to typically

286
00:18:56,516 --> 00:18:59,528
text and the output is typically text,

287
00:18:59,694 --> 00:19:03,144
it could also be code, right? Our input

288
00:19:03,192 --> 00:19:06,952
is software, but our output is software as well. So the ability

289
00:19:07,016 --> 00:19:10,492
to put a serverless API or

290
00:19:10,546 --> 00:19:13,704
other types of constructs around this software and achieve

291
00:19:13,752 --> 00:19:17,570
new experiences for customers is also possible.

292
00:19:18,020 --> 00:19:21,536
So again, this is why we need to understand the software at this

293
00:19:21,558 --> 00:19:24,716
level of intricacy, because performance also matters.

294
00:19:24,828 --> 00:19:28,436
Our ability to scale to zero also matters. And so understanding at

295
00:19:28,458 --> 00:19:32,500
this level of granularity gets the software functioning well.

296
00:19:32,650 --> 00:19:36,992
For your personal use of BCD and just understanding that framework,

297
00:19:37,136 --> 00:19:41,056
you may not have to be able to achieve everything the software achieves,

298
00:19:41,088 --> 00:19:44,584
but your ability to understand the software in a way that ensures that you

299
00:19:44,622 --> 00:19:48,596
know how to deterministically get the software over to the destination

300
00:19:48,708 --> 00:19:52,232
is a feat in of itself. And so once again,

301
00:19:52,366 --> 00:19:55,484
when we containerize, we're able to ensure that there's proper

302
00:19:55,522 --> 00:19:59,516
instantiation, proper ordering, clustering if need be.

303
00:19:59,618 --> 00:20:03,164
That could be the clustering of a three tier web app,

304
00:20:03,202 --> 00:20:06,556
that could be the pattern of a

305
00:20:06,658 --> 00:20:09,616
scale out database, so on and so forth. So we'll talk more about that.

306
00:20:09,718 --> 00:20:12,848
But the point is that we need to understand those relationships so that we

307
00:20:12,854 --> 00:20:16,064
can achieve the scalability, so that you can

308
00:20:16,102 --> 00:20:19,472
continue to see how this framework

309
00:20:19,536 --> 00:20:23,664
is working. We want to delve deeper into the container manifest,

310
00:20:23,712 --> 00:20:27,760
and we're going to do that with an in house developed software.

311
00:20:27,920 --> 00:20:31,248
This software, again, we try to bring up

312
00:20:31,274 --> 00:20:35,304
some edge cases. There's plenty of new use cases where we've taken

313
00:20:35,422 --> 00:20:38,728
something that's been only out there for a couple of years,

314
00:20:38,814 --> 00:20:42,148
or maybe the software has been green filled. Again, code to

315
00:20:42,174 --> 00:20:45,436
container is also very exciting capabilities that we've put

316
00:20:45,458 --> 00:20:49,372
out there, but the ability to really take

317
00:20:49,426 --> 00:20:53,516
software as it exists in its current environment. In this particular case,

318
00:20:53,618 --> 00:20:58,124
this software was created 20 years ago, and every

319
00:20:58,162 --> 00:21:02,352
leveraging system vendor and everyone said it wasn't possible to be done.

320
00:21:02,486 --> 00:21:06,156
And we actually had did it a few weeks prior

321
00:21:06,188 --> 00:21:09,508
to those statements being made. And so it's exciting to see what

322
00:21:09,514 --> 00:21:13,328
you can achieve when you truly understand this, plus some of the computational truths

323
00:21:13,344 --> 00:21:17,444
that we'll go through as well. So with

324
00:21:17,642 --> 00:21:21,544
this example application, let's look at how when we take a

325
00:21:21,582 --> 00:21:24,756
software through this approach, how we're

326
00:21:24,788 --> 00:21:28,296
able to get it to its destination. And in this

327
00:21:28,318 --> 00:21:31,828
case we'll look at the destination container artifact to see

328
00:21:32,014 --> 00:21:35,372
how actually it was able to be organized by

329
00:21:35,506 --> 00:21:39,228
leveraging VCD. So here we're leveraging the broker app

330
00:21:39,314 --> 00:21:42,888
and we can see that binary Andor configuration

331
00:21:42,984 --> 00:21:46,930
allow us to evaluate the application.

332
00:21:47,380 --> 00:21:51,196
In this case we're moving the data over to Azure

333
00:21:51,228 --> 00:21:54,556
SQL and in that case we're

334
00:21:54,668 --> 00:21:58,384
recognized that ahead of time and are able to ensure that the software

335
00:21:58,432 --> 00:22:00,820
executes across that requirement.

336
00:22:02,120 --> 00:22:05,408
Here we can see that the container manifest

337
00:22:05,584 --> 00:22:09,540
is able to account for the application specific components

338
00:22:09,620 --> 00:22:14,052
as well as those that are purely configuration. This configuration

339
00:22:14,196 --> 00:22:18,196
and these pieces are unique to the instantiation

340
00:22:18,228 --> 00:22:21,508
of the software. For multiple environments we

341
00:22:21,534 --> 00:22:25,576
may need to create separate configuration and this capability

342
00:22:25,688 --> 00:22:29,416
is made possible through the BCD framework Andor evolution

343
00:22:29,448 --> 00:22:33,724
migrate. So again here we're able to see that

344
00:22:33,762 --> 00:22:37,216
the configuration is able to be tailored based on

345
00:22:37,238 --> 00:22:40,444
that and that might become variables passed through queries,

346
00:22:40,492 --> 00:22:45,120
so on and so forth. As we mature that software artifact,

347
00:22:46,420 --> 00:22:50,372
as we look at the data components of this, we can

348
00:22:50,426 --> 00:22:54,260
see that the customer specific data will reside in Azure SQL.

349
00:22:55,000 --> 00:22:58,356
We can also see that in our configuration we need

350
00:22:58,378 --> 00:23:02,152
to point to that data source and that we're able to do that really

351
00:23:02,206 --> 00:23:06,484
on the fly as a part of the BCD framework

352
00:23:06,532 --> 00:23:10,056
andor the configuration that's occurring there. And so really when

353
00:23:10,078 --> 00:23:13,916
we understand how BCD works, we can start to see how not only does

354
00:23:13,938 --> 00:23:17,596
it create a very organized way to ensure that

355
00:23:17,618 --> 00:23:22,040
the software reaches the destination, but also creates very organized manifests

356
00:23:22,120 --> 00:23:25,936
and are able to make it easy to scale in a cloud or

357
00:23:25,958 --> 00:23:30,044
Kubernetes environment. A couple of deterministic architectures

358
00:23:30,092 --> 00:23:33,504
that we could achieve for our scalability pattern. So now that we have

359
00:23:33,542 --> 00:23:37,472
our software effectively migrated, the ability

360
00:23:37,536 --> 00:23:41,376
to take that into its destination architecture

361
00:23:41,488 --> 00:23:46,304
is important and we really want that to be quite deterministic.

362
00:23:46,432 --> 00:23:50,132
Now there's many ways to scale applications and this

363
00:23:50,186 --> 00:23:53,464
doesn't limit the ability, but we'll talk about

364
00:23:53,582 --> 00:23:57,144
the use cases that really serve about the 80 to

365
00:23:57,182 --> 00:24:00,516
90 percentile of software. When you really look at the separation

366
00:24:00,548 --> 00:24:04,392
of software, we will talk about the computational

367
00:24:04,456 --> 00:24:08,172
truths that make that possible. But what's also important is to understand

368
00:24:08,226 --> 00:24:11,628
that the delineation occurs typically via a

369
00:24:11,634 --> 00:24:14,976
number of patterns that typically occurs by the application

370
00:24:15,078 --> 00:24:18,880
function, that may occur by resource demand,

371
00:24:19,300 --> 00:24:22,400
or that may occur by the component such as a package.

372
00:24:23,220 --> 00:24:27,536
What we really see here is that that ability

373
00:24:27,728 --> 00:24:31,364
to separate that application, maybe for a

374
00:24:31,402 --> 00:24:35,044
shopping cart application, we may have to separate the

375
00:24:35,082 --> 00:24:39,028
component that is the actual product

376
00:24:39,114 --> 00:24:41,860
library. And so those may be separate components,

377
00:24:41,940 --> 00:24:45,016
whether they're in an application that was made

378
00:24:45,038 --> 00:24:49,016
in a macro way or it was separated in its own native services from

379
00:24:49,038 --> 00:24:53,176
the beginning. Understanding that relationship will ensure that when we scale

380
00:24:53,288 --> 00:24:56,700
specific instances or components, that we're scaling for that capability.

381
00:24:57,840 --> 00:25:00,540
When we look at the actual resource demand,

382
00:25:01,120 --> 00:25:04,844
we look at scalability based on its

383
00:25:05,042 --> 00:25:08,364
hardware demand. So that can be cp, memory, disk, network,

384
00:25:08,492 --> 00:25:11,856
and really ensuring that we're able to leverage the

385
00:25:11,878 --> 00:25:15,264
right architecture pattern based on that. And last but not least,

386
00:25:15,302 --> 00:25:18,660
to get a package. So something as simple as NgInX,

387
00:25:19,480 --> 00:25:23,200
maybe it needs to be separated or scaled independently

388
00:25:23,280 --> 00:25:27,190
to achieve the level of demand coming to the actual

389
00:25:27,640 --> 00:25:31,108
end component. In the

390
00:25:31,114 --> 00:25:34,776
case of the application function, we can see that there might be

391
00:25:34,798 --> 00:25:38,376
a multiplicative relationship where let's talk about if

392
00:25:38,398 --> 00:25:42,104
it's an app WebDB, we might scale the application Andor Web service more

393
00:25:42,142 --> 00:25:45,544
than we scale the database Andor in those relationships,

394
00:25:45,592 --> 00:25:49,052
we understand our scalability pattern. We can use deployments and services

395
00:25:49,186 --> 00:25:53,448
to really ensure that those reach the correct destination

396
00:25:53,544 --> 00:25:57,168
Andor architecture. When looking at

397
00:25:57,254 --> 00:26:01,020
the actual resource demand, we recognize

398
00:26:01,100 --> 00:26:04,384
that we may need to create another instance based on,

399
00:26:04,422 --> 00:26:08,196
or another 100 instances based on resource demand. But really we

400
00:26:08,218 --> 00:26:12,324
can depend on our infrastructure components to do that. And so

401
00:26:12,442 --> 00:26:16,656
we might leverage a pod autoscaler to ensure that it's continuously

402
00:26:16,688 --> 00:26:20,864
meeting resource demand. When we look at the

403
00:26:20,922 --> 00:26:24,344
actual separation by component, again, this is just an

404
00:26:24,382 --> 00:26:28,356
m plus one pattern where the deployment count may be what's being changed

405
00:26:28,388 --> 00:26:30,980
to ensure that we reach our destination.

406
00:26:31,140 --> 00:26:34,840
And really this simplicity of component,

407
00:26:35,000 --> 00:26:38,844
this may also be the case in a scale out database where you're trying

408
00:26:38,882 --> 00:26:42,504
to achieve quorum and you need to ensure that there is a minimum

409
00:26:42,552 --> 00:26:46,320
amount or odd number to ensure that you reach that.

410
00:26:46,390 --> 00:26:49,616
So again, no matter what the requirements of

411
00:26:49,638 --> 00:26:53,100
a topology, we can achieve this by understanding the scalability

412
00:26:53,180 --> 00:26:57,108
pattern and leveraging the framework to ensure that

413
00:26:57,194 --> 00:27:00,580
the end resulting manifest will achieve this capability.

414
00:27:02,600 --> 00:27:06,004
Now for a few computational truths and what

415
00:27:06,042 --> 00:27:09,572
we recognize when we're really trying

416
00:27:09,626 --> 00:27:13,640
to do these modernizations, we've come across so many scenarios where

417
00:27:13,790 --> 00:27:17,880
someone has said, hey, this is impossible, it can't be done, or there have been

418
00:27:17,950 --> 00:27:21,416
vendors, the Andor who created the software says it can't be

419
00:27:21,438 --> 00:27:25,508
done. Or even companies have spent over twelve months trying

420
00:27:25,534 --> 00:27:27,790
to do it and say look, this is just not possible.

421
00:27:28,240 --> 00:27:31,516
And in these cases we kind of love these obviously.

422
00:27:31,618 --> 00:27:34,944
But what's most important is when you come across these roadblocks is

423
00:27:34,982 --> 00:27:38,416
how you approach the problem. And what we see is

424
00:27:38,438 --> 00:27:41,536
that typically networking Andor security will be the

425
00:27:41,558 --> 00:27:46,476
biggest blocker. So you do have to understand how

426
00:27:46,518 --> 00:27:50,404
to overcome those gaps. Typically the easiest way to do that is

427
00:27:50,442 --> 00:27:53,392
by understanding how it works in a destination environment.

428
00:27:53,536 --> 00:27:56,944
Typically Andor our Kubernetes architectures,

429
00:27:57,072 --> 00:28:00,424
Andor our cloud native architectures are quite mature. So they are

430
00:28:00,462 --> 00:28:03,908
able to achieve every bit of security and communications

431
00:28:04,004 --> 00:28:07,704
scalability that any previous environment, but also

432
00:28:07,822 --> 00:28:11,688
by looking at it through OSI. Now OSI basically

433
00:28:11,774 --> 00:28:14,920
states that any two disparate systems can communicate.

434
00:28:15,080 --> 00:28:18,716
When we look at OSI we recognize, and some may know

435
00:28:18,738 --> 00:28:21,912
this as physical data link, network, transport, session presentation,

436
00:28:21,976 --> 00:28:24,860
application or please do not throw sausage pizza away,

437
00:28:24,930 --> 00:28:28,092
however you remember it, just remember that whenever

438
00:28:28,156 --> 00:28:32,096
you're looking at software going from source to destination to understand how

439
00:28:32,118 --> 00:28:35,200
is it achieved in the source and how is it achieved in destination.

440
00:28:35,620 --> 00:28:38,956
Now when we look at this, and this is actually how evolution

441
00:28:38,988 --> 00:28:42,950
migrate implements VCD is, it creates native translation maps across

442
00:28:43,400 --> 00:28:47,216
those layers. Andor so we know how something is supposed to behave in its source,

443
00:28:47,248 --> 00:28:49,648
we know how it's supposed to behave in a destination and it's how we can

444
00:28:49,674 --> 00:28:53,464
achieve that scale. And so this again might be valuable for

445
00:28:53,502 --> 00:28:55,800
you as you reach that capability.

446
00:28:56,860 --> 00:29:00,404
The other big thing that we find informs how we leverage

447
00:29:00,452 --> 00:29:04,620
this framework to modernize is really in

448
00:29:04,770 --> 00:29:10,200
the relationships between components. And whether this is interrelationships

449
00:29:10,280 --> 00:29:14,620
between networked components or networked applications or intra,

450
00:29:14,960 --> 00:29:18,272
this might be IPC calls that are happening

451
00:29:18,326 --> 00:29:22,064
inside the software. We can understand those things in order to ensure that

452
00:29:22,102 --> 00:29:25,836
when they reach their destination, they're not only in a container artifact,

453
00:29:25,868 --> 00:29:29,776
but they're also able to meet the correct scalability pattern. And so when you're parsing

454
00:29:29,808 --> 00:29:32,948
your own configuration, it might be helpful to understand what are

455
00:29:32,954 --> 00:29:37,008
the relationships occurring in this software, between software and really focusing

456
00:29:37,024 --> 00:29:40,608
on that to understand the scalability patterns. Andor last

457
00:29:40,634 --> 00:29:44,676
but not least, understanding operating systems are abstractions.

458
00:29:44,868 --> 00:29:48,264
When we start to look at an operating system we

459
00:29:48,302 --> 00:29:51,664
typically say, oh, it's impossible because of what's been supported on this operating

460
00:29:51,732 --> 00:29:55,052
system. And it's very interesting

461
00:29:55,106 --> 00:29:58,732
to see that operating systems and our developers here have worked for many

462
00:29:58,786 --> 00:30:02,056
years to ensure that there is compatibility

463
00:30:02,168 --> 00:30:06,288
across kernels. Andor really the relationship

464
00:30:06,374 --> 00:30:09,904
between those packages and interfaces are there.

465
00:30:09,942 --> 00:30:13,552
And so understanding a little bit about how those

466
00:30:13,606 --> 00:30:16,912
work is very valuable. And it really is

467
00:30:16,966 --> 00:30:20,416
why whenever you look at the actual attempts

468
00:30:20,448 --> 00:30:23,830
to modernize, you're able to achieve a lot of that across

469
00:30:24,200 --> 00:30:27,876
these capabilities. So OS and software modernization are

470
00:30:27,898 --> 00:30:31,736
key parts of digital transformation, and being able to

471
00:30:31,918 --> 00:30:35,144
achieve that capability at scale is very important and very

472
00:30:35,182 --> 00:30:38,788
valuable. Again, the key piece here is when you're

473
00:30:38,804 --> 00:30:42,584
looking at the leveraging system, look at it less as this

474
00:30:42,622 --> 00:30:46,348
black box, which you can't change, and look at it more about

475
00:30:46,514 --> 00:30:50,028
like it's an interface andor a set of packages and capabilities that

476
00:30:50,114 --> 00:30:53,876
must be complied to. Typically in our regression

477
00:30:53,928 --> 00:30:57,472
testing, we're able to show that everything, end to end,

478
00:30:57,526 --> 00:31:01,104
will be successful. Last but

479
00:31:01,142 --> 00:31:04,944
not least, let's talk about some of the scalability patterns that

480
00:31:05,062 --> 00:31:08,564
exist for when we move our

481
00:31:08,602 --> 00:31:12,096
software into the destination artifact. So there's

482
00:31:12,128 --> 00:31:15,952
many different outcomes that we can achieve now that we understand the software,

483
00:31:16,096 --> 00:31:19,972
so intricacy that we're mobilizing to its next generation

484
00:31:20,036 --> 00:31:23,604
platform or across cloud environments. We typically

485
00:31:23,652 --> 00:31:27,432
see this in the area of just enterprise digital transformation, where we might

486
00:31:27,486 --> 00:31:30,600
want to achieve software or OS modernization,

487
00:31:30,940 --> 00:31:34,380
and really ensuring that we're getting to support

488
00:31:34,450 --> 00:31:38,360
it in latest versions are possible. As far as edge computing,

489
00:31:38,440 --> 00:31:41,964
when we look at things such as multi access, edge compute and its

490
00:31:42,002 --> 00:31:46,096
requirements to understand latency, we start to understand how we can create

491
00:31:46,198 --> 00:31:49,632
distributed workloads. We start to understand how we can

492
00:31:49,766 --> 00:31:53,280
actually take the software. Maybe for the data

493
00:31:53,350 --> 00:31:57,184
component or database component, we may be putting a

494
00:31:57,302 --> 00:32:01,008
read only replica at the edge and allowing for right pastures

495
00:32:01,184 --> 00:32:05,184
to occur. And so really ensuring that we're meeting the latency sensitive

496
00:32:05,232 --> 00:32:09,348
nature of the application is possible. Now, sometimes this means that

497
00:32:09,434 --> 00:32:13,092
the software may not be able to play as a cloud

498
00:32:13,146 --> 00:32:17,424
native application, but it can participate in a cloud native environment.

499
00:32:17,552 --> 00:32:20,804
And so again, these types of capabilities are

500
00:32:20,842 --> 00:32:24,108
very important to accelerating the rate at which we can

501
00:32:24,194 --> 00:32:27,800
leverage software in distributed environments such as the edge.

