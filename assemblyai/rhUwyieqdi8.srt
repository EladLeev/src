1
00:00:25,410 --> 00:00:29,506
You. Hello everyone, I am hamidarabay.

2
00:00:29,618 --> 00:00:33,270
Thank you for joining me today in Conf 42 and welcome

3
00:00:33,340 --> 00:00:37,426
to my talk about architecting dotted microservices in Docker

4
00:00:37,458 --> 00:00:41,794
ecosystem. So who I am? I am Microsoft MVP,

5
00:00:41,842 --> 00:00:44,082
MVP, MVP. MVP. MVP. MVP.

6
00:00:44,146 --> 00:00:48,130
MVP in developer technologies speaker in doubt. Net foundation.

7
00:00:48,290 --> 00:00:52,030
I'm also MCT Edge certified and book

8
00:00:52,100 --> 00:00:56,014
author. You can follow me on mittenblog, LinkedIn, YouTube or

9
00:00:56,052 --> 00:00:59,834
Twitter. Today we will talk about microservices

10
00:00:59,962 --> 00:01:03,682
architecture, container and Docker. We will

11
00:01:03,736 --> 00:01:07,278
see the difference between Docker, container, Docker image.

12
00:01:07,374 --> 00:01:10,770
We will set up our development environments

13
00:01:11,350 --> 00:01:14,622
to be able to test some demonstrations.

14
00:01:14,766 --> 00:01:18,034
So what is microservices architectures?

15
00:01:18,162 --> 00:01:21,590
Microservices are the natural evolution of service

16
00:01:21,660 --> 00:01:25,762
oriented architectures. But there are difference between microservices

17
00:01:25,826 --> 00:01:29,162
and service oriented architecture. So we can talk about

18
00:01:29,296 --> 00:01:33,110
some characteristics related to microservices.

19
00:01:33,270 --> 00:01:37,402
In microservices architecture, services are small,

20
00:01:37,536 --> 00:01:40,862
independent and loosely coupled. Each service

21
00:01:40,996 --> 00:01:44,142
is separate code base which

22
00:01:44,196 --> 00:01:47,406
can be managed by a small development team.

23
00:01:47,508 --> 00:01:50,862
All services can be deployed independently. A team

24
00:01:50,916 --> 00:01:54,706
can update an existing service without rebuilding and

25
00:01:54,808 --> 00:01:59,230
deploying the entire application. Services are responsible

26
00:01:59,310 --> 00:02:03,730
for persisting their own data or any external state.

27
00:02:03,880 --> 00:02:07,682
This differs from the traditional model where a separate

28
00:02:07,746 --> 00:02:11,042
data layer handles data persistence.

29
00:02:11,186 --> 00:02:15,842
Services communicate with each other by using welldefined

30
00:02:15,986 --> 00:02:19,426
APIs. Internal implementation details

31
00:02:19,458 --> 00:02:23,114
of each service are hidden from other services.

32
00:02:23,312 --> 00:02:26,746
Services don't need to share the same technology step

33
00:02:26,848 --> 00:02:30,574
libraries or frameworks. Besides for the

34
00:02:30,612 --> 00:02:34,666
services themselves, some other components appears

35
00:02:34,778 --> 00:02:39,006
in typical microservices architecture, management of

36
00:02:39,028 --> 00:02:42,618
the component is responsible for placing services

37
00:02:42,724 --> 00:02:45,758
on nodes, identifying failures,

38
00:02:45,934 --> 00:02:49,614
rebalancing services across nodes, and so forth.

39
00:02:49,742 --> 00:02:53,710
We can talk about the different elements

40
00:02:53,790 --> 00:02:57,202
related to microservices like service discovery

41
00:02:57,266 --> 00:03:01,202
that maintain a list of services and which nodes

42
00:03:01,346 --> 00:03:05,698
they are located on. It enables service lookup

43
00:03:05,794 --> 00:03:09,514
to find the endpoint for a service. When we talk

44
00:03:09,552 --> 00:03:13,174
about microservices architectures, we have another important element

45
00:03:13,222 --> 00:03:16,854
to understand that is API Gateway. That is the entry

46
00:03:16,902 --> 00:03:19,770
point for all the entire clients.

47
00:03:20,210 --> 00:03:24,442
Developers consider microservices as an architectural

48
00:03:24,506 --> 00:03:28,526
style that promotes the development of complex applications

49
00:03:28,708 --> 00:03:32,606
as a suite of small services based on business

50
00:03:32,708 --> 00:03:36,926
capabilities and multiple independent subsystems

51
00:03:37,038 --> 00:03:40,514
in the form of can autonomous services.

52
00:03:40,712 --> 00:03:44,794
The following pictures shows the microservices

53
00:03:44,942 --> 00:03:48,850
architecture style. There are various components

54
00:03:48,930 --> 00:03:52,658
in a microservices architectures apart from the microservices

55
00:03:52,754 --> 00:03:56,742
themselves. So we'll start talking about the management part

56
00:03:56,796 --> 00:04:00,314
that maintain the nodes for the services. We have

57
00:04:00,352 --> 00:04:03,814
also identity provider that manage the identity

58
00:04:03,862 --> 00:04:07,738
information and provides authentication services within

59
00:04:07,824 --> 00:04:11,918
a distributed network. Service discovery keeps track

60
00:04:12,004 --> 00:04:15,886
of services and service addresses and endpoints. Here we

61
00:04:15,908 --> 00:04:19,598
have the API gateway. It serves a client's entry point,

62
00:04:19,684 --> 00:04:23,502
the single point of contact from the client,

63
00:04:23,646 --> 00:04:27,742
which in turn returns responses from underlying

64
00:04:27,806 --> 00:04:31,118
microservices and sometimes an aggregated

65
00:04:31,214 --> 00:04:34,826
response from multiple underlying microservices.

66
00:04:34,958 --> 00:04:38,454
An API gateway sits between the clients and the

67
00:04:38,492 --> 00:04:42,146
services. It acts as reverse proxy,

68
00:04:42,258 --> 00:04:45,430
routing requests from clients to services.

69
00:04:45,580 --> 00:04:49,690
It may also perform various cross cutting tasks such as

70
00:04:49,760 --> 00:04:53,878
authentication, SSL termination, and braid

71
00:04:53,974 --> 00:04:58,090
limiting. If you don't deploy gateway, clients must send

72
00:04:58,160 --> 00:05:02,062
requests directly. Two front end services it

73
00:05:02,116 --> 00:05:05,406
creates coupling between the client and the

74
00:05:05,428 --> 00:05:09,086
backends. The client needs to know how

75
00:05:09,108 --> 00:05:12,042
the individual services are decomposed.

76
00:05:12,186 --> 00:05:15,794
That makes it harder to maintain the client and

77
00:05:15,832 --> 00:05:19,842
also harder to refactor services. So the API gateway can

78
00:05:19,896 --> 00:05:23,666
perform other cross cutting functions, as we

79
00:05:23,688 --> 00:05:27,826
said before, like authentication, logging, SSL termination

80
00:05:27,938 --> 00:05:31,746
and load balancing. Let's now understand the role

81
00:05:31,778 --> 00:05:35,858
of an architect. An architect will define the software architectures

82
00:05:35,954 --> 00:05:39,702
of a computing system that presents a set of structures needed

83
00:05:39,756 --> 00:05:44,086
to reason above, a system which comprises software elements,

84
00:05:44,198 --> 00:05:48,406
relations among them, and the properties of both. This architecture

85
00:05:48,438 --> 00:05:52,422
should meet the nonfunctional requirements in development

86
00:05:52,486 --> 00:05:56,250
like maintainability, the stability, all deployability,

87
00:05:56,410 --> 00:06:00,714
and in runtime like scalability, performance and availability.

88
00:06:00,842 --> 00:06:03,986
The microservices architectures offer

89
00:06:04,168 --> 00:06:08,654
tremendous benefits, but it's not a silver bullet.

90
00:06:08,782 --> 00:06:12,386
It also has some significant drawbacks, and the

91
00:06:12,408 --> 00:06:16,502
microservices pattern languages is a collection of patterns that

92
00:06:16,556 --> 00:06:20,306
solve architectures, design development and operational

93
00:06:20,418 --> 00:06:23,794
problems. It enables software developers

94
00:06:23,842 --> 00:06:27,406
to apply the microservices architecture effectively.

95
00:06:27,538 --> 00:06:31,318
Containers combine an Apple plus, its configuration

96
00:06:31,414 --> 00:06:35,382
and dependency into a single, independently deployable

97
00:06:35,446 --> 00:06:39,366
units. Containers are an excellent fit for bundling

98
00:06:39,478 --> 00:06:42,506
and deploying independent microservices.

99
00:06:42,698 --> 00:06:45,338
Let's learn more about containers.

100
00:06:45,514 --> 00:06:49,194
Containerization is an approach to software development

101
00:06:49,322 --> 00:06:53,106
in which an application or service, its dependency and

102
00:06:53,128 --> 00:06:56,626
its configuration are packaged together as a

103
00:06:56,648 --> 00:07:00,446
container image. The configuration can be abstracted

104
00:07:00,478 --> 00:07:04,786
as deployment manifestoise. For example, the containerized application

105
00:07:04,888 --> 00:07:09,186
can be tested as a unit and deployed as a container image instance

106
00:07:09,298 --> 00:07:12,882
to the host operating system. Just as shipping

107
00:07:12,946 --> 00:07:16,274
container allow goods to be transported by sheep,

108
00:07:16,322 --> 00:07:20,290
train or truck, regardless of the cargo inside.

109
00:07:20,460 --> 00:07:23,546
Software containers act as a standard unit of

110
00:07:23,568 --> 00:07:27,322
software deploying that can container different code

111
00:07:27,376 --> 00:07:31,022
and dependency. Containerizing of software this way

112
00:07:31,076 --> 00:07:34,794
enables developers and it professionals to deploy

113
00:07:34,842 --> 00:07:38,778
them across environments with little or no modification.

114
00:07:38,954 --> 00:07:42,882
Containers also isolate application from

115
00:07:42,936 --> 00:07:45,970
each other on a shared operating system.

116
00:07:46,120 --> 00:07:49,714
Containerbased applications run on top of

117
00:07:49,752 --> 00:07:53,474
a container hosted that in turn runs on the

118
00:07:53,512 --> 00:07:56,598
operating system, Linux or Windows, for example.

119
00:07:56,764 --> 00:08:00,770
Containers therefore have significantly smaller footprint

120
00:08:00,850 --> 00:08:04,950
than virtual machine images. Each container can run

121
00:08:05,020 --> 00:08:08,666
a wall web application or a service as shown in

122
00:08:08,688 --> 00:08:12,122
this picture. We have some examples here.

123
00:08:12,176 --> 00:08:16,026
In Docker a container host, we can run the

124
00:08:16,048 --> 00:08:19,306
first application, another application, a service,

125
00:08:19,408 --> 00:08:22,894
and another service, for example. Another benefit of

126
00:08:22,932 --> 00:08:26,750
a containerization is scalability. You can scale out

127
00:08:26,820 --> 00:08:31,210
quickly by creating new containers for short term tasks.

128
00:08:31,370 --> 00:08:35,086
From an application point of view, instantiating an image it's

129
00:08:35,118 --> 00:08:38,834
like creating a container is similar to instantiating a

130
00:08:38,872 --> 00:08:42,434
process like service or web app for

131
00:08:42,472 --> 00:08:46,406
reliability. However, when you run multiple instance of

132
00:08:46,428 --> 00:08:50,306
the same image across multiple host server, you typically

133
00:08:50,418 --> 00:08:54,246
want each container image instance to run in

134
00:08:54,268 --> 00:08:57,878
a different host server or between machine in different

135
00:08:57,964 --> 00:09:01,814
fold domains. In short, containers offer the benefit

136
00:09:01,862 --> 00:09:04,662
of isolation, portability, agility,

137
00:09:04,806 --> 00:09:08,794
scalability and control across the wall application

138
00:09:08,992 --> 00:09:12,086
lifecycle or flow. The most important definite

139
00:09:12,118 --> 00:09:16,526
benefits is the environments as solutions between

140
00:09:16,628 --> 00:09:20,766
the dev and the operations. What is the difference between

141
00:09:20,868 --> 00:09:24,034
Docker container and Docker image? Let's start by

142
00:09:24,072 --> 00:09:28,190
Docker container. Docker container is virtualized runtime environment

143
00:09:28,350 --> 00:09:32,494
used in application developments. As we mentioned before in the definition

144
00:09:32,542 --> 00:09:35,650
of Docker, with Docker, we are able to create, run,

145
00:09:35,720 --> 00:09:39,142
and deploy applications that are isolated from

146
00:09:39,196 --> 00:09:42,582
the deploying hardware. A docker container can

147
00:09:42,636 --> 00:09:46,962
use just one machine, share its kernel, and virtualize

148
00:09:47,026 --> 00:09:51,142
the operating system to run more isolated processes.

149
00:09:51,286 --> 00:09:54,486
So docker containers are lightweight.

150
00:09:54,678 --> 00:09:58,346
Docker image is like a snapshot in other types of

151
00:09:58,368 --> 00:10:02,158
virtual machine environments, it's a record of

152
00:10:02,244 --> 00:10:06,522
Docker container at a specific point in time. Docker images

153
00:10:06,586 --> 00:10:10,234
are also immutable. Why? They can't be changed,

154
00:10:10,362 --> 00:10:14,510
they can be duplicated, shared or deleted.

155
00:10:14,870 --> 00:10:18,274
The feature is useful for testing new software or

156
00:10:18,312 --> 00:10:21,854
configurations because whatever happens, the image

157
00:10:21,902 --> 00:10:26,226
remains and changes. Containers require the existing runnable

158
00:10:26,258 --> 00:10:30,562
images. Two exist. They are independent on images

159
00:10:30,626 --> 00:10:33,954
because they are used to construct runtime

160
00:10:34,002 --> 00:10:36,600
environments and are needed to run an application.

161
00:10:37,390 --> 00:10:40,886
You might want to use Docker containers just to simplify

162
00:10:41,078 --> 00:10:44,726
deployments. Even if you are not creating microservices,

163
00:10:44,918 --> 00:10:48,294
for example, perhaps you want to improve your DevOps.

164
00:10:48,342 --> 00:10:52,602
Workflow with Docker containers can give you better isolated

165
00:10:52,666 --> 00:10:56,442
test environments and can also eliminate

166
00:10:56,586 --> 00:11:00,138
deploying issues caused by missing dependency

167
00:11:00,234 --> 00:11:03,922
when you move to production environments. In cases like

168
00:11:03,976 --> 00:11:08,034
this, even if you are deploying a monolithic applications,

169
00:11:08,232 --> 00:11:11,954
it makes sense to use Docker and Windows containers for

170
00:11:11,992 --> 00:11:15,574
your current. NET framework applications in

171
00:11:15,612 --> 00:11:19,462
most cases. For this scenario, you will not

172
00:11:19,516 --> 00:11:22,630
need to migrate your existing application to.

173
00:11:22,700 --> 00:11:26,258
NET six or seven. You can use Docker containers

174
00:11:26,354 --> 00:11:29,866
that include the traditional. NET framework. However,

175
00:11:30,048 --> 00:11:33,766
a recommended approach is to use the latest version

176
00:11:33,798 --> 00:11:37,962
of. NET six or seven in our case, as you extend an

177
00:11:38,016 --> 00:11:41,530
existing application such as writing a new

178
00:11:41,600 --> 00:11:45,034
service in SP net core. Let's prepare

179
00:11:45,082 --> 00:11:48,542
our environment for running containers locally and

180
00:11:48,596 --> 00:11:52,190
for that we need to follow all these steps.

181
00:11:52,770 --> 00:11:56,418
We need to install Docker desktop. It's free and it's available

182
00:11:56,584 --> 00:12:00,434
for Mac and Windows. Use this link to be able to

183
00:12:00,472 --> 00:12:04,770
install the latest version of Docker desktop with the latest updates.

184
00:12:05,190 --> 00:12:09,094
So we can open Docker.com and we

185
00:12:09,132 --> 00:12:12,662
can click download Docker desktop here we can

186
00:12:12,716 --> 00:12:16,450
install it on Windows, Linux or macOS.

187
00:12:16,610 --> 00:12:20,634
We need to install Visual Studio 2019 or

188
00:12:20,672 --> 00:12:24,314
the latest version 2022. We can also use

189
00:12:24,352 --> 00:12:27,962
visual Studio code and two do that we will go to

190
00:12:28,016 --> 00:12:31,358
the website of Visual Studio and

191
00:12:31,444 --> 00:12:34,814
here we will use Visual Studio Microsoft.com.

192
00:12:34,932 --> 00:12:39,134
Here we can select Visual Studio. We have many

193
00:12:39,332 --> 00:12:43,426
version, we can use community version, it's really free and we

194
00:12:43,448 --> 00:12:47,186
have professional enterprise but in our demo we

195
00:12:47,208 --> 00:12:50,674
can use only community version. We have also

196
00:12:50,712 --> 00:12:54,638
visual studio for macOS, for the environment of macOS

197
00:12:54,814 --> 00:12:58,534
and here we can download visual studio code and

198
00:12:58,572 --> 00:13:03,190
it's available for Windows, macOS and also for Linux.

199
00:13:03,690 --> 00:13:07,526
We need to have an Azure account where we are able to

200
00:13:07,548 --> 00:13:11,178
create an Azure container registry and every other

201
00:13:11,264 --> 00:13:15,206
Azure services. We will use Powershell in Windows

202
00:13:15,318 --> 00:13:18,986
or Azure cloud shell using direct link. You need

203
00:13:19,008 --> 00:13:23,182
to open your browser shell azure.com

204
00:13:23,316 --> 00:13:26,746
else you select the cloud shell icon on the Azure

205
00:13:26,778 --> 00:13:30,286
portal. We will see that in Azure after if

206
00:13:30,308 --> 00:13:34,290
you are using visual studio code, don't forget to add the different

207
00:13:34,360 --> 00:13:37,614
extensions like Microsoft C sharp for visual

208
00:13:37,662 --> 00:13:41,294
studio code, Docker extension and Azure

209
00:13:41,342 --> 00:13:45,074
app service extension must be unsteaded. As soon as

210
00:13:45,112 --> 00:13:48,582
our environment is ready, we will start with the first step

211
00:13:48,636 --> 00:13:52,102
which is the creation of a docker image of a web

212
00:13:52,156 --> 00:13:55,794
application that we will create from an existing visual studio

213
00:13:55,842 --> 00:13:59,238
template. This is the demonstration flow.

214
00:13:59,334 --> 00:14:03,030
We start by creating and building Docker image.

215
00:14:03,190 --> 00:14:07,338
We will see two methods, the first one using visual studio and

216
00:14:07,344 --> 00:14:11,202
the second using Docker command liner.

217
00:14:11,286 --> 00:14:14,798
After we will tag and pull the image locally and in the end

218
00:14:14,884 --> 00:14:18,346
we will build and store images using Azure container

219
00:14:18,378 --> 00:14:21,678
registry docker app and we will start

220
00:14:21,844 --> 00:14:25,934
discovering Azure container apps. After installing Docker

221
00:14:25,982 --> 00:14:29,522
desktop we will open it. It should be

222
00:14:29,576 --> 00:14:32,738
running. As you can see here the engine is running.

223
00:14:32,904 --> 00:14:36,606
Here we have a list of containers that we will create it

224
00:14:36,648 --> 00:14:40,262
and here we have a list of images. If you need to see more

225
00:14:40,316 --> 00:14:43,702
about the different settings, you click just

226
00:14:43,756 --> 00:14:47,480
here in this icon and you have all information

227
00:14:48,250 --> 00:14:51,782
needed for Dockering giant. If you needed to enable

228
00:14:51,846 --> 00:14:55,462
kubernetes you just select here the different extension.

229
00:14:55,526 --> 00:14:58,794
For example here I enable docker extension. The use

230
00:14:58,832 --> 00:15:02,942
of this extension and here we have general information

231
00:15:03,076 --> 00:15:06,414
related general settings related to

232
00:15:06,452 --> 00:15:11,226
Docker desktop. Now we will open visual studio.

233
00:15:11,418 --> 00:15:14,480
This is visual Studio and we will create a. NEt project.

234
00:15:15,730 --> 00:15:19,598
We will select this template ASp. NEt core web API

235
00:15:19,694 --> 00:15:23,506
we can select web API for example, but in our

236
00:15:23,528 --> 00:15:27,110
case we select just web API. We select next.

237
00:15:27,180 --> 00:15:30,934
Here we give a name to our application. We identify the

238
00:15:30,972 --> 00:15:34,678
location of our application and we will select after

239
00:15:34,764 --> 00:15:38,326
next and I select here next.

240
00:15:38,508 --> 00:15:41,850
Here we have to select the framework. It can be.

241
00:15:41,920 --> 00:15:45,702
Net six or. Net seven for example we select the latest version

242
00:15:45,766 --> 00:15:50,018
of. NET framework. I will disable the configuration

243
00:15:50,134 --> 00:15:53,882
for HTTPs. Here we are able to enable Docker

244
00:15:53,946 --> 00:15:57,422
or not. If it's not enabled, we can

245
00:15:57,556 --> 00:16:01,406
also add our Docker file. We see that after

246
00:16:01,508 --> 00:16:05,518
but I will keep it enabled. We will select the docker

247
00:16:05,614 --> 00:16:09,090
operating system, Linux or Windows after

248
00:16:09,160 --> 00:16:12,706
we select create button to be

249
00:16:12,728 --> 00:16:16,130
able to create our application. So the first

250
00:16:16,200 --> 00:16:19,826
demo consists on building a docker image. We will use we

251
00:16:19,848 --> 00:16:23,606
just showed you the previous solution that we

252
00:16:23,628 --> 00:16:27,346
created. The web application that we created we will use also visual

253
00:16:27,378 --> 00:16:30,906
studio core. Let's start. Now we come back

254
00:16:31,008 --> 00:16:34,486
to our solution. In our conference

255
00:16:34,518 --> 00:16:37,914
managing project we have Docker file that

256
00:16:37,952 --> 00:16:41,966
is generated automatically. As you can see here.

257
00:16:42,068 --> 00:16:46,222
We can add this file just by

258
00:16:46,356 --> 00:16:49,310
right click on the solution. It's really simple.

259
00:16:49,460 --> 00:16:53,326
We select add and we select Docker

260
00:16:53,358 --> 00:16:56,654
support. Here we select the target Linux

261
00:16:56,702 --> 00:16:59,858
operating system or Windows and we click on

262
00:16:59,944 --> 00:17:03,780
ok and the file can be generated also if

263
00:17:04,230 --> 00:17:07,558
we didn't enable the Docker support when

264
00:17:07,644 --> 00:17:11,478
we created our solution or if we want to add

265
00:17:11,644 --> 00:17:15,462
Docker file to containerize our solution in

266
00:17:15,596 --> 00:17:19,718
an old application. So let's try to discover

267
00:17:19,814 --> 00:17:23,002
this docker file. We will start from this

268
00:17:23,056 --> 00:17:26,618
line from Microsoft.com.

269
00:17:26,784 --> 00:17:30,254
Net SDK seven to tell Docker what

270
00:17:30,292 --> 00:17:33,760
image we would like to use to build our application.

271
00:17:34,130 --> 00:17:37,262
Docker images can be inherited from other

272
00:17:37,316 --> 00:17:41,182
images. Therefore instead of creating our own

273
00:17:41,236 --> 00:17:44,802
image, we will use the official. Net SDK image that

274
00:17:44,856 --> 00:17:49,220
already has all the tools and packages that we need to build

275
00:17:49,590 --> 00:17:53,102
a. Net application. We will use multistage

276
00:17:53,166 --> 00:17:56,998
build as defined stage for building

277
00:17:57,084 --> 00:18:00,930
the web application. We define build stage

278
00:18:01,010 --> 00:18:05,110
in our docker file using us to make things easier when

279
00:18:05,180 --> 00:18:08,634
running the rest of the comments we will use

280
00:18:08,752 --> 00:18:12,810
workteer with the source to create

281
00:18:12,960 --> 00:18:17,606
working directory for our source files. This instructs udoker

282
00:18:17,638 --> 00:18:21,354
to use this path as the default location for all subsequent

283
00:18:21,402 --> 00:18:24,686
commands. By doing this we do not have type

284
00:18:24,788 --> 00:18:28,794
out full file paths, but can use relative

285
00:18:28,842 --> 00:18:32,078
paths based on the working directory also

286
00:18:32,164 --> 00:18:35,934
not necessary. The comments below will make a copy

287
00:18:35,982 --> 00:18:40,718
here only the CS project files and then runnet

288
00:18:40,814 --> 00:18:44,546
restore. Each comment creates a new container layers to

289
00:18:44,568 --> 00:18:48,418
speed the building of containers. Docker caches these layers.

290
00:18:48,514 --> 00:18:52,178
Since these files won't change often, we can take advantage

291
00:18:52,274 --> 00:18:55,606
of the caching by copying these files and running

292
00:18:55,708 --> 00:18:58,570
restore as separate comments.

293
00:18:59,070 --> 00:19:02,346
Next we will need to copy all the

294
00:19:02,368 --> 00:19:05,754
rest of our source files into

295
00:19:05,792 --> 00:19:10,234
the image. This line below is copy the files here

296
00:19:10,432 --> 00:19:14,510
from the source directory on your local machine to directory called

297
00:19:14,580 --> 00:19:18,814
source in the images in the local so we keep the

298
00:19:18,852 --> 00:19:22,810
copy locally and here. In the end we need to run

299
00:19:22,980 --> 00:19:26,900
net publish command line to build our project.

300
00:19:27,270 --> 00:19:30,574
Let's go back to the first line. We will specify

301
00:19:30,622 --> 00:19:34,500
the image that we will use two run our application

302
00:19:34,950 --> 00:19:38,630
and we will define our runtime stage.

303
00:19:38,970 --> 00:19:42,642
We will specify the working directory at this stage

304
00:19:42,706 --> 00:19:46,962
also and we will expose the poor

305
00:19:47,026 --> 00:19:50,710
80 to incoming requests.

306
00:19:51,530 --> 00:19:55,674
We will use entry point to tell Docker what command we

307
00:19:55,712 --> 00:19:59,762
want to run when our image is executed inside the container.

308
00:19:59,926 --> 00:20:03,758
We do this using the. Net here

309
00:20:03,924 --> 00:20:07,534
and our dll of the solution as you can see

310
00:20:07,572 --> 00:20:11,022
here and to make your build context as more

311
00:20:11,076 --> 00:20:15,006
as possible. We have inside this docker docker

312
00:20:15,038 --> 00:20:18,626
ignore that includes all these

313
00:20:18,808 --> 00:20:22,482
folders. Now to build our image. It's really

314
00:20:22,536 --> 00:20:26,070
simple. We just select here

315
00:20:26,140 --> 00:20:29,606
build or rebuild to clean and build and we

316
00:20:29,628 --> 00:20:33,094
will try to check docker desktop if

317
00:20:33,132 --> 00:20:36,646
we have any container deploying or

318
00:20:36,668 --> 00:20:40,614
any image. As you can see here we have conference

319
00:20:40,662 --> 00:20:44,358
manager we will try to check our container.

320
00:20:44,534 --> 00:20:48,314
We need to run our solution to be able to

321
00:20:48,352 --> 00:20:51,614
have or to create our container and to see

322
00:20:51,652 --> 00:20:54,926
it in this place. So I

323
00:20:54,948 --> 00:20:58,654
will select Docker. It's really simple way to run

324
00:20:58,692 --> 00:21:02,390
our solution and our container using Visual Studio

325
00:21:02,490 --> 00:21:05,826
2022 and I will try to

326
00:21:05,848 --> 00:21:10,274
see here what happens. As you can see we

327
00:21:10,312 --> 00:21:13,666
have container support. We can

328
00:21:13,688 --> 00:21:17,574
see our container, we can stop it. We can

329
00:21:17,612 --> 00:21:21,286
open terminal windows to see what's going on.

330
00:21:21,468 --> 00:21:25,270
And this is our application. It's really simple

331
00:21:25,340 --> 00:21:28,822
application. Let's check Docker desktop

332
00:21:28,886 --> 00:21:32,426
here and we see as a

333
00:21:32,448 --> 00:21:36,358
container already running here we have the conference manager

334
00:21:36,534 --> 00:21:40,366
is created, our container is

335
00:21:40,388 --> 00:21:44,110
created and we are able to see it here using

336
00:21:44,180 --> 00:21:47,774
Docker desktop. Now we

337
00:21:47,812 --> 00:21:51,278
will open visual studio code and we will create.

338
00:21:51,364 --> 00:21:54,702
Net web API using. Net.

339
00:21:54,756 --> 00:21:58,150
Net web API as it's

340
00:21:58,170 --> 00:22:01,810
created. I will close the terminal and we will use control

341
00:22:01,880 --> 00:22:06,406
shift p command line if you want to

342
00:22:06,428 --> 00:22:10,006
see the different command line to create our docker file for

343
00:22:10,028 --> 00:22:13,910
example. Now I will open the folder

344
00:22:15,130 --> 00:22:16,950
and this is our solutions.

345
00:22:18,510 --> 00:22:22,090
After we will select control shift p

346
00:22:22,160 --> 00:22:25,820
to be able to add our docker file control shift and p

347
00:22:28,110 --> 00:22:32,286
and we say docker add file to

348
00:22:32,388 --> 00:22:36,538
workspace. We select this one, we select our framework.

349
00:22:36,634 --> 00:22:39,440
Net in our case the operating system,

350
00:22:39,810 --> 00:22:43,540
the ports needed. I will change it here

351
00:22:44,470 --> 00:22:47,886
and he will ask me about adding Docker

352
00:22:47,918 --> 00:22:51,140
compose. I will say maybe yes, in this time

353
00:22:51,590 --> 00:22:55,702
we will detail it after. This is

354
00:22:55,756 --> 00:22:59,122
our Docker file. It's more and more detailed,

355
00:22:59,266 --> 00:23:02,806
but it's the same concept we

356
00:23:02,828 --> 00:23:07,490
use from Workteer copy. We have the endpoint so

357
00:23:07,580 --> 00:23:11,222
we using publishing net restore.

358
00:23:11,286 --> 00:23:14,810
So we have basically the same content

359
00:23:14,960 --> 00:23:18,426
as before. Now to build our image I

360
00:23:18,448 --> 00:23:22,126
will open terminal, new terminal and I will

361
00:23:22,148 --> 00:23:26,320
use this comment line Docker build t

362
00:23:27,010 --> 00:23:31,694
minus t conference manager image and

363
00:23:31,892 --> 00:23:35,346
I give version, let's say version. It will

364
00:23:35,368 --> 00:23:39,778
be a tag. We will see that after and we

365
00:23:39,944 --> 00:23:43,218
enter here and it's building

366
00:23:43,304 --> 00:23:47,186
as you can see here. Now to run our container we

367
00:23:47,208 --> 00:23:50,838
will use Docker can. This is the port

368
00:23:50,924 --> 00:23:55,254
number and our image that we already

369
00:23:55,372 --> 00:23:58,922
build it and we select here and

370
00:23:58,976 --> 00:24:01,946
we check in Docker here.

371
00:24:02,128 --> 00:24:05,194
Let's go back to images. We have

372
00:24:05,232 --> 00:24:08,554
our image conference managing image and in

373
00:24:08,592 --> 00:24:12,234
container we have the name of this container

374
00:24:12,282 --> 00:24:15,614
as you can see here and this is the image I

375
00:24:15,652 --> 00:24:19,626
go back here. This is container created

376
00:24:19,658 --> 00:24:23,166
from our image. Now we will see how we

377
00:24:23,188 --> 00:24:26,994
can tag an image. The docker tag helps maintain the

378
00:24:27,032 --> 00:24:30,114
build version to push the image to the Docker app.

379
00:24:30,232 --> 00:24:33,426
The Docker hub allow us to group images together

380
00:24:33,528 --> 00:24:37,218
based on name and tag. And we have the same thing

381
00:24:37,304 --> 00:24:41,326
with the azure container registry. Multiple docker

382
00:24:41,358 --> 00:24:43,922
tags can point to a particular image,

383
00:24:43,986 --> 00:24:47,730
basically as a git. Docker tags are similar to specific

384
00:24:47,820 --> 00:24:51,574
commits. Docker tags are just an alias

385
00:24:51,702 --> 00:24:54,954
for an image id. Let's see

386
00:24:54,992 --> 00:24:59,100
now how we can use visual studio code to add text

387
00:24:59,550 --> 00:25:03,594
if we come back to our solutions in the terminal.

388
00:25:03,722 --> 00:25:06,794
If we come back to the terminal, we use it a command

389
00:25:06,842 --> 00:25:09,966
line, this one run. This is

390
00:25:09,988 --> 00:25:15,730
the port and we use it. Conference image 1010

391
00:25:15,800 --> 00:25:19,842
is our tag in our case, but we can

392
00:25:19,896 --> 00:25:23,490
add more tags using Docker extension.

393
00:25:23,910 --> 00:25:28,278
As you can see here we have the first tag and we can

394
00:25:28,444 --> 00:25:31,862
click right click on conference and

395
00:25:31,916 --> 00:25:35,782
we add our tag by selecting tag here we select

396
00:25:35,836 --> 00:25:39,610
tag and we can use this one

397
00:25:39,680 --> 00:25:43,642
2.0 for example and we run

398
00:25:43,696 --> 00:25:47,146
it as you can see here we have

399
00:25:47,248 --> 00:25:51,478
our second tag. We will see in Docker

400
00:25:51,574 --> 00:25:55,038
if we have any changes related to the tag here.

401
00:25:55,124 --> 00:25:58,302
As you can see we have the first one and the second one.

402
00:25:58,436 --> 00:26:01,854
Now to build and store our docker images we will use

403
00:26:01,892 --> 00:26:05,502
Azure container registry. So we'll open Azure portal

404
00:26:05,566 --> 00:26:08,414
and we will create Azure Container registry.

405
00:26:08,542 --> 00:26:13,170
After we will deploying using visual Studio 2022

406
00:26:13,320 --> 00:26:17,174
now we will create our Azure container registry using

407
00:26:17,292 --> 00:26:20,390
Azure portal Select create a resource

408
00:26:20,810 --> 00:26:24,534
after in categories we will select containers and

409
00:26:24,572 --> 00:26:28,380
here we have container history. We click on Create.

410
00:26:28,990 --> 00:26:33,050
We have multiple tabs. We start by basics tab

411
00:26:33,390 --> 00:26:37,786
and here in project details we need to define subscription, resource group

412
00:26:37,968 --> 00:26:41,366
and the different elements needed to create our container

413
00:26:41,398 --> 00:26:45,090
registry. The name of our registry location availability

414
00:26:45,190 --> 00:26:48,926
zone and here we select basic or standard

415
00:26:49,028 --> 00:26:52,366
or premium SKU. As you

416
00:26:52,388 --> 00:26:56,002
can see I updated my page. If you are using

417
00:26:56,056 --> 00:27:00,414
a private ip you need to select networking tab

418
00:27:00,542 --> 00:27:04,034
and you select private access. Here we have

419
00:27:04,072 --> 00:27:07,686
encryption. If you need to use customer manager key you

420
00:27:07,708 --> 00:27:11,174
can enable it and use it. We can add some

421
00:27:11,212 --> 00:27:15,382
tags and in the end we will select review and create.

422
00:27:15,516 --> 00:27:19,420
As you can see the validation based after we select create

423
00:27:20,110 --> 00:27:23,894
even our Azure Container registry

424
00:27:23,942 --> 00:27:27,754
is created. We will use here

425
00:27:27,872 --> 00:27:31,934
visual studio to publish our application in

426
00:27:31,972 --> 00:27:35,680
this registry. To do that we select

427
00:27:36,050 --> 00:27:39,600
container manager the project right click

428
00:27:39,970 --> 00:27:40,830
publish.

429
00:27:43,350 --> 00:27:46,478
Here we have multiple choices.

430
00:27:46,654 --> 00:27:50,690
We select Azure because we need to use

431
00:27:50,760 --> 00:27:54,574
Azure Container registry. You can also use a docker container

432
00:27:54,622 --> 00:27:58,062
registry or folder, FTP,

433
00:27:58,126 --> 00:28:02,222
ftps server, ias or just import profile.

434
00:28:02,366 --> 00:28:06,422
If I select Docker container registry I will select next for example and

435
00:28:06,476 --> 00:28:10,054
we can find also azure Container registry in Azure.

436
00:28:10,102 --> 00:28:13,130
We have also Azure container registry.

437
00:28:14,110 --> 00:28:17,210
Here we have Azure app service and Azure container registry.

438
00:28:17,870 --> 00:28:21,914
We can use also Azure

439
00:28:21,962 --> 00:28:25,854
app service as a container. If we need to just

440
00:28:25,972 --> 00:28:30,250
deploy one container. But if you have multiple containers,

441
00:28:30,410 --> 00:28:33,486
we need to add our container in Azure

442
00:28:33,518 --> 00:28:40,930
container history. We select next and

443
00:28:41,000 --> 00:28:44,286
I need to check if our container history is already created.

444
00:28:44,318 --> 00:28:47,782
As you can see here it's already created. We click

445
00:28:47,836 --> 00:28:49,590
go to the resource.

446
00:28:51,050 --> 00:28:55,254
Here we have the login server. We need just to check the

447
00:28:55,292 --> 00:28:58,566
repositories. We don't have any repositories.

448
00:28:58,758 --> 00:29:02,410
When we upload our application we will see our repository

449
00:29:02,990 --> 00:29:06,170
and our container inside the repository.

450
00:29:06,750 --> 00:29:11,194
Let's go back to visual studio. Here we have conference

451
00:29:11,242 --> 00:29:15,390
manager. We click on finish after we select close

452
00:29:15,460 --> 00:29:19,418
and we click on publish to be able to publish our container

453
00:29:19,514 --> 00:29:23,074
in Azure Container registry it takes few

454
00:29:23,112 --> 00:29:26,900
seconds. Now we check

455
00:29:27,270 --> 00:29:30,706
Azure portal to see our registry and

456
00:29:30,808 --> 00:29:34,418
here we select repositories and we have our

457
00:29:34,504 --> 00:29:39,206
repository container manager as

458
00:29:39,228 --> 00:29:42,422
you can see here now

459
00:29:42,476 --> 00:29:46,166
if we open Docker desktop here we

460
00:29:46,188 --> 00:29:49,946
can see our repository added in

461
00:29:49,968 --> 00:29:53,754
the list. As you can see here we will use now

462
00:29:53,792 --> 00:29:57,562
visual studio code to see how we can push our

463
00:29:57,616 --> 00:30:01,370
image to Azure container registry that we already created.

464
00:30:01,450 --> 00:30:05,502
We go back to visual studio code and

465
00:30:05,556 --> 00:30:09,280
we will use the docker extension as we did before

466
00:30:09,810 --> 00:30:13,422
and here we can see all the registry.

467
00:30:13,486 --> 00:30:17,634
We have Azure or Docker hub. I will select

468
00:30:17,832 --> 00:30:22,340
the first second one, this one I will say push for example

469
00:30:22,950 --> 00:30:24,850
and I will select Azure.

470
00:30:26,330 --> 00:30:30,118
I have a list of the registries inside

471
00:30:30,204 --> 00:30:34,582
my Azure account. I will select conference manager and

472
00:30:34,716 --> 00:30:38,278
we will use the tag image, the same tag image.

473
00:30:38,454 --> 00:30:42,778
We've not made a change here and

474
00:30:42,864 --> 00:30:46,294
here. As you can see it takes few seconds

475
00:30:46,342 --> 00:30:49,974
to be pushed to our registry and we check

476
00:30:50,032 --> 00:30:52,560
after can Azure portal I will finish it.

477
00:30:53,410 --> 00:30:56,606
I will open Azure portal and I

478
00:30:56,628 --> 00:30:59,774
will go to repositories and we find

479
00:30:59,892 --> 00:31:03,582
conference mentor image using our

480
00:31:03,636 --> 00:31:06,910
tiger as you can see here, this is the tiger.

481
00:31:07,510 --> 00:31:12,066
If we check Docker we

482
00:31:12,088 --> 00:31:16,402
are able to see also the image here conference

483
00:31:16,466 --> 00:31:19,846
manager image if you need for example to

484
00:31:19,868 --> 00:31:23,480
push the first tag, we see how

485
00:31:24,010 --> 00:31:27,946
we can proceed. What is the result? I will use the

486
00:31:27,968 --> 00:31:32,250
same tag for the same image.

487
00:31:33,470 --> 00:31:37,786
Let's go back two Azure portal repositories and here

488
00:31:37,888 --> 00:31:41,786
we will check the first one, the second one as you can

489
00:31:41,808 --> 00:31:45,402
see here we have the fourth project we created using Visual

490
00:31:45,466 --> 00:31:48,958
Studio 2022 and this is the second project

491
00:31:49,044 --> 00:31:52,522
uses visual studio code. Here we have only

492
00:31:52,596 --> 00:31:56,098
one tag. Latest the default one, use the default one

493
00:31:56,184 --> 00:31:58,290
and here we have two tags.

494
00:32:00,070 --> 00:32:04,370
To create Azure container registry we can use Azure porter,

495
00:32:04,890 --> 00:32:08,914
Azure Cli, Azure Powershell, any template arm

496
00:32:08,962 --> 00:32:13,110
templates. In our case we just tested

497
00:32:13,530 --> 00:32:17,362
the use of Azure portal. We can use Azure Cli.

498
00:32:17,426 --> 00:32:22,380
So I will just go to shell azure.com

499
00:32:23,790 --> 00:32:27,146
I need to be authenticated to

500
00:32:27,168 --> 00:32:30,490
my account and we use this

501
00:32:30,560 --> 00:32:34,614
command line Azacr

502
00:32:34,742 --> 00:32:38,174
created I will define our resource group.

503
00:32:38,212 --> 00:32:42,174
I will use the previous created one, the name and

504
00:32:42,212 --> 00:32:45,840
my plan. I select enter

505
00:32:46,770 --> 00:32:50,662
and in a few seconds our edge container registry

506
00:32:50,746 --> 00:32:54,260
will be created inside the same resource group.

507
00:32:56,810 --> 00:33:00,454
It's running now and

508
00:33:00,492 --> 00:33:04,120
as you can see here we have a JSON file as a result

509
00:33:04,570 --> 00:33:08,860
and I will check in my resource group

510
00:33:09,470 --> 00:33:12,460
the different resources created here.

511
00:33:16,030 --> 00:33:20,362
And here I have my container for conference that

512
00:33:20,416 --> 00:33:24,122
present our container registry as

513
00:33:24,176 --> 00:33:27,742
registry. We are using Azure container registry but

514
00:33:27,796 --> 00:33:30,974
we are able to deploy our

515
00:33:31,172 --> 00:33:34,594
image, our container image two docker app

516
00:33:34,712 --> 00:33:38,834
that is a public registry and

517
00:33:38,952 --> 00:33:42,834
to do that it's really simple. We can use

518
00:33:42,952 --> 00:33:46,646
the same publish here I will select a

519
00:33:46,668 --> 00:33:50,600
second one for example here a new one

520
00:33:51,450 --> 00:33:55,270
here I will select docker container and I will select

521
00:33:55,340 --> 00:33:58,394
Docker as you can see here we are able

522
00:33:58,512 --> 00:34:02,662
to publish our application as a docker image to any container

523
00:34:02,726 --> 00:34:05,850
registry in the cloud in prem

524
00:34:06,590 --> 00:34:10,782
so you need just to define your

525
00:34:10,916 --> 00:34:14,842
path of your repository. Now we select Docker hub.

526
00:34:14,986 --> 00:34:18,622
We click on next we need to

527
00:34:18,676 --> 00:34:22,240
add the username the password after we click on finish.

528
00:34:22,690 --> 00:34:26,242
As you can see here we click it on finish. After we

529
00:34:26,296 --> 00:34:30,546
select close and we select publish it

530
00:34:30,568 --> 00:34:34,274
takes few seconds. Two be published to Docker Hub and

531
00:34:34,312 --> 00:34:37,978
we will try to check Docker hub to see if our configuration

532
00:34:38,014 --> 00:34:41,234
image was pushed or not in Docker

533
00:34:41,282 --> 00:34:44,946
hub. Now if I open Docker

534
00:34:44,978 --> 00:34:49,378
hub using app docker.com,

535
00:34:49,484 --> 00:34:53,146
I'm using my personal account and we

536
00:34:53,168 --> 00:34:56,650
can find my container image conference manager.

537
00:34:59,550 --> 00:35:03,278
If you are using visual studio code, we can also

538
00:35:03,364 --> 00:35:05,790
publish our image to Docker Hub.

539
00:35:06,370 --> 00:35:10,062
So for example let's select this one and we click

540
00:35:10,196 --> 00:35:14,330
push and instead of selecting

541
00:35:14,490 --> 00:35:18,038
as before Azure, we will select Docker hub.

542
00:35:18,234 --> 00:35:21,922
I select my own account. If I have multiple accounts you can select

543
00:35:21,976 --> 00:35:23,620
the convenient account needed.

544
00:35:24,890 --> 00:35:28,390
I leave the same tag

545
00:35:28,730 --> 00:35:32,626
after it takes few seconds

546
00:35:32,818 --> 00:35:37,094
to be run. In this way if

547
00:35:37,132 --> 00:35:40,778
I go back to my Docker app

548
00:35:40,944 --> 00:35:44,422
we can find the conference manager image.

549
00:35:44,566 --> 00:35:48,026
Let's open some description. Here we

550
00:35:48,048 --> 00:35:50,860
have the tag as you can see the first one.

551
00:35:52,510 --> 00:35:56,226
As you break down your monolithic application into separate, closely copied

552
00:35:56,278 --> 00:35:59,834
microservices, your team will gain core autonomy and freedom.

553
00:35:59,962 --> 00:36:04,730
However, they still have to closely cooperate when interacting

554
00:36:04,810 --> 00:36:08,210
with the infrastructure the microservices must turn on.

555
00:36:08,280 --> 00:36:12,382
You will have to solve problems like predicting

556
00:36:12,446 --> 00:36:15,694
how much computing resource each service will need,

557
00:36:15,832 --> 00:36:19,314
how these requirements change under cloud, how to carve

558
00:36:19,362 --> 00:36:23,682
out infrastructure partition and divide them between microservices

559
00:36:23,826 --> 00:36:26,994
and enforce resource restrictions.

560
00:36:27,122 --> 00:36:31,174
Kubernetes or orchestrator solves

561
00:36:31,222 --> 00:36:34,950
these problems quite elegantly and provides a common framework

562
00:36:35,030 --> 00:36:38,746
to describe, inspect and reason about infrastructure research,

563
00:36:38,928 --> 00:36:42,938
sharing and utilization. That's why adopting

564
00:36:43,034 --> 00:36:46,462
Kubernetes as part of your microservice rearchitecture is a good

565
00:36:46,516 --> 00:36:50,798
idea. Microsoft Azure offers many options

566
00:36:50,884 --> 00:36:54,290
to work with containers and orchestrators.

567
00:36:54,870 --> 00:36:58,306
We use it before Azure container registry to store and

568
00:36:58,328 --> 00:37:01,650
manage our private container image. We use also

569
00:37:01,720 --> 00:37:06,002
docker app for public images. Azure container instance

570
00:37:06,066 --> 00:37:10,470
or Azure app services can be used to run isolated containers.

571
00:37:10,970 --> 00:37:15,110
We have also Azure Kubernetes service that is a great option

572
00:37:15,180 --> 00:37:19,158
for more complex scenario in which full container orchestration,

573
00:37:19,334 --> 00:37:22,730
automatic scaling and service discovery are required.

574
00:37:23,230 --> 00:37:26,810
The problem is Kubernetes is extremely difficult

575
00:37:26,880 --> 00:37:30,182
to use and we have another service that is

576
00:37:30,256 --> 00:37:32,240
Azure container app.

577
00:37:34,370 --> 00:37:37,694
If you need two, learn more about building modern application

578
00:37:37,812 --> 00:37:41,086
using microservices containers. Azure services

579
00:37:41,188 --> 00:37:45,850
orchestrator you can see these books on Amazon

580
00:37:46,010 --> 00:37:49,422
and if you have any questions after this session you can

581
00:37:49,556 --> 00:37:53,310
reach me by email via Twitter LinkedIn.

582
00:37:53,730 --> 00:37:54,860
Thank you for joining me today.

