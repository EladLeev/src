1
00:00:00,730 --> 00:00:04,366
What if you could work with some of the world's most innovative companies,

2
00:00:04,548 --> 00:00:07,338
all from the comfort of a remote workplace?

3
00:00:07,514 --> 00:00:10,874
Andela has matched thousands of technologists across the globe

4
00:00:10,922 --> 00:00:14,234
to their next career adventure. We're empowering

5
00:00:14,282 --> 00:00:17,770
new talent worldwide, from Sao Paulo to Egypt

6
00:00:17,850 --> 00:00:21,374
and Lagos to Warsaw. Now the future of

7
00:00:21,412 --> 00:00:23,978
work is yours to create. Anytime,

8
00:00:24,074 --> 00:00:27,030
anywhere, the world is at your fingertips.

9
00:00:27,370 --> 00:01:13,834
This is Andela Dahoy

10
00:01:13,882 --> 00:01:17,122
there my name Savas and I would like to go serverless

11
00:01:17,186 --> 00:01:20,754
with you. But before you head out with a total stranger into the cloudy serverless

12
00:01:20,802 --> 00:01:24,690
wild, let me introduce myself. I am Savas Ziplies,

13
00:01:24,770 --> 00:01:28,246
founder, managing director at Ellipsis and passionate software engineer for

14
00:01:28,268 --> 00:01:32,294
over 15 years now, having worked on research and product developments in multiple

15
00:01:32,342 --> 00:01:34,934
areas and industries such as mobile apps,

16
00:01:34,982 --> 00:01:38,410
caring backend and high available service applications.

17
00:01:39,070 --> 00:01:41,830
With the advent of DevOps and serverless,

18
00:01:41,990 --> 00:01:45,278
and the goal to bring DevOps back again closer to

19
00:01:45,284 --> 00:01:48,814
the operation, I would like to show you today how

20
00:01:48,852 --> 00:01:52,238
to leverage your daily go environment and just

21
00:01:52,324 --> 00:01:56,074
deploy it serverless from the tip of your finger. So let's

22
00:01:56,122 --> 00:01:59,838
start. And let's start with the most important question. Why serverless?

23
00:02:00,014 --> 00:02:03,234
And this is hard to answer. It's an excellent question, but it's hard to answer.

24
00:02:03,272 --> 00:02:06,754
And I hope by the end of this presentation you will know for yourself if

25
00:02:06,792 --> 00:02:10,338
serverless is good for you or even not. But defining

26
00:02:10,354 --> 00:02:13,846
serverless is also already hard because serverless can mean

27
00:02:13,868 --> 00:02:17,554
a lot for some people. Mobile developers, for example, that just use

28
00:02:17,612 --> 00:02:21,414
a backend service like codebase. It's already serverless

29
00:02:21,462 --> 00:02:25,034
because they don't have any server anymore. But this is rather backend aws,

30
00:02:25,072 --> 00:02:28,726
a service compared to a real serverless

31
00:02:28,838 --> 00:02:32,410
vendor function as a service. What we will talk about today,

32
00:02:32,560 --> 00:02:36,154
so what we will talk about today is not caring about the infrastructure.

33
00:02:36,282 --> 00:02:39,742
So there are serverless, in the end, there are serverless, it's just the cloud,

34
00:02:39,796 --> 00:02:43,370
it's the service of others. But you don't own the service anymore,

35
00:02:43,530 --> 00:02:47,582
so you are serverless. And this is the important part. No dedicated

36
00:02:47,646 --> 00:02:51,234
servers for you, no dedicated instances for you. You just think

37
00:02:51,272 --> 00:02:54,722
about the functions and the functionality that you want to deliver to your

38
00:02:54,776 --> 00:02:57,966
app. So you are just simply developing.

39
00:02:58,158 --> 00:03:01,766
If we break it down to the four pillars for serverless and for

40
00:03:01,788 --> 00:03:05,586
today, we are talking about the infrastructure as a service that we want to deploy

41
00:03:05,618 --> 00:03:09,046
to. They will care about the high availability and the

42
00:03:09,148 --> 00:03:12,060
nearly endless scalability that we want to use.

43
00:03:12,590 --> 00:03:15,834
What we deploy only runs when we need it,

44
00:03:15,872 --> 00:03:19,658
so we also only pay when we need it. And we just focus completely on

45
00:03:19,664 --> 00:03:22,974
the development. We just continue as we did before, develop our

46
00:03:23,012 --> 00:03:27,054
application and just care a little bit, tiny little bit about

47
00:03:27,092 --> 00:03:31,294
the operations side. So if you look at the market right now, what is

48
00:03:31,332 --> 00:03:34,686
there available? You probably heard about Microsoft Azure functions,

49
00:03:34,718 --> 00:03:38,654
you probably heard about AWS Lambda, maybe even Google Cloud functions.

50
00:03:38,702 --> 00:03:42,638
And some might even heard about IBM cloud functions.

51
00:03:42,734 --> 00:03:45,874
Why IBM cloud functions here? Because it is based on

52
00:03:45,912 --> 00:03:49,622
Apache OpenWisc which is can open framework that you can potentially also

53
00:03:49,676 --> 00:03:53,494
use to deploy a functions as a service on

54
00:03:53,532 --> 00:03:57,266
your own Kubernetes cluster or your own server environment or FN

55
00:03:57,298 --> 00:04:00,618
project which provides something similar that you could use.

56
00:04:00,784 --> 00:04:04,346
On top of that there are also other full service providers like the server or

57
00:04:04,368 --> 00:04:08,394
Netlify which also have functions as a service. But more

58
00:04:08,432 --> 00:04:12,510
abstracted for a web development part, if you really want to deploy pretty much everything,

59
00:04:12,660 --> 00:04:16,030
they provide a full service abstracting what is really behind

60
00:04:16,100 --> 00:04:19,470
that. So with so much going on,

61
00:04:19,620 --> 00:04:22,990
let's just go for it. Let's develop our serverless application.

62
00:04:23,140 --> 00:04:26,506
So if you think about it from an architectural perspective,

63
00:04:26,618 --> 00:04:30,194
it's pretty simple. We have for example our web application and our web application

64
00:04:30,312 --> 00:04:33,426
has some requirements. So we write down the user stories and what

65
00:04:33,448 --> 00:04:37,198
we want to develop. So for example we need to provide the time we

66
00:04:37,224 --> 00:04:40,498
need to update an entry filter data search data, yada yada

67
00:04:40,514 --> 00:04:44,710
yada. So the web application just want to push the requests and

68
00:04:44,780 --> 00:04:48,226
get the data that we have stored in a database,

69
00:04:48,258 --> 00:04:51,898
for example from our singlefile functions. If you would now develop this,

70
00:04:51,984 --> 00:04:55,542
for example, we have three developers picking different user stories

71
00:04:55,686 --> 00:04:59,446
working on the time implementation, the update implementation, the search implementation,

72
00:04:59,558 --> 00:05:02,970
and just go ahead create their functions. One might

73
00:05:03,040 --> 00:05:06,270
develop it in typescript, the other one might develop it in go,

74
00:05:06,340 --> 00:05:09,742
the other one in python. So it's pretty flexible and everybody can work

75
00:05:09,796 --> 00:05:13,450
in the best environment that they would like to work in.

76
00:05:13,620 --> 00:05:17,234
Then everything is deployed. Let's take the example of AWS. You have

77
00:05:17,272 --> 00:05:21,086
the different endpoints. So for example API time API

78
00:05:21,118 --> 00:05:24,994
update API search where you can then access from

79
00:05:25,032 --> 00:05:29,266
a client perspective the different endpoints and functionality.

80
00:05:29,458 --> 00:05:32,680
So client and front end developer is happy.

81
00:05:33,770 --> 00:05:37,126
If we look now what is really happening inside these functions and we

82
00:05:37,148 --> 00:05:40,698
take a first close look at the Google cloud function, then you can see

83
00:05:40,784 --> 00:05:44,106
that's basically just a simple function, in this

84
00:05:44,128 --> 00:05:47,798
case hello world, that just implements the HTTP handler interface

85
00:05:47,894 --> 00:05:51,114
response router request is in there. And then you just go

86
00:05:51,152 --> 00:05:54,526
ahead and do whatever you would like. In this case it's pretty simple.

87
00:05:54,708 --> 00:05:58,542
You just return your hello name or hello world without

88
00:05:58,596 --> 00:06:01,982
any main or anything and you could just deploy it and have a serverless function

89
00:06:02,036 --> 00:06:05,746
on Google Online. For AWS it's pretty similar. You can

90
00:06:05,768 --> 00:06:10,002
also deploy or return a hello worlds or hello name function,

91
00:06:10,136 --> 00:06:13,202
but you have to proxy these requests first, because based

92
00:06:13,256 --> 00:06:16,078
on the API gateway by AWS,

93
00:06:16,174 --> 00:06:20,086
you have to proxy these into the lambda handler that is already provided by

94
00:06:20,108 --> 00:06:23,526
AWS. So after that it's pretty much the same as we have

95
00:06:23,548 --> 00:06:26,918
seen on Google and with many other providers again, so it's a

96
00:06:26,924 --> 00:06:30,298
little bit more complicated compared to some others,

97
00:06:30,384 --> 00:06:33,866
but in the end it's the same. So if

98
00:06:33,888 --> 00:06:37,834
we would continue now with the AWS example. So you

99
00:06:37,872 --> 00:06:41,482
create just your project, add the AWS lambda go

100
00:06:41,536 --> 00:06:45,306
library, and add the lambda start handler as we have seen on the slide

101
00:06:45,338 --> 00:06:48,718
before. Then you create your AWS account,

102
00:06:48,884 --> 00:06:52,350
you can create a free account, you have a free tier, you have 1 million

103
00:06:52,420 --> 00:06:55,826
requests on lambda that you can execute for free. So just go

104
00:06:55,848 --> 00:06:59,426
ahead, just create something, build your application,

105
00:06:59,608 --> 00:07:03,186
install the AWS cly, zip everything up, create your

106
00:07:03,208 --> 00:07:06,918
iam permissions, because without permissions you cannot invoke or upload anything.

107
00:07:07,084 --> 00:07:10,614
Then by creating your function, you're just

108
00:07:10,652 --> 00:07:13,894
uploading basically your compiled go application,

109
00:07:14,092 --> 00:07:18,086
push it online, and then you can invoke it if you invoke

110
00:07:18,118 --> 00:07:22,502
it. This example is very creative. You get hello world returned

111
00:07:22,566 --> 00:07:25,434
and you can rinse and repeat function by function,

112
00:07:25,632 --> 00:07:28,538
leveraging your time, update, filter, search,

113
00:07:28,624 --> 00:07:32,270
whatever you need. So it's very easy

114
00:07:32,340 --> 00:07:35,870
and quick to start easy in development, function by function.

115
00:07:35,940 --> 00:07:39,534
Basically you could work user story by user story and you would

116
00:07:39,572 --> 00:07:42,846
really follow a single purpose design from

117
00:07:42,868 --> 00:07:46,674
the get go. But as you already have seen, there are already

118
00:07:46,712 --> 00:07:50,450
differences only between Google and AWS, and it's similar

119
00:07:50,520 --> 00:07:53,780
with other vendors. So you are immediately a vendor locked here.

120
00:07:54,710 --> 00:07:58,578
And to some occurrences the single purpose functions might

121
00:07:58,664 --> 00:08:01,846
be a little bit too microservice for some development. You just want

122
00:08:01,868 --> 00:08:05,302
to think an app. You want to develop an app and not think already

123
00:08:05,436 --> 00:08:08,070
from the start in the single functions.

124
00:08:09,150 --> 00:08:12,582
On top of that, if you start creating 50 functions,

125
00:08:12,646 --> 00:08:16,726
100 functions, maybe with dependencies to different infrastructure

126
00:08:16,758 --> 00:08:20,442
like user database or in between, it might become very

127
00:08:20,496 --> 00:08:23,726
tedious to develop locally and then especially

128
00:08:23,828 --> 00:08:27,466
test it locally if there are some interdependencies.

129
00:08:27,578 --> 00:08:31,498
So it's not native to what we are normally used in development.

130
00:08:31,594 --> 00:08:35,326
Everything can be covered with structure and with good architectural design, of course.

131
00:08:35,428 --> 00:08:38,914
But maybe we just want to stick with what we already know.

132
00:08:39,112 --> 00:08:42,594
So these native fast functions, they fulfill their use

133
00:08:42,632 --> 00:08:45,682
cases, they have a use case. If you really need small,

134
00:08:45,816 --> 00:08:49,234
quick, high available functions that you just

135
00:08:49,272 --> 00:08:52,546
want to deploy on single clouds and that you just want to incorporate

136
00:08:52,578 --> 00:08:56,070
in your existing application. But maybe it's not right for you if you want to

137
00:08:56,140 --> 00:08:59,798
develop a whole application. But this is what we want to.

138
00:08:59,884 --> 00:09:03,866
So let's go a little bit further. So next level is

139
00:09:03,968 --> 00:09:07,002
when we look at our architecture that we have seen as our simple

140
00:09:07,056 --> 00:09:10,518
serverless architecture, that we do not think in functions anymore,

141
00:09:10,614 --> 00:09:14,602
but think in applications. So we are developing apps because

142
00:09:14,656 --> 00:09:17,706
this is what we do. It can be one app, it can be two apps,

143
00:09:17,738 --> 00:09:21,262
it can be multiple apps. We can start off with one app

144
00:09:21,316 --> 00:09:24,946
and then split it later into multiple apps because of the requirements that

145
00:09:24,968 --> 00:09:28,770
we have derived from the execution. You just start

146
00:09:28,840 --> 00:09:31,970
really developing and focusing on your application deployments.

147
00:09:32,470 --> 00:09:36,046
So our goal is to reuse

148
00:09:36,158 --> 00:09:39,778
existing frameworks and libraries that we already have in our go environment

149
00:09:39,874 --> 00:09:43,206
and that we work with on a daily basis. We want

150
00:09:43,228 --> 00:09:46,774
to start simple, so developing just our application, but stay

151
00:09:46,812 --> 00:09:50,578
flexible if we might potentially more or want to split

152
00:09:50,594 --> 00:09:54,474
it up. We want to deploy it to AWS in our example today,

153
00:09:54,592 --> 00:09:58,378
but be flexible to also deploy it to others. And we

154
00:09:58,544 --> 00:10:00,860
don't want to care about the infrastructure of course.

155
00:10:01,470 --> 00:10:05,374
So I would like to call this now for today a

156
00:10:05,412 --> 00:10:08,970
framework as a service approach to stay with the abbreviation of Fars.

157
00:10:09,130 --> 00:10:13,034
We are flexible and extendable by using an existing framework

158
00:10:13,082 --> 00:10:16,010
which already has so many plugins, so many modules,

159
00:10:16,090 --> 00:10:19,826
so many middleware that we can use. It has all the routing, it has all

160
00:10:19,848 --> 00:10:24,066
the JWT authentication, so we don't have to do anything there.

161
00:10:24,168 --> 00:10:27,766
We want to be able to develop locally, deploy it in

162
00:10:27,788 --> 00:10:31,826
a docker container, deploy it on our own service, but also be able to deploy

163
00:10:31,858 --> 00:10:35,078
it serverless. So development first,

164
00:10:35,164 --> 00:10:38,966
operation second. And when we are using a

165
00:10:38,988 --> 00:10:42,570
common web framework and a common design pattern, we are also using something

166
00:10:42,640 --> 00:10:45,386
that we already know, a structure that we already know. So we are keeping it

167
00:10:45,408 --> 00:10:49,290
simple, not serverless. And for the example today,

168
00:10:49,360 --> 00:10:53,482
the project structure given today, we are looking at a monolithic

169
00:10:53,546 --> 00:10:57,002
microservice architecture. So we are combining the convention

170
00:10:57,066 --> 00:10:58,910
and the configuration altogether.

171
00:11:00,610 --> 00:11:04,094
For the example, I've picked fiber as an

172
00:11:04,132 --> 00:11:07,246
expressjs inspired Golang web framework,

173
00:11:07,358 --> 00:11:09,570
very fast, very easy to use,

174
00:11:09,720 --> 00:11:13,186
and will be incorporated in the example today.

175
00:11:13,368 --> 00:11:16,722
This we want to deploy to AWS with AWS client

176
00:11:16,786 --> 00:11:20,866
SaM, and building, testing and deploying can be done via Docker,

177
00:11:20,898 --> 00:11:24,322
of course. So if we look at the project structure

178
00:11:24,386 --> 00:11:27,734
that is provided here, it's basically segregated into,

179
00:11:27,772 --> 00:11:30,998
I would say three or four parts. So we have the build part.

180
00:11:31,084 --> 00:11:34,362
The build part is where the build configurations for the different providers are in there.

181
00:11:34,416 --> 00:11:37,866
In our case AWS, then the most important part

182
00:11:37,888 --> 00:11:41,242
is the command part. This is where our serverless apps really live

183
00:11:41,296 --> 00:11:44,686
in. We have our API, a queue handler, for example a

184
00:11:44,708 --> 00:11:48,394
web API or whatever we need. All our serverless

185
00:11:48,442 --> 00:11:52,154
applications live in the command area and are fully fledged applications.

186
00:11:52,282 --> 00:11:55,426
On top of that we can add any common code. So for

187
00:11:55,448 --> 00:11:58,578
example models or helper functions that we want to share

188
00:11:58,664 --> 00:12:02,414
between our different commands and then some additional files

189
00:12:02,462 --> 00:12:06,326
like environment, Docker compose and so on. I won't go through all

190
00:12:06,348 --> 00:12:10,754
the different code lines as those are just normal go projects.

191
00:12:10,882 --> 00:12:14,662
So I provided a GitHub repository which you can check

192
00:12:14,716 --> 00:12:18,262
out yourself and see if everything works

193
00:12:18,316 --> 00:12:22,310
out for you too. So if we look closer

194
00:12:22,390 --> 00:12:25,446
at one of the commands, for example the API command,

195
00:12:25,558 --> 00:12:28,886
it's just a fully fledged API. It serves

196
00:12:28,918 --> 00:12:32,126
AWS its own, it stands on its own, it's just a go module in it

197
00:12:32,228 --> 00:12:36,298
app where you can just develop, include fiber,

198
00:12:36,474 --> 00:12:39,834
add your roots, add your middleware, add your database

199
00:12:39,882 --> 00:12:43,518
connection, whatever you need, you can add it there, but you

200
00:12:43,524 --> 00:12:47,330
can add additional commands for example. So you could even add vendor specific

201
00:12:47,400 --> 00:12:51,106
commands. So for example that are stuck to AWS. Everything can be

202
00:12:51,208 --> 00:12:54,402
mixed altogether. But the important part is

203
00:12:54,456 --> 00:12:58,114
you can start simple and extend it later on. You are not

204
00:12:58,152 --> 00:13:02,054
locked by anything from the get go, but you can later on

205
00:13:02,092 --> 00:13:05,970
decide or for example in this application I have noticed that this endpoint

206
00:13:06,050 --> 00:13:09,446
requires more memory, so I split it up into a different function

207
00:13:09,548 --> 00:13:13,478
which is basically just a new command. Split it up, create a new deployment configuration

208
00:13:13,574 --> 00:13:17,574
and you have a new serverless configuration with the according configuration of memory

209
00:13:17,622 --> 00:13:22,358
that you require now

210
00:13:22,464 --> 00:13:25,854
to handle the different entries coming

211
00:13:25,892 --> 00:13:29,726
from AWS or locally or later on GCP or whatever we can

212
00:13:29,748 --> 00:13:32,994
think of. We want to create a single point of entry which is in our

213
00:13:33,032 --> 00:13:37,506
case our main go file where we just basically

214
00:13:37,608 --> 00:13:41,246
import a new environment variable in our case server

215
00:13:41,278 --> 00:13:44,834
environment to decide where are we running in this case,

216
00:13:44,872 --> 00:13:49,030
if we're running on AWS, we start the lambda handler that we have seen earlier.

217
00:13:49,610 --> 00:13:53,650
If we are not in any specific server environment, we are just starting a normal

218
00:13:53,730 --> 00:13:57,510
fiber local web server and can just test it or deploy it

219
00:13:57,580 --> 00:14:00,634
however we like it. So we have a single point of code and a single

220
00:14:00,672 --> 00:14:04,762
point of entry here for AWS. AWS mentioned we already have.

221
00:14:04,896 --> 00:14:08,582
We need to add a little bit more as we have to proxy the request

222
00:14:08,646 --> 00:14:11,934
into fiber. But it's quite easy as

223
00:14:11,972 --> 00:14:16,014
AWS provides everything themselves. So AWS lambda Go

224
00:14:16,052 --> 00:14:19,738
API proxy is a GitHub repository which provides

225
00:14:19,834 --> 00:14:23,806
adapters that can be attached to fiber, but also gin or echo

226
00:14:23,838 --> 00:14:27,374
and other web frameworks. So based on our server environment,

227
00:14:27,422 --> 00:14:30,558
we just init it, attach it, proxy our context

228
00:14:30,654 --> 00:14:34,398
and we are back into our normal fiber context.

229
00:14:34,494 --> 00:14:38,162
And everything after that is just normal development

230
00:14:38,226 --> 00:14:40,440
as we know it.

231
00:14:42,330 --> 00:14:46,546
And this is why we just develop. So we are not caring about serverless,

232
00:14:46,578 --> 00:14:49,750
we are not caring, but AWS, we are not caring about GCP.

233
00:14:49,830 --> 00:14:53,242
And this is the goal. We just want to develop, test, and everything that works

234
00:14:53,296 --> 00:14:56,998
locally should just work automatically serverless,

235
00:14:57,174 --> 00:15:00,426
but be high available and scalable on

236
00:15:00,448 --> 00:15:03,886
the cloud, available for everybody. So just develop,

237
00:15:03,988 --> 00:15:07,374
finish your app and when you're ready, we're bringing it to the cloud.

238
00:15:07,492 --> 00:15:11,134
Now we're really going serverless. So we

239
00:15:11,172 --> 00:15:14,498
already have our build structure, we have our commands, now we

240
00:15:14,504 --> 00:15:18,290
want to bring it to AWS. How do we bring it to AWS?

241
00:15:18,630 --> 00:15:22,206
By using AWS Sam. Sam stands

242
00:15:22,238 --> 00:15:25,746
for serverless application model and the name already gives

243
00:15:25,768 --> 00:15:28,866
it away. It's an application modeling. So we are not modeling

244
00:15:28,898 --> 00:15:32,840
an infrastructure, but we are modeling our services. We are modeling our application

245
00:15:33,370 --> 00:15:36,934
as a service online. So it serves as an ops layer between

246
00:15:36,972 --> 00:15:41,020
our app that we have developed locally and the serverless deployment. In the end,

247
00:15:42,910 --> 00:15:46,934
you can just install the AWS Sam cly

248
00:15:47,062 --> 00:15:50,870
in. It can select from different templates,

249
00:15:51,030 --> 00:15:55,014
zip your artifacts, or create for example containers via

250
00:15:55,062 --> 00:15:58,800
an ECR. On AWS, for example, you select go

251
00:15:59,250 --> 00:16:02,942
as your programming language in our case and just create your application.

252
00:16:03,076 --> 00:16:06,398
Sam takes care about everything. It creates the folders, it creates

253
00:16:06,414 --> 00:16:09,874
the configuration. And theoretically you could just call Sam build.

254
00:16:09,992 --> 00:16:13,266
It builds and zips the initial template that

255
00:16:13,288 --> 00:16:16,706
has been created, then calls Sam deploy and just deploy

256
00:16:16,738 --> 00:16:20,242
it to your configured AWS account. And suddenly

257
00:16:20,306 --> 00:16:24,486
you have your first serverless application online running with

258
00:16:24,508 --> 00:16:27,800
SAM deploy guided. You get even asked the important questions,

259
00:16:28,410 --> 00:16:32,794
what you want to do, where you want to host it, which region, for example,

260
00:16:32,912 --> 00:16:35,846
and you can configure everything from the tip of your fingers.

261
00:16:35,878 --> 00:16:39,482
And this is what we want to. But as we have our own

262
00:16:39,536 --> 00:16:43,226
structure with applications and not single functions which would be

263
00:16:43,248 --> 00:16:46,894
created if you just call SAM in it, we have to adapt it to our

264
00:16:46,932 --> 00:16:50,506
project structure. So we just look at a template, yaml,

265
00:16:50,538 --> 00:16:54,242
that is created by Sam, because this is basically the infrastructure as code

266
00:16:54,296 --> 00:16:58,626
or the app as code that we are using in

267
00:16:58,648 --> 00:17:02,866
the app as code in the template yaml. You have resources and

268
00:17:02,968 --> 00:17:06,014
our function, our API function for example is a resource.

269
00:17:06,062 --> 00:17:09,158
It's can AWS serverless function. But instead

270
00:17:09,244 --> 00:17:12,674
of just having single files, we define the URi

271
00:17:12,802 --> 00:17:16,466
back to our folder structure where we have our commands and define

272
00:17:16,498 --> 00:17:19,942
the whole build as our singlefile function. We can

273
00:17:19,996 --> 00:17:23,802
add additional properties like for example memory size and timeout. And always

274
00:17:23,856 --> 00:17:27,658
remember, you want to always start off low and the lowest you

275
00:17:27,664 --> 00:17:31,206
can run the cheapest. You will end up in the end in a serverless environment.

276
00:17:31,318 --> 00:17:35,214
And this is basically all the configuration that we need that we give away to

277
00:17:35,252 --> 00:17:38,654
Sam. And then if we call Sam, build and deploy, Sam takes

278
00:17:38,692 --> 00:17:42,158
care about the rest. The important

279
00:17:42,244 --> 00:17:46,450
part is then how does our app get called.

280
00:17:46,600 --> 00:17:49,986
So we have to add an event. An event is to

281
00:17:50,008 --> 00:17:52,734
trigger how our app is invoked.

282
00:17:52,862 --> 00:17:56,338
And as our app is a function we want to attach it to an

283
00:17:56,344 --> 00:18:00,438
API resource and we want to just proxy in

284
00:18:00,524 --> 00:18:03,746
all the requests that are coming in and handle it internally.

285
00:18:03,938 --> 00:18:07,750
So compared to what we have seen earlier where we created an API time

286
00:18:07,900 --> 00:18:11,874
API update, API search for example, we don't

287
00:18:11,922 --> 00:18:15,066
split it up because we are doing the handling, not the operations side is doing

288
00:18:15,088 --> 00:18:19,242
the handling. So we are just proxying all the requests that are coming in

289
00:18:19,376 --> 00:18:22,140
into our own app and handle the rest.

290
00:18:22,670 --> 00:18:25,994
On top of that we have to configure the environment variables

291
00:18:26,042 --> 00:18:30,026
of course so that we can set the server environment so that our application knows

292
00:18:30,058 --> 00:18:33,666
we are running in an AWS environment. And of course a

293
00:18:33,688 --> 00:18:37,454
lot else because as already mentioned we are defining resources.

294
00:18:37,582 --> 00:18:41,822
So if you define resources like for example an RDS database,

295
00:18:41,966 --> 00:18:45,314
you can reference the RDS database that you have

296
00:18:45,352 --> 00:18:48,846
defined in the same template and

297
00:18:48,888 --> 00:18:52,134
just attach it as an environment variable so that

298
00:18:52,172 --> 00:18:56,018
you don't have to create anything on an AWS console. Copy the URL

299
00:18:56,194 --> 00:18:59,286
and paste it in here and then the URL changes and everything is broken.

300
00:18:59,398 --> 00:19:03,094
You just reference your deployments directly here and AWS SAM

301
00:19:03,142 --> 00:19:05,340
and cloudformation takes care about the rest.

302
00:19:05,710 --> 00:19:09,642
So sometimes you might need additional data.

303
00:19:09,776 --> 00:19:13,386
So I picked an example that you might need for example chromium

304
00:19:13,498 --> 00:19:17,246
to be used by your services application because you want to invoke a

305
00:19:17,268 --> 00:19:21,086
chrome instance and then visit a specific website because you need

306
00:19:21,108 --> 00:19:25,666
the Javascript to be called to get some information. For example to

307
00:19:25,688 --> 00:19:28,706
have this running and not necessarily have

308
00:19:28,728 --> 00:19:32,882
to build a new container image, you can just add the data

309
00:19:33,016 --> 00:19:36,774
as a layer on top of your serverless function. So you would just

310
00:19:36,812 --> 00:19:40,326
download whatever data you need. In this case the

311
00:19:40,348 --> 00:19:43,746
chromium build, have it in your build structure,

312
00:19:43,778 --> 00:19:47,202
you define where it is lying around with the content URI

313
00:19:47,346 --> 00:19:51,366
and then it is just attached as serverless layer that is always hooked

314
00:19:51,398 --> 00:19:55,222
into the serverless execution function. So every time the function is executed.

315
00:19:55,286 --> 00:19:58,966
The data is available that you have uploaded here. And as functions

316
00:19:58,998 --> 00:20:02,346
and layers are always versioned, you can always update new

317
00:20:02,368 --> 00:20:05,582
versions, for example chromium, but you could also grow back and

318
00:20:05,716 --> 00:20:09,440
switch back and forth in the end.

319
00:20:10,370 --> 00:20:13,802
Also already mentioned you might want to configure databases,

320
00:20:13,946 --> 00:20:17,486
dynamodb, SQS, queues or redis clustered.

321
00:20:17,518 --> 00:20:20,946
Whatever you can think of, you can basically configure in this template because it

322
00:20:20,968 --> 00:20:24,302
is a cloud formation based template and everything that AWS

323
00:20:24,366 --> 00:20:28,350
offers you can configure in this template. So creating an

324
00:20:28,440 --> 00:20:32,166
RDS instance, easy. Creating a queue, very easy. And the

325
00:20:32,188 --> 00:20:35,638
important part is you don't have to do anything on the console and

326
00:20:35,644 --> 00:20:39,910
AWS mentioned copy around to some URLs. But you define just everything internally

327
00:20:40,070 --> 00:20:43,846
and everything is handled by AWS SAm

328
00:20:43,958 --> 00:20:47,354
and also injected accordingly. So if you have to

329
00:20:47,392 --> 00:20:50,458
wait for a certain instance, AWS cases about this.

330
00:20:50,544 --> 00:20:53,934
If you update for example, an instance that you increase for

331
00:20:53,972 --> 00:20:58,122
example the allocated storage because you want to go from 10gb to 100gb,

332
00:20:58,186 --> 00:21:01,294
AWS takes care about this modification of the

333
00:21:01,332 --> 00:21:05,134
resource. You don't have to do it yourself. So there's no manual

334
00:21:05,182 --> 00:21:08,514
setup required. And everything is resources that are just

335
00:21:08,552 --> 00:21:11,140
interconnected and usable for you.

336
00:21:12,070 --> 00:21:15,934
So if we look at it from a development cycle,

337
00:21:15,982 --> 00:21:19,726
I would say right now. So you would start off developing and

338
00:21:19,768 --> 00:21:22,822
configuring what you actually use. So maybe you would start oh, I need a

339
00:21:22,876 --> 00:21:26,742
database in the beginning for my app. Okay, you just configure your database and start

340
00:21:26,796 --> 00:21:30,246
developing. You start developing, creating your first commands,

341
00:21:30,438 --> 00:21:33,580
maybe thinking I have to add this road,

342
00:21:34,430 --> 00:21:37,386
this functions, this service, whatever,

343
00:21:37,568 --> 00:21:41,114
then just build it, deploy it. Everything is

344
00:21:41,152 --> 00:21:44,318
on AWS, check it out or it's running fine,

345
00:21:44,404 --> 00:21:48,542
maybe it's not running. So you're reconfiguring, turning the cycle around.

346
00:21:48,676 --> 00:21:52,382
Everything is just modifying, adding, modifying, removing. And everything

347
00:21:52,436 --> 00:21:56,546
is handled by AWS Sam. So you don't have to care about anything else.

348
00:21:56,728 --> 00:22:00,194
So if you would look now how this would eventually look,

349
00:22:00,312 --> 00:22:03,554
if you're calling Sam build and you worlds have three functions, AWS in this

350
00:22:03,592 --> 00:22:06,914
case the API function, a web function and a queue function.

351
00:22:07,032 --> 00:22:10,360
These functions would be built and zipped by SAM build

352
00:22:10,730 --> 00:22:14,182
based on the configuration that we have made in the template level.

353
00:22:14,316 --> 00:22:18,246
Then you worlds be able to deploy it. If you have deployed once

354
00:22:18,348 --> 00:22:22,138
with a guided environment, the SAM config Tommy is

355
00:22:22,144 --> 00:22:25,766
created which is basically the deployments configuration

356
00:22:25,878 --> 00:22:29,274
that is then available on the system and then can always be

357
00:22:29,312 --> 00:22:33,082
reused. You can also overwrite for example an AWS

358
00:22:33,146 --> 00:22:36,286
profile because you want to use a different profile or deploy the

359
00:22:36,308 --> 00:22:39,822
same application to two different AWS environments, because maybe

360
00:22:39,876 --> 00:22:43,918
for security reasons or whatever, you can even override specific

361
00:22:44,004 --> 00:22:47,918
environment variables and inject something for testing purposes.

362
00:22:48,014 --> 00:22:51,714
So you are pretty much free to do a lot and SAM takes care

363
00:22:51,752 --> 00:22:56,178
about the rest. So you're now deploying apps instead of functions.

364
00:22:56,354 --> 00:23:00,342
And if SAM deploys, you can check out everything that is actually

365
00:23:00,396 --> 00:23:04,754
happening with SAM. So SAM always asks for confirmation,

366
00:23:04,882 --> 00:23:08,898
or basically it asks for that in the default configuration.

367
00:23:08,994 --> 00:23:12,474
And you should never change it actually. So you can see

368
00:23:12,592 --> 00:23:16,154
where is everything uploaded, the s three bucket, you can see what

369
00:23:16,192 --> 00:23:19,718
has been added as a resource, what has been modified as a resource,

370
00:23:19,814 --> 00:23:23,690
what else has been uploaded, for example, all these possibilities

371
00:23:23,770 --> 00:23:27,886
you have available and visible from the command line so

372
00:23:27,908 --> 00:23:31,662
that you can see what is really happening and can really confirm, yes, this is

373
00:23:31,716 --> 00:23:35,406
supposed to be deployed. So if

374
00:23:35,428 --> 00:23:38,994
we look at the deployment configuration, then deployment configuration is pretty

375
00:23:39,032 --> 00:23:42,466
much very simple. It is exactly what you

376
00:23:42,488 --> 00:23:46,030
have entered when you first started guided

377
00:23:46,110 --> 00:23:49,766
deployments via SAM. But the important part is you can

378
00:23:49,788 --> 00:23:53,106
have multiple different stages. So you basically have profiles

379
00:23:53,138 --> 00:23:56,482
here. So you can have a default profile, a dev profile,

380
00:23:56,546 --> 00:24:00,042
a staging provide production profile. And this is the important

381
00:24:00,096 --> 00:24:03,914
part. So you can have multiple deployments directly in

382
00:24:03,952 --> 00:24:07,420
one configure without the requirement to have

383
00:24:08,030 --> 00:24:11,366
different files or different setups or different checkouts

384
00:24:11,398 --> 00:24:14,970
running. So if we would take the two files that we have right now,

385
00:24:15,040 --> 00:24:18,286
we have the template yaml, which is basically the infrastructure as code or

386
00:24:18,308 --> 00:24:21,514
the app as code, if you want to call it like this, and the Sam

387
00:24:21,562 --> 00:24:24,100
config tunnel, which is the deployments AWS code.

388
00:24:24,630 --> 00:24:28,530
So there are of course also some drawbacks.

389
00:24:28,950 --> 00:24:32,686
The example given is pretty much locked to AWS SAM

390
00:24:32,798 --> 00:24:36,158
or AWS in general, but we have split

391
00:24:36,174 --> 00:24:39,558
it up. So good. I would say

392
00:24:39,644 --> 00:24:43,634
that we can just exchange the mediator that we have here with the AWS

393
00:24:43,682 --> 00:24:47,414
SAM and introduce a different one, for example for GCP or

394
00:24:47,532 --> 00:24:51,542
Azure or whatever we want to via scripts or via other tools.

395
00:24:51,606 --> 00:24:54,714
So we created just an ops layer that we can exchange for

396
00:24:54,752 --> 00:24:58,426
something else to deploy our app that works locally and that

397
00:24:58,448 --> 00:25:01,370
worlds out of the box anyways to any other vendor.

398
00:25:01,710 --> 00:25:04,986
The other thing that we did, we introduced a framework. This framework offers

399
00:25:05,018 --> 00:25:08,894
us a lot on functionality and libraries that we potentially can use, but it also

400
00:25:08,932 --> 00:25:12,810
introduced some overhead. And the overhead

401
00:25:12,890 --> 00:25:16,578
can increase the boot and execution time of your serverless function.

402
00:25:16,664 --> 00:25:19,886
And this is important because every millisecond of reserved

403
00:25:19,918 --> 00:25:22,974
memory that you use from your serverless

404
00:25:23,022 --> 00:25:26,722
function, cases and costs can excel pretty heavily.

405
00:25:26,866 --> 00:25:30,614
But as you use existing frameworks. Frameworks have

406
00:25:30,812 --> 00:25:34,114
common optimizations, frameworks are normally known

407
00:25:34,242 --> 00:25:37,446
and there's a lot of documentation. So in most cases you

408
00:25:37,468 --> 00:25:41,050
can circumvent this overhead that you generate there

409
00:25:41,120 --> 00:25:44,714
and it doesn't affect your serverless function too much, at least from

410
00:25:44,752 --> 00:25:48,886
my experience. So with all my advocating

411
00:25:48,918 --> 00:25:53,054
for serverless right now, everything could go serverless right

412
00:25:53,092 --> 00:25:57,418
now, right? So if you ask yourself do I need serverless?

413
00:25:57,514 --> 00:26:00,990
I would say no. So serverless is not the first

414
00:26:01,060 --> 00:26:04,770
idea to think about. As mentioned, think about your application.

415
00:26:04,920 --> 00:26:08,946
First start developing your application, then with

416
00:26:08,968 --> 00:26:12,786
a big but you can look at the pros and cons and think about if

417
00:26:12,808 --> 00:26:16,206
you should introduce a deployment to a serverless environment.

418
00:26:16,398 --> 00:26:20,150
It provides high availability and nearly endless scalability without

419
00:26:20,220 --> 00:26:23,874
the need of a big DevOps team. So really this is bringing the developer

420
00:26:23,922 --> 00:26:27,954
back to operation. Who can maintain a fully running serverless

421
00:26:28,002 --> 00:26:31,274
application on its own. It's easy to start and

422
00:26:31,312 --> 00:26:34,966
cases with your customer supporting peaks when you have for example marketing

423
00:26:34,998 --> 00:26:38,902
campaigns. So if you are ever in the lions

424
00:26:38,966 --> 00:26:42,794
then you're ready for it. You're only

425
00:26:42,832 --> 00:26:46,126
paying when it's running and the availability is only given when it's running.

426
00:26:46,228 --> 00:26:50,398
So it's good. If you have also maybe no traffic, no customers,

427
00:26:50,484 --> 00:26:53,986
it's not good, but at least then you are not paying. And I only gave

428
00:26:54,008 --> 00:26:57,346
you a glimpse about serverless deployments and serverless abilities right now,

429
00:26:57,368 --> 00:27:01,220
so there's much more to discover. So just go ahead.

430
00:27:01,910 --> 00:27:05,266
But on the opposite side,

431
00:27:05,368 --> 00:27:08,838
you have no insights into the infrastructure. This is good and bad. You don't want

432
00:27:08,844 --> 00:27:12,326
to care about the infrastructure, but this also limits you in the optimization that

433
00:27:12,348 --> 00:27:15,858
you have. You cannot care about servers, you cannot

434
00:27:15,874 --> 00:27:19,274
cases about memory basically, or cpus or what hardware is

435
00:27:19,312 --> 00:27:22,860
used. This is all provided by the vendor that you are locking in.

436
00:27:23,310 --> 00:27:26,650
Costs can easily excel AWS a serverless

437
00:27:27,070 --> 00:27:30,310
on a serverless environment, as serverless really requires optimization

438
00:27:30,470 --> 00:27:33,966
because you are paying as mentioned for every millisecond in memory. And now for

439
00:27:33,988 --> 00:27:37,374
example, if you set a timeout of let's say five minutes and you are

440
00:27:37,412 --> 00:27:41,470
reserving 1gb of ram and you have a failed,

441
00:27:41,970 --> 00:27:46,030
I don't know, a board condition that is not hooking

442
00:27:46,190 --> 00:27:48,482
and every time you're paying for five minutes,

443
00:27:48,536 --> 00:27:52,878
1gb and this can be very, very expensive very easily.

444
00:27:52,974 --> 00:27:56,658
So always think about monitoring very important and setting limits.

445
00:27:56,834 --> 00:28:00,086
The other thing is if you have constantly running apps or

446
00:28:00,108 --> 00:28:03,474
constantly running endpoints, then maybe serverless

447
00:28:03,522 --> 00:28:06,886
is not the best because you're paying basically for

448
00:28:06,908 --> 00:28:10,362
every invocation of the serverless app. And maybe it's better

449
00:28:10,416 --> 00:28:14,794
to have it warmed up, have it caching and

450
00:28:14,832 --> 00:28:18,186
have it running on normal instances and just scale in

451
00:28:18,208 --> 00:28:22,014
a more classic manner. The other thing is you're only

452
00:28:22,052 --> 00:28:25,534
as scalable as the rest that you configure. If you

453
00:28:25,572 --> 00:28:28,990
configure resources like for example the smallest database available,

454
00:28:29,140 --> 00:28:32,458
then of course you might be able to

455
00:28:32,564 --> 00:28:36,526
catch 10 million requests because of an advertising campaign.

456
00:28:36,638 --> 00:28:40,002
But your database cannot hold it. So the biggest part

457
00:28:40,056 --> 00:28:44,290
always defines your availability and scalability.

458
00:28:44,710 --> 00:28:48,722
And one important point, in a serverless environment

459
00:28:48,866 --> 00:28:52,386
you are limited to the computational resources that the vendor

460
00:28:52,418 --> 00:28:56,262
provides you. So for example, you can define a timeout and a memory size,

461
00:28:56,316 --> 00:28:59,862
but you cannot define the cpu amount. For example

462
00:28:59,916 --> 00:29:03,914
in the AWS case because at the current state with

463
00:29:03,952 --> 00:29:07,414
every 768 megabytes you get one VCPU.

464
00:29:07,462 --> 00:29:10,826
So until you go over this limit of memory you only

465
00:29:10,848 --> 00:29:14,314
have one VCPU. But if you need for example more vcpus

466
00:29:14,362 --> 00:29:18,302
you would have to increase the memory size. But with memory size you again pay

467
00:29:18,356 --> 00:29:22,030
more money and you have to decide if you want to go

468
00:29:22,100 --> 00:29:25,070
down that route or optimize your application.

469
00:29:25,220 --> 00:29:29,202
So this is a good and bad part. You are forced to optimize your application

470
00:29:29,336 --> 00:29:32,420
to reduce the memory and execution time.

471
00:29:32,950 --> 00:29:36,200
So now looking at the pros and cons,

472
00:29:36,970 --> 00:29:40,678
I cannot give you really decisive answer

473
00:29:40,764 --> 00:29:44,742
if you should go serverless. The only thing I could

474
00:29:44,796 --> 00:29:48,582
say is just go, just try it out.

475
00:29:48,716 --> 00:29:52,598
There are so many free tiers and free accounts that you could

476
00:29:52,684 --> 00:29:56,040
register for Microsoft AWS or whatever.

477
00:29:56,570 --> 00:30:00,602
Take the example that is provided on GitHub with this presentation nation

478
00:30:00,746 --> 00:30:04,222
and just try it. But find out for yourself if this works

479
00:30:04,276 --> 00:30:08,494
out in your environment. If this is a good use case for your application,

480
00:30:08,692 --> 00:30:12,654
you know best what to do, but think about your application first

481
00:30:12,772 --> 00:30:16,414
and not the operation part. Serverless is only here to

482
00:30:16,452 --> 00:30:20,174
help you and not to dictate what you should

483
00:30:20,212 --> 00:30:22,140
do. Thanks a lot for your time.

