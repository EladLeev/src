1
00:01:28,370 --> 00:01:32,002
This is a developer's introduction to service mesh. I realized

2
00:01:32,066 --> 00:01:35,878
that a lot of the service mesh resources that I was seeing had

3
00:01:35,964 --> 00:01:39,138
can operator approach to it, which is how do you build a service mesh?

4
00:01:39,154 --> 00:01:42,234
How do you configure it? But it turns out there's a lot of developer

5
00:01:42,282 --> 00:01:46,190
capability that you need to take in service mesh

6
00:01:46,690 --> 00:01:49,934
and use for your applications in order to get value out of it.

7
00:01:49,972 --> 00:01:53,522
So if you're a developer or you're an operator, who needs to maybe

8
00:01:53,576 --> 00:01:57,042
enable developers on how to use a service mesh? This is

9
00:01:57,096 --> 00:02:00,866
a very rapid introduction and overview into all of

10
00:02:00,888 --> 00:02:04,180
the different ways a service mesh affects your application.

11
00:02:06,550 --> 00:02:10,322
So my journey into service mesh started with this very vague statement

12
00:02:10,386 --> 00:02:13,878
of we must have a service mesh. And a security

13
00:02:13,964 --> 00:02:17,682
engineer approached me with this concern. I was a little bit confused.

14
00:02:17,746 --> 00:02:21,098
I wasn't sure what a service mesh was at the time. I was kind

15
00:02:21,104 --> 00:02:24,682
of doing an embed with an application development team as

16
00:02:24,736 --> 00:02:28,310
sort of an operations or infrastructure engineer,

17
00:02:28,390 --> 00:02:31,982
and it was a very interesting statement. I had never heard of it.

18
00:02:32,036 --> 00:02:35,710
And eventually I got to the core of what the

19
00:02:35,780 --> 00:02:39,694
engineer was looking for, and they mentioned to me that they wanted service

20
00:02:39,812 --> 00:02:43,602
to service communication with mtls. Basically, they wanted

21
00:02:43,656 --> 00:02:47,166
each service to communicate encrypted with a certificate.

22
00:02:47,358 --> 00:02:51,618
And when they approached the application

23
00:02:51,704 --> 00:02:55,326
team for this requirement,

24
00:02:55,438 --> 00:02:59,190
the concern was that it would take way too long to refactor every single

25
00:02:59,260 --> 00:03:02,946
application and all of the code to use certificates.

26
00:03:03,058 --> 00:03:06,230
And that is a valid concern. Do you need

27
00:03:06,300 --> 00:03:10,434
service to service mtls? If for the most part you've secured

28
00:03:10,482 --> 00:03:13,938
all your applications internally into a private network?

29
00:03:14,034 --> 00:03:17,930
Well, you can never be too sure. So the security

30
00:03:18,000 --> 00:03:21,462
team was looking for a way to secure communications

31
00:03:21,526 --> 00:03:25,194
with mtls, point to point with applications and

32
00:03:25,312 --> 00:03:29,354
their research introduction service mesh. Now, as I investigated

33
00:03:29,402 --> 00:03:33,038
service mesh a little bit further, it turns out there's a lot of pieces to

34
00:03:33,124 --> 00:03:36,702
how applications connect to each other. It's not just about securing

35
00:03:36,766 --> 00:03:39,682
and encrypting the communications between services.

36
00:03:39,816 --> 00:03:43,314
Turns out, services need to discover each other. We usually did this by

37
00:03:43,352 --> 00:03:47,798
DNS. So how does service one get to service two second

38
00:03:47,884 --> 00:03:51,222
services? Load balance. You need to be able to load balance between

39
00:03:51,276 --> 00:03:54,680
instances of services as well as between different services.

40
00:03:55,770 --> 00:03:58,886
Security was the concern that first came to

41
00:03:58,908 --> 00:04:02,890
me. But besides mtls, there's also authorization too.

42
00:04:02,960 --> 00:04:06,758
So are services allowed to communicate with each other on an API?

43
00:04:06,854 --> 00:04:10,650
There were a lot of sophisticated tools out there, as well as code libraries that

44
00:04:10,720 --> 00:04:14,880
were supporting this in applications. And did we really want to change that?

45
00:04:15,570 --> 00:04:18,926
Finally, traffic management. Some applications might be

46
00:04:18,948 --> 00:04:22,686
a little bit more sophisticated in how they require retry handling as

47
00:04:22,708 --> 00:04:26,434
well as error handling and telemetry, which we were

48
00:04:26,472 --> 00:04:30,082
trying for brick tracing. It was really difficult to implement and we were trying

49
00:04:30,136 --> 00:04:32,882
to pretty much get metrics unified across the board.

50
00:04:32,936 --> 00:04:36,242
So all of these functions were ways in which

51
00:04:36,296 --> 00:04:40,166
services communicated with each other or the ways that they needed to

52
00:04:40,188 --> 00:04:43,334
interact with each other. We weren't really sure what

53
00:04:43,372 --> 00:04:46,934
a good answer was because right now all of these different kinds of

54
00:04:46,972 --> 00:04:50,230
concepts required multiple tools.

55
00:04:50,970 --> 00:04:54,186
And so I did more research on the service mesh to try to

56
00:04:54,208 --> 00:04:57,946
understand why it solves this problem. And it comes down to this.

57
00:04:58,048 --> 00:05:01,802
Service meshes rely on something called proxies. In this case, we're talking

58
00:05:01,856 --> 00:05:05,358
about envoy proxy as a tool, but there are many other proxies as

59
00:05:05,364 --> 00:05:08,686
well as service meshes with other custom proxies. But in

60
00:05:08,708 --> 00:05:12,766
this case, we'll just focus a little bit more on envoy. For every application

61
00:05:12,868 --> 00:05:16,562
instance that you have, for example, I have report v two, report v three,

62
00:05:16,616 --> 00:05:20,002
expense v one, and expense v two, I have a proxy running

63
00:05:20,056 --> 00:05:24,290
next to it. The proxy is responsible for all communications between services.

64
00:05:24,440 --> 00:05:27,574
So anytime you need to communicate out of report v two,

65
00:05:27,612 --> 00:05:31,270
it goes through proxy. Anytime it comes in, it's through proxy.

66
00:05:32,170 --> 00:05:35,810
This has an interesting side effect. If you have multiple

67
00:05:35,970 --> 00:05:39,660
application frameworks, which is usually the case in larger companies,

68
00:05:40,190 --> 00:05:43,654
you have the ability to, well, direct traffic

69
00:05:43,702 --> 00:05:47,466
through the proxies. And as a side effect, this means that you can build

70
00:05:47,568 --> 00:05:51,182
abstractions or almost a layer on top

71
00:05:51,236 --> 00:05:55,290
of the proxies. For example, the expense proxies represent

72
00:05:55,370 --> 00:05:58,974
as a whole the expense service, whether version one, version two.

73
00:05:59,092 --> 00:06:02,790
Similarly, the report service represents the abstraction of report version

74
00:06:02,810 --> 00:06:06,900
two and version three, and the proxies can represent that.

75
00:06:07,750 --> 00:06:11,474
Now report communications to expense. Similarly, everything goes

76
00:06:11,512 --> 00:06:14,978
through the proxies. So the proxies control whether or not report service

77
00:06:15,064 --> 00:06:18,120
can communicate to expense, the upstream service.

78
00:06:18,970 --> 00:06:22,754
All of this, right, plus some kind of control plane equals

79
00:06:22,802 --> 00:06:26,534
a service mesh. And when we mention control plane, we mentioned it

80
00:06:26,572 --> 00:06:30,454
as a way to say you can push configurations out to each proxy

81
00:06:30,582 --> 00:06:33,850
and a service mesh pushes configuration out to each proxy.

82
00:06:34,270 --> 00:06:37,690
So if, for example, I wanted to create a report service,

83
00:06:37,760 --> 00:06:41,514
the service mesh would create the abstraction of the report service

84
00:06:41,632 --> 00:06:45,774
and send that configuration to proxies. Now, regardless of

85
00:06:45,812 --> 00:06:49,326
which service mesh you use, for the most part, they're all using a very similar

86
00:06:49,428 --> 00:06:53,574
approach in the way that they're pushing the configuration out to the proxies.

87
00:06:53,642 --> 00:06:56,834
So most of the configurations you'll see today, while they are

88
00:06:56,872 --> 00:07:00,286
consul focused or they're envoy proxy focused,

89
00:07:00,398 --> 00:07:04,062
you'll see similar functionality in other service meshes.

90
00:07:04,126 --> 00:07:07,366
My hope is that if you're using something else, you'll be able to understand the

91
00:07:07,388 --> 00:07:10,934
terminology, the generic terminology, and apply it

92
00:07:10,972 --> 00:07:14,758
to your application. So in this

93
00:07:14,924 --> 00:07:18,326
case we are able to create a

94
00:07:18,348 --> 00:07:22,346
service mesh configuration, push it out to proxies. Now if

95
00:07:22,368 --> 00:07:26,694
you're in kubernetes, it's pretty easy to add the proxy

96
00:07:26,742 --> 00:07:30,426
in place. The idea is that you can use an annotation or

97
00:07:30,448 --> 00:07:34,014
you can inject it by default. So most service meshes will allow you to

98
00:07:34,052 --> 00:07:38,026
add a service mesh annotation and it will inject

99
00:07:38,138 --> 00:07:42,062
the proxy for you and the proxy for

100
00:07:42,116 --> 00:07:45,854
many of the Kubernetes ones are envoy, although some of the other service meshes

101
00:07:45,902 --> 00:07:49,346
use different proxy tools. So the

102
00:07:49,368 --> 00:07:53,010
idea is that if you're doing this in Kubernetes, you can do the annotation

103
00:07:53,350 --> 00:07:57,346
in console. Does do service mesh outside of

104
00:07:57,368 --> 00:08:01,586
kubernetes as well. In this case you do have to add the process sidecar.

105
00:08:01,698 --> 00:08:05,078
Process sidecar proxy. So if you're doing this on

106
00:08:05,084 --> 00:08:08,902
a virtual machine for a much older application, you will have to deploy

107
00:08:08,966 --> 00:08:12,570
the binary for the proxy and then configure it as a process

108
00:08:12,640 --> 00:08:14,010
on the virtual machine.

109
00:08:16,990 --> 00:08:20,060
So next, what does this mean? Well,

110
00:08:20,530 --> 00:08:24,094
this configuration, this abstraction, pushing all

111
00:08:24,132 --> 00:08:27,882
of these things into a service mesh means that you can configure

112
00:08:28,026 --> 00:08:31,358
service discovery, load balancing, security, traffic management and

113
00:08:31,364 --> 00:08:34,762
telemetry in one place irrespective of the

114
00:08:34,916 --> 00:08:38,418
application code and the library. So if you're a

115
00:08:38,424 --> 00:08:41,874
development team or you're an operations team tracing to enable development team doing

116
00:08:41,912 --> 00:08:45,406
this, the idea is that you're replacing the functionality

117
00:08:45,438 --> 00:08:49,094
that you might have implemented or already implemented in code for

118
00:08:49,132 --> 00:08:53,138
service discovery, cloud balancing, security, traffic management and arguably telemetry

119
00:08:53,234 --> 00:08:56,120
into a service mesh. So we're going to go through all five of these.

120
00:08:56,810 --> 00:09:00,266
In the case of service discovery, remember there's two sets of

121
00:09:00,288 --> 00:09:03,606
abstractions, the application options as well as the service mesh.

122
00:09:03,798 --> 00:09:07,306
Application side options typically involve libraries like Eureka if

123
00:09:07,328 --> 00:09:10,682
you're in the securing ecosystem, DNS or Kubernetes services.

124
00:09:10,736 --> 00:09:14,366
If you're on Kubernetes, a service mesh does this all with

125
00:09:14,388 --> 00:09:18,302
proxy registration. So in the application code

126
00:09:18,356 --> 00:09:21,406
case in a programming language that allows you to do this,

127
00:09:21,588 --> 00:09:24,862
you can do something as easily as adding an annotation

128
00:09:25,006 --> 00:09:28,306
in your application. So this is securing and in

129
00:09:28,328 --> 00:09:32,494
this case I'm enabling discovery client and now I've got service discovery for spring

130
00:09:32,542 --> 00:09:36,174
applications. Problematically, not all applications

131
00:09:36,222 --> 00:09:40,594
are using spring or Java for that matter. So you may have heterogeneous

132
00:09:40,642 --> 00:09:43,974
workloads with different kinds of application frameworks, and in which case maybe

133
00:09:44,012 --> 00:09:47,558
the service mesh service discovery approach is actually

134
00:09:47,644 --> 00:09:51,126
much more useful. Service mesh will again create the

135
00:09:51,148 --> 00:09:54,298
abstraction of the report service for v two, v three, as well

136
00:09:54,304 --> 00:09:57,942
as the expense service for v one, v two. Doesn't matter what application frameworks

137
00:09:58,006 --> 00:10:02,030
they are when you look at a service mesh

138
00:10:02,450 --> 00:10:06,810
admin configuration. So if you're looking at the proxy admin configuration,

139
00:10:06,970 --> 00:10:10,362
most of them will have this cluster's endpoint.

140
00:10:10,426 --> 00:10:13,870
And this cluster's endpoint has a list of the service name,

141
00:10:13,940 --> 00:10:17,806
such as expense, as well as the ip address. So in this case I'm

142
00:10:17,838 --> 00:10:21,246
going to the proxy, the envoy proxy, running an API

143
00:10:21,278 --> 00:10:25,066
call to just do some debugging. And if you examine this debug interface,

144
00:10:25,118 --> 00:10:28,402
you'll see that there's can expense mapping, Jaeger mapping,

145
00:10:28,466 --> 00:10:31,480
expense v two mapping to each IP address.

146
00:10:33,290 --> 00:10:37,014
This is actually pushed out because when the proxy registers it

147
00:10:37,052 --> 00:10:40,438
has information about the service and consul

148
00:10:40,454 --> 00:10:43,398
itself pushes that information further to the proxies.

149
00:10:43,494 --> 00:10:47,660
So that is where you're getting the service discovery piece.

150
00:10:48,270 --> 00:10:51,370
In the case of load balancing, you also have two options

151
00:10:51,440 --> 00:10:55,306
here, application side. Again, you can use a library like thane load

152
00:10:55,338 --> 00:10:59,006
balancers and DNS. The combination usually give you some

153
00:10:59,028 --> 00:11:02,554
kind of load balancing configuration. In the case of service mesh,

154
00:11:02,602 --> 00:11:06,670
you're using pretty much just proxy configuration. So again, if you're lucky

155
00:11:06,750 --> 00:11:10,274
and you're using something like spring, you have enable fang clients and

156
00:11:10,312 --> 00:11:13,582
that injects a client that allows you to load balance

157
00:11:13,646 --> 00:11:17,510
between certain service instances or application instances.

158
00:11:18,970 --> 00:11:22,226
In the case of multiple application frameworks,

159
00:11:22,258 --> 00:11:25,574
well, a service mesh again takes that abstraction, pushes it out

160
00:11:25,612 --> 00:11:28,746
into a separate layer. So in this case you can use a service mesh to

161
00:11:28,768 --> 00:11:32,074
push configuration out 50% to version 150 percent

162
00:11:32,112 --> 00:11:35,900
to versions two. What this looks like is that

163
00:11:36,750 --> 00:11:39,500
if you go into console, for example,

164
00:11:39,970 --> 00:11:44,634
and I retrieve service splitter

165
00:11:44,762 --> 00:11:48,682
configuration, what this does is that it outlines sort of an expense

166
00:11:48,746 --> 00:11:53,146
service splitter, for example. And if I print out the CRD

167
00:11:53,178 --> 00:11:56,526
or the custom resource for it, you'll notice that 50% of the weight goes

168
00:11:56,548 --> 00:11:59,794
to v 150 percent goes to v two. All of this is

169
00:11:59,832 --> 00:12:03,346
done through my interface of choice for my service mesh. So in this

170
00:12:03,368 --> 00:12:06,658
case, this is a custom resource definition in Kubernetes. But you could

171
00:12:06,664 --> 00:12:10,550
do this with an API call to console, API call to any other service mesh.

172
00:12:10,970 --> 00:12:14,630
Why is this important? Well, when you examine this in

173
00:12:14,700 --> 00:12:17,886
your service mesh configuration or your proxy configuration,

174
00:12:18,018 --> 00:12:22,182
your service mesh is mapping that interface,

175
00:12:22,246 --> 00:12:26,262
that declarative interface that you've made on the weight

176
00:12:26,406 --> 00:12:30,154
to your proxy configuration so

177
00:12:30,272 --> 00:12:33,754
effectively what it's doing is that it's doing that transformation

178
00:12:33,802 --> 00:12:37,722
for you. So you'll also notice the weights 5000 5000 expense

179
00:12:37,786 --> 00:12:41,006
and expense v two as well as the total weight. So this

180
00:12:41,028 --> 00:12:44,718
is on the administrative side of the proxy itself.

181
00:12:44,804 --> 00:12:48,498
So the proxy has JSOn and this is actually available

182
00:12:48,584 --> 00:12:52,894
for you to see. So basically service meshes are pushing all this configuration

183
00:12:52,942 --> 00:12:56,934
out to the proxies and now the proxy have awareness of all

184
00:12:56,972 --> 00:13:00,502
of these weights that you need. The benefit of this

185
00:13:00,636 --> 00:13:04,086
is that if you are accessing it from report service,

186
00:13:04,188 --> 00:13:08,198
so that's what I'm going to do. I'm going to

187
00:13:08,364 --> 00:13:12,506
access this through an API call from my upstream service

188
00:13:12,608 --> 00:13:16,150
to my expense service and I'm just going to get the expense version.

189
00:13:16,310 --> 00:13:19,834
You'll notice that it is load balancing between the

190
00:13:19,872 --> 00:13:23,486
Java version which is o zero one snapshot as well

191
00:13:23,508 --> 00:13:27,790
as the net version which is 60. So all of these are

192
00:13:27,940 --> 00:13:31,806
configure through one interface and pushed out. So irrespective of

193
00:13:31,828 --> 00:13:35,550
whether or not net or Java or any other application framework,

194
00:13:35,630 --> 00:13:38,100
you have a single abstraction to do that.

195
00:13:42,470 --> 00:13:46,146
So security, this is where I started my journey and this is where I

196
00:13:46,168 --> 00:13:48,934
first heard about service mesh. And there were some misnomers to it,

197
00:13:48,972 --> 00:13:52,886
right? Security requires a couple different abstractions when

198
00:13:52,908 --> 00:13:56,738
it comes to loading a certificate or doing API authorization.

199
00:13:56,834 --> 00:14:00,450
So libraries will, and write your own libraries

200
00:14:00,530 --> 00:14:04,246
often allow sort of an easy interface to side cloud

201
00:14:04,278 --> 00:14:07,514
a certificate or validate it if you want. On top of that,

202
00:14:07,552 --> 00:14:11,134
if you're doing something like API authorization, for example, report can only

203
00:14:11,252 --> 00:14:13,790
access expense on the version endpoint.

204
00:14:14,370 --> 00:14:18,334
That API authorization flow could be done separately by a

205
00:14:18,372 --> 00:14:22,480
server, a special server, or it can do it by OIDC or job.

206
00:14:22,930 --> 00:14:25,860
In the case of service mesh, it's a little bit different.

207
00:14:26,550 --> 00:14:30,366
You get mtls out of the box between proxies

208
00:14:30,558 --> 00:14:34,142
as well as proxy filters, and the proxy filters

209
00:14:34,206 --> 00:14:38,062
help you filter traffic based on API authorization

210
00:14:38,126 --> 00:14:41,814
endpoints. So I'll actually show this. First we'll talk about the application side

211
00:14:41,852 --> 00:14:45,842
and then we'll talk about service mesh. But on the application side, the complicated

212
00:14:45,906 --> 00:14:49,366
complaint that I was getting from a number of developers for quite some time was

213
00:14:49,388 --> 00:14:52,550
that they would have to add their own certificate validation

214
00:14:52,630 --> 00:14:55,930
code into their codebase. And this is taken from the

215
00:14:56,000 --> 00:14:59,450
ASP net core documentation. But for example, in the case of.

216
00:14:59,520 --> 00:15:03,138
Net you'll have to add a validation event and you'll

217
00:15:03,174 --> 00:15:05,966
have to add your own logic for that. So it can be quite a bit

218
00:15:05,988 --> 00:15:08,986
of code. In the case of service mesh,

219
00:15:09,098 --> 00:15:12,234
mtls is a little bit different mtls

220
00:15:12,282 --> 00:15:15,714
happens between each of the proxies. So proxy from v one

221
00:15:15,752 --> 00:15:18,994
to v three to v one,

222
00:15:19,032 --> 00:15:23,086
v two, v three across. All of these services are all mtls,

223
00:15:23,118 --> 00:15:26,582
so they're all encrypted. However, they're not encrypted between

224
00:15:26,636 --> 00:15:30,962
proxy and report, for example, report v three, for example. So each proxy

225
00:15:31,026 --> 00:15:34,950
that is running sidecar with the report or

226
00:15:35,020 --> 00:15:38,902
expense instance is not going to have any

227
00:15:38,956 --> 00:15:42,614
mtls. So that's where the caveat is, but mtls

228
00:15:42,662 --> 00:15:45,130
is going to be within the mesh and between the proxies.

229
00:15:46,270 --> 00:15:49,462
Now, if you're looking at this in the service mesh,

230
00:15:49,526 --> 00:15:53,626
you can actually see that it is applying a certificate to each proxy.

231
00:15:53,738 --> 00:15:57,450
So if you do a config dump, which is again the administrative interface

232
00:15:57,530 --> 00:16:00,814
for envoy proxy, you'll notice that there's a

233
00:16:00,852 --> 00:16:03,822
certificate chain as well as a private key and a validation context.

234
00:16:03,886 --> 00:16:07,346
So all of this is done within the mesh. So you get

235
00:16:07,448 --> 00:16:10,930
mtls between proxies, effectively point to point,

236
00:16:11,000 --> 00:16:14,450
it's unencrypted between the proxy and the application instance.

237
00:16:21,930 --> 00:16:25,894
Second piece of this is API authorization. API authorization is

238
00:16:25,932 --> 00:16:29,218
whether or not report can communications to expense.

239
00:16:29,314 --> 00:16:32,726
Can it do it on certain API endpoints, can you only do it on

240
00:16:32,748 --> 00:16:36,346
certain methods? Now in spring, it's really easy to

241
00:16:36,368 --> 00:16:40,214
get this done in that you have an oauth two client annotation

242
00:16:40,262 --> 00:16:44,022
as well as a global method security annotation, and then you can configure

243
00:16:44,166 --> 00:16:47,994
how services communicate to each other. But if you have something like

244
00:16:48,112 --> 00:16:51,514
net go or something else that doesn't really exist,

245
00:16:51,562 --> 00:16:54,606
it's not that easy to implement. You have to build yourself. So in

246
00:16:54,628 --> 00:16:57,882
this case you can push it into once again the service mesh.

247
00:16:58,026 --> 00:17:02,414
So for example, in this service mesh, I'm allowing report to access API

248
00:17:02,462 --> 00:17:06,350
expense trip on the expense service. That API authorization

249
00:17:06,430 --> 00:17:10,414
means that if the traffic going through the proxy accesses

250
00:17:10,542 --> 00:17:14,326
an endpoint to the expense service that's not API expense trip, it will

251
00:17:14,348 --> 00:17:18,034
not be allowed to do so. It's a little confusing,

252
00:17:18,082 --> 00:17:21,186
and there's a lot of text in this, but the idea is that if you're

253
00:17:21,218 --> 00:17:25,094
doing a dump on the administrative interface of envoy

254
00:17:25,142 --> 00:17:28,070
proxy, you'll notice that there's a filter implementation.

255
00:17:28,150 --> 00:17:32,090
This filter implementation adds the rules for

256
00:17:32,240 --> 00:17:35,978
access between services. So in this case, the principal

257
00:17:36,074 --> 00:17:39,774
report can access expense on

258
00:17:39,812 --> 00:17:43,498
the path prefix of API expense trip. However, it's not allowed

259
00:17:43,514 --> 00:17:46,862
to access anything else. Now, if you were to look at this

260
00:17:46,996 --> 00:17:49,938
not as part of envoy proxy, and you were to look at this in a

261
00:17:49,944 --> 00:17:53,986
much, I would say a much more user friendly way.

262
00:17:54,168 --> 00:17:57,326
You can see this as part of, let's say something called intentions

263
00:17:57,358 --> 00:18:00,958
in consul console basically abstracts

264
00:18:01,134 --> 00:18:04,566
these proxy configurations and will sort of give

265
00:18:04,588 --> 00:18:08,214
you a more intent driven view of how it works.

266
00:18:08,332 --> 00:18:12,906
But effectively what it's doing is that when you create a custom resource and

267
00:18:13,088 --> 00:18:17,018
called an intention, the intention describes you can allow report

268
00:18:17,104 --> 00:18:20,774
to access expense on API

269
00:18:20,822 --> 00:18:24,442
expense trip using a get. You can also get from the API from

270
00:18:24,496 --> 00:18:27,726
report, but you cannot do anything else. So in

271
00:18:27,748 --> 00:18:31,600
this case, this intention is mapping down to

272
00:18:32,050 --> 00:18:35,546
the proxy configuration that I showed

273
00:18:35,578 --> 00:18:36,350
earlier.

274
00:18:39,110 --> 00:18:42,830
So traffic management, this one's a little bit more complicated.

275
00:18:42,910 --> 00:18:46,414
It can get very very lengthy to describe,

276
00:18:46,462 --> 00:18:49,618
and so I'm going to try to abbreviate this. But in

277
00:18:49,704 --> 00:18:53,794
application space, especially with services, we talk a lot about circuit breaking,

278
00:18:53,842 --> 00:18:57,734
retry handling, the importance of error handling, and most

279
00:18:57,772 --> 00:19:01,654
of these have been traditionally done by libraries. So there

280
00:19:01,692 --> 00:19:05,650
were libraries that would allow you to circuit break based on certain configurations,

281
00:19:05,810 --> 00:19:09,466
or you would write your own kind of retry handling, which does happen.

282
00:19:09,648 --> 00:19:13,398
In the case of service mesh, you can do a similar functionality.

283
00:19:13,494 --> 00:19:17,326
There is a bit of a confusing terminology shift in that

284
00:19:17,348 --> 00:19:20,734
if you're using something like envoy, a circuit breaker is

285
00:19:20,772 --> 00:19:24,506
not quite the same as the circuit breaking pattern. The circuit

286
00:19:24,538 --> 00:19:28,450
breaker sets the maximum pending and current connections for the upstream services,

287
00:19:28,600 --> 00:19:32,622
and then outlier detection does the collection. So technically outlier detection

288
00:19:32,686 --> 00:19:36,722
does the circuit breaking and ejects the service instance once certain

289
00:19:36,776 --> 00:19:40,354
number of failures reach a threshold. But the

290
00:19:40,392 --> 00:19:43,954
communications of the two combined implement the circuit breaker

291
00:19:44,002 --> 00:19:47,686
pattern. So if you're familiar with that from can application view, you'll need

292
00:19:47,708 --> 00:19:51,522
the combination. So in the case of securing

293
00:19:51,586 --> 00:19:55,142
really nice, you enable circuit breaker. It's an annotation there.

294
00:19:55,276 --> 00:19:58,506
It makes it super easy. In the case of net, it's a little bit

295
00:19:58,528 --> 00:20:02,986
trickier. You have to write your own circuit breaker policy. So in

296
00:20:03,008 --> 00:20:06,454
this case, the trouble with this is that if you want a holistic

297
00:20:06,502 --> 00:20:09,758
view across all of your services about how they're circuit breaking on

298
00:20:09,764 --> 00:20:12,906
each other and all of their behaviors, you'll have to scan

299
00:20:12,938 --> 00:20:16,800
through all of the code in order to find that information. So in this situation,

300
00:20:17,170 --> 00:20:20,546
you do have to consider how do you inject this

301
00:20:20,568 --> 00:20:24,274
information into each application. And if it's not using net

302
00:20:24,312 --> 00:20:28,274
and it's using something different, and you're doing this across multiple services,

303
00:20:28,392 --> 00:20:32,302
you need to keep track of what kind of circuit breaker behavior

304
00:20:32,366 --> 00:20:35,842
is happening. So there are some nuances to this so you can implement

305
00:20:35,906 --> 00:20:38,550
this again as an abstraction in service mesh.

306
00:20:38,890 --> 00:20:42,578
If there's a certain number of HTTP 500 errors like greater

307
00:20:42,594 --> 00:20:45,794
than three, eject the service and then divert

308
00:20:45,842 --> 00:20:49,046
traffic to the other service version. So this is pretty useful.

309
00:20:49,158 --> 00:20:52,218
If, for example, you rolled out expense v two and there are a ton of

310
00:20:52,224 --> 00:20:55,786
errors in it, then circuit breaking will eject the

311
00:20:55,808 --> 00:20:59,638
service and then divert everything by default to expense v

312
00:20:59,664 --> 00:21:03,358
one. Circuit breaking does require a little bit more time to show.

313
00:21:03,444 --> 00:21:06,638
I'm not going to show that today for the sake of time,

314
00:21:06,724 --> 00:21:10,402
but if you're interested in seeing this, there are a couple

315
00:21:10,456 --> 00:21:13,806
of interesting videos to show how circuit

316
00:21:13,838 --> 00:21:16,610
breaking in service mesh works in greater depth.

317
00:21:18,230 --> 00:21:21,330
Now, in order to configure this in the console side,

318
00:21:21,480 --> 00:21:25,382
I won't show this in the envoy config because it's a big, rather large

319
00:21:25,436 --> 00:21:28,834
config. But if you're configuring this from your service mesh

320
00:21:28,882 --> 00:21:32,286
and you're pushing it into your envoy configure, you would configure

321
00:21:32,338 --> 00:21:34,540
something in consul called a passive health check.

322
00:21:36,350 --> 00:21:39,974
Finally, this is probably the one that is my favorite,

323
00:21:40,022 --> 00:21:43,706
but also the one that I get commonly asked questions for

324
00:21:43,888 --> 00:21:47,486
telemetry is a little bit tricky. There's two sources of

325
00:21:47,508 --> 00:21:51,162
telemetry, and that's for metrics and for traces.

326
00:21:51,226 --> 00:21:55,006
So when I say telemetry, it's for metrics and traces both. But there's actually two

327
00:21:55,028 --> 00:21:58,660
sources of telemetry you need. There's application side

328
00:21:59,270 --> 00:22:02,494
sources. So this is like the libraries for open telemetry,

329
00:22:02,542 --> 00:22:06,594
the Prometheus exporters, or you write your own application side options.

330
00:22:06,792 --> 00:22:10,194
Then there's the service mesh telemetry. So the service

331
00:22:10,232 --> 00:22:13,110
mesh telemetry has proxy metrics, proxy traces.

332
00:22:14,410 --> 00:22:18,086
One of the things that you have to understand with telemetry is that you

333
00:22:18,108 --> 00:22:21,846
must have both application and service mesh. Just because you have

334
00:22:21,868 --> 00:22:25,260
a service mesh doesn't mean that you get telemetry out of the box.

335
00:22:25,790 --> 00:22:29,594
Not all the information in the service mesh metrics and traces will

336
00:22:29,712 --> 00:22:33,786
help unless you have the application side set up to do that.

337
00:22:33,968 --> 00:22:37,742
So one thing to consider is you need instrumentation for your application.

338
00:22:37,876 --> 00:22:41,886
You cannot omit this. Your application

339
00:22:41,988 --> 00:22:45,806
needs instrumentation specifically for tracing because

340
00:22:45,988 --> 00:22:49,670
it needs to propagate the traces. So if you do not have metrics

341
00:22:49,690 --> 00:22:53,826
or tracing in your application, adding the service mesh doesn't necessarily give

342
00:22:53,848 --> 00:22:56,740
you that out of the box. So you still need that.

343
00:22:57,590 --> 00:23:01,410
If you're looking at something like net, I'm using open telemetry,

344
00:23:01,830 --> 00:23:05,362
I just add open telemetry metrics as well as add open telemetry

345
00:23:05,426 --> 00:23:08,998
tracing. And easy enough, it creates the metrics as

346
00:23:09,004 --> 00:23:12,054
well as traces that I need. In this case I'm using

347
00:23:12,092 --> 00:23:15,770
Prometheus as well as I'm exporting zipkin spans.

348
00:23:17,070 --> 00:23:20,486
In the case of open telemetry for Java, open telemetry for Java

349
00:23:20,518 --> 00:23:24,122
has an agent, so you don't actually need to add anything to

350
00:23:24,176 --> 00:23:27,566
your application code. Instead you load this library and

351
00:23:27,588 --> 00:23:31,034
then you add some configurations. Again, I'm using Zipkin Prometheus.

352
00:23:31,162 --> 00:23:34,842
You have to keep them consistent. If they're not consistent, then traces

353
00:23:34,906 --> 00:23:37,710
in particular will not go through correctly.

354
00:23:38,450 --> 00:23:42,066
So the service mesh configuration for tracing is a little bit

355
00:23:42,088 --> 00:23:45,218
different. You first have to configure your

356
00:23:45,224 --> 00:23:48,414
service mesh to expose the proxy traces. So the proxies

357
00:23:48,462 --> 00:23:51,438
themselves carry trace information. You want to expose those.

358
00:23:51,544 --> 00:23:54,966
So the way you do that is that if you're in envoy or if

359
00:23:54,988 --> 00:23:58,242
you're in a service mesh, a service mesh will push

360
00:23:58,306 --> 00:24:01,570
this tracer config into envoy.

361
00:24:01,730 --> 00:24:04,874
And if you check the proxies, the proxies will

362
00:24:04,912 --> 00:24:08,426
have the envoy trace config for, let's say

363
00:24:08,448 --> 00:24:12,134
Zipkin, and then you can assign the collector cluster.

364
00:24:12,182 --> 00:24:14,730
In this case I'm using Jaeger as well as the endpoint.

365
00:24:15,630 --> 00:24:18,894
One thing that I found that was very difficult for this

366
00:24:18,932 --> 00:24:23,002
situation is that you have to make sure that whatever instrumentation

367
00:24:23,066 --> 00:24:26,206
library you're using and the export format for

368
00:24:26,228 --> 00:24:29,746
traces must match the tracer that

369
00:24:29,768 --> 00:24:33,054
you're using in envoy or your service mesh.

370
00:24:33,182 --> 00:24:36,894
So for a very long time, the envoy version, older envoy

371
00:24:36,942 --> 00:24:40,398
versions pretty much supported Zipkin formats and that was

372
00:24:40,424 --> 00:24:45,062
pretty much all it would use. Now it has much more

373
00:24:45,116 --> 00:24:48,630
tracer options for you, so just make sure it's consistent.

374
00:24:48,970 --> 00:24:52,134
In this case, I just standardized on Zipkin because

375
00:24:52,332 --> 00:24:55,946
previous libraries did not support let's say like

376
00:24:56,048 --> 00:24:59,818
open tracing or other libraries, it was just using Zipkin. So as the

377
00:24:59,824 --> 00:25:03,526
lowest common denominator for all my applications, I just chose Zipkin

378
00:25:03,558 --> 00:25:07,530
spans. And in this case I would use the Zipkin format

379
00:25:07,610 --> 00:25:10,270
for specifically envoy.

380
00:25:12,290 --> 00:25:16,206
In the case of metrics, you need to expose service mesh and

381
00:25:16,228 --> 00:25:19,570
proxy metrics. Those actually do come out of the box

382
00:25:19,720 --> 00:25:22,866
as long as you enable them. In the case of consul, for example, I'm just

383
00:25:22,888 --> 00:25:28,820
doing envoy Prometheus bind address on 2000 and 20,200

384
00:25:29,590 --> 00:25:33,010
and that pretty much enables the proxy metrics

385
00:25:33,090 --> 00:25:36,902
in Prometheus format. Now the trick however, is that

386
00:25:36,956 --> 00:25:40,818
if you really want to get the benefit of metrics, you have to merge

387
00:25:40,914 --> 00:25:44,298
the metrics that you instrumented in your application with the

388
00:25:44,304 --> 00:25:47,610
proxy metrics endpoint. So most

389
00:25:47,680 --> 00:25:51,814
service meshes allow you to merge the application metrics

390
00:25:51,862 --> 00:25:55,258
with the proxy metrics. And this is something you will need to add or I

391
00:25:55,264 --> 00:25:58,906
highly recommend you add. In the case of console,

392
00:25:58,938 --> 00:26:02,702
you can add an annotation that says enable metrics merging equals true,

393
00:26:02,836 --> 00:26:06,126
and then you tell it which service metrics port. The metrics are

394
00:26:06,148 --> 00:26:09,300
available on. The metrics port is on the application.

395
00:26:09,910 --> 00:26:12,340
So in this case I have 94 64.

396
00:26:12,790 --> 00:26:16,642
It was really convenient. The result is that when you

397
00:26:16,776 --> 00:26:20,546
get the metrics endpoint from the proxy, not from

398
00:26:20,568 --> 00:26:24,562
the application, from the proxy, you'll notice that it merges the envoy

399
00:26:24,626 --> 00:26:27,878
metrics as well as the, let's say, runtime JVN metrics. This is

400
00:26:27,884 --> 00:26:31,334
in the case of Java, but the idea is that you

401
00:26:31,372 --> 00:26:35,260
want to expose the application metrics for Prometheus to use,

402
00:26:35,790 --> 00:26:39,542
merge the metrics into the envoy proxy endpoint,

403
00:26:39,606 --> 00:26:42,602
and that way Prometheus can scrape it in one place.

404
00:26:42,656 --> 00:26:45,594
So they're not just you protect your application that way, right?

405
00:26:45,632 --> 00:26:48,526
So in the case of mesh, what you're trying to do is just keep your

406
00:26:48,548 --> 00:26:52,126
application, avoid it from being publicly available.

407
00:26:52,228 --> 00:26:55,722
So what you're doing is you're scraping the envoy endpoint,

408
00:26:55,786 --> 00:26:59,054
envoy proxy endpoint, which merges the metrics. So that's where

409
00:26:59,172 --> 00:27:02,962
trick. For those who are trying to do this and you've invested into

410
00:27:03,016 --> 00:27:06,306
instrumenting your application, you want to make sure this is done. This is where

411
00:27:06,328 --> 00:27:07,060
it is.

412
00:27:09,510 --> 00:27:12,770
If you do all of this, right? In the case of service

413
00:27:12,840 --> 00:27:16,342
mesh, if you do all of this, what you end up seeing is

414
00:27:16,476 --> 00:27:20,674
a very different kind of trace, and it's not vastly

415
00:27:20,722 --> 00:27:24,426
different, but you do get a little bit more information. So here I've been

416
00:27:24,448 --> 00:27:28,086
trying to issue traces across different commands.

417
00:27:28,118 --> 00:27:31,846
So previously, before you'll notice that I did some traces, I'm using Kong

418
00:27:31,878 --> 00:27:35,494
as an API gateway. Kong itself is also in the service mesh,

419
00:27:35,542 --> 00:27:38,862
actually. So you'll notice there's like proxy information here

420
00:27:38,916 --> 00:27:42,266
about where it is, its peer, et cetera.

421
00:27:42,458 --> 00:27:46,394
And then you'll notice there's actually a component proxy. This is the envoy trace

422
00:27:46,442 --> 00:27:50,046
here. So envoy trace includes the internal span

423
00:27:50,078 --> 00:27:53,586
format, lets me know exactly where it's going. It's a

424
00:27:53,608 --> 00:27:57,118
report, it's report v three. So this is where I know it's

425
00:27:57,134 --> 00:28:01,366
going to the version three. You'll notice that these are my application

426
00:28:01,468 --> 00:28:05,106
traces. So this is from open telemetry. I added open telemetry

427
00:28:05,138 --> 00:28:08,486
in here and it's tracking the calls to

428
00:28:08,508 --> 00:28:12,038
the controller as well. So you'll notice hotel libraries name

429
00:28:12,124 --> 00:28:16,294
as well as the get subsequent nested child spans

430
00:28:16,342 --> 00:28:20,662
here as well. This is calling expense, so you'll notice that it's furthermore

431
00:28:20,726 --> 00:28:24,726
calling expense. And then you'll notice that there's the demo expenses.

432
00:28:24,758 --> 00:28:28,062
So this is calling the database. So the full trace here

433
00:28:28,116 --> 00:28:31,550
is available. But the only reason why it works is that I have turned on

434
00:28:31,620 --> 00:28:35,322
tracing implementations in every part of the expected

435
00:28:35,386 --> 00:28:39,314
trace. So from proxies to the

436
00:28:39,352 --> 00:28:42,946
gateways to internal instrumentation within the

437
00:28:42,968 --> 00:28:46,642
applications, I need to make sure to propagate all of them. All right,

438
00:28:46,696 --> 00:28:50,554
so we talked about these five different concepts, service discovery, balance,

439
00:28:50,622 --> 00:28:53,926
cloud balancing, security, traffic management, and telemetry. All of

440
00:28:53,948 --> 00:28:57,238
these are very, very central to how services

441
00:28:57,324 --> 00:29:00,870
communicate to each other. You can do this within an application,

442
00:29:01,020 --> 00:29:04,882
but you can also abstract some of these functionalities

443
00:29:04,946 --> 00:29:08,234
away into a service mesh. This isn't a statement on whether or not you should

444
00:29:08,272 --> 00:29:11,946
use service mesh or you shouldn't. The point is that most applications will end up

445
00:29:11,968 --> 00:29:15,226
using a little bit of either an internal configure as well

446
00:29:15,248 --> 00:29:18,334
as a service mesh. The idea is that if you have a lot of different

447
00:29:18,372 --> 00:29:22,186
services you plan on growing that you don't want to configure

448
00:29:22,378 --> 00:29:26,126
all of these different code bases. Then maybe consider doing

449
00:29:26,148 --> 00:29:29,818
a service mesh and abstraction. But if you're a developer and you're being asked to

450
00:29:29,844 --> 00:29:33,022
implement it, hopefully this provides a reasonable

451
00:29:33,086 --> 00:29:36,114
mapping of how you would do this in can application,

452
00:29:36,232 --> 00:29:39,410
but then how it impacts and changes as part of a service mesh.

453
00:29:40,070 --> 00:29:43,446
Now, if you want a very thorough example like the live one

454
00:29:43,468 --> 00:29:47,206
I showed today, you can feel free to go to this URL. It has all

455
00:29:47,228 --> 00:29:52,038
of the in depth configuration as well as the entire

456
00:29:52,124 --> 00:29:56,086
environment that you would need to set up. Hopefully it provides a

457
00:29:56,108 --> 00:30:00,566
deeper reference. If you have any questions about

458
00:30:00,748 --> 00:30:04,326
what the appropriate configurations are, you're more than welcome to reach out to

459
00:30:04,348 --> 00:30:07,660
me. I appreciate you tuning in to comp 42.

