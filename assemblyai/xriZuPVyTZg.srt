1
00:00:27,970 --> 00:00:31,622
Security should be one of the first things that comes into mind

2
00:00:31,676 --> 00:00:34,738
when you create Java software, Java applications.

3
00:00:34,834 --> 00:00:38,630
I would say security first, but I will get into that later.

4
00:00:38,700 --> 00:00:42,614
I'm going to break into Java application, but first we need to talk about this

5
00:00:42,652 --> 00:00:46,722
word, devsecops. We all probably know Devsecops,

6
00:00:46,786 --> 00:00:50,586
right? A lot of people try to practice DevOps. And if you are not aware,

7
00:00:50,618 --> 00:00:54,170
if you do that, think about the following thing. Are you creating software?

8
00:00:54,250 --> 00:00:57,966
Are you responsible for putting that into production? And when

9
00:00:57,988 --> 00:01:01,566
things go wrong they will call you to fix it. If that is what you

10
00:01:01,588 --> 00:01:05,110
do in some way you are doing DevOps, you are taking responsibility

11
00:01:05,210 --> 00:01:09,038
for the software that you create. There are a lot of practices around DevOps,

12
00:01:09,134 --> 00:01:12,734
but the major thing is that we focus on developers

13
00:01:12,782 --> 00:01:16,822
and operations. We tear down walls between them and make sure that they

14
00:01:16,876 --> 00:01:21,030
work together and we own our stuff as a team, both during

15
00:01:21,100 --> 00:01:25,030
creation and in production. There's one thing that's not

16
00:01:25,100 --> 00:01:28,390
particularly there in many cases, and that is security.

17
00:01:28,540 --> 00:01:31,946
That's why I say security first and it's right there in the

18
00:01:31,968 --> 00:01:35,306
middle. However, when I saw this word the first time I thought it was a

19
00:01:35,328 --> 00:01:38,746
buzzword and I'm like, yep, what's next? Dev, cloud sec?

20
00:01:38,848 --> 00:01:42,202
Biz, devsecops? The point is, in my opinion,

21
00:01:42,266 --> 00:01:45,482
security should be part of the development lifecycle,

22
00:01:45,626 --> 00:01:49,406
just like scalability and maintainability. And it

23
00:01:49,428 --> 00:01:53,754
should be part of the upcycle because, well, maintainability and scalability

24
00:01:53,802 --> 00:01:57,298
is also something, for instance, we do on the upside. So security

25
00:01:57,384 --> 00:02:01,266
should be an integral part of the whole dev DevOps thing. But it

26
00:02:01,288 --> 00:02:04,862
is not. That's why the word devsecops is

27
00:02:05,016 --> 00:02:08,326
emphasizing on that security part, because we

28
00:02:08,428 --> 00:02:12,102
need to think security first and have it as a

29
00:02:12,156 --> 00:02:15,462
primary mindset next to things like

30
00:02:15,596 --> 00:02:19,526
scalability, maintainability, readability and

31
00:02:19,548 --> 00:02:22,666
all these abilities that we are creating for our code.

32
00:02:22,768 --> 00:02:26,426
So let's focus on that security part and what we

33
00:02:26,448 --> 00:02:29,494
can do as developers. But first, my name is Brian Vermeer,

34
00:02:29,542 --> 00:02:33,126
I am a developer advocate for sneak. I am a Java developer

35
00:02:33,158 --> 00:02:37,034
by heart and I do talks. I recently became a Java champion,

36
00:02:37,082 --> 00:02:40,126
so I'm very grateful for that, that the community chose me to be one of

37
00:02:40,148 --> 00:02:43,678
the few Java champions in the world. I do some stuff for the community

38
00:02:43,764 --> 00:02:47,294
like the virtual jug and the national Netherlands jug,

39
00:02:47,342 --> 00:02:51,106
the NL jug and a bunch of other stuff. I really enjoyed it,

40
00:02:51,208 --> 00:02:54,610
giving talks and sharing knowledge and most of the time

41
00:02:54,680 --> 00:02:58,322
sharing things about being a secure Java developer.

42
00:02:58,386 --> 00:03:02,440
But with that devsecops thing, we're trying to solve a problem and I already

43
00:03:02,970 --> 00:03:07,106
shine a little light on it to see what that problem is. But let's

44
00:03:07,138 --> 00:03:10,918
split that out because, for instance, ten years ago, so it's

45
00:03:10,934 --> 00:03:14,870
almost a decade ago, I worked for a bank,

46
00:03:14,950 --> 00:03:18,442
and before that I worked for a government agency. And what happened

47
00:03:18,496 --> 00:03:22,042
there is that we created software, but the time from

48
00:03:22,096 --> 00:03:25,518
creation to going to production was. There was a long time between that,

49
00:03:25,604 --> 00:03:29,102
actually, we went to production three times a year, and that is not

50
00:03:29,156 --> 00:03:32,606
what you want today. I mean, we try to speed up things. If you look

51
00:03:32,628 --> 00:03:36,414
at ecommerce or basically all applications that run productions,

52
00:03:36,462 --> 00:03:39,922
it can be sped up to things like three times a day instead

53
00:03:39,976 --> 00:03:43,870
of three times a year. Point is that we focus on new features,

54
00:03:43,950 --> 00:03:46,910
right? That product manager is looking that,

55
00:03:47,000 --> 00:03:50,326
let's get that feature out as soon as possible to

56
00:03:50,348 --> 00:03:53,714
be before our competitors, to win that battle,

57
00:03:53,762 --> 00:03:58,534
and that's a fair game. However, in many cases, we cut corners and

58
00:03:58,732 --> 00:04:02,410
security is at that point a little of the things that we're like,

59
00:04:02,480 --> 00:04:06,698
yeah, fair enough. So there is a lack of security

60
00:04:06,784 --> 00:04:11,046
focus throughout the whole application lifecycle. And that's because although

61
00:04:11,078 --> 00:04:13,962
we try to tear down walls between developers and operations,

62
00:04:14,106 --> 00:04:17,646
security is in very much almost all companies. It's still a

63
00:04:17,668 --> 00:04:20,938
siloed thing. It is not something that is adopted by the development

64
00:04:20,954 --> 00:04:24,906
teams or by the DevOps teams. It is a team that works separately,

65
00:04:25,018 --> 00:04:28,814
checks your stuff and say you work in a three week sprint

66
00:04:28,862 --> 00:04:32,626
or cycle, and after three weeks you created that feature and you're ready to

67
00:04:32,648 --> 00:04:35,966
go to production. And then somebody comes up to you and said, yeah, we tested

68
00:04:35,998 --> 00:04:39,534
it, but no, that's friction. I don't like that. I worked my

69
00:04:39,592 --> 00:04:42,806
butt off to make sure that this feature works, and then somebody comes up to

70
00:04:42,828 --> 00:04:46,054
me and says, I cannot put it into production because

71
00:04:46,172 --> 00:04:49,990
others might be a possible security issue. Wouldn't it be nice to

72
00:04:50,060 --> 00:04:53,770
have these things and that information already available

73
00:04:53,840 --> 00:04:57,098
to you? Just like you want to have quick feedback on your unit test,

74
00:04:57,184 --> 00:05:00,358
because in the end, we need to think of the same things altogether.

75
00:05:00,454 --> 00:05:03,578
In the end, we do not want that customer data that is in our application

76
00:05:03,664 --> 00:05:06,510
is compromised and we are the next headline in the news.

77
00:05:06,580 --> 00:05:10,606
We want to prevent that. So how bad is that situation? Well, who of

78
00:05:10,628 --> 00:05:14,146
you have heard of a company called Equifax? And I

79
00:05:14,168 --> 00:05:17,986
know it's an example from 2017 already,

80
00:05:18,088 --> 00:05:22,146
but Equifax, and you see some headlines over here. Equifax is

81
00:05:22,168 --> 00:05:25,970
a commonly base in Atlanta doing crediting scores, but the company's not important.

82
00:05:26,040 --> 00:05:29,970
They built their business logic on top of Apache struts.

83
00:05:30,050 --> 00:05:33,858
Apache struts two. In that case, that particular version of Apache struts

84
00:05:33,874 --> 00:05:37,638
was vulnerable. And their business logic, I assume it was okay.

85
00:05:37,724 --> 00:05:41,030
But because the plumbing, the foundation, there was a vulnerabilities

86
00:05:41,110 --> 00:05:45,306
in that people could get in. Because a vulnerabilities was

87
00:05:45,328 --> 00:05:48,682
found, people could get in and nobody in the company

88
00:05:48,816 --> 00:05:51,914
noticed. Basically they were not aware that this was happening.

89
00:05:52,032 --> 00:05:55,166
So people could snoop around in that system for months. I don't

90
00:05:55,188 --> 00:05:58,014
know how long they were in there, but they were in their head, they took

91
00:05:58,052 --> 00:06:01,902
their time. In the end, over 140,000,000 us

92
00:06:01,956 --> 00:06:05,226
customers were compromised because the data they found they brought

93
00:06:05,258 --> 00:06:08,930
out into the open. And that's not what we want. But let's look into that

94
00:06:09,000 --> 00:06:13,234
hack right away. If we go to, let's go to this

95
00:06:13,272 --> 00:06:16,818
one. And you see this is a Java application and it runs on Heroku,

96
00:06:16,834 --> 00:06:18,440
it runs actually on the cloud.

97
00:06:20,170 --> 00:06:23,880
I can sign up, that's okay, let me sign up,

98
00:06:26,490 --> 00:06:29,990
that was Alexa. However, let's go into this application.

99
00:06:30,060 --> 00:06:32,890
I don't actually need to sign up because it's in the plumbing. So let's go

100
00:06:32,960 --> 00:06:36,298
to this thing. For instance, I can do

101
00:06:36,384 --> 00:06:39,706
a curl request to this application outside of

102
00:06:39,728 --> 00:06:43,018
the actual Business logic and do some weird, weird things. Let me enlarge

103
00:06:43,034 --> 00:06:44,160
this for you a bit.

104
00:06:46,610 --> 00:06:49,120
So I have a header over here,

105
00:06:54,210 --> 00:06:57,378
and this header is what I'm going to use. As you

106
00:06:57,384 --> 00:07:00,466
can see, this header contains a

107
00:07:00,648 --> 00:07:04,402
content type and that content type. This is the value of that content

108
00:07:04,456 --> 00:07:08,306
type. If you look closely, you probably figure out

109
00:07:08,328 --> 00:07:11,334
what's happening. And if you know what kind of content type this is,

110
00:07:11,452 --> 00:07:14,582
well, we can at least say it's a faulty content type. It's a content type

111
00:07:14,636 --> 00:07:18,326
that is not really there. It is not something that

112
00:07:18,348 --> 00:07:21,530
is valid. And the point is, when you use a content

113
00:07:21,600 --> 00:07:24,966
type like this, with that Apache struts version

114
00:07:24,998 --> 00:07:28,262
that we are using, it's the same Apache struts version that Equifax

115
00:07:28,326 --> 00:07:32,026
used at the time. We go into an exceptional flow, and in that exceptional flow

116
00:07:32,058 --> 00:07:36,186
it is possible to utilize OGNl, the object graph navigational language,

117
00:07:36,298 --> 00:07:39,626
basically the expression language within Apache struts.

118
00:07:39,658 --> 00:07:43,166
And with that expression language I am able to interfere with the

119
00:07:43,188 --> 00:07:46,978
objects. I can call getters, setters, that kind of stuff, but I also can create

120
00:07:47,144 --> 00:07:50,510
new objects. And what I'm doing here is I am creating

121
00:07:50,590 --> 00:07:54,002
a new process builder, right? And that process

122
00:07:54,056 --> 00:07:57,438
builder, I feed it the bash,

123
00:07:57,614 --> 00:08:00,754
and that bash on its turn is fed an arbitrary

124
00:08:00,802 --> 00:08:03,686
command. So basically what I'm trying to do, I'm trying to spin up a new

125
00:08:03,708 --> 00:08:07,014
process and feed it a Linux command. It depends on what

126
00:08:07,052 --> 00:08:10,566
privileges this application is running, for instance in a docker container

127
00:08:10,598 --> 00:08:13,674
or whatever, it doesn't matter. But the point is I can feed it basically any

128
00:08:13,712 --> 00:08:16,966
arbitrary command. Let me show you, I have some applications

129
00:08:16,998 --> 00:08:22,174
over here and let

130
00:08:22,212 --> 00:08:25,470
me go to into the exploits. I prepared something,

131
00:08:25,620 --> 00:08:29,642
so let's go and look at the n variables.

132
00:08:29,706 --> 00:08:33,022
So what I'm going to do here is I am going to

133
00:08:33,076 --> 00:08:36,610
call the command nf. I substitute, I use this header I showed you,

134
00:08:36,680 --> 00:08:40,638
I substitute command for the command nf, which basically is a Linux command

135
00:08:40,654 --> 00:08:44,638
that shows me all the environment variables. I am doing a curl minus

136
00:08:44,734 --> 00:08:48,098
v on this thing, but this is

137
00:08:48,104 --> 00:08:51,954
a localhost and our application runs on Heroku,

138
00:08:52,002 --> 00:08:56,934
right? So let's just do

139
00:08:56,972 --> 00:09:00,682
it. This is the application, let's just go over here,

140
00:09:00,816 --> 00:09:04,678
let's use this one. So instead of the localhost

141
00:09:04,774 --> 00:09:09,046
I am inserting

142
00:09:09,238 --> 00:09:12,438
my cloud application and let's

143
00:09:12,454 --> 00:09:16,046
see what happens. And what happens is you see a lot of stuff over

144
00:09:16,068 --> 00:09:19,598
here, but you see that I'm HTTP 200 and in

145
00:09:19,604 --> 00:09:23,294
my result I now have part of the environment

146
00:09:23,342 --> 00:09:27,218
variables on this local machine. So that means that this function,

147
00:09:27,304 --> 00:09:30,674
this command actually executed. And now I see what

148
00:09:30,712 --> 00:09:34,350
the environment variables are. On this particular heroku

149
00:09:34,430 --> 00:09:37,874
instance I can see the Java ops, I can see

150
00:09:37,912 --> 00:09:41,254
where Java home is. Let's keep this one in mind because I need that later

151
00:09:41,292 --> 00:09:44,982
for another hack. Point is if I can call the NF command I probably

152
00:09:45,036 --> 00:09:48,438
am able to call other common as well. I might be able to create a

153
00:09:48,444 --> 00:09:51,658
script to download software, call that script. I basically have a

154
00:09:51,664 --> 00:09:55,306
lot of power now and I can do whatever I want depending on

155
00:09:55,328 --> 00:09:58,874
the privileges. I can execute arbitrary code and that

156
00:09:58,912 --> 00:10:02,090
is not something that we want. And just because I'm using

157
00:10:02,160 --> 00:10:05,342
a outdated version of Apache struts and I didn't update it

158
00:10:05,396 --> 00:10:08,890
when there was a newer version out, that is basically what happened to the folks

159
00:10:08,970 --> 00:10:12,734
from equifax. So continuing on this, let me get

160
00:10:12,772 --> 00:10:15,934
my application back like that. Thank you. Let's go into

161
00:10:15,972 --> 00:10:20,046
your application, say this is your application, this is your Java jar or Java

162
00:10:20,078 --> 00:10:23,378
war or whatever it might be that you want to put into production. How much

163
00:10:23,464 --> 00:10:26,706
of the code that you put into production is actually the

164
00:10:26,728 --> 00:10:31,122
code you have written? Because you probably use the spring initializer or any other initializer

165
00:10:31,186 --> 00:10:34,678
that generates a part of stuff. Plus you might have a pum or a

166
00:10:34,684 --> 00:10:38,338
gradle file that imports a lot of stuff from framework libraries.

167
00:10:38,434 --> 00:10:41,818
You get me right? And the answer is this is probably your code.

168
00:10:41,904 --> 00:10:45,034
This is probably the code you wrote and Danny's there at hole. That whole big

169
00:10:45,072 --> 00:10:48,346
yellow ball is dependencies, and dependencies bring in,

170
00:10:48,368 --> 00:10:51,994
dependencies bring other dependencies in. There's a lot of code that you pull

171
00:10:52,032 --> 00:10:55,534
in from the Internet and use for good reason. Because we do not want

172
00:10:55,572 --> 00:10:59,354
to create yet another corrupt repository or yet another rest endpoint.

173
00:10:59,402 --> 00:11:02,302
We want to focus on the business logics. That makes a difference.

174
00:11:02,436 --> 00:11:06,254
However, we take a lot of pride in that small red

175
00:11:06,372 --> 00:11:09,486
or purple bowl in the middle. We do code reviews,

176
00:11:09,678 --> 00:11:13,470
maybe we have a QA system in place. We try to make our code neath,

177
00:11:13,550 --> 00:11:16,818
speedy, maintainable, and we do code reviews and that kind of

178
00:11:16,824 --> 00:11:20,430
stuff, pair programming. But how do you maintain your dependencies?

179
00:11:20,510 --> 00:11:23,254
In a lot of companies, once a dependency is in, it never gets out.

180
00:11:23,292 --> 00:11:26,822
And do you update them? Are you aware what's actually working there? What's happening there?

181
00:11:26,876 --> 00:11:30,486
Let me give you some numbers. Examples. Say this is a node application, because it's

182
00:11:30,518 --> 00:11:34,102
easy to make fun of JavaScript, I'm sorry. Say this is a 19

183
00:11:34,166 --> 00:11:37,818
line serverless code application, JavaScript application,

184
00:11:37,904 --> 00:11:42,014
and I'm using two dependencies, AWS SDK and node fetch. So two

185
00:11:42,052 --> 00:11:45,658
direct dependencies. But dependencies have dependencies having dependencies.

186
00:11:45,754 --> 00:11:49,146
In the end, we will have 19 dependencies.

187
00:11:49,258 --> 00:11:52,334
Not so much in my opinion. That's okay, but how many

188
00:11:52,372 --> 00:11:55,806
lines of code do I put into production? Drumroll. It's just a

189
00:11:55,828 --> 00:11:59,186
little bit shy of 200,000 lines of code. And then every node developer comes up

190
00:11:59,208 --> 00:12:02,642
and say, but not every part of that code is available or is

191
00:12:02,696 --> 00:12:05,794
actually, you can execute it. True, but do you know what

192
00:12:05,832 --> 00:12:08,946
can be executed or not? But let's move into a Java example. I have a

193
00:12:08,968 --> 00:12:12,486
spring serverless example over here, and this is just a code snippet because

194
00:12:12,508 --> 00:12:15,842
the code was 222 lines of code, and that was an accident

195
00:12:15,906 --> 00:12:19,782
that it was two, two, two. However, it had five direct dependencies.

196
00:12:19,846 --> 00:12:23,702
And these dependencies, like from the spring cloud framework

197
00:12:23,766 --> 00:12:27,322
and AWS, again, it came back to 54

198
00:12:27,376 --> 00:12:31,050
dependencies in total. Now the question is, how many lines of code

199
00:12:31,120 --> 00:12:34,506
do I actually put into production from this neat two on

200
00:12:34,528 --> 00:12:38,590
the 22 lines of code, spring application, guess what, over 400,000

201
00:12:38,660 --> 00:12:42,046
lines of code. Almost 500,000. And I'm responsible not for

202
00:12:42,068 --> 00:12:45,790
the 222 lines, no, I'm responsible for the whole shebang.

203
00:12:45,870 --> 00:12:49,246
So all the 400 something lines. And remember, how does Java

204
00:12:49,278 --> 00:12:52,786
work? Every jar that is included in my application

205
00:12:52,888 --> 00:12:56,226
or that is there, is available. Well, most of the time is available on your

206
00:12:56,248 --> 00:13:00,038
class path. So it can be loaded into memory and can be used,

207
00:13:00,124 --> 00:13:03,446
for instance, with a arbitrary code insertion like I

208
00:13:03,468 --> 00:13:06,774
just showed you. So we need to take care of both these parts, not only

209
00:13:06,812 --> 00:13:10,294
our code, but also of somebody else that we pull in.

210
00:13:10,412 --> 00:13:14,074
And we know that open source usage has exploded in the last couple

211
00:13:14,112 --> 00:13:17,926
of years, well, the last decade, basically. The problem is, I won't say open source

212
00:13:17,958 --> 00:13:21,658
is not secure, but open source isn't secure nor insecure, if you know what I

213
00:13:21,664 --> 00:13:25,374
mean. I mean that open source is created by developers just like you

214
00:13:25,412 --> 00:13:29,342
and me, and you might be an open source contributor. And as we know

215
00:13:29,396 --> 00:13:32,814
from our professional lives, maybe we make mistakes and mistakes will be found

216
00:13:32,852 --> 00:13:35,854
over time. So we need to be aware of this as well when we use

217
00:13:35,892 --> 00:13:39,202
open source available software. Get me? So think about the next

218
00:13:39,256 --> 00:13:42,450
method. If you use a package that is well known, well used,

219
00:13:42,520 --> 00:13:46,046
and well used by a lot of companies, that means if there is a tiny

220
00:13:46,078 --> 00:13:49,302
flaw in it, or a big flaw in it that attacker can use,

221
00:13:49,356 --> 00:13:52,534
he has a potential reach of targets that

222
00:13:52,572 --> 00:13:56,086
can go into millions. For instance, if there is a problem with

223
00:13:56,188 --> 00:13:59,122
spring boot or take any big package,

224
00:13:59,186 --> 00:14:01,722
and there is an issue with that, a lot of people are using that.

225
00:14:01,776 --> 00:14:05,302
So one vulnerability can get into many victims.

226
00:14:05,366 --> 00:14:08,486
And most of the times these vulnerabilities are already fixed, you just have to update

227
00:14:08,518 --> 00:14:12,506
the version, a few numbers just for the sake of it. Total packages indexed per

228
00:14:12,528 --> 00:14:15,694
ecosystem. And this is already a little bit of old an graph, but this gets

229
00:14:15,732 --> 00:14:19,146
the point. Between 2018 and 2019, NPM grew

230
00:14:19,178 --> 00:14:22,606
tremendously. So that's JavaScript. During 2019, they were over

231
00:14:22,628 --> 00:14:26,394
a million packages. However, if you look at Java, which is the blue purplish

232
00:14:26,442 --> 00:14:29,854
line, Maven Central, in this case, the increase of the amount of packages

233
00:14:29,902 --> 00:14:33,490
is over 100,000. So there are a lot of packages coming there every

234
00:14:33,560 --> 00:14:36,946
year, and that's because of new updates, et cetera. But if you look at new

235
00:14:36,968 --> 00:14:40,114
vulnerabilities that are found each years, this is also rising

236
00:14:40,162 --> 00:14:43,846
because we find vulnerabilities over time and packages are

237
00:14:43,868 --> 00:14:46,966
using packages are using packages. It can be that it's not just the

238
00:14:46,988 --> 00:14:50,706
package that you import, but something underneath. That's what we actually found

239
00:14:50,748 --> 00:14:54,074
out. Over here, right in the middle is maven central, and you see

240
00:14:54,112 --> 00:14:57,462
that most of the vulnerabilities that are found are indirect.

241
00:14:57,526 --> 00:15:00,646
So in the layers below the package that you include,

242
00:15:00,678 --> 00:15:04,350
and that's fair. So think about that. Pulling in a package, what do you actually

243
00:15:04,420 --> 00:15:07,418
take with it? We ask OS maintainers, open source maintainers,

244
00:15:07,434 --> 00:15:11,390
how confident they are about their own security knowledge. And 63%

245
00:15:11,460 --> 00:15:14,814
says I'm kind of confident, and that is just as confident as

246
00:15:14,852 --> 00:15:17,806
you and me. But we have base programming and we take a lot of pride

247
00:15:17,838 --> 00:15:21,682
in our own code. However, we pull something in from somebody else that we trust

248
00:15:21,736 --> 00:15:25,326
blindly. But who is responsible for security? A lot of people say it's a shared

249
00:15:25,358 --> 00:15:28,934
responsibility between the security teams and operations. But most

250
00:15:28,972 --> 00:15:32,438
of the people think and believe that the developer has a fair share.

251
00:15:32,524 --> 00:15:35,846
Developers need to take responsibility for that. And I think

252
00:15:35,868 --> 00:15:39,238
it's logical, because we build this stuff, we know how we built the

253
00:15:39,244 --> 00:15:42,922
stuff up, we know what kind of technologies we used. And people

254
00:15:42,976 --> 00:15:46,714
trust our software, our clients trust our software, just like I

255
00:15:46,752 --> 00:15:50,314
trust the person that built this house I'm currently standing in.

256
00:15:50,352 --> 00:15:54,058
If he is not aware of regulations and the security

257
00:15:54,144 --> 00:15:57,386
that this building will not collapse, I wouldn't be standing

258
00:15:57,418 --> 00:16:00,734
here. Very comfortable. Same holds for software. Well, we can go on

259
00:16:00,772 --> 00:16:05,374
and on. Like how do you find out about vulnerabilities? But 27%

260
00:16:05,412 --> 00:16:08,770
said I probably won't. This interesting one, who of you works with

261
00:16:08,840 --> 00:16:12,018
legacy software? I think a bunch of you. And it takes some time for a

262
00:16:12,024 --> 00:16:15,794
vulnerabilities to get discovered. The median over here in this case is two

263
00:16:15,832 --> 00:16:19,278
and a half years. So over time things will get found. And if it's

264
00:16:19,294 --> 00:16:22,022
in production for a long time, you didn't dare to touch it because,

265
00:16:22,076 --> 00:16:25,942
well, nobody owns that code anymore. That happened for a bank I worked for

266
00:16:25,996 --> 00:16:29,474
a couple of years ago. And if it's outward facing, you might be vulnerable.

267
00:16:29,522 --> 00:16:32,762
Docker also an interesting part. Who uses Docker? I bet a lot of you.

268
00:16:32,816 --> 00:16:36,614
I did a research in end of 2019 that pulled

269
00:16:36,662 --> 00:16:40,346
the ten most popular docker images from Docker Hub and we scanned them

270
00:16:40,368 --> 00:16:43,994
for vulnerabilities. And there are a lot of vulnerabilities in that, all these

271
00:16:44,112 --> 00:16:48,218
latest versions of these packages, because what you do is from some base image

272
00:16:48,234 --> 00:16:51,802
and you build your stuff upon that. However, with our scanning tool within sneak,

273
00:16:51,866 --> 00:16:55,234
I scanned our stuff and what we found out is that most of these things

274
00:16:55,352 --> 00:16:59,618
are built on top of a very large operating system,

275
00:16:59,704 --> 00:17:03,378
for instance, Debian. And then you have to think, if I want to pull in

276
00:17:03,464 --> 00:17:07,234
the node image, the node latest image, do I actually need

277
00:17:07,272 --> 00:17:11,158
the full Debian distribution? And that comes with a lot of binaries that might have

278
00:17:11,244 --> 00:17:14,486
issues as well. But we're not going into darker today. We asked

279
00:17:14,508 --> 00:17:17,926
people if they find operating system vulnerabilities and half of

280
00:17:17,948 --> 00:17:21,674
the people interview didn't. However, I want to go to the hacking part

281
00:17:21,712 --> 00:17:25,194
because that is interesting. And I want to start with a very small

282
00:17:25,232 --> 00:17:28,826
code application to show you some basic vulnerabilities. And I

283
00:17:28,848 --> 00:17:32,234
chose a node application because, well, we found this vulnerability. However, it is

284
00:17:32,272 --> 00:17:35,566
not so much because it's code, but it is because this application is

285
00:17:35,588 --> 00:17:38,766
vulnerable. This is an application in node JS and it is a

286
00:17:38,788 --> 00:17:42,414
to do application. And what I can do, I can pull in things like buy

287
00:17:42,452 --> 00:17:45,886
flowers and I can make a list of that, nothing really special, what it

288
00:17:45,908 --> 00:17:48,370
can do, as well as at the bottom over here you see a link,

289
00:17:48,440 --> 00:17:51,554
a static link to an about page. And you see that this is the best

290
00:17:51,592 --> 00:17:55,218
about page ever and the best scalable page ever, because hey,

291
00:17:55,304 --> 00:17:58,654
you can scale it. So it works on mobile and the contrast

292
00:17:58,702 --> 00:18:02,086
is good and everything is great. However, it's not the

293
00:18:02,108 --> 00:18:05,238
point. The point is that this is a static HTML page and

294
00:18:05,244 --> 00:18:08,726
it served to you by a library, a node JS library called St.

295
00:18:08,828 --> 00:18:12,182
We use the version that is vulnerable. And let me show you what the vulnerability

296
00:18:12,246 --> 00:18:15,834
is. It is a path traversal vulnerability. So going into

297
00:18:15,952 --> 00:18:19,178
this app, let me use curl and I

298
00:18:19,184 --> 00:18:22,634
think that is the best way to do so. If I curl this and curl

299
00:18:22,682 --> 00:18:23,840
the about page,

300
00:18:26,930 --> 00:18:30,542
I need to be on the right screen. Yes, say I curl the about

301
00:18:30,596 --> 00:18:33,982
page, then I will get the HTML perfectly fine. But the point is there is

302
00:18:34,036 --> 00:18:37,458
a path traversal vulnerability in here. So normally a

303
00:18:37,464 --> 00:18:40,898
path reversal would be something like this. What we try to

304
00:18:40,904 --> 00:18:44,654
do, we try to go back into the path. So out of the public folder

305
00:18:44,702 --> 00:18:48,046
and basically I'm trying to get out of the main folder where

306
00:18:48,088 --> 00:18:52,374
the web server is located and go into the root of the current system,

307
00:18:52,492 --> 00:18:56,306
of the actual machine. However, by doing this I get rerouted

308
00:18:56,338 --> 00:18:59,698
back to my home page. You see here is the link

309
00:18:59,724 --> 00:19:03,274
to the about page, et cetera, because the St libraries is a real

310
00:19:03,312 --> 00:19:07,366
library and it basically denied, specifically denied.

311
00:19:07,558 --> 00:19:10,906
It recognized the dot dot slash and it says okay, you're doing a path of

312
00:19:10,928 --> 00:19:14,414
Russell. No way. However, that's exactly what I'm trying to say.

313
00:19:14,452 --> 00:19:18,366
It try to it specifically deny to dot dot slash. So if we are a

314
00:19:18,388 --> 00:19:21,886
little bit smarter we can go and do something like

315
00:19:21,988 --> 00:19:25,530
maybe escaping or maybe encoding.

316
00:19:25,610 --> 00:19:29,090
So what is the HTML encoding for

317
00:19:29,160 --> 00:19:32,398
a dot? Let me just tell you that is percent to e. And if I'm

318
00:19:32,414 --> 00:19:35,390
using percent to e, which is the encoding for a dot,

319
00:19:35,470 --> 00:19:38,594
I just do dot dot slash over here. And if I do dot dot slash

320
00:19:38,642 --> 00:19:42,086
over here and I just let me just do

321
00:19:42,108 --> 00:19:46,694
it right, let me copy the whole thing like

322
00:19:46,732 --> 00:19:53,226
this. And now

323
00:19:53,248 --> 00:19:56,586
I'm in the root of my current local system because I'm using the

324
00:19:56,608 --> 00:19:59,834
wrong library. But if I can do this, I can also go

325
00:19:59,872 --> 00:20:04,534
into a file like the passwd

326
00:20:04,582 --> 00:20:07,934
file. For those who don't know, if you dot dot slash you will get back

327
00:20:07,972 --> 00:20:11,806
into your path. But if you are in the root and you dot slash in

328
00:20:11,828 --> 00:20:14,174
the root, you will end up in the root. So it doesn't matter how many

329
00:20:14,212 --> 00:20:17,466
dot dot slashes I do at this point. Over here I'm in the root

330
00:20:17,498 --> 00:20:20,654
and I'm going to the etc folder and going to the passwd

331
00:20:20,702 --> 00:20:24,146
file, and as you can see, it can be shown, and this is on my

332
00:20:24,168 --> 00:20:27,778
local machine, but I can also put it in the cloud somewhere and it works

333
00:20:27,864 --> 00:20:31,238
fine. People say yeah, okay, but you can only read now. How important

334
00:20:31,324 --> 00:20:34,486
is that? How important is it when you can only read this

335
00:20:34,508 --> 00:20:37,814
stuff? Well, it is the start of a journey, because now I can read

336
00:20:37,852 --> 00:20:41,738
into files that are there, and if your web application is not really

337
00:20:41,824 --> 00:20:44,954
well configured, I might be able to go into a certain

338
00:20:44,992 --> 00:20:47,638
place that you don't want me to be. I can snoop into the files,

339
00:20:47,734 --> 00:20:51,414
may find tokens or credentials to a database,

340
00:20:51,462 --> 00:20:54,938
et cetera, et cetera, et cetera. For instance, what I can do is if I'm

341
00:20:54,954 --> 00:20:58,042
over here and instead of going to the root,

342
00:20:58,106 --> 00:21:01,662
I can do the percent

343
00:21:01,716 --> 00:21:05,646
to e over here, and I'm just going back one directory in

344
00:21:05,668 --> 00:21:08,820
the path breaking out of the public directory, which shouldn't be available,

345
00:21:09,190 --> 00:21:12,146
but I can't. What I can see over here is that I can go to

346
00:21:12,168 --> 00:21:15,330
the package JSon, which is basically

347
00:21:15,400 --> 00:21:18,974
the NPM way of specifying your dependencies,

348
00:21:19,022 --> 00:21:22,438
just like your palm XML or your build Gretel. And if I do this,

349
00:21:22,524 --> 00:21:26,242
I can see what kind of dependencies you have. Like it uses DMS

350
00:21:26,306 --> 00:21:29,378
library, I know that one is vulnerable, et cetera, et cetera. It uses

351
00:21:29,394 --> 00:21:32,874
the express library that is vulnerable this version. And I can look that up because

352
00:21:32,912 --> 00:21:37,718
that information is available on the Internet, right? Even more path

353
00:21:37,734 --> 00:21:41,894
traversal and looking into files I can look, and this is Javascript,

354
00:21:41,942 --> 00:21:45,310
and that's why I don't like it. I can literally go into the

355
00:21:45,380 --> 00:21:48,954
JS files like the app JS, and somebody forgot

356
00:21:49,002 --> 00:21:52,734
to get their token out. It is interesting if the

357
00:21:52,852 --> 00:21:55,946
stuff is open sourced, fair enough, it would be already on GitHub. But if it's

358
00:21:55,978 --> 00:21:58,686
not, I can see what the actual version is on the server. That might be

359
00:21:58,708 --> 00:22:01,262
interesting, right? And with this token I can go on and on and on.

360
00:22:01,316 --> 00:22:05,266
So it is a start of a journey, right? Okay, let me move to Java

361
00:22:05,298 --> 00:22:09,238
example. And this is interesting because I'm going back to that

362
00:22:09,324 --> 00:22:12,086
previous example of the application I showed you,

363
00:22:12,188 --> 00:22:16,150
and you see this to do application. Let me sign up

364
00:22:16,300 --> 00:22:19,800
this time. So I'm actually going into the application. No,

365
00:22:20,250 --> 00:22:24,234
let me just sign in with my email address like this and

366
00:22:24,272 --> 00:22:27,642
put a password in like 123456. Because hey,

367
00:22:27,696 --> 00:22:30,422
I work for a security company and this is safe,

368
00:22:30,566 --> 00:22:34,166
but it's a demo application and it will be restarted

369
00:22:34,198 --> 00:22:37,854
in 15 minutes after this talk. So I sign up, I'm in this

370
00:22:37,892 --> 00:22:41,534
application, and again, it is a to do list. What I can do over here

371
00:22:41,572 --> 00:22:44,990
is I can create a to do and I can create something fancy

372
00:22:45,070 --> 00:22:48,734
like eat pie with a PI symbol.

373
00:22:48,782 --> 00:22:53,218
I love that. I love this geeky stuff. So put it somewhere in 1970,

374
00:22:53,304 --> 00:22:57,060
and if it's already on the list because of 1970,

375
00:22:57,430 --> 00:23:00,694
I will give it the high priority. Great. And what

376
00:23:00,812 --> 00:23:04,166
you see over here is that I have a table that it

377
00:23:04,188 --> 00:23:07,634
is a to do and okay, cool. But the title

378
00:23:07,682 --> 00:23:11,802
is eat PI. And that PI symbol is transformed into

379
00:23:11,936 --> 00:23:15,866
an aSCII representation, the slash u whatever.

380
00:23:15,968 --> 00:23:19,754
So what it uses over here, it takes the title and

381
00:23:19,792 --> 00:23:24,126
goes into the native to ASCII function that is part of your jdk that

382
00:23:24,148 --> 00:23:27,806
is there. If you download a JDK from what vendor whatsoever, there is

383
00:23:27,828 --> 00:23:31,466
a native to ASCII function available and that transforms that symbol into the ASCII

384
00:23:31,498 --> 00:23:35,074
representation. Keep that thought. Hold that thought. This application can do

385
00:23:35,112 --> 00:23:37,922
something more. We can upload files, which is interesting,

386
00:23:38,056 --> 00:23:41,250
and it can upload zip files. But what if

387
00:23:41,320 --> 00:23:43,540
my zip file looked like this?

388
00:23:43,990 --> 00:23:48,306
So remember the java home I showed you earlier?

389
00:23:48,498 --> 00:23:51,590
Okay, now it will all come together.

390
00:23:51,740 --> 00:23:55,074
So let's

391
00:23:55,122 --> 00:23:58,966
look at the zip file I created over here. So I

392
00:23:59,068 --> 00:24:03,046
would call zip info on zip

393
00:24:03,078 --> 00:24:06,906
slip zip. And you see this zip file contains two

394
00:24:06,928 --> 00:24:11,018
files, a good text, which is a normal text file,

395
00:24:11,194 --> 00:24:14,858
which is there, and it contains a file with the file

396
00:24:14,874 --> 00:24:18,126
name. And we already found out

397
00:24:18,148 --> 00:24:23,162
that is a path traversal. And then that slash app jdk

398
00:24:23,306 --> 00:24:26,978
that I found out from my end variable that I did

399
00:24:27,064 --> 00:24:30,642
with my previous hack. And what I'm doing now is I'm trying to

400
00:24:30,696 --> 00:24:34,686
overwrite the native to ASCII file by extracting

401
00:24:34,718 --> 00:24:38,660
this zip file. So I'm going back into the root, going to the app

402
00:24:38,970 --> 00:24:42,098
jdk, basically the jdk on my heroku

403
00:24:42,114 --> 00:24:45,378
instance into the bin file. There is that native to AsCII file, and I'm

404
00:24:45,394 --> 00:24:48,742
overriding it, I'm trying to override it. So let's see if this works.

405
00:24:48,796 --> 00:24:52,326
And this is can actual zip file. This is a valid zip file. So let's

406
00:24:52,358 --> 00:24:55,642
see if that works. Let's go into that application again,

407
00:24:55,776 --> 00:25:00,170
choose the file and I need to go to my break demo files.

408
00:25:00,590 --> 00:25:03,674
It's over here. My zip slip. Let's say this is the zip file I just

409
00:25:03,712 --> 00:25:06,986
showed you and let me upload it. And what we see in the public folder

410
00:25:07,018 --> 00:25:10,670
where normally all the stuff goes, the good text is there, so we know that

411
00:25:10,740 --> 00:25:14,286
it actually extracted the zip file. Interesting. So what

412
00:25:14,308 --> 00:25:18,014
did it do with the dot dot slash dot dot slash thing? Did it silently

413
00:25:18,062 --> 00:25:21,730
swallow the exception and didn't show me which could be possible? Or did it actually

414
00:25:21,800 --> 00:25:25,074
execute it? Let me show you if I'm going to create

415
00:25:25,112 --> 00:25:29,042
another to do and I say hello

416
00:25:29,096 --> 00:25:32,806
folks and it doesn't matter if I put it, put it on the 2

417
00:25:32,828 --> 00:25:36,486
February 1970 and give it a medium priority. But what

418
00:25:36,508 --> 00:25:40,242
you see now is that the title is now replaced with muhaha Gotcha.

419
00:25:40,306 --> 00:25:43,786
That is because I overwrote the native to ASCII file with a very

420
00:25:43,808 --> 00:25:47,158
simple file that echoes this string. So every title

421
00:25:47,254 --> 00:25:51,190
goes into that native to ASCII file and will be transformed in literally

422
00:25:51,270 --> 00:25:55,418
muhaha gotcha. And that is because I'm using a zip library

423
00:25:55,514 --> 00:25:59,182
to unzip my zip file, because others is no such thing

424
00:25:59,236 --> 00:26:03,098
in the java library, or there is no such unzip file

425
00:26:03,274 --> 00:26:06,462
in quora Java libraries. So we use an external library.

426
00:26:06,526 --> 00:26:09,746
It can either be from any vendors, there are a lot of vendors that

427
00:26:09,768 --> 00:26:12,430
do that. But this version of this library,

428
00:26:12,590 --> 00:26:15,858
and this was found by our research team,

429
00:26:15,944 --> 00:26:19,254
was there in a lot of libraries. Point here is that it looks into

430
00:26:19,292 --> 00:26:22,850
the zip file and it didn't sanitize the input.

431
00:26:22,930 --> 00:26:26,294
So the dot dot slash wasn't stripped away, it was

432
00:26:26,332 --> 00:26:29,590
just look into the zip file, create a file at the same place,

433
00:26:29,660 --> 00:26:33,386
overwrite it and put the same bytes in. So it basically took the path and

434
00:26:33,408 --> 00:26:36,730
the file name and executed it instead of looking hey,

435
00:26:36,800 --> 00:26:40,266
is this location actually inside the application where

436
00:26:40,288 --> 00:26:43,546
I want it to be? So not looking at the specific path, but you should

437
00:26:43,568 --> 00:26:47,194
be looking at the canonical path. Nevertheless it didn't sanitize that input.

438
00:26:47,242 --> 00:26:50,206
So what you see over here, I can overwrite files that are there on my

439
00:26:50,228 --> 00:26:53,998
system and have a different meaning, which is

440
00:26:54,164 --> 00:26:57,682
in first instance is a path throughsal problem, but that means

441
00:26:57,736 --> 00:27:00,914
I can insert arbitrary code. Interesting, right? Let's go

442
00:27:00,952 --> 00:27:04,174
from there. This is happening because I'm

443
00:27:04,222 --> 00:27:07,822
just using a library and it was already updated

444
00:27:07,966 --> 00:27:11,730
to a newer version because the vulnerabilities was found and disclosed.

445
00:27:11,810 --> 00:27:15,046
But I didn't know, I didn't look at it, it was already in

446
00:27:15,068 --> 00:27:18,374
production. Let's go back to that. First thing, you know

447
00:27:18,412 --> 00:27:22,086
that application I showed you, or actually this application where I showed

448
00:27:22,118 --> 00:27:25,718
you the arbitrary code execution with the expression language.

449
00:27:25,814 --> 00:27:28,806
A lot of people come back to me and say then, yeah, but that's Apache

450
00:27:28,838 --> 00:27:32,046
struts. Who uses that nowadays? Well, that might be

451
00:27:32,068 --> 00:27:35,486
the case, but let's look at another problem.

452
00:27:35,668 --> 00:27:39,454
Let's look at, is this the right one?

453
00:27:39,492 --> 00:27:43,166
Yes, this is the right one. This is a spring application, a spring boot application,

454
00:27:43,348 --> 00:27:46,626
and this is spring, we call it spring goof. Let me just enlarge this bit

455
00:27:46,648 --> 00:27:50,610
a little bit for you. I think if I can do this.

456
00:27:50,680 --> 00:27:54,546
Yes, cool. So this is a spring boot application and

457
00:27:54,568 --> 00:27:57,954
it contains a grocery list like beans

458
00:27:58,002 --> 00:28:01,490
for $0.50, milk for $1.09, et cetera, et cetera.

459
00:28:01,570 --> 00:28:04,646
Interesting, right? The domain is not very interesting as

460
00:28:04,668 --> 00:28:08,466
well. It is just a simple pojo that is serializable

461
00:28:08,498 --> 00:28:11,946
in this case, but contains a name and a cost and an

462
00:28:11,968 --> 00:28:15,178
id that is automatically generated and a lot of getters and

463
00:28:15,184 --> 00:28:18,698
setters in a two string. Nothing really important. The important thing is in

464
00:28:18,704 --> 00:28:23,466
the repository. And we probably are familiar with spring boot applications

465
00:28:23,578 --> 00:28:27,086
and the marvelous things that our friends from spring created for

466
00:28:27,108 --> 00:28:30,874
us. For instance, if I'm using spring data, I can extend

467
00:28:30,922 --> 00:28:34,894
the crud repository. And by extending the crud repository I do not have

468
00:28:34,932 --> 00:28:38,786
to create all crud functionality myself just by naming conventions like

469
00:28:38,808 --> 00:28:42,306
find all and find by name and giving it the right parameter. Like here it

470
00:28:42,328 --> 00:28:45,890
connects to the database that is available to me because

471
00:28:45,960 --> 00:28:50,114
of probably the dependencies I pulled in and it automatically configured

472
00:28:50,162 --> 00:28:53,702
it for me. I do not have to create the SQL string myself

473
00:28:53,836 --> 00:28:57,714
for the find by name. That is interesting. So I can really prototype

474
00:28:57,762 --> 00:29:01,162
very fast. Then I'm using spring data rest from

475
00:29:01,216 --> 00:29:04,778
a somewhat old version of spring. And at spring data rest I

476
00:29:04,784 --> 00:29:08,326
can use this annotation repository rest resource and that transforms

477
00:29:08,358 --> 00:29:12,094
my crud repository into a rest repository and gives me a bunch of

478
00:29:12,132 --> 00:29:15,662
endpoints. So basically my crud functionality are now

479
00:29:15,716 --> 00:29:19,486
available through JSON endpoints. Interesting, because if

480
00:29:19,508 --> 00:29:22,766
I can do this, I have a proof of concept and

481
00:29:22,788 --> 00:29:25,454
I can work on for instance my front end which might be a mobile app

482
00:29:25,492 --> 00:29:28,878
or whatever. But let's look at this application and that spring data rest because there's

483
00:29:28,894 --> 00:29:32,306
an issue with that. I am trying to run this application and I always have

484
00:29:32,328 --> 00:29:35,906
to pray to the demo gods that this application works. And as

485
00:29:35,928 --> 00:29:39,542
you can see it spins up and it has these items in.

486
00:29:39,596 --> 00:29:43,334
Okay, cool. So let's go back to a web browser like we see over

487
00:29:43,372 --> 00:29:46,994
here. And let's go to localhost

488
00:29:47,042 --> 00:29:50,486
80 80. And this is the hell browser. My hell browser just is there to

489
00:29:50,508 --> 00:29:54,278
show you what I can do with different arrest endpoints. See the hell browser

490
00:29:54,294 --> 00:29:58,454
for spring data rest. So what I can do is I can show you items

491
00:29:58,582 --> 00:30:01,598
one, and that will exactly show me the first item on

492
00:30:01,604 --> 00:30:04,350
my grocery list, beans for $0.50.

493
00:30:05,010 --> 00:30:09,022
Cool. I can give you number two, number three. But I can also do something

494
00:30:09,076 --> 00:30:12,686
like hey, search find by

495
00:30:12,708 --> 00:30:15,986
name. And name is better. This is exactly the corrupt repository I have

496
00:30:16,008 --> 00:30:19,154
that is transformed into a rest repository. And by

497
00:30:19,192 --> 00:30:22,974
query parameters I can say hey, give me beer. And indeed

498
00:30:23,022 --> 00:30:26,866
it gives me better for 599. Cool, it works.

499
00:30:26,968 --> 00:30:30,694
And I probably wrote a bunch of tests around it, ship it, because now

500
00:30:30,732 --> 00:30:34,086
we can go into the front end and then we are done within two

501
00:30:34,108 --> 00:30:37,750
days. But wait a minute, I said there was a problem with spring data

502
00:30:37,820 --> 00:30:41,718
rest. Let me show you that issue again. I will do this from my browser

503
00:30:41,814 --> 00:30:45,322
or from my terminal, and normally I will put my hoodie on,

504
00:30:45,456 --> 00:30:49,466
but not this time. So let

505
00:30:49,488 --> 00:30:53,306
me show you this JSON file. If I do a curl

506
00:30:53,338 --> 00:30:57,470
request, in this case a curl patch request, give it a body,

507
00:30:57,620 --> 00:31:01,440
a certain JSON body, I am allowed to

508
00:31:03,010 --> 00:31:06,198
give it a body like this. And this is just JSon mean, it's a JSOn

509
00:31:06,234 --> 00:31:09,794
list with key value pairs only. What I'm trying to do here

510
00:31:09,912 --> 00:31:13,026
with this version, with this specific version I was allowed to,

511
00:31:13,128 --> 00:31:17,058
if I do a curl patch request, I'm allowed to execute

512
00:31:17,154 --> 00:31:20,822
SPL, the spring expression language. And I do in somewhat the same

513
00:31:20,876 --> 00:31:24,278
way I can create, in this case

514
00:31:24,444 --> 00:31:28,470
I call a runtime, like here I'm getting the runtime and

515
00:31:28,540 --> 00:31:31,578
I execute a command, get it as an input stream, reroute to an

516
00:31:31,584 --> 00:31:33,980
output stream to show you it here on screen.

517
00:31:35,310 --> 00:31:39,126
For instance, what I can do is let's do the passwd file

518
00:31:39,158 --> 00:31:42,042
again. So I say spring rest,

519
00:31:42,096 --> 00:31:44,430
aspoid passwd.

520
00:31:45,730 --> 00:31:48,430
Let me copy paste this for you so it's a little bit more visible.

521
00:31:50,050 --> 00:31:53,200
So I'm enlarging it a bit more.

522
00:31:53,730 --> 00:31:56,514
So what you can see over here and let me show you the second line

523
00:31:56,552 --> 00:32:00,914
here. Yes, over here. So I do a curl patch request and I'm using

524
00:32:01,032 --> 00:32:04,906
this body and instead of the common

525
00:32:05,038 --> 00:32:08,562
which was there in the first example, I'm going to the etc.

526
00:32:08,626 --> 00:32:12,934
And then patchwd. I call

527
00:32:13,052 --> 00:32:16,502
this patch, curl patch request on my

528
00:32:16,636 --> 00:32:19,918
item one, which was the endpoint that was created

529
00:32:19,954 --> 00:32:23,206
for me to show me my first item

530
00:32:23,238 --> 00:32:27,050
in my grocery list. So it's there for a reason and I didn't configure anything

531
00:32:27,120 --> 00:32:30,858
yet. This is just it. But if I do this,

532
00:32:31,024 --> 00:32:34,886
you will see that I have the past WD

533
00:32:34,918 --> 00:32:38,154
file or I see the input of my past

534
00:32:38,192 --> 00:32:41,566
WD file. Yes, in the end it will

535
00:32:41,588 --> 00:32:44,842
give you a problem with an SPL evaluation exception.

536
00:32:44,906 --> 00:32:48,638
But that's not an issue because the actual command was already executed.

537
00:32:48,734 --> 00:32:52,082
And if I can read a certain file, I can also

538
00:32:52,136 --> 00:32:55,650
create a certain file or delete a certain file. And again,

539
00:32:55,800 --> 00:32:59,426
same issues as we have with the Apache struts sync. So it's

540
00:32:59,458 --> 00:33:03,094
something that is happening in other frameworks as well. It's not

541
00:33:03,132 --> 00:33:06,966
just Apache struts and these things are happening in other framework and you should

542
00:33:06,988 --> 00:33:10,278
be aware of that, these things happening because it is not your code,

543
00:33:10,364 --> 00:33:13,642
it is the code that you imported. And that is now a problem to you.

544
00:33:13,696 --> 00:33:16,986
And you probably weren't aware of this, were you? So what can

545
00:33:17,008 --> 00:33:20,202
we do about this? Let's go into how do we

546
00:33:20,256 --> 00:33:23,526
and at sneak see a solution. So we have hacked

547
00:33:23,558 --> 00:33:27,130
the stuff, but the solution is three ways, culture, process and tooling.

548
00:33:27,210 --> 00:33:30,606
And they are equally important. First of all, the culture, let's go

549
00:33:30,628 --> 00:33:34,362
in that. And I say team culture, but it can be company culture or department

550
00:33:34,426 --> 00:33:38,318
culture. Let's keep it to culture. Because within the teams

551
00:33:38,334 --> 00:33:41,970
that we work with, we have a lot of different people. We have developers,

552
00:33:42,310 --> 00:33:45,938
security people, operations people, management and a lot of more. But we all have

553
00:33:45,944 --> 00:33:49,766
a different mindset. We all think about different things, we all find different things important.

554
00:33:49,868 --> 00:33:53,586
Developers want to create things, security people want to make sure that it's

555
00:33:53,618 --> 00:33:57,350
not breached. So if a developer doesn't create something, it's all cool.

556
00:33:57,420 --> 00:34:00,786
Operations people, they care about, hey, what you developed

557
00:34:00,818 --> 00:34:03,482
and what we need to go in production, how can I scale it up?

558
00:34:03,536 --> 00:34:06,742
Can I just put in more pods? Can I easily

559
00:34:06,806 --> 00:34:10,522
restart things, things like that, that are on the operational side

560
00:34:10,576 --> 00:34:14,270
from a traditional point of view. And management, they probably think about

561
00:34:14,340 --> 00:34:18,126
getting things done, making revenue, making sure that that feature is

562
00:34:18,148 --> 00:34:21,390
out. So we all have different things we care about.

563
00:34:21,460 --> 00:34:24,990
Different KPIs, to say it in a fancy business word.

564
00:34:25,060 --> 00:34:29,138
However, if we think about each other's KPIs and

565
00:34:29,224 --> 00:34:32,466
each other's point of views a little bit more, then we are up for

566
00:34:32,488 --> 00:34:35,838
a good start. If a developer takes into account that you don't

567
00:34:35,854 --> 00:34:39,286
want to get breached, instead of just making sure it works, makes also sure

568
00:34:39,308 --> 00:34:42,870
that you don't get breached by having good practices in place,

569
00:34:42,940 --> 00:34:47,334
that's already a start. So the security folks will probably help

570
00:34:47,372 --> 00:34:50,374
you out with that. So play along. Just like children, we need to play along.

571
00:34:50,412 --> 00:34:54,086
And for instance management as well. If they just pushing you to get more features

572
00:34:54,118 --> 00:34:56,858
out at a certain pace, is that fair enough?

573
00:34:56,944 --> 00:34:59,786
Don't you need to take care of things like technical debt? Don't you need to

574
00:34:59,808 --> 00:35:03,242
review what kind of dependencies you take in? You need to take time to clean

575
00:35:03,296 --> 00:35:07,406
up your house, you need to take time to maintain normally if

576
00:35:07,428 --> 00:35:10,606
you look at physical things, we need to maintain cars and buildings, we also need

577
00:35:10,628 --> 00:35:14,158
to maintain software. So from managed point of view you should take that time.

578
00:35:14,244 --> 00:35:16,994
We should be aware of that, that it's not only building on top of something

579
00:35:17,032 --> 00:35:20,274
else. So if we play along together, then we're off

580
00:35:20,392 --> 00:35:24,126
with a good start. If that's not the case, then I'm afraid it's

581
00:35:24,158 --> 00:35:27,718
kind of useless. Just bringing in more process does not

582
00:35:27,804 --> 00:35:31,794
work. Saying like hey, we are breached. And now you have this Excel

583
00:35:31,842 --> 00:35:35,702
cheat sheet or this Excel sheet sheet. You need to

584
00:35:35,836 --> 00:35:39,574
mark every test manually that you have done that, and that might work

585
00:35:39,612 --> 00:35:42,786
for a week or two weeks, or creating more processes in

586
00:35:42,828 --> 00:35:46,170
that you need to get actively involved in. That might work for sometimes,

587
00:35:46,240 --> 00:35:49,706
but in the end you will gradually get back to the way you were working.

588
00:35:49,808 --> 00:35:53,950
So why not do it the other way around? See how you create

589
00:35:54,100 --> 00:35:57,774
your software. What is the process for you for creating something? And make sure

590
00:35:57,892 --> 00:36:01,758
that you fit security practices in that process that

591
00:36:01,764 --> 00:36:05,118
you already have so it will not slow you down. One of these things are,

592
00:36:05,204 --> 00:36:08,290
well, obviously is automation. Why not scan your stuff?

593
00:36:08,360 --> 00:36:11,422
Why not create tests that are security focused?

594
00:36:11,486 --> 00:36:14,766
If we do that and then we can run something and we see if it's

595
00:36:14,798 --> 00:36:18,226
there or not, instead of actively testing, hey, can I breach this? Yes or

596
00:36:18,248 --> 00:36:21,494
no? So automating stuff is a really important part over

597
00:36:21,532 --> 00:36:25,314
here because we want to focus on the stuff that we are good at creating

598
00:36:25,362 --> 00:36:28,854
software. And then we have tooling, you need to pick the tooling that

599
00:36:28,892 --> 00:36:32,454
is right for the way that you work. So instead of hey,

600
00:36:32,492 --> 00:36:35,786
management picked a tool and we need to satisfy this QA thing that

601
00:36:35,808 --> 00:36:38,714
is there somewhere in my pipeline that's not a good way of working. We actually

602
00:36:38,752 --> 00:36:42,410
need to adopt the tooling that help us in the current process

603
00:36:42,480 --> 00:36:45,646
that we work with. And if we do that, we're in a good position,

604
00:36:45,748 --> 00:36:48,926
automate a lot and we at Snyk, that is our focus. We want to be

605
00:36:48,948 --> 00:36:52,526
developer first. So what we are doing is we

606
00:36:52,548 --> 00:36:56,546
can create scanning tools for you. We scan for instance, your dependencies to

607
00:36:56,568 --> 00:37:00,322
see if there are problems. And we can do that in every single

608
00:37:00,456 --> 00:37:04,206
step of your pipeline or better set your software

609
00:37:04,238 --> 00:37:08,082
development lifecycle. And what I will show you now is

610
00:37:08,216 --> 00:37:11,606
my tool that is a free tool. There are other tools as well, but the

611
00:37:11,628 --> 00:37:15,142
point is that you need to be doing this. So if I'm going to,

612
00:37:15,276 --> 00:37:18,182
for instance my intellij application over here,

613
00:37:18,236 --> 00:37:22,258
this is that spring goof thing, I can stop it and I have

614
00:37:22,284 --> 00:37:25,658
the sneak plugin available and I can run a

615
00:37:25,664 --> 00:37:28,806
scan and that scan will look at my, in this case my manifest file,

616
00:37:28,838 --> 00:37:32,734
which is my pump file, and see what kind of versions of dependencies are there.

617
00:37:32,932 --> 00:37:36,282
It abstracts the complete dependency tree

618
00:37:36,346 --> 00:37:39,594
and sees if others are issues or what that dependency

619
00:37:39,642 --> 00:37:42,830
tree is, sends it over to sneak and sees if there are issues.

620
00:37:42,900 --> 00:37:46,206
And there are a bunch of issues. And all these issues come with information.

621
00:37:46,308 --> 00:37:49,938
And what is the information and how should I remediate stuff like that? So that

622
00:37:49,944 --> 00:37:53,138
is from out of your browser. But also I'm more of a

623
00:37:53,144 --> 00:37:57,346
guy that loves to work from the terminal. So instead of let

624
00:37:57,368 --> 00:38:00,598
me see where I am, I'm in the exploits folder. So I'm going to the

625
00:38:00,604 --> 00:38:04,146
root of that same folder, the spring goof application, and I'm doing a sneak

626
00:38:04,178 --> 00:38:07,526
test. It's a common line application that

627
00:38:07,628 --> 00:38:10,502
can be done here as well. And what it does, it does exactly the same.

628
00:38:10,556 --> 00:38:14,026
Only now in my terminal, in the same way you might be able, and what

629
00:38:14,048 --> 00:38:17,386
you see over here, this is interesting, is that a bunch of these things can

630
00:38:17,408 --> 00:38:20,874
be fixed. And this is because I enlarged my

631
00:38:20,912 --> 00:38:24,538
system. But it says okay, issues with no direct upgrades or path.

632
00:38:24,634 --> 00:38:28,282
And in some cases there are here an improper

633
00:38:28,346 --> 00:38:31,790
input validation in some specific version of the spring web.

634
00:38:31,860 --> 00:38:35,726
But if we go up, yeah, for instance here, update spring

635
00:38:35,758 --> 00:38:39,822
boot arrest jpa one five five build snapshot.

636
00:38:39,886 --> 00:38:43,778
Yes I know, to two point twelve release to fix

637
00:38:43,864 --> 00:38:47,586
all these underlying issues. And of course if I just downsize my

638
00:38:47,608 --> 00:38:50,830
terminal it will have a better view. But I scaled it up to make

639
00:38:50,840 --> 00:38:53,446
it more visible for you at this point. But you see is by doing these

640
00:38:53,468 --> 00:38:56,966
kind of things on your local machine I have quick feedback. And that is

641
00:38:56,988 --> 00:39:01,062
interesting because when I have quick feedback, just like my unit tests,

642
00:39:01,126 --> 00:39:04,342
I can actually prevent that a library

643
00:39:04,406 --> 00:39:08,230
that I depend on will get into my repository.

644
00:39:08,390 --> 00:39:12,700
So by doing this either here or either

645
00:39:13,230 --> 00:39:16,606
in your ide is a possibility. But next to that we have

646
00:39:16,628 --> 00:39:20,270
things like that's on your left side, on the coding side. Then you have

647
00:39:20,340 --> 00:39:24,122
the repository in your repository. For instance, why not connect your repository

648
00:39:24,186 --> 00:39:27,294
to a scanning tool that scans on a daily basis. If there are new

649
00:39:27,332 --> 00:39:30,594
vulnerabilities found or new fixes found and actively ping you like hey,

650
00:39:30,632 --> 00:39:33,666
we found something in your repository and we have a fix for you. That's the

651
00:39:33,688 --> 00:39:37,154
important part. Not only pointing out that there is a problem, but also there

652
00:39:37,192 --> 00:39:41,014
is a fix as well. Why not for instance, scan every pull request that comes

653
00:39:41,052 --> 00:39:44,358
in for possible new vulnerabilities that come in. If not,

654
00:39:44,444 --> 00:39:47,926
you might break the build or you might be actively pinged. Depending on your

655
00:39:47,948 --> 00:39:51,254
process. In your CI pipeline you can do things as well. And now I'm only

656
00:39:51,292 --> 00:39:54,602
talking about your dependencies. But in your CI pipeline I can do that sneak test

657
00:39:54,656 --> 00:39:58,406
in the same way. For instance we connect with Jenkins and with GitHub actions

658
00:39:58,438 --> 00:40:01,866
and all kinds of pipelines. Or you can connect that Cli I

659
00:40:01,888 --> 00:40:05,454
showed you manually. Nevertheless, it doesn't matter what tool you use,

660
00:40:05,492 --> 00:40:08,734
but use a tool over there, but not just there. If you do it just

661
00:40:08,772 --> 00:40:12,506
there, that means that when you build there might be some time between coding

662
00:40:12,538 --> 00:40:15,854
and actually building in your pipeline. So that feedback cycle takes a long time.

663
00:40:15,892 --> 00:40:18,802
And before you go to production, you want to be safe at that point.

664
00:40:18,856 --> 00:40:22,658
And that is fair. That is actually fair. But when you

665
00:40:22,744 --> 00:40:25,922
build it from your CI pipeline and you want to deploy it after

666
00:40:25,976 --> 00:40:28,798
deployment, you're not done because we do devsecops.

667
00:40:28,894 --> 00:40:32,358
Why not make a snapshot in that point in time, for instance by using a

668
00:40:32,364 --> 00:40:35,846
sneak monitor, and that takes a snapshot of that point in time and scans it

669
00:40:35,868 --> 00:40:39,366
on a daily basis and actively pings you if there is a new

670
00:40:39,388 --> 00:40:42,506
vulnerability found, because that can take up to two and a half years.

671
00:40:42,608 --> 00:40:45,866
Few things I want to show you. I connected for instance a bunch of

672
00:40:45,888 --> 00:40:49,622
my repositories from GitHub to in this case my sneak UI.

673
00:40:49,686 --> 00:40:53,062
This is spring goof, exactly the same thing I showed you earlier.

674
00:40:53,126 --> 00:40:56,926
And it will scan my repository on a daily base and shows me if

675
00:40:56,948 --> 00:41:00,506
there are problems, for instance, and what is the priority score

676
00:41:00,538 --> 00:41:04,586
like which one do I have to help first? And these are interesting facts

677
00:41:04,778 --> 00:41:08,610
that you can help. And because it's scanning on a daily basis, you see last

678
00:41:08,680 --> 00:41:12,114
recurring test 5 hours ago, I can test it now, but tomorrow it will test

679
00:41:12,152 --> 00:41:15,410
again. I did it on a daily basis. So that is one thing.

680
00:41:15,480 --> 00:41:19,174
But also and this is a sneak peek of your own code because that

681
00:41:19,212 --> 00:41:22,198
code that you created is still something that is important.

682
00:41:22,284 --> 00:41:25,890
I enabled a beta for sneak code that we are launching.

683
00:41:25,970 --> 00:41:29,126
It's not yet in the free tier, but it will

684
00:41:29,148 --> 00:41:32,634
be soon and it does code analysis for you. So next to

685
00:41:32,672 --> 00:41:36,362
the scanning of your dependencies, which is a very very important part. It also

686
00:41:36,496 --> 00:41:39,578
says something like hey, there's a SQL injection in a part of your code.

687
00:41:39,664 --> 00:41:43,082
Let me just show you what is the issue. Well, I'm using a parameter

688
00:41:43,146 --> 00:41:46,666
here and I'm actually copy pasting the parameter into a literal

689
00:41:46,698 --> 00:41:50,174
string for a SQL query what I can use to

690
00:41:50,212 --> 00:41:53,534
do a SQL injection. So these are interesting parts. This is already

691
00:41:53,572 --> 00:41:56,914
there. It's coming up for the free tier. So I wanted to

692
00:41:57,112 --> 00:42:00,306
show you this. So what we mean is we need to get

693
00:42:00,328 --> 00:42:03,266
the tooling right to fit your needs.

694
00:42:03,448 --> 00:42:07,058
Not so much satisfy a tool because it says hey,

695
00:42:07,144 --> 00:42:10,806
there is an issue. No, take a tool that helps you,

696
00:42:10,908 --> 00:42:14,326
gives you information on what is wrong, how to fix it,

697
00:42:14,428 --> 00:42:17,846
and pings you in the correct way that you want to

698
00:42:17,868 --> 00:42:21,306
do that. So what we say is make sure that in every step of

699
00:42:21,328 --> 00:42:24,906
your development lifecycle you have security in

700
00:42:24,928 --> 00:42:28,346
place from the creation, from the thought process and

701
00:42:28,368 --> 00:42:32,474
the coding process on your local machine while you're creating it, to the production process

702
00:42:32,592 --> 00:42:36,330
by monitoring the stuff. Basically what we say, and this is a buzzword,

703
00:42:36,410 --> 00:42:40,126
shift left and left means as soon as left as

704
00:42:40,148 --> 00:42:43,694
possible in that previous thing I showed you. So start from

705
00:42:43,732 --> 00:42:47,474
the developer's machine already if you want to know more about best practices in

706
00:42:47,512 --> 00:42:50,994
code. So this was about your dependencies. But if you want to have more

707
00:42:51,032 --> 00:42:54,158
best practices on how to create good Java applications,

708
00:42:54,254 --> 00:42:57,586
or how to create good Java applications, for instance for Docker, visit our

709
00:42:57,608 --> 00:43:00,726
sneak blog. We have a lot of stuff on there, not just the tooling I

710
00:43:00,748 --> 00:43:03,638
showed you, but a lot of research we do and a lot of help that

711
00:43:03,644 --> 00:43:07,762
we want to get into the community to make you a secure developer.

712
00:43:07,826 --> 00:43:11,266
I want to end with this sheet. We're currently asking you to do a Java

713
00:43:11,298 --> 00:43:15,186
survey, and if you're able to, please go to the Java

714
00:43:15,218 --> 00:43:18,982
ecosystem survey and fill it in. That will be all. That was my talk.

715
00:43:19,036 --> 00:43:21,930
Thank you for watching. Enjoy the rest of the conference. See ya.

