{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/073b9586-ec91-4aea-8893-42b66d9ae404", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["abhishek gupta", "abstractions", "allows", "apis", "app", "applications", "apps", "attendees", "aws", "based", "be", "become", "build", "building", "but", "by", "called", "can", "cdks", "cloud", "cluster", "cncf", "code", "combination", "components", "concept", "conf fourty two", "config", "constructs", "containers", "context", "could", "defacto", "deploying", "developers", "emerged", "endtoend", "etc", "firstclass", "has", "infrastructureiscode", "kubernetes", "kustomize", "languages", "livecoding", "objectoriented", "opensource", "orchestrating", "packaging", "principal developer advocate", "programming", "project", "provide", "reusable", "solutions", "specifications", "understanding", "using", "workflow", "workflows", "yaml", "yamlcentric"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "id": "0dc1054e-3cfb-4585-814a-81172703ca10", "status": "completed", "error": null, "text": "Thanks for tuning in and welcome to this talk. I am Abhishek Gupta, a developer advocate at AWS where I work on a bunch of things, but containers, databases and golang happen to be some of my key focus areas. And I am joining you today from my home here in New Delhi, India. So why am I really talking about deleting or removing Yaml? To be very, very honest with you, I have nothing against YaML. I have tolerated things like XML in the the past. So I guess YAML is fine. But I'm a developer, I like to write code and the last time I checked, YAML isn't really a programming language. But if you think in terms of kubernetes, YaML is the king. It's like this lingua franca, so to speak. So if you look at existing tooling like helm or customize, or even if you're writing manifests by hand, it's all Yaml. So although the talk says removing YAml, it's more about circumventing it or pushing it behind the scenes so that it's not in your face all the time, so to speak. So yeah, in the next 20 to 25 minutes or so I will talk about this tool called CDK for Kubernetes. CDK. It's in short, and it's an open source project which is part of the CNCF or the cloud Native Computing foundation. And in very, very simple terms, cdks is a framework using which you can define and model your kubernetes, Opensource and applications. So I'll give you a verb and tour of how you can use cdks with the Go programming language. So I want to start off by talking about how would you typically use something like CDK. So conceptually it's actually quite simple. So as you can see here is a very, very high level overview of the workflow. So if you kind of start off by bootstrapping a project, you write some code to define your Kubernetes application and then you ask CDK eight to convert that code into YAMl. Right? And once you have that YAml manifest, it's really up to you as to how you want to use it. Every CDK application consists of what you call a tree of components, and these are also called constructs. So you combine basic constructs like a deployment, or a service or ingress, or a persistent volume and so on and so forth, and combine that into a chart and a chart is yet another construct in syndicates. And finally, one or more of such charts can be but inside an app or an application. So an app is the root of the tree in the entire hierarchy, right? So what I'm going to do is switch over to my ide. Now enough of slides and we'll spend some time looking at some code, just playing around with things and trying to make sense of everything, trying to make sense of what cdks is and how it works. So let me do that. All right, awesome. So in addition to actually being a framework, CDkates also provides a very, very handy CLI. So what I'm going to do is use this CLI to bootstrap a very simple application here just to get things going right. So I hope you can see this. So I'm going to create a new directory and change into that. Simple as that. And then I'll kick things off. All right, so what I'm going to do now is use the CLI to bootstrap an application. So say CDkates, which is the CLI init, initialize an app. And I'm using go here as a programming language. So I'm specifying go app here. So I started off with an empty directory and just invoked the CDK CLI and asked me, hey, give me something to work with, right? And what it's going to do is come back to me and you'll see that soon. So it's going to spit. But this very, very simple, yet very useful starting point from where I can build on stuff, right? So here it is. This process is done. So if I were to open this main go file over here real quick. And if you look at this function called new, my chart, what this does is create something called a CDKs chart object. Okay. And if I were to scroll down a little bit and show you the main function. So this actually encapsulates or this chart is within this app, right? So in this app there's just one chart. And right now this chart is actually empty. But I'm going to add some code here and we'll define a very, very simple sort of hello world Kubernetes, our favorite Nginx deployment here. So in the interest of time, what I'm going to do is do some copy paste and then walk you through that code real quick. So let me do that and I'll just update some of the packages here because they are not quite right, but yeah. All right, awesome. So just focus on this part of the code right here. So even if you've deployed a very sort of simple Kubernetes application in the past, you have some experience with that you should be familiar with what you actually see right now. So things like labels or selectors or deployment, or a container here, an image and so on and so forth, just like you would define a yaml manifest, right? But the big difference here is that now this is in the form of code. This just happens to be go code. But CDKs also supports Python, typescript and Java as well. So while this looks pretty simple, and you might feel like, hey, this is enough, I'm good, but trust me, things are going to actually get pretty verbose when you start building serious stuff using these simple primitives. So what I'm going to do now is actually containers with this Nginx based example, but show you how to improve this a little bit. Right? So in order to do that, I'll switch over to a different project here, which I have for you. Now, if I were to open this main go file right here. Now this is going to look very, very similar to what I just showed you, but at the same time it's different. So what I'm actually doing is using the CDKs plus API, which is much more natural and intuitive. So if I scroll up a little bit, if you see, this is the package which I'm using, which is called CDKs plus. So what I do here is define a deploying, add a container to it. And if you notice, I really don't need a lot of boilerplate code here, things like defining selectors or labels. And then finally what I do is expose this via a service. So all this is go code. And to convert this into a manifest, I can actually go ahead and use the CLI. And to do that, I'm going to hop back into this terminal right here and use a command called cdks synth. Okay? So what this will do is this will generate a manifest in a different folder called deskt. So if you see this is right here. Now, if I were to open that manifest for you, just to show this, as you can see, I just have a deployment, very simple deployment with pod spec and all the usual stuff, right? The selectors and the labels and the containers image everything, all the normal stuff, which you would typically do if you would define it manually, for example. And if I were to scroll down, you would see the service as well, which happens to be of the type load balancer here. So just like we defined in our go code, that's exactly how the yaml sort of got manifested, so to speak. Right now. Now that you have this Yaml file, it's really up to you. Of course, in terms of how you want to use it. So you can obviously use Kubectl and do all this manually, but actually integrating this into your existing Gitops workflow is something. It's an obvious choice and that's a very interesting topic. But to be honest with you, I don't have time to cover it in detail. So let's go ahead and keep proceeding. So any Kubernetes demo is incomplete without Nginx, right? So let's actually go ahead and deploy this thing. So I'm going to go back. So I'm actually using a local Kubernetes cluster here. Just happens to be a single node kind cluster for the purposes of this demo. So what I'm going to do is just apply this Yaml file. So just apply the context of this disk folder. And as you can see, the deployment and service have been created. So if I were to go ahead and check as to what's going on. So if you see that the pod is currently in the container creating phase. So in the meanwhile we can go ahead and check our service. And you can see the service here as well, the load balancer type, it has been created. And if I were to go back and check the pod again. Yeah, so it's in the running status now. So if I wanted to try and access this NginX deployment for the purposes of this demo, I'm going to just use port forwarding here on port 1990 and go to my browser here real quick and cool. We are able to have this simple demo up and running and access our Nginx server. Great. Now while this Nginx example was very simple, of course. Right. But now I'm going to move on to something a little bit more involved. So I'm going to show you a WordPress stack that has a MySQL database along with the WordPress application itself. So in order to do that, what I will do is I'll switch over to yet another folder or project which I have. So if I were to open the code here and scroll up a little bit. Now if you notice here we actually have two charts. One is this new MySQL chart and the other one is the new WordPress chart. Okay. And as you can see, there is a lot going on here. We are defining all sorts of Kubernetes resources like secrets and deployments and of course containers. And also notice persistent volumes and persistent volume claims. Right. And the same applies to the WordPress chart as well. So pretty awesome. This is good, right? But let me repeat this again. You do not want to write these things over and over, say by multiple teams within your organization. What you can actually do is write this as a custom construct, a custom cdks construct, and then it will be usable as an artifact. It's a very simple reusable artifact which other teams can utilize. So let me show this to you as well. And for that, as usual, I'm going to hop into another project quickly and show you how a custom construct works. So if you pay attention to this function, call right here. Now imagine, imagine if someone wanted to stand up a simple WordPress cluster. What they can do is simply go in and use the custom construct, just like any of the out of the box ones which you use like deployment or a service and so on and so forth. So this new WordPress stack function actually encapsulates the process of creating the components for a WordPress stack. Now if I were to dig into this a little bit and go into what this function does, and notice, the first thing you should notice is it actually returns a construct, right? It doesn't return a chart, okay? And whatever you see within this function now, it's very similar to what I just showed you, right? I showed you two different charts. One was for MySQL, one was for WordPress. This function sort of encapsulates everything, all that process and provides this AWs, a single go to sort of artifact which other developers, other engineers within your organization can use. Right? All right, cool, this looks good. So let's go ahead and deploy a WordPress cluster. So as usual, what I'm going to do is use this simple command cdks synth. It's going to kickstart the process of creating the YAMl manifests. And what I can actually do is go ahead and create this. So what I'm going to do is actually watch the pods in the background while I, excuse me. So I think I was a slight typo here. All right, so I'm going to watch the pods and at the same time apply the context of this chart. So let's see what's going on here. So yeah, our pods are getting created. They are in the pending state right now. But while this is getting done, let me show you the manifest which was actually generated. That should be pretty interesting. Yeah, so you see here just the usual stuff. Everything which we had specified in the form of that function. So we have a secret here. We have a deployment for MySQL database for WordPress. We have persistent volume claims we have a service, all the usual things which you would expect, right? But imagine you had to write all this by hand. It's better to define this in code and then ask a tool like cdks to convert that into YAml. Right? So the same applies to the WordPress deployment as well. So I have a deployment object and a service which is of type load balancer because I need to access my WordPress application publicly and so on and so forth. Right. So let's actually go back and see what's happening. All right. So awesome. So I think things are ready. What we can do is actually check our persistent volumes and volume claims as well. Pv is up and ready. And what about the PVC? It is bound so I think things look good. So we are right to try this thing out. So as usual I'm going to do some port forwarding here just to test things out and I'm going to access the WordPress on port 80 80. So let me go back to my browser here and just change my port real quick. Let's see how this goes. All right, so what you see now is actually the landing page for a WordPress website, something which I can create from scratch just for demo purposes. I can show this to you as to how you can sort of play around with this WordPress application. So I have set up my website now I can just log in using the credentials I had just set. Yeah, so right now you're seeing a WordPress application on Kubernetes using CDK. So this is the admin console. Yeah, I can go ahead add a new post life from conf fourty two. So far so good I guess, and publish this post. And I can actually now go back to the website itself, exit the admin console and yeah, this is my WordPress website. Cool, nice. So far so awesome. Now you can go ahead and sort of keep playing with this WordPress website, maybe try things like deleting the mySQl deployment and just fooling around with things to see how it behaves and so on and so forth. So I'll leave that as an exercise to you. And what I'm going to do now is take a look at a slightly more advanced use based and this is about how to actually use crds with cdks. So crds actually if you're not familiar, it stands for custom resource definitions. So custom resources are actually a part of the Kubernetes extension API. So just like we have pods and deployments and other native objects in Kubernetes, you can define custom ones as well. And it's the custom resource definition API that actually makes this possible. So although CRDs and their implementations are relatively advanced, and obviously I'm not going to cover that in this session, but at the end of the day you have to understand that they are also defined as YAMl manifests. But with CDK eight, what you can do is import existing crds or custom resource definitions and simply use them as API in your code. Okay, so let me show you an example of a project called Strimzi. So it's actually a Kubernetes operator that helps you run and manage Apache Kafka on Kubernetes. So I already have the crds involved. So let me quickly go back to that project as well and show you how that thing is. So like I said, I have the Strimzi crds already installed. So as you can see here, there are a bunch of crds, but the ones which I'll be using are for creating a Kafka cluster and a Kafka topic. So I'll just be using two crds here. So Kafka topics and this core Kafka cluster CRD. Okay. All right, so what I'll do is first import these crds using the syndicates CLI, okay. And I'm going to reference the crds directly from GitHub, as you will see very soon. Oops, typo. And as you can see, I'm doing a CDK, it's import, and this is the location for the CRD, the Yaml file itself. I'm referencing the one directly from GitHub, and this is going to go ahead and import this. This is for the Kafka cluster CRD, and I will also import the CRD for working with Kafka topics. So as always, I have referred to this CRD right here directly from GitHub, but doesn't really matter as long as you have access to this Yaml file. All right, so if I go ahead and check the imports folder here, you'll find something interesting. So we have a couple of directories called Kafka streams IO and Kafka topic, underscore blah blah blah. So these are slightly verbose naming, but the important thing is that now what you can do is use these crds as API, like I said earlier. So if I were to open this code right here and show you this function called new Kafka Chart, which happens to return a CDK's chart, what is it really doing? So it's simply using that API, the one which we just generated to define or specify a new Kafka cluster. And it has a zookeeper as well. So as you can see, I have provided the version, the number of replicas or the number of Kafka brokers, the configuration for the server and so on and so forth. Okay, and how would I actually use this if I were to open the main go file? You will see that all I'm doing is encapsulating this chart into an application, a syndicates app, and yes, that's pretty much all I need to do. Right? So to create a new Kafka cluster, I'm going to follow the same old, the usual workflow. So I'll first do a syndicates synth. It is going to spit but Yaml manifest. So if you see here, if I were to open this file here again, this is the custom resource definition for Kafka cluster using strimzi, right? So everything which we had specified in the code is here. The version, the number of replicas and the configuration and so on and so forth. So simple as that. Now I can go ahead and apply this manifest to the cluster so that it can go ahead and create the resources required for this Apache Kafka installation on kubernetes. Okay, so to be very honest with you, this is actually going to take a bit of time. So if I were to check this right here. So as you can see, I have all the resources in the Kafka namespace and the cluster operator. This is something which I had, like I said, I had already deployed the crds as well as the strimz operator. So as you can see, this is already up and running. Of course, otherwise nothing would work. And right now what's work in progress is the zookeeper pod and the related resources. Okay, I already have zookeeper service created here, so let's see how this goes. If I were to check this again as to how things are going. Actually, you know what, let me do this. Get pods. Okay. So I can see that all these pods are up and running. So what I'm going to do is just wait for some of these resources. Excuse me, I didn't mean to type that. My apologies. So let's see if everything we need is here. So let's see. Yeah, so some of the resources are still actually getting created. Now sort of once everything is created, you should actually see a sort of success message from this command. We'll give it a few seconds. Awesome. Okay, so as you can see, our Kafka resources, the Kafka cluster on kubernetes is up and running. Now we can actually go ahead and test it using the good old Kafka Cli the producer and consumer Cli. So let me go ahead and do that. So I'm going to first get the value for the bootstrap server. I'm just going to simply run a bunch of commands and show you how this cluster actually works. And what I'm going to do is initiate the producer here and I'm going to start the consumer in a different terminal first the bootstrap server, and it, and I can actually go back here and produce messages. Hello, oops. Hello conf 42. If I can type cube native, let's see what's going on on the consumer side. All right, awesome. So we are actually able to receive these messages. Hello Con 42, cube native. Awesome. So this is great, right? So what you just saw, it's a very, very simple example, I do agree. But then if you think about in the larger, in the bigger scheme of things, you were able to actually write code, actual go code, to define a Kafka cluster and then use that to convert that into a CRD specification or yaml to define your custom resource definition and then apply that to your Kubernetes cluster. So with that said, what I'm going to do is switch back to my presentation. That's pretty much a wrap up in terms of the demos at least. So let me switch back real quick. So that's pretty much all I have. I mean this is all I could cover in the space of about 20 odd minutes. But just to give you a quick recap. So we covered the basic syndicates API and how to bootstrap a project and write a Kubernetes deploying. And then you saw how cdks plus provides a much better developer experience in terms of a very natural and intuitive API. We then explored how to abstract away WordPress as a custom component and then use that on demand to spin up a complete WordPress deployment on kubernetes. And last but not the least, we looked at some advanced stuff where we imported a custom resource definition as an API and then used that to kick off a Kafka cluster on kubernetes. So really what I'm hoping for you is to think about this concept of infrastructure is code as opposed to infrastructure as code. So what you saw here is actually a code first approach using the programming languages we are familiar with, which we leverage day in, day out, right? So if you want to learn more, there are lots of resources you can refer to. And I've actually been writing up a series of blog posts. So yeah, check that out. I think I've finished about four blogs and a couple of them are still left so it's a pretty lengthy series but I'm hoping it will be useful for you. Of course you can read up on the Kubernetes excuse me the CDK's documentation AWS well and there are a bunch of examples on the CDK's GitHub repo and of course then there is the API reference as well. One last thing before I let you go, I would really really appreciate it if you can provide your feedback. We really want to hear from you how your experience was and we always look for ways to improve so all you need to do is scan this QR code or go directly to this URL if you so prefer. It shouldn't take more than a minute to be honest with you so this is very short and sweet feedback so I would really appreciate it if you can help us with your inputs. So thanks again for joining and enjoy the rest of the conference. Cheers.", "words": [], "utterances": null, "confidence": 0.959125909307871, "audio_duration": 1549.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Abhishek Gupta is a developer advocate at AWS. In the next 20 to 25 minutes or so he will talk about this tool called CDK for Kubernetes. He'll give a tour of how you can use CDK with the Go programming language.\n- Every CDK application consists of what you call a tree of components. You combine basic constructs like a deployment, or a service or ingress, and combine that into a chart. Once you have that YAml manifest, it's up to you as to how you want to use it.\n- Use the CDKs plus API to bootstrap an application. We'll define a very, very simple sort of hello world Kubernetes deployment. But things are going to get pretty verbose when you start building serious stuff using these simple primitives.\n-  Kubernetes demo is incomplete without Nginx, right? So let's go ahead and deploy a WordPress cluster. This function encapsulates the process of creating the components for a WordPress stack. It's a very simple reusable artifact which other teams can utilize.\n- So this is the admin console. And I can actually now go back to the website itself. Cool, nice. Now you can go ahead and sort of keep playing with this WordPress website. Maybe try deleting the mySQl deployment and just fooling around with things.\n- With CDK eight, what you can do is import existing crds or custom resource definitions and simply use them as API in your code. To create a new Kafka cluster, follow the usual workflow.\n- CDK plus provides a much better developer experience in terms of a very natural and intuitive API. What you saw here is actually a code first approach using the programming languages we are familiar with. If you want to learn more, there are lots of resources you can refer to. I've actually been writing up a series of blog posts.\n- One last thing before I let you go, I would really really appreciate it if you can provide your feedback. We really want to hear from you how your experience was and we always look for ways to improve. All you need to do is scan this QR code or go directly to this URL.", "auto_highlights_result": {"status": "success", "results": [{"count": 9, "rank": 0.07, "text": "Kafka cluster", "timestamps": [{"start": 1046544, "end": 1047382}, {"start": 1053258, "end": 1054730}, {"start": 1082908, "end": 1083666}, {"start": 1137452, "end": 1138630}, {"start": 1166088, "end": 1166894}, {"start": 1185820, "end": 1186754}, {"start": 1308324, "end": 1308906}, {"start": 1396288, "end": 1397530}, {"start": 1465140, "end": 1465886}]}, {"count": 1, "rank": 0.06, "text": "new Kafka Chart", "timestamps": [{"start": 1125576, "end": 1126794}]}, {"count": 1, "rank": 0.06, "text": "simple Kubernetes application", "timestamps": [{"start": 331004, "end": 332310}]}, {"count": 2, "rank": 0.06, "text": "Kafka topics", "timestamps": [{"start": 1051572, "end": 1052314}, {"start": 1087932, "end": 1089186}]}, {"count": 2, "rank": 0.06, "text": "Apache Kafka", "timestamps": [{"start": 1023656, "end": 1024686}, {"start": 1204212, "end": 1205146}]}, {"count": 1, "rank": 0.06, "text": "Kubernetes resources", "timestamps": [{"start": 632908, "end": 634034}]}, {"count": 1, "rank": 0.06, "text": "Kafka Cli", "timestamps": [{"start": 1314612, "end": 1315722}]}, {"count": 1, "rank": 0.06, "text": "Kafka brokers", "timestamps": [{"start": 1145424, "end": 1146566}]}, {"count": 1, "rank": 0.06, "text": "Kafka Chart", "timestamps": [{"start": 1125832, "end": 1126794}]}, {"count": 2, "rank": 0.06, "text": "custom resource definitions", "timestamps": [{"start": 972152, "end": 973838}, {"start": 1008772, "end": 1010298}]}, {"count": 17, "rank": 0.05, "text": "things", "timestamps": [{"start": 31372, "end": 31670}, {"start": 48818, "end": 49014}, {"start": 189808, "end": 189994}, {"start": 213112, "end": 213362}, {"start": 225518, "end": 225726}, {"start": 337984, "end": 338282}, {"start": 367992, "end": 368194}, {"start": 426108, "end": 426374}, {"start": 654852, "end": 655198}, {"start": 828718, "end": 828962}, {"start": 859492, "end": 859742}, {"start": 871992, "end": 872194}, {"start": 878252, "end": 878454}, {"start": 949088, "end": 949274}, {"start": 952368, "end": 952554}, {"start": 1251668, "end": 1251854}, {"start": 1390864, "end": 1391034}]}, {"count": 20, "rank": 0.05, "text": "WordPress", "timestamps": [{"start": 603652, "end": 604282}, {"start": 607188, "end": 607546}, {"start": 627048, "end": 627682}, {"start": 644992, "end": 645446}, {"start": 695744, "end": 696294}, {"start": 708836, "end": 709482}, {"start": 714948, "end": 715530}, {"start": 739328, "end": 740054}, {"start": 758308, "end": 758794}, {"start": 823560, "end": 824478}, {"start": 841232, "end": 841686}, {"start": 847808, "end": 848214}, {"start": 880428, "end": 881154}, {"start": 895472, "end": 896330}, {"start": 907348, "end": 907786}, {"start": 915784, "end": 916126}, {"start": 941504, "end": 941974}, {"start": 947488, "end": 947846}, {"start": 1447792, "end": 1448662}, {"start": 1453300, "end": 1453834}]}, {"count": 1, "rank": 0.05, "text": "boilerplate code", "timestamps": [{"start": 424152, "end": 425542}]}, {"count": 1, "rank": 0.05, "text": "Kafka streams IO and Kafka topic", "timestamps": [{"start": 1105428, "end": 1107578}]}, {"count": 1, "rank": 0.05, "text": "actual go code", "timestamps": [{"start": 1394464, "end": 1395434}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}