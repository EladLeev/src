1
00:00:00,410 --> 00:00:06,094
Jamaica make up real

2
00:00:06,132 --> 00:00:10,618
time feedback into the behavior of your distributed systems and observing

3
00:00:10,714 --> 00:00:14,046
changes exceptions. Errors in real time

4
00:00:14,148 --> 00:00:17,914
allows you to not only experiment with confidence, but respond

5
00:00:18,042 --> 00:00:20,480
instantly to get things working again.

6
00:00:24,610 --> 00:01:04,734
You hi

7
00:01:04,772 --> 00:01:08,610
everyone, my name is Kuna George. I am a developer advocate at

8
00:01:08,680 --> 00:01:13,138
AWS and excited to be here at 42 today

9
00:01:13,304 --> 00:01:16,850
to talk about my two favorite topics

10
00:01:16,930 --> 00:01:19,810
combined, chaos engineering and serverless.

11
00:01:19,890 --> 00:01:24,098
In this session I'm going to talk about chaos engineering for serverless

12
00:01:24,274 --> 00:01:28,358
using AWS fault injection simulator.

13
00:01:28,454 --> 00:01:31,834
So let's get to it. So I think you

14
00:01:31,872 --> 00:01:35,914
all know the faces of chaos engineering by now,

15
00:01:36,112 --> 00:01:39,050
where we walk through from a steady state,

16
00:01:39,120 --> 00:01:42,990
creating our hypothesis and then create and run

17
00:01:43,060 --> 00:01:46,794
our experiments and so on. And for this specific session

18
00:01:46,922 --> 00:01:50,206
I'm going to focus on the hypothesis part, how to

19
00:01:50,228 --> 00:01:53,474
create hypothesis for serverless and

20
00:01:53,512 --> 00:01:57,810
how to run experiments for serverless applications.

21
00:01:58,630 --> 00:02:02,462
So to begin with, to just set the stage,

22
00:02:02,526 --> 00:02:06,350
I want to talk just briefly about serverless. In case

23
00:02:06,440 --> 00:02:10,454
you don't know what serverless is, so many

24
00:02:10,492 --> 00:02:14,322
of you might know that these are the tenants that define serverless

25
00:02:14,386 --> 00:02:18,166
as can operational model. First off, we don't have any infrastructure

26
00:02:18,198 --> 00:02:21,802
to provision or manage, so there's no servers for us

27
00:02:21,856 --> 00:02:25,354
to provision, operate, patch and so on.

28
00:02:25,472 --> 00:02:29,178
And serverless automatically scales by the unit of

29
00:02:29,264 --> 00:02:33,022
consumption, the unit of

30
00:02:33,076 --> 00:02:37,150
work or consumption rather than by the server unit.

31
00:02:37,570 --> 00:02:41,326
And with serverless we pay for value. We have a

32
00:02:41,348 --> 00:02:44,866
pay for value building model. So for

33
00:02:44,888 --> 00:02:48,734
instance, you might value consistent throughput or execution duration,

34
00:02:48,862 --> 00:02:52,398
you only pay for that rather than buy the server unit.

35
00:02:52,494 --> 00:02:56,294
And serverless is built with availability and

36
00:02:56,332 --> 00:02:59,830
fault tolerance in mind, so you don't have to

37
00:02:59,980 --> 00:03:03,862
specifically think about architecting for availability because

38
00:03:03,916 --> 00:03:06,840
it's built in into that service.

39
00:03:07,710 --> 00:03:11,290
But when we say serverless, we mean that it's about

40
00:03:11,360 --> 00:03:14,726
removing the undifferentiated heavy lifting

41
00:03:14,758 --> 00:03:18,314
that is server operations. So you

42
00:03:18,432 --> 00:03:21,582
don't have access to the underlying services,

43
00:03:21,716 --> 00:03:25,310
the underlying infrastructure, which could be

44
00:03:25,380 --> 00:03:28,894
a difficulty when it comes to chaos engineering, but more on that

45
00:03:28,932 --> 00:03:33,298
later on. And at AWS, when we're talking about serverless services,

46
00:03:33,464 --> 00:03:36,702
well, we are often referring to these like AWS,

47
00:03:36,766 --> 00:03:39,570
Lambda, Amazon Dynamodb,

48
00:03:40,310 --> 00:03:42,530
Amazon API gateway,

49
00:03:42,950 --> 00:03:46,566
our object storage service s three,

50
00:03:46,748 --> 00:03:51,330
and a lot of other services as well, like SNS

51
00:03:51,410 --> 00:03:55,494
and SQs and so on. And the serverless landscape is

52
00:03:55,532 --> 00:03:59,002
really growing all the time. So now

53
00:03:59,056 --> 00:04:02,986
with that said, let's get to the topic of this

54
00:04:03,088 --> 00:04:06,810
session. Serverless chaos experiments.

55
00:04:07,150 --> 00:04:11,338
So when we're creating our experiments,

56
00:04:11,434 --> 00:04:14,682
we can start by looking at some of the perhaps

57
00:04:14,746 --> 00:04:18,330
common serverless weaknesses that we can see in architectures

58
00:04:18,410 --> 00:04:22,062
at time, for instance, we can look at

59
00:04:22,116 --> 00:04:26,126
errors. Are we handling errors correctly within our applications?

60
00:04:26,238 --> 00:04:29,922
No matter if the error handling is inside our code or

61
00:04:29,976 --> 00:04:33,502
a feature of the service, we better make sure that we're handling

62
00:04:33,566 --> 00:04:37,554
errors. And certain services have releases or

63
00:04:37,592 --> 00:04:41,880
features like dead letter queues and things like that, which are great,

64
00:04:42,330 --> 00:04:46,306
but we want to make sure to be able to test it. And chaos engineering

65
00:04:46,338 --> 00:04:50,534
can help us do that. And with AWS,

66
00:04:50,582 --> 00:04:54,698
lambda functions and different dependencies like other AWS services

67
00:04:54,784 --> 00:04:58,662
or third parties, we need to and want to get our timeout

68
00:04:58,726 --> 00:05:02,494
values right. And in most cases they probably are,

69
00:05:02,612 --> 00:05:06,494
but that's often in a steady state. So what happens when there are

70
00:05:06,532 --> 00:05:09,310
issues, say latency for instance?

71
00:05:11,010 --> 00:05:14,514
And with event driven architectures becoming more and

72
00:05:14,552 --> 00:05:18,162
more common, how we handle events within our

73
00:05:18,296 --> 00:05:21,666
solutions or our applications is really important.

74
00:05:21,848 --> 00:05:25,766
Are we queuing events and messages correctly? What happens to

75
00:05:25,788 --> 00:05:30,150
events in case of any issues within our applications?

76
00:05:31,690 --> 00:05:35,670
And we're using many different services, and we also often

77
00:05:35,740 --> 00:05:39,370
have third party dependencies and we trust

78
00:05:39,440 --> 00:05:42,890
them to be there. So what happens if they aren't there?

79
00:05:42,960 --> 00:05:46,490
Do we have fallbacks or graceful degradation?

80
00:05:47,390 --> 00:05:51,174
How do we handle if a third party is unavailable?

81
00:05:51,302 --> 00:05:54,926
And these are just some of the potential weaknesses, and there are of

82
00:05:54,948 --> 00:05:58,890
course a lot of others as well. So we want to find these weaknesses,

83
00:05:58,970 --> 00:06:02,930
these unknowns, and fix them. We want to fix them before they break

84
00:06:03,000 --> 00:06:07,010
and create a big outage in our serverless applications.

85
00:06:08,790 --> 00:06:12,414
So what are some techniques then for doing fault

86
00:06:12,462 --> 00:06:16,054
injection on serverless applications? Well, we can start

87
00:06:16,092 --> 00:06:20,230
off with configuration manipulation, some common

88
00:06:20,300 --> 00:06:24,114
faults. There might be throttling for instance, or setting

89
00:06:24,162 --> 00:06:27,850
concurrency limits. We can deny access

90
00:06:27,920 --> 00:06:31,814
to services or other parts

91
00:06:31,862 --> 00:06:36,022
of our application. Basically any type of service configuration

92
00:06:36,086 --> 00:06:39,814
that's available to us is something that we can use to create

93
00:06:39,952 --> 00:06:43,454
fault injection and tools to do this might be

94
00:06:43,572 --> 00:06:47,326
resource policies or using IAM policies to

95
00:06:47,348 --> 00:06:51,530
restrict access. We can use VPC attachments

96
00:06:51,610 --> 00:06:55,186
and so on. Another technique is to

97
00:06:55,208 --> 00:06:58,898
do network manipulation and common faults. There might be,

98
00:06:59,064 --> 00:07:03,678
say TCP packet loss, doing bandwidth limitation,

99
00:07:03,854 --> 00:07:07,810
network latency, or restricting connectivity.

100
00:07:07,970 --> 00:07:12,130
And tools we can use to do that might be security groups,

101
00:07:12,290 --> 00:07:15,522
network access control lists, using network

102
00:07:15,586 --> 00:07:19,702
firewalls, HTTP proxies, Nat instances

103
00:07:19,766 --> 00:07:22,858
and so on. And then we have code

104
00:07:22,944 --> 00:07:26,022
manipulation. So with code manipulation

105
00:07:26,086 --> 00:07:29,242
we can create different type of faults. We can

106
00:07:29,296 --> 00:07:32,826
for instance, create different API responses.

107
00:07:32,938 --> 00:07:37,018
We can do disk exhaustion, we can corrupt

108
00:07:37,114 --> 00:07:40,762
messages in the code. We can create network

109
00:07:40,826 --> 00:07:43,230
latency with code manipulation.

110
00:07:44,230 --> 00:07:48,430
One thing though is that we're missing environment

111
00:07:48,510 --> 00:07:51,954
manipulation, and that is basically because we don't have

112
00:07:51,992 --> 00:07:55,590
access to the environment where we perhaps would have

113
00:07:55,660 --> 00:07:58,840
started if this wasn't a serverless application.

114
00:07:59,850 --> 00:08:03,494
So with that, let's then look at a concrete example.

115
00:08:03,612 --> 00:08:07,394
So very simple, serverless applications on

116
00:08:07,452 --> 00:08:10,826
screen. Right now it is a web service.

117
00:08:10,928 --> 00:08:14,118
We have an API gateway that's fronting a lambda

118
00:08:14,134 --> 00:08:18,534
function that retrieves data from Amazon Dynamodb.

119
00:08:18,662 --> 00:08:22,318
And we also have a queue. So items that are

120
00:08:22,484 --> 00:08:25,838
posted into our API are stored in a

121
00:08:25,844 --> 00:08:29,678
queue and then retrieved by an AWS lambda function

122
00:08:29,764 --> 00:08:33,054
before storing them in a dynamodb table

123
00:08:33,182 --> 00:08:37,262
simple serverless application, but contains several

124
00:08:37,326 --> 00:08:40,674
different services. So what

125
00:08:40,712 --> 00:08:44,334
we can do then on this is we can inject errors

126
00:08:44,382 --> 00:08:48,818
into our code, for instance by creating exceptions

127
00:08:48,914 --> 00:08:52,262
or by using other types of errors. We can

128
00:08:52,316 --> 00:08:55,926
remove downstream services so we don't have access

129
00:08:56,028 --> 00:08:59,062
to a downstream service or a third party API.

130
00:08:59,126 --> 00:09:02,394
For instance, we can alter the concurrency of

131
00:09:02,432 --> 00:09:06,598
our AWS lambda functions, and we can restrict capacity

132
00:09:06,694 --> 00:09:08,010
of tables.

133
00:09:09,550 --> 00:09:13,582
Other examples might be that we can create security

134
00:09:13,716 --> 00:09:17,502
policy errors where we restrict access

135
00:09:17,636 --> 00:09:21,482
to services. We can create course configuration

136
00:09:21,546 --> 00:09:25,762
errors, something that perhaps we struggle with to

137
00:09:25,816 --> 00:09:29,410
get course right. And that is a good example of something

138
00:09:29,480 --> 00:09:32,706
that we might try. What happens in our application if we

139
00:09:32,728 --> 00:09:36,502
have course configuration errors? And once again,

140
00:09:36,556 --> 00:09:40,258
we can basically create any type of service configuration error.

141
00:09:40,434 --> 00:09:44,982
And we can also do manipulation with the disk space available

142
00:09:45,116 --> 00:09:49,500
in our AWS lambda functions, if that is important to us.

143
00:09:50,590 --> 00:09:54,966
And the perhaps most common example of doing chaos engineering

144
00:09:54,998 --> 00:09:58,394
experiments for serverless is to add latency to

145
00:09:58,432 --> 00:10:02,266
our functions. And by using that, by adding latency,

146
00:10:02,378 --> 00:10:05,962
we can simulate a bunch of different failure scenarios. For instance,

147
00:10:06,026 --> 00:10:10,410
it could be runtime or code issues, it could be integration

148
00:10:10,490 --> 00:10:13,634
issues to downstream or upstream services.

149
00:10:13,832 --> 00:10:18,094
It could be to test our timeouts for our AWS

150
00:10:18,142 --> 00:10:21,842
lambda functions. And it can also be to test how our

151
00:10:21,896 --> 00:10:25,810
application behaves in case of cold starts.

152
00:10:28,010 --> 00:10:31,666
So let's then start off by looking at configuration

153
00:10:31,778 --> 00:10:33,960
manipulation to begin with.

154
00:10:35,210 --> 00:10:38,922
So when doing that, we can modify different

155
00:10:38,976 --> 00:10:42,634
types of service configurations and we

156
00:10:42,672 --> 00:10:46,774
can change IAM policies are two good examples.

157
00:10:46,902 --> 00:10:50,694
And to do that, we can use the AWS console

158
00:10:50,742 --> 00:10:54,266
straight away, just make changes there, observe what's

159
00:10:54,298 --> 00:10:57,626
happening, and then change it back. We can use the AWS

160
00:10:57,658 --> 00:11:00,894
CLI, have our companies ready to make a

161
00:11:00,932 --> 00:11:04,018
change to a service or a policy, do that,

162
00:11:04,104 --> 00:11:07,298
observe what's happening, and then roll back with another

163
00:11:07,384 --> 00:11:10,862
command. In the CLI, we can use APIs,

164
00:11:11,006 --> 00:11:14,818
we can use the different sdks to make these changes.

165
00:11:14,984 --> 00:11:18,566
Or of course we can use serverless, serverless serverless AWS fault

166
00:11:18,588 --> 00:11:21,974
injection simulator. Well, and the big reason I

167
00:11:22,012 --> 00:11:25,542
see to use serverless serverless serverless serverless AWS fault injection

168
00:11:25,676 --> 00:11:28,730
simulator. The safeguards that we get with

169
00:11:28,800 --> 00:11:32,566
a managed chaos engineering service and safeguards,

170
00:11:32,598 --> 00:11:36,314
they act as this automated stop button. So it

171
00:11:36,432 --> 00:11:40,186
monitors the blast radius of the experiments that we're running and

172
00:11:40,208 --> 00:11:44,122
modes sure that it is contained, and that failures created

173
00:11:44,186 --> 00:11:47,760
with the experiment are rolled back if alarms go off.

174
00:11:48,130 --> 00:11:51,822
So if we run an alarm instead of

175
00:11:51,876 --> 00:11:55,682
me manually having to observe it and stop it

176
00:11:55,736 --> 00:11:59,694
if alarms go off, or let's say that we've run our experiment

177
00:11:59,742 --> 00:12:03,026
for five minutes and that's the end, we can

178
00:12:03,048 --> 00:12:06,422
then use AWS Fisc to automatically stop and

179
00:12:06,476 --> 00:12:09,000
roll back to the previous state.

180
00:12:10,250 --> 00:12:14,882
So let's look at an example then on configuration manipulation.

181
00:12:15,026 --> 00:12:18,954
So this is the same application that we're using.

182
00:12:19,152 --> 00:12:22,774
What if Sqs invocation of lambda functions

183
00:12:22,822 --> 00:12:26,474
is throttled, so we are pushing a lot of messages to

184
00:12:26,512 --> 00:12:30,574
our SQs queue, but if the lambda function is throttled so

185
00:12:30,612 --> 00:12:34,494
we're not able to pick up those messages, what happens in

186
00:12:34,532 --> 00:12:37,994
our application then? Or what if SQs

187
00:12:38,042 --> 00:12:41,930
invocations of the lambda function is disrupted entirely

188
00:12:42,010 --> 00:12:45,246
so we're not picking up any messages from the queue?

189
00:12:45,438 --> 00:12:49,662
Or another example, what if lambda function loses permission

190
00:12:49,726 --> 00:12:53,794
to the dynamodb table and isn't able to store the

191
00:12:53,832 --> 00:12:57,442
messages that it's picked up from the queue and processed

192
00:12:57,506 --> 00:12:59,320
within the lambda function?

193
00:13:00,650 --> 00:13:04,214
So let me briefly show you an example of how we can

194
00:13:04,252 --> 00:13:07,902
do this type of configuration manipulation

195
00:13:07,986 --> 00:13:09,580
with a quick demo.

196
00:13:11,150 --> 00:13:15,014
So, switching over to the AWS console

197
00:13:15,062 --> 00:13:18,940
in this case and what we're seeing here is an AWS lambda function,

198
00:13:19,710 --> 00:13:23,630
and this is the AWS console. So we have a lot of different

199
00:13:23,780 --> 00:13:27,882
options, configurations and so on. I've switched to the configuration

200
00:13:27,946 --> 00:13:31,502
tab and the concurrency setting, and as you can see

201
00:13:31,556 --> 00:13:35,298
now it's set to the default value nine nine nine.

202
00:13:35,464 --> 00:13:38,674
And in the console I can easily set it to zero,

203
00:13:38,792 --> 00:13:42,130
meaning that the function will be throttled and it

204
00:13:42,200 --> 00:13:46,770
won't be able to run

205
00:13:46,840 --> 00:13:50,166
that AWS lambda function. But I didn't save it.

206
00:13:50,188 --> 00:13:53,126
Now it's still at nine nine nine. Instead, I want to show you how we

207
00:13:53,148 --> 00:13:56,754
can do this using AWS Fis. So I have an experiments

208
00:13:56,802 --> 00:14:00,614
template created in Fis already to update

209
00:14:00,662 --> 00:14:04,394
lambda concurrency, and I'm making use of an

210
00:14:04,432 --> 00:14:08,650
action that's called SSM start automation execution.

211
00:14:09,390 --> 00:14:12,970
And with that we can run SSM

212
00:14:13,050 --> 00:14:16,954
documents. They in turn then contain

213
00:14:17,082 --> 00:14:20,954
different type of automations that we want to do. So I've

214
00:14:21,002 --> 00:14:24,546
defined this document that is created to

215
00:14:24,568 --> 00:14:28,446
be able to then change the concurrency of our AWS lambda

216
00:14:28,478 --> 00:14:32,114
functions. So it has a

217
00:14:32,152 --> 00:14:35,734
first step where it will update the concurrency to whatever we

218
00:14:35,772 --> 00:14:39,670
set it to zero for instance. Then it will sleep

219
00:14:40,170 --> 00:14:43,960
and in the end it will then

220
00:14:44,330 --> 00:14:46,310
do a rollback.

221
00:14:47,290 --> 00:14:51,126
So we can then add these parameters to

222
00:14:51,228 --> 00:14:54,682
our fiscs action to be able to update that

223
00:14:54,736 --> 00:14:58,090
lambda function and have that automated

224
00:14:58,670 --> 00:15:02,398
rollback when the experiment is done or in case

225
00:15:02,484 --> 00:15:06,298
of an alarm. So let's start this experiment

226
00:15:06,394 --> 00:15:12,410
just to see what it looks like the

227
00:15:12,500 --> 00:15:15,730
experiment is initiating.

228
00:15:16,870 --> 00:15:20,146
It is now running. There we go. So it

229
00:15:20,168 --> 00:15:24,782
will now run that SSM automation looking

230
00:15:24,936 --> 00:15:28,054
in the lambda console. It's still at nine, nine nine.

231
00:15:28,172 --> 00:15:34,610
Let's do a refresh and

232
00:15:34,680 --> 00:15:38,820
we can see that the reserved concurrency is now set to zero.

233
00:15:39,270 --> 00:15:43,330
We can also see at the top that this function is throttled

234
00:15:43,410 --> 00:15:47,446
so it will not be invoked as

235
00:15:47,468 --> 00:15:50,726
soon as this experiment is done now. Or if an

236
00:15:50,748 --> 00:15:53,894
alarm sets off it will then do that rollback.

237
00:15:54,022 --> 00:15:57,306
So now we can see it

238
00:15:57,328 --> 00:16:01,226
was a quick 1 minute experiment. It is now rolled back to

239
00:16:01,248 --> 00:16:04,758
the initial state which was 9999.

240
00:16:04,944 --> 00:16:08,602
So that was a very quick example of how we can use AWS,

241
00:16:08,666 --> 00:16:12,474
fis and this very adaptive

242
00:16:12,522 --> 00:16:16,090
way of creating automation to change configuration,

243
00:16:16,170 --> 00:16:21,374
change policies and so on by using the SSM

244
00:16:21,422 --> 00:16:24,846
automation action. Very cool feature that allows

245
00:16:24,878 --> 00:16:27,570
us to do a lot of these experiments.

246
00:16:29,210 --> 00:16:33,030
So let's look at one of the other three then code

247
00:16:33,100 --> 00:16:36,950
manipulation. And this is a favorite of mine.

248
00:16:37,930 --> 00:16:41,858
So there are today two main options for

249
00:16:41,884 --> 00:16:45,274
using fault injection for AWS lambda. There is the

250
00:16:45,312 --> 00:16:48,886
chaos lambda for Python and then failure lambda

251
00:16:48,918 --> 00:16:50,780
for node JS based.

252
00:16:52,430 --> 00:16:55,534
And let's have a look at the node JS one

253
00:16:55,572 --> 00:16:59,722
fault injection with failure lambda. It is an NPM package

254
00:16:59,786 --> 00:17:03,310
that you can use for node JS based lambda functions.

255
00:17:04,130 --> 00:17:07,694
You configure it using parameter store or AWS

256
00:17:07,742 --> 00:17:11,534
app config and it chaos several

257
00:17:11,582 --> 00:17:15,870
different fault modes that you can use. So you can add latency.

258
00:17:16,030 --> 00:17:19,666
You can change the status code for an

259
00:17:19,688 --> 00:17:23,222
API. For instance, instead of returning a 200, you can return

260
00:17:23,276 --> 00:17:26,770
a 404, 502 or whatever you wish.

261
00:17:26,930 --> 00:17:31,138
You can create exceptions within the invocation of the lambda

262
00:17:31,154 --> 00:17:34,554
function. You can add things to the

263
00:17:34,592 --> 00:17:38,662
disk to create disk space faults. You can use deny

264
00:17:38,726 --> 00:17:42,330
list to deny calls to specific URLs.

265
00:17:44,430 --> 00:17:47,918
And what you do is basically you install the

266
00:17:48,004 --> 00:17:51,454
NPM package, then you import it in the lambda function and you

267
00:17:51,492 --> 00:17:55,006
wrap the lambda function handler. So like this,

268
00:17:55,108 --> 00:17:58,786
we then import failure lambda and then we wrap our

269
00:17:58,888 --> 00:18:02,686
handler with failure lambda in this case. And then we're

270
00:18:02,718 --> 00:18:06,862
good to go to be able to add these fault

271
00:18:06,926 --> 00:18:08,900
injection to our lambda function.

272
00:18:09,850 --> 00:18:13,490
And as I mentioned, we control it with a parameter

273
00:18:13,570 --> 00:18:16,790
in basic JSOn? So we set

274
00:18:16,860 --> 00:18:20,450
if it's enabled or not, we set the failure mode,

275
00:18:20,610 --> 00:18:23,994
which type of fault injection we want to do. We set

276
00:18:24,032 --> 00:18:27,446
a rate if it should be on all invocations

277
00:18:27,558 --> 00:18:31,558
or as in this case on 50% of invocations

278
00:18:31,734 --> 00:18:35,374
we can set the latency and so on. Configure each

279
00:18:35,412 --> 00:18:41,758
of these different fault modes and

280
00:18:41,924 --> 00:18:45,802
then let's

281
00:18:45,866 --> 00:18:48,820
look at an example for this as well.

282
00:18:49,350 --> 00:18:53,474
So what if my function takes an extra 300

283
00:18:53,512 --> 00:18:56,882
milliseconds for each invocation? What happens to my

284
00:18:56,936 --> 00:19:00,546
application in those cases? Or what if my

285
00:19:00,568 --> 00:19:03,926
function returns can error code? So instead of returning a

286
00:19:03,948 --> 00:19:07,362
200 response to the API or to the client,

287
00:19:07,506 --> 00:19:10,998
what if it's 404 or a 502 or

288
00:19:11,084 --> 00:19:14,060
301 or whatever error code we want to use?

289
00:19:14,750 --> 00:19:18,490
Or what if I can't get data from dynamodb?

290
00:19:20,030 --> 00:19:23,530
So let's looks at an example of how we can use

291
00:19:23,600 --> 00:19:27,082
this in practice then. So this is a very basic

292
00:19:27,146 --> 00:19:31,278
site used for this example, serverless chaos demo site.

293
00:19:31,444 --> 00:19:34,622
I'm using three functions that are

294
00:19:34,676 --> 00:19:38,386
just copies of each other to be able to easily show the

295
00:19:38,408 --> 00:19:42,580
difference between them. So this

296
00:19:43,270 --> 00:19:46,370
is now running, it is fetching data

297
00:19:46,440 --> 00:19:50,422
from dynamodb to then load a new image. And this

298
00:19:50,476 --> 00:19:55,334
is constantly updating and we can see it's 150

299
00:19:55,452 --> 00:19:58,902
to 200 milliseconds per invocation at the moment.

300
00:19:59,036 --> 00:20:03,340
This is our AWS lambda function for function one.

301
00:20:03,710 --> 00:20:07,750
Just to show you that we are importing failure lambda

302
00:20:07,910 --> 00:20:11,066
and we're wrapping the

303
00:20:11,248 --> 00:20:14,814
lambda handler with failure lambda as well. In this

304
00:20:14,852 --> 00:20:18,782
case then we have a

305
00:20:18,836 --> 00:20:23,134
parameter stored in parameter store which

306
00:20:23,172 --> 00:20:26,414
then contains the configuration for

307
00:20:26,452 --> 00:20:29,460
that specific AWS lambda function.

308
00:20:30,230 --> 00:20:33,746
So it is now set to false so

309
00:20:33,768 --> 00:20:37,620
it isn't enabled. We can

310
00:20:38,070 --> 00:20:41,202
then specify the failure mode, in this case latency,

311
00:20:41,346 --> 00:20:44,738
and we're using a minimum latency of 100 milliseconds

312
00:20:44,754 --> 00:20:48,150
and a maximum latency of 400 milliseconds.

313
00:20:49,050 --> 00:20:52,394
So now to enable this, we simply update this

314
00:20:52,432 --> 00:20:56,218
parameter, set it to

315
00:20:56,304 --> 00:21:00,154
true still with

316
00:21:00,192 --> 00:21:04,220
latency, and then save it.

317
00:21:05,410 --> 00:21:09,310
Now switching back to the site and now

318
00:21:09,380 --> 00:21:11,440
observing function number one.

319
00:21:12,210 --> 00:21:15,870
We can now see that the invocation time for function one

320
00:21:15,940 --> 00:21:18,850
is longer than for function two and three.

321
00:21:19,000 --> 00:21:22,722
So we have added latency to that

322
00:21:22,776 --> 00:21:25,918
AWS lambda function for each invocation.

323
00:21:26,094 --> 00:21:30,134
And this is to be able to test how our application behaves in

324
00:21:30,172 --> 00:21:36,790
case of latency. And looking

325
00:21:36,860 --> 00:21:40,134
in the logs, we can also see that it's showing that

326
00:21:40,172 --> 00:21:44,140
we are adding latency to the invocations as well.

327
00:21:45,790 --> 00:21:49,866
So that's latency fault injection. And as

328
00:21:49,888 --> 00:21:54,134
I mentioned before, we have a bunch of different ways we can or

329
00:21:54,272 --> 00:21:58,142
different things we can test by using latency. So just disabling this

330
00:21:58,196 --> 00:22:02,814
again, updating the parameter saving and

331
00:22:02,852 --> 00:22:06,714
now it should go back and be around 200

332
00:22:06,772 --> 00:22:10,194
milliseconds once again and that seems to be

333
00:22:10,232 --> 00:22:13,922
the case. Cool. So now then let's check

334
00:22:13,976 --> 00:22:17,582
parameter number two. In this case we're

335
00:22:17,646 --> 00:22:22,194
going to use a different failure mode and we're going to use status

336
00:22:22,242 --> 00:22:25,298
code instead to then manipulate

337
00:22:25,394 --> 00:22:29,014
what status code is returned from our API and in this case

338
00:22:29,052 --> 00:22:33,462
it's set to 404. So instead of returning 200,

339
00:22:33,516 --> 00:22:37,514
we're returning 404 and I'm setting a rate of 0.5,

340
00:22:37,632 --> 00:22:41,530
meaning that it will return a 404 on about half

341
00:22:41,600 --> 00:22:45,374
of the invocations, saving that,

342
00:22:45,492 --> 00:22:49,006
switching back to the site and we

343
00:22:49,028 --> 00:22:53,358
can see functions two, we're getting 200

344
00:22:53,444 --> 00:22:58,260
right now. We are getting 200

345
00:23:00,950 --> 00:23:04,418
and still 200. Come on. There we go,

346
00:23:04,584 --> 00:23:08,290
we got an error on one invocation we get an error again,

347
00:23:08,360 --> 00:23:12,082
meaning that it's unable to get the response

348
00:23:12,146 --> 00:23:15,446
from Dynamodb, basically getting a URL for

349
00:23:15,468 --> 00:23:18,230
a new image so it can't load a new image.

350
00:23:19,690 --> 00:23:23,702
So by using this fault injection method,

351
00:23:23,766 --> 00:23:29,942
we're able to then simulate what happens if we have responses

352
00:23:30,006 --> 00:23:34,162
that aren't 200 or okay from our APIs,

353
00:23:34,326 --> 00:23:38,080
changing it back and it should now load a new

354
00:23:38,610 --> 00:23:41,918
image on each invocation, which seems to

355
00:23:41,924 --> 00:23:45,918
be the case. Right, let's check

356
00:23:46,004 --> 00:23:49,220
failure lambda parameter number three then,

357
00:23:50,550 --> 00:23:54,290
and updating this one I am

358
00:23:54,360 --> 00:23:57,810
going to use a different failure mode. In this case we're going to use

359
00:23:57,880 --> 00:24:02,118
deny list and

360
00:24:02,204 --> 00:24:05,638
with the deny list we're able to add then which

361
00:24:05,724 --> 00:24:08,934
calls to deny. In this case we're denying to s

362
00:24:08,972 --> 00:24:12,202
three and to dynamodb. But this could be any

363
00:24:12,256 --> 00:24:14,540
third party dependency as well.

364
00:24:15,230 --> 00:24:18,778
Setting it to true, and if you remember

365
00:24:18,864 --> 00:24:22,426
the architecture we looked at, we have a dynamodb as a

366
00:24:22,448 --> 00:24:26,174
downstream dependency, meaning that our

367
00:24:26,212 --> 00:24:30,042
lambda function should now not be able to fetch

368
00:24:30,106 --> 00:24:33,374
data from dynamodb. For function number three,

369
00:24:33,492 --> 00:24:37,826
we can see that function one, function two, they are continuing to

370
00:24:37,928 --> 00:24:41,602
update, but function three is

371
00:24:41,656 --> 00:24:45,090
throwing an error and isn't loading new images.

372
00:24:45,590 --> 00:24:49,486
So once again we can see what happens when we are

373
00:24:49,608 --> 00:24:53,240
injecting that type of fault into our application.

374
00:24:54,890 --> 00:24:58,454
So that was very manual. So let's have a look

375
00:24:58,492 --> 00:25:01,966
at how we can do this using AWS fault injection

376
00:25:02,018 --> 00:25:06,342
instead and make use of those safeguards and automatic

377
00:25:06,406 --> 00:25:10,134
rollback that I talked about. So creating a new experiments

378
00:25:10,182 --> 00:25:14,194
template, choosing a role to be able to run this experiment,

379
00:25:14,342 --> 00:25:19,470
I'm now adding an action and

380
00:25:19,620 --> 00:25:23,562
let's give that a name, lambda fault

381
00:25:23,626 --> 00:25:26,890
injection and selecting the action type.

382
00:25:26,980 --> 00:25:30,866
And we used the automation execution in

383
00:25:30,888 --> 00:25:34,546
the previous example that I showed you using fis. And we can

384
00:25:34,568 --> 00:25:38,638
use this here as well to set a document

385
00:25:38,734 --> 00:25:42,674
and a document that is then meant to update

386
00:25:42,722 --> 00:25:46,514
parameters in parameter store. So we have one document created

387
00:25:46,562 --> 00:25:48,600
for this that you can simply use.

388
00:25:50,410 --> 00:25:53,466
So then you just define what's needed.

389
00:25:53,568 --> 00:25:57,174
That is the new parameter and the rollback

390
00:25:57,222 --> 00:25:58,090
parameter.

391
00:26:00,510 --> 00:26:04,042
And that's fine and dandy, that works, that's very

392
00:26:04,096 --> 00:26:08,074
cool. And you can use that straight

393
00:26:08,122 --> 00:26:12,160
away to do different types of experiments against parameter store.

394
00:26:15,250 --> 00:26:18,866
Now switching back to fis. I want

395
00:26:18,888 --> 00:26:22,242
to show you something that we're say

396
00:26:22,296 --> 00:26:26,434
playing with right now, because we're seeing customers using

397
00:26:26,552 --> 00:26:29,982
parameters a bit. So we are using an experiment

398
00:26:30,046 --> 00:26:33,914
ourselves with an action type that basically is put parameters

399
00:26:33,982 --> 00:26:37,606
to see if that might be something that customers want to

400
00:26:37,628 --> 00:26:41,640
use. So I'm selecting this action type

401
00:26:41,950 --> 00:26:46,060
put parameter. I will then add

402
00:26:47,310 --> 00:26:51,660
duration for the experiment or for the action at two minutes.

403
00:26:52,270 --> 00:26:56,094
Then I need to give a name to the

404
00:26:56,132 --> 00:26:59,482
parameter to update. So let's

405
00:26:59,546 --> 00:27:03,002
copy the name of failure lambda parameter

406
00:27:03,066 --> 00:27:06,606
two. And now you can

407
00:27:06,628 --> 00:27:10,514
see that I am supposed to add a value and

408
00:27:10,552 --> 00:27:14,418
a rollback value, and the value in this case is

409
00:27:14,584 --> 00:27:18,322
the value that will be put into

410
00:27:18,376 --> 00:27:21,862
parameter store. So I'm copying it from

411
00:27:21,916 --> 00:27:25,110
our existing parameter,

412
00:27:27,370 --> 00:27:30,966
switching so that it's true, meaning that when the

413
00:27:30,988 --> 00:27:34,806
experiment starts, it's going to enable the experiment.

414
00:27:34,998 --> 00:27:38,650
We're going to use status code as the failure mode,

415
00:27:39,230 --> 00:27:43,450
keep it at rate 0.5 so 50% of invocations,

416
00:27:44,190 --> 00:27:47,934
and finally keep using 404 as

417
00:27:47,972 --> 00:27:51,774
a status code. Then we have the rollback value and that's the

418
00:27:51,812 --> 00:27:55,562
value of the parameter. When the experiment stops,

419
00:27:55,706 --> 00:27:59,620
either by the duration is over or by

420
00:28:00,550 --> 00:28:04,466
stop condition. So saving

421
00:28:04,568 --> 00:28:08,494
that we don't define a target

422
00:28:08,622 --> 00:28:11,894
because the target in this case is defined through the

423
00:28:11,932 --> 00:28:15,510
parameter instead creating my experiment template,

424
00:28:21,280 --> 00:28:24,130
I can start it,

425
00:28:28,270 --> 00:28:35,092
start the experiment and

426
00:28:35,146 --> 00:28:37,430
we can see that it is running.

427
00:28:38,920 --> 00:28:42,244
So, meaning that if we now switch

428
00:28:42,292 --> 00:28:45,752
to our parameter and refresh that we can see

429
00:28:45,806 --> 00:28:48,650
that it is set to be enabled now.

430
00:28:51,020 --> 00:28:54,332
So now the experiment is running. Switching over to

431
00:28:54,386 --> 00:28:57,852
the demo site, we can see that the function number two

432
00:28:57,906 --> 00:29:01,388
is giving us an error because it is

433
00:29:01,554 --> 00:29:08,770
getting a 404 response in return and

434
00:29:09,380 --> 00:29:13,456
200 response 404

435
00:29:13,558 --> 00:29:17,056
so about 50% of invocations. Let's check the

436
00:29:17,078 --> 00:29:21,028
experiment in FIS. It is now completed and

437
00:29:21,114 --> 00:29:24,692
with it being completed we should now have a rollback of our

438
00:29:24,746 --> 00:29:29,908
parameter. So let's take a look at the

439
00:29:29,994 --> 00:29:37,024
parameter in parameter store and

440
00:29:37,062 --> 00:29:41,780
we can see that it is set to disenabled false, so disabled

441
00:29:42,200 --> 00:29:45,776
and functions number two is returning. 200 responses.

442
00:29:45,968 --> 00:29:49,892
Very cool. So that's an example of how we can use AWS

443
00:29:49,956 --> 00:29:53,850
fis to once again automate use these

444
00:29:54,780 --> 00:29:58,520
experiments in a safer way. I want to show you one last thing

445
00:29:58,590 --> 00:30:02,284
with this. I've talked about stop conditions, but haven't really

446
00:30:02,322 --> 00:30:06,220
used any. So let's add a stop condition to this experiment.

447
00:30:07,360 --> 00:30:11,580
I'm going to use demo one that I have my fist demo alarm.

448
00:30:11,920 --> 00:30:15,520
Saving that and we can now

449
00:30:15,670 --> 00:30:19,056
switch over to Cloudwatch. And this is the

450
00:30:19,078 --> 00:30:22,704
alarm in question. So as you can see, it is right now

451
00:30:22,742 --> 00:30:26,432
in the ok state, meaning that no alarm

452
00:30:26,496 --> 00:30:29,636
is setting up right now. Starting the

453
00:30:29,658 --> 00:30:32,230
experiments, the same experiment. Once again,

454
00:30:34,200 --> 00:30:38,376
with the experiment started, the parameter is

455
00:30:38,478 --> 00:30:39,640
being updated.

456
00:30:43,940 --> 00:30:46,480
Double checking. Yes, it's updated.

457
00:30:47,940 --> 00:30:49,680
And with that updated,

458
00:30:50,660 --> 00:30:53,716
we will now have four

459
00:30:53,738 --> 00:30:57,812
or four responses every now and then on function number two. About 50%

460
00:30:57,866 --> 00:31:00,550
of invocations seems to work.

461
00:31:02,120 --> 00:31:06,168
So let's now then try to use this stop

462
00:31:06,254 --> 00:31:09,080
condition. What if an alarm sets off?

463
00:31:09,230 --> 00:31:13,128
So instead of actually making sure that something

464
00:31:13,214 --> 00:31:16,956
sets off, we can use the CLI to set the alarm state for

465
00:31:16,978 --> 00:31:20,590
my specific alarm into the alarm state.

466
00:31:22,080 --> 00:31:24,460
So doing that, using that command,

467
00:31:25,680 --> 00:31:29,404
switching back to Cloudwatch, we can see that it is now in

468
00:31:29,442 --> 00:31:33,052
alarm state. And AWS, soon as that alarm

469
00:31:33,116 --> 00:31:36,892
moves into the alarm state, we can see that AWS FIS

470
00:31:36,956 --> 00:31:40,352
is stopping the experiments. Since that was our stop

471
00:31:40,406 --> 00:31:44,148
condition, a safeguard, it is halted by a

472
00:31:44,154 --> 00:31:47,380
stop condition, and that

473
00:31:47,450 --> 00:31:50,740
also then means that it will use the rollback behavior

474
00:31:51,160 --> 00:31:53,060
update, our parameter.

475
00:31:53,820 --> 00:31:57,560
Refreshing to make sure, yes, it is now

476
00:31:57,630 --> 00:32:01,944
disabled. The experiment and

477
00:32:02,142 --> 00:32:06,084
our demo site should now be back to normal

478
00:32:06,212 --> 00:32:09,790
and returning 200 responses once more.

479
00:32:10,400 --> 00:32:14,332
So that was an example of how we can use AWS FIS to

480
00:32:14,386 --> 00:32:18,504
first off do these experiments updating a parameter.

481
00:32:18,552 --> 00:32:21,856
And I showed you something that we

482
00:32:21,878 --> 00:32:25,504
are experimenting with a new action type where

483
00:32:25,542 --> 00:32:29,084
we put a parameter straight into parameter

484
00:32:29,132 --> 00:32:33,620
store, but you can all do it right now using SSM automation.

485
00:32:34,120 --> 00:32:36,710
The document is available for use.

486
00:32:37,160 --> 00:32:42,516
All right, so then I

487
00:32:42,538 --> 00:32:46,600
want to do a bit of a summary recap of what we've looked

488
00:32:46,670 --> 00:32:49,784
at. First off,

489
00:32:49,822 --> 00:32:53,652
the chaos engineering part is the same no matter if it's serverless

490
00:32:53,716 --> 00:32:56,250
or if it's say, server full.

491
00:32:56,640 --> 00:33:00,780
To find the hypothesis for your serverless application,

492
00:33:00,930 --> 00:33:04,460
use those what ifs that we asked earlier on.

493
00:33:04,610 --> 00:33:08,552
What if a downstream service is unavailable? What if latency

494
00:33:08,616 --> 00:33:12,050
is added and then create a hypothesis around that?

495
00:33:12,420 --> 00:33:16,364
And when you're doing the experiments, make use of both configuration

496
00:33:16,492 --> 00:33:20,512
network and code manipulation. We looked at examples for

497
00:33:20,566 --> 00:33:24,180
configuration and code manipulation in this session,

498
00:33:24,520 --> 00:33:28,320
and then try to use safeguards and automatic rollback

499
00:33:28,400 --> 00:33:32,164
so you don't have to be responsible for actually running a

500
00:33:32,282 --> 00:33:35,972
command to rollback or changing configuration

501
00:33:36,036 --> 00:33:39,860
in a console to be able to use that rollback

502
00:33:39,940 --> 00:33:43,368
behavior. And if you want

503
00:33:43,374 --> 00:33:46,548
to have more chaos engineering for serverless,

504
00:33:46,644 --> 00:33:50,440
just scan the QR code shown on screen right now,

505
00:33:50,510 --> 00:33:54,356
or go to grosh serverless chaos

506
00:33:54,468 --> 00:33:57,320
for more links, examples, demos,

507
00:33:58,060 --> 00:34:02,160
all gather in one place. And with that,

508
00:34:02,310 --> 00:34:06,176
I want to thank you for joining this session. Happy to

509
00:34:06,198 --> 00:34:09,456
be here at Conf 42 chaos Engineering. My name

510
00:34:09,478 --> 00:34:13,296
is Gunnar Grosch, developer advocate at AWS. If you

511
00:34:13,318 --> 00:34:17,024
want to contact me, I'm available on Twitter as shown on screen,

512
00:34:17,142 --> 00:34:20,416
and LinkedIn, of course. Happy to connect. Thank you

513
00:34:20,438 --> 00:34:20,910
all for watching.

