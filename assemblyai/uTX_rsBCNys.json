{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/ea7fa6ed-1474-48c1-a9bd-a044da9c024e", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["applications", "be", "best", "bet", "but", "buzzwords", "can", "cloud", "cloud native ready", "cloudnative", "code", "complex", "conf fourty two", "containers", "demands", "developer advocate", "elder moraes", "java", "java code", "kubernetes", "lifecycle", "microprofile", "quarkus", "red hat", "scalability", "technologies", "those", "train", "turn", "updates"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "id": "a12f8507-49bb-4216-ae07-6e077f0f0a76", "status": "completed", "error": null, "text": "Two cloud native I'm very happy to be with you today to share some knowledge, some content, some news about Java in the cloud native world. My name is Audrey Morice. I work for Red Hat. And today I will give you the session, your Java code called native. Ready? A live experience. And why live experience? Because everything that I'm going to show you starting from now, it's based on live coding sessions and live coding. Okay, so I will start by showing a demo. So it's demo time right now. Okay, I will switch here to my terminal and I will move here to my blue green. Yes. And here OC project Blue Green Canary. Let me explain a little bit before it starts. Let me also increase the size of my phone. Okay, great. What I'm going to do right now, well, we are talking here about cloud native applications. When we think about cloud native applications, we hope, we expect that this application has some features. Like for example, what I'm going to show right now, it's what we call servicing mesh features. What is servicing mesh? It's a layer that you can have on top of your application that will manage, that will handle all the traffic in order to provide your application the security that it needs, the cloud balancing, the traffic management and other stuff. Okay, so this demo that I'm going to show you right now, it's for this matter, okay, so this is what we call blue green deployment. So I will open here, here it is my demo. So if you pay attention, you will see that my screen is switching between blue and green. So this is the same application with two different versions. One version is a blue version and the other version is a green version. If I check here my kubernetes, we will see that I have, so I have here the blue version of my application and the green version of my application. Okay. So of course I have a cloud balancing working in this application. And each request to the application, the load balancing is switching between green version and blue version. Okay. All right, so what I'm going to do right now is to add a new version for this application, a Canary version. What I'm going to do is right now I will deploy the deploy here the version canary. Just to explain why we wait a little bit. I have here tons of scripts as you just saw, because it will make my life easier in order to show this demo to you. You can see that the Canary version is already working. We will see it on those browser a little bit. Okay. It's already working. So I have all those scripts just to make my life easier of course, when you are working in production, you will also build your own scripts to make your life easier. But basically what I will do in this few minutes showing this demo is switching my yaml files in order to manage the traffic and the route to my application. Okay, so great. Here I have my application working with three versions right now. So I have one version that is blue, one version that is green, one version that is yellow, the Canary version, and my load balancer is load balancing the request between those three versions of the application. Great, awesome. Right now let's play with the traffic to this applications. So I will check my scripts here. So now let's switch the traffic only to blue version. Wait some seconds to this. Okay, now it's done. Let's wait. And now we have just the blue version of the application being considered by the load balancing. Okay, so now just the blue version. Now let's switch to green version. Wait a few seconds to switch to green and stick with the green version. And now we will switch to yellow version, canary. And now we have just the anery version. Again, what does it have to do with cloud native? One of the main aspects of cloud native application is that you should be able to make some changes, this is the right word for this, without downtime to your application. So you can see that I made three changes on the routes to my application, the traffic to my application without downtime. Okay, so the users are still accessing my application and there is no downtime. Right. Let's try something else. Where are you? Great. So now, as you can see here, I'm using a chrome browser. So what I'm going to do right now is to change. I will make the chrome users will stick with the green version and the Firefox users will stick with canary version. So we'll change here, the Canary to Firefox, and let's open a Firefox window here. Just a second. Great. So, demo. Okay, so everything is working? Yes, it's working. So we are using here Firefox. Firefox is sticking with the Canary version and the chrome is sticking with the green version. Right. Great. I have some other options here, if I show you, but as we have some limits of time here, I could, for example, move everything that everyone that is working with Android to the Canary version and everything else. Every other users stick with green. And here just with iPhone, and here just with everyone that's using mobile. Okay, so by having this kind of approach on your architecture and your application being built using this approach, you can have all these options and this is a very simple example, but just to give you those kind of possibilities that you have. Cloud native approach when building your application. Okay, just for starting right now, I will show you much more code in a few minutes. But here, this is our first example here, this application is a Java application using cloud native approach. Good, let's switch to slides again. So this was our first demo and just for you to know me, if you haven't, my name is Elder Moraes, I work here for Red Hat as a developer advocate here. I'm in Brazil, I'm brazilian based in Sao Paulo. This is a QR code for my mailing list and also the URL if you would like to receive some content, but Java cloud native microservice containers kubernetes I share in this list. Okay, so just subscribe, I will not send you any spam. Okay. I'm a board member also at Java, one of the biggest Java user groups in the world, and I'm also the author of the Jakarta e cookbook and I'm very happy with this book because in the first 24 hours it reached the top one on Amazon United States. So it's a great book. If you work with Java on enterprise environment, maybe my book would be helpful for you. And also my mission here as not only a red hat but as a professional is to help Java developers around those world to build and deliver awesome applications, right? So our cloud native application today we have some stuff. So basically I will use microservice approach, that's one of the fundamentals of cloud native application. Not that you have to use microservice but you should use because some features that I will show you in a few seconds. Also I will use rest client, I will use health Shack because your application will run on some orchestrated environment and by that it should have some health shack possibilities for your orchestration being able to manage your application. Also we will work with metrics for scalability, we will use reactive both with mutiny and kafka, and also we will deploy our application using containers and kubernetes. Okay, and let's move to code time starting from now we will not see any slides anymore. Okay, just one last slide in the end of the session. Amazing. Let's change some stuff here. I will move here, check if, okay, so let's forgot the dash. Perfect. And also I will switch my namespace to this one. If you don't know what I'm doing here, I'm connected to a Kubernetes cluster that is hosted on the cloud, in this case on AWS. So I'm really working in a Kubernetes here so let me just check this namespace is clean so we are able to move on. Okay, no resources, so all good here. Okay so I will build a Java application from scratch and you will keep adding some features to help this application to work with the best approaches, best practice when we talk about cloud native application, cloud native word cloud native approach and whatever you name it. I will build a Java application using Quarkus. Why Quarkus? Because Quarkus will give me a lot of productivity. I have a lot of extensions, Quarkus extensions that will make my life much more easier when building this cloud native application here today. All right so I will just open not a comma let's say. Okay, all good. So it will open my virtual visual studio code and I will use can integration with maven and there is a feature in this plugin called developer mode. So by using mVN Quarkus dev, what it will do right now is to compile my application to bootstrap this application. So this application will keep running and every change that I do in this application will be hot deployed. Okay so once I call this application, all the changes will reflect on my application, right? So this application started in 1 second. It's great, especially for a Java application. Okay so let me tweak my here and switch to this. Okay oh good. So let me show you. Oh good, great. I will remove the best folder. Don't do that. Right? I will just do that for those sake of the time here while we are working on this demo. But you should not remove the best, right? Okay guys, what am I going to do right now is to start building this application. As you said, we have a base project built when we created this project using Quarkus. I have even a rest endpoint ready right here. So I'll call here. Okay as easy I can change here to hello and I change this application. And this application was hot, deployed in 600 milesconds. Okay so this is very fast. Okay guys let's build this application because we are really excited here today. We'll start by adding some data management in this application. So by data we'll add some extensions. So first we will add extensions to work with data. So JSoNB, JGBC and hibernate to work with panache. That is the default data management for. Okay so let's start building our classes. First we will add some configurations, blah blah blah blah. I will not deep dive in too much details. My intention here is to give you a bigger picture of this because it would take hours to explain every single bit that I'm showing you right now. But I will give you a whole picture of all the possibilities that we have with Java in the cloud native world today, especially when working with quarkus, I will build this, it will be my entity. So this first application I will build here will manage fruits, okay so I have here first my entity for fruits and I will build my rest endpoint here, my resource, the fruit resource and it will have a wheel list of course the fruits. So if I go right now on my terminal and using this guy, okay so change detected, 1.5 seconds to do it hot deploy. Of course my data, my database, it's empty. And let's right now add a new method here to add a new fruit. Okay so I just created this method here, I will call this, I will call this new method by not hot deploying application because it will do for me in 475 seconds. And now I have a banana in my database, okay but I would like to do something more scalability. So I will add a new file to this folder here which will be a import SQl and add some new fruits to my database and it will call train. Okay I still have a banana. Sometimes I need to redeploy. The good part even if I need to redeploy is that quarkus will do it really fast. Okay so how many? 2 seconds, 2.7 seconds. Okay so not anything at all. Okay so now I have a lot of data in my database, what I'm going to do right now is to add a custom finder, okay so because if you paid attention here I'm using a list all that is from my entity, okay so I will add a new finder here, that is my finder where I will pass a season and will list fruits based on those season. So right now we just change our rest endpoint to be able to use this new parameter, okay so I have a new parameter here where I will use to list by season and I can again run this call here but for example using summer and now I have just the fruits that is based on summer. Now we are good to take this application and deploy on those cloud deploy on my kubernetes cluster. So what we're going to do right now is to add a new extension, two extensions, one is quarkus kubernetes and the other is quarkus Container image, okay so one will build the container image and the other one we should deploy on the Kubernetes. Okay so we add some new properties for this application. So let's switch here. Okay I will make some changes. This one will be docker I o. This one will be elder price. Let's remove these spaces because YML will not work with spaces. And right now how can I take this application and create a containers image and deploy it into the cloud. It's very, very simple. MvN clean package. Okay we'll package those application but I will pass one parameter, quarkus kubernetes deploy equals true. Oh I forgot something. Stop. I need to log on my docker registry. Okay great, now we are good to go. So right now it will package the application, will build the container image and will deploy this application on my kubernetes cluster if you don't have any mistakes. All right, bet me check here. This is the beauty of the live coding session. We are able to debug the applications. I need to add one guy here to trust on the certified certification. Now I hope we will work. All right. Okay guys, this is the real life, on your daily basis you will face this kind of. Yeah, now we are going. Okay guys, so it's basically building the image and we'll start the process of pushing this container image on my kubernetes. Okay, so let's watch QBctl get bots. Yes. Okay so my application is already running. Okay. It's really fast because Quarkus starts really fast. How can we access this application? I have a service, let's see the DNS of those application. Is this guy here. And by experience I know that we take like one to two minutes to really respond. Okay but let's check curl those guy. Hello. Oh it's working. Wow, it was really, really fast. Today I change here to fruit. Fruit, wow it's there, it's working. Okay, so sometimes it takes like one to two minutes but today we were looking, it's already working. So I took this application I just created on my machine and deployed on the cloud. Okay of course we are not done. We still have a lot of stuff to do here and let's go forward. Right now what we are going to do is to add some new features to those application. So first I will add another extension, the rest client extension and we have fruits here, but we have just the name and the season. I would like to add some data to these fruits and I will do that by using an external service. So I will connect to this external service using a rest client. I add the extension and we'll create some other classes here. So I will create another class here to work with. This is the fruit device. The name of the service that I will use, it is called fruit device. I will create another interface that will be my interface between my local applications and the remote. Okay so basically this is the API, it's an interface, this is the path and this is the method that I will call on this remote application. I will add the address of this application is this guy here? Okay you can check afterwards online. Printvice.com is where I will get the data that I need to improve my application. I will create adto java, blah blah blah. As I said, I will not deep dive into too much details to save time and show you much more stuff than going too much details. And now I will change my fruity resource in order to use our new rest client. Okay so now we are using the fruit device to add some new data to our fruits. So let's fall again our application. So again using summer detected some changes 1.2 seconds and now I not only have the fruit name and the season but I also have carbohydrates and calories. These two guys here are coming from the fruit device. So by using my rest client I'm able to connect with remote applications and get some data and add to my local application. Great. So moving on. Now I'm adding some health shack features to my application. And why I'm going to do that because as I said in the beginning of the talk, when our application is hosted on can orchestrated environment the orchestrator should be able to look to our application know two stuff. One, your application is live and two, your application is ready because if it's not live it will queue the application and create it again and it's not ready. It will wait until it's ready. So your application should be able to provide this kind of information to the orchestrator. And here we are using kubernetes. So that's how Kubernetes will manage the application. I just added the extension for health shack those this application and one cool stuff I will even open on my browser, better picture of this, if I just call here health it will give me the information because by just adding the extensions it add the feature to the application. So I didn't need to code anything but I will because I would like to customize this health shack feature. So I will create two probes, one liveness probe and one redness probe. So let's create them. So liveness probe and those liveness probe will just say well I'm alive, says nothing is not live. Okay. But if it's working, it will just respond. This guy here and here you can customize I'm live c 42 for example. And the other guy is the redness probe. The redness, it's where probably you will add some rules, some more complexity because it's what is ready for your application. It could be to be able to access some database, it could be to be able to access some other service. So until you are able to check this, you will not respond as I'm ready. Okay, but in this case we are just building a custom example here. And if I just call this guy again now I have the specific responses both from the liveness and from the redness. Okay good. So we are now our application is connecting with remote applications. It's giving health check responses. Now let's add some metrics. Here we add the quarkus micrometer. Quarkus has integration with also the microprofile, but those default today is micrometer for Quarkus but it still have support for microprofile metrics. But here today I will show you using micrometer. Here's the only one that I need to change the pond file. So I will let me this guy, okay, I will create a specific class to show you how to use the metrics. Let's go here new file Java. And here is my timely resource. So basically here it will work by using annotation. So I define it that this method here is being counted. Okay, so the metric that we use here is counted and the name of this metric is time. Now this guy here I will use by this way. Great. Let's compile this application. We're not compiled, just call. Okay, let's see if it will work without, okay great. So took 1.4 seconds to auto deploy the application. And here we'll call a few times just to have some data. And right now I will open as we did with the help we can did with metrics. So just use here metrics, voila. Here time. So here we have that metric that we created and we know here that we call it 30 times and we have some other information. Basically it's just a counted metric. So it's just counting. Okay, so here you know where it is, deception and so on. Now the two last parts of this session, we will start working with reactive features. So let's add an extension for rest easy mutiny that we will use right now. We will move away from the fruits and we'll dive into beer. So our application will start working with beer. We'll create here a beer class that will be our kind of entity. So I have here, actually it's a pojo. Okay, it's not an entity, but that's fine. Let's create now a beer service. Beer service that is our best client for this service will work with beer. We will add again another address for this guy. It's not roots anymore, now it's API, punk API. And we'll create a resource, blah blah blah java. So this is our service. And pay attention that as we work with reactive using the mutiny extension, the producers keep doing the application JSon. But here on the method, the return is a mute, okay? That's the kind of return using by mutiny. Okay? All right. If everything is working, we should be able right now to call our application. So let's call here, let me try again. If not, we will sometimes took some time to connect to the revolt application to get the data. But if not, we will just redeploy. All right? Yes. Now we have this beautiful list of beer. I love beer. Okay, so if you love beer as well, maybe you know what I'm talking about. So we have those remote service. But right now I'm using a reactive approach to gather all this data. And the last part, now we are almost done here. We will keep doing reactive approach, but right now using reactive streams with Kafka. So let's add a Kafka extension here. Okay, good. And this application, now we work it in this session with fruits, then with beer, now with wine. I do love wine as well. So let's work with some wine here. But boom. We already also have a audio. This new application we will work off with prices of the wine. So let's create a priced wine class, okay? And we will create, we not have a database of course, but we will create a class called here wine generator that will help us to guess what generate wines. Okay, we will create a resource that will be our endpoint. So, and this guy here, okay, so we have here the channel that we will connect on the kafka that is priced wine. The return is also a mutey as we saw on the last example. And we will bet the information that are priced wines. Okay, for doing that, we will also need, guess what? A Kafka. Okay, so we will add some new properties here. I will create a docker compose file to spin up a kafka on my machine, my local machine here. So basically we create this docker compose. Let's edit this file and I will red hat we need here. Okay, let me see basically those example we work with Kafka zookeeper and a price generator service that I just created here. So I will restart this application, I will split this guy here compose app. Okay, so this will spin up a Kafka on my machine. I hope everyone is connected right now and let's try it. I will call this new service and voila. I'm using a wine generator to populate my kafka and getting a list of wine with prices. All right, good. So well, we did it. We made it. Okay guys, I'm really help when things just work. This was our call time so I would like to end just sharing with you those QR code and this URL from developers Redhead.com, our red hat developers program where we share a lot of content about Java containers, microservice, kubernetes, all the cloud native related stuff you can just describe and we will send to you when we have news about it. Okay, so in the portal there are a lot of content, all free, all open source. Because everything that we did, everything that we do on red hat is open source. Okay? So we are very happy to share all those with you and just to say goodbye to you. I'm really happy that you shared your time with me in these few minutes in this session. I hope you enjoyed and you have here my twitter. Okay, so you can reach me on Twitter. If you have any questions, any comments, just please share with me. I will be very happy to talk to you. See you next time. Have a great confidence and bye.", "words": [], "utterances": null, "confidence": 0.930151290249429, "audio_duration": 2228.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Audrey Morice will give you the session, your Java code called native. Everything that I'm going to show you starting from now, is based on live coding sessions and live coding.\n- OC project Blue Green Canary is a demonstration of cloud native applications. It's a layer that you can have on top of your application that will handle all the traffic. One of the main aspects of cloud. native application is that you should be able to make changes without downtime.\n- Elder Moraes is a developer advocate for Red Hat. He uses Java cloud native microservice containers kubernetes. He is also the author of the Jakarta e cookbook. His mission is to help Java developers build and deliver awesome applications.\n- I'm connected to a Kubernetes cluster that is hosted on the cloud, in this case on AWS. Let me just check this namespace is clean so we are able to move on. Amazing.\n- A Java application using Quarkus will give me a lot of productivity. Every change that I do in this application will be hot deployed. My intention here is to give you a bigger picture of all the possibilities that we have with Java in the cloud native world.\n- Today I change here to fruit. Fruit, wow it's there, it's working. And now I will change my fruity resource in order to use our new rest client. As I said, I will not deep dive into too much details to save time and show you much more stuff.\n- Using rest client I'm able to connect with remote applications and get some data. Now I'm adding some health shack features to my application. Now let's add some metrics. Here we add the quarkus micrometer. Let's see if it will work without.\n- We will work with fruits, then with beer, now with wine. We will keep doing reactive approach, but right now using reactive streams with Kafka. If everything is working, we should be able right now to call our application. If not, we will sometimes took some time to connect to the revolt application.\n- This was our call time so I would like to end just sharing with you those QR code and this URL from developers Redhead. com. We share a lot of content about Java containers, microservice, kubernetes. All free, all open source. See you next time.", "auto_highlights_result": {"status": "success", "results": [{"count": 5, "rank": 0.09, "text": "cloud native application", "timestamps": [{"start": 336652, "end": 337794}, {"start": 554356, "end": 555358}, {"start": 562900, "end": 564142}, {"start": 673974, "end": 675536}, {"start": 698606, "end": 699688}]}, {"count": 2, "rank": 0.09, "text": "remote applications", "timestamps": [{"start": 1479722, "end": 1480848}, {"start": 1644190, "end": 1645332}]}, {"count": 1, "rank": 0.09, "text": "awesome applications", "timestamps": [{"start": 551754, "end": 552922}]}, {"count": 1, "rank": 0.07, "text": "Java cloud native microservice containers", "timestamps": [{"start": 507316, "end": 509722}]}, {"count": 3, "rank": 0.06, "text": "cloud native approach", "timestamps": [{"start": 461988, "end": 463726}, {"start": 477724, "end": 479442}, {"start": 676950, "end": 678156}]}, {"count": 4, "rank": 0.05, "text": "Java application", "timestamps": [{"start": 476348, "end": 477062}, {"start": 661026, "end": 662028}, {"start": 682600, "end": 683348}, {"start": 756258, "end": 757070}]}, {"count": 1, "rank": 0.05, "text": "new application", "timestamps": [{"start": 1999566, "end": 2000264}]}, {"count": 7, "rank": 0.05, "text": "green version", "timestamps": [{"start": 167528, "end": 168222}, {"start": 178988, "end": 179762}, {"start": 192032, "end": 192902}, {"start": 314788, "end": 316058}, {"start": 321128, "end": 322014}, {"start": 381516, "end": 382594}, {"start": 413384, "end": 414270}]}, {"count": 1, "rank": 0.05, "text": "not hot deploying application", "timestamps": [{"start": 970386, "end": 972016}]}, {"count": 1, "rank": 0.05, "text": "Java containers", "timestamps": [{"start": 2179436, "end": 2180386}]}, {"count": 6, "rank": 0.05, "text": "blue version", "timestamps": [{"start": 165224, "end": 165950}, {"start": 176716, "end": 177394}, {"start": 193232, "end": 193990}, {"start": 296432, "end": 297766}, {"start": 305092, "end": 305882}, {"start": 311972, "end": 312906}]}, {"count": 1, "rank": 0.05, "text": "cloud native word cloud native approach", "timestamps": [{"start": 675638, "end": 678156}]}, {"count": 1, "rank": 0.05, "text": "local applications", "timestamps": [{"start": 1382254, "end": 1383290}]}, {"count": 1, "rank": 0.05, "text": "first application", "timestamps": [{"start": 906226, "end": 906908}]}, {"count": 1, "rank": 0.05, "text": "Java developers", "timestamps": [{"start": 548576, "end": 549590}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}