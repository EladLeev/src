1
00:00:27,570 --> 00:00:31,074
Hello everyone, and welcome to my presentation about let's

2
00:00:31,122 --> 00:00:34,854
build our own dependency injection framework. My name is Mark Hendriks. I'm a

3
00:00:34,892 --> 00:00:38,150
software architect at Ordina, which is a it service

4
00:00:38,220 --> 00:00:41,926
provider based in the Netherlands, Belgium and Luxembourg. And before we go

5
00:00:41,948 --> 00:00:45,398
into building our own dependency injection framework, there's a concept that I

6
00:00:45,404 --> 00:00:49,206
need to talk to you about, and that's inversion of control. And inversion of

7
00:00:49,228 --> 00:00:52,702
control is nothing more than an architectural pattern in

8
00:00:52,756 --> 00:00:55,962
which an outside entity, a container or framework,

9
00:00:56,026 --> 00:00:59,626
wires together all the dependencies that you need and passes

10
00:00:59,658 --> 00:01:03,258
them through the class that needs them, instead of that class having to instantiate

11
00:01:03,274 --> 00:01:06,978
them themselves. Let's have a little code example which illustrates this a

12
00:01:06,984 --> 00:01:10,546
bit better. The top example doesn't make use

13
00:01:10,568 --> 00:01:13,826
of inversion of control because the my class has a dependency and

14
00:01:13,848 --> 00:01:17,182
my dependency and it instantiates it with the new keyword.

15
00:01:17,246 --> 00:01:20,726
And technically there's nothing wrong with this, it works. But if

16
00:01:20,748 --> 00:01:23,942
we look at the second example, you see that the dependency is

17
00:01:23,996 --> 00:01:28,194
passed through the constructor instead of it being instantiated

18
00:01:28,242 --> 00:01:31,834
within the my class. And this is making use

19
00:01:31,872 --> 00:01:35,894
of inversion of control. And technically speaking this is already dependency injection

20
00:01:35,942 --> 00:01:39,862
because the my class is no longer responsible for instantiating

21
00:01:40,006 --> 00:01:43,370
an instance of my dependency. And in this case it's

22
00:01:43,450 --> 00:01:47,118
constructor injection because we're using a constructor and you can also

23
00:01:47,204 --> 00:01:50,686
use field injection injecting it via fields, or you can

24
00:01:50,708 --> 00:01:54,654
use setter injection using setter methods to inject dependencies into

25
00:01:54,692 --> 00:01:58,130
a class. That way we're going to cover all three of those during this talk.

26
00:01:58,200 --> 00:02:01,346
So yeah, dependency injection is nothing more than having an outside

27
00:02:01,448 --> 00:02:04,546
entity providing you with the dependencies that you need.

28
00:02:04,648 --> 00:02:08,902
And in spring you might have seen the at auto byte annotation before

29
00:02:09,036 --> 00:02:12,274
they use it to tell that you want to have dependencies

30
00:02:12,322 --> 00:02:15,378
injected in there. And Google juice,

31
00:02:15,474 --> 00:02:18,642
Yafa Yakarta e. They all use at inject.

32
00:02:18,786 --> 00:02:21,546
And if you look at this example, this is how you would do it in

33
00:02:21,568 --> 00:02:25,446
spring. And I know you don't actually need to put the add auto

34
00:02:25,478 --> 00:02:28,666
write annotation on there anymore in spring, because if there's only one

35
00:02:28,688 --> 00:02:32,570
constructor, it knows implicitly that it's there. But this is just for demonstration

36
00:02:32,650 --> 00:02:36,490
purposes, and this is the Java Jakarta ee

37
00:02:36,570 --> 00:02:40,286
version of that. But how does it work? Well, for me it

38
00:02:40,308 --> 00:02:43,694
felt a lot like magic, but of course it's not

39
00:02:43,732 --> 00:02:47,282
magic. Let's be honest, if you look under the hood, it's actually

40
00:02:47,336 --> 00:02:52,030
a clever use of the reflection API, which has been around Java

41
00:02:52,190 --> 00:02:56,366
since the beginning of Java pretty much. And reflection is nothing more than can

42
00:02:56,408 --> 00:03:00,454
API, in which you can inspect and manipulate code

43
00:03:00,572 --> 00:03:03,782
and classes at runtime. And that might

44
00:03:03,916 --> 00:03:07,094
seem a bit daunting, but as long has

45
00:03:07,132 --> 00:03:10,994
you know what you're doing, it's not too scary to work with reflection.

46
00:03:11,042 --> 00:03:14,714
From my own understanding, I wanted to know more about reflection, and I wanted

47
00:03:14,752 --> 00:03:18,406
to know more about how dependency injection frameworks

48
00:03:18,438 --> 00:03:21,738
actually worked. So I built my own dependency injection framework and I

49
00:03:21,744 --> 00:03:25,386
called it the injectinator. And for those who know Phineas and Ferp,

50
00:03:25,418 --> 00:03:29,258
which is a show by Disney, this is Professor Dolphinsmirtz

51
00:03:29,274 --> 00:03:32,894
and he is terrible at naming all the suspensions enter into the post

52
00:03:32,932 --> 00:03:36,642
fix inator. And that's what I got my inspiration from.

53
00:03:36,776 --> 00:03:39,838
And you're going to see this throughout this talk. I'm just an engineer

54
00:03:39,934 --> 00:03:43,470
and I'm terrible at naming things, like a lot of engineers,

55
00:03:43,550 --> 00:03:46,482
so hence this name. Okay,

56
00:03:46,536 --> 00:03:50,054
enough slides for now. Let's go straight into the code, shall we?

57
00:03:50,092 --> 00:03:53,158
It's going to bring up intellij really quickly. Okay,

58
00:03:53,324 --> 00:03:56,678
I've got a little demo project

59
00:03:56,764 --> 00:04:00,234
here. Let me quickly remove this. Got a little demo set up

60
00:04:00,272 --> 00:04:03,818
here. It's nothing more than a maven project.

61
00:04:03,904 --> 00:04:07,158
I'm using Java 15, but the version of Java doesn't

62
00:04:07,174 --> 00:04:10,670
really matter. I've tried it with Java 811 and 15

63
00:04:10,740 --> 00:04:14,314
and it works on all versions, so it should work on your version.

64
00:04:14,362 --> 00:04:16,350
Pretty much it just uses reflection.

65
00:04:18,850 --> 00:04:22,382
I've got an awesome class which just

66
00:04:22,436 --> 00:04:26,590
has a dependency on logger which isn't instantiated

67
00:04:26,670 --> 00:04:30,114
anywhere here, and logger is nothing more

68
00:04:30,152 --> 00:04:33,074
than just a simple logger, just to show that it's working. I'm going to use

69
00:04:33,112 --> 00:04:36,258
these classes to show the purpose of the framework that we're

70
00:04:36,264 --> 00:04:39,558
going to build, and an example class in which we're just going to wire it

71
00:04:39,564 --> 00:04:42,982
together and get it started. So let me just close

72
00:04:43,036 --> 00:04:47,366
these. The first thing that we need is a way to tell

73
00:04:47,468 --> 00:04:50,898
our framework that we want to have something injected and we're

74
00:04:50,914 --> 00:04:53,194
going to go the same route. We're going to use can annotation for that,

75
00:04:53,232 --> 00:04:56,554
and we could use the add inject annotation, we could add

76
00:04:56,592 --> 00:04:59,706
a dependency. We're not going to do that. We want to have our framework to

77
00:04:59,728 --> 00:05:03,902
be self reliant, no dependencies to outside code.

78
00:05:03,956 --> 00:05:07,870
So let's make our own annotation and let's call it injectme.

79
00:05:09,570 --> 00:05:13,086
It's an annotation, and the first thing we need to do is tell the

80
00:05:13,108 --> 00:05:16,030
compiler at what time do we want this annotation to be available.

81
00:05:16,180 --> 00:05:18,994
Well, in our case we're going to use this for reflection. So we want this

82
00:05:19,032 --> 00:05:22,718
to be available at runtime. So we're going to say retention and we're

83
00:05:22,734 --> 00:05:26,510
going to say at runtime retention policy runtime.

84
00:05:26,670 --> 00:05:30,098
And the second thing we want to do is tell the compiler on which types

85
00:05:30,114 --> 00:05:33,362
of elements can we put this annotation.

86
00:05:33,426 --> 00:05:36,742
And in our case I told you about three types of

87
00:05:36,796 --> 00:05:40,514
dependency injection, constructor injection field injection and setter

88
00:05:40,562 --> 00:05:43,702
injection. And those are actually the three types of elements

89
00:05:43,766 --> 00:05:46,986
that we want to be able to put this annotation on. So just going to

90
00:05:47,008 --> 00:05:50,378
say target and we're going to say we want to be able to

91
00:05:50,384 --> 00:05:53,760
put us can element type constructor on element type

92
00:05:54,450 --> 00:05:58,618
field and on element type method.

93
00:05:58,794 --> 00:06:02,238
There's no setter here because setter is nothing more than a method, but we're going

94
00:06:02,244 --> 00:06:04,900
to work around that in a while, in a bit.

95
00:06:05,350 --> 00:06:09,762
Okay, this is sorted. Next thing that we want to do is make

96
00:06:09,816 --> 00:06:13,054
a little configuration class in which we can wire

97
00:06:13,102 --> 00:06:17,060
together the dependencies because we do have to tell the framework for

98
00:06:18,710 --> 00:06:22,630
which actual implementation we want to be injecting that for.

99
00:06:22,700 --> 00:06:25,970
So going to make an interface and to stay into theme we're

100
00:06:26,470 --> 00:06:30,262
going to call this the syringe. And the syringe has two classes.

101
00:06:30,326 --> 00:06:33,946
It has a configure so that

102
00:06:33,968 --> 00:06:38,554
we can actually wire it together. And the second one being,

103
00:06:38,752 --> 00:06:42,754
let me just type this out quickly. This will turn a class extends

104
00:06:42,822 --> 00:06:46,206
t and we're going to call this get injectable because

105
00:06:46,228 --> 00:06:49,486
we want to get the actual implementation of the, or actually the

106
00:06:49,508 --> 00:06:53,230
implementation class of our dependencies that we're going to inject.

107
00:06:54,370 --> 00:06:58,180
We're just going to say class type t and we're just going to call this

108
00:06:58,710 --> 00:07:02,066
type and that's it. Now we're going to make an

109
00:07:02,088 --> 00:07:05,298
actual implementation. So implement interface. I'm going to

110
00:07:05,304 --> 00:07:09,366
call this my syringe for

111
00:07:09,388 --> 00:07:12,438
the example. We're going to put it in the example package and we're going to

112
00:07:12,444 --> 00:07:15,862
implement those. Okay, first thing that we want to do

113
00:07:15,916 --> 00:07:20,342
is actually have some sort of a construction

114
00:07:20,406 --> 00:07:24,294
in memory where we can save the dependency

115
00:07:24,342 --> 00:07:27,066
with the actual implementation that we can map them. And we're going to use a

116
00:07:27,088 --> 00:07:30,774
map for that private

117
00:07:30,822 --> 00:07:34,414
map of type class. And we don't know which class it

118
00:07:34,452 --> 00:07:37,822
is. And the second one, we don't know which class it is either,

119
00:07:37,876 --> 00:07:41,898
because we can put in multiple dependencies in this map. So we're

120
00:07:41,914 --> 00:07:46,686
going to call this injectables injectables

121
00:07:46,718 --> 00:07:50,354
and it's nothing more than a new has map in

122
00:07:50,392 --> 00:07:54,546
configure. We actually want to wire together the

123
00:07:54,568 --> 00:07:57,718
interfaces with the implementation we're going to use. In our case, we're going

124
00:07:57,724 --> 00:08:01,638
to use the logger with the mylogger implementation. So going to

125
00:08:01,644 --> 00:08:04,310
say register injectable,

126
00:08:05,530 --> 00:08:08,874
we're going to pass in the logger class and

127
00:08:08,912 --> 00:08:11,260
the mylogger class.

128
00:08:11,870 --> 00:08:15,370
This method doesn't exist obviously, so let's create

129
00:08:15,440 --> 00:08:18,826
it. And what you actually have

130
00:08:18,848 --> 00:08:22,186
to state here is going to use some generics. I'm going to say this will

131
00:08:22,208 --> 00:08:27,694
be a type t. I'm going to call this the base class and

132
00:08:27,812 --> 00:08:31,518
this will be a class which extends the

133
00:08:31,684 --> 00:08:34,050
type t. And we'll call this the subclass.

134
00:08:35,350 --> 00:08:38,590
And this is fairly simple. We just have to put it into the injectables map

135
00:08:38,670 --> 00:08:42,580
injectables put base class

136
00:08:43,190 --> 00:08:47,000
subclass and that's that. But we can do one more thing here

137
00:08:48,250 --> 00:08:52,694
because we're working with classes. We can actually state where we want to use

138
00:08:52,732 --> 00:08:56,310
this as a subclass of the base class. And what this does is actually

139
00:08:56,380 --> 00:08:59,954
checking if it's actually assignable.

140
00:09:00,002 --> 00:09:03,274
And I know the generics already take care of that, but I

141
00:09:03,312 --> 00:09:07,354
would really like to feel fast and just make it extra sure that you

142
00:09:07,552 --> 00:09:10,640
are working with an actual subclass of this base class.

143
00:09:12,130 --> 00:09:15,918
Okay. And the next thing we want to do

144
00:09:16,084 --> 00:09:20,122
is check if we have the injectable

145
00:09:20,186 --> 00:09:24,478
ready, and if not we're going to throw an exception. So injectables

146
00:09:24,574 --> 00:09:26,820
get for type.

147
00:09:29,990 --> 00:09:33,650
We'll just save this and this is the injectable

148
00:09:34,890 --> 00:09:37,510
and we're just going to say injectable.

149
00:09:38,330 --> 00:09:42,054
If this is null, we'll throw a new

150
00:09:42,172 --> 00:09:45,494
legal argument, exception. And we can say something

151
00:09:45,532 --> 00:09:47,810
like no,

152
00:09:47,980 --> 00:09:51,420
injectable registered for type.

153
00:09:52,750 --> 00:09:57,306
Be creative with your message, I would say. And then we'll return

154
00:09:57,488 --> 00:10:01,394
the injectable.

155
00:10:01,542 --> 00:10:05,146
And this is an interesting one because we're now going to get a compiler error

156
00:10:05,178 --> 00:10:09,294
because it says that we are expecting a

157
00:10:09,332 --> 00:10:13,214
class that extends t, but we're actually giving back a class

158
00:10:13,332 --> 00:10:16,514
which doesn't extend anything, not that we know

159
00:10:16,552 --> 00:10:20,306
anyway, unknown type. So what we can do here is pretty much the

160
00:10:20,328 --> 00:10:23,730
same as we did here. We're just going to pass this back as a

161
00:10:23,800 --> 00:10:27,174
subclass of the type we just passed in.

162
00:10:27,292 --> 00:10:30,040
And now it works. Okay.

163
00:10:32,010 --> 00:10:35,254
Next thing that we're going to do is we're going to start off with the

164
00:10:35,292 --> 00:10:39,638
example class and we want to instantiate

165
00:10:39,814 --> 00:10:42,854
the injectinator so that we actually can start doing some injection.

166
00:10:42,902 --> 00:10:47,222
So going to say injectinatorinjectinator

167
00:10:47,366 --> 00:10:49,450
equals injectinator.

168
00:10:50,110 --> 00:10:52,490
Getinjectinator of getinstance.

169
00:10:54,370 --> 00:10:57,582
Let's go with getinjectinator we're going to pass in a

170
00:10:57,716 --> 00:11:01,818
new my syringe and we're

171
00:11:01,834 --> 00:11:05,394
going to create this. It's public static. We'll just say this is

172
00:11:05,432 --> 00:11:09,410
a syringe and this is the syringe and this will return a

173
00:11:09,480 --> 00:11:13,346
new injectinator which accepts the syringe for this

174
00:11:13,368 --> 00:11:16,726
constructor doesn't exist so let's create it as

175
00:11:16,748 --> 00:11:21,030
well. And we'll just say this syringe equals syringe.

176
00:11:21,370 --> 00:11:25,766
This field doesn't exist so let's create that and

177
00:11:25,788 --> 00:11:27,350
we'll just make this private.

178
00:11:28,830 --> 00:11:32,460
Okay, that's part one, this part works.

179
00:11:32,830 --> 00:11:37,370
Next, what we want to do is we want to get an actual implementation

180
00:11:37,790 --> 00:11:41,818
of the awesome class which has all the dependencies injected. So let's get a

181
00:11:41,824 --> 00:11:45,818
head start with that. So we're going to say awesome class, awesome class equals

182
00:11:45,994 --> 00:11:50,298
injectinator and we'll say inject and we're

183
00:11:50,314 --> 00:11:54,080
going to pass in the awesome class. This method doesn't exist so

184
00:11:54,610 --> 00:11:57,874
let's create it. And this is not going to pass back an awesome class because

185
00:11:57,912 --> 00:12:01,058
we want to make this generic. So we're just going to say it will return

186
00:12:01,144 --> 00:12:04,770
a type t and we'll pass in

187
00:12:04,840 --> 00:12:08,182
type t and we'll just call this the class to

188
00:12:08,316 --> 00:12:11,814
inject to. And I spoke about

189
00:12:11,852 --> 00:12:16,194
three places which we could do. Dependency injection. There are constructors, fields and setters.

190
00:12:16,242 --> 00:12:20,874
And let's start off with field injection, shall we? So we'll just say return

191
00:12:20,992 --> 00:12:24,586
inject via fields and we'll pass in

192
00:12:24,608 --> 00:12:28,380
the class to inject to. This doesn't exist so let's create that

193
00:12:28,990 --> 00:12:32,222
for now. We're going to return. No, first thing that we need to do

194
00:12:32,276 --> 00:12:36,494
is make an actual instance of the class that we want to

195
00:12:36,532 --> 00:12:41,482
inject into. So class to inject to get constructor

196
00:12:41,626 --> 00:12:48,450
and new instance and we'll call this instance

197
00:12:49,110 --> 00:12:52,178
and this will throw a couple of exceptions. And what I'm going to

198
00:12:52,184 --> 00:12:55,806
do here today is the lazy man's route. But please don't

199
00:12:55,838 --> 00:12:59,714
do this in production. I'm not going to properly handle

200
00:12:59,762 --> 00:13:03,640
exceptions. I'm not going to do proper exception propagation either.

201
00:13:04,090 --> 00:13:07,682
It's just to make it simple for sake of this talk

202
00:13:07,756 --> 00:13:11,462
for tonight, but please don't do this in production.

203
00:13:11,526 --> 00:13:15,130
Please throws exception,

204
00:13:17,710 --> 00:13:21,134
just add it here as well. And what we're going to

205
00:13:21,172 --> 00:13:24,494
do is for

206
00:13:24,532 --> 00:13:28,830
that class to inject to. We're going to say get methods

207
00:13:30,130 --> 00:13:33,898
or get method, my apologies. Get fields. We're starting with field injection and

208
00:13:33,924 --> 00:13:37,458
as you can see there's two types. There's get fields and

209
00:13:37,464 --> 00:13:40,978
there's get declared fields. And there's a

210
00:13:41,144 --> 00:13:44,434
small distinction between the two. Get fields will only

211
00:13:44,472 --> 00:13:47,822
give you all the publicly accessible fields, and the get declared

212
00:13:47,886 --> 00:13:51,174
fields will give you all the non publicly accessible fields as well.

213
00:13:51,212 --> 00:13:54,482
And we want to be able to annotate private

214
00:13:54,546 --> 00:13:57,794
fields. So we're going to go with the get declared fields

215
00:13:57,842 --> 00:14:01,626
and we're going to loop over those, just going to call it a field and

216
00:14:01,648 --> 00:14:05,580
we're going to check if the field is annotated. So if field

217
00:14:06,110 --> 00:14:09,626
is annotation present, going to check for

218
00:14:09,648 --> 00:14:12,830
the injectme. If that's present.

219
00:14:12,900 --> 00:14:17,710
First thing we need to do is set

220
00:14:17,780 --> 00:14:22,042
accessible to true. This is just to comfort

221
00:14:22,186 --> 00:14:25,780
the possible security manager that you might have running in your application.

222
00:14:26,950 --> 00:14:30,306
And next, what we're going to do is field set.

223
00:14:30,488 --> 00:14:34,142
And set takes two parameters

224
00:14:34,206 --> 00:14:38,054
of object type and the first

225
00:14:38,092 --> 00:14:41,782
one is the instance in which you want to set this field. And the

226
00:14:41,916 --> 00:14:45,574
second parameter is the actual

227
00:14:45,692 --> 00:14:48,954
value you want to set the field to in that instance that you passed in.

228
00:14:48,992 --> 00:14:52,234
So we're going to say instance and

229
00:14:52,272 --> 00:14:56,410
we're going to say field gettype,

230
00:14:58,190 --> 00:15:01,550
but this isn't enough. What we're going to do now is we're going to do

231
00:15:01,620 --> 00:15:05,566
a little bit of recursion because it

232
00:15:05,588 --> 00:15:09,278
might be possible that the dependency that we want to inject has

233
00:15:09,444 --> 00:15:12,558
dependencies of its own. So we're going to skip this

234
00:15:12,644 --> 00:15:16,626
actually, we're just going to cut it and what we're actually going to do is

235
00:15:16,728 --> 00:15:20,802
a little bit of recursion. We're going to call inject here again and we're actually

236
00:15:20,856 --> 00:15:24,226
going to ask the syringe to get the injectable for

237
00:15:24,248 --> 00:15:27,526
that type because this might be an interface and we want

238
00:15:27,548 --> 00:15:31,026
to have an actual implementation of that interface. So that's why we ask the syringe

239
00:15:31,058 --> 00:15:34,934
for an actual implementation class first and

240
00:15:34,972 --> 00:15:38,760
then we return the instance. Okay,

241
00:15:40,410 --> 00:15:43,866
so next thing we're going to do is the awesome class has

242
00:15:43,888 --> 00:15:47,482
one method and it's log. And if I run this now this will give a

243
00:15:47,536 --> 00:15:51,082
huge null pointer exception because we haven't instantiated

244
00:15:51,146 --> 00:15:54,222
the actual dependency yet.

245
00:15:54,276 --> 00:15:57,838
Then exactly as stated, logger lar causes a

246
00:15:57,844 --> 00:16:03,158
null pointer but outwired.

247
00:16:03,274 --> 00:16:06,546
My apologies. Inject me. If I just put inject me

248
00:16:06,568 --> 00:16:10,100
in here and we run this code again. If everything went all right,

249
00:16:12,070 --> 00:16:15,206
I made one little mistake and the

250
00:16:15,228 --> 00:16:19,538
mistake is in the syringe, or actually it's in the injectinator.

251
00:16:19,634 --> 00:16:23,094
What I forgot to do is we did the dewiring of

252
00:16:23,132 --> 00:16:27,294
the different implementations of the dependencies

253
00:16:27,442 --> 00:16:31,226
inside the configure method, and we haven't called this here, just a

254
00:16:31,248 --> 00:16:36,140
small oversight. So this

255
00:16:36,590 --> 00:16:40,560
syringe configure and now it should work.

256
00:16:44,290 --> 00:16:47,790
It's not the most awesome message ever, obviously, but it just

257
00:16:47,860 --> 00:16:51,038
demonstrates that it works. Okay,

258
00:16:51,204 --> 00:16:55,226
so the next one we're going to do is constructor injection.

259
00:16:55,418 --> 00:16:58,446
Let's go back to the injectinator here.

260
00:16:58,628 --> 00:17:00,946
And what we're going to do next is we're going to keep this as the

261
00:17:00,968 --> 00:17:04,226
default. So we're going to leave this at the bottom and we're going to

262
00:17:04,248 --> 00:17:08,578
say class to inject to get constructors.

263
00:17:08,754 --> 00:17:12,550
We only want to do this with publicly accessible constructors. So just

264
00:17:12,620 --> 00:17:15,160
get constructors and we're going to loop over them.

265
00:17:15,690 --> 00:17:19,382
And constructor is annotation present

266
00:17:19,516 --> 00:17:23,418
for the injectme class. If that's the case we're going to say return

267
00:17:23,584 --> 00:17:27,226
inject via constructor and

268
00:17:27,248 --> 00:17:30,682
we're going to pass in the constructor and the class to inject to. And why

269
00:17:30,736 --> 00:17:33,660
we do that, I'll tell you in a second.

270
00:17:35,550 --> 00:17:38,398
Okay, we're going to start off with a return null. And there's a couple of

271
00:17:38,404 --> 00:17:41,790
things that we need here. First, what we're going to do is we want to

272
00:17:41,860 --> 00:17:45,038
know all the parameter types of the constructor that we're

273
00:17:45,054 --> 00:17:49,138
going to use for the injection. So constructor get

274
00:17:49,224 --> 00:17:53,060
parameter types and we're going to

275
00:17:53,510 --> 00:17:57,140
put these in an array of type class.

276
00:17:57,670 --> 00:18:01,830
And the next thing, what we want is an actual array to save

277
00:18:01,900 --> 00:18:05,446
all the actual implementations into because we're going to need that to

278
00:18:05,548 --> 00:18:09,820
actually call the constructor in a bit. So we'll just say object

279
00:18:11,310 --> 00:18:14,682
call these dependencies and

280
00:18:14,736 --> 00:18:18,940
it's not more than a new object array with the

281
00:18:19,630 --> 00:18:22,350
length of the parameter types array.

282
00:18:23,650 --> 00:18:27,770
And we're going to have a little external iterator

283
00:18:27,850 --> 00:18:32,074
here and we're going to loop over the parameter

284
00:18:32,122 --> 00:18:36,290
types. And what we're going to do is for the dependency

285
00:18:37,110 --> 00:18:40,878
in index I zero base counting.

286
00:18:40,894 --> 00:18:44,274
So we start with zero is we're going to do the same recursion here

287
00:18:44,312 --> 00:18:48,630
and we're going to say inject and we're going to ask the syringe

288
00:18:49,450 --> 00:18:53,554
to give us the injectable for the parameter

289
00:18:53,602 --> 00:18:57,654
type. This throws an exception. Let's just

290
00:18:57,692 --> 00:19:01,400
throw it and then we're going to do an I plus plus.

291
00:19:01,770 --> 00:19:05,210
Okay, we could also do I plus plus here, but for

292
00:19:05,280 --> 00:19:08,140
simplicity and readability's sake I'll just leave it here.

293
00:19:09,950 --> 00:19:13,438
And what we're going to do now is actually we're going to tell the class

294
00:19:13,524 --> 00:19:15,600
to inject to,

295
00:19:16,210 --> 00:19:20,094
to give us the constructor with

296
00:19:20,212 --> 00:19:24,230
these parameter types, make a new instance

297
00:19:24,330 --> 00:19:27,906
and use all of these implementations of

298
00:19:27,928 --> 00:19:31,540
the dependencies that you need to use that constructor that we're going to use.

299
00:19:32,630 --> 00:19:36,478
Okay, and if that all works, let me

300
00:19:36,504 --> 00:19:40,566
just remove this one for now. Let's get

301
00:19:40,668 --> 00:19:44,374
ourselves a nice constructor, annotate it with

302
00:19:44,412 --> 00:19:48,902
at injectme, and if I did everything correctly, this should

303
00:19:48,956 --> 00:19:51,800
still work, same message, so it still works.

304
00:19:52,170 --> 00:19:55,466
Okay, going back to injectinator, there's one

305
00:19:55,488 --> 00:19:59,290
more place where we can implement dependency injection,

306
00:19:59,630 --> 00:20:03,834
and that is via setters or method injection, I prefer that

307
00:20:03,872 --> 00:20:07,166
name. Okay, so what we're going to do, we're going to say that it's the

308
00:20:07,188 --> 00:20:11,134
second place that we're going to check. So we're going to do here is the

309
00:20:11,252 --> 00:20:14,910
class to inject to get methods.

310
00:20:17,090 --> 00:20:20,382
And you see there's two types here as well. It's get methods and get declared

311
00:20:20,446 --> 00:20:23,634
methods. And case being methods is

312
00:20:23,672 --> 00:20:26,850
only the publicly accessible ones and the get declared will also

313
00:20:26,920 --> 00:20:30,546
give back all the non publicly accessible ones. But a setter

314
00:20:30,578 --> 00:20:34,626
is public by default. So we're only going to check for publicly

315
00:20:34,658 --> 00:20:37,640
accessible methods. I'm going to loop over those,

316
00:20:38,250 --> 00:20:41,830
we're going to do the same check. So method is annotation

317
00:20:41,990 --> 00:20:45,686
present for the injectme class and if that's

318
00:20:45,718 --> 00:20:49,014
the case we're just going to do return inject via

319
00:20:49,062 --> 00:20:53,002
setters. Class two, inject two,

320
00:20:53,056 --> 00:20:56,000
this doesn't exist. So let's create that method as well.

321
00:20:56,530 --> 00:20:59,598
This is all right. And we have to do the same here.

322
00:20:59,684 --> 00:21:03,770
We're going to start off with getting a new instance,

323
00:21:03,930 --> 00:21:07,600
just going to save this to instance and this will

324
00:21:08,210 --> 00:21:10,030
throw an exceptional,

325
00:21:11,590 --> 00:21:15,438
this will eventually give back the instance and we're

326
00:21:15,454 --> 00:21:19,154
going to loop over the methods now. So class to inject

327
00:21:19,202 --> 00:21:23,446
to get methods. And what

328
00:21:23,468 --> 00:21:26,966
we're going to do is method is annotation present

329
00:21:27,068 --> 00:21:30,120
for the injectme class,

330
00:21:34,170 --> 00:21:38,270
and that's

331
00:21:38,290 --> 00:21:41,930
far if obviously. So if it's available then

332
00:21:42,000 --> 00:21:48,254
we're going to do pretty much the same. We're going to say method not

333
00:21:48,292 --> 00:21:51,838
set, but it's called invoke in this case. And it takes two parameters as

334
00:21:51,844 --> 00:21:54,914
well, both of type object and the first one

335
00:21:54,952 --> 00:21:58,322
being the instance that you want to invoke this method on.

336
00:21:58,376 --> 00:22:01,570
And the second object is actually four arcs,

337
00:22:01,990 --> 00:22:05,646
which are the actual objects

338
00:22:05,678 --> 00:22:10,610
that you want to pass into that method that you're calling. So invoke

339
00:22:10,770 --> 00:22:14,546
instance. And in our case we're going to do the same recursion,

340
00:22:14,658 --> 00:22:18,610
not instance, inject syringe,

341
00:22:18,690 --> 00:22:22,246
get injectable. And this might seem a bit tricky, but I'll

342
00:22:22,358 --> 00:22:27,334
get back to you in a sec. Get parameter

343
00:22:27,382 --> 00:22:30,538
types, which gives back an array. And just going to

344
00:22:30,544 --> 00:22:35,150
bluntly say that we want to get

345
00:22:35,220 --> 00:22:40,894
the first one type

346
00:22:40,932 --> 00:22:44,094
parameters get parameter types wrong

347
00:22:44,132 --> 00:22:47,610
way around. Okay? And some of you may state, well, this could cause an

348
00:22:47,620 --> 00:22:50,962
index out of bound exception. And you're correct, it can.

349
00:22:51,096 --> 00:22:54,446
But the thing is, a setter, if you check the bean specification,

350
00:22:54,478 --> 00:22:58,390
it's always public, it always starts with set. It always only has one parameter count.

351
00:22:58,460 --> 00:23:01,778
So let's build in some safety checks for ourselves,

352
00:23:01,874 --> 00:23:05,042
shall we? So we're going to check if the annotation

353
00:23:05,186 --> 00:23:08,834
is present and also the method

354
00:23:08,882 --> 00:23:13,046
name. For instance, get name starts

355
00:23:13,078 --> 00:23:16,826
with set. That can be another check. It doesn't say much

356
00:23:16,928 --> 00:23:22,062
at the moment. Let's just format this a little bit and

357
00:23:22,196 --> 00:23:25,950
we can do one more check. We can also check if the method

358
00:23:26,690 --> 00:23:30,814
get parameter count and

359
00:23:30,852 --> 00:23:34,942
that should equal one and only then will

360
00:23:34,996 --> 00:23:38,306
this type of this will

361
00:23:38,328 --> 00:23:41,966
be invoked then. So we sorted

362
00:23:41,998 --> 00:23:45,678
that out. This should no longer cause can index out of bound exception. And let's

363
00:23:45,694 --> 00:23:49,318
see if this still works. Let's have a

364
00:23:49,324 --> 00:23:52,834
look. Go back to the awesome class. Let's just remove

365
00:23:52,882 --> 00:23:56,454
this constructor for now, no need

366
00:23:56,492 --> 00:23:59,914
for it at the moment. And let's just put a

367
00:24:00,032 --> 00:24:03,910
setter in here and put at inject

368
00:24:03,990 --> 00:24:05,740
me on top of that.

369
00:24:09,930 --> 00:24:13,634
And it still works. Be careful

370
00:24:13,682 --> 00:24:17,050
though. Setter injection, it works. But the thing is,

371
00:24:17,200 --> 00:24:20,682
even after construction, if something goes wrong with

372
00:24:20,736 --> 00:24:24,346
calling the setters for whatever reason, you might end up with an

373
00:24:24,368 --> 00:24:27,510
incomplete object. With a constructor injection,

374
00:24:27,670 --> 00:24:31,326
your code will just fail and die pretty much because you won't be able

375
00:24:31,348 --> 00:24:34,894
to get an actual half constructed object. And in this case you

376
00:24:34,932 --> 00:24:37,998
can. So do be really careful with that.

377
00:24:38,164 --> 00:24:40,580
Just keep that in mind. Okay.

378
00:24:41,910 --> 00:24:45,330
If you take a look at the spring framework, for instance,

379
00:24:45,990 --> 00:24:49,182
for all the dependencies that they inject, they give back a singleton.

380
00:24:49,246 --> 00:24:53,090
And in our case we make a new instance every single

381
00:24:53,160 --> 00:24:57,250
time that we need it. And to demonstrate that that's actually the case,

382
00:24:57,320 --> 00:25:00,078
let's just quickly go into my logger,

383
00:25:00,254 --> 00:25:03,098
put a private int called,

384
00:25:03,144 --> 00:25:06,874
called count. We'll just

385
00:25:06,912 --> 00:25:11,194
set it to zero and we'll just put in an extra message and

386
00:25:11,232 --> 00:25:13,180
say times called.

387
00:25:14,590 --> 00:25:17,120
And we'll say plus, plus call count.

388
00:25:17,730 --> 00:25:21,358
And if we go to the example app and just

389
00:25:21,524 --> 00:25:22,880
duplicate these,

390
00:25:25,010 --> 00:25:28,802
it's two different instances and they each

391
00:25:28,856 --> 00:25:32,066
have their own instance of the logger. So if you

392
00:25:32,088 --> 00:25:35,682
run this, you should see times called. It's both

393
00:25:35,736 --> 00:25:39,714
one in both examples. So let

394
00:25:39,752 --> 00:25:43,074
me quickly show you how we can actually make

395
00:25:43,112 --> 00:25:46,638
it so that we can decide if we want to have a new instance so

396
00:25:46,664 --> 00:25:50,646
that we get a singleton instead. So what

397
00:25:50,668 --> 00:25:54,266
we're going to do is we're going to introduce a enum and we'll just

398
00:25:54,288 --> 00:25:55,820
call it injection type.

399
00:25:57,550 --> 00:26:01,690
And there's only two values, either new or singleton

400
00:26:02,990 --> 00:26:07,050
and that's that. Next we need to update the

401
00:26:07,200 --> 00:26:10,366
injectme so that we tell it that it can take

402
00:26:10,388 --> 00:26:13,774
a value. We'll say injection type.

403
00:26:13,812 --> 00:26:17,534
And if we call this, I'll just call it injection type to start

404
00:26:17,572 --> 00:26:21,266
off with. I'll show you what I mean.

405
00:26:21,368 --> 00:26:24,900
And we'll say it defaults to the new.

406
00:26:26,150 --> 00:26:29,442
There's no related problems. The thing is, if we want to

407
00:26:29,576 --> 00:26:32,898
keep it as is, we don't need to do anything. But if we want

408
00:26:32,904 --> 00:26:36,582
to say a singleton here, we actually have to say injection type.

409
00:26:36,636 --> 00:26:40,006
Is the injection type singleton. And this can be

410
00:26:40,028 --> 00:26:44,026
shorthanded. We only use this. So if you call this value instead,

411
00:26:44,208 --> 00:26:48,474
that is the default. And in that case you

412
00:26:48,512 --> 00:26:50,140
can just leave this out.

413
00:26:51,310 --> 00:26:53,260
That's a nice shorthand for that.

414
00:26:53,950 --> 00:26:57,614
Okay, I'm just going to remove this

415
00:26:57,652 --> 00:27:01,406
for now. And what we're going to do next is we

416
00:27:01,428 --> 00:27:04,586
already got our setter in place. So let's

417
00:27:04,618 --> 00:27:09,070
start off with implementing the singleton

418
00:27:09,150 --> 00:27:13,662
implementation for setters. So inject

419
00:27:13,726 --> 00:27:17,538
via setters. And first of all, we actually want to store

420
00:27:17,624 --> 00:27:24,334
our singleton implementation. So we're going to say private

421
00:27:24,382 --> 00:27:27,430
final and we're going to call this, make this a map as well.

422
00:27:27,500 --> 00:27:31,160
And it is a map of type class

423
00:27:32,570 --> 00:27:36,966
unknown can object because we're going to store actual implementations

424
00:27:37,078 --> 00:27:40,474
in there and we'll call this singletons and

425
00:27:40,512 --> 00:27:42,890
it's nothing more than a new hash map.

426
00:27:43,630 --> 00:27:47,726
Okay, so what we're going to do now is we're going

427
00:27:47,748 --> 00:27:51,566
to do one extra check over here and the check will

428
00:27:51,588 --> 00:27:55,354
be if the annotation has its value set to singleton

429
00:27:55,402 --> 00:27:59,074
or not. So method get

430
00:27:59,112 --> 00:28:03,778
annotation injectme class value

431
00:28:03,864 --> 00:28:06,370
if that equals Singleton.

432
00:28:06,950 --> 00:28:10,354
If that's the case, we're going to do

433
00:28:10,552 --> 00:28:14,546
something new and otherwise we're

434
00:28:14,578 --> 00:28:17,926
going to keep using the implementation that

435
00:28:17,948 --> 00:28:21,526
we already have. And this looks pretty much like this, but I'm just

436
00:28:21,548 --> 00:28:25,270
going to copy paste it. And the only thing that we're going to change

437
00:28:25,420 --> 00:28:28,986
is that we're not actually, I'm just

438
00:28:29,008 --> 00:28:32,026
going to clean this out,

439
00:28:32,208 --> 00:28:36,302
get singleton and get singleton for the

440
00:28:36,356 --> 00:28:40,314
method, get parameter

441
00:28:40,362 --> 00:28:43,694
types and it is the first one.

442
00:28:43,812 --> 00:28:46,938
This method doesn't exist, so let's create it and it'll

443
00:28:46,954 --> 00:28:50,420
just give back an object which is fine. In our case

444
00:28:50,870 --> 00:28:54,994
class, we don't know, we'll just call this type and

445
00:28:55,192 --> 00:28:57,250
we're not going to return null.

446
00:28:59,030 --> 00:29:05,746
And what we're going to do is singletons

447
00:29:05,778 --> 00:29:09,510
that contains key. We're going to check if it's already present

448
00:29:09,580 --> 00:29:13,078
in the list. And actually we're going to check if it's not present in the

449
00:29:13,084 --> 00:29:15,242
list. If it's not in the list, we have to put it in there first.

450
00:29:15,296 --> 00:29:19,066
So singletons put and we're going to put for type,

451
00:29:19,168 --> 00:29:24,710
and what we're going to do is inject

452
00:29:24,870 --> 00:29:27,982
syringe. It's the same stuff over again with

453
00:29:28,036 --> 00:29:30,430
same recursion.

454
00:29:31,730 --> 00:29:35,146
And this throws an exception. So let's just throw that and then we're

455
00:29:35,178 --> 00:29:39,534
going to say return singletons

456
00:29:39,662 --> 00:29:42,020
gettype. Okay,

457
00:29:43,670 --> 00:29:46,914
fairly simple. So if I run this now, it will

458
00:29:46,952 --> 00:29:50,378
still have the same outcome,

459
00:29:50,574 --> 00:29:54,674
still two different implementations, two different instances

460
00:29:54,722 --> 00:29:57,862
pretty much. And if we

461
00:29:57,916 --> 00:30:01,442
go to our awesome class and we actually say injection

462
00:30:01,506 --> 00:30:06,474
type singleton and now see

463
00:30:06,512 --> 00:30:10,282
that it's been called twice. So even though both

464
00:30:10,336 --> 00:30:13,914
the instances of the awesome class want to have

465
00:30:13,952 --> 00:30:17,726
an instance of the mylogger, they only use

466
00:30:17,828 --> 00:30:21,658
one actual instance for that. So that's

467
00:30:21,674 --> 00:30:25,374
really nice. Okay, I'm going to leave it with

468
00:30:25,412 --> 00:30:28,666
this for the building around the pension framework.

469
00:30:28,858 --> 00:30:31,810
If after this talk you've got any questions,

470
00:30:31,960 --> 00:30:35,218
feel free to contact me. You can find

471
00:30:35,304 --> 00:30:39,438
me at the cheerfuldev on Twitter. That's my Twitter handle.

472
00:30:39,534 --> 00:30:43,122
Just ask questions there if you want. And if you want to have a more

473
00:30:43,176 --> 00:30:47,154
complete version of the framework that we just built together,

474
00:30:47,272 --> 00:30:51,026
have a look at my GitHub repository. It's the

475
00:30:51,048 --> 00:30:54,714
cheerful deaf and the project is called the injectinator. So thanks again

476
00:30:54,752 --> 00:30:58,218
for your time, and I hope you learned something. Have a

477
00:30:58,224 --> 00:30:58,682
good one.

