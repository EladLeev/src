1
00:00:39,010 --> 00:00:42,834
Hello Comp 42. Thank you so much for joining

2
00:00:42,882 --> 00:00:46,614
my talk today. My name is Joe Skeen and this

3
00:00:46,732 --> 00:00:49,750
is falling in love with unit testing.

4
00:00:50,130 --> 00:00:53,790
Buckle up. This is going to be a really

5
00:00:53,860 --> 00:00:58,240
intense talk, but I hope that you walk away with

6
00:00:58,930 --> 00:01:02,206
a lot more appreciation for unit testing, why it

7
00:01:02,228 --> 00:01:05,554
is that we're doing it, how to do it without making it

8
00:01:05,592 --> 00:01:09,214
a drudgery, and why we really shouldn't

9
00:01:09,262 --> 00:01:12,434
let AI write our unit tests for us.

10
00:01:12,632 --> 00:01:16,594
I've presented this talk in a few different flavors

11
00:01:16,722 --> 00:01:20,466
at different conferences using different programming languages.

12
00:01:20,658 --> 00:01:24,006
Since this is the DevOps conference, I'm going to be

13
00:01:24,028 --> 00:01:27,302
using Powershell and Pester today

14
00:01:27,436 --> 00:01:31,386
in my code examples. But everything that I talk about are

15
00:01:31,408 --> 00:01:34,570
going to be universal principles that you can

16
00:01:34,640 --> 00:01:38,326
adapt to any programming language or unit testing

17
00:01:38,358 --> 00:01:42,166
framework that you happen to be using. So let's jump into it.

18
00:01:42,208 --> 00:01:45,134
If you'd like to follow along with the slides today,

19
00:01:45,252 --> 00:01:49,150
I have them posted out here. You can go ahead and follow that link

20
00:01:49,300 --> 00:01:53,346
and follow along with me. All right,

21
00:01:53,448 --> 00:01:57,202
so before we jump in too deep, we need to answer

22
00:01:57,256 --> 00:02:00,370
the question. What is unit testing?

23
00:02:00,870 --> 00:02:04,660
Unit testing is can automated test

24
00:02:05,210 --> 00:02:09,000
that validates your logic at the lowest level possible.

25
00:02:10,010 --> 00:02:13,174
So when you think about kind

26
00:02:13,212 --> 00:02:16,470
of the spectrum of testing,

27
00:02:17,050 --> 00:02:20,858
so to speak, you have, your unit tests are

28
00:02:20,944 --> 00:02:24,742
going to be the ones that are testing the smallest

29
00:02:24,806 --> 00:02:28,342
parts. Then you have integration testing or API

30
00:02:28,406 --> 00:02:32,186
testing that will combine different parts

31
00:02:32,218 --> 00:02:35,646
of your program and validate that. Then you have

32
00:02:35,668 --> 00:02:39,246
your end to end tests above that which

33
00:02:39,428 --> 00:02:43,300
have basically all of the parts of the program together.

34
00:02:44,230 --> 00:02:47,090
And then on top of that, you have manual testing.

35
00:02:48,230 --> 00:02:52,210
The thing that you need to remember about this is

36
00:02:52,280 --> 00:02:56,214
that the higher you go

37
00:02:56,252 --> 00:02:59,906
up on this pyramid, the more tests

38
00:03:00,018 --> 00:03:03,622
you have to write in order to validate all

39
00:03:03,676 --> 00:03:07,618
use cases. Think about that a second.

40
00:03:07,804 --> 00:03:11,450
If you have a system that is very complex,

41
00:03:13,230 --> 00:03:16,442
you will need to have an end to end

42
00:03:16,496 --> 00:03:19,500
test that covers every

43
00:03:19,970 --> 00:03:23,678
possible permutation and combination of

44
00:03:23,764 --> 00:03:27,374
use cases of every single feature of

45
00:03:27,412 --> 00:03:30,670
your app in order to have full test

46
00:03:30,740 --> 00:03:34,434
coverage. In order two, do that with

47
00:03:34,472 --> 00:03:37,794
unit tests. However, because you're able to

48
00:03:37,832 --> 00:03:41,460
isolate each component into its own area

49
00:03:41,830 --> 00:03:45,526
and mock out dependencies and just focus on

50
00:03:45,548 --> 00:03:50,002
the logic, you can write many more tests

51
00:03:50,146 --> 00:03:52,360
which take a lot less code,

52
00:03:53,370 --> 00:03:57,706
but give you a

53
00:03:57,728 --> 00:04:01,386
higher amount of assurance that

54
00:04:01,408 --> 00:04:04,614
you have actually covered all the use cases and that there aren't

55
00:04:04,662 --> 00:04:09,274
any edge cases out there waiting to come

56
00:04:09,312 --> 00:04:13,262
back to bite you in the middle of the night. Been there, done that.

57
00:04:13,316 --> 00:04:17,290
Not fun. So unit tests

58
00:04:17,370 --> 00:04:20,622
should be the basis of your

59
00:04:20,676 --> 00:04:23,550
automated testing strategy.

60
00:04:23,710 --> 00:04:27,106
That doesn't mean that you shouldn't have integration tests or end

61
00:04:27,128 --> 00:04:30,482
to end tests. Having some of those is

62
00:04:30,536 --> 00:04:32,980
often a good thing. However,

63
00:04:33,990 --> 00:04:37,990
if you are using end to end tests to

64
00:04:38,140 --> 00:04:41,190
make sure that you don't have to write unit tests,

65
00:04:41,930 --> 00:04:45,750
that's going to be a problem. Now why is that

66
00:04:45,820 --> 00:04:48,620
a problem? Well,

67
00:04:50,110 --> 00:04:53,526
for that I'm going to go two my personal definition of unit

68
00:04:53,558 --> 00:04:56,966
testing, and that is that unit

69
00:04:56,998 --> 00:05:01,178
testing is the process of aligning requirements

70
00:05:01,354 --> 00:05:05,360
with reality. Let that sink in a second.

71
00:05:05,890 --> 00:05:09,194
The process of aligning requirements

72
00:05:09,322 --> 00:05:10,510
with reality.

73
00:05:12,630 --> 00:05:16,738
In this talk, I'm going to be showing you my

74
00:05:16,824 --> 00:05:20,398
style of unit testing, which for lack

75
00:05:20,414 --> 00:05:24,770
of a better term, I'm calling intuitive unit testing pattern.

76
00:05:25,290 --> 00:05:28,518
And I'm going to show you exactly

77
00:05:28,684 --> 00:05:32,438
how requirements are going to

78
00:05:32,444 --> 00:05:36,226
be tying directly to each and every one of your unit tests,

79
00:05:36,418 --> 00:05:43,610
and how you can take your unit test suite

80
00:05:44,110 --> 00:05:47,434
two, a nontechnical stakeholder, and be able

81
00:05:47,472 --> 00:05:51,786
to show them, hey, these are the requirements

82
00:05:51,898 --> 00:05:55,774
for the application as I understand them, am I

83
00:05:55,812 --> 00:05:59,982
correct? And you can sit down and talk

84
00:06:00,036 --> 00:06:04,162
through all of the edge cases that you have

85
00:06:04,216 --> 00:06:09,550
been able to test for. This will provide greater

86
00:06:09,710 --> 00:06:13,662
confidence between the stakeholder and the developer

87
00:06:13,806 --> 00:06:18,374
that everything has been coded correctly and

88
00:06:18,492 --> 00:06:22,454
that you are ready to ship whatever

89
00:06:22,572 --> 00:06:25,000
feature or product that you are building.

90
00:06:28,660 --> 00:06:30,660
If you think a little bit further.

91
00:06:31,800 --> 00:06:34,864
And this ties into the reason why we don't

92
00:06:34,912 --> 00:06:37,590
want to have AI write our tests for us.

93
00:06:38,520 --> 00:06:41,590
If you think about it, most of the time,

94
00:06:41,900 --> 00:06:45,784
if you are able to give an

95
00:06:45,822 --> 00:06:50,360
AI, like Chat GPT, for example, or GitHub Copilot,

96
00:06:51,100 --> 00:06:54,830
a description of the requirements for a function,

97
00:06:56,080 --> 00:06:59,724
it can spew out the code for you in

98
00:06:59,762 --> 00:07:01,310
any language you want.

99
00:07:02,560 --> 00:07:06,280
But in order to get really good

100
00:07:06,370 --> 00:07:10,560
code, you have to be really good at prompt engineering.

101
00:07:11,220 --> 00:07:15,360
In other words, being able to be very specific and

102
00:07:15,430 --> 00:07:18,560
telling the AI exactly what

103
00:07:18,630 --> 00:07:22,788
you expect as the outcome of

104
00:07:22,874 --> 00:07:26,244
the code. Well, if you

105
00:07:26,282 --> 00:07:30,756
take all of the time to do that, you have already done about

106
00:07:30,858 --> 00:07:33,880
90% of unit testing.

107
00:07:34,300 --> 00:07:38,024
If you can define the requirements in

108
00:07:38,062 --> 00:07:42,248
a very plain and easy two understand and

109
00:07:42,414 --> 00:07:45,310
not easily confused way,

110
00:07:46,320 --> 00:07:49,544
you have basically written an outline

111
00:07:49,672 --> 00:07:53,932
for your unit test suite, for the component or class or

112
00:07:54,066 --> 00:07:56,940
whatever function you are testing.

113
00:07:58,100 --> 00:08:01,744
We'll get into that in just a moment here.

114
00:08:01,942 --> 00:08:06,160
But I want you to think about that. We as developers

115
00:08:06,580 --> 00:08:10,004
are paid not because we can

116
00:08:10,042 --> 00:08:13,444
write code in whatever language, not because

117
00:08:13,482 --> 00:08:17,044
we can write the business logic. The AIS can do

118
00:08:17,082 --> 00:08:21,460
that for us now, but we are paid for

119
00:08:21,530 --> 00:08:26,170
our genuinely human focused thought.

120
00:08:27,500 --> 00:08:31,176
And to turn the process

121
00:08:31,358 --> 00:08:34,700
of writing the tests over to an AI

122
00:08:35,360 --> 00:08:38,924
would be to lose out

123
00:08:39,042 --> 00:08:42,750
on a valuable opportunity

124
00:08:43,280 --> 00:08:46,944
that you as a developer can take to make sure

125
00:08:46,982 --> 00:08:50,450
that all of the requirements are well understood by you

126
00:08:51,060 --> 00:08:54,556
and that you can agree with the stakeholders

127
00:08:54,668 --> 00:08:58,240
what those requirements are. That is

128
00:08:58,390 --> 00:09:02,064
super crucial. And I think that unit

129
00:09:02,112 --> 00:09:06,244
testing as a result is one of,

130
00:09:06,362 --> 00:09:09,728
if not the most important skills

131
00:09:09,904 --> 00:09:13,764
for a serious software engineer

132
00:09:13,812 --> 00:09:16,840
to have to be able to have that mindset,

133
00:09:17,500 --> 00:09:21,144
being able to take requirements and break them

134
00:09:21,182 --> 00:09:24,732
down and be able to prove through

135
00:09:24,786 --> 00:09:28,380
automated tests that your code

136
00:09:28,450 --> 00:09:32,030
works the way that you think it does.

137
00:09:32,960 --> 00:09:36,312
Well, enough talk. Let's actually get into

138
00:09:36,466 --> 00:09:40,796
a practical example here. We'll do this thought exercise

139
00:09:40,988 --> 00:09:44,944
and I like to decouple the

140
00:09:44,982 --> 00:09:48,540
ideas that I'm teaching about unit testing

141
00:09:48,620 --> 00:09:52,352
and the thought process that you go through. I like to decouple

142
00:09:52,416 --> 00:09:55,556
that from software in

143
00:09:55,578 --> 00:10:00,180
general because this is really about reasoning with requirements.

144
00:10:00,600 --> 00:10:04,536
So we're going to talk about an object

145
00:10:04,638 --> 00:10:08,664
that hopefully everyone has experience with and can

146
00:10:08,702 --> 00:10:12,360
relate to, and that is going to be a door.

147
00:10:13,420 --> 00:10:17,132
Now, because this is a unit test that we are trying

148
00:10:17,186 --> 00:10:21,164
two achieve here. We don't want to try

149
00:10:21,202 --> 00:10:24,830
to tackle the entire door system at once.

150
00:10:25,280 --> 00:10:29,196
Instead we want to find the smallest

151
00:10:29,388 --> 00:10:33,568
piece that can be interacted with and

152
00:10:33,734 --> 00:10:36,816
test that. So for that,

153
00:10:36,998 --> 00:10:41,488
I'm going to go with the privacy doorknob.

154
00:10:41,664 --> 00:10:45,910
This is the kind of doorknob that you may be able two find

155
00:10:47,080 --> 00:10:51,380
on a bedroom door or a bathroom door. Pretty commonly

156
00:10:51,820 --> 00:10:55,748
some of them will have a turning mechanism

157
00:10:55,844 --> 00:10:59,012
for the lock or a button to push.

158
00:10:59,156 --> 00:11:03,210
This one, we're just going to use this example

159
00:11:04,240 --> 00:11:07,710
that I grabbed off of Amazon of

160
00:11:08,320 --> 00:11:12,200
this door that has a knob

161
00:11:12,280 --> 00:11:15,820
on the outside, on the inside, a push button

162
00:11:15,970 --> 00:11:20,050
and a latch bolt. And we will just focus on that

163
00:11:20,420 --> 00:11:24,800
and start talking about what kinds of requirements

164
00:11:25,220 --> 00:11:29,084
would you expect for this

165
00:11:29,222 --> 00:11:31,940
knob to be working properly.

166
00:11:32,760 --> 00:11:36,372
Okay, so we're going to start

167
00:11:36,426 --> 00:11:40,292
just by writing sentences that

168
00:11:40,346 --> 00:11:44,760
first define the thing, the what that we are testing

169
00:11:45,500 --> 00:11:49,016
and then explain the when we

170
00:11:49,038 --> 00:11:52,760
are doing something to it, we want

171
00:11:52,910 --> 00:11:56,716
this result to happen. So our first sentence that

172
00:11:56,738 --> 00:12:00,156
we can use to describe the behavior is a

173
00:12:00,178 --> 00:12:03,212
privacy doorknob. When the push button is not

174
00:12:03,266 --> 00:12:07,308
pressed and the user turns the inside knob,

175
00:12:07,484 --> 00:12:10,080
should also turn the outside knob.

176
00:12:10,580 --> 00:12:14,770
Okay. Some of you may have

177
00:12:15,700 --> 00:12:19,670
seen sentences like this before

178
00:12:21,000 --> 00:12:24,820
using gerkin or cucumber syntax,

179
00:12:25,640 --> 00:12:29,620
and they will use

180
00:12:29,690 --> 00:12:33,592
like given when then statements to

181
00:12:33,726 --> 00:12:35,770
be able two describe this.

182
00:12:37,660 --> 00:12:40,920
You are more than welcome to use that style.

183
00:12:41,500 --> 00:12:45,724
I think it does help you to kind of things through the

184
00:12:45,842 --> 00:12:49,164
parts of that structured sentence. But I'm just going to

185
00:12:49,202 --> 00:12:53,352
use kind of a more natural language

186
00:12:53,496 --> 00:12:57,090
sentence for my examples here.

187
00:12:57,700 --> 00:13:01,536
So let's add another use case here.

188
00:13:01,638 --> 00:13:04,672
A privacy doorknob. When the push button is not

189
00:13:04,726 --> 00:13:08,956
pressed and the user turns, the inside knob should

190
00:13:09,078 --> 00:13:12,404
retract the latch bolt. So not only is

191
00:13:12,442 --> 00:13:16,180
the outside knob turning, but also the latch bolt is being

192
00:13:16,250 --> 00:13:20,772
retracted when you turn

193
00:13:20,826 --> 00:13:24,536
the knob. Okay, but what

194
00:13:24,558 --> 00:13:27,960
about if you turn it one way versus the other way?

195
00:13:28,110 --> 00:13:31,816
You need to always be thinking, am I being specific

196
00:13:31,918 --> 00:13:35,756
enough? In this case, there are two different ways that you can turn

197
00:13:35,858 --> 00:13:39,420
the knob either clockwise or counterclockwise.

198
00:13:40,320 --> 00:13:44,924
And specifically, you expect the

199
00:13:45,122 --> 00:13:48,928
opposite side of the knob to

200
00:13:49,094 --> 00:13:53,008
be rotated the opposite direction with

201
00:13:53,094 --> 00:13:56,944
respect to an observer from

202
00:13:56,982 --> 00:14:00,512
that side of the door than the direction that you are turning

203
00:14:00,576 --> 00:14:04,244
the other side. So when the inside knob is

204
00:14:04,282 --> 00:14:08,100
turned clockwise, the outside knob should be turned counterclockwise

205
00:14:08,840 --> 00:14:10,500
and vice versa.

206
00:14:12,620 --> 00:14:15,992
Okay, so we are going

207
00:14:16,046 --> 00:14:19,908
two, just keep on piling on some more sentences

208
00:14:20,004 --> 00:14:23,816
here. So I

209
00:14:23,838 --> 00:14:25,770
believe we have both of those.

210
00:14:27,360 --> 00:14:30,684
A privacy doorknob, when the push button is not

211
00:14:30,722 --> 00:14:33,944
pressed, when the user turns the outside knob should retract the latch bolt.

212
00:14:33,992 --> 00:14:38,640
Yes, we had that one already, and now we have both

213
00:14:38,710 --> 00:14:42,432
the clockwise and counterclockwise versions of

214
00:14:42,486 --> 00:14:46,144
those. And you can see at this point we

215
00:14:46,182 --> 00:14:50,240
are getting to have quite a few test cases

216
00:14:50,920 --> 00:14:54,532
and we haven't even really scratched the surface. There's a lot of other things

217
00:14:54,586 --> 00:14:58,710
we need to account for. And so this is

218
00:14:59,240 --> 00:15:02,328
where I like to take a step back. When you

219
00:15:02,414 --> 00:15:06,010
start getting overwhelmed, you start getting a little bit anxious about

220
00:15:06,380 --> 00:15:09,672
how many test cases you are authoring here.

221
00:15:09,806 --> 00:15:13,032
Take a step back. And we

222
00:15:13,086 --> 00:15:16,620
are going to apply some

223
00:15:16,690 --> 00:15:21,016
of our code quality principles

224
00:15:21,048 --> 00:15:24,892
that we already know and love, like dry two these

225
00:15:24,946 --> 00:15:28,944
test cases, we don't want everything to

226
00:15:28,982 --> 00:15:32,732
be so overly wordy that we can't

227
00:15:32,796 --> 00:15:36,336
really scan through and understand what

228
00:15:36,358 --> 00:15:39,250
is happening and what the actual requirements are.

229
00:15:39,720 --> 00:15:43,572
So let's restructure it. To reduce the

230
00:15:43,626 --> 00:15:47,600
duplication. We have a privacy doorknob

231
00:15:47,680 --> 00:15:51,156
when the push button is not pressed, when the user turns the

232
00:15:51,178 --> 00:15:54,970
inside knob clockwise. And then we have two different

233
00:15:55,580 --> 00:16:00,292
outcomes that we are expecting. Should also turn the outside knob counterclockwise

234
00:16:00,356 --> 00:16:04,076
and should retract the latch bolt. This format is

235
00:16:04,098 --> 00:16:07,964
way more palatable already and allows you

236
00:16:08,082 --> 00:16:11,916
to kind of group things

237
00:16:12,018 --> 00:16:14,510
that are set up the same way.

238
00:16:15,600 --> 00:16:20,290
Now, you will notice that we still have some of the results are

239
00:16:21,300 --> 00:16:25,344
duplicated, but that's okay because in

240
00:16:25,382 --> 00:16:29,444
this case, we need to be very specific about

241
00:16:29,482 --> 00:16:33,104
how we want those outcomes to be. And so it's

242
00:16:33,152 --> 00:16:37,316
better to remove the duplication at the beginning of

243
00:16:37,338 --> 00:16:40,784
the requirements and then have multiple

244
00:16:40,832 --> 00:16:44,330
expectations that may be similar,

245
00:16:44,700 --> 00:16:48,120
but should be really easy to reason with.

246
00:16:48,190 --> 00:16:50,650
And we'll see that in just a moment.

247
00:16:52,780 --> 00:16:56,044
With this new structure, we can now expand. We can

248
00:16:56,082 --> 00:17:00,748
look into other use cases, such as when

249
00:17:00,834 --> 00:17:04,940
you have the lock button pressed,

250
00:17:06,160 --> 00:17:10,928
well, you shouldn't be able to turn the outside knob and

251
00:17:11,094 --> 00:17:14,224
you should be able to turn the inside knob, but when you

252
00:17:14,262 --> 00:17:17,616
do, it should pop the

253
00:17:17,638 --> 00:17:21,536
lock button back out. And so we're

254
00:17:21,568 --> 00:17:25,252
just continuing to iterate and to think about, okay,

255
00:17:25,386 --> 00:17:29,044
what are some other things that we could add to

256
00:17:29,162 --> 00:17:33,400
our behavioral spec specification

257
00:17:33,740 --> 00:17:36,200
for this doorknob component?

258
00:17:37,500 --> 00:17:40,970
Okay, so let's think about this also.

259
00:17:41,660 --> 00:17:45,710
What if the door is locked, but it's open,

260
00:17:46,080 --> 00:17:48,728
and someone tries to close the door,

261
00:17:48,904 --> 00:17:52,140
thus pushing against that latch bolt?

262
00:17:52,560 --> 00:17:56,344
Should the latch bolt stay stationary or

263
00:17:56,402 --> 00:17:59,840
should it retract and allow you to close the door,

264
00:18:00,420 --> 00:18:03,648
even though the

265
00:18:03,654 --> 00:18:05,330
knob is in the locked state?

266
00:18:06,660 --> 00:18:08,930
So you need to think about that as well.

267
00:18:12,440 --> 00:18:15,780
There's also some exceptional use cases we should at least

268
00:18:15,850 --> 00:18:20,032
consider. What if the user exerts

269
00:18:20,096 --> 00:18:23,240
way too much force on the knob?

270
00:18:24,300 --> 00:18:30,952
Should it break? Should it give

271
00:18:31,006 --> 00:18:34,128
in at a certain amount of stress?

272
00:18:34,324 --> 00:18:37,804
These are things that you should at least be

273
00:18:37,842 --> 00:18:41,404
aware of. Even if there isn't a

274
00:18:41,442 --> 00:18:45,336
graceful solution for each one of these exceptional

275
00:18:45,368 --> 00:18:48,972
use cases, it may be okay to say that it breaks,

276
00:18:49,116 --> 00:18:52,944
right? But you need to at least be

277
00:18:52,982 --> 00:18:56,528
aware, okay, these are the ways that it can break.

278
00:18:56,614 --> 00:18:58,370
And I'm okay with that.

279
00:19:01,300 --> 00:19:04,832
Now, I said earlier that once you have all of your requirements

280
00:19:04,896 --> 00:19:08,612
together, you have 90% of your unit tests done.

281
00:19:08,746 --> 00:19:12,424
So I'm going to try to make good on that promise as

282
00:19:12,462 --> 00:19:16,536
we transition from this bulleted list of

283
00:19:16,558 --> 00:19:20,040
requirements to actual working unit tests.

284
00:19:20,540 --> 00:19:24,160
So we're going to be using this pattern

285
00:19:24,260 --> 00:19:28,124
called aaa or arrange act assert to

286
00:19:28,162 --> 00:19:31,724
implement our unit tests. And we'll touch

287
00:19:31,762 --> 00:19:33,470
a little bit on that in a second.

288
00:19:34,720 --> 00:19:38,256
But basically a range is all about

289
00:19:38,358 --> 00:19:41,392
what are the preconditions that need

290
00:19:41,526 --> 00:19:45,184
to be fulfilled in order to be able

291
00:19:45,222 --> 00:19:48,416
to run your test case. So all

292
00:19:48,438 --> 00:19:52,420
of those when statements in our requirements,

293
00:19:52,840 --> 00:19:56,340
there's the action, which is actually the last

294
00:19:56,410 --> 00:20:00,272
when statement. So when the knob is turned,

295
00:20:00,416 --> 00:20:03,636
this is the thing that we're not sure whether it's

296
00:20:03,668 --> 00:20:07,624
going to work properly or not, and so we need to test it.

297
00:20:07,742 --> 00:20:12,756
And then the assert is just about observing

298
00:20:12,948 --> 00:20:17,500
the side effects or the return value or whatever

299
00:20:17,650 --> 00:20:21,404
result comes from that action that

300
00:20:21,442 --> 00:20:25,356
you just tested. So we're going to apply this

301
00:20:25,538 --> 00:20:29,264
to a doorknob that I wrote in

302
00:20:29,302 --> 00:20:33,164
Powershell. Don't have to look too carefully

303
00:20:33,212 --> 00:20:37,068
at this because it's

304
00:20:37,084 --> 00:20:40,644
not really about the implementation here that's important.

305
00:20:40,842 --> 00:20:44,992
It's about can your unit tests verify

306
00:20:45,056 --> 00:20:49,764
that the implementation is correct? And I

307
00:20:49,802 --> 00:20:53,624
personally don't write classes in Powershell because

308
00:20:53,662 --> 00:20:57,048
there's a lot of gotchas there very often.

309
00:20:57,214 --> 00:21:00,744
And so this will just kind

310
00:21:00,782 --> 00:21:04,620
of be a sample.

311
00:21:05,840 --> 00:21:08,648
Okay, so in Pester,

312
00:21:08,744 --> 00:21:12,044
which is the unit testing framework of

313
00:21:12,082 --> 00:21:15,310
choice for Powershell, you have

314
00:21:15,760 --> 00:21:19,664
this really great describe context it

315
00:21:19,862 --> 00:21:23,532
structure that you can use. This is called behavior

316
00:21:23,596 --> 00:21:27,184
driven developers. When you're able

317
00:21:27,222 --> 00:21:31,590
to basically use these given when, then type

318
00:21:33,320 --> 00:21:36,240
statements and turn them into tests.

319
00:21:36,400 --> 00:21:40,436
So we're going to fill them out.

320
00:21:40,618 --> 00:21:44,090
First of all, we'll just paste our outline there.

321
00:21:45,020 --> 00:21:48,500
And this is actually admittedly

322
00:21:48,660 --> 00:21:52,072
a part of the implementation that you could use

323
00:21:52,126 --> 00:21:55,944
AI to help with. You just don't want them touching any

324
00:21:55,982 --> 00:22:00,084
of these sentences, you know.

325
00:22:00,142 --> 00:22:03,436
Now we're down to code slinging and AI is pretty good

326
00:22:03,458 --> 00:22:06,796
at that. But wait, because there's

327
00:22:06,828 --> 00:22:09,984
some patterns and gotchas that we're going to cover

328
00:22:10,182 --> 00:22:13,410
that you don't want to just let

329
00:22:14,740 --> 00:22:18,240
the AI go crazy unchecked.

330
00:22:18,840 --> 00:22:23,536
Okay, so we took that first bulleted

331
00:22:23,568 --> 00:22:26,752
list. There we have our outer describe.

332
00:22:26,816 --> 00:22:30,356
We've got a context block now for the

333
00:22:30,378 --> 00:22:34,520
when. And then the cool thing is you can nest these contexts

334
00:22:35,260 --> 00:22:38,952
as deep as you want to. So if you have when this

335
00:22:39,006 --> 00:22:42,216
happens and this happens and this happens, they can all have their

336
00:22:42,238 --> 00:22:46,120
own context. Then you have your three it statements

337
00:22:46,200 --> 00:22:50,364
here and those are going to be kind of the leaves of

338
00:22:50,402 --> 00:22:54,296
your requirements tree. Okay, so we're

339
00:22:54,328 --> 00:22:57,920
just going to zoom into this test

340
00:22:57,990 --> 00:23:01,532
case here and implement that using arrange

341
00:23:01,596 --> 00:23:05,788
act assert. So to arrange there's

342
00:23:05,804 --> 00:23:09,492
a few things we need to do. First of all, we need to bring the

343
00:23:09,546 --> 00:23:13,284
code that we are trying to test into context in

344
00:23:13,322 --> 00:23:17,268
Powershell. We do that by sourcing that file into

345
00:23:17,434 --> 00:23:21,280
this file. Next we're going to

346
00:23:21,370 --> 00:23:24,596
create an instance of that class that we've

347
00:23:24,628 --> 00:23:28,472
created and then we are going to set the

348
00:23:28,526 --> 00:23:32,104
state that we want to test

349
00:23:32,222 --> 00:23:35,420
against. So this is

350
00:23:35,490 --> 00:23:38,360
a test where we're seeing if it's locked.

351
00:23:38,440 --> 00:23:40,940
Someone tries to use the outside knob,

352
00:23:41,760 --> 00:23:45,436
it shouldn't turn. Okay, so the action is the

353
00:23:45,458 --> 00:23:48,272
person trying two do the thing. Right.

354
00:23:48,406 --> 00:23:51,776
So we've got knob turn, outside knob, we're turning it

355
00:23:51,798 --> 00:23:55,490
clockwise. The result that comes out

356
00:23:56,260 --> 00:23:59,524
checking the outside knob property,

357
00:23:59,722 --> 00:24:04,004
it should be null. And just to kind

358
00:24:04,042 --> 00:24:07,430
of, let's see back

359
00:24:08,040 --> 00:24:11,388
on this one here we've

360
00:24:11,424 --> 00:24:15,912
got things.

361
00:24:15,966 --> 00:24:19,960
Knob interaction result is kind of the data structure I put together

362
00:24:20,030 --> 00:24:23,496
for the output of this so there may be an

363
00:24:23,518 --> 00:24:27,388
inside knob, an outside knob, or a latch bolt property

364
00:24:27,474 --> 00:24:30,956
on there describing what happened to them, whether the

365
00:24:30,978 --> 00:24:34,456
inside knob got rotated, the outside knob got rotated, the latch

366
00:24:34,488 --> 00:24:37,824
bolt was

367
00:24:38,022 --> 00:24:41,616
extended or retracted. So basically we

368
00:24:41,638 --> 00:24:47,136
come back here and this

369
00:24:47,158 --> 00:24:51,696
is a pretty good arrange act assert implementation

370
00:24:51,808 --> 00:24:55,332
for our unit test. And it's pretty clear,

371
00:24:55,466 --> 00:24:58,704
if you take a look at it, what the different steps

372
00:24:58,752 --> 00:25:02,292
are. So we can take things and let's do it

373
00:25:02,346 --> 00:25:05,528
with the next two test cases. Things is the

374
00:25:05,534 --> 00:25:08,836
one that we did already. So the setup

375
00:25:08,868 --> 00:25:12,484
is going to be the same for this. So we source

376
00:25:12,532 --> 00:25:15,880
that in, we create the instance,

377
00:25:15,960 --> 00:25:19,304
we press the button, we turn the outside knob.

378
00:25:19,432 --> 00:25:22,956
This time, instead of looking at the outside knob, we're looking at

379
00:25:22,978 --> 00:25:26,440
the inside knob and

380
00:25:26,530 --> 00:25:28,960
that one should also not be turned.

381
00:25:30,500 --> 00:25:34,096
And then for the latch bolt, we do all

382
00:25:34,118 --> 00:25:37,676
the same things again. But instead we're

383
00:25:37,708 --> 00:25:41,856
going to be looking at the latch bolt property. It should remain extended,

384
00:25:41,888 --> 00:25:45,536
it should not retract when someone tries to open the door

385
00:25:45,568 --> 00:25:47,910
when it's locked. Okay,

386
00:25:48,760 --> 00:25:52,072
now this is where things start getting really

387
00:25:52,126 --> 00:25:56,200
cool, is that if you run pester,

388
00:25:56,540 --> 00:26:00,628
and I'm not using the default configuration,

389
00:26:00,724 --> 00:26:04,664
I'm telling it to use the detailed verbosity,

390
00:26:04,792 --> 00:26:08,204
which I really wish was the

391
00:26:08,242 --> 00:26:11,484
default, quite frankly. But look at

392
00:26:11,522 --> 00:26:15,832
what you get coming out of this describing a privacy doorknob.

393
00:26:15,896 --> 00:26:19,616
Context when the push button is pressed. Context when the user tries to

394
00:26:19,638 --> 00:26:23,696
turn the outside knob clockwise, should not turn the outside knob at

395
00:26:23,718 --> 00:26:26,912
all. This is our outline. It's come back

396
00:26:26,966 --> 00:26:30,276
out on the other side of the tests. And now we

397
00:26:30,298 --> 00:26:34,608
can say, yes, this particular requirement

398
00:26:34,784 --> 00:26:38,230
down to the t is fulfilled by our code.

399
00:26:39,000 --> 00:26:42,488
And this is the really exciting thing is when you

400
00:26:42,494 --> 00:26:45,832
can start seeing a bunch of these stacking up and

401
00:26:45,886 --> 00:26:49,112
being able to see all of your requirements coming

402
00:26:49,166 --> 00:26:52,504
to life. Okay,

403
00:26:52,702 --> 00:26:56,124
but it's not all sunshine and

404
00:26:56,162 --> 00:26:59,564
roses, because if we look here,

405
00:26:59,762 --> 00:27:02,956
we have all this duplicated code here.

406
00:27:03,138 --> 00:27:07,164
And if we start getting two tens

407
00:27:07,212 --> 00:27:10,080
and hundreds of unit tests,

408
00:27:10,820 --> 00:27:14,272
having all this extra noise here that's duplicated makes

409
00:27:14,326 --> 00:27:16,924
it way harder to maintain these tests,

410
00:27:17,052 --> 00:27:20,304
especially since we've

411
00:27:20,352 --> 00:27:23,556
already kind of established that all

412
00:27:23,578 --> 00:27:26,960
the tests within things context

413
00:27:27,040 --> 00:27:30,816
here should have a doorknob

414
00:27:30,928 --> 00:27:34,890
and it should have the button pressed already. And so

415
00:27:35,420 --> 00:27:39,624
how do we deduplicate this? We're going to do some

416
00:27:39,662 --> 00:27:43,716
dry principles here. And this is where you get to use

417
00:27:43,838 --> 00:27:48,840
before each loops or before each statements

418
00:27:48,920 --> 00:27:50,300
or functions.

419
00:27:51,600 --> 00:27:55,816
And this is really where we go from normal

420
00:27:55,848 --> 00:27:59,360
unit tests to what I like to call intuitive unit testing.

421
00:28:00,500 --> 00:28:04,144
So we're going to create a before each

422
00:28:04,342 --> 00:28:09,504
block, on every single one of these blocks

423
00:28:09,552 --> 00:28:13,364
here, not inside the it, because there's only one of

424
00:28:13,402 --> 00:28:17,110
those. You can't have anything nested inside of an it.

425
00:28:17,960 --> 00:28:22,090
But inside these before each is, we want to define anything

426
00:28:23,260 --> 00:28:26,376
or do any of the setup that

427
00:28:26,398 --> 00:28:30,104
is required to fulfill what is right above it

428
00:28:30,142 --> 00:28:33,544
here. So a privacy doorknob. In order to have this

429
00:28:33,582 --> 00:28:37,928
fulfilled, we actually need an instance of a privacy doorknob.

430
00:28:38,104 --> 00:28:41,820
So that means we need these two lines in

431
00:28:41,890 --> 00:28:43,150
our before each.

432
00:28:46,000 --> 00:28:50,336
So we got that. And now we

433
00:28:50,358 --> 00:28:54,476
should be able to get rid of all of that duplication

434
00:28:54,668 --> 00:28:56,880
in the other test cases.

435
00:28:58,420 --> 00:28:59,170
Okay.

436
00:29:02,760 --> 00:29:07,924
And we got some extra code there that I

437
00:29:07,962 --> 00:29:11,216
needed to clean up there. Okay, so we've

438
00:29:11,248 --> 00:29:12,680
got our arrange.

439
00:29:15,180 --> 00:29:19,160
We still have knob press button. And you'll notice that

440
00:29:19,230 --> 00:29:22,936
is defined here. So we should do that in

441
00:29:22,958 --> 00:29:26,684
the before each right here. So we're going to move that up

442
00:29:26,722 --> 00:29:29,948
here. And now look at

443
00:29:29,954 --> 00:29:33,390
that. Our range block is completely gone there.

444
00:29:33,760 --> 00:29:34,940
That's weird.

445
00:29:37,460 --> 00:29:38,210
Okay,

446
00:29:41,700 --> 00:29:44,930
let's go ahead and clean all that up.

447
00:29:50,200 --> 00:29:53,936
Okay. And now the next thing that's duplicated

448
00:29:54,048 --> 00:29:57,236
is this, when the user tries to turn

449
00:29:57,258 --> 00:30:01,536
the outside knob clockwise. So we could put that

450
00:30:01,658 --> 00:30:05,144
in here. Now, the one

451
00:30:05,182 --> 00:30:08,616
thing that I don't like about this

452
00:30:08,718 --> 00:30:12,296
is we're kind of just treating this as if

453
00:30:12,318 --> 00:30:16,012
it's just another before each, which is kind of

454
00:30:16,066 --> 00:30:18,990
like our arrange part of our unit test.

455
00:30:20,080 --> 00:30:25,870
And I'd like to be a little bit more specific

456
00:30:28,240 --> 00:30:32,412
and actually point to the fact that this is the action

457
00:30:32,556 --> 00:30:35,984
and you can throw a comment on that. Yeah, I guess that makes sense.

458
00:30:36,022 --> 00:30:39,376
You could do act here, right. But then you'd

459
00:30:39,408 --> 00:30:44,260
have to go like arrange

460
00:30:45,720 --> 00:30:47,910
and arrange. Right.

461
00:30:49,640 --> 00:30:53,240
Another way I like to do it is to just

462
00:30:53,310 --> 00:30:56,856
define the action as

463
00:30:56,958 --> 00:31:01,140
a function, or in Powershell's case, a script block

464
00:31:01,300 --> 00:31:04,540
that you can call whenever you are ready

465
00:31:04,610 --> 00:31:08,364
for that. And so we

466
00:31:08,402 --> 00:31:12,350
have different actions that we can do.

467
00:31:13,200 --> 00:31:17,484
Maybe we do the outside knob here, but inside this context,

468
00:31:17,532 --> 00:31:22,256
we could also do the inside knob. But this

469
00:31:22,278 --> 00:31:25,520
is where we're actually defining our action.

470
00:31:26,260 --> 00:31:29,716
And sometimes that might be at the very top, depending on how your

471
00:31:29,738 --> 00:31:33,120
test is structured. If you're testing a class versus

472
00:31:33,200 --> 00:31:35,780
just a function or a script file.

473
00:31:37,240 --> 00:31:40,916
But since this is where we are basically saying what

474
00:31:40,938 --> 00:31:45,144
the action is, this is

475
00:31:45,182 --> 00:31:49,400
where the before each is. And I'm just going to put action

476
00:31:49,740 --> 00:31:53,256
equals, and I'm going to put

477
00:31:53,278 --> 00:31:56,984
a script block here. And so I'm

478
00:31:57,032 --> 00:31:59,710
going to paste that into there.

479
00:32:00,640 --> 00:32:04,636
And then we

480
00:32:04,658 --> 00:32:08,476
can say invoke expression

481
00:32:08,668 --> 00:32:14,236
or sorry, it's invoke command script

482
00:32:14,428 --> 00:32:17,360
block action.

483
00:32:18,740 --> 00:32:22,644
And that's how you run a script block. So here

484
00:32:22,682 --> 00:32:26,416
it doesn't make quite as much sense because we just define

485
00:32:26,448 --> 00:32:29,796
it here and then we immediately call it. But if you had this

486
00:32:29,898 --> 00:32:34,000
action defined up here because

487
00:32:34,090 --> 00:32:37,496
you were only testing a single function, but then you had a bunch of

488
00:32:37,518 --> 00:32:41,224
different setup steps, it would be nice to

489
00:32:41,262 --> 00:32:44,552
say this is my action, it's already out of the way,

490
00:32:44,686 --> 00:32:49,064
and then I don't have to worry about it until I'm ready to basically execute

491
00:32:49,112 --> 00:32:51,310
that action. Okay,

492
00:32:52,800 --> 00:32:56,296
so I'm going to put that back like this since that's not the case for

493
00:32:56,338 --> 00:32:58,080
things particular test suite.

494
00:33:01,140 --> 00:33:04,496
And another thing that we probably will want

495
00:33:04,518 --> 00:33:07,968
two do, and I can go through and clean these up.

496
00:33:08,054 --> 00:33:11,270
You can see that we've basically gone from,

497
00:33:11,880 --> 00:33:15,556
what was it like eight to twelve lines per test case. We're down

498
00:33:15,578 --> 00:33:19,220
to just one in each it. And it's just a single assert

499
00:33:19,880 --> 00:33:22,952
that ties into this

500
00:33:23,006 --> 00:33:26,196
statement here should not turn the outside knob at all. And you're

501
00:33:26,228 --> 00:33:29,690
just basically translating that statement into code

502
00:33:31,340 --> 00:33:34,828
as an assertion. Okay.

503
00:33:34,994 --> 00:33:37,630
One of the other things that I'll generally do,

504
00:33:38,800 --> 00:33:42,670
and this is very specific to pester, is that

505
00:33:43,440 --> 00:33:46,736
sometimes the scope between

506
00:33:46,838 --> 00:33:50,304
these different script blocks can

507
00:33:50,342 --> 00:33:53,980
get kind of weird. In earlier versions of Pester,

508
00:33:54,060 --> 00:33:58,144
you could define things outside here like

509
00:33:58,262 --> 00:34:01,430
my VAR equals two.

510
00:34:03,720 --> 00:34:07,472
I promise I can type. But in the latest

511
00:34:07,536 --> 00:34:11,280
versions of pastor, this will basically be completely

512
00:34:11,370 --> 00:34:14,856
invisible to your tests. All it will see are things that

513
00:34:14,878 --> 00:34:18,552
are inside your before each and your

514
00:34:18,606 --> 00:34:21,736
it. And that's it.

515
00:34:21,918 --> 00:34:25,560
So because of the PS script analyzer

516
00:34:25,640 --> 00:34:29,404
saying oh no, things aren't being used and

517
00:34:29,522 --> 00:34:32,776
I can't remember, maybe sometimes it actually doesn't carry

518
00:34:32,808 --> 00:34:36,156
over the scope the way that I expect it

519
00:34:36,178 --> 00:34:41,040
to. I like two turn these variables into script scoped,

520
00:34:42,420 --> 00:34:46,160
which means that these variables

521
00:34:48,340 --> 00:34:52,870
will live during the entire lifetime of

522
00:34:53,480 --> 00:34:56,756
this script file. And so you don't have to worry if you're

523
00:34:56,778 --> 00:35:03,784
in a script block or in some

524
00:35:03,822 --> 00:35:07,512
other weird situation, you can just put

525
00:35:07,566 --> 00:35:11,060
script on there and then now you don't have to worry

526
00:35:11,140 --> 00:35:13,880
about the scoping of those variables.

527
00:35:15,600 --> 00:35:19,352
Okay. And then I'll bring script

528
00:35:19,416 --> 00:35:22,632
onto here as well so that we don't have to worry about the scoping

529
00:35:22,696 --> 00:35:23,310
there.

530
00:35:26,820 --> 00:35:29,970
And paste. There we go.

531
00:35:31,060 --> 00:35:34,944
Okay, so this is good to generalize it

532
00:35:34,982 --> 00:35:38,130
just a little bit further. I like to

533
00:35:38,920 --> 00:35:42,676
use some terms. So we've already got action here

534
00:35:42,778 --> 00:35:46,320
for that to kind of identify.

535
00:35:46,400 --> 00:35:50,500
This is the action part of our arrange act assert.

536
00:35:52,860 --> 00:35:56,584
But you also can do some other things, like instead

537
00:35:56,622 --> 00:36:00,136
of calling this script knob, you can be a

538
00:36:00,158 --> 00:36:04,272
little bit more descriptive in the testing vernacular

539
00:36:04,356 --> 00:36:08,088
and say that this is our subject

540
00:36:08,184 --> 00:36:09,980
under test sut.

541
00:36:11,680 --> 00:36:14,876
And so that is saying that in this

542
00:36:14,978 --> 00:36:17,960
test case, things is the test subject.

543
00:36:18,040 --> 00:36:21,728
It is the thing that we are going to be acting on

544
00:36:21,814 --> 00:36:25,456
in our action. And so that's kind of a

545
00:36:25,478 --> 00:36:29,204
good like checking over things and making sure that things are

546
00:36:29,242 --> 00:36:33,236
right. Does your action function or

547
00:36:33,258 --> 00:36:37,524
script block call something on the subject under test?

548
00:36:37,642 --> 00:36:41,140
If not, you might be accidentally testing your own test

549
00:36:41,210 --> 00:36:44,920
or testing your own mocks, which will lead

550
00:36:44,990 --> 00:36:48,890
to a lot of problems there

551
00:36:51,260 --> 00:36:54,444
and then. Yeah, this is just a nice way

552
00:36:54,482 --> 00:36:57,804
of assigning a variable outside of that that you

553
00:36:57,842 --> 00:36:59,950
can assert against.

554
00:37:01,040 --> 00:37:04,364
So this is pretty cool. And with

555
00:37:04,482 --> 00:37:08,210
this in place, we really could

556
00:37:09,300 --> 00:37:14,000
continue to implement the rest of these really easily

557
00:37:14,580 --> 00:37:18,144
as long as we keep putting in those before each

558
00:37:18,182 --> 00:37:22,612
blocks where they make sense and things

559
00:37:22,666 --> 00:37:26,352
just kind of become very intuitive and very easy to implement

560
00:37:26,416 --> 00:37:28,500
as far as the testing is concerned.

561
00:37:29,400 --> 00:37:33,400
Things are not cluttered, things are not duplicate.

562
00:37:34,620 --> 00:37:38,420
You can come through here, if you were to get a test failure,

563
00:37:38,580 --> 00:37:41,944
you would know exactly where to go and what

564
00:37:41,982 --> 00:37:45,372
was failing and why without having

565
00:37:45,426 --> 00:37:49,116
to interpret lots of error messages. So to

566
00:37:49,138 --> 00:37:52,684
recap, the intuitive testing pattern as it

567
00:37:52,722 --> 00:37:56,124
applies to Powershell and pester is you

568
00:37:56,162 --> 00:37:59,980
always want to have a before each block,

569
00:38:00,560 --> 00:38:03,920
inside of each, right inside of each describe,

570
00:38:04,580 --> 00:38:08,880
inside of each context and

571
00:38:09,030 --> 00:38:12,544
things is where you're going to do all of your arrange

572
00:38:12,592 --> 00:38:15,540
steps and define your action.

573
00:38:16,120 --> 00:38:19,732
And once you've gotten to the point where you are

574
00:38:19,786 --> 00:38:22,760
to the innermost context,

575
00:38:23,500 --> 00:38:26,120
you can invoke that action.

576
00:38:28,460 --> 00:38:31,930
The its should be one liners if at all possible.

577
00:38:33,340 --> 00:38:39,368
Even though it's possible to have lots of different assertions

578
00:38:39,464 --> 00:38:42,030
in the same test,

579
00:38:42,480 --> 00:38:46,236
it's not great. It would be better to make an it that has

580
00:38:46,258 --> 00:38:50,800
a good description as the name and then have a one liner expectation.

581
00:38:53,620 --> 00:38:57,712
It does take a little bit of getting used to to think about

582
00:38:57,846 --> 00:39:01,284
writing tests things way. But I found that this,

583
00:39:01,402 --> 00:39:04,596
whether I'm writing in Powershell or Javascript or c

584
00:39:04,618 --> 00:39:07,876
sharp or whatever language I happen to

585
00:39:07,898 --> 00:39:11,460
be working in that day, this pattern

586
00:39:12,060 --> 00:39:15,304
works really, really well and will help

587
00:39:15,342 --> 00:39:18,600
you to be very successful when testing.

588
00:39:20,380 --> 00:39:24,264
So I hope you now understand why

589
00:39:24,302 --> 00:39:27,736
it is that we don't want to just hand over the task

590
00:39:27,768 --> 00:39:31,116
of unit testing two an AI. If I were two, go to

591
00:39:31,138 --> 00:39:34,876
Chat GPT right now and tell it to write me a

592
00:39:34,898 --> 00:39:37,920
unit test suite for a doorknob.

593
00:39:39,060 --> 00:39:43,088
It is unlikely that we would get the same level

594
00:39:43,174 --> 00:39:47,088
of maintainability in the output, because a lot of the training

595
00:39:47,174 --> 00:39:50,496
data is based on unit

596
00:39:50,528 --> 00:39:54,576
tests that were not written this way. And unfortunately,

597
00:39:54,768 --> 00:39:57,984
one of the big barriers to unit testing

598
00:39:58,112 --> 00:40:01,816
is the precedent of a lot of

599
00:40:01,918 --> 00:40:05,860
duplicate code, a lot of test names

600
00:40:06,020 --> 00:40:09,272
that don't actually tie to requirements, but is

601
00:40:09,326 --> 00:40:12,490
like something like test one. Right?

602
00:40:13,260 --> 00:40:16,716
I know you've seen that in code basis before. I've seen it

603
00:40:16,738 --> 00:40:20,476
so many places. That is the

604
00:40:20,498 --> 00:40:24,380
input for the AIS. And until the AIs

605
00:40:25,760 --> 00:40:29,360
are trained in how to write

606
00:40:29,430 --> 00:40:31,970
tests in an intuitive way like this,

607
00:40:33,300 --> 00:40:36,848
I wouldn't trust the AI to write your tests for you.

608
00:40:37,014 --> 00:40:40,672
But again, the requirements gathering

609
00:40:40,736 --> 00:40:44,196
step, regardless of how well the AI can

610
00:40:44,218 --> 00:40:47,684
churn out the code in the right format, you want

611
00:40:47,722 --> 00:40:51,060
to be in charge of your product's requirements.

612
00:40:51,660 --> 00:40:55,336
That is why you are a

613
00:40:55,358 --> 00:40:58,920
human and not a computer writing software.

614
00:41:01,020 --> 00:41:04,508
Before we wrap up, let's talk about one more important thing,

615
00:41:04,594 --> 00:41:08,030
which is how to make sure that you don't over test,

616
00:41:09,600 --> 00:41:13,224
making superfluous test cases that don't

617
00:41:13,272 --> 00:41:17,250
actually add any actual value to your

618
00:41:17,780 --> 00:41:21,104
confidence level. Let's consider this

619
00:41:21,142 --> 00:41:25,872
powershell function called remove vowel takes

620
00:41:25,926 --> 00:41:29,480
in a string that is the input,

621
00:41:29,660 --> 00:41:33,220
and it'll output a string that is

622
00:41:33,290 --> 00:41:37,280
the same as the input string, but having removed

623
00:41:37,360 --> 00:41:39,700
any vowel characters.

624
00:41:40,360 --> 00:41:43,816
Okay, so the things that you

625
00:41:43,838 --> 00:41:47,624
should be testing empty string as

626
00:41:47,742 --> 00:41:51,592
kind of a test boundary case. Yeah.

627
00:41:51,646 --> 00:41:56,188
What if somebody passes in null or an empty value or

628
00:41:56,274 --> 00:41:59,644
just a value with nothing but

629
00:41:59,762 --> 00:42:01,870
white space in it? Right.

630
00:42:03,040 --> 00:42:07,036
You should test a small string with some vowels, a small string

631
00:42:07,068 --> 00:42:10,700
with only vowels, a small string with no vowels,

632
00:42:10,860 --> 00:42:14,252
a very large string. Make sure that performance wise,

633
00:42:14,316 --> 00:42:17,824
it doesn't have problems. And then you can also

634
00:42:17,862 --> 00:42:21,264
throw in a string with complex unit code characters

635
00:42:21,312 --> 00:42:24,656
like emoji or other languages

636
00:42:24,848 --> 00:42:27,988
that you wouldn't necessarily expect.

637
00:42:28,154 --> 00:42:32,264
But you should know what's going to happen if

638
00:42:32,302 --> 00:42:35,864
you throw something like that at you. The world is getting

639
00:42:35,902 --> 00:42:39,690
a lot more international every day, and you should be

640
00:42:40,140 --> 00:42:42,840
not just thinking about your current locale,

641
00:42:44,320 --> 00:42:48,124
but that being said, you don't see

642
00:42:48,162 --> 00:42:51,740
in things list that we should test it with every

643
00:42:51,810 --> 00:42:55,020
possible combination of letters.

644
00:42:55,360 --> 00:42:59,344
Right. That's not really feasible. It doesn't make sense to

645
00:42:59,382 --> 00:43:02,288
do that. Instead,

646
00:43:02,454 --> 00:43:07,120
you're looking at classes of input and

647
00:43:07,270 --> 00:43:10,916
making sure that you have a test case that

648
00:43:10,938 --> 00:43:14,660
will cover each of those classes of input.

649
00:43:15,320 --> 00:43:18,710
Okay, so with that,

650
00:43:19,640 --> 00:43:22,776
I know that there is so much more that we

651
00:43:22,798 --> 00:43:26,564
could cover. We've just barely scratched the surface.

652
00:43:26,612 --> 00:43:29,752
But what I really wanted to do today was

653
00:43:29,806 --> 00:43:33,336
help you to understand how unit testing can

654
00:43:33,358 --> 00:43:35,900
actually be an exciting and fun thing to do,

655
00:43:36,050 --> 00:43:38,700
rather than feeling like it's a chore,

656
00:43:40,720 --> 00:43:43,950
but yeah, we could have easily gone over

657
00:43:44,480 --> 00:43:47,984
how to implement this in continuous integration and

658
00:43:48,022 --> 00:43:51,456
continuous deployment pipelines as

659
00:43:51,478 --> 00:43:55,488
this is a DevOps conference, but I felt like this probably

660
00:43:55,574 --> 00:43:58,764
will benefit you guys more in the long

661
00:43:58,822 --> 00:44:02,532
term if you get things idea that

662
00:44:02,586 --> 00:44:06,820
unit testing is important and it's fun and

663
00:44:06,890 --> 00:44:09,190
you're not going to be perfect at it right away.

664
00:44:10,040 --> 00:44:13,944
Try going through the same process that we've gone through today with

665
00:44:13,982 --> 00:44:17,944
the doorknob and going from distilling your

666
00:44:17,982 --> 00:44:22,120
requirements down to arrange, act, assert, and finally

667
00:44:22,270 --> 00:44:26,424
into the intuitive testing patterns that we've demonstrated

668
00:44:26,472 --> 00:44:30,444
here. Just keep on practicing and you'll get better

669
00:44:30,562 --> 00:44:34,364
and your code will get better. You'll start thinking about

670
00:44:34,402 --> 00:44:38,444
those edge cases a lot more than you did previously,

671
00:44:38,572 --> 00:44:41,360
and your code is going two be a whole lot more robust.

672
00:44:43,300 --> 00:44:47,250
So thank you so much for watching again,

673
00:44:47,780 --> 00:44:49,830
feel free to contact me.

674
00:44:52,360 --> 00:44:55,780
I basically do this kind of thing full time,

675
00:44:55,930 --> 00:44:59,808
helping out other developers learn how to up their skills

676
00:44:59,904 --> 00:45:03,704
and up their game, and so feel free to reach out.

677
00:45:03,902 --> 00:45:08,244
And I'd be happy to repeat

678
00:45:08,292 --> 00:45:11,608
some of this and tailor it to

679
00:45:11,694 --> 00:45:16,472
your specific team's needs if

680
00:45:16,526 --> 00:45:20,040
you would like something like that. Again, thank you for Conf

681
00:45:20,110 --> 00:45:24,104
42, for letting me speak here,

682
00:45:24,222 --> 00:45:27,856
and I hope you guys have a great time at the

683
00:45:27,878 --> 00:45:32,012
rest of the conference and good luck. Unit testing

684
00:45:32,156 --> 00:45:32,540
see ya.

