1
00:00:38,930 --> 00:00:42,694
Hi everyone and welcome to thanks for

2
00:00:42,732 --> 00:00:47,190
all Kubernetes Ingress API long life to Gateway API.

3
00:00:47,850 --> 00:00:51,498
And I'd say yes, the name in the foreground

4
00:00:51,594 --> 00:00:54,960
describes pretty well, which is the current situation.

5
00:00:55,730 --> 00:01:00,430
But stop any spoiler. Let's start instead the git API adventure

6
00:01:00,930 --> 00:01:04,802
just words about me my name is Yuri and

7
00:01:04,856 --> 00:01:08,882
this is absolutely my cave where I usually write small

8
00:01:08,936 --> 00:01:12,846
tech articles, tech tips, my suggested readings

9
00:01:13,038 --> 00:01:15,910
and travel and sport adventures.

10
00:01:16,250 --> 00:01:19,894
So if you want you can take note of it and

11
00:01:20,092 --> 00:01:22,920
for any reasons you can reach me.

12
00:01:23,930 --> 00:01:27,190
Of course, also to talk about Gateway API,

13
00:01:27,530 --> 00:01:31,526
the first very question is

14
00:01:31,708 --> 00:01:35,740
why, Yuri, are you about to tell us all these things?

15
00:01:36,510 --> 00:01:40,234
And the answer is exactly in front of us.

16
00:01:40,352 --> 00:01:44,406
So since October 2023, our lovely

17
00:01:44,518 --> 00:01:48,110
kubernetes in recipe has been frozen. Yes,

18
00:01:48,180 --> 00:01:51,066
you heard well, has been frozen.

19
00:01:51,178 --> 00:01:54,354
So what it means, it means that no features will be

20
00:01:54,392 --> 00:01:58,606
added anymore to ingress in favor to the new Gateway

21
00:01:58,638 --> 00:02:02,514
API standard. This is a screenshot from

22
00:02:02,552 --> 00:02:06,580
the official Kubernetes Ingress API that you can check also

23
00:02:06,950 --> 00:02:11,010
on. What I suppose is that the frozen

24
00:02:11,090 --> 00:02:14,850
word has been carefully chosen to avoid

25
00:02:15,010 --> 00:02:18,714
riots from kubernetes users and

26
00:02:18,912 --> 00:02:22,038
I suppose then will be softly,

27
00:02:22,134 --> 00:02:26,154
then be deprecated. But this is an

28
00:02:26,192 --> 00:02:29,514
opinion of mine, so take note of it.

29
00:02:29,712 --> 00:02:33,342
But anyway, don't panic. So for who

30
00:02:33,396 --> 00:02:35,760
doesn't know this quote yet,

31
00:02:36,850 --> 00:02:40,960
I don't really know what to say to use

32
00:02:41,970 --> 00:02:45,730
today. I want to be a good guy and live here on the bottom

33
00:02:45,800 --> 00:02:49,394
right, the most awesome book that I ever read in

34
00:02:49,432 --> 00:02:52,926
my life, which is the it kicker's

35
00:02:52,958 --> 00:02:56,974
guide to the galaxy or the italian version,

36
00:02:57,102 --> 00:03:00,610
Vida Galactica per Lee autostopisti.

37
00:03:01,350 --> 00:03:04,534
So don't disparate. I'm here to tell you as

38
00:03:04,572 --> 00:03:08,022
much information as possible regarding the rise of

39
00:03:08,076 --> 00:03:12,154
Gateway API. And today the

40
00:03:12,192 --> 00:03:16,390
adventure will cover very quickly what is Ingress?

41
00:03:16,550 --> 00:03:20,054
And then the introduction to Gateway API.

42
00:03:20,182 --> 00:03:23,838
And we will see next a demo

43
00:03:24,004 --> 00:03:27,710
regarding how to use Gateway API on Google Cloud

44
00:03:27,780 --> 00:03:31,966
platform. And we will finish with a summary a

45
00:03:31,988 --> 00:03:35,578
brief history of Ingress before the Gateway

46
00:03:35,594 --> 00:03:39,982
API introduction, I had to prepare a few slides regarding

47
00:03:40,046 --> 00:03:43,842
Ingress API, mainly for two reasons. The first

48
00:03:43,896 --> 00:03:47,430
one is that to understand why

49
00:03:47,580 --> 00:03:50,806
Gateway API was born, we have to do a

50
00:03:50,828 --> 00:03:54,102
brief history of Ingress. And then the second one

51
00:03:54,156 --> 00:03:57,634
that we owe it to it a crif history.

52
00:03:57,772 --> 00:04:02,090
So 2015 Kubernetes introduces Ingress API.

53
00:04:02,670 --> 00:04:06,986
This is exactly the same year where Kubernetes 10

54
00:04:07,088 --> 00:04:11,098
was released, and then 2020 Ingress

55
00:04:11,274 --> 00:04:15,258
API became stable. What was the aim?

56
00:04:15,354 --> 00:04:19,322
And the aim of ingress was to create an API object to solve

57
00:04:19,386 --> 00:04:23,314
a very specific and basic problem.

58
00:04:23,432 --> 00:04:26,974
So the management of HTTP external

59
00:04:27,022 --> 00:04:30,514
access to our workloads running. Of course on

60
00:04:30,552 --> 00:04:33,998
Kubernetes Ingress API

61
00:04:34,094 --> 00:04:37,622
operates on layer seven, even if during time

62
00:04:37,756 --> 00:04:40,342
many implementation on layer three,

63
00:04:40,396 --> 00:04:43,846
four have been implemented. But the

64
00:04:43,868 --> 00:04:47,590
layer seven is the main purpose of ingresses and

65
00:04:47,660 --> 00:04:51,290
the portability of course, when it is

66
00:04:51,360 --> 00:04:54,774
used in its very basic way. So the basic

67
00:04:54,822 --> 00:04:58,426
way, as we will see next, it is not usually enough

68
00:04:58,528 --> 00:05:02,080
in real world scenario how ingress works.

69
00:05:02,610 --> 00:05:05,934
Let's first of all imagine to

70
00:05:05,972 --> 00:05:09,934
connect to a Kubernetes cluster and apply the

71
00:05:09,972 --> 00:05:13,714
yaml template on the right for who

72
00:05:13,832 --> 00:05:17,294
don't really know it. This is the most common way to expose

73
00:05:17,342 --> 00:05:21,266
HTTP service on a Kubernetes system. It basically

74
00:05:21,368 --> 00:05:25,590
describes in a declarative way, a simple way,

75
00:05:25,740 --> 00:05:28,760
how we want to expose what.

76
00:05:29,130 --> 00:05:33,238
So in this case we are trying to expose our service one,

77
00:05:33,404 --> 00:05:37,160
on hostname HTTPs example

78
00:05:38,010 --> 00:05:41,100
four, apply it,

79
00:05:41,630 --> 00:05:45,020
but against the loads nothing will happen.

80
00:05:45,470 --> 00:05:49,178
So we missed something. And what we

81
00:05:49,344 --> 00:05:53,226
missed we missed mainly the ingress control

82
00:05:53,338 --> 00:05:56,922
character. So the ingress

83
00:05:56,986 --> 00:06:00,766
controller is who really makes it happen.

84
00:06:00,868 --> 00:06:04,542
So putting all together in this diagram, we can see how ingress

85
00:06:04,606 --> 00:06:08,862
controller continuously watch for new Kubernetes ingress

86
00:06:08,926 --> 00:06:12,978
that we saw before here and

87
00:06:13,144 --> 00:06:16,626
then register the new configuration

88
00:06:16,738 --> 00:06:20,040
and be ready to serve the traffic coming from the outside,

89
00:06:21,290 --> 00:06:25,138
which is usually this external traffic,

90
00:06:25,234 --> 00:06:28,254
first ingested from an external load balancer,

91
00:06:28,402 --> 00:06:33,290
usually managed on a cloud platform solution,

92
00:06:34,670 --> 00:06:38,102
and then forwarded the traffic to our ingress

93
00:06:38,166 --> 00:06:41,822
controller. This traffic is usually also

94
00:06:41,956 --> 00:06:45,742
called as north south. So the traffic that

95
00:06:45,796 --> 00:06:49,758
comes from the outside and go down to the inside.

96
00:06:49,924 --> 00:06:53,998
On the contrary, the west s traffic is

97
00:06:54,084 --> 00:06:57,502
the traffic that is covered by

98
00:06:57,556 --> 00:07:00,740
pod to pod communication. So the internal one,

99
00:07:01,110 --> 00:07:04,882
what's wrong with ingress? Well, basically I'd say

100
00:07:04,936 --> 00:07:08,614
nothing. As we said before, it solved for

101
00:07:08,652 --> 00:07:12,246
many, it is still solving a

102
00:07:12,268 --> 00:07:16,166
very basic and specific problem, which is HTTP routing in

103
00:07:16,188 --> 00:07:19,690
a very basic way and

104
00:07:19,840 --> 00:07:23,718
also giving to ingress controller provider

105
00:07:23,814 --> 00:07:27,210
implementator the possibility to customize it

106
00:07:27,280 --> 00:07:31,742
to use ingress in real world scenario built

107
00:07:31,796 --> 00:07:35,390
with the increase of modern complexity of

108
00:07:35,460 --> 00:07:39,550
our system, the multitenancy needs

109
00:07:39,620 --> 00:07:43,760
of kubernetes infrastructure, the multi cloud

110
00:07:44,150 --> 00:07:47,362
environments, the need, the real need

111
00:07:47,416 --> 00:07:48,770
of portability,

112
00:07:51,190 --> 00:07:54,762
these ended for the poor ingress

113
00:07:54,926 --> 00:07:58,322
to have a lack of native advanced

114
00:07:58,386 --> 00:08:02,370
usage. So for example, not path rewriting

115
00:08:02,450 --> 00:08:06,200
is available in a native way. So we

116
00:08:06,810 --> 00:08:10,134
ended to be locked

117
00:08:10,182 --> 00:08:13,670
in, in a lot of provider specific configuration.

118
00:08:13,750 --> 00:08:17,530
I mean the hundreds of ingress annotation

119
00:08:18,590 --> 00:08:23,150
available from every ingress controller implementations

120
00:08:23,650 --> 00:08:27,680
and most importantly the third one, the lack of

121
00:08:28,210 --> 00:08:32,126
role orientation. So the main problem here is

122
00:08:32,228 --> 00:08:35,698
as well as we will see next, is that

123
00:08:35,784 --> 00:08:39,506
ingress configuration reside all in

124
00:08:39,528 --> 00:08:44,398
the same file. So for example developers

125
00:08:44,494 --> 00:08:47,234
has to deal with TLS configuration,

126
00:08:47,362 --> 00:08:52,150
hostnames configuration and

127
00:08:52,220 --> 00:08:56,230
of course routing. How we survived

128
00:08:56,890 --> 00:09:00,486
as said before, each ingress controller has taken its path

129
00:09:00,518 --> 00:09:04,620
defining its property way

130
00:09:05,630 --> 00:09:10,022
with annotation ingress annotation to enrich

131
00:09:10,166 --> 00:09:14,758
Ingress API features.

132
00:09:14,934 --> 00:09:18,890
So we ended to enrich our Ingress YAML configuration

133
00:09:18,970 --> 00:09:22,350
with a lot of custom configuration,

134
00:09:22,930 --> 00:09:26,962
sometimes also unstable over the time that the

135
00:09:27,016 --> 00:09:30,130
ingress annotation that as said before carried us

136
00:09:30,200 --> 00:09:34,734
to a cloud, not cloud but Ingress controller provider

137
00:09:34,782 --> 00:09:39,862
lock in allowing to the big picture I

138
00:09:39,916 --> 00:09:44,440
want here to underline how also

139
00:09:45,930 --> 00:09:49,590
meshes are another important component

140
00:09:50,170 --> 00:09:53,962
allowing to the big picture and

141
00:09:54,016 --> 00:09:57,558
I want to mention it because it will be useful

142
00:09:57,654 --> 00:10:01,674
then in the next slides which

143
00:10:01,712 --> 00:10:05,994
is of course serving mesh. An important brick in modern complex

144
00:10:06,122 --> 00:10:10,330
application and in the pioneer

145
00:10:10,410 --> 00:10:14,670
of meshes has been course istio.

146
00:10:14,830 --> 00:10:18,514
Thanks to service meshes we have been

147
00:10:18,552 --> 00:10:22,020
able to pull off from our application

148
00:10:22,470 --> 00:10:26,534
a lot of networking logic and delegate all

149
00:10:26,572 --> 00:10:30,438
this stuff to of course service

150
00:10:30,524 --> 00:10:34,470
smash configuration. So leave inside application

151
00:10:34,620 --> 00:10:36,470
only business logic.

152
00:10:37,870 --> 00:10:41,958
I mean for example delegate to service smash,

153
00:10:42,054 --> 00:10:45,558
TLS, termination, mutual authentication,

154
00:10:45,734 --> 00:10:48,874
throttling circuit breaker and so

155
00:10:48,912 --> 00:10:53,546
on. Let's do warm welcome to Gateway API

156
00:10:53,738 --> 00:10:57,262
like an ID card, I'd like to see

157
00:10:57,396 --> 00:11:01,326
who is it? Gatewaypi is an open source project managed by

158
00:11:01,348 --> 00:11:04,574
the SIG network community. Who is the SIG network

159
00:11:04,622 --> 00:11:09,346
community or who doesn't know it? It is a network special

160
00:11:09,528 --> 00:11:13,198
interest network group which is officially

161
00:11:13,294 --> 00:11:17,046
recognized by Kubernetes itself as a contributor to a lot

162
00:11:17,068 --> 00:11:20,774
of Kubernetes subsystems, for example

163
00:11:20,892 --> 00:11:24,854
DNS, Ingress network plugins, network policy,

164
00:11:24,972 --> 00:11:28,582
and now also Gateway API. Gateway PI

165
00:11:28,646 --> 00:11:32,842
has reached its very first stability on 31

166
00:11:32,896 --> 00:11:37,260
October 2023, and you probably

167
00:11:38,830 --> 00:11:41,760
are thinking the same thing.

168
00:11:42,290 --> 00:11:45,694
Maybe as me it was a

169
00:11:45,732 --> 00:11:48,880
trick or treat. We will see next.

170
00:11:49,650 --> 00:11:53,058
Again, a lot of clap for fans for

171
00:11:53,144 --> 00:11:56,834
Gateway API. I want also to leave here a

172
00:11:56,872 --> 00:12:00,238
Spotify episode from the Kubernetes podcast

173
00:12:00,334 --> 00:12:03,566
by Google that you can find of course on Spotify.

174
00:12:03,758 --> 00:12:07,800
The guest was Rob Scott, a software engineer at Google

175
00:12:08,330 --> 00:12:12,040
and the lead of the SIG network Gateway API project.

176
00:12:12,970 --> 00:12:16,390
Here. Rob tells us a lot of interesting

177
00:12:16,540 --> 00:12:20,086
things regarding Gateway API. Let's deep

178
00:12:20,118 --> 00:12:24,374
dive a little bit more into Gateway API.

179
00:12:24,502 --> 00:12:28,906
Gateway API is basically a

180
00:12:28,928 --> 00:12:32,238
collection of new customer resources. We can mention,

181
00:12:32,324 --> 00:12:36,042
for example, gateway class, Gateway HTTP route,

182
00:12:36,106 --> 00:12:38,880
TCP route, and many others.

183
00:12:39,570 --> 00:12:43,442
On the right diagram you can immediately see how

184
00:12:43,576 --> 00:12:46,786
Gateway API was thinking, and was thinking

185
00:12:46,888 --> 00:12:50,322
to be more role oriented. First of all,

186
00:12:50,456 --> 00:12:53,970
where for example, infrastructure provider

187
00:12:54,890 --> 00:12:59,046
takes care of the concept to the gateway class that

188
00:12:59,068 --> 00:13:03,302
we will see next. Cluster operator instead takes care

189
00:13:03,356 --> 00:13:07,650
of the gateway concept that again we will see next here.

190
00:13:07,820 --> 00:13:11,174
Just a spoiler, the cluster

191
00:13:11,222 --> 00:13:15,062
operator can manage TLS configuration,

192
00:13:15,206 --> 00:13:19,050
available host names, and finally,

193
00:13:19,200 --> 00:13:22,878
application developer cares only to the

194
00:13:23,044 --> 00:13:26,798
HTTP route, so only

195
00:13:26,964 --> 00:13:30,734
takes care of what he she wants to take care.

196
00:13:30,852 --> 00:13:34,580
So the routing, the application and nothing else.

197
00:13:35,190 --> 00:13:38,558
Starting with some analogies with the old Ingress.

198
00:13:38,734 --> 00:13:42,158
It is a little bit weird to see old Ingress,

199
00:13:42,254 --> 00:13:45,686
but I think we have to get used to it.

200
00:13:45,868 --> 00:13:49,702
And if you're familiar with Ingress API, you can think

201
00:13:49,836 --> 00:13:53,474
Gateway API exactly as a more expressive

202
00:13:53,522 --> 00:13:56,630
and next generation of that API.

203
00:13:57,470 --> 00:14:01,206
It is not obviously written in any gateway API

204
00:14:01,318 --> 00:14:04,970
documentation, even if it is mentioned in the

205
00:14:05,040 --> 00:14:08,250
previous Spotify episode that I

206
00:14:08,400 --> 00:14:13,290
left before. It is objectively

207
00:14:13,370 --> 00:14:17,434
inspired by Istio. So Gateway API was objectively

208
00:14:17,482 --> 00:14:21,246
inspired by istio. Some concepts just

209
00:14:21,268 --> 00:14:24,706
to recap, the first one, the role oriented that just

210
00:14:24,888 --> 00:14:28,258
we mentioned. The second

211
00:14:28,344 --> 00:14:32,274
one, the truly portable in

212
00:14:32,312 --> 00:14:35,646
real world scenario expressive.

213
00:14:35,758 --> 00:14:39,302
Thanks to Gateway API, we can now transform the

214
00:14:39,356 --> 00:14:42,726
majority of custom ingress annotation to

215
00:14:42,908 --> 00:14:46,902
native gateway API configuration. And the

216
00:14:46,956 --> 00:14:51,170
fourth the extensible. So as Ingress

217
00:14:51,250 --> 00:14:54,586
also gateway API is extensible in

218
00:14:54,608 --> 00:14:58,780
order to not force any limits by default to

219
00:14:59,470 --> 00:15:02,842
implementers this might sound

220
00:15:02,896 --> 00:15:06,894
trivial, but this is essential to of

221
00:15:06,932 --> 00:15:10,510
course distinguish a gateway from Gateway API.

222
00:15:11,010 --> 00:15:14,782
We are talking here of gateway API.

223
00:15:14,846 --> 00:15:18,578
Of course API Gateway is instead

224
00:15:18,664 --> 00:15:21,854
a general concept that describes anything that exposes

225
00:15:21,902 --> 00:15:24,878
capabilities of a backend service. For example,

226
00:15:24,984 --> 00:15:29,110
AWS API gateway gateway API again is

227
00:15:29,260 --> 00:15:33,426
an interface. So we are talking about an interface.

228
00:15:33,618 --> 00:15:37,582
Many API gateway are already implementing gateway API.

229
00:15:37,666 --> 00:15:41,914
So we can mention of course Google Cloud platform that

230
00:15:42,112 --> 00:15:46,460
is covered in the next demo.

231
00:15:46,910 --> 00:15:51,530
Kong Wso two Kong Nginx

232
00:15:51,690 --> 00:15:55,726
traffic AWS. You can find all

233
00:15:55,748 --> 00:15:59,994
the implementation status here. Another analogy

234
00:16:00,042 --> 00:16:03,634
with Ingress that probably put a primer for the

235
00:16:03,672 --> 00:16:07,550
hands on part. We can see on the left our lovely

236
00:16:07,630 --> 00:16:11,266
ingress, and on the

237
00:16:11,288 --> 00:16:14,500
right what it will become.

238
00:16:14,970 --> 00:16:19,042
The ingress is basically composed

239
00:16:19,186 --> 00:16:22,322
in little pieces that are the custom resources

240
00:16:22,386 --> 00:16:25,910
of gateway API. For example, starting from the top,

241
00:16:26,060 --> 00:16:29,654
ingress classes are exactly the same concept

242
00:16:29,702 --> 00:16:33,900
of gateway class. So as before,

243
00:16:34,350 --> 00:16:38,038
these are usually already provided by cloud providers.

244
00:16:38,134 --> 00:16:42,094
So this was the violet arrow and

245
00:16:42,212 --> 00:16:46,350
with a light blue arrow

246
00:16:47,730 --> 00:16:51,358
going down the OS name configuration is

247
00:16:51,524 --> 00:16:55,514
a gateway PI. First of all defined gateway

248
00:16:55,562 --> 00:16:59,374
resources. And talking about the light blue

249
00:16:59,422 --> 00:17:03,022
narrow. And this way we can give to cluster

250
00:17:03,086 --> 00:17:07,042
operator the power to decide what are allowed

251
00:17:07,106 --> 00:17:10,870
hosts and include of course TLS configuration.

252
00:17:11,450 --> 00:17:15,314
We finally arrived to the application developer

253
00:17:15,362 --> 00:17:19,580
role and now on

254
00:17:20,110 --> 00:17:24,540
developer side is finally incur only

255
00:17:24,990 --> 00:17:28,746
what matters. So I'm talking about essentially to the

256
00:17:28,768 --> 00:17:32,710
HTTP routing that include also path definition,

257
00:17:32,870 --> 00:17:36,400
path providing either manipulation and so on.

258
00:17:36,770 --> 00:17:40,574
The last analogy that I want to do is as

259
00:17:40,612 --> 00:17:44,066
we deal with ingress controllers, now we have to

260
00:17:44,088 --> 00:17:48,020
deal with gateway controller, even if

261
00:17:49,350 --> 00:17:53,342
gateway controllers are not always managed

262
00:17:53,406 --> 00:17:57,762
by Kubernetes users. For example on GKE

263
00:17:57,906 --> 00:18:01,878
that we will see next, the gateway controller is

264
00:18:01,964 --> 00:18:04,630
totally managed by the cloud provider.

265
00:18:04,970 --> 00:18:08,150
Let's with more focus the gateway API.

266
00:18:08,970 --> 00:18:13,118
So these are the main custom resources

267
00:18:13,154 --> 00:18:16,438
that gateway API adds.

268
00:18:16,614 --> 00:18:20,010
And let's start with the main three items,

269
00:18:20,770 --> 00:18:24,478
hands on time. Let's start the hands on.

270
00:18:24,564 --> 00:18:27,966
As I said, the hands on

271
00:18:28,068 --> 00:18:32,994
is based on Google Cloud platform. So here

272
00:18:33,112 --> 00:18:36,420
in this repository on my GitHub space,

273
00:18:36,790 --> 00:18:40,370
I collected all the material that you

274
00:18:40,520 --> 00:18:44,290
will then be able to retrieve

275
00:18:44,890 --> 00:18:48,182
if you want it, of course. And first of all

276
00:18:48,236 --> 00:18:51,938
I had to provision a GKE Kubernetes cluster.

277
00:18:52,114 --> 00:18:56,450
I provision it here with an autopilot

278
00:18:56,530 --> 00:19:00,122
mode, which is pretty cool. Then I have

279
00:19:00,176 --> 00:19:04,250
to connect to the Kubernetes cluster. So first of all,

280
00:19:04,400 --> 00:19:08,890
let's connect to it. Okay, so we

281
00:19:09,040 --> 00:19:12,750
will now see some pod and

282
00:19:12,900 --> 00:19:15,920
be also a node. Okay, awesome.

283
00:19:16,370 --> 00:19:19,550
So switch back to the path.

284
00:19:19,970 --> 00:19:23,874
What we will do now is basically two

285
00:19:23,912 --> 00:19:27,710
kind of exercise. The first one we will deploy

286
00:19:27,790 --> 00:19:31,138
a simple blue application that

287
00:19:31,304 --> 00:19:35,218
will be exposed using ingress. And then

288
00:19:35,304 --> 00:19:38,934
we will use Gateway API to do exactly the

289
00:19:38,972 --> 00:19:42,790
same thing. And then see

290
00:19:42,860 --> 00:19:46,742
how gateway API can solve a lot of problems that

291
00:19:46,796 --> 00:19:50,300
ingress could not do.

292
00:19:50,990 --> 00:19:54,490
So let's start with the first exercise

293
00:19:54,910 --> 00:19:58,378
and this is exactly what we will do.

294
00:19:58,464 --> 00:20:02,798
So a basic traffic routing using

295
00:20:02,884 --> 00:20:06,880
ingresses that flow only to the blue application.

296
00:20:07,650 --> 00:20:11,662
So first of all I'd like

297
00:20:11,716 --> 00:20:15,170
to install the blue one.

298
00:20:15,320 --> 00:20:19,122
So let's return to the CLI and

299
00:20:19,176 --> 00:20:22,100
install the blue application.

300
00:20:22,950 --> 00:20:26,502
Let's see if all is working as

301
00:20:26,556 --> 00:20:30,280
expected. Okay awesome.

302
00:20:30,650 --> 00:20:35,126
So going back to our path then,

303
00:20:35,308 --> 00:20:39,414
we have now to wait that the GKE cloud load balancer

304
00:20:39,462 --> 00:20:43,130
is provisioned. Why? And the

305
00:20:43,200 --> 00:20:47,100
reason is because how I

306
00:20:47,710 --> 00:20:53,694
do is enable an

307
00:20:53,732 --> 00:20:57,422
ingress resource that is configurated here as

308
00:20:57,476 --> 00:21:00,974
follows. So it is using an

309
00:21:01,012 --> 00:21:03,330
ingress class GCE.

310
00:21:04,070 --> 00:21:08,610
The host name will be this one. And the path

311
00:21:09,270 --> 00:21:13,758
where our dummy blue application is exposed

312
00:21:13,854 --> 00:21:17,378
is this one. So let's

313
00:21:17,554 --> 00:21:21,430
go to the Google cloud platform web

314
00:21:21,500 --> 00:21:24,902
page and let's see what is

315
00:21:24,956 --> 00:21:28,970
happening. So first of all I have to go to the network services

316
00:21:29,120 --> 00:21:33,580
load balancing and see that something

317
00:21:33,950 --> 00:21:37,562
will start move. Let's wait a couple

318
00:21:37,616 --> 00:21:41,306
of seconds. Here we go. Now it's

319
00:21:41,338 --> 00:21:45,566
ready. So the ingress made

320
00:21:45,668 --> 00:21:50,350
it work. So we can now try going

321
00:21:50,420 --> 00:21:54,274
back to our path of the

322
00:21:54,312 --> 00:21:58,162
first exercise. We saw the load balancer and

323
00:21:58,216 --> 00:22:01,474
now we can copy the public IP and

324
00:22:01,512 --> 00:22:05,294
in order to reach our custom fake

325
00:22:05,342 --> 00:22:09,014
hostname we have to put the public Ip on

326
00:22:09,052 --> 00:22:12,040
our etcd host name.

327
00:22:12,410 --> 00:22:16,790
So going back to the CLI

328
00:22:17,470 --> 00:22:21,610
or can copy the public Ip

329
00:22:21,950 --> 00:22:26,966
here and switch back CLi.

330
00:22:27,158 --> 00:22:30,894
And I already have the record,

331
00:22:31,012 --> 00:22:34,574
I have only to switch the right

332
00:22:34,692 --> 00:22:38,654
ip here. So is this one

333
00:22:38,772 --> 00:22:42,554
okay, now going back to

334
00:22:42,612 --> 00:22:46,290
our path, we can now try

335
00:22:46,360 --> 00:22:50,162
to reach our host name that is exposed using

336
00:22:50,296 --> 00:22:53,806
basic ingress API. So let's

337
00:22:53,838 --> 00:22:57,186
try. It's not ready yet because load

338
00:22:57,218 --> 00:23:00,838
balancer is becoming ready.

339
00:23:00,924 --> 00:23:04,674
So let's wait a couple of seconds. Load balancer

340
00:23:04,722 --> 00:23:08,102
is ready now. So refreshing. We can say

341
00:23:08,156 --> 00:23:12,018
that our colored page blue

342
00:23:12,194 --> 00:23:15,526
10 zero application is ready as

343
00:23:15,548 --> 00:23:18,966
we can see here. I wanted to show

344
00:23:19,068 --> 00:23:23,440
some either us from the outside

345
00:23:24,050 --> 00:23:27,854
and the path that is arriving to

346
00:23:27,892 --> 00:23:32,346
our blue application. Cool. So we

347
00:23:32,468 --> 00:23:36,370
covered the basic ingress exposure

348
00:23:36,710 --> 00:23:40,130
and the last tool.

349
00:23:40,280 --> 00:23:44,210
I'd say that what are the limitations here?

350
00:23:44,360 --> 00:23:48,130
For example, how can I add some HTTP URL

351
00:23:48,210 --> 00:23:52,214
rewrites or either manipulations? And the

352
00:23:52,332 --> 00:23:55,894
answer is unfortunately you

353
00:23:55,932 --> 00:23:59,542
can't, or rather you can't in a native

354
00:23:59,606 --> 00:24:03,930
way. So we already talked in previous slides how we survived,

355
00:24:04,350 --> 00:24:09,142
so we ended in a provider specific ingress

356
00:24:09,206 --> 00:24:12,942
control implementation lock in.

357
00:24:13,076 --> 00:24:16,954
So yeah, we had to use a lot of ingress controller

358
00:24:17,002 --> 00:24:20,750
annotation reach this aim

359
00:24:21,170 --> 00:24:24,530
going on. So the core exercise

360
00:24:24,950 --> 00:24:28,722
here is the gateway API one. And let's see

361
00:24:28,776 --> 00:24:31,874
now how gateway API solve a lot of

362
00:24:31,912 --> 00:24:36,322
ingress API limitation. For example HTTP

363
00:24:36,386 --> 00:24:40,258
rules, more scalable, more oral oriented,

364
00:24:40,434 --> 00:24:43,586
and in a real world scenario

365
00:24:43,698 --> 00:24:47,522
I'd like to install a

366
00:24:47,596 --> 00:24:52,810
second green application and then use

367
00:24:52,880 --> 00:24:56,426
another namespace, an infrastructure namespace where I

368
00:24:56,448 --> 00:25:00,798
will put gateway stuff from

369
00:25:00,884 --> 00:25:04,634
the cluster operator role

370
00:25:04,762 --> 00:25:09,134
and then putting again the developer operator ahead,

371
00:25:09,252 --> 00:25:12,794
I'll try to make some HTTP routing rules

372
00:25:12,842 --> 00:25:16,154
in order to expose our applications,

373
00:25:16,282 --> 00:25:20,482
both the blue one and the green one, and then finally

374
00:25:20,616 --> 00:25:24,606
some either manipulation path rewriting cannery and blue

375
00:25:24,638 --> 00:25:28,390
green using only native gateway API

376
00:25:28,730 --> 00:25:32,290
functionality. So let's start from the beginning

377
00:25:32,370 --> 00:25:36,680
and let's install the green application

378
00:25:37,470 --> 00:25:42,026
to the CLI again. Install the

379
00:25:42,048 --> 00:25:44,940
green one, let's wait.

380
00:25:45,630 --> 00:25:48,970
The readiness could it's already

381
00:25:49,040 --> 00:25:52,766
running. So going back to

382
00:25:52,788 --> 00:25:56,080
the path, then I have to

383
00:25:56,530 --> 00:26:00,990
label the development namespace

384
00:26:02,630 --> 00:26:05,540
and we will see next why.

385
00:26:08,550 --> 00:26:12,238
Next thing to do is to create the infrastructure

386
00:26:12,334 --> 00:26:17,570
namespace where we will put then the gateway definition.

387
00:26:17,730 --> 00:26:21,714
So let's go back to the CLI

388
00:26:21,842 --> 00:26:24,630
create the namespace infrastructure.

389
00:26:24,970 --> 00:26:29,158
And what we have to do now PowerPoint

390
00:26:29,334 --> 00:26:32,778
is putting the operator hat and

391
00:26:32,864 --> 00:26:36,874
install the gateway resource. Note that the gateway class

392
00:26:37,072 --> 00:26:41,194
is already provided by the cloud provider, in this case GKE.

393
00:26:41,322 --> 00:26:44,346
So if meantime I can copy

394
00:26:44,378 --> 00:26:47,950
it, but if I return to the CLI

395
00:26:48,610 --> 00:26:53,566
and I can check it get gateway

396
00:26:53,758 --> 00:26:58,290
class, I can see four different

397
00:26:58,360 --> 00:27:02,340
gateway classes, we will use the first one

398
00:27:02,710 --> 00:27:07,106
and these are provided by cloud provider.

399
00:27:07,298 --> 00:27:10,150
So let's install our gateway.

400
00:27:10,490 --> 00:27:13,960
And what I did here is exactly,

401
00:27:14,410 --> 00:27:18,380
let's see on code

402
00:27:18,990 --> 00:27:22,598
is exactly this file.

403
00:27:22,694 --> 00:27:26,230
So what I stole is a gateway

404
00:27:26,310 --> 00:27:30,490
kind resource from the Gateway API official

405
00:27:30,570 --> 00:27:33,822
API version. And the name is that

406
00:27:33,876 --> 00:27:37,914
one in the namespace infrastructure created

407
00:27:37,962 --> 00:27:41,934
just before the Gateway class name is one of

408
00:27:42,132 --> 00:27:46,180
the Google cloud platform available.

409
00:27:46,710 --> 00:27:50,782
And here I decided to create a basic

410
00:27:50,846 --> 00:27:54,922
HTTP on the 80 port listener

411
00:27:55,086 --> 00:27:58,822
and the host name is a custom one, which name

412
00:27:58,876 --> 00:28:02,466
is a new name exposed by Gatewaypi.

413
00:28:02,578 --> 00:28:06,600
Net. And here we can also

414
00:28:08,430 --> 00:28:12,042
say to gateway to accept only from

415
00:28:12,176 --> 00:28:15,590
specific namespaces the routes.

416
00:28:15,750 --> 00:28:19,834
And here I decided to accept from all namespaces, but we

417
00:28:19,872 --> 00:28:22,510
can also be more granular.

418
00:28:23,090 --> 00:28:26,606
Then I want to mention also the

419
00:28:26,628 --> 00:28:30,078
TLS configuration. So here always

420
00:28:30,164 --> 00:28:33,906
on the gateway configuration, on the

421
00:28:33,928 --> 00:28:37,634
cluster operator role we

422
00:28:37,672 --> 00:28:42,606
can define how it is configured,

423
00:28:42,718 --> 00:28:46,466
the TLS part, so we can say here that it

424
00:28:46,488 --> 00:28:49,974
is involved the secret, which name is this one,

425
00:28:50,172 --> 00:28:53,800
and a pretty cool feature is that we can

426
00:28:54,250 --> 00:28:58,474
take this secret from a different namespace from

427
00:28:58,592 --> 00:29:03,094
for example infrastructure charts.

428
00:29:03,222 --> 00:29:07,658
So here we can delegate then to

429
00:29:07,824 --> 00:29:12,398
another corporate team the

430
00:29:12,484 --> 00:29:14,910
management of certificates.

431
00:29:15,490 --> 00:29:19,662
That is pretty cool. We already

432
00:29:19,716 --> 00:29:22,886
applied with a cluster operator hat.

433
00:29:22,938 --> 00:29:26,354
So let's see how it is going on the

434
00:29:26,392 --> 00:29:30,322
cluster side. So let's go back here and

435
00:29:30,376 --> 00:29:35,330
let's describe the gateway resource.

436
00:29:35,930 --> 00:29:39,606
We can see here something is moving.

437
00:29:39,708 --> 00:29:43,350
So it was applied and it seems that

438
00:29:43,500 --> 00:29:46,694
it is already synced. So I

439
00:29:46,732 --> 00:29:50,780
expect now going back to the Google cloud platform

440
00:29:51,390 --> 00:29:55,414
to see that a new load

441
00:29:55,462 --> 00:29:58,214
balancer will be created.

442
00:29:58,342 --> 00:30:03,966
Awesome this one, and it

443
00:30:03,988 --> 00:30:08,000
has not any rules yet because

444
00:30:08,770 --> 00:30:12,834
we deployed only the gateway part. So let's go

445
00:30:12,872 --> 00:30:16,930
back to the path and yeah,

446
00:30:17,000 --> 00:30:20,834
no rules created yet. And now we have, in order to

447
00:30:20,872 --> 00:30:24,462
create some rules put the developer operator hat.

448
00:30:24,526 --> 00:30:28,166
So install the first

449
00:30:28,348 --> 00:30:31,618
very easy HTTP route resource.

450
00:30:31,794 --> 00:30:33,750
So this is the command,

451
00:30:34,330 --> 00:30:38,620
let's go back to the ClI and then see

452
00:30:39,150 --> 00:30:43,002
what is this route. Easy. So let's see

453
00:30:43,056 --> 00:30:47,034
on visual studio code what

454
00:30:47,152 --> 00:30:50,602
I did, and basically under the

455
00:30:50,656 --> 00:30:53,790
development hat folder I see

456
00:30:53,860 --> 00:30:57,502
the easy route that is this one kind

457
00:30:57,556 --> 00:31:01,006
HTTP route, which name is this one in

458
00:31:01,028 --> 00:31:04,974
the development namespace, see that the development and the infrastructure

459
00:31:05,022 --> 00:31:08,706
namespace are different. And here we

460
00:31:08,728 --> 00:31:11,970
are referring to the gateway

461
00:31:12,550 --> 00:31:17,266
name, which is this one in the namespace infrastructure.

462
00:31:17,458 --> 00:31:21,062
And the only allowed namespace host name,

463
00:31:21,116 --> 00:31:25,846
sorry is this one. So if I try to users

464
00:31:25,948 --> 00:31:30,170
a different host name will be rejected.

465
00:31:30,670 --> 00:31:34,346
And this is a basic rule. So it match

466
00:31:34,448 --> 00:31:38,154
all on this host name with

467
00:31:38,192 --> 00:31:41,534
this path and redirect all to the our

468
00:31:41,652 --> 00:31:45,918
dummy version, one blue application on 3000

469
00:31:46,004 --> 00:31:49,710
port. Let's see how it is going to

470
00:31:49,860 --> 00:31:52,400
TTP route side.

471
00:31:53,270 --> 00:31:57,234
Here we go. Oh cool. So we

472
00:31:57,352 --> 00:32:01,602
are seeing that it is already a success.

473
00:32:01,736 --> 00:32:05,742
So it means that it was correctly

474
00:32:05,886 --> 00:32:10,150
attached to the gateway in the namespace infrastructure

475
00:32:10,490 --> 00:32:14,214
and returning to the cloud

476
00:32:14,332 --> 00:32:18,200
provider. We should see that now

477
00:32:18,650 --> 00:32:21,742
something challenges.

478
00:32:21,826 --> 00:32:26,394
So we can see now that a new endpoint group is ready.

479
00:32:26,592 --> 00:32:29,210
So returning to our path,

480
00:32:29,970 --> 00:32:33,598
what we need now is try to reach

481
00:32:33,684 --> 00:32:36,862
the new name, which is now by

482
00:32:36,916 --> 00:32:41,214
Gateway API. The previous one was by

483
00:32:41,252 --> 00:32:43,940
Ingress, so are different.

484
00:32:44,630 --> 00:32:48,962
So let's pick the new public ip from

485
00:32:49,016 --> 00:32:52,078
the new cloud load balancer,

486
00:32:52,254 --> 00:32:56,260
which is this one going back

487
00:32:56,630 --> 00:33:00,914
the CLI and also the

488
00:33:00,952 --> 00:33:03,000
second record.

489
00:33:03,530 --> 00:33:07,320
Cool. So let's back

490
00:33:07,790 --> 00:33:11,546
the path. So now we expect

491
00:33:11,648 --> 00:33:15,450
to reach the new application exposed.

492
00:33:17,790 --> 00:33:21,822
Well the application is always the same, the blue one, but is

493
00:33:21,876 --> 00:33:25,342
now exposed using Gateway API instead of

494
00:33:25,476 --> 00:33:29,694
ingress. So let's try cool. It's exactly

495
00:33:29,812 --> 00:33:33,706
the same result as we reached using Ingress.

496
00:33:33,818 --> 00:33:36,922
So you can see here Gatewayapi.

497
00:33:37,066 --> 00:33:40,038
Net. Here it's ingress.

498
00:33:40,154 --> 00:33:43,700
Net. So it's exactly the same result.

499
00:33:44,150 --> 00:33:47,302
So let's add some more feature coming

500
00:33:47,356 --> 00:33:51,410
from Gateway API using always the developer

501
00:33:51,490 --> 00:33:55,414
operator head. For example, let's add a

502
00:33:55,452 --> 00:33:59,382
custom meter using always native

503
00:33:59,446 --> 00:34:01,850
integration of Gateway API.

504
00:34:02,350 --> 00:34:05,686
So the new HTTP route

505
00:34:05,718 --> 00:34:09,974
is described in this file. Let's apply it again

506
00:34:10,112 --> 00:34:13,162
and see what contains.

507
00:34:13,306 --> 00:34:17,440
So first of all let's apply it

508
00:34:17,890 --> 00:34:21,514
and going back visual studio

509
00:34:21,562 --> 00:34:25,154
code. Let's see what I did. What I

510
00:34:25,192 --> 00:34:28,740
did is exactly described here

511
00:34:29,510 --> 00:34:33,410
on the right I put previews

512
00:34:34,070 --> 00:34:37,814
HTTP route. See that I'm basically

513
00:34:38,012 --> 00:34:42,966
editing exactly the same route and

514
00:34:43,148 --> 00:34:46,934
what it challenges, it challenges basically this part.

515
00:34:47,052 --> 00:34:50,970
So I added a filter

516
00:34:52,030 --> 00:34:55,370
which basically add, as the name said,

517
00:34:55,440 --> 00:34:59,114
a filter before forwarding the

518
00:34:59,152 --> 00:35:02,926
request to our blue application. And the

519
00:35:02,948 --> 00:35:06,218
filter type is request either modifier.

520
00:35:06,394 --> 00:35:09,726
And as the name said, I'm trying to add a

521
00:35:09,748 --> 00:35:13,326
new editor which name is my eater and

522
00:35:13,348 --> 00:35:17,698
the value is foe. This is only what

523
00:35:17,864 --> 00:35:22,580
I change it. So let's see how it is going

524
00:35:23,350 --> 00:35:27,282
on HTTP route side. So let's do

525
00:35:27,416 --> 00:35:31,078
scribe again. And we can see that

526
00:35:31,244 --> 00:35:35,590
a few seconds ago there was a reconciliation

527
00:35:38,110 --> 00:35:41,926
the Gateway resource from HTTP

528
00:35:41,958 --> 00:35:46,042
route, the Gateway resource. So I expect now that

529
00:35:46,176 --> 00:35:49,622
my new custom editor is reaching

530
00:35:49,686 --> 00:35:53,214
our blue application, let's go

531
00:35:53,252 --> 00:35:57,680
back our path and try to

532
00:35:58,450 --> 00:36:02,358
use the GitVPI net URL

533
00:36:02,474 --> 00:36:05,010
and see if something is changing.

534
00:36:05,350 --> 00:36:08,210
Wow. The eater is already here.

535
00:36:08,280 --> 00:36:11,534
So I can see that my eater custom my dear

536
00:36:11,582 --> 00:36:15,022
is here and the values is

537
00:36:15,176 --> 00:36:18,470
exactly four as expected.

538
00:36:18,970 --> 00:36:22,534
And the second exercise here is to do

539
00:36:22,572 --> 00:36:26,680
a path rewriting. So let's go back,

540
00:36:27,130 --> 00:36:31,114
let's first apply it and then see what

541
00:36:31,152 --> 00:36:35,286
is having. So let's apply the new file root

542
00:36:35,318 --> 00:36:39,354
either pathway write so

543
00:36:39,392 --> 00:36:43,102
it's configured and now let's see

544
00:36:43,236 --> 00:36:47,120
what is changed from HTTP route side

545
00:36:47,650 --> 00:36:51,566
what is challenges can see again on the

546
00:36:51,588 --> 00:36:55,310
left I leave on the right the previous version

547
00:36:55,470 --> 00:36:59,106
is exactly the same name. So we are editing exactly

548
00:36:59,208 --> 00:37:03,758
the same route and we are just implementing

549
00:37:03,854 --> 00:37:07,894
a new filter. So I

550
00:37:07,932 --> 00:37:11,974
added a new filter just after the

551
00:37:12,012 --> 00:37:15,414
previous request, either modifier I add a

552
00:37:15,452 --> 00:37:18,786
new URL rewrite where I can also rewrite

553
00:37:18,818 --> 00:37:25,382
the host name, but it is not covered in this demo I'm

554
00:37:25,446 --> 00:37:28,758
editing now the path, a new path

555
00:37:28,854 --> 00:37:32,206
is exactly this one. So I already

556
00:37:32,308 --> 00:37:36,240
applied it. Let's see how it is going.

557
00:37:36,930 --> 00:37:40,702
And 53 seconds ago was a success.

558
00:37:40,836 --> 00:37:44,820
The reconciliation. So I expect again that

559
00:37:45,190 --> 00:37:49,694
already is going expected.

560
00:37:49,822 --> 00:37:53,826
So what I expect now that if I try to

561
00:37:53,848 --> 00:37:58,162
reach the blue application, the path that is printed

562
00:37:58,226 --> 00:38:01,720
from the blue application side will not be

563
00:38:02,250 --> 00:38:05,650
slash anymore, but should be the new path.

564
00:38:05,730 --> 00:38:09,978
So let's try cool. So the new path is

565
00:38:10,064 --> 00:38:13,978
already here. So the blue application is

566
00:38:14,064 --> 00:38:17,980
getting the new path while from the external everything

567
00:38:18,510 --> 00:38:22,746
is the same. So we are already using the slash path.

568
00:38:22,938 --> 00:38:26,174
Let's do a couple of pretty cool example

569
00:38:26,292 --> 00:38:29,534
of deploying. So we will try to do a

570
00:38:29,572 --> 00:38:32,830
canary deploy and then a blue green deploy.

571
00:38:33,270 --> 00:38:36,702
The canary deploy it's described

572
00:38:36,766 --> 00:38:40,370
in the route canary Yaml HTTP route

573
00:38:40,870 --> 00:38:45,906
what I'll try to do is to split

574
00:38:45,938 --> 00:38:49,602
the traffic based on a custom meter.

575
00:38:49,666 --> 00:38:54,022
The custom meter is the traffic either and

576
00:38:54,076 --> 00:38:57,834
the values has to be test. So if

577
00:38:57,872 --> 00:39:00,810
this condition is matched,

578
00:39:01,150 --> 00:39:05,306
the canary configuration should

579
00:39:05,408 --> 00:39:09,066
then flow the traffic to the new one and only in

580
00:39:09,088 --> 00:39:13,450
that case because in all other cases. So by default

581
00:39:13,610 --> 00:39:16,926
all traffic has to be served by the

582
00:39:16,948 --> 00:39:20,750
blue application. So let's introduce

583
00:39:21,090 --> 00:39:24,690
the cannery again. Let's first apply

584
00:39:24,760 --> 00:39:28,900
it back to the cli Id

585
00:39:29,510 --> 00:39:34,340
canary routing let's see on

586
00:39:34,890 --> 00:39:38,594
code what the root

587
00:39:38,642 --> 00:39:41,400
canary yaml here.

588
00:39:41,850 --> 00:39:45,602
Cool. So on the left the new HTTP route.

589
00:39:45,746 --> 00:39:49,190
Again the name is always the same. So we are editing

590
00:39:49,270 --> 00:39:52,874
always the same route. And on the left we can see

591
00:39:52,912 --> 00:39:56,954
that a new match appeared here.

592
00:39:57,152 --> 00:40:00,894
So what we are doing now is

593
00:40:01,092 --> 00:40:04,798
we are adding a new match that match

594
00:40:04,884 --> 00:40:08,746
only traffic that has this header.

595
00:40:08,858 --> 00:40:13,122
So the traffic that has this traffic header name and

596
00:40:13,176 --> 00:40:17,138
the values has to be test then

597
00:40:17,224 --> 00:40:21,694
in this case please we are saying to the route redirect

598
00:40:21,742 --> 00:40:25,650
all the traffic to the green application by default

599
00:40:26,010 --> 00:40:28,280
continues to serve the blue application.

600
00:40:28,730 --> 00:40:32,694
So what we will expect now,

601
00:40:32,892 --> 00:40:36,118
as we saw before, we expect

602
00:40:36,204 --> 00:40:40,234
that if we set the traffic either with

603
00:40:40,272 --> 00:40:44,060
test value we expect to see the green application.

604
00:40:44,830 --> 00:40:48,282
So first of all let's try by default that

605
00:40:48,336 --> 00:40:51,440
everything is going as before.

606
00:40:52,130 --> 00:40:55,760
So the blue one is here. Let's try to do,

607
00:40:58,530 --> 00:41:02,160
let's try to add the custom either who's in this custom

608
00:41:02,550 --> 00:41:05,650
either manipulation extension.

609
00:41:06,310 --> 00:41:09,922
So try we have to wait a couple

610
00:41:09,976 --> 00:41:13,730
of seconds, maybe that the load balancer

611
00:41:14,390 --> 00:41:17,558
sync it. I think it's ready now.

612
00:41:17,644 --> 00:41:21,560
So try to put again the either

613
00:41:22,250 --> 00:41:26,422
and yeah we are reaching now the green application

614
00:41:26,556 --> 00:41:30,058
and always we are always

615
00:41:30,144 --> 00:41:33,514
reaching the green application and try to pull

616
00:41:33,552 --> 00:41:37,402
off the either. We are back to the

617
00:41:37,536 --> 00:41:40,874
blue one. Cool. So we did also the

618
00:41:40,912 --> 00:41:44,382
canary deploy using gateway API and

619
00:41:44,436 --> 00:41:48,990
the last one I'd like to show you is the blue green deploy

620
00:41:49,330 --> 00:41:53,406
which is basically the traffic splitting

621
00:41:53,598 --> 00:41:57,682
using a percentage. So the 50%

622
00:41:57,816 --> 00:42:01,166
of the traffic we want to be surveyed by the blue

623
00:42:01,198 --> 00:42:05,634
application and the other part. So the other 50%

624
00:42:05,832 --> 00:42:10,040
surveyed by the green one try

625
00:42:10,650 --> 00:42:15,014
to always apply it and see

626
00:42:15,212 --> 00:42:19,180
what is changed from the

627
00:42:19,790 --> 00:42:23,318
HTTP route side. The blue

628
00:42:23,414 --> 00:42:26,780
green is left.

629
00:42:27,310 --> 00:42:30,854
On the right we see the canary that was the previous.

630
00:42:30,982 --> 00:42:34,560
Again always the myrot is

631
00:42:35,010 --> 00:42:35,870
edited.

632
00:42:38,130 --> 00:42:41,280
What we see on the left, that is

633
00:42:41,730 --> 00:42:46,420
we are not using the double matches match

634
00:42:47,030 --> 00:42:51,250
strategy. We are using a single match strategy

635
00:42:52,230 --> 00:42:56,134
which match always the slash path. But we are

636
00:42:56,172 --> 00:43:00,258
saying to the HTTP route to redirect

637
00:43:00,354 --> 00:43:04,182
the 50% of the traffic to the blue service and the

638
00:43:04,236 --> 00:43:07,400
other 50% of the traffic to the green one.

639
00:43:07,790 --> 00:43:11,578
And in this way we can do a sort of

640
00:43:11,744 --> 00:43:16,060
gradual release and for example

641
00:43:16,670 --> 00:43:20,134
reduce over the time the

642
00:43:20,192 --> 00:43:22,640
traffic. Sorry,

643
00:43:23,250 --> 00:43:27,498
contrary. This way we are introducing gradually

644
00:43:27,594 --> 00:43:31,550
the green application and we can then arrive to

645
00:43:31,620 --> 00:43:34,690
1% traffic to the green one.

646
00:43:34,760 --> 00:43:38,162
So let's before try to do a

647
00:43:38,216 --> 00:43:41,890
50% as I already

648
00:43:42,040 --> 00:43:45,254
applied. So what expect now let's see how

649
00:43:45,292 --> 00:43:48,680
it is going from the HTTP route side.

650
00:43:49,210 --> 00:43:53,222
Again let's describe it

651
00:43:53,276 --> 00:43:56,626
seems already reconciliated.

652
00:43:56,818 --> 00:43:59,974
Yes I'd say yes. So let's

653
00:44:00,022 --> 00:44:04,074
go back to Chrome and see if it is working as

654
00:44:04,112 --> 00:44:08,522
expected. So now what I expect using

655
00:44:08,576 --> 00:44:12,138
no either I expect to be redirect

656
00:44:12,234 --> 00:44:16,078
with a 50% probability to the green one and

657
00:44:16,164 --> 00:44:20,154
the other probability to the blue one. So let's

658
00:44:20,202 --> 00:44:23,886
try and cool it's

659
00:44:23,918 --> 00:44:27,474
already applied so we can see that

660
00:44:27,512 --> 00:44:30,754
we are going to the green one and to the

661
00:44:30,792 --> 00:44:33,330
blue one with a 50% probability.

662
00:44:34,070 --> 00:44:37,778
And yeah, this was the last

663
00:44:37,944 --> 00:44:41,702
example in this hands on. Let's go back

664
00:44:41,756 --> 00:44:45,414
to the slide with final talks. Hope you

665
00:44:45,452 --> 00:44:48,874
enjoyed the hands on on Google Cloud platform.

666
00:44:49,072 --> 00:44:52,998
Let's see now a weekly summary.

667
00:44:53,174 --> 00:44:57,206
So in summary, we had the chance to see how Gateway API

668
00:44:57,238 --> 00:45:00,506
evolved, the ingress API and

669
00:45:00,608 --> 00:45:04,534
which features has been introduced thanks to Gateway

670
00:45:04,582 --> 00:45:08,014
API. This is a very quick

671
00:45:08,132 --> 00:45:11,920
recap of what we said and we tried.

672
00:45:12,790 --> 00:45:16,158
So this diagram represent

673
00:45:16,254 --> 00:45:20,130
exactly where we are now thanks to Gatewaypi.

674
00:45:20,790 --> 00:45:24,162
And we saw exactly this on

675
00:45:24,216 --> 00:45:28,038
the hands on. We saw in the hands

676
00:45:28,124 --> 00:45:31,682
on the part of the two typical user

677
00:45:31,746 --> 00:45:36,230
personas. So we saw the cluster operator and the developers

678
00:45:37,050 --> 00:45:40,790
side that usually works on Kubernetes

679
00:45:40,870 --> 00:45:45,066
platforms. Just last two things, look into the future,

680
00:45:45,248 --> 00:45:47,210
of course, of Gateway API.

681
00:45:48,270 --> 00:45:51,778
The first one is a question, will Gateway API

682
00:45:51,814 --> 00:45:56,410
replace the ingress API? And the official

683
00:45:56,490 --> 00:45:58,560
answer is no,

684
00:45:59,730 --> 00:46:03,154
as you can see here from the official answer of

685
00:46:03,192 --> 00:46:07,586
Gateway API. But in

686
00:46:07,608 --> 00:46:11,186
my opinion I'd say the answer is yes. Again,

687
00:46:11,288 --> 00:46:14,466
it's a personal opinion, so take care of it.

688
00:46:14,648 --> 00:46:16,920
And the second and the last one,

689
00:46:17,290 --> 00:46:20,790
it's this one, gateway API for

690
00:46:20,860 --> 00:46:22,840
service mesh. Yes,

691
00:46:24,010 --> 00:46:27,686
before I wanted to mention

692
00:46:27,788 --> 00:46:31,394
istio because of it, because Gateway

693
00:46:31,442 --> 00:46:36,010
API is working on a service mesh standard solution.

694
00:46:36,590 --> 00:46:40,958
Pretty cool. And the real pretty cool thing is that

695
00:46:41,124 --> 00:46:44,414
just a spoiler of it, because this kind of

696
00:46:44,452 --> 00:46:47,230
feature is in an alpha status.

697
00:46:47,570 --> 00:46:50,986
So in using exactly the same HTTP

698
00:46:51,018 --> 00:46:55,806
route that we saw before, we will be able to attach

699
00:46:55,998 --> 00:47:00,398
these awesome features to Kubernetes

700
00:47:00,494 --> 00:47:04,306
services instead of gateway resources. So we

701
00:47:04,328 --> 00:47:07,910
are enriching basic services from

702
00:47:07,980 --> 00:47:11,174
Kubernetes with a lot of features that

703
00:47:11,212 --> 00:47:15,334
comes from API. Thanks you

704
00:47:15,372 --> 00:47:19,234
all again. And I leave here my blog

705
00:47:19,362 --> 00:47:23,462
URL and most importantly the GitHub project where

706
00:47:23,516 --> 00:47:26,680
I collected all the stuff from the hands on.

707
00:47:28,730 --> 00:47:32,094
Yeah, you can try it on your

708
00:47:32,132 --> 00:47:36,446
own, you can contact me whenever you want.

709
00:47:36,628 --> 00:47:38,638
And thanks again.

