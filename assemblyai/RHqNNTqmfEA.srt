1
00:00:41,010 --> 00:00:44,614
Hi, this talk is called compiling containers. I'm going to

2
00:00:44,652 --> 00:00:47,878
talk about how container images are made. I'm going

3
00:00:47,884 --> 00:00:51,598
to talk about this tool that I think is pretty tool called buildkit. I'm going

4
00:00:51,604 --> 00:00:55,742
to teach you a little bit about compilers and do a code demo and

5
00:00:55,796 --> 00:00:59,454
talk a little bit about the future of containerization and cloud

6
00:00:59,492 --> 00:01:03,018
native stuff. So I hope you enjoy it. I'm Adam Gordon Bell.

7
00:01:03,114 --> 00:01:06,942
I am an open source software developer.

8
00:01:07,086 --> 00:01:10,398
I am a Canadian. I am a podcaster.

9
00:01:10,414 --> 00:01:13,458
I have a podcast about software engineering. You can see there on the right.

10
00:01:13,544 --> 00:01:16,818
If you want to check it out, just search for my name.

11
00:01:16,904 --> 00:01:19,970
Your podcast player. I'm a developer advocate at Earthly

12
00:01:20,050 --> 00:01:22,834
where we are trying to improve builds.

13
00:01:22,962 --> 00:01:26,646
I'm not going to talk about Earthly too much today, but you should

14
00:01:26,668 --> 00:01:29,930
check it out. Earthly dev. You've probably heard a lot

15
00:01:30,000 --> 00:01:33,686
about container runtimes in recent history. Kubernetes stopped

16
00:01:33,718 --> 00:01:37,526
using Docker shim and started using Cri shim.

17
00:01:37,638 --> 00:01:41,510
A lot of people freaked out, but really there's a lot of these runtimes.

18
00:01:41,590 --> 00:01:44,970
You can see a bunch of them here, run C container D, et cetera.

19
00:01:45,050 --> 00:01:48,718
It doesn't really matter the various functionality of

20
00:01:48,804 --> 00:01:52,554
each of these. For the talk today I'm going to be talking about container

21
00:01:52,602 --> 00:01:55,934
images, OCI images, to be specific. All of these

22
00:01:55,972 --> 00:01:59,874
container runtimes can run OCi images. And what I want to talk about is

23
00:01:59,912 --> 00:02:03,506
how you make this image, how you make the image that turns into a

24
00:02:03,528 --> 00:02:07,266
running container. And we're going to get a little bit down in the weeds about

25
00:02:07,288 --> 00:02:11,190
how that is done. So just a little backend information. You probably know

26
00:02:11,260 --> 00:02:14,982
what a container is. It's like a virtual machine, except you share

27
00:02:15,036 --> 00:02:18,834
the operating system kernel and some other stuff. So it has lower overhead.

28
00:02:18,882 --> 00:02:22,650
It's like the ten second version. But do you know the difference between a

29
00:02:22,720 --> 00:02:25,818
container and an image? So the way I like to think

30
00:02:25,824 --> 00:02:29,734
about it is via analogy, if you think about an executable, an executable

31
00:02:29,782 --> 00:02:32,766
is a program that you can run on your computer. And when you launch it,

32
00:02:32,788 --> 00:02:36,410
it becomes a process, and you can launch as many processes

33
00:02:36,490 --> 00:02:39,434
as you want from that single executable. Similarly,

34
00:02:39,482 --> 00:02:42,926
an image is something that's not running, and when you run that

35
00:02:42,948 --> 00:02:46,666
image, it becomes a container and you can run many containers from

36
00:02:46,708 --> 00:02:50,082
a single image. So sort of an executable is to an image as

37
00:02:50,136 --> 00:02:53,266
a process is to a container. You could imagine a

38
00:02:53,288 --> 00:02:56,846
virtual machine fitting in. This has, well, an image is like a VM image.

39
00:02:56,878 --> 00:03:01,094
Container is like a running VM, except that when you make changes to

40
00:03:01,132 --> 00:03:04,598
a running vm, you can save them back to the image. With a

41
00:03:04,684 --> 00:03:08,006
docker image they are immutable, so any changes that

42
00:03:08,028 --> 00:03:11,690
happen while it's running won't actually affect the image.

43
00:03:12,030 --> 00:03:15,830
So that executable turns into a process. But how do we get that executable?

44
00:03:15,910 --> 00:03:19,146
To get the executable we use a compiler. So here is

45
00:03:19,168 --> 00:03:22,538
an example. I have this hello world. It's written in C. You can see it

46
00:03:22,544 --> 00:03:25,038
here on the left. I'm going to pass it to a compiler. I'm going to

47
00:03:25,044 --> 00:03:28,638
use LlvM with the clang frontend. Hello world as an

48
00:03:28,644 --> 00:03:32,346
example comes from this book, the c programming language by Brian Kernahan

49
00:03:32,378 --> 00:03:35,886
and Dennis Ritchie. And I mean we're still using this as an example today in

50
00:03:35,908 --> 00:03:39,650
many languages. So I'm going to compile it to x 86 and

51
00:03:39,720 --> 00:03:43,346
my x 86 ends up being like this code we see

52
00:03:43,368 --> 00:03:46,626
here on the right, which is x 86 assembly. This is the

53
00:03:46,648 --> 00:03:50,246
assembly code for what will be executed when you run this program.

54
00:03:50,428 --> 00:03:53,894
Assembly code maps basically one to one to machine code,

55
00:03:53,932 --> 00:03:57,426
which is binary, which we're not showing here because it's much harder

56
00:03:57,458 --> 00:04:01,638
to read. But the machine code is what actually is executed on your cpu.

57
00:04:01,734 --> 00:04:04,826
It's what your cpu architecture understands. So the

58
00:04:04,848 --> 00:04:08,554
docker equivalent of this simple hello world program is something

59
00:04:08,592 --> 00:04:11,866
like this. So we have from alpine we're going to copy

60
00:04:11,898 --> 00:04:16,110
in a readme file and then we're going to echo some results to

61
00:04:16,180 --> 00:04:19,482
a file called build txt. So to compile

62
00:04:19,546 --> 00:04:22,730
that we use docker build. So Docker build dot,

63
00:04:22,810 --> 00:04:26,258
which is our present working directory. And then we're going to pass it t

64
00:04:26,344 --> 00:04:29,662
to tag it test. So creating an image from a Docker file,

65
00:04:29,726 --> 00:04:33,134
it sort of works the same way as our hello world example. The Docker

66
00:04:33,182 --> 00:04:37,102
file is passed to buildkit along with the build context,

67
00:04:37,166 --> 00:04:40,818
which in our case was the present working directory because we used dot.

68
00:04:40,914 --> 00:04:44,566
Generally each statement is turned into a layer as part of this

69
00:04:44,588 --> 00:04:47,842
build step, and those layers are packaged up into an image.

70
00:04:47,906 --> 00:04:51,458
One thing that's different from a traditional compiler is that with the compiler you're

71
00:04:51,474 --> 00:04:55,146
just taking the source code, but Docker builds, you're actually taking the

72
00:04:55,168 --> 00:04:59,194
file system context and that's how you can do things like this copy command because

73
00:04:59,232 --> 00:05:02,506
you can take things from the file system that are referenced when

74
00:05:02,528 --> 00:05:05,642
you pass it in. So in this case we pass in our present working directory

75
00:05:05,706 --> 00:05:09,310
and we use that to copy in files. So comparing our

76
00:05:09,380 --> 00:05:12,766
c compiling to our Docker building, we can

77
00:05:12,788 --> 00:05:15,874
see how they look quite similar. You have the same type of

78
00:05:15,912 --> 00:05:19,586
steps. Starting with your input. You have the compiler, which is

79
00:05:19,608 --> 00:05:23,662
llvm or buildkit, and then you end up with your executable or image.

80
00:05:23,726 --> 00:05:27,026
So what is buildkit? This is buildkit, kind of

81
00:05:27,048 --> 00:05:30,534
the brains behind Docker build, and it drives not just

82
00:05:30,572 --> 00:05:34,278
docker build, but a number of interesting cloud native projects. One is open

83
00:05:34,364 --> 00:05:37,734
fast open functions as a service, which as I understand it,

84
00:05:37,772 --> 00:05:42,166
is a project to run serverless functions on Kubernetes. There is Rancher

85
00:05:42,198 --> 00:05:45,754
Rio, which is an application development engine for cloud.

86
00:05:45,872 --> 00:05:49,322
And there's probably tens of other projects that use

87
00:05:49,376 --> 00:05:52,538
buildkit. And buildkit's what we're going to dive in a little bit today. I want

88
00:05:52,544 --> 00:05:55,662
to give you intuition for how these images are made,

89
00:05:55,716 --> 00:05:59,070
which I think could be pretty useful. But first let's talk a little bit more

90
00:05:59,140 --> 00:06:02,990
about compilers. So earlier I had this diagram again with the hello world,

91
00:06:03,060 --> 00:06:06,786
and we generate this assembly. Saying compilers work this way is kind of

92
00:06:06,808 --> 00:06:10,418
a lie. It's a simplification. On the left here is the

93
00:06:10,504 --> 00:06:14,066
PDP eleven. That is the first computer that a

94
00:06:14,088 --> 00:06:17,246
C compiler existed for. That compiler was written by Dennis Ritchie.

95
00:06:17,278 --> 00:06:20,934
And the simple diagram that I showed earlier, that actually is

96
00:06:20,972 --> 00:06:24,406
exactly what would happen on the PDP eleven. The C code would be taken by

97
00:06:24,428 --> 00:06:28,210
the compiler and it would be converted into PDP eleven assembly instructions.

98
00:06:28,290 --> 00:06:32,114
But this direct mapping, it poses a problem. Whenever you have a new machine,

99
00:06:32,162 --> 00:06:36,006
it means you need a new compiler. And what language do you write that compiler

100
00:06:36,038 --> 00:06:39,414
in? The first C compiler, as I said, was written in PDP eleven assembly,

101
00:06:39,462 --> 00:06:42,646
but you don't want to have to repeat that for every new machine architecture.

102
00:06:42,678 --> 00:06:46,174
For every new cpu. What happens when the vax eleven comes out?

103
00:06:46,212 --> 00:06:49,486
Or the new Apple M one that you see here on the right? So this

104
00:06:49,508 --> 00:06:52,846
problem has very quickly solved by compiler authors who came up

105
00:06:52,868 --> 00:06:56,142
with this structure. They said a compiler can be split into

106
00:06:56,196 --> 00:06:59,986
stages. You have a front end, you have an optimizer and

107
00:07:00,008 --> 00:07:03,406
you have a back end. The front end takes in your source, your various files

108
00:07:03,438 --> 00:07:06,942
and tokenizes them and parses them, builds an abstract syntax tree.

109
00:07:07,006 --> 00:07:10,298
The middle is the optimizer. It could do performance optimizations

110
00:07:10,334 --> 00:07:13,846
to make your code faster. At some point they called this middle the middle end,

111
00:07:13,948 --> 00:07:17,462
which I'm glad that term didn't catch on. And then you have the back end

112
00:07:17,516 --> 00:07:20,066
which actually generates the actual assembly.

113
00:07:20,178 --> 00:07:24,150
Now the beauty of this approach is you don't need to build a new compiler

114
00:07:24,230 --> 00:07:27,622
for every machine architecture. You can just build a new backend.

115
00:07:27,766 --> 00:07:30,742
So this will all relate to docker images,

116
00:07:30,886 --> 00:07:34,442
trust me. But the trick here is to get all the back ends

117
00:07:34,506 --> 00:07:37,866
speaking the same language. For that you need an intermediate

118
00:07:37,898 --> 00:07:41,514
representation. You need a language that's not c, but isn't assembly

119
00:07:41,562 --> 00:07:46,430
either. You need something in between. So once you have that language, and with LLVM

120
00:07:46,510 --> 00:07:50,030
it's called LLVM iR, which is the intermediate representation.

121
00:07:50,110 --> 00:07:54,382
All the backends then need to do is translate from that intermediate representation

122
00:07:54,446 --> 00:07:57,634
to the machine architecture that's specific to where

123
00:07:57,672 --> 00:08:01,446
they get things to run bit. Once you have that, you can

124
00:08:01,468 --> 00:08:04,914
have multiple front ends as well. So this is modern LLVM.

125
00:08:04,962 --> 00:08:07,922
This is sort of what it looks like. It started with the clang frontend.

126
00:08:07,986 --> 00:08:11,834
Now it has many front ends, right? It has rust front end, there's a go

127
00:08:11,872 --> 00:08:15,750
one, there's Julia. There's all kinds of different front ends.

128
00:08:15,830 --> 00:08:19,622
There's been sort of a cambrian explosion of ahead of time compiled programming languages

129
00:08:19,686 --> 00:08:23,066
in the past ten years. It's a result of how easy it is to add

130
00:08:23,088 --> 00:08:26,254
a front end because of this architecture that LLVM has. And the reason

131
00:08:26,292 --> 00:08:29,834
is that this is just a common interface between the various layers.

132
00:08:29,882 --> 00:08:34,206
It becomes sort of like a protocol. On the back end we

133
00:08:34,228 --> 00:08:37,722
have not just x 86 and arm and risk and power pc,

134
00:08:37,786 --> 00:08:41,534
but we also have webassembly back end, which means you could take your Julia

135
00:08:41,582 --> 00:08:44,814
or your rust and I guess compiler it to run in your web browser.

136
00:08:44,862 --> 00:08:48,306
There's even gpu back ends where you could compile your code to run

137
00:08:48,328 --> 00:08:51,926
on pixel shaders. You can build a front end has well, right? So if

138
00:08:51,948 --> 00:08:55,250
you can create a front end that translates to this llvmir,

139
00:08:55,330 --> 00:08:58,726
you have a new programming language. Everything else, all the support for all

140
00:08:58,748 --> 00:09:01,962
these various back ends is taken care of. So this is super cool.

141
00:09:02,016 --> 00:09:06,106
And the secret is just this intermediate representation. The front ends need to emit it

142
00:09:06,128 --> 00:09:10,294
and the back ends need to consume it. So bringing it back to container images

143
00:09:10,342 --> 00:09:13,818
build bit works the same way. It has something called Llbir,

144
00:09:13,914 --> 00:09:17,594
which is low level builder internal representation, because containers

145
00:09:17,642 --> 00:09:20,766
need to be able to run on lots of machine architectures as well. And once

146
00:09:20,788 --> 00:09:24,346
you have the IR for varying back ends, you can start having varying

147
00:09:24,378 --> 00:09:27,422
front ends as well. So right now there's not too many front ends.

148
00:09:27,486 --> 00:09:31,454
Probably the most commonly used are just the various versions of the Docker syntax.

149
00:09:31,502 --> 00:09:34,770
There's Docker V 1.1, but as I mentioned, there's open fast,

150
00:09:34,840 --> 00:09:37,794
there's buildpack, there's some other things, but it doesn't have to be that way.

151
00:09:37,912 --> 00:09:41,894
So just to explain how it works, LLVM IR looks like this on the left.

152
00:09:42,012 --> 00:09:45,042
It's sort of a verbose and explicit programming language.

153
00:09:45,106 --> 00:09:48,514
LLB is much simpler. It looks quite different with LLVM.

154
00:09:48,562 --> 00:09:53,014
The basics are kind of a simple programming language. With Llbir

155
00:09:53,142 --> 00:09:56,294
it's sort of a language for creating these self contained

156
00:09:56,342 --> 00:10:00,234
cloud native packages. So let me show you how that works. So let's start with

157
00:10:00,272 --> 00:10:03,614
building just a simple docker file and then we'll go from there.

158
00:10:03,652 --> 00:10:07,690
So this is the one we showed earlier just from alpine copy readme.

159
00:10:07,850 --> 00:10:12,046
Then we're going to echo this to a file so I

160
00:10:12,068 --> 00:10:15,666
can build this just like this,

161
00:10:15,848 --> 00:10:19,346
I'm going to tag it, test, build the file and then we

162
00:10:19,368 --> 00:10:23,198
can run it. So we want it to be interactive

163
00:10:23,294 --> 00:10:26,630
and we want to run test and we're going to open a shell.

164
00:10:27,370 --> 00:10:32,790
So now we're inside of it and we can see in

165
00:10:32,860 --> 00:10:37,910
this program standard docker build exit.

166
00:10:39,130 --> 00:10:43,450
So let's now take this file and just build it with buildkit instead.

167
00:10:43,600 --> 00:10:47,290
So I'm on a Mac. So to do that I need to do brew

168
00:10:47,950 --> 00:10:51,398
install buildkit. I already have it installed.

169
00:10:51,494 --> 00:10:54,366
But if you're on a Mac this is what you would need to do and

170
00:10:54,388 --> 00:10:57,498
that gives you this new command called build.

171
00:10:57,594 --> 00:11:01,342
You can kind of read through what it does there, but it lets you build

172
00:11:01,396 --> 00:11:05,726
things bit. When it build things bit needs to communicate with this backend that'll

173
00:11:05,758 --> 00:11:09,186
make the GRPC requests against Buildkit D.

174
00:11:09,288 --> 00:11:12,594
So we actually need to start that up. Let's actually

175
00:11:12,632 --> 00:11:15,170
make sure I don't already have it running. Okay, I don't.

176
00:11:17,850 --> 00:11:20,994
So this is how I would start the backend

177
00:11:21,042 --> 00:11:24,434
part of buildkit. It just runs as a container. It's called Moby

178
00:11:24,482 --> 00:11:26,790
buildkit and I'm just going to call bit buildkit.

179
00:11:28,250 --> 00:11:31,626
And then you can see that here. And then I'm just

180
00:11:31,648 --> 00:11:34,986
going to tell build where it is by doing that.

181
00:11:35,088 --> 00:11:38,394
So now it knows it is running as a docker container and then it has

182
00:11:38,432 --> 00:11:41,094
this name. Actually that is incorrect.

183
00:11:41,222 --> 00:11:44,320
That should say buildkit, right?

184
00:11:45,170 --> 00:11:48,430
So I actually want that I believe.

185
00:11:48,500 --> 00:11:52,398
Let's see how it goes. So once we have that running,

186
00:11:52,484 --> 00:11:55,570
then we can try to build this using buildkit directly.

187
00:11:55,910 --> 00:11:59,502
So using build bit directly is a little bit more verbose.

188
00:11:59,566 --> 00:12:02,100
So just clear this,

189
00:12:02,470 --> 00:12:05,678
you can just use it like this. So I'm going to use build CTL.

190
00:12:05,774 --> 00:12:09,398
I'm going to call build. I can specify which frontend that I want

191
00:12:09,404 --> 00:12:12,066
to use. I'm going to use the v zero syntax,

192
00:12:12,258 --> 00:12:16,294
specify the context. That's like where I can copy in files from. For my

193
00:12:16,332 --> 00:12:20,262
copy command I specify my docker file, which is in my present working

194
00:12:20,316 --> 00:12:23,926
directory. And then here we're giving it some output options. So we want to output

195
00:12:23,958 --> 00:12:26,938
as an image. This is specifying the back end that we showed earlier. There's a

196
00:12:26,944 --> 00:12:30,780
couple of different backends. I can just make a tar file or whatever. So here

197
00:12:31,230 --> 00:12:34,350
frontend, here back end I'm going to give it a name

198
00:12:34,420 --> 00:12:38,074
and tell it to push it. So I'm going to actually push it to Dockerfile

199
00:12:38,202 --> 00:12:44,414
Agbell test. So let's run that and

200
00:12:44,452 --> 00:12:45,040
then,

201
00:12:47,110 --> 00:12:50,722
so we pushed it there. Let's test

202
00:12:50,776 --> 00:12:53,540
by pulling it test.

203
00:12:54,550 --> 00:12:57,814
Actually you know what we should do is change this here.

204
00:12:57,932 --> 00:13:01,800
So let's call this build bit build.

205
00:13:02,970 --> 00:13:06,870
Let's run this again so that we can differentiate

206
00:13:08,030 --> 00:13:11,674
and then we'll pull bit and then we can run it

207
00:13:11,792 --> 00:13:15,020
with Docker run.

208
00:13:15,470 --> 00:13:19,354
It was called AGBL test. And then we want to open

209
00:13:19,392 --> 00:13:23,338
a shell and then if we look at our

210
00:13:23,504 --> 00:13:26,862
build txt, there we go, build bit built.

211
00:13:26,916 --> 00:13:30,110
So we just built this file using buildkit directly.

212
00:13:32,370 --> 00:13:36,130
So now we're getting somewhere. So let's do something a little bit more advanced.

213
00:13:37,110 --> 00:13:39,918
If you remember, let's open up a new file.

214
00:13:40,014 --> 00:13:43,602
The way that buildkit's working is you have your front

215
00:13:43,656 --> 00:13:48,038
end and it's going to send LLB to

216
00:13:48,124 --> 00:13:51,686
build bit to the

217
00:13:51,708 --> 00:13:55,826
build kit daemon which can send LLB

218
00:13:56,018 --> 00:13:59,020
to back end.

219
00:13:59,390 --> 00:14:02,234
So let's just inject ourselves here.

220
00:14:02,272 --> 00:14:06,026
Let's programmatically build a front end. So to do

221
00:14:06,048 --> 00:14:10,134
that, all we need to do is build up this LLB and then send

222
00:14:10,192 --> 00:14:13,690
it. And LLB is specified as a protobuff.

223
00:14:13,770 --> 00:14:17,806
So you just have to make like a GRPC request with like here's my

224
00:14:17,828 --> 00:14:22,320
protobuff. So I put together an example here.

225
00:14:23,570 --> 00:14:27,682
So you could do this in any language where you have support

226
00:14:27,736 --> 00:14:31,522
for protocol buffers. But what I've done is I've used go

227
00:14:31,576 --> 00:14:34,654
and that's because buildkit itself is written in go and they have the nice client

228
00:14:34,702 --> 00:14:38,642
library that I can just pull in. And that gives me the easy ability

229
00:14:38,706 --> 00:14:41,830
to put these together and see the various operations

230
00:14:42,890 --> 00:14:46,726
and even dig in and see how it works if I'd like. So this

231
00:14:46,748 --> 00:14:50,150
is just my translation of our original Docker file.

232
00:14:51,150 --> 00:14:55,190
So we're going to come from an image that is from Docker IO library

233
00:14:55,270 --> 00:14:59,446
alpine. You notice it's a little bit more explicit. I need to copy

234
00:14:59,478 --> 00:15:03,450
in a file from my context, which I'm going to specify.

235
00:15:03,790 --> 00:15:07,598
I'm going to copy my readme and name it there readme. Then I'm

236
00:15:07,604 --> 00:15:10,414
going to do a run. The run you can see is a little bit more

237
00:15:10,452 --> 00:15:13,806
explicit too. Back here we just have echoes here we have

238
00:15:13,828 --> 00:15:17,470
to wrap it in a shell. That's because these commands like Echo

239
00:15:17,550 --> 00:15:20,674
and sending it to a file, those are shell commands. So we need to run

240
00:15:20,712 --> 00:15:24,626
it inside of a shell. Okay. So this will generate all of

241
00:15:24,648 --> 00:15:28,130
our LLB. And up here in our main program

242
00:15:28,200 --> 00:15:31,670
all we're doing is just writing it to standard out. The reason

243
00:15:31,820 --> 00:15:35,382
is we're going to use build to kind of make this happen.

244
00:15:35,436 --> 00:15:38,906
But first let's just take a look at what we get.

245
00:15:39,088 --> 00:15:42,700
Yeah. So we can just run this

246
00:15:43,630 --> 00:15:46,906
and we just get all of the

247
00:15:47,088 --> 00:15:50,938
protocol buffer contents to standard out. And it's

248
00:15:50,954 --> 00:15:54,960
a binary format, so not super readable bit.

249
00:15:55,970 --> 00:15:59,600
What we can do is take it, it's clear.

250
00:16:00,130 --> 00:16:03,566
What we can do is take that output. We can send it to build which

251
00:16:03,588 --> 00:16:06,750
has a command called dump LLB. And then we'll pipe it through JQ.

252
00:16:06,830 --> 00:16:10,798
And we should get something more like a JSOn formatted.

253
00:16:10,974 --> 00:16:14,418
So now we can kind of see this is the raw commands that

254
00:16:14,424 --> 00:16:18,150
we are sending through. So this, you can see is our run

255
00:16:18,220 --> 00:16:22,114
command. We should be able to see. Here's our copy source

256
00:16:22,162 --> 00:16:25,126
and destination should have our context. Yeah,

257
00:16:25,148 --> 00:16:28,794
here's our local context that that copy from will run. Here's our

258
00:16:28,832 --> 00:16:32,346
from. So that's kind of what

259
00:16:32,368 --> 00:16:36,154
the raw LLB, I guess this is the formatted LLB looks

260
00:16:36,192 --> 00:16:39,660
like. So now let's just try to build this.

261
00:16:40,050 --> 00:16:42,400
So I'm going to do this.

262
00:16:44,050 --> 00:16:47,760
No, we haven't built it yet. Let's start with building it.

263
00:16:51,410 --> 00:16:52,800
So we'll clear.

264
00:16:56,210 --> 00:16:59,666
So same idea. We're going to pipe it to build CTL. We're going

265
00:16:59,688 --> 00:17:03,406
to pass it this local context, but now we're telling it to output

266
00:17:03,438 --> 00:17:06,642
an image and call that ag bell test and

267
00:17:06,696 --> 00:17:10,082
push bit. If you were like

268
00:17:10,136 --> 00:17:14,498
using this, if you wanted to build a more robust

269
00:17:14,594 --> 00:17:18,694
solution, you might want to have this application actually find

270
00:17:18,732 --> 00:17:21,706
out if build KitD was running,

271
00:17:21,808 --> 00:17:25,014
maybe start it up. If it wasn't, maybe have some error

272
00:17:25,062 --> 00:17:28,762
checking and whatever. But this is a nice way

273
00:17:28,816 --> 00:17:32,990
to test it out. We just rely on this build CTL tool to

274
00:17:33,060 --> 00:17:37,120
handle all of that for us. So this should be building our program

275
00:17:37,970 --> 00:17:42,206
and we can see it running right there and

276
00:17:42,228 --> 00:17:45,778
then just, we can pull it down just to make sure

277
00:17:45,944 --> 00:17:49,330
that it actually pushed it. And then same idea.

278
00:17:49,400 --> 00:17:53,454
We can do docker, run it AGL

279
00:17:53,502 --> 00:17:55,990
test and let's run a shell.

280
00:17:56,730 --> 00:18:01,400
And then inside the shell what was our file built

281
00:18:02,170 --> 00:18:05,320
instead of built? There we go, programmatically built.

282
00:18:06,410 --> 00:18:10,410
So that image will run anywhere where you have a container runtime.

283
00:18:11,070 --> 00:18:14,966
So I think this is cool because by popping

284
00:18:14,998 --> 00:18:19,114
into a programming language here rather than using a Docker file like

285
00:18:19,152 --> 00:18:22,346
this, if you need to do some things that are very complex, you have all

286
00:18:22,368 --> 00:18:25,994
the kind of control flow and structures and libraries

287
00:18:26,042 --> 00:18:29,454
and things that a programming language brings you, right? You can kind of

288
00:18:29,492 --> 00:18:34,142
raise the abstraction up. You could use it to get rid of duplication.

289
00:18:34,286 --> 00:18:38,340
I think it could be an interesting solution depending upon your use case.

290
00:18:39,030 --> 00:18:42,722
But front ends are actually

291
00:18:42,776 --> 00:18:46,280
usually more compiler than that, right? Like a front end usually

292
00:18:48,090 --> 00:18:51,334
instead of just sending LLB, it's usually more like

293
00:18:51,372 --> 00:18:54,706
taking in source code, which would be our dockerfile,

294
00:18:54,898 --> 00:18:58,098
and turning bit into tokens

295
00:18:58,274 --> 00:19:03,994
and then parsing those into an ast and

296
00:19:04,032 --> 00:19:07,670
then generating the LLB

297
00:19:07,830 --> 00:19:11,466
and sending it on. So let's try something a

298
00:19:11,488 --> 00:19:14,750
little bit more like that. That might actually take a little while.

299
00:19:14,820 --> 00:19:19,040
So I put together a little bit of an example front.

300
00:19:19,890 --> 00:19:23,518
You did I share this already? If you

301
00:19:23,524 --> 00:19:27,490
look in this repo, you'll find it. It is here in this IC file

302
00:19:27,990 --> 00:19:31,842
subfolder. So this is a Ic file. This is my own frontend

303
00:19:31,896 --> 00:19:35,426
that I put together for Docker. Docker has this

304
00:19:35,528 --> 00:19:38,786
syntax. When you call Docker build, if you specify

305
00:19:38,898 --> 00:19:42,146
syntax and then the name of a publicly accessible

306
00:19:42,258 --> 00:19:45,366
Dockerfile container, it will pull this down and it

307
00:19:45,388 --> 00:19:49,098
will use bit as the front end for building things. It'll expect

308
00:19:49,184 --> 00:19:53,238
it to take the source over GrPC

309
00:19:53,334 --> 00:19:56,506
to parse it, to tokenize it, I guess

310
00:19:56,528 --> 00:19:59,834
tokenize first and then parse, generate the LLB and then send

311
00:19:59,872 --> 00:20:03,614
that on to buildkit. So that is pretty cool because

312
00:20:03,652 --> 00:20:07,070
you don't even have to have people install anything. Docker will

313
00:20:07,140 --> 00:20:11,054
pull this down if you just specify this. So I built

314
00:20:11,092 --> 00:20:13,914
my own front end, which I'm calling an IC file.

315
00:20:14,042 --> 00:20:17,694
It's more of a proof of concept, but there exists this language called

316
00:20:17,732 --> 00:20:21,586
intrical, which is from the kind of built as a joke. I thought

317
00:20:21,608 --> 00:20:24,846
it was kind of humorous to build a front end for Dockerfile

318
00:20:24,878 --> 00:20:28,386
that looks somewhat like intrical. So mainly it

319
00:20:28,408 --> 00:20:31,190
does all the same things as a Docker file, it just uses different words.

320
00:20:31,260 --> 00:20:34,802
So instead of from we have come from, instead of copy

321
00:20:34,866 --> 00:20:38,402
you use stash, which kind of stash the files inside of your container.

322
00:20:38,466 --> 00:20:41,674
Instead of run, you use please, which is just more

323
00:20:41,712 --> 00:20:45,238
polite. Intragal was known

324
00:20:45,254 --> 00:20:48,682
for its please statements. So in integral every you could either say do

325
00:20:48,736 --> 00:20:52,118
or please do. And if you didn't say please enough times then the compiler

326
00:20:52,134 --> 00:20:55,838
would say like sorry, your program is not polite enough, I won't compile it.

327
00:20:55,924 --> 00:20:58,542
I think if you put too many please statements it would also say your program

328
00:20:58,596 --> 00:21:02,414
is too polite. Anyways, it's just a proof of concept, just for fun.

329
00:21:02,532 --> 00:21:06,050
But now that we are building a complete

330
00:21:06,120 --> 00:21:10,386
frontend and putting it in a docker container, we can actually build

331
00:21:10,568 --> 00:21:13,826
without even using buildkit, without using it

332
00:21:13,848 --> 00:21:17,798
directly, I guess. So let me show you what that might look like.

333
00:21:17,964 --> 00:21:22,226
So I guess first let's change it to my IC file folder

334
00:21:22,338 --> 00:21:26,086
and then it's just the standard docker builds. But we

335
00:21:26,108 --> 00:21:29,514
need to specify the file explicitly because it's not used to having

336
00:21:29,552 --> 00:21:32,986
something called Nic file. Then we'll tag it ic one so we can

337
00:21:33,008 --> 00:21:36,010
build that just standard dockerfile,

338
00:21:36,750 --> 00:21:40,700
no build CTL required. And then

339
00:21:41,710 --> 00:21:44,974
we can do the same thing, we'll pull it, what did I just

340
00:21:45,012 --> 00:21:48,334
call it? Oh, I guess I didn't push it. So I think we can just

341
00:21:48,372 --> 00:21:52,970
run it. So we want interactive,

342
00:21:53,130 --> 00:21:57,422
we want to run iq one and same thing. Let's get a shell

343
00:21:57,566 --> 00:22:00,834
and here we are inside of it, we can take a look. And if

344
00:22:00,872 --> 00:22:04,418
we look at cat built, we can see custom

345
00:22:04,504 --> 00:22:07,826
built front end. That is our image. So we have

346
00:22:07,848 --> 00:22:11,090
just built our own syntactical front end for docker files.

347
00:22:11,250 --> 00:22:14,706
I don't recommend you actually use this, but I think it is a nice proof

348
00:22:14,738 --> 00:22:18,646
of concept. So if you wanted to build your own syntax on the frontend for

349
00:22:18,668 --> 00:22:21,618
a docker file, this project could be a good place to start. What I did

350
00:22:21,644 --> 00:22:24,906
is I took one of the existing front ends for Docker and I

351
00:22:24,928 --> 00:22:28,570
yanked it out. So you'll find in here all the parsers for

352
00:22:28,640 --> 00:22:32,262
parsing the lines. You'll find the conversion steps for converting

353
00:22:32,326 --> 00:22:35,998
from the Dockerfile syntax to LLB. You will find

354
00:22:36,084 --> 00:22:39,678
the various commands for starting it up. But the main thing that I

355
00:22:39,684 --> 00:22:43,730
did was just look at the mapping for terminology to

356
00:22:43,880 --> 00:22:47,122
features and I replaced the existing commands with

357
00:22:47,176 --> 00:22:50,830
the intercal style keywords, such as using stash

358
00:22:50,910 --> 00:22:54,562
for copy or using please for

359
00:22:54,616 --> 00:22:57,330
run or health check is are you okay?

360
00:22:57,480 --> 00:23:00,486
Anyways, it's a fun little example that just shows some of the things that you

361
00:23:00,508 --> 00:23:03,874
might be able to do with these tools. And that concludes

362
00:23:03,922 --> 00:23:07,990
the demos. So I think this is pretty neat, but you might be imagining like

363
00:23:08,060 --> 00:23:12,162
who cares? We can create our own backend and front ends for containerization,

364
00:23:12,226 --> 00:23:15,514
but why would we? These examples are just proof of concept, but you can do

365
00:23:15,552 --> 00:23:19,094
real things with this. Something you could do is build your own AWS

366
00:23:19,142 --> 00:23:22,598
lambda clone, right? Like use the programmatic functionality that I has

367
00:23:22,624 --> 00:23:26,094
just showing earlier where you can build a service that

368
00:23:26,132 --> 00:23:29,466
takes in JavaScript. Maybe it just takes in a post request

369
00:23:29,498 --> 00:23:32,926
with some JavaScript and then programmatically builds a docker container with

370
00:23:32,948 --> 00:23:36,094
that in it and ships it off to kubernetes. That would actually not be that

371
00:23:36,132 --> 00:23:38,914
hard, right? As a proof of concept, you could probably do that in a couple

372
00:23:38,952 --> 00:23:42,494
hundred lines of code. You could also just build a specific image format

373
00:23:42,542 --> 00:23:45,966
for your. This is called a mocker file. The creator noted

374
00:23:45,998 --> 00:23:49,638
that Dockerfile in his organization were mainly just a list of a

375
00:23:49,644 --> 00:23:52,882
whole bunch of things that you need to call like Aptgeton.

376
00:23:52,946 --> 00:23:56,646
So you see this commands in Dockerfile files. One thing you can do

377
00:23:56,668 --> 00:24:00,706
is put one per line, but then just because of the way that Docker images

378
00:24:00,738 --> 00:24:03,498
get built, you end up with a whole bunch of layers. So the thing that

379
00:24:03,504 --> 00:24:07,066
happens more commonly is you build just like a giant line that has all

380
00:24:07,088 --> 00:24:10,358
these installs on it. That's kind of a mess, right? So Dockerfile,

381
00:24:10,454 --> 00:24:14,714
which is specified in Yaml, you just provide a list of packages and the Dockerfile

382
00:24:14,762 --> 00:24:18,794
will install each of these packages by just issuing those LLB requests.

383
00:24:18,842 --> 00:24:22,634
This mocker file is specified in Yaml, which depends. Sometimes like Yaml,

384
00:24:22,682 --> 00:24:25,646
sometimes I don't. But I think it really works for this use case. It nicely

385
00:24:25,678 --> 00:24:29,634
constrains the problem down to exactly that needed to be done for

386
00:24:29,672 --> 00:24:33,042
many docker image creation tasks. The other

387
00:24:33,096 --> 00:24:36,350
thing you could do with build bit, and this is probably my big messages,

388
00:24:36,430 --> 00:24:39,542
is I don't know, let's figure it out. We can't know what we can create

389
00:24:39,596 --> 00:24:43,506
until we do it. When LLVM was created, rust didn't exist and Swift didn't exist

390
00:24:43,538 --> 00:24:47,126
and Julia didn't exist. There was no pixel shader backend or

391
00:24:47,148 --> 00:24:50,674
webassembly, but these things were all enabled by it existing.

392
00:24:50,722 --> 00:24:53,718
And now we have this tool for creating cloud native workflows.

393
00:24:53,814 --> 00:24:57,030
What should we do with it? I work on this project called Earthly.

394
00:24:57,110 --> 00:25:01,066
We use some of these build kit features for doing pretty cool

395
00:25:01,168 --> 00:25:03,942
reproducible builds like CI pipelines.

396
00:25:04,086 --> 00:25:07,806
But I want to see more projects using it, like building on these foundations on

397
00:25:07,828 --> 00:25:11,274
a historical scale. I think we're really early in cloud computing,

398
00:25:11,322 --> 00:25:14,362
so we get to kind of decide what the future looks like.

399
00:25:14,436 --> 00:25:18,034
So your name here, your project here, I mean, what can you build

400
00:25:18,072 --> 00:25:21,230
with this? And one other thing, this kind of three stage

401
00:25:21,310 --> 00:25:23,890
compile solution is super useful.

402
00:25:24,310 --> 00:25:27,538
Compiler problems are hidden everywhere, and when you spot one,

403
00:25:27,624 --> 00:25:30,710
there's like a whole literature of how to solve compiler problems.

404
00:25:30,860 --> 00:25:34,454
So if you recognize something you're facing is actually a compiler problem,

405
00:25:34,572 --> 00:25:37,986
all of a sudden there are all kinds of tools you can use to solve

406
00:25:38,018 --> 00:25:41,686
it. There's more stuff about Buildkit that I also didn't get

407
00:25:41,708 --> 00:25:44,906
a chance to cover in the demo. It's more than just

408
00:25:44,928 --> 00:25:47,978
an old fashioned compiler. I've shown you how you can add front ends for it,

409
00:25:47,984 --> 00:25:51,322
but you might have noticed you can do that without requiring anybody to install things.

410
00:25:51,376 --> 00:25:55,114
You just have to reference the container it's in, because it unsurprisingly

411
00:25:55,162 --> 00:25:58,606
uses Docker containers for the different parts of its structure. But that's not

412
00:25:58,628 --> 00:26:02,030
all right. A traditional compiler is usually a pure function,

413
00:26:02,180 --> 00:26:05,486
kind of where it takes in all the source, does some stuff, and produces an

414
00:26:05,508 --> 00:26:09,282
output. But buildkit does more than that. It has workers which power

415
00:26:09,336 --> 00:26:12,798
a feature called Docker Build X, which let you build a single docker

416
00:26:12,814 --> 00:26:17,130
image for many machine architectures at once. You can run multiple architecture

417
00:26:17,230 --> 00:26:21,010
backend at the same time, and also it has really advanced

418
00:26:21,090 --> 00:26:24,854
caching. It's very cache efficient because it's expecting things

419
00:26:24,892 --> 00:26:28,406
to be called repeatedly, and so it can keep track of what steps can

420
00:26:28,428 --> 00:26:33,006
be skipped and replay them. Think about it like kind of like an incremental compiler.

421
00:26:33,138 --> 00:26:36,378
I worked in Scala for a long time. The compiler was super slow from a

422
00:26:36,384 --> 00:26:39,690
cold start, but when you were incrementally building things, it was super fast.

423
00:26:39,760 --> 00:26:43,654
So buildkit is kind of built from the ground up to be aggressively incremental.

424
00:26:43,702 --> 00:26:47,342
Another thing is, it's concurrent. Anytime you build something, we can kind of

425
00:26:47,396 --> 00:26:50,846
look at the structure of what you're building, determine what steps depend on

426
00:26:50,868 --> 00:26:54,586
others, and buildkit will run them in parallel where it can. And the coolest

427
00:26:54,618 --> 00:26:57,682
feature is probably that it can be distributed because

428
00:26:57,736 --> 00:27:00,786
you're using GRPC between these layers instead of just like a

429
00:27:00,808 --> 00:27:04,094
C API, like a standard compiler might use. It's trivial

430
00:27:04,142 --> 00:27:07,458
to actually have a cluster of these things. You could have a

431
00:27:07,464 --> 00:27:11,042
whole bunch of workers and they could be running on different machine architectures,

432
00:27:11,106 --> 00:27:14,258
or they could just be all in the cloud. So you can distribute your workload

433
00:27:14,354 --> 00:27:18,022
and you can distribute out the work that way. So I think that is super

434
00:27:18,076 --> 00:27:21,510
neat. So I am Adam Gordon Bell. This was my talk.

435
00:27:21,580 --> 00:27:24,934
You can find me basically anywhere by searching for that name. I'll share

436
00:27:24,972 --> 00:27:29,250
the links to the source for the examples. Build something cool using Buildkit

437
00:27:29,330 --> 00:27:32,318
and let me know about it if you're looking for inspiration, you can take a

438
00:27:32,324 --> 00:27:35,582
look at earthly, you can find it on GitHub or at Earthly Dev, thank you

439
00:27:35,636 --> 00:27:35,900
so much.

