1
00:00:27,170 --> 00:00:30,306
Hello, my name is Jeanne Grana, and today we're going to talk about Elm,

2
00:00:30,338 --> 00:00:33,110
which is a delightful language for front end development.

3
00:00:33,450 --> 00:00:36,854
When you want to do front end development today, you have to use

4
00:00:36,892 --> 00:00:40,278
JavaScript because it's everywhere. If you want

5
00:00:40,284 --> 00:00:43,586
to use react, angular, viseo, Vanilla JavaScript,

6
00:00:43,778 --> 00:00:48,120
you have to use JavaScript to have interactivity on your website.

7
00:00:48,970 --> 00:00:53,002
And the biggest advantage of JavaScript is that it's backward compatible.

8
00:00:53,066 --> 00:00:57,630
That means that if you have a website that is working today with JavaScript

9
00:00:58,530 --> 00:01:01,310
on it in 20 years,

10
00:01:01,380 --> 00:01:05,122
50 years, one century, it should still

11
00:01:05,176 --> 00:01:08,370
work because the web platform is backward compatible.

12
00:01:09,110 --> 00:01:12,626
It's a big advantage, I think. But for me it's also its

13
00:01:12,648 --> 00:01:17,558
biggest disadvantage, because if you can break

14
00:01:17,644 --> 00:01:21,298
compatible, you can deprecate things. That means you can't

15
00:01:21,394 --> 00:01:25,286
remove things from the language, even the

16
00:01:25,308 --> 00:01:28,898
things that are bitwell. For example, in JavaScript, if you

17
00:01:28,924 --> 00:01:32,202
try to compare null and zero, null greater than

18
00:01:32,256 --> 00:01:35,350
zero is false, null equals to zero is false,

19
00:01:35,430 --> 00:01:38,602
but null greater or equals to zero is true.

20
00:01:38,656 --> 00:01:40,730
So a little weird,

21
00:01:41,730 --> 00:01:46,334
but as this is in the language since

22
00:01:46,372 --> 00:01:49,662
the beginning, you can't remove that, because if some

23
00:01:49,716 --> 00:01:53,710
websites have dependencies on this, it will break.

24
00:01:53,780 --> 00:01:57,762
So if you have a look at the JavaScript syntax size over

25
00:01:57,816 --> 00:02:01,774
time it will only grow because you can remove

26
00:02:01,822 --> 00:02:05,086
anything that you add to the language. So each time you add a new

27
00:02:05,128 --> 00:02:08,710
tiny functionality, new tiny feature to the language,

28
00:02:09,370 --> 00:02:13,798
it will remain forever inside the language, especially during

29
00:02:13,964 --> 00:02:17,506
the new ES six version where we've added

30
00:02:17,538 --> 00:02:21,482
a lot of things. So everything is here to stay, and it will never

31
00:02:21,536 --> 00:02:23,450
be removed from the language,

32
00:02:24,590 --> 00:02:28,150
even the mistakes and badly designed API,

33
00:02:28,310 --> 00:02:30,220
if there are any.

34
00:02:31,870 --> 00:02:35,406
So there is a lot to learn because we're not using JavaScript the

35
00:02:35,428 --> 00:02:39,006
same way that it was conceived. So we've added a

36
00:02:39,028 --> 00:02:42,474
lot of features to the language, and the language

37
00:02:42,522 --> 00:02:46,162
has become quite complex. There are a lot of ways

38
00:02:46,216 --> 00:02:49,394
to do the same thing. For example, if you try to use

39
00:02:49,432 --> 00:02:52,546
asynchronous operation, you can have callbacks, you can

40
00:02:52,568 --> 00:02:56,126
have promise, you can have generators, you can have asynch

41
00:02:56,158 --> 00:03:00,294
await functions. There are a lot of things to

42
00:03:00,332 --> 00:03:04,006
learn, a lot of way to do things, and once you've learned them,

43
00:03:04,108 --> 00:03:08,118
you need to learn when to use one over another.

44
00:03:08,284 --> 00:03:12,054
So a lot of things to learn. But even after you've

45
00:03:12,102 --> 00:03:15,462
learned the language itself, you have to learn its ecosystem,

46
00:03:15,526 --> 00:03:19,130
because usually you will want to use some framework,

47
00:03:20,610 --> 00:03:25,310
some library, because the standard library in JavaScript is pretty poor.

48
00:03:25,810 --> 00:03:29,630
So you have to learn react angular view enough

49
00:03:29,700 --> 00:03:33,582
to know which one to use when, or if you even

50
00:03:33,636 --> 00:03:37,326
need to have a framework like that.

51
00:03:37,508 --> 00:03:41,342
And once you learn all of that, if you want to go to production,

52
00:03:41,486 --> 00:03:44,606
you need to learn a little bit about tooling in JavaScript.

53
00:03:44,718 --> 00:03:48,374
So how webpack works, how you can configure it,

54
00:03:48,572 --> 00:03:52,550
parcel, et cetera. So there are a lot of bundlers,

55
00:03:52,890 --> 00:03:56,200
but you have to learn this also.

56
00:03:56,890 --> 00:04:01,014
Another drawback of JavaScript is that it's by essence dynamic.

57
00:04:01,062 --> 00:04:05,638
That means you can reference some part of the code dynamically,

58
00:04:05,814 --> 00:04:09,254
making it hard to statically analyze

59
00:04:09,302 --> 00:04:12,630
the code. So it's hard to optimize. You can

60
00:04:12,790 --> 00:04:16,698
really do a good bitcode elimination or tree shaking

61
00:04:16,874 --> 00:04:20,334
because you're never sure that a chunk of code

62
00:04:20,372 --> 00:04:24,420
is not used. With ES six modules, you can now

63
00:04:24,870 --> 00:04:27,778
know for sure if a file isn't used,

64
00:04:27,944 --> 00:04:31,362
but you can't know if inside a file that is

65
00:04:31,416 --> 00:04:35,494
used, everything is used or not. So you have some

66
00:04:35,532 --> 00:04:40,866
assets that are bigger than expected because you're

67
00:04:40,898 --> 00:04:44,246
forced to use something to

68
00:04:44,268 --> 00:04:47,080
have some chunks of code that you are not using,

69
00:04:47,870 --> 00:04:51,882
but still you have a complex build state because we still want

70
00:04:51,936 --> 00:04:55,766
to eliminate everything that we can. So it's

71
00:04:55,798 --> 00:04:58,170
pretty hard to optimize as a language.

72
00:04:59,970 --> 00:05:03,386
But for me the main drawback

73
00:05:03,418 --> 00:05:07,600
of JavaScript, it's low confident level because

74
00:05:09,010 --> 00:05:12,542
for many reasons, for example because

75
00:05:12,596 --> 00:05:16,754
of new learn undefined values, you can have a runtime exception in

76
00:05:16,792 --> 00:05:21,074
production. I will even bet my house that the

77
00:05:21,112 --> 00:05:24,514
majority of bugs in JavaScript are

78
00:05:24,552 --> 00:05:28,178
caused by null pointer exception. Undefined is not a value,

79
00:05:28,344 --> 00:05:31,926
et cetera. So we will see that in elm it's a

80
00:05:31,948 --> 00:05:35,830
bit different. You have really

81
00:05:35,900 --> 00:05:39,990
minor editor assistance because as the language is dynamic,

82
00:05:40,150 --> 00:05:44,394
a tool can only assist you to

83
00:05:44,432 --> 00:05:48,886
a certain point, and after that it's

84
00:05:48,918 --> 00:05:52,474
up to you to fix things leading to painful

85
00:05:52,522 --> 00:05:55,726
refactoring. If you want a comparison, just have a look

86
00:05:55,748 --> 00:05:57,790
at the Java ecosystem.

87
00:05:59,730 --> 00:06:03,186
I'm not very fond of Java, but I have to admit they

88
00:06:03,208 --> 00:06:07,310
have a really wonderful ecosystem for tooling.

89
00:06:07,470 --> 00:06:10,734
You can do a lot of refactoring from your editor.

90
00:06:10,782 --> 00:06:14,906
It's pretty nice. The feedback

91
00:06:14,958 --> 00:06:18,918
cycle is pretty slow because often you

92
00:06:18,924 --> 00:06:22,646
will need to go to runtime to see if something

93
00:06:22,748 --> 00:06:26,802
is working or not. Even if you're practicing TDD

94
00:06:26,866 --> 00:06:30,086
test driven development, there are a few things that you won't

95
00:06:30,118 --> 00:06:33,900
notice until you try to actually run your code.

96
00:06:34,270 --> 00:06:37,130
So it's a pretty slow feedback cycle.

97
00:06:38,190 --> 00:06:41,466
And the main drawback

98
00:06:41,498 --> 00:06:45,230
for me is that dependencies in JavaScript are risky.

99
00:06:46,130 --> 00:06:49,802
I can talk about that during an entire session,

100
00:06:49,866 --> 00:06:52,954
so I won't go into further details

101
00:06:53,002 --> 00:06:56,626
right here, but I have got you two links that

102
00:06:56,648 --> 00:07:00,142
you can check. In NPM a package

103
00:07:00,206 --> 00:07:03,714
can do almost everything. So it can

104
00:07:03,832 --> 00:07:07,526
call another server, it can do

105
00:07:07,628 --> 00:07:11,106
whatever it wants. So installing

106
00:07:11,138 --> 00:07:13,910
a dependency is always risky.

107
00:07:14,410 --> 00:07:18,710
In NPM everything

108
00:07:18,780 --> 00:07:22,266
leads us to M. So what is M? Elm is a

109
00:07:22,288 --> 00:07:26,378
type functional language, create fast and reliable web application.

110
00:07:26,544 --> 00:07:30,150
There are a lot of things in this definition we will try to

111
00:07:30,240 --> 00:07:34,126
break things. So first we can notice that

112
00:07:34,148 --> 00:07:37,934
it's really domain specific. In the definition it

113
00:07:37,972 --> 00:07:40,640
says it's to build a web application.

114
00:07:42,470 --> 00:07:45,774
So it's not used as javascript in server

115
00:07:45,902 --> 00:07:50,206
or for your coffee machine or for your raspberry.

116
00:07:50,398 --> 00:07:53,646
It's only focused on websites and web applications,

117
00:07:53,678 --> 00:07:57,414
so it's really specific and it does

118
00:07:57,452 --> 00:07:59,560
only one thing and it does it well.

119
00:08:00,970 --> 00:08:04,822
Also it's something that is statically typed. We've talked

120
00:08:04,876 --> 00:08:08,794
about Javascript being dynamic in

121
00:08:08,832 --> 00:08:11,930
Elm it's not. So everything can be analyzed

122
00:08:12,670 --> 00:08:16,726
by your tools. That means many bugs don't

123
00:08:16,758 --> 00:08:20,346
even compile, so you cannot send some bugs

124
00:08:20,378 --> 00:08:23,866
to production because it won't compile. The editor

125
00:08:23,898 --> 00:08:27,274
can really help you with every refactoring.

126
00:08:27,402 --> 00:08:31,834
And when you try to refactor your code it's always compiler

127
00:08:31,882 --> 00:08:35,442
driven because you will change something

128
00:08:35,576 --> 00:08:39,422
and the compiler will throw nice and helpful

129
00:08:39,486 --> 00:08:43,154
errors to help you fix what

130
00:08:43,192 --> 00:08:47,110
you've just broken. So refactoring is compiler driven

131
00:08:47,450 --> 00:08:50,902
and the feedback cycle is really fast because as

132
00:08:50,956 --> 00:08:54,360
you get your errors instantly when you type your code,

133
00:08:55,530 --> 00:08:58,854
you can know if something is wrong. In fact,

134
00:08:58,892 --> 00:09:02,378
in arm we're saying that once it compiles it means

135
00:09:02,464 --> 00:09:05,500
it work. So pretty nice.

136
00:09:06,670 --> 00:09:10,502
It is safer. Don't trust my word.

137
00:09:10,656 --> 00:09:14,266
I have a graphic right here showing

138
00:09:14,298 --> 00:09:17,834
the runtime exception encountered by Noradink,

139
00:09:17,882 --> 00:09:22,334
which is a pretty big website elearning platform and

140
00:09:22,372 --> 00:09:25,730
a big user of Elm. So during three years

141
00:09:25,880 --> 00:09:29,646
there are like 62,000 Javascript

142
00:09:29,758 --> 00:09:33,346
runtime exception against

143
00:09:33,448 --> 00:09:36,740
almost zero runtime exception with m,

144
00:09:37,050 --> 00:09:39,190
which is quite impressive.

145
00:09:40,330 --> 00:09:43,990
Of course they have like 17,000

146
00:09:44,060 --> 00:09:49,178
line of code of JavaScript, so it's pretty

147
00:09:49,344 --> 00:09:52,730
dingling number, but you have to

148
00:09:52,800 --> 00:09:57,530
balance it with 200,000

149
00:09:57,600 --> 00:10:01,310
line of code of m. So 17,000

150
00:10:01,380 --> 00:10:06,286
line of code in JavaScript can trigger 62,000

151
00:10:06,468 --> 00:10:10,414
runtime exception while 200,000 line

152
00:10:10,452 --> 00:10:13,966
of code elm production almost zero exception.

153
00:10:14,078 --> 00:10:18,210
So it's a language that is by design really safer

154
00:10:18,550 --> 00:10:19,970
for your production.

155
00:10:21,830 --> 00:10:25,714
So it's a functional programming

156
00:10:25,762 --> 00:10:29,110
language. So functional programming is blah blah blah.

157
00:10:29,450 --> 00:10:33,826
In fact, I don't care about the academic definition of functional programming.

158
00:10:33,938 --> 00:10:37,894
For me, functional programming just means that it's

159
00:10:37,942 --> 00:10:42,442
honest. It's being honest. Let me explain my

160
00:10:42,496 --> 00:10:46,134
point. So in JavaScript,

161
00:10:46,182 --> 00:10:49,562
for example, if you have a send

162
00:10:49,616 --> 00:10:52,942
email function here, when you're calling

163
00:10:52,996 --> 00:10:56,334
this function, if you don't look at the body, you don't know what

164
00:10:56,372 --> 00:10:59,918
happens, anything can happen. And for example,

165
00:11:00,004 --> 00:11:03,402
you don't know that if the user email is not provided,

166
00:11:03,466 --> 00:11:06,706
it will throw can error. And if you

167
00:11:06,728 --> 00:11:10,162
don't know that, you don't use try catch around

168
00:11:10,216 --> 00:11:13,470
your code and you won't catch this error in production.

169
00:11:13,550 --> 00:11:17,494
So in production you have something that can be broken just because you

170
00:11:17,532 --> 00:11:20,802
don't know how the send email function is implemented.

171
00:11:20,946 --> 00:11:24,354
But it could be even worse. For example, you could launch

172
00:11:24,402 --> 00:11:28,300
a nuclear missiles on somebody or

173
00:11:29,470 --> 00:11:32,426
transmit your credentials to someone.

174
00:11:32,608 --> 00:11:36,870
So with functional programming you wouldn't

175
00:11:37,030 --> 00:11:40,542
be exposed to this kind of things, because in

176
00:11:40,596 --> 00:11:44,590
Elm side effects are

177
00:11:44,740 --> 00:11:48,558
explicitly declared. So if your function can produce side effect,

178
00:11:48,724 --> 00:11:53,186
for example sending something over network or anything

179
00:11:53,288 --> 00:11:56,642
else, your function will

180
00:11:56,776 --> 00:12:00,734
show that it does something, so you can't have unwanted

181
00:12:00,862 --> 00:12:04,674
side effect. That's why I talk about honesty, because a

182
00:12:04,712 --> 00:12:08,360
function says exactly what it does and

183
00:12:10,730 --> 00:12:13,750
it doesn't do anything that you can ignore.

184
00:12:14,810 --> 00:12:18,522
The language is really fast, everything is static, so you can

185
00:12:18,576 --> 00:12:22,300
eliminate every chunks of code that is not used. You know

186
00:12:23,390 --> 00:12:26,810
everything that is used in phase language, pretty nice.

187
00:12:26,960 --> 00:12:31,286
Everything is pure. So you can have further optimization

188
00:12:31,398 --> 00:12:34,794
from uglyphage. Yes, so you have smaller

189
00:12:34,842 --> 00:12:38,138
lets and you can have some comparison

190
00:12:38,234 --> 00:12:42,560
on Internet. So it's really fast.

191
00:12:44,210 --> 00:12:48,260
If you have a look at the guide of Elm, you can see

192
00:12:48,630 --> 00:12:51,506
this sentence that is quite important to me.

193
00:12:51,688 --> 00:12:55,286
Elm has a very strong emphasis on simplicity, ease of use and

194
00:12:55,308 --> 00:12:58,966
quality tooling. And behind this simple sentence you

195
00:12:58,988 --> 00:13:02,562
have all the philosophy of m focusing on simplicity,

196
00:13:02,626 --> 00:13:06,194
so the language will decrease in syntax

197
00:13:06,242 --> 00:13:09,514
over time. It's really easy to use and everything is

198
00:13:09,552 --> 00:13:13,226
done for newcomers to not be lost. And the

199
00:13:13,248 --> 00:13:17,158
tooling is really good. So simplicity and ease

200
00:13:17,174 --> 00:13:20,606
of use, because it's focused on one purpose, so you don't need a lot of

201
00:13:20,628 --> 00:13:24,382
features inside the language. You have a

202
00:13:24,516 --> 00:13:28,046
very small list of features and you

203
00:13:28,068 --> 00:13:33,570
can learn it really fast. Even over

204
00:13:33,640 --> 00:13:38,130
time the language has lost some syntax

205
00:13:39,030 --> 00:13:42,142
more than adding more syntax.

206
00:13:42,206 --> 00:13:46,306
So it's simpler and simpler. The API

207
00:13:46,338 --> 00:13:50,406
are really well thought because you can break things because the

208
00:13:50,428 --> 00:13:53,654
language is compiled. So when you compatible things,

209
00:13:53,772 --> 00:13:56,854
you don't care about what was original source code,

210
00:13:56,972 --> 00:14:00,310
so you can deprecate things between versions.

211
00:14:00,470 --> 00:14:04,106
It's not a problem. In Elm everything is

212
00:14:04,128 --> 00:14:07,334
explicit, meaning that there's nothing hidden.

213
00:14:07,382 --> 00:14:11,130
Like in JavaScript, everything is honest and explicit.

214
00:14:12,110 --> 00:14:15,118
The quality stooling when you install,

215
00:14:15,204 --> 00:14:18,478
for example, Elm, you have a compiler install, a project

216
00:14:18,564 --> 00:14:21,402
starter, a package manager, a dev environment,

217
00:14:21,466 --> 00:14:25,198
a ripple to execute some Elm command in

218
00:14:25,204 --> 00:14:29,362
the terminal, and a Doc tool and

219
00:14:29,416 --> 00:14:32,494
the test runner. There are two test runners in Elm,

220
00:14:32,542 --> 00:14:35,942
but they are compatible with each other and everybody is using

221
00:14:35,996 --> 00:14:40,066
the same test library. So it's

222
00:14:40,098 --> 00:14:43,522
really nice. The documentation

223
00:14:43,586 --> 00:14:47,962
is enforced, meaning you can publish a package without having

224
00:14:48,016 --> 00:14:51,738
a documentation with it, and it's all available

225
00:14:51,904 --> 00:14:55,066
on the website, on the end

226
00:14:55,088 --> 00:14:58,714
package website. So it looks like that it's pretty nice.

227
00:14:58,912 --> 00:15:02,734
So you're never lost with someone else's code

228
00:15:02,852 --> 00:15:07,070
because you have some documentation. The versioning is enforced.

229
00:15:07,490 --> 00:15:11,246
I don't know if you're familiar with semantics training,

230
00:15:11,348 --> 00:15:15,614
but it's this triplet of numbers representing

231
00:15:15,662 --> 00:15:18,914
the version. The last one is called the

232
00:15:18,952 --> 00:15:22,594
fixed number, and when you increment it, it means

233
00:15:22,632 --> 00:15:26,198
that nothing has changed for the outside world. So anybody

234
00:15:26,284 --> 00:15:30,274
that relied on your package can update safely

235
00:15:30,322 --> 00:15:33,990
without breaking anything. But as soon as

236
00:15:34,140 --> 00:15:37,426
you've added something to your API, you need

237
00:15:37,468 --> 00:15:40,890
to increment the second number that is called the minor.

238
00:15:41,630 --> 00:15:45,274
That means something was added, but it won't break

239
00:15:45,472 --> 00:15:48,806
any people's code because it's only something that was added.

240
00:15:48,918 --> 00:15:52,394
But as soon as you have a breaking

241
00:15:52,442 --> 00:15:55,898
change, so you remove something, you change a behavior

242
00:15:55,994 --> 00:15:59,770
or anything else you need to increment the major version.

243
00:15:59,930 --> 00:16:03,746
So in NPM this is used, but it's only a

244
00:16:03,768 --> 00:16:07,186
convention, so it depends on the maintainer of the

245
00:16:07,208 --> 00:16:11,086
package. If they make a mistake or ignore this rule,

246
00:16:11,278 --> 00:16:14,900
you can update your dependencies and break your application.

247
00:16:15,850 --> 00:16:20,534
It's not possible because the compiler will

248
00:16:20,572 --> 00:16:23,654
decide which version your package has. So for

249
00:16:23,692 --> 00:16:27,654
example, if you try to break something, the compatible will

250
00:16:27,692 --> 00:16:31,654
say okay, it's a major version, so you need to increment the measure version.

251
00:16:31,782 --> 00:16:34,490
So when you update your dependencies,

252
00:16:35,390 --> 00:16:38,762
you're sure you won't break anything. So it's pretty

253
00:16:38,816 --> 00:16:42,090
nice. The community is awesome.

254
00:16:42,240 --> 00:16:45,386
In fact, if you have a look at the talks of the creator

255
00:16:45,418 --> 00:16:49,418
of the language events applications, you can see that it's

256
00:16:49,434 --> 00:16:53,186
mainly focused on how to build a community, how to animate it,

257
00:16:53,368 --> 00:16:55,620
how to build trust in the community,

258
00:16:56,630 --> 00:17:00,354
and a reflection on what is success on

259
00:17:00,392 --> 00:17:05,842
the online communities. So these

260
00:17:05,896 --> 00:17:09,094
threadholes are really nice. So if you

261
00:17:09,132 --> 00:17:12,934
want to have a look, we have the links to the slide at the

262
00:17:12,972 --> 00:17:17,110
end of the presentation. This Community gathers

263
00:17:17,850 --> 00:17:21,366
on slack and on a discourse which is

264
00:17:21,548 --> 00:17:23,720
a forum for m.

265
00:17:24,590 --> 00:17:27,866
So let's have a look at the syntax and for that we will go

266
00:17:27,888 --> 00:17:31,678
to the terminal and use

267
00:17:31,764 --> 00:17:35,166
elm repel. So as I said, when you install elm you have

268
00:17:35,188 --> 00:17:38,720
access to many tools. Here we will help

269
00:17:39,570 --> 00:17:43,440
use the repo, which will allow me to type

270
00:17:45,970 --> 00:17:49,250
some elm command inside my terminal.

271
00:17:51,590 --> 00:17:54,658
Lets me just move that.

272
00:17:54,744 --> 00:17:58,070
Okay, perfect. So let's start with something

273
00:17:58,140 --> 00:18:00,790
really simple. So for example a string,

274
00:18:01,690 --> 00:18:05,106
if you have a look at the return, it returns

275
00:18:05,138 --> 00:18:09,034
the value. So hello. And here you have the type of

276
00:18:09,072 --> 00:18:13,974
the return value. So here the type say it's a string with uppercase

277
00:18:14,022 --> 00:18:16,700
s. So let's try a number.

278
00:18:17,630 --> 00:18:21,406
First thing we can notice is that the

279
00:18:21,428 --> 00:18:25,162
type is a bit different. Here it's a number with lowercase

280
00:18:25,226 --> 00:18:28,782
n, because number only represents a type

281
00:18:28,836 --> 00:18:31,882
variable, meaning that the compiler

282
00:18:31,946 --> 00:18:35,566
knows that it's a number, but it don't know exactly what it is.

283
00:18:35,748 --> 00:18:39,554
Because in arm you have two types of number. You have float and

284
00:18:39,592 --> 00:18:43,170
you have int. So here the number is just a compiler saying

285
00:18:43,240 --> 00:18:46,854
okay, I know this is a number, but I'm not sure if it's float or

286
00:18:46,892 --> 00:18:50,582
an int. That's why we have a lowercase n right

287
00:18:50,636 --> 00:18:54,098
there. So you have some basic operation,

288
00:18:54,194 --> 00:18:58,106
for example the

289
00:18:58,128 --> 00:19:01,210
entire division. Here we have an int,

290
00:19:01,280 --> 00:19:06,022
so we can see an int, we can concatenate

291
00:19:06,086 --> 00:19:08,620
things maybe. Hello?

292
00:19:11,810 --> 00:19:16,238
So let's see something

293
00:19:16,324 --> 00:19:19,534
simple. Here we have some error from

294
00:19:19,572 --> 00:19:22,240
the compiler, because I've tried to,

295
00:19:23,250 --> 00:19:26,594
let's see the error. I cannot do addition with string values like this

296
00:19:26,632 --> 00:19:30,562
one. So in arm you don't concatenate things

297
00:19:30,616 --> 00:19:33,650
with the plus operator like in JavaScript,

298
00:19:34,310 --> 00:19:37,522
but you have to use the double plus operators.

299
00:19:37,586 --> 00:19:41,462
But if you have a look at this error, it's pretty nicely done,

300
00:19:41,516 --> 00:19:44,674
because the promise location

301
00:19:44,722 --> 00:19:49,270
of your code is displayed with a really great explanation

302
00:19:49,350 --> 00:19:52,666
of what happens and how you can

303
00:19:52,688 --> 00:19:56,838
fix that. So it's pretty nice. In elm

304
00:19:56,934 --> 00:20:00,206
the errors will guide you to

305
00:20:00,228 --> 00:20:02,960
working code, so it's pretty nice.

306
00:20:03,970 --> 00:20:08,126
So let's see, what do we have else we

307
00:20:08,148 --> 00:20:10,400
can have some variables. So for example,

308
00:20:11,570 --> 00:20:15,042
I can say is 42

309
00:20:15,176 --> 00:20:18,302
equals to true. So declaring

310
00:20:18,366 --> 00:20:22,386
a variable is just assigning a value to

311
00:20:22,408 --> 00:20:26,494
a name. And here for example, we have some conditions.

312
00:20:26,542 --> 00:20:30,920
So if 42

313
00:20:33,610 --> 00:20:36,866
so if you have a look at the syntax right here we don't

314
00:20:36,898 --> 00:20:40,666
have parentheses, we don't have brackets, only if

315
00:20:40,768 --> 00:20:44,394
the condition then here this

316
00:20:44,432 --> 00:20:48,620
is value that will be returned if it's true. So hello.

317
00:20:51,310 --> 00:20:59,246
Then you have a health and there you can return the

318
00:20:59,268 --> 00:21:02,446
value if it's false. When you

319
00:21:02,468 --> 00:21:06,050
try to press enter you can see that it returns a value.

320
00:21:06,120 --> 00:21:10,066
So in elm conditions are an

321
00:21:10,088 --> 00:21:14,014
expression and not a sentence like in JavaScript. In Javascript

322
00:21:14,062 --> 00:21:17,686
a condition doesn't return a value. In elm it

323
00:21:17,708 --> 00:21:21,174
does so this expression is

324
00:21:21,212 --> 00:21:24,550
equals to hello conf

325
00:21:24,620 --> 00:21:27,240
42. Okay,

326
00:21:28,010 --> 00:21:31,446
so we have foundation. It's a functional language. So let's

327
00:21:31,478 --> 00:21:34,842
create a function. To declare a function, you just

328
00:21:34,896 --> 00:21:38,438
have to write the name of the function, the parameters.

329
00:21:38,614 --> 00:21:42,014
So here let's say we have two parameters, a and b,

330
00:21:42,132 --> 00:21:45,646
and equals to the body of the function. So here it

331
00:21:45,668 --> 00:21:48,846
will be a plus b. So as you can see,

332
00:21:48,868 --> 00:21:52,670
the syntax is really simple, really straightforward,

333
00:21:54,770 --> 00:21:58,178
not a lot of characters to type. So pretty nice.

334
00:21:58,344 --> 00:22:01,666
If you have a look at the function signature, you can see

335
00:22:01,688 --> 00:22:05,060
that it's pretty new. That means that it's a function

336
00:22:05,370 --> 00:22:08,834
which takes one number, another number and returns

337
00:22:08,882 --> 00:22:09,640
a number.

338
00:22:11,290 --> 00:22:14,950
So this is a function type signature.

339
00:22:16,090 --> 00:22:19,320
What do we miss? So for example,

340
00:22:20,570 --> 00:22:23,660
the arrays in m are called list.

341
00:22:24,110 --> 00:22:26,620
So it's a list of a.

342
00:22:27,390 --> 00:22:31,814
A is like number tie variable. It's a compiler

343
00:22:31,862 --> 00:22:35,390
saying okay, it's a list of something, but I don't know yet what is

344
00:22:35,460 --> 00:22:38,686
inside. So it's a list of a. But if you

345
00:22:38,708 --> 00:22:42,442
put something inside like hello, it will say okay, I know,

346
00:22:42,516 --> 00:22:47,634
it's a list of string, which means you can't use different

347
00:22:47,832 --> 00:22:51,426
kind of value inside the list. If you try you will have an

348
00:22:51,448 --> 00:22:54,770
error from the compiler saying okay,

349
00:22:54,920 --> 00:22:59,346
the second element is a number. The previous elements were string,

350
00:22:59,458 --> 00:23:03,222
so there is something wrong. And if you want to do this

351
00:23:03,276 --> 00:23:06,566
anyway, you can have a look at this link to know how

352
00:23:06,588 --> 00:23:09,770
to do that. If you are trying to convert

353
00:23:10,590 --> 00:23:14,154
this isnt to a string, you can use this function.

354
00:23:14,272 --> 00:23:17,834
So as you can see it will try to

355
00:23:17,872 --> 00:23:21,914
learn to teach you how to fix your mistake.

356
00:23:21,962 --> 00:23:25,470
So that's really helpful.

357
00:23:26,850 --> 00:23:30,334
We also have some tuples which is two or

358
00:23:30,372 --> 00:23:33,842
three values when you want. For example,

359
00:23:33,896 --> 00:23:37,490
to return two values from a function you can return a tuple.

360
00:23:39,590 --> 00:23:43,106
Okay, you can have three value inside the poll if

361
00:23:43,128 --> 00:23:46,502
you want. If you have more complex data

362
00:23:46,556 --> 00:23:50,934
structure you can use something that

363
00:23:50,972 --> 00:23:54,374
isnt, sorry, you can use something that looks

364
00:23:54,412 --> 00:23:58,346
like objects in JavaScript. So for example I

365
00:23:58,368 --> 00:24:03,290
can say that I have an object with a login being Jordan

366
00:24:04,510 --> 00:24:09,530
and the password being password.

367
00:24:10,450 --> 00:24:13,870
Wait, I need to be safe right

368
00:24:13,940 --> 00:24:17,680
here. Perfect. So this is a record.

369
00:24:21,890 --> 00:24:23,780
So this is a record, sorry.

370
00:24:24,950 --> 00:24:28,946
With two elements, a login and a

371
00:24:28,968 --> 00:24:32,180
password. So perfect,

372
00:24:33,430 --> 00:24:39,560
sometimes, often in arm you will try to type

373
00:24:40,410 --> 00:24:43,974
your value. So you will have to type this and as

374
00:24:44,012 --> 00:24:47,802
it's pretty long you will often use

375
00:24:47,856 --> 00:24:51,786
type aliases. So you can create a type alias and

376
00:24:51,808 --> 00:24:55,274
say okay, the user is the same

377
00:24:55,312 --> 00:24:58,060
thing that exactly this.

378
00:25:00,450 --> 00:25:03,534
And then you have access to a new function that

379
00:25:03,572 --> 00:25:07,520
was created with this declaration, which is the user function

380
00:25:08,450 --> 00:25:12,062
that can create a user. So the user function

381
00:25:12,116 --> 00:25:16,158
is a function that is expecting one string, another string, and returns

382
00:25:16,254 --> 00:25:24,178
a user. So if you do something

383
00:25:24,264 --> 00:25:28,262
like that, you will have a user with

384
00:25:28,396 --> 00:25:32,118
a login jordan and a password. So this is

385
00:25:32,204 --> 00:25:35,106
the first kind of type that you can create a type alias.

386
00:25:35,138 --> 00:25:39,154
So it's helpful, but it's not revolutionary.

387
00:25:39,282 --> 00:25:42,886
But in arm you also have custom types.

388
00:25:42,918 --> 00:25:46,074
So custom types are very

389
00:25:46,112 --> 00:25:49,446
much like an enemy in typescript or Java.

390
00:25:49,558 --> 00:25:52,686
So for example, let's take

391
00:25:52,708 --> 00:25:56,238
a JavaScript example. You want to retrieve something

392
00:25:56,324 --> 00:25:58,634
from the server. So a string,

393
00:25:58,762 --> 00:26:02,126
so you will declare a

394
00:26:02,148 --> 00:26:05,566
variable like that, for example, that will

395
00:26:05,588 --> 00:26:09,410
be new at first, then a boolean

396
00:26:10,710 --> 00:26:13,860
that will be false. True, sorry,

397
00:26:15,670 --> 00:26:19,330
you want to know if it's an error, so you have another boolean,

398
00:26:19,490 --> 00:26:23,202
okay. And you have three variables to represent

399
00:26:23,266 --> 00:26:26,614
only one thing. It's a remote string that we

400
00:26:26,652 --> 00:26:30,338
will fetch on your server that can be loading, that can be on

401
00:26:30,364 --> 00:26:34,054
error. So you have three variables

402
00:26:34,102 --> 00:26:37,754
only for this concept. And for

403
00:26:37,792 --> 00:26:41,690
example right here is loading is true and is can error is true

404
00:26:41,760 --> 00:26:45,162
also, which is kind of weird because if there was an error,

405
00:26:45,226 --> 00:26:49,162
it shouldn't be loading or not. So you have some incompatible

406
00:26:49,226 --> 00:26:52,814
states that can happen. In arm you will

407
00:26:52,932 --> 00:26:57,218
create a new type and say okay, my rematch string is something

408
00:26:57,384 --> 00:27:01,202
that is maybe not loaded or maybe

409
00:27:01,256 --> 00:27:05,090
it's loaded. So here it looks a lot like can enume,

410
00:27:05,450 --> 00:27:09,654
but you can also say that it's loaded and it contains a

411
00:27:09,692 --> 00:27:14,082
string. So this variant of the enume

412
00:27:14,146 --> 00:27:17,866
can contain a string, but you

413
00:27:17,888 --> 00:27:21,414
can also say for example, it's an error as it contains

414
00:27:21,542 --> 00:27:24,140
one error code and one error message.

415
00:27:28,830 --> 00:27:31,822
Oh, sorry,

416
00:27:31,876 --> 00:27:35,726
it's coding. So as

417
00:27:35,748 --> 00:27:38,320
you can see, the error is pretty nice too.

418
00:27:39,810 --> 00:27:43,362
So after that I can say okay,

419
00:27:43,416 --> 00:27:47,566
my remote string is equals to not loaded.

420
00:27:47,758 --> 00:27:51,454
So you have a remote string that is not loaded. When it's

421
00:27:51,502 --> 00:27:55,206
loading, you can say okay, it's loading. Or you

422
00:27:55,228 --> 00:27:58,914
can say okay, you've retrieved the string.

423
00:27:58,962 --> 00:28:03,266
So it contains the string. Hello, it seems something loaded.

424
00:28:03,378 --> 00:28:09,994
Or you can say there was an error 400

425
00:28:10,112 --> 00:28:11,450
bad request.

426
00:28:14,030 --> 00:28:18,198
So this is kind of like can enumerate

427
00:28:18,214 --> 00:28:21,710
but with values inside.

428
00:28:21,780 --> 00:28:25,166
So it's pretty nice to really represent what you

429
00:28:25,188 --> 00:28:26,350
want to represent.

430
00:28:27,650 --> 00:28:31,150
Okay, do we have null?

431
00:28:32,630 --> 00:28:37,122
We don't have null inside the language maybe undefined now.

432
00:28:37,256 --> 00:28:40,180
In elm we have something that is called nothing.

433
00:28:40,630 --> 00:28:44,402
So pretty nice. I've just renamed it. In fact,

434
00:28:44,456 --> 00:28:48,038
if you have a look at the null reference on Google,

435
00:28:48,204 --> 00:28:52,946
you can maybe find this quote

436
00:28:52,978 --> 00:28:56,146
from Tony orr. I call it my billion dollar mistake.

437
00:28:56,178 --> 00:28:59,526
So Tony orr is the inverter of the new reference.

438
00:28:59,638 --> 00:29:03,414
So it says this is my billion dollar mistake.

439
00:29:03,542 --> 00:29:06,534
This has led to innumerable errors,

440
00:29:06,582 --> 00:29:09,814
vulnerabilities and system crashes. So Tony Rose

441
00:29:09,862 --> 00:29:13,646
advised to not use the null reference because this is what can

442
00:29:13,668 --> 00:29:17,694
cause runtime exception. So in l we've not

443
00:29:17,732 --> 00:29:21,354
just renamed undefined

444
00:29:21,402 --> 00:29:25,202
it to nothing is something quite special. If you have a look

445
00:29:25,256 --> 00:29:28,786
at the type, it's something that is

446
00:29:28,808 --> 00:29:32,482
a maybe of something. So this is a type variable, we are getting

447
00:29:32,536 --> 00:29:36,006
used to that. So this is a maybe. A maybe is a

448
00:29:36,028 --> 00:29:39,558
custom type defined like this. So maybe of a

449
00:29:39,724 --> 00:29:43,926
is nothing or just something

450
00:29:44,028 --> 00:29:49,002
of type a. So for example, you can say my

451
00:29:49,056 --> 00:29:53,210
string is nothing, meaning it has no value,

452
00:29:53,360 --> 00:29:57,018
or you can say it's just hello.

453
00:29:57,184 --> 00:30:00,638
So it contains a value which is hello.

454
00:30:00,804 --> 00:30:04,602
So the main difference with Javascript is that the compiler

455
00:30:04,666 --> 00:30:08,922
knows because of the type of the variable

456
00:30:09,066 --> 00:30:12,974
that it's can ab and it can be nothing.

457
00:30:13,172 --> 00:30:17,294
So you have to handle every case in arm, so the compatible will force

458
00:30:17,342 --> 00:30:20,914
you to handle the case where it's nothing. That's why

459
00:30:21,032 --> 00:30:24,894
you can't have any runtime exception because of undefined values

460
00:30:24,942 --> 00:30:27,720
in elm. That's pretty nice.

461
00:30:28,890 --> 00:30:32,134
I think we've seen almost all syntax, just two things

462
00:30:32,172 --> 00:30:35,942
we haven't seen. If you have a complex expression like here,

463
00:30:35,996 --> 00:30:39,702
you can use a latin block to split it.

464
00:30:39,756 --> 00:30:43,074
For example here I've split it into two variables,

465
00:30:43,122 --> 00:30:46,886
24 and 1624 and

466
00:30:46,908 --> 00:30:50,206
16. In the in you can use the

467
00:30:50,228 --> 00:30:54,160
variable that you've declared right in the lip block. So pretty simple.

468
00:30:55,250 --> 00:30:58,766
And you have the case of expression, which is kind of a

469
00:30:58,788 --> 00:31:02,366
switch in JavaScript, except that

470
00:31:02,388 --> 00:31:06,500
you're not matching the value itself, but also

471
00:31:06,870 --> 00:31:10,194
the pattern, the structure of this

472
00:31:10,232 --> 00:31:13,794
value. So for example here I can say if it's equal to zero,

473
00:31:13,912 --> 00:31:16,966
okay, I will return zero. If it's equal to one, I will

474
00:31:16,988 --> 00:31:20,550
return one. But if it's anything else, and here anything

475
00:31:20,620 --> 00:31:24,582
else is a variable, so it can catch every

476
00:31:24,636 --> 00:31:27,240
structure. Because a variable can contain anything,

477
00:31:27,870 --> 00:31:31,546
I will return that. If I'm not using this

478
00:31:31,568 --> 00:31:34,986
variable, the convention is to use an underscore to

479
00:31:35,008 --> 00:31:39,002
say I won't use the value. You can

480
00:31:39,056 --> 00:31:43,478
also use case of on custom types it's

481
00:31:43,494 --> 00:31:47,402
its main use case. For example here I have a maybe of string.

482
00:31:47,466 --> 00:31:50,960
I can say if it's nothing I will return my string maybe.

483
00:31:51,330 --> 00:31:55,060
But if it's equal, for example to just hello,

484
00:31:56,550 --> 00:31:59,714
it will match with this member and

485
00:31:59,752 --> 00:32:03,186
it will say okay, my string will contain hello. So my string is

486
00:32:03,208 --> 00:32:08,246
a variable that will contain hello and then you

487
00:32:08,268 --> 00:32:12,134
can return hello inside the body of this

488
00:32:12,172 --> 00:32:15,682
member. Okay, so to go further,

489
00:32:15,826 --> 00:32:19,734
we will build a really simple application in elm,

490
00:32:19,862 --> 00:32:23,180
which is head of tail. So really simple.

491
00:32:23,710 --> 00:32:26,474
If you have a look, we can start a new game.

492
00:32:26,672 --> 00:32:30,374
Here we have flipped a coin and we're asking

493
00:32:30,432 --> 00:32:34,366
the user to choose between head and tails. And maybe it

494
00:32:34,388 --> 00:32:36,990
will be right, maybe it won't.

495
00:32:37,970 --> 00:32:40,810
So if we have a look at the current version,

496
00:32:40,970 --> 00:32:44,226
this one, it's not doing anything. We only have the

497
00:32:44,248 --> 00:32:47,620
starting screen. So let's see the code.

498
00:32:48,790 --> 00:32:53,022
Looking at the code, so we have an index HTML file

499
00:32:53,166 --> 00:32:56,440
which will import the compiled program.

500
00:32:56,890 --> 00:33:00,630
So ElM compiles JavaScript and you can import

501
00:33:00,700 --> 00:33:04,214
the JavaScript inside your HTML, and then you will

502
00:33:04,332 --> 00:33:07,858
instantiate your application with the init method.

503
00:33:08,034 --> 00:33:12,342
So let's have a look at the code. Here we have the module declaration.

504
00:33:12,406 --> 00:33:15,786
So each file is a module and is declared with a

505
00:33:15,808 --> 00:33:19,754
name. It can expose something to other modules, then you can

506
00:33:19,792 --> 00:33:23,626
import something from other modules. So here we are

507
00:33:23,648 --> 00:33:27,822
importing some things to under a browser application and

508
00:33:27,876 --> 00:33:31,374
HTML. We'll see that later. And main is the

509
00:33:31,412 --> 00:33:34,786
earth of your program here. It's a program, as you can see

510
00:33:34,808 --> 00:33:36,370
with the type annotation.

511
00:33:38,310 --> 00:33:41,842
So it's a program which is an element. It means it will take

512
00:33:41,896 --> 00:33:45,266
control over an element inside the dome, and you

513
00:33:45,288 --> 00:33:50,542
have a few elements. So during

514
00:33:50,616 --> 00:33:54,134
application in Elm, we've noticed that we're always using the same

515
00:33:54,172 --> 00:33:57,630
pattern that was standardized under the helm architecture.

516
00:33:57,730 --> 00:34:01,754
So the ElM architecture is basically one

517
00:34:01,792 --> 00:34:05,130
data flow. So you have a model. A model is

518
00:34:05,200 --> 00:34:10,298
a type that you defined, and this type can

519
00:34:10,384 --> 00:34:14,450
contain every state of your application. So any variables

520
00:34:14,470 --> 00:34:18,494
that you can have inside your application is stored inside

521
00:34:18,612 --> 00:34:22,698
this type, the model that you define. So this model is

522
00:34:22,804 --> 00:34:26,626
given as parameter to a view function that you declare. So you

523
00:34:26,648 --> 00:34:29,874
have a view function that receives this model as

524
00:34:29,912 --> 00:34:34,306
argument, and you return some HTML to

525
00:34:34,328 --> 00:34:37,714
the end runtime. So you have a view function that returns

526
00:34:37,842 --> 00:34:40,886
the HTML that will be displayed. The runtime will

527
00:34:40,908 --> 00:34:44,678
display this HTML, and every time something happens,

528
00:34:44,764 --> 00:34:48,914
for example, when the user clicks on something, the runtime

529
00:34:48,962 --> 00:34:52,870
will generate a message, which is a type that you undefined

530
00:34:53,030 --> 00:34:56,170
yourself. So it will trigger a message. This message

531
00:34:56,240 --> 00:35:00,226
will be sent to another function that you declare, the update function. The update

532
00:35:00,278 --> 00:35:04,286
function will receive the current model, this message,

533
00:35:04,388 --> 00:35:07,390
until it will return a new model,

534
00:35:07,460 --> 00:35:10,986
a new updated model. This model will be transmitted

535
00:35:11,018 --> 00:35:14,494
to the view function to display the new view, et cetera.

536
00:35:14,622 --> 00:35:18,722
So it's a circular data flow that

537
00:35:18,776 --> 00:35:23,170
looks like a lot like redux if you're used to using

538
00:35:23,240 --> 00:35:27,750
redux because redux was inspired by Zelma architecture.

539
00:35:29,530 --> 00:35:32,520
So going back to the code,

540
00:35:33,290 --> 00:35:36,962
so we have the init function, which is the initial

541
00:35:37,026 --> 00:35:41,260
model. So here we can see that it's the first model of our applications.

542
00:35:41,710 --> 00:35:45,420
We also have something that is a command, we will see later what it is.

543
00:35:46,190 --> 00:35:49,514
We have the update function. Now let's start with the view function.

544
00:35:49,632 --> 00:35:53,326
So we have the view function. The view function receives the model,

545
00:35:53,428 --> 00:35:56,878
the model that we have declared right here. The model is a

546
00:35:56,884 --> 00:36:00,174
custom type with only one variant. It's in the first state

547
00:36:00,212 --> 00:36:01,920
of the applications in the game.

548
00:36:03,430 --> 00:36:07,394
So the view receives this model and returns some

549
00:36:07,432 --> 00:36:11,794
HTML. So in Elm, HTML is

550
00:36:11,832 --> 00:36:15,554
created by using n function, taking two arguments. The first

551
00:36:15,592 --> 00:36:19,142
one is a list of attributes, for example class id and

552
00:36:19,196 --> 00:36:23,382
click, et cetera. And the second is a list of child

553
00:36:23,436 --> 00:36:27,046
elements. So here the only child is a button with

554
00:36:27,068 --> 00:36:30,214
a class button primary containing

555
00:36:30,262 --> 00:36:33,946
the text start a new game. So if you have a look at the

556
00:36:33,968 --> 00:36:35,980
application, it's this button.

557
00:36:38,110 --> 00:36:40,860
Okay, sorry.

558
00:36:41,810 --> 00:36:45,486
And we have the update function which takes a message.

559
00:36:45,668 --> 00:36:49,294
The message is the type that we've declared here. We don't have any kind

560
00:36:49,332 --> 00:36:52,686
of message, so I've just put a

561
00:36:52,708 --> 00:36:55,950
placeholder or a message, so it receives

562
00:36:56,030 --> 00:36:59,714
a message, a model, and it returns a new model. But here,

563
00:36:59,752 --> 00:37:03,826
as you can see, we are always returning the safer model. So it's not

564
00:37:03,848 --> 00:37:07,800
doing anything. So our application cannot do anything because

565
00:37:08,250 --> 00:37:12,774
the update is not doing anything. So let's try

566
00:37:12,812 --> 00:37:16,566
to implement this second screen. So this one, so here it

567
00:37:16,588 --> 00:37:19,926
doesn't work. We need a second state in

568
00:37:19,948 --> 00:37:23,820
role model. So let's add a new state which is

569
00:37:24,190 --> 00:37:27,834
again state, meaning that we have

570
00:37:27,872 --> 00:37:31,566
started the game. So now what

571
00:37:31,588 --> 00:37:35,790
we need to do is check

572
00:37:35,860 --> 00:37:39,150
what is the model inside the view. So we will use case

573
00:37:39,220 --> 00:37:42,822
of and if it's a no game we can display

574
00:37:42,986 --> 00:37:46,402
what we were displaying for the

575
00:37:46,456 --> 00:37:49,060
start screen. But if it's a game,

576
00:37:49,910 --> 00:37:53,410
we need to display the game view. So I have a little

577
00:37:53,480 --> 00:37:56,726
helper right here. So when it's a game we

578
00:37:56,748 --> 00:37:59,910
can display the question and the two buttons.

579
00:38:00,330 --> 00:38:03,794
Let's try that. It doesn't

580
00:38:03,842 --> 00:38:07,454
work because if you have a look right here, we are not sending

581
00:38:07,522 --> 00:38:11,366
any message to the runtime.

582
00:38:11,558 --> 00:38:15,674
So here we need to create a new message to say

583
00:38:15,872 --> 00:38:19,418
okay, we need to flip the coin, so it's a

584
00:38:19,424 --> 00:38:22,510
message that you can create. And when

585
00:38:22,580 --> 00:38:25,440
we are clicking on the new start button,

586
00:38:26,530 --> 00:38:28,880
we will send this message.

587
00:38:30,530 --> 00:38:34,114
So on click, we will send this message to

588
00:38:34,152 --> 00:38:38,014
the application. So if we have a look, clicking on the button not trigger

589
00:38:38,062 --> 00:38:42,482
some messages. So we have some messages that

590
00:38:42,536 --> 00:38:45,486
are send it to the runtime.

591
00:38:45,678 --> 00:38:49,110
But if you have a look at the model, it never changed because update function

592
00:38:49,180 --> 00:38:51,778
is not doing anything as we said earlier.

593
00:38:51,954 --> 00:38:55,766
So let's have a look at the update function here. We need

594
00:38:55,788 --> 00:38:59,302
to know what has happened. So let's say that if

595
00:38:59,356 --> 00:39:02,310
our message is a flip coding,

596
00:39:03,870 --> 00:39:07,258
then we need to change the model. So the

597
00:39:07,264 --> 00:39:09,740
model was in the game and now we need a game.

598
00:39:10,910 --> 00:39:14,270
So let's have a look. And now it works.

599
00:39:14,340 --> 00:39:17,854
As you can see, we have a flipcoin message that is

600
00:39:17,892 --> 00:39:21,598
triggered. The flipcoin message is sent to the update function

601
00:39:21,684 --> 00:39:23,540
that will change the model to. Again,

602
00:39:25,510 --> 00:39:28,146
earlier I said that when you click on the button,

603
00:39:28,248 --> 00:39:33,746
you flip a coin. So here we need to store the

604
00:39:33,768 --> 00:39:37,526
coin state. So let's add a parameter to the game and

605
00:39:37,548 --> 00:39:40,120
say that it contains the coin state.

606
00:39:41,530 --> 00:39:44,934
So let's create a coin state model which is

607
00:39:45,052 --> 00:39:48,166
either head or tail. So as you

608
00:39:48,188 --> 00:39:51,546
can see, you can really represent what you want to represent. You don't have to

609
00:39:51,568 --> 00:39:55,226
use a boolean to implement things like that.

610
00:39:55,408 --> 00:39:58,778
So it contains a punch state. I have an error because

611
00:39:58,944 --> 00:40:02,010
my variant is wrong. So let's go to the error.

612
00:40:02,670 --> 00:40:06,560
So right here I need to give it something. Let's say I give it

613
00:40:07,250 --> 00:40:10,718
and here I don't care about what is the value. So I

614
00:40:10,724 --> 00:40:12,990
will just use underscore.

615
00:40:13,650 --> 00:40:17,026
It should compile. Yeah, it compiled so it works

616
00:40:17,208 --> 00:40:21,346
okay if I have a look now,

617
00:40:21,528 --> 00:40:25,090
my model contains again head, but here

618
00:40:25,160 --> 00:40:28,646
it's always head. So it's not very nice because the game would

619
00:40:28,668 --> 00:40:32,210
be pretty easy. So we need to generate a random

620
00:40:32,370 --> 00:40:35,906
coin. But in elm, remember it's a functional

621
00:40:35,938 --> 00:40:39,846
programming language, meaning there is no side effect. You can generate

622
00:40:39,878 --> 00:40:43,626
a random value because that will mean that the same function will return

623
00:40:43,728 --> 00:40:48,054
something different when you call it with the same parameters.

624
00:40:48,182 --> 00:40:50,300
So we need something else.

625
00:40:51,890 --> 00:40:55,406
In elm you don't execute side effects, you let the

626
00:40:55,428 --> 00:40:59,246
runtime execute them. So in the update function you can return a

627
00:40:59,268 --> 00:41:02,830
command, and the command is basically an order

628
00:41:02,900 --> 00:41:06,306
that you will give to the elm runtime to say, okay, I need

629
00:41:06,328 --> 00:41:10,114
you to do something, please do it and use

630
00:41:10,152 --> 00:41:13,474
a message to return the result value.

631
00:41:13,592 --> 00:41:17,106
So for example, here we want to generate

632
00:41:17,138 --> 00:41:20,230
a random coin. So we'll create a recipe

633
00:41:21,290 --> 00:41:25,026
to explain to the runtime how to generate random coin.

634
00:41:25,138 --> 00:41:28,406
We won't generate it, and the

635
00:41:28,428 --> 00:41:31,986
runtime will flip the coin according

636
00:41:32,018 --> 00:41:35,802
to the recipe and return the result

637
00:41:35,936 --> 00:41:39,594
inside the message. So the recipe is called

638
00:41:39,632 --> 00:41:43,882
a generator of coding state. So it's a generator that

639
00:41:43,936 --> 00:41:47,502
generates coinstate and then runtime will

640
00:41:47,556 --> 00:41:52,586
receive a command of type message that

641
00:41:52,628 --> 00:41:55,650
it will use to generate your value.

642
00:41:55,800 --> 00:41:58,866
So let's have a look. First we need to

643
00:41:58,888 --> 00:42:02,574
create a coding generator. So let's create a random coin

644
00:42:02,622 --> 00:42:06,930
which is a generator of coinstate.

645
00:42:08,810 --> 00:42:12,950
So for that we will use the random package.

646
00:42:13,610 --> 00:42:17,502
So we will say that it's a random uniform,

647
00:42:17,586 --> 00:42:21,466
so it's a uniform probability of

648
00:42:21,568 --> 00:42:25,338
ed or tail. So it will generate either

649
00:42:25,424 --> 00:42:28,010
ed or tail with a uniform probability.

650
00:42:29,230 --> 00:42:32,990
Here we cannot just give this argument because

651
00:42:33,140 --> 00:42:36,494
remember I said that the APIs were really well

652
00:42:36,532 --> 00:42:40,446
thought and what will happen if someone was

653
00:42:40,548 --> 00:42:44,498
using it like that? Here you're asking to the

654
00:42:44,584 --> 00:42:48,482
uniform method to generate a random value inside

655
00:42:48,616 --> 00:42:51,858
no value, so it cannot actually generate a

656
00:42:51,864 --> 00:42:55,906
value. So random universe needs a

657
00:42:55,928 --> 00:42:59,654
non empty list. And what is a not empty list? It's in fact

658
00:42:59,692 --> 00:43:03,398
a list with at least one element and another

659
00:43:03,484 --> 00:43:06,882
list that can be empty. So an unlist

660
00:43:06,946 --> 00:43:10,234
is one element and a list that

661
00:43:10,272 --> 00:43:13,722
can be empty. So it has always at least

662
00:43:13,776 --> 00:43:17,354
this element to generate. So here

663
00:43:17,392 --> 00:43:20,974
we have a random coin generator, and here in the

664
00:43:21,012 --> 00:43:25,050
update we need to tell the compiler

665
00:43:25,210 --> 00:43:27,950
that we want to generate a random coin.

666
00:43:28,450 --> 00:43:31,902
Once it has generated this value, we need to get it back.

667
00:43:31,956 --> 00:43:35,394
So for this we will create a new message

668
00:43:35,512 --> 00:43:38,450
which is coin flipped,

669
00:43:40,550 --> 00:43:42,660
which will contain a coding state.

670
00:43:44,070 --> 00:43:47,426
So we can give that as argument to nonhandled the generate.

671
00:43:47,538 --> 00:43:51,106
So once the coin is flipped, the compiler

672
00:43:51,138 --> 00:43:54,566
will return a new message that we

673
00:43:54,588 --> 00:43:58,154
need to end up. So here the coding has been flipped, so we can store

674
00:43:58,192 --> 00:44:01,834
it inside the state and we

675
00:44:01,872 --> 00:44:06,070
don't need any more side effects. So let's return command

676
00:44:06,150 --> 00:44:09,290
none. Here we haven't really a game

677
00:44:09,360 --> 00:44:12,606
add. We still have a new game waiting for the coin to be

678
00:44:12,628 --> 00:44:15,678
flipped. And now it will work. So if we

679
00:44:15,684 --> 00:44:19,200
have a look at the application, now we have a random value

680
00:44:19,650 --> 00:44:22,800
that is generated. Perfect.

681
00:44:23,510 --> 00:44:26,882
Let's create the third screen, the result screen.

682
00:44:26,936 --> 00:44:30,914
So let's create that with

683
00:44:30,952 --> 00:44:34,386
a game state. Once again we

684
00:44:34,408 --> 00:44:37,590
can create a type for the game state and say it is a win

685
00:44:37,660 --> 00:44:40,760
or loss. Okay,

686
00:44:41,370 --> 00:44:44,742
in the view function you have an error because you haven't under this case.

687
00:44:44,796 --> 00:44:47,240
So let's create the result view.

688
00:44:50,030 --> 00:44:53,290
Sorry. So perfect we have the result

689
00:44:53,360 --> 00:44:56,458
view. And now when we are clicking on this button,

690
00:44:56,544 --> 00:45:00,206
we need to decide what to display. So let's create a

691
00:45:00,228 --> 00:45:03,994
new message which is a player bet. So the player

692
00:45:04,042 --> 00:45:06,080
will bet on funcoin State.

693
00:45:08,290 --> 00:45:12,374
So here when we are clicking on ads, we want to generate

694
00:45:12,522 --> 00:45:14,420
a player, but on Ed.

695
00:45:15,910 --> 00:45:19,374
And here when we're clicking our tails want to generate

696
00:45:19,422 --> 00:45:21,170
a player, but on tail,

697
00:45:23,190 --> 00:45:26,486
so perfect, we have an error in the update because we

698
00:45:26,508 --> 00:45:30,230
are not handling the new message here. We will just say,

699
00:45:30,300 --> 00:45:30,920
okay,

700
00:45:34,730 --> 00:45:38,470
if my model equals

701
00:45:38,550 --> 00:45:42,666
to game has a coding state that the player is betting on,

702
00:45:42,768 --> 00:45:46,250
it's a win. Else it's a loss, sorry,

703
00:45:46,320 --> 00:45:47,770
else it's a loss.

704
00:45:49,470 --> 00:45:52,878
Okay, and we will use that and say this is a result

705
00:45:52,964 --> 00:45:56,526
containing the result and

706
00:45:56,628 --> 00:46:00,362
no command. Perfect. It compiles,

707
00:46:00,426 --> 00:46:04,026
it will work. Let's have a look where it is

708
00:46:04,148 --> 00:46:08,018
right here. So let's start a new game. As we can see,

709
00:46:08,184 --> 00:46:12,420
it's a tail. So if I click on tail, I win.

710
00:46:13,350 --> 00:46:16,722
Here it's tail again. So if I click

711
00:46:16,776 --> 00:46:20,486
on add it's hyper. So this is how

712
00:46:20,588 --> 00:46:23,750
you create application. In elm, you create some state,

713
00:46:23,820 --> 00:46:27,930
some model, then you have some message that can

714
00:46:28,000 --> 00:46:31,690
change the state of your application. And in the update function

715
00:46:31,760 --> 00:46:35,142
you're just updating your state accordingly.

716
00:46:35,286 --> 00:46:38,854
So it's pretty easy to understand and the compiler

717
00:46:38,902 --> 00:46:42,862
can really help you implement things because it will only

718
00:46:42,916 --> 00:46:45,680
compile when everything is done.

719
00:46:49,010 --> 00:46:52,886
So let's have a look at the advantage of Elm. So Elm

720
00:46:53,018 --> 00:46:56,622
has a really great developer experience because of the error messages,

721
00:46:56,686 --> 00:47:00,226
because of the tooling, because of the community, you have no

722
00:47:00,248 --> 00:47:03,060
runtime exception, which is pretty nice,

723
00:47:04,790 --> 00:47:08,198
very good. It has a great debugger, as you

724
00:47:08,204 --> 00:47:11,526
can see. I can see exactly what happens inside my application.

725
00:47:11,628 --> 00:47:14,870
I can go back in time to different state,

726
00:47:14,940 --> 00:47:17,618
I can export this to someone.

727
00:47:17,804 --> 00:47:21,014
So it's pretty nice. The type system is really powerful.

728
00:47:21,062 --> 00:47:24,570
It will always try to reduce

729
00:47:25,310 --> 00:47:29,114
the possibilities of your variables to handle less

730
00:47:29,152 --> 00:47:32,702
and less case. So it's really nice. The performance is really

731
00:47:32,756 --> 00:47:36,080
great and the community once again is amazing.

732
00:47:36,690 --> 00:47:40,474
It has some drawbacks, for example the governance

733
00:47:40,522 --> 00:47:44,318
model, it's basically a one man project because events

734
00:47:44,334 --> 00:47:48,338
API key is the one decided for everything. So if you're not

735
00:47:48,424 --> 00:47:51,342
happy with what he wants to do with the language,

736
00:47:51,406 --> 00:47:55,018
it's not good. So it depends

737
00:47:55,054 --> 00:47:58,566
on what you want. And some

738
00:47:58,588 --> 00:48:01,814
people find it a bit verbose because everything is

739
00:48:01,852 --> 00:48:05,558
explicit. So for example for navigation or something like that,

740
00:48:05,644 --> 00:48:10,610
you have to explicitly do something.

741
00:48:10,700 --> 00:48:14,282
But for me it's an advantage because you understand everything that

742
00:48:14,336 --> 00:48:18,822
happens, nothing is hidden. And the asymmetric

743
00:48:18,886 --> 00:48:23,066
Javascript communication can be a bit destabilizing.

744
00:48:23,098 --> 00:48:25,760
The debut at first, sorry,

745
00:48:27,410 --> 00:48:30,734
because you only can communicate with JavaScript through

746
00:48:30,852 --> 00:48:34,174
messages, so you send a message and you wait for an info.

747
00:48:34,302 --> 00:48:38,334
So it can be surprising

748
00:48:38,382 --> 00:48:41,346
at first. Why should you use them?

749
00:48:41,448 --> 00:48:44,466
Because you have a complex UI or complex model.

750
00:48:44,568 --> 00:48:48,262
A lot of change happening inside your application and you want to

751
00:48:48,396 --> 00:48:52,930
understand what is happening. Elm is really good for complex applications.

752
00:48:53,090 --> 00:48:56,310
You have frequent refactoring because ELm really

753
00:48:56,380 --> 00:49:00,078
shines during refactoring. You care for dogs?

754
00:49:00,114 --> 00:49:03,526
Of course, if you don't want your production

755
00:49:03,558 --> 00:49:06,700
to be full of dogs, Elm will help with that.

756
00:49:07,470 --> 00:49:11,514
If you want to go into programming functional programming language

757
00:49:11,562 --> 00:49:15,070
like SQL, ELM is really a gentle introduction

758
00:49:15,810 --> 00:49:19,358
to these languages. If you want

759
00:49:19,364 --> 00:49:22,954
to write better code, because since I've started Elm,

760
00:49:23,082 --> 00:49:28,030
my javascript has become more readable and better

761
00:49:28,100 --> 00:49:32,030
for me. You can start today working

762
00:49:32,100 --> 00:49:35,800
with elm with my workshop. So it's a workshop on GitHub that you can

763
00:49:36,970 --> 00:49:40,614
clone and then follow the steps. Everything is described inside

764
00:49:40,652 --> 00:49:43,986
the readme and if you want to have the link to this slide,

765
00:49:44,018 --> 00:49:47,570
they are available right here. Thank you for listening.

