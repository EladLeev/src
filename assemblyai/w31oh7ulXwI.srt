1
00:00:19,610 --> 00:00:22,926
Hello everyone, welcome to my presentation on unleashing the power of

2
00:00:22,948 --> 00:00:26,994
serverless for building scalable and cost solution using AWS

3
00:00:27,042 --> 00:00:30,294
Lambda and GQGen. In this presentation we are going to cover two

4
00:00:30,332 --> 00:00:34,054
most powerful technologies. One is serverless computing and another is

5
00:00:34,172 --> 00:00:37,394
one of the go popular library GQ gen for generating graphqL

6
00:00:37,442 --> 00:00:40,866
apps. We'll start by exploring what is serverless computing.

7
00:00:40,978 --> 00:00:44,202
Then we'll go in more deep dive about how we can implement using

8
00:00:44,256 --> 00:00:48,266
AWS lambda and then we are going to cover what is graphQL APIs and

9
00:00:48,288 --> 00:00:51,706
how we can implement using gqengine. Before going further, I just want to give a

10
00:00:51,728 --> 00:00:55,306
small introduction about myself. My name is Durgaprasad Budhwani. I'm working as a chief

11
00:00:55,338 --> 00:00:59,214
technologist at Tech nine throughout my career. I always fortunate enough to work

12
00:00:59,252 --> 00:01:02,426
with latest technologies, with latest trends and with various clients

13
00:01:02,458 --> 00:01:06,186
with multiple domains and I always fortunate enough to provide them a cutting

14
00:01:06,218 --> 00:01:09,666
edge solutions which fulfill their needs. And this is what we do in

15
00:01:09,688 --> 00:01:13,534
tech nine. We always work on our latest technologies. Let's talk about serverless

16
00:01:13,582 --> 00:01:16,946
computing in case of serverless computing which is also known as function as

17
00:01:16,968 --> 00:01:21,586
a service, the cloud providers such as AWS, Azure, Google or Versaille

18
00:01:21,698 --> 00:01:25,094
will manage the infrastructure and automatically allocate resources for

19
00:01:25,132 --> 00:01:28,342
running and executing the code in the response of any request or

20
00:01:28,396 --> 00:01:31,654
can event. In case of traditional computing, the developer has to manage

21
00:01:31,692 --> 00:01:34,906
the servers. It could be a developers or a DevOps team has to manage the

22
00:01:34,928 --> 00:01:38,746
servers. With serverless computing, the developer only need to write the

23
00:01:38,768 --> 00:01:42,506
code for the specific function they want to run and the cloud provider

24
00:01:42,538 --> 00:01:46,042
will handle the infrastructure, scalability and availability

25
00:01:46,106 --> 00:01:49,886
of those functions. This allows the developer to focus on writing the code and

26
00:01:49,908 --> 00:01:53,146
building the application without worrying about the underlying infrastructure.

27
00:01:53,258 --> 00:01:56,910
There are lot of advantages of serverless architecture or serverless computing.

28
00:01:56,990 --> 00:02:00,178
One of the main primary advantage of serverless computing is a

29
00:02:00,184 --> 00:02:03,442
cost reduction. Since users only pay for the actual amount

30
00:02:03,496 --> 00:02:07,518
of compute time consumed by their functions, they can save money by avoiding

31
00:02:07,534 --> 00:02:10,806
the cost of managing and maintaining servers. Serverless computing can

32
00:02:10,828 --> 00:02:13,958
automatically scale to handle changes in demand. As the

33
00:02:13,964 --> 00:02:17,366
number of requests or event increases, the cloud provider can allocate more

34
00:02:17,388 --> 00:02:21,798
resources to handle those workload, ensuring that the application remains responsive.

35
00:02:21,974 --> 00:02:25,386
Serverless computing allows developer to focus on writing code and

36
00:02:25,408 --> 00:02:29,286
building application rather than managing infrastructure. This simplifies the development

37
00:02:29,318 --> 00:02:33,738
process as well as developer can only avoid the complexity of managing servers,

38
00:02:33,834 --> 00:02:37,434
load balancers or other infrastructure. Component serverless

39
00:02:37,482 --> 00:02:41,086
computing allows developer to focus on writing code and building application rather than

40
00:02:41,108 --> 00:02:44,926
managing infrastructure which include it actually simplified the development

41
00:02:44,958 --> 00:02:48,494
process, the developer has not to worry about managing servers,

42
00:02:48,622 --> 00:02:52,526
load balancers, other infrastructure component with the serverless computing,

43
00:02:52,558 --> 00:02:56,626
developer can quickly and easily develop code changes without worrying about the

44
00:02:56,648 --> 00:03:00,130
underlying infrastructure. This can speed up the development process and improve

45
00:03:00,210 --> 00:03:04,258
time to market for new features and application and serverless computing can improve

46
00:03:04,274 --> 00:03:07,494
the application reliability by automatically handling tasks such as

47
00:03:07,532 --> 00:03:11,446
server maintenance, load balancing and scaling. This can help to reduce the risk

48
00:03:11,478 --> 00:03:15,926
of application downtime and ensure that the applications remain available to the users.

49
00:03:16,038 --> 00:03:19,162
AWS Lambda is nothing but it's a serverless compute service

50
00:03:19,216 --> 00:03:22,746
provided by Amazon Web Services that allows developer to run the

51
00:03:22,768 --> 00:03:26,298
code in the response of event or request. With AWS Lambda,

52
00:03:26,314 --> 00:03:29,994
the developer can write code in variety of programming language which include Java,

53
00:03:30,042 --> 00:03:33,406
Python, node, JS, and then they can upload their code to

54
00:03:33,428 --> 00:03:36,586
run as a function. In AWS environment, these services automatically

55
00:03:36,618 --> 00:03:40,398
handle the compute resource scaling, availability of functions so that the developer

56
00:03:40,414 --> 00:03:44,478
can focus on writing code and building application rather than managing servers.

57
00:03:44,574 --> 00:03:48,198
AWS Lambda support variety of programming languages there are a

58
00:03:48,204 --> 00:03:52,434
couple of languages which has provided as a native which include Java

59
00:03:52,562 --> 00:03:56,194
net. If a programming language is not supporting AWS

60
00:03:56,242 --> 00:04:00,038
lambda, but you can also create a docker image or you

61
00:04:00,044 --> 00:04:03,274
can also create your custom runtime and then you can also run your

62
00:04:03,312 --> 00:04:06,826
code on AWS lambda which is basically happened when you are

63
00:04:06,848 --> 00:04:09,994
choosing a PHP language. You can create your docker image or

64
00:04:10,032 --> 00:04:13,462
you can use a custom runtime. In case of the trust language.

65
00:04:13,606 --> 00:04:17,774
AWS lambda is often used for the event driven application where code

66
00:04:17,812 --> 00:04:21,982
is triggered in the response of events such as changes in Amazon S three

67
00:04:22,116 --> 00:04:25,286
or any new message which is pushed into AWS SQS,

68
00:04:25,338 --> 00:04:28,994
Amazon Q service or in case of any

69
00:04:29,032 --> 00:04:32,274
message which has been pushed to Amazon simple notification. It can

70
00:04:32,312 --> 00:04:36,126
also be used to create API and run bad jobs and perform data processing

71
00:04:36,158 --> 00:04:39,190
tasks. So we are going to see how we are going to write a simple

72
00:04:39,260 --> 00:04:43,286
go application for AWS lambda. But before going to more on how

73
00:04:43,308 --> 00:04:46,502
we are Golang to write this for the AWS lambda, first we'll take a simple

74
00:04:46,556 --> 00:04:50,998
example of go application which is listening to any HTTP request.

75
00:04:51,174 --> 00:04:54,634
For that we can see a simple example where a

76
00:04:54,672 --> 00:04:58,106
main is kind of starting point. This program is

77
00:04:58,128 --> 00:05:01,786
using gin framework. Jin is nothing but one of the popular web framework.

78
00:05:01,898 --> 00:05:05,774
Here it is creating a router and the

79
00:05:05,812 --> 00:05:08,974
router is then listening to an HTTP request, a get

80
00:05:09,012 --> 00:05:12,558
request. When someone is going to put for this specific request it

81
00:05:12,564 --> 00:05:15,906
is going to return a hello world and then at the end this web

82
00:05:15,928 --> 00:05:19,282
framework will start listening to HTTP request on the port

83
00:05:19,336 --> 00:05:24,290
number 80 80. That means when someone is going to hit the localhost HTTP

84
00:05:25,030 --> 00:05:28,306
localhost 8080 request, this will going to print

85
00:05:28,338 --> 00:05:31,654
the hello world. A very basic example in Golang go

86
00:05:31,692 --> 00:05:35,446
application. Now when you want to write a similar application for

87
00:05:35,468 --> 00:05:39,206
the AWS lambda, in that case, now when we want to port the

88
00:05:39,228 --> 00:05:42,714
similar application for this AWS lambda, then we need to do

89
00:05:42,752 --> 00:05:46,090
a couple of more changes. The same thing is

90
00:05:46,160 --> 00:05:49,754
we are going to use for the gin framework for the routing. We need to

91
00:05:49,872 --> 00:05:53,702
import multiple libraries like AWS lambda go events,

92
00:05:53,766 --> 00:05:57,566
AWS go lambdas. And then we are going to also going

93
00:05:57,588 --> 00:06:01,230
to use this lambda go API proxy. So this proxy support

94
00:06:01,300 --> 00:06:05,150
for multiple framework, it support for fiber, it's support for gorilla,

95
00:06:05,310 --> 00:06:09,074
it's one of the library provided by the AWS lab so that it

96
00:06:09,112 --> 00:06:12,574
can use the existing router, the router which has been created,

97
00:06:12,622 --> 00:06:16,222
and it can kind of mostly

98
00:06:16,286 --> 00:06:19,886
port or wrap as per the AWS lambda.

99
00:06:20,078 --> 00:06:23,366
So we're doing the same thing at the global level. We are just

100
00:06:23,388 --> 00:06:27,222
initializing this gin lambda. We are doing the initialization of part

101
00:06:27,276 --> 00:06:30,854
this thing. So one of the, we can say a small drawback of AWS

102
00:06:30,902 --> 00:06:34,214
lambda is because it's going to run a function periodically.

103
00:06:34,342 --> 00:06:38,186
So function initialization time is going to take some time. So that is called

104
00:06:38,208 --> 00:06:41,578
as a call start time. We can kind of reduce the

105
00:06:41,584 --> 00:06:44,974
overall call starter for the successive calls. And that's why

106
00:06:45,172 --> 00:06:48,490
so the calls which required to do one time initialization,

107
00:06:48,570 --> 00:06:52,126
it's recommended to put into the initialization block so that for the next

108
00:06:52,148 --> 00:06:55,562
successive call this block will not kind of reinitialize.

109
00:06:55,706 --> 00:06:58,914
So we are just doing the same thing here in the initialization bar.

110
00:06:58,952 --> 00:07:02,514
We are just initializing the router. We are also kind of saying

111
00:07:02,552 --> 00:07:05,758
that if someone is going to hit for this forward slash endpoint,

112
00:07:05,854 --> 00:07:09,186
just return hello serverless. And then we are initializing

113
00:07:09,218 --> 00:07:12,562
our gin lambda which is a proxy

114
00:07:12,626 --> 00:07:16,662
and we are passing the router. So this handler will be kind of starting

115
00:07:16,716 --> 00:07:20,406
point for the AWS lambda. It accepts few things. One is context,

116
00:07:20,518 --> 00:07:26,138
which has a lot of information. It has information about the

117
00:07:26,224 --> 00:07:30,218
x ray. If you're enabling the x ray, it has information about

118
00:07:30,384 --> 00:07:32,730
from where the call has been initiated,

119
00:07:33,730 --> 00:07:37,550
kind of a lot of information in the context. And then it just provide

120
00:07:37,620 --> 00:07:40,986
another thing which is a proxy API request proxy. Then this proxy

121
00:07:41,018 --> 00:07:44,354
will have information about the exit path that it is

122
00:07:44,392 --> 00:07:47,666
calling. Then we are just kind of

123
00:07:47,768 --> 00:07:50,990
wrapping inside the gin lambda

124
00:07:51,070 --> 00:07:54,754
proxy with context where we're passing both the things and then the

125
00:07:54,792 --> 00:07:58,546
starting point will be lambda start. So it's like a same like it

126
00:07:58,568 --> 00:08:02,006
will wait for the request, then it will call the lambda start, it will

127
00:08:02,028 --> 00:08:05,222
call the lambda. We already have a router which is already

128
00:08:05,276 --> 00:08:08,850
initialized. We are good to go. And when someone is going to hit this URL,

129
00:08:08,930 --> 00:08:12,346
it's going to call hello serverless. So we have seen that

130
00:08:12,448 --> 00:08:16,700
lot of code, for example, for the router AWS, well as

131
00:08:17,230 --> 00:08:20,986
when you are writing a basic goal and application, most of the code is same.

132
00:08:21,088 --> 00:08:24,654
Only a small kind of a wrapper is required when we are running this code

133
00:08:24,692 --> 00:08:28,718
for the AWS lambda. So let me quickly

134
00:08:28,804 --> 00:08:32,046
open my editor and just walk you through on how we can kind

135
00:08:32,068 --> 00:08:35,390
of make sure that we are trying to use the same code.

136
00:08:35,460 --> 00:08:39,266
And I will also walk you through what are the practices which AWS recommend when

137
00:08:39,288 --> 00:08:42,386
we are going for the AWS lambda. Now I'm going to show you that how

138
00:08:42,408 --> 00:08:45,922
we can use the code sharing. That means the code which has been written for

139
00:08:45,976 --> 00:08:49,634
serving the AWS lambda. We can also run the same code locally.

140
00:08:49,762 --> 00:08:53,222
One of the main challenge of running any of the service technology code

141
00:08:53,276 --> 00:08:57,474
local is how can test everything locally.

142
00:08:57,602 --> 00:09:00,746
So there are a lot of tools available. One of

143
00:09:00,768 --> 00:09:03,926
the great tool especially for AWS is called as local stack.

144
00:09:04,038 --> 00:09:07,878
By using that local stack you can also run AWS lambda locally.

145
00:09:07,974 --> 00:09:12,082
Internally it just deploy into this local stack environment

146
00:09:12,166 --> 00:09:15,674
which is kind of equivalent to AWS lambda environment.

147
00:09:15,802 --> 00:09:19,278
And by that mechanism we can test it out. But again,

148
00:09:19,364 --> 00:09:22,826
kind of deploying that code, it's kind of a time consuming

149
00:09:22,858 --> 00:09:26,434
process. So this is a simplified process which I am

150
00:09:26,552 --> 00:09:29,826
figured out and I hope that you are also going to get some

151
00:09:29,848 --> 00:09:32,974
benefit of that thing. So the solution

152
00:09:33,022 --> 00:09:36,230
is pretty simple. We need to identify what is the common

153
00:09:36,300 --> 00:09:40,086
code. This is also one of the combination from AWS lambda is

154
00:09:40,188 --> 00:09:43,586
to keep your initialization code separate

155
00:09:43,618 --> 00:09:47,126
from your business logic code. So in our case, consider that

156
00:09:47,148 --> 00:09:50,922
our business logic is to serve our HTTP request. In that

157
00:09:50,976 --> 00:09:54,634
case, we are just kind of moving that code,

158
00:09:54,752 --> 00:09:57,622
especially for the routing code, into a separate file.

159
00:09:57,686 --> 00:10:01,274
Let's call as router go and then on

160
00:10:01,312 --> 00:10:05,162
our local go which is going to run on the local system, we're just mentioning

161
00:10:05,226 --> 00:10:08,906
here that just call the router and just initialize

162
00:10:08,938 --> 00:10:12,446
the router. It was the same code which I shown a few seconds back in

163
00:10:12,468 --> 00:10:16,174
the presentation that we can run a basic lambda

164
00:10:16,222 --> 00:10:19,538
code, just initialize the gen router and run the code.

165
00:10:19,704 --> 00:10:22,866
So this is good. We can

166
00:10:22,888 --> 00:10:26,502
quickly test it out whether this is working or not. I'm going to

167
00:10:26,636 --> 00:10:30,694
run the same code. Go run local code which is pointing this

168
00:10:30,732 --> 00:10:34,342
local folder and it has

169
00:10:34,396 --> 00:10:37,430
started listening on the port number 80 80.

170
00:10:38,810 --> 00:10:42,082
I was just using one of the feature of I'm using this Golang

171
00:10:42,146 --> 00:10:45,338
tool for all this kind of a development purpose, and this is

172
00:10:45,344 --> 00:10:48,618
one of the good tool, especially for the Go language. You can also use the

173
00:10:48,624 --> 00:10:52,510
same tool for the Vs code, the same principle which I'm showing here.

174
00:10:52,580 --> 00:10:56,334
It will be work and I also request the organizer to

175
00:10:56,372 --> 00:10:59,774
share the GitHub link along

176
00:10:59,812 --> 00:11:04,320
with the presentation. So now the port is running on 8080.

177
00:11:04,770 --> 00:11:08,094
You can see I can directly call a request which is our get HTTP

178
00:11:08,142 --> 00:11:11,666
request, and we can get the data which

179
00:11:11,688 --> 00:11:15,262
is hello world which is coming from this router.

180
00:11:15,406 --> 00:11:18,502
Router has been initialized and here we can get the hello

181
00:11:18,556 --> 00:11:22,374
world thing. Similarly, if I want to write

182
00:11:22,412 --> 00:11:25,638
the code for lambda and I need to kind of

183
00:11:25,644 --> 00:11:28,966
follow the same principle, that the initialization code will be separate and

184
00:11:28,988 --> 00:11:33,146
the business logic code will be different, then this

185
00:11:33,168 --> 00:11:36,602
is how it's going to be happened over here. Again, the main

186
00:11:36,656 --> 00:11:40,218
is kind of a starting point for us. Then we are initializing everything.

187
00:11:40,384 --> 00:11:46,266
We are taking the router information in

188
00:11:46,288 --> 00:11:49,162
our goal and initialized. We are just initializing the router.

189
00:11:49,306 --> 00:11:52,662
Then we are also using AWS lambda proxy.

190
00:11:52,746 --> 00:11:55,982
Inside the proxy we actually created a global variable.

191
00:11:56,126 --> 00:11:59,986
Here we are just passing, just creating the kind

192
00:12:00,008 --> 00:12:03,826
of a global object new adapter and passing the

193
00:12:03,848 --> 00:12:07,174
router. And then this is the starting point of

194
00:12:07,212 --> 00:12:10,834
AWS lambda, especially for the HTTP request. We got the context,

195
00:12:10,882 --> 00:12:13,430
we get the request and this will be the response.

196
00:12:13,930 --> 00:12:17,410
And since we are using this AWS labs

197
00:12:17,570 --> 00:12:21,482
gin proxy, it just kind of wrap everything and the same

198
00:12:21,536 --> 00:12:25,274
code will work for both the things. Now this

199
00:12:25,312 --> 00:12:29,194
is how we are able to kind of share the code between our local thing

200
00:12:29,232 --> 00:12:33,600
and lambda, and we can kind of run this entire code too.

201
00:12:34,210 --> 00:12:38,026
There are various options for the deployment, but for this presentation I'm

202
00:12:38,058 --> 00:12:42,026
going to use serverless application model AWS SAM for the deployment.

203
00:12:42,138 --> 00:12:45,322
So the other options could be we can deploy using a terraform,

204
00:12:45,386 --> 00:12:48,738
we can deploy using cloudformation, we can deploy using plume, or we

205
00:12:48,744 --> 00:12:52,242
can deploy using AWS Cdk. But if you are going

206
00:12:52,296 --> 00:12:55,602
to do for some sort of PoC, then this SAM will be kind of

207
00:12:55,656 --> 00:12:59,070
much easier. For the deployment. We need to install a SAm ClI which is

208
00:12:59,080 --> 00:13:02,386
equivalent to our AWS ClI. After installing same CLI

209
00:13:02,418 --> 00:13:06,214
we need to run a command which is same initialize. So this is going

210
00:13:06,252 --> 00:13:09,878
to ask you a couple of things. It has a couple of boilerplate

211
00:13:09,894 --> 00:13:13,446
project for the Golang, for rust

212
00:13:13,478 --> 00:13:16,970
language, for node js, multiple languages and we can also

213
00:13:17,040 --> 00:13:20,854
choose a custom project also. So I already installed

214
00:13:20,902 --> 00:13:24,000
this SAM initialize and it has created kind of some project.

215
00:13:25,810 --> 00:13:28,826
So after running a SAM initialization part, it has created

216
00:13:28,858 --> 00:13:32,334
some sample project for me. I actually taken the respect information which is

217
00:13:32,372 --> 00:13:35,994
required to run this application does include a Mac

218
00:13:36,042 --> 00:13:39,870
file where we are going to run a SAm build command template

219
00:13:39,950 --> 00:13:43,330
yaml file which is responsible for kind of.

220
00:13:43,480 --> 00:13:47,386
It is mostly equivalent to a cloudformation template, but it's mostly configured

221
00:13:47,438 --> 00:13:51,170
based on Samway so that we can deploy our lambda.

222
00:13:51,330 --> 00:13:54,360
And a couple of modification has been made so far.

223
00:13:55,130 --> 00:13:59,042
And this is kind of one of the important thing for us is because

224
00:13:59,196 --> 00:14:02,538
this will tell us what kind of thing we need to do.

225
00:14:02,704 --> 00:14:06,086
So it start with a folder location.

226
00:14:06,198 --> 00:14:10,394
So when I'm going to run my build command, which is my back

227
00:14:10,432 --> 00:14:14,046
build command, it's going to generate the artifact. But this

228
00:14:14,068 --> 00:14:17,598
build command will utilize this same template. It's going to

229
00:14:17,604 --> 00:14:21,242
see where the code path is. In our case the lambda server

230
00:14:21,306 --> 00:14:24,574
go, that was where the code was. There it

231
00:14:24,612 --> 00:14:29,346
will create the name of the handler. So this handler will be kind

232
00:14:29,368 --> 00:14:32,626
of a logical name for the handler then which runtime we need

233
00:14:32,648 --> 00:14:37,750
to use. So the lambda support multiple runtime node js Python.

234
00:14:38,090 --> 00:14:41,334
So similarly right now it's supporting go one x

235
00:14:41,372 --> 00:14:45,446
version, then you can select an architecture. So AWS Lambda support two

236
00:14:45,468 --> 00:14:48,662
kind of architecture. One is we get called AWS

237
00:14:48,716 --> 00:14:52,042
86 64 and another one is arm. For this I'm just

238
00:14:52,096 --> 00:14:55,754
selecting can arm. Then it will ask for when

239
00:14:55,792 --> 00:14:59,242
we are going to invoke this lambda, when this lambda is going to be called.

240
00:14:59,376 --> 00:15:03,450
So here we are saying that this event will have a logical name,

241
00:15:03,520 --> 00:15:07,086
catch all. It's just kind of a logical name. And then the type of

242
00:15:07,108 --> 00:15:10,734
event will be an API, which is kind of can API request from your

243
00:15:10,772 --> 00:15:14,174
API gateway, and it's going to create

244
00:15:14,212 --> 00:15:17,906
an API gateway for us. And when someone is going to say a

245
00:15:17,928 --> 00:15:22,354
specific endpoint get request, then this is going to invoke at

246
00:15:22,392 --> 00:15:26,226
the output of this one. When I'm going to run Sam build command and

247
00:15:26,248 --> 00:15:30,482
send deploy command is going to generate the entire structure

248
00:15:30,546 --> 00:15:33,702
stack for me. And once the structure is ready,

249
00:15:33,756 --> 00:15:36,822
then we are going to see a couple of URLs at the end.

250
00:15:36,956 --> 00:15:40,742
So what I'm saying to this Sam framework

251
00:15:40,806 --> 00:15:44,682
is, or I would say internally, it's actually calling a cloud

252
00:15:44,736 --> 00:15:48,666
formation template. So what I'm saying to them is just create an

253
00:15:48,688 --> 00:15:52,566
API gateway for me and just also share the API gateway

254
00:15:52,598 --> 00:15:56,350
URL at the end of it. After deploying the same template.

255
00:15:57,330 --> 00:16:01,262
It's going to generate a URL. The format of URL will be something like this.

256
00:16:01,396 --> 00:16:04,978
This will be kind of a name of API gateway execute API is going

257
00:16:04,984 --> 00:16:08,814
to make can execute call to this API. We have this prod

258
00:16:08,862 --> 00:16:13,426
which will be the default stage environment. And when

259
00:16:13,448 --> 00:16:16,930
I'm going to hit this URL again, it's a gate request call.

260
00:16:17,080 --> 00:16:20,226
So it's going to make a call to that lambda and it's going to print

261
00:16:20,258 --> 00:16:23,734
hello world. So this hello world is same like which we have seen on a

262
00:16:23,772 --> 00:16:27,094
local system when the code was running on

263
00:16:27,132 --> 00:16:30,726
locally. This is the same thing over here, and this information is

264
00:16:30,748 --> 00:16:34,170
coming from the router. So we have seen that

265
00:16:34,320 --> 00:16:37,450
we can do kind of code sharing part of that thing. We can kind of

266
00:16:37,520 --> 00:16:40,554
write the same code which can be used by the lambda and local.

267
00:16:40,752 --> 00:16:44,090
Now this is mostly all about the AWS lambda.

268
00:16:44,170 --> 00:16:47,146
Now let's come back to the next section, which is our graphQl.

269
00:16:47,178 --> 00:16:50,526
So GQL gen. So I'm going to most talk about

270
00:16:50,548 --> 00:16:54,266
the GraphQL part. So GraphQL is a query language

271
00:16:54,298 --> 00:16:58,234
for Apan that was developed in 2012 by Facebook and they made

272
00:16:58,292 --> 00:17:01,906
open source as 2015. It was mostly designed to

273
00:17:01,928 --> 00:17:05,746
improve the efficiency and flexibility of API by requesting to

274
00:17:05,768 --> 00:17:09,554
fetch the data which is only required, and to retrieve

275
00:17:09,602 --> 00:17:13,366
multiple set of data in a single request. And GraphQL is

276
00:17:13,388 --> 00:17:16,534
a strong type schema that offers structure of data and that can

277
00:17:16,572 --> 00:17:19,926
query and query language that allows clients to specify the data they want

278
00:17:19,948 --> 00:17:23,626
to retrieve. It can be used in any programming language and

279
00:17:23,648 --> 00:17:27,126
backend technology. So when you are talking about the graphql,

280
00:17:27,158 --> 00:17:30,454
we only need to think about the schema. So this schema will define

281
00:17:30,502 --> 00:17:34,154
everything. It defines what kind of model we want,

282
00:17:34,272 --> 00:17:37,534
how we want to tech that model, and how we want to update that model.

283
00:17:37,652 --> 00:17:41,550
So schema is kind of a core for graphQl. And after

284
00:17:41,620 --> 00:17:45,526
that there are two important concepts, which is called as Qian

285
00:17:45,578 --> 00:17:49,122
mutation. In case of traditional rest application, we have

286
00:17:49,176 --> 00:17:53,330
multiple things to get to update the data. So for example,

287
00:17:53,480 --> 00:17:56,526
we have put request, post request, delete request.

288
00:17:56,638 --> 00:18:00,120
So these are all the operations which is used to kind of update the data.

289
00:18:01,290 --> 00:18:05,030
In case of GraphQL, that is called as mutation. So whenever you want to perform

290
00:18:05,100 --> 00:18:08,662
any sort of update, which also include the deletion of that object,

291
00:18:08,796 --> 00:18:11,866
it's called as mutation. And when we want to tech the

292
00:18:11,888 --> 00:18:15,770
data that is called as query. So q is nothing but just get the data

293
00:18:15,840 --> 00:18:19,020
and mutations, just kind of modify the data.

294
00:18:19,630 --> 00:18:22,906
Let me show you a quick example of GraphQL. Schema. So we

295
00:18:22,928 --> 00:18:25,998
have query for tech the data, we have mutation for update the

296
00:18:26,004 --> 00:18:29,786
data and we have different, different models. So now let's

297
00:18:29,818 --> 00:18:33,326
consider a simple example that we want to create a to do app. The to

298
00:18:33,348 --> 00:18:38,242
do app required an id title description and completed to

299
00:18:38,296 --> 00:18:41,682
get the data from the API. We are going to have

300
00:18:41,736 --> 00:18:45,026
another input. When we are saying that 4k if you want to

301
00:18:45,048 --> 00:18:48,538
create to do, then we need to pass a title

302
00:18:48,574 --> 00:18:52,626
and description. Here the description is optional. If you see an exclamatory

303
00:18:52,658 --> 00:18:56,274
mark that is, this is required property. Similarly, when you want to update

304
00:18:56,322 --> 00:18:59,906
any of the to do, we need to pass the title description and the status

305
00:18:59,938 --> 00:19:03,258
whether it's completed or not. Okay, in case when you want

306
00:19:03,264 --> 00:19:06,758
to query here we say that, okay, we are going to get the to DOS

307
00:19:06,854 --> 00:19:10,266
and to DOS will going to get the list. So if

308
00:19:10,288 --> 00:19:13,886
you can see this is array option, we have square bracket inside. We are

309
00:19:13,908 --> 00:19:17,630
passing a model, the model is required and this return

310
00:19:17,780 --> 00:19:21,150
is also required. Even if it's going to return the empty object,

311
00:19:21,220 --> 00:19:24,690
that is perfectly fine. Similarly, mutation, what are the options

312
00:19:24,760 --> 00:19:27,634
we can perform? We can perform create to do,

313
00:19:27,672 --> 00:19:31,106
update to do and delete to do. Now this

314
00:19:31,128 --> 00:19:35,634
is all about the Graphql schema. Now what happened is now

315
00:19:35,672 --> 00:19:38,358
someone is going to say, okay, if I want to get the data, if I

316
00:19:38,364 --> 00:19:42,006
want to update the data. In our typical restful application we

317
00:19:42,028 --> 00:19:46,134
used to create a controller. We used to create a routing and everything. In case

318
00:19:46,172 --> 00:19:50,074
of graphql, instead of creating a controller router, we need to kind

319
00:19:50,112 --> 00:19:53,100
of mention the resolver for example.

320
00:19:54,350 --> 00:19:58,634
Now this is kind of a simple example, let's say if I want to get

321
00:19:58,672 --> 00:20:02,038
the to do which has id title completed.

322
00:20:02,134 --> 00:20:05,694
So this information will be linked to a particular set of

323
00:20:05,732 --> 00:20:09,006
function which is Golang to execute. Now it may

324
00:20:09,028 --> 00:20:12,494
be possible that the id title and completed these are going to

325
00:20:12,532 --> 00:20:15,826
come from different, different functions. So we can

326
00:20:15,848 --> 00:20:19,518
have a nested resolver. Also in our graphql GQl

327
00:20:19,534 --> 00:20:22,866
generation we will see that how these things are getting linked. So please bear with

328
00:20:22,888 --> 00:20:26,558
me for another five minutes. Now, what is GQL

329
00:20:26,574 --> 00:20:29,826
gen? So Gql Gen is a go library for building a graphql API.

330
00:20:29,858 --> 00:20:33,778
It generates typescript server code based on the GraphQL schema and resolver functions

331
00:20:33,874 --> 00:20:37,154
that you define. So we talk about the schema.

332
00:20:37,202 --> 00:20:40,586
The resolver is nothing but the function which is getting execute and is going to

333
00:20:40,608 --> 00:20:44,220
either update the data or is going to get the data.

334
00:20:44,670 --> 00:20:48,566
So with GQL you can define your graphQl schema

335
00:20:48,598 --> 00:20:51,934
in a graphQl schema language and graphQl generates go code for your

336
00:20:51,972 --> 00:20:55,338
server that handles the queries and mutations. This eliminates

337
00:20:55,354 --> 00:20:59,230
the need for manually parsing incoming requests and serializing outgoing responses.

338
00:21:00,610 --> 00:21:04,346
The GQL is built with a performance in mind and uses generation

339
00:21:04,378 --> 00:21:08,242
to code efficient and types of code. To getting

340
00:21:08,296 --> 00:21:11,806
started with the GQL gen, we need to run a simple command. This command

341
00:21:11,838 --> 00:21:15,826
is nothing good. To initialize the GQL gen, we need to run

342
00:21:15,848 --> 00:21:19,886
the command go, run GitHub.com 99 designs and GQL gen initialize.

343
00:21:19,998 --> 00:21:23,142
It's going to initialize the setup. It's going to create a dummy project

344
00:21:23,196 --> 00:21:27,190
for you. And once the setup is done, we also need to resolve the dependency.

345
00:21:28,490 --> 00:21:31,962
I already did this thing, so let me quickly walk you through on the code

346
00:21:32,016 --> 00:21:35,574
part, what it has been generated, and then we'll go in more details

347
00:21:35,622 --> 00:21:38,810
about how we are going to integrate with AWS lambda.

348
00:21:40,430 --> 00:21:43,786
After running GQL initialize command is going to create a folder structure

349
00:21:43,818 --> 00:21:47,726
which is equivalent to this one. The starting part for the

350
00:21:47,748 --> 00:21:51,246
GQL is to understand the GQL gen yaml file. And this

351
00:21:51,268 --> 00:21:55,106
YaMl file has lot of information. So let's go by a bit

352
00:21:55,128 --> 00:21:58,622
of information from here. So it checks

353
00:21:58,766 --> 00:22:02,754
with a schema where the schema is available. So here

354
00:22:02,792 --> 00:22:06,098
it's mentioned that the schema is available on a graphql folder. So it go to

355
00:22:06,104 --> 00:22:08,770
the Graphql folder, it will check for this file extension,

356
00:22:08,850 --> 00:22:12,306
Graphql S. And here it's going to find out the schema.

357
00:22:12,418 --> 00:22:16,200
And based on this schema, it's going to create the resolver and the model,

358
00:22:16,970 --> 00:22:20,802
and then it's going to check what will be the file path.

359
00:22:20,866 --> 00:22:23,798
If you want to change the file path, we can change the file path.

360
00:22:23,974 --> 00:22:27,226
Here it has uses this graphql generator go.

361
00:22:27,328 --> 00:22:30,458
So this is the generator Go is a kind of auto

362
00:22:30,474 --> 00:22:32,750
generated file after the initialization.

363
00:22:33,970 --> 00:22:37,374
Similarly, it's going to create a models for

364
00:22:37,412 --> 00:22:40,240
us. The model will be,

365
00:22:41,490 --> 00:22:44,514
if you can go back to our schema, we'll see that we have this to

366
00:22:44,552 --> 00:22:47,794
do. This is one model and new

367
00:22:47,832 --> 00:22:51,266
to do. This is another model. So it's going to

368
00:22:51,288 --> 00:22:54,562
create models new to do and to do based

369
00:22:54,616 --> 00:22:57,986
on the file which you are going to provide. So here it's

370
00:22:58,008 --> 00:23:01,734
mentioned that the models underscore gen Go is the place where

371
00:23:01,772 --> 00:23:05,254
it's going to create a model. Now if you already

372
00:23:05,292 --> 00:23:10,214
have can existing model and you don't want to create those models by

373
00:23:10,252 --> 00:23:13,562
this code, gen by Jigger gen. So what you can do is

374
00:23:13,616 --> 00:23:17,466
you can have one more option which is called as autobind. And here

375
00:23:17,488 --> 00:23:20,986
you can mention the path of your model. For example, in one

376
00:23:21,008 --> 00:23:23,918
of the example I'm going to show you that I already have a path where

377
00:23:24,004 --> 00:23:27,386
I mentioned my model and then I'm just telling

378
00:23:27,418 --> 00:23:30,942
the GQ gen that use the existing model, don't create the new

379
00:23:30,996 --> 00:23:34,270
model in models underscore gen file.

380
00:23:37,190 --> 00:23:40,610
So this queries and mutations, it has different,

381
00:23:40,680 --> 00:23:44,322
different kind of functionality. For example, we require one

382
00:23:44,376 --> 00:23:47,746
resolver. Resolver is nothing but the function when someone is

383
00:23:47,768 --> 00:23:51,542
going to request for this query and then we require another create

384
00:23:51,596 --> 00:23:54,726
to do. I just want to kind of create as simple as possible. So I

385
00:23:54,748 --> 00:23:58,278
just put the create to do where I'm going to put the to do information

386
00:23:58,364 --> 00:24:02,426
and it's golang to create this thing. So the

387
00:24:02,448 --> 00:24:05,818
base class for the resolver is resolver go. It has nothing,

388
00:24:05,904 --> 00:24:09,258
it has just a simple thing. This can be

389
00:24:09,264 --> 00:24:12,394
used as a dependency injections. I'm going to cover that part as

390
00:24:12,432 --> 00:24:15,920
well and then it's going to create a schema now.

391
00:24:16,690 --> 00:24:19,870
So if you want to have a separate schema based on the file name,

392
00:24:19,940 --> 00:24:24,254
that is also possible. That is something that we can configure here,

393
00:24:24,292 --> 00:24:27,874
that what kind of schema we want. And it's mentioned that, okay, just follow

394
00:24:27,912 --> 00:24:30,610
the schema based on the schema, just create the resolver.

395
00:24:31,510 --> 00:24:35,634
So we have this schema resolver and it

396
00:24:35,672 --> 00:24:38,514
has multiple function which is actually not implemented.

397
00:24:38,642 --> 00:24:42,694
For example, we are looking for to DOS to

398
00:24:42,732 --> 00:24:46,646
get the kind of curie information and it's mentioned here that

399
00:24:46,668 --> 00:24:50,262
this to do does not implement it. This is where we need to put our

400
00:24:50,316 --> 00:24:54,042
code. Similarly, it has created a resolver for create

401
00:24:54,096 --> 00:24:57,338
to do, which is mentioned here. So we require one more resolve for the

402
00:24:57,344 --> 00:25:00,746
create to do and it has created a resolver that is also

403
00:25:00,768 --> 00:25:04,294
not implemented. So we need to put the logic over here to create

404
00:25:04,352 --> 00:25:07,806
it. Now thing is, I just want to show you the entire end

405
00:25:07,828 --> 00:25:11,374
to end flow where I can perform a basic code operation for that thing.

406
00:25:11,492 --> 00:25:14,914
And I'm very fond of AWS. So what I've done so

407
00:25:14,952 --> 00:25:18,274
far is I created one AWS sample where

408
00:25:18,312 --> 00:25:22,546
it's going to kind of get the data from

409
00:25:22,568 --> 00:25:25,390
the dynamodb and update the data from the dynamodb.

410
00:25:25,550 --> 00:25:29,458
But before Golang to more on how this is going to be implemented,

411
00:25:29,554 --> 00:25:32,966
I just created a very simple sample where we can see

412
00:25:32,988 --> 00:25:36,790
that how we can perform basic code operation on DynamoDB.

413
00:25:40,010 --> 00:25:43,786
The main thing is with the dynamodb is code is a bit complex to

414
00:25:43,808 --> 00:25:47,430
understand, but there are a lot of libraries which are kind of a wrap,

415
00:25:47,590 --> 00:25:50,918
which is kind of a wrapper on the dynamodb

416
00:25:51,014 --> 00:25:54,846
to make our life easy. And one of them is dynamo. Now what this

417
00:25:54,868 --> 00:25:58,010
dynamo does is we need to mention the schema.

418
00:25:58,090 --> 00:26:02,014
So it's like we have can object where we need to just

419
00:26:02,052 --> 00:26:04,878
do a card operation, basic create, update,

420
00:26:04,974 --> 00:26:08,082
delete operation. And we need to say, okay,

421
00:26:08,216 --> 00:26:11,954
now this id is linked to particular this id into

422
00:26:11,992 --> 00:26:15,186
the table dynamodb table. Similarly, user id will link

423
00:26:15,208 --> 00:26:18,434
to user id table. And likewise we have other properties

424
00:26:18,482 --> 00:26:22,066
which can link to specific attribute to the dynamodb

425
00:26:22,098 --> 00:26:25,766
table. So consider this, because Dynamodb is like a key

426
00:26:25,788 --> 00:26:29,494
value pair database. So we can't use a term column, but right

427
00:26:29,532 --> 00:26:32,234
now we can use a term kind of column where we have this id,

428
00:26:32,272 --> 00:26:35,706
user id text and done. These are kind

429
00:26:35,728 --> 00:26:39,734
of attributes or we can say properties of a particular document

430
00:26:39,782 --> 00:26:42,998
in Dynamodb. And then

431
00:26:43,184 --> 00:26:46,622
we're just initializing a new AWS session. So this new

432
00:26:46,676 --> 00:26:50,906
session is in case when we want to kind of do anything related

433
00:26:50,938 --> 00:26:54,606
to the AWS, we need to initialize this AWS session here. We can

434
00:26:54,628 --> 00:26:58,274
also provide which region we want. We can also

435
00:26:58,312 --> 00:27:01,586
provide the credentials AWS. Well, I'm going to pass the

436
00:27:01,608 --> 00:27:05,026
credentials and region using an environment variable which I'm going to show you

437
00:27:05,048 --> 00:27:08,520
in a few minutes. And then I'm just initializing my

438
00:27:08,970 --> 00:27:12,630
dynamo which is kind of a wrapper on the dynamodb

439
00:27:13,290 --> 00:27:17,346
library provided by AWS. And then I'm just selecting a database

440
00:27:17,378 --> 00:27:21,210
table. For me, I just already created a table to save

441
00:27:21,280 --> 00:27:24,506
all of our time. And then I'm just doing

442
00:27:24,688 --> 00:27:28,330
creating an object for the table. It's like a struct for the table,

443
00:27:29,070 --> 00:27:32,320
running a put command, it's going to add this information.

444
00:27:32,770 --> 00:27:35,998
And then here I change a

445
00:27:36,004 --> 00:27:39,694
schema a bit, I'm passing a user id with this thing and

446
00:27:39,732 --> 00:27:43,358
at the end I'm just making a call to again the

447
00:27:43,364 --> 00:27:46,866
dynamodb table here. I'm saying, okay, give me the information based on

448
00:27:46,888 --> 00:27:50,626
the user id and it's just returning me this result and

449
00:27:50,648 --> 00:27:53,698
this result will be visible. A very simple example.

450
00:27:53,864 --> 00:27:58,114
So the main purpose

451
00:27:58,162 --> 00:28:01,800
of showing this example is that for our actual

452
00:28:02,330 --> 00:28:05,542
application we are going to use dynamodb where we are going to see the things

453
00:28:05,596 --> 00:28:10,346
end to end. Okay, now the

454
00:28:10,368 --> 00:28:13,594
GQL code which has been generated so far, I modified that

455
00:28:13,632 --> 00:28:17,222
code. So this is kind of updated

456
00:28:17,286 --> 00:28:20,602
code so far. It's a bit clean code

457
00:28:20,656 --> 00:28:24,158
compared to what has been generated. So let me quickly walk you through on

458
00:28:24,164 --> 00:28:27,774
that code. First here I just mentioned AWS where

459
00:28:27,812 --> 00:28:31,678
client I'm just provides a session information. Okay, this is the session information

460
00:28:31,764 --> 00:28:35,806
for us. We have this graphql which is same auto

461
00:28:35,838 --> 00:28:39,746
generated. Now we have a model to

462
00:28:39,768 --> 00:28:43,154
do model which I shown you before. We have this id,

463
00:28:43,192 --> 00:28:46,494
user id text dynamite. These are the address on that part.

464
00:28:46,632 --> 00:28:50,070
Now I'm just mentioning this GQL generate that,

465
00:28:50,140 --> 00:28:53,506
do not create a new model for moss,

466
00:28:53,618 --> 00:28:57,126
don't create a new model for me. So it's not created over here.

467
00:28:57,228 --> 00:29:00,826
And this is possible by providing a path where it

468
00:29:00,848 --> 00:29:04,134
can use an autobanding. So my to do models,

469
00:29:04,182 --> 00:29:07,430
this model folder is a part of this autobanding.

470
00:29:07,510 --> 00:29:10,922
So GQlgen will say okay, this model already exists, so I don't need to create

471
00:29:10,976 --> 00:29:14,400
another one. And then that's why it's just ignored that model.

472
00:29:15,490 --> 00:29:18,974
Then I created a service because the code which was

473
00:29:19,012 --> 00:29:22,286
in dynamo, it's just for the PoC, not for the

474
00:29:22,308 --> 00:29:26,146
actual code. So I just created a to do service. And this to

475
00:29:26,168 --> 00:29:28,980
do service is actually doing two things here.

476
00:29:30,710 --> 00:29:33,860
It's just doing adding a to do.

477
00:29:34,390 --> 00:29:38,182
In that case it's just generating a unique id,

478
00:29:38,316 --> 00:29:41,794
it's making a dynamodb table call, it's making a put request,

479
00:29:41,922 --> 00:29:45,830
getting the data and then we are good to go. The new

480
00:29:45,980 --> 00:29:49,162
table will be added when someone is going to call to this service.

481
00:29:49,296 --> 00:29:53,430
And similarly we need to fetch all the users informations.

482
00:29:53,590 --> 00:29:56,918
We need to fetch all the 2d information by the user.

483
00:29:57,014 --> 00:30:00,634
So here I'm passing a user id, there it is

484
00:30:00,672 --> 00:30:04,526
again, scanning the call, it's passing the user id and then we

485
00:30:04,548 --> 00:30:08,094
are getting the results which is kind of modeled for us. So this is

486
00:30:08,132 --> 00:30:14,254
a simple service that we have now coming

487
00:30:14,292 --> 00:30:17,986
back to the server go code. So this code has been kind of modified a

488
00:30:18,008 --> 00:30:21,646
bit so that we should use the gin framework. So far the auto

489
00:30:21,678 --> 00:30:25,426
generated code from GqlGen does not have this concept called

490
00:30:25,448 --> 00:30:28,674
as gin. They have a documentation that how we can integrate with the gin.

491
00:30:28,802 --> 00:30:32,598
And I follow the same documentation and this is the code we have.

492
00:30:32,764 --> 00:30:36,742
Okay, so again the code start from very simple thing,

493
00:30:36,796 --> 00:30:40,198
main here we are mentioning the port number. If the port number is not mentioned,

494
00:30:40,284 --> 00:30:43,974
we are going with the default port number. We are initializing the gin router.

495
00:30:44,102 --> 00:30:47,786
We are actually initializing two more endpoints. One is query where

496
00:30:47,808 --> 00:30:51,674
we are going to perform the graphql operation and the playground. So this

497
00:30:51,792 --> 00:30:55,502
juque and gen support a playground. We can use the same playground again

498
00:30:55,636 --> 00:30:59,162
or we can use something else. I'm going to show you one more chrome

499
00:30:59,226 --> 00:31:02,670
extension that you can use and you can play around with the playground.

500
00:31:03,110 --> 00:31:08,962
So this graphql handler here,

501
00:31:09,016 --> 00:31:11,982
I'm just initializing the new dynamo client,

502
00:31:12,126 --> 00:31:15,554
initializing the new to do service and I'm passing this

503
00:31:15,592 --> 00:31:19,266
information to default handler server.

504
00:31:19,378 --> 00:31:22,854
So this handler server is actually provides by our

505
00:31:22,892 --> 00:31:26,498
GQLGen, it's provided

506
00:31:26,514 --> 00:31:30,714
by GQGen and I'm just initializing this handler server and then

507
00:31:30,832 --> 00:31:34,378
when the server is initialized I'm passing this information to

508
00:31:34,384 --> 00:31:38,314
the gin context for

509
00:31:38,352 --> 00:31:42,540
the resolver, the resolver which has been generated here

510
00:31:44,990 --> 00:31:49,006
I'm passing the to do service as a dependency over here so that the

511
00:31:49,028 --> 00:31:51,760
resolver have all the information about the to do service.

512
00:31:52,130 --> 00:31:55,940
So this is the basic configuration that we have done so far

513
00:31:57,910 --> 00:32:01,778
and now the GQL gen

514
00:32:01,864 --> 00:32:07,000
has know about

515
00:32:07,610 --> 00:32:12,086
to do service and it

516
00:32:12,108 --> 00:32:13,960
has the instance of for the to do service.

517
00:32:15,850 --> 00:32:20,470
Now if I'm going back to my schema again now

518
00:32:20,620 --> 00:32:23,274
I need to fetch the data for the to Dos and I need to create

519
00:32:23,312 --> 00:32:27,034
a new to do for that. The GraphQL GQ engine has already

520
00:32:27,072 --> 00:32:30,346
created a resolver for us and here we

521
00:32:30,368 --> 00:32:34,414
are fulfilling that information. So for the create to do which

522
00:32:34,452 --> 00:32:38,126
is for the mutation operation we are just adding into to

523
00:32:38,148 --> 00:32:41,902
do which include the text user id and done current

524
00:32:41,956 --> 00:32:45,454
status which is false. And for fetching all

525
00:32:45,492 --> 00:32:48,882
the to DOS we are just passing the user id and it will return

526
00:32:48,936 --> 00:32:51,730
us information over all the user ids.

527
00:32:52,230 --> 00:32:55,966
Sorry it will return the information about all the to DOS based on the user

528
00:32:55,998 --> 00:32:59,206
id. To quickly see this in

529
00:32:59,228 --> 00:33:03,270
action I'm going to run here.

530
00:33:03,340 --> 00:33:06,962
So let me stop my existing server,

531
00:33:07,026 --> 00:33:10,454
let me go to specific this folder and

532
00:33:10,492 --> 00:33:14,186
here like I said that I'm going to run this information

533
00:33:14,288 --> 00:33:17,738
on AWS cloud and I'm going to use my

534
00:33:17,824 --> 00:33:21,354
existing profile. So you can pass your AWS credential here or

535
00:33:21,392 --> 00:33:25,098
you can also configure AWS provides for the same I'm

536
00:33:25,114 --> 00:33:28,814
just configuring the AWS profile and thanks to take nine

537
00:33:28,852 --> 00:33:32,910
so they are allowing me to use their AWS cloud for this purpose

538
00:33:34,150 --> 00:33:37,698
and I'm mentioning the region information. So these two information is

539
00:33:37,704 --> 00:33:43,954
required for dynamodb and then

540
00:33:43,992 --> 00:33:48,150
I can run the same command go run server.

541
00:33:52,490 --> 00:33:56,214
Now what can I do here is I can quickly show you

542
00:33:56,252 --> 00:34:00,822
that the entire thing in a now

543
00:34:00,876 --> 00:34:03,926
it has started the server. Now we can see that it has two endpoints.

544
00:34:03,958 --> 00:34:08,118
One is a gate request endpoints which is pointing to a playground

545
00:34:08,214 --> 00:34:11,706
and we have post call which is actually calling to this which

546
00:34:11,728 --> 00:34:14,320
is actually handling this resolver schema and everything.

547
00:34:16,690 --> 00:34:20,906
So when we open this port number 8080 where the gqlgen

548
00:34:20,938 --> 00:34:24,286
server is running. It is going to show us the playground. So this

549
00:34:24,308 --> 00:34:27,986
is kind of playground. So we can see there are

550
00:34:28,008 --> 00:34:31,538
multiple program provided. This is default playground provided by the

551
00:34:31,544 --> 00:34:34,898
gqueengen. And we can also see the information

552
00:34:34,984 --> 00:34:38,222
about the schema. So if you can see the documents,

553
00:34:38,286 --> 00:34:41,798
it has cure and mutation. The query has this to do where we

554
00:34:41,804 --> 00:34:45,398
need to pass the user id and mutation where we

555
00:34:45,404 --> 00:34:52,150
can kind of create a new to do. So I'm

556
00:34:52,230 --> 00:34:56,506
quickly going to show you a simple example. We have query to do if

557
00:34:56,528 --> 00:34:59,754
you can see to do, it's asking for user id and

558
00:34:59,792 --> 00:35:03,354
then text and user id. So this is the

559
00:35:03,392 --> 00:35:06,686
information when we are saying that, okay, this is the information we are passing you.

560
00:35:06,788 --> 00:35:09,920
And at the written just return me text and user id.

561
00:35:10,290 --> 00:35:13,486
If I'm going to run this thing. We can see we are getting text and

562
00:35:13,508 --> 00:35:17,038
user id. If I'm going to bypass any of the field, let's say

563
00:35:17,124 --> 00:35:20,754
I only need a text because I already know the user id this

564
00:35:20,792 --> 00:35:24,226
information is going to become. Now we can see that the information which

565
00:35:24,248 --> 00:35:28,494
is coming from backend is

566
00:35:28,552 --> 00:35:31,414
something that we are asking for. So this is one of the kind of a

567
00:35:31,452 --> 00:35:34,310
major advantage of graphQl.

568
00:35:36,010 --> 00:35:39,554
Now apart from query, we can also run mutation

569
00:35:39,602 --> 00:35:42,554
where we can create a new data.

570
00:35:42,752 --> 00:35:46,460
So here we are saying that, okay, create a to do, just pass some

571
00:35:47,230 --> 00:35:50,922
random values over here, the text and for the user id.

572
00:35:50,976 --> 00:35:54,614
So if I'm Golang to say for the user id to create it

573
00:35:54,752 --> 00:35:58,334
and then return me only the id, if I'm going to run the same

574
00:35:58,372 --> 00:36:01,806
command here and say that I need to have for

575
00:36:01,828 --> 00:36:05,598
the second user get the data and I'm going to

576
00:36:05,604 --> 00:36:08,946
run this thing again. So you can see that it's just returning me for the

577
00:36:08,968 --> 00:36:12,466
user two and this is for

578
00:36:12,488 --> 00:36:16,098
the user one. So this is all about the playground in this thing.

579
00:36:16,264 --> 00:36:19,910
Now let's see how we can deploy the same thing on AWS lambda.

580
00:36:20,970 --> 00:36:24,726
Now for the lambda, what I've done so far is I just created a

581
00:36:24,748 --> 00:36:28,562
common code, which is mostly a router code, into the router

582
00:36:28,626 --> 00:36:32,246
go file. We can quickly see that we have this router.

583
00:36:32,358 --> 00:36:35,980
We have the information about the GraphqL handler, legal information.

584
00:36:36,350 --> 00:36:40,106
It just initialized the router and it just kind

585
00:36:40,128 --> 00:36:44,186
of returned the path of the router. And then I created

586
00:36:44,298 --> 00:36:48,126
two different folders, one for local, for the

587
00:36:48,148 --> 00:36:51,690
local which is for the local operation, the offline mode,

588
00:36:51,770 --> 00:36:55,406
and then lambda main go, which is to run the application

589
00:36:55,508 --> 00:36:59,314
on lambda the main local main go

590
00:36:59,352 --> 00:37:02,546
is nothing but a simple initializing router, passing the

591
00:37:02,568 --> 00:37:06,462
port number to the router and then lambda

592
00:37:06,526 --> 00:37:10,198
has the same configuration, initializing a router which you

593
00:37:10,204 --> 00:37:13,330
have seen as a code sharing slide.

594
00:37:13,490 --> 00:37:17,478
And then we are just creating a proxy and we are just starting the

595
00:37:17,484 --> 00:37:21,066
lambda. So that's it. We are doing it for

596
00:37:21,088 --> 00:37:24,970
the deployment. The deployment is almost same,

597
00:37:25,040 --> 00:37:28,166
nothing has been changed. Only one thing which has been changed

598
00:37:28,198 --> 00:37:31,722
so far in the deployment is because

599
00:37:31,776 --> 00:37:35,786
this application require a dynamodB access. So we actually added a dynamodb

600
00:37:35,818 --> 00:37:39,514
access over here. We are just passing a customized

601
00:37:39,562 --> 00:37:43,114
role information. We are saying it can perform gate

602
00:37:43,162 --> 00:37:46,690
port queries, can update operation on the DynamodB database.

603
00:37:47,030 --> 00:37:51,154
And then the function that we have, I think

604
00:37:51,192 --> 00:37:54,130
everything is same. The path is lambda folder.

605
00:37:54,630 --> 00:37:58,166
We have kind of customized name for the handler name. It is

606
00:37:58,188 --> 00:38:01,586
using this runtime go one x version

607
00:38:01,778 --> 00:38:05,574
and it is using a specific role and that role has

608
00:38:05,612 --> 00:38:08,966
been created over there which has the dynamic access. Rest of

609
00:38:08,988 --> 00:38:12,406
the things are same. Now one more, there is a

610
00:38:12,428 --> 00:38:15,866
small, very small difference over there. If you can see the

611
00:38:15,888 --> 00:38:20,134
queries, it has only two things. So we have this gate query for the playground

612
00:38:20,262 --> 00:38:23,386
and for the post query to do kind of

613
00:38:23,408 --> 00:38:26,782
a query or mutation. So in graphql everything is mostly a post

614
00:38:26,836 --> 00:38:31,006
operation. So if you want to update something we need to use the

615
00:38:31,028 --> 00:38:34,560
HTTP work which is post or if you want to use any,

616
00:38:35,570 --> 00:38:39,230
get the data. We again go in for the post operation.

617
00:38:39,390 --> 00:38:43,026
So this is the entire configuration that

618
00:38:43,048 --> 00:38:46,562
we have here. We are mentioning that

619
00:38:46,696 --> 00:38:50,274
we need to kind of open two endpoint. One will be a gate

620
00:38:50,322 --> 00:38:53,686
and another will be a post. Post is for QD and gate is for

621
00:38:53,708 --> 00:38:57,126
the playground and that's it.

622
00:38:57,228 --> 00:39:01,302
And then again we need to run the same command, same build for building

623
00:39:01,356 --> 00:39:04,566
this structure and same deploy. And during the same deploy

624
00:39:04,598 --> 00:39:07,418
it is going to ask you a lot of things like what will be a

625
00:39:07,424 --> 00:39:10,934
cloudformation stack name, other information, your bucket

626
00:39:10,982 --> 00:39:14,026
name. And once the deployment is done you are going to get

627
00:39:14,048 --> 00:39:17,406
a URL. And this time I'm going to show you

628
00:39:17,428 --> 00:39:20,938
a different chrome extension which is for the playground.

629
00:39:21,034 --> 00:39:24,366
And we'll see how we can play around with the same thing. And the

630
00:39:24,388 --> 00:39:28,210
code is deployed on AWS lambda.

631
00:39:29,430 --> 00:39:32,754
So this is kind of a different variation of playground. So we have seen this

632
00:39:32,792 --> 00:39:36,334
playground which is provided by the GQL gen and this is kind of a chrome

633
00:39:36,382 --> 00:39:39,654
extension for us which is kind of very standard playground for

634
00:39:39,692 --> 00:39:42,920
graphQl operation. We can see schema here,

635
00:39:43,290 --> 00:39:46,982
we can see the schema over here and then we can

636
00:39:47,036 --> 00:39:50,906
perform the same operation. We can do again the query call

637
00:39:51,008 --> 00:39:54,860
with gate and the user information is going to return the data.

638
00:39:55,390 --> 00:39:59,450
We can quickly check for different user is

639
00:39:59,520 --> 00:40:03,978
returning this data. I can check for the specific thing

640
00:40:04,144 --> 00:40:07,774
and the important thing is the URL which you are seeing over here.

641
00:40:07,892 --> 00:40:11,118
This is actually pointing to an API gateway and

642
00:40:11,204 --> 00:40:13,914
this is the endpoint where we are heading so far.

643
00:40:14,052 --> 00:40:16,420
Similarly we can also do the mutation here.

644
00:40:21,510 --> 00:40:25,554
I can put some more content here, update and

645
00:40:25,592 --> 00:40:28,790
then again run the same query for the same user.

646
00:40:33,770 --> 00:40:37,414
And now you can see my contain this value which has been put

647
00:40:37,532 --> 00:40:41,366
it's available. So this is all about how we can

648
00:40:41,388 --> 00:40:44,886
use the GQN generator for creating the resolvers and how we

649
00:40:44,908 --> 00:40:48,486
can kind of deploy this thing on AWS lambda. Thank you

650
00:40:48,508 --> 00:40:52,222
so much for watching this presentation. I hope that you have learn lot of things

651
00:40:52,276 --> 00:40:55,486
from these presentations. And before I sign off I just

652
00:40:55,508 --> 00:40:58,894
want to give some information about my current company. I'm working in

653
00:40:58,932 --> 00:41:02,286
take nine and this is the fastest growing company in the

654
00:41:02,308 --> 00:41:06,254
world. We have offices in US, India and Latin America and

655
00:41:06,292 --> 00:41:09,886
you can reach out us on LinkedIn as well as you can call us on

656
00:41:09,908 --> 00:41:12,460
the mentioned mobile number. So thank you so much.

