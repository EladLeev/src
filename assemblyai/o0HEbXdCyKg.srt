1
00:00:25,330 --> 00:00:28,738
You hi, my name is Daniel

2
00:00:28,834 --> 00:00:32,326
for the Conf 42 I'll walk you through types those compile options.

3
00:00:32,428 --> 00:00:35,846
If you'd like to discuss a little bit more, you can just scan the

4
00:00:35,868 --> 00:00:38,886
QR code Andor connect with me via LinkedIn. I will be happy to answer more

5
00:00:38,908 --> 00:00:43,160
questions. So types compiler rules, type risk compiler options

6
00:00:44,570 --> 00:00:48,466
what it is about if we would like visit the technical documentation,

7
00:00:48,498 --> 00:00:52,240
we'd see a bunch of rules and it's really like difficult to

8
00:00:52,610 --> 00:00:55,902
walk through all of them. It requires lots of time and

9
00:00:55,956 --> 00:01:00,094
attention. Our presentation is mostly about this part which is

10
00:01:00,292 --> 00:01:03,938
highlighted in red. We'll also touch upon a

11
00:01:03,944 --> 00:01:07,506
little bit of the compiler option from

12
00:01:07,528 --> 00:01:11,940
different categories, but the strict rules are mostly around

13
00:01:12,630 --> 00:01:16,450
in those highlighted red zone. Before like

14
00:01:16,520 --> 00:01:19,986
few minutes back the way how it

15
00:01:20,008 --> 00:01:23,526
was divided Andor in the documentation was a little

16
00:01:23,548 --> 00:01:27,586
bit different, so we could explicitly see which are strict checks

17
00:01:27,698 --> 00:01:30,898
which are for example interchecks. Now they kind of

18
00:01:30,924 --> 00:01:34,394
compiler this and then they call it type checking, but those

19
00:01:34,432 --> 00:01:38,298
rules are still the same, they just categorize it a little bit different.

20
00:01:38,464 --> 00:01:41,070
So we are starting on the TS config.

21
00:01:41,890 --> 00:01:44,960
I hope most of you know what TS config is.

22
00:01:46,210 --> 00:01:49,454
This part of the TS config which we will be

23
00:01:49,492 --> 00:01:53,490
talking about is of course in the compile options, and within

24
00:01:53,560 --> 00:01:56,594
the compiler options you can set up

25
00:01:56,792 --> 00:02:00,078
some extra checks to make your typescript

26
00:02:00,174 --> 00:02:03,426
to be more strict or for certain rules we

27
00:02:03,448 --> 00:02:07,246
will be talking about the first rule we'll touch upon.

28
00:02:07,438 --> 00:02:10,470
We'll start slowly. It's not implicit Annie,

29
00:02:11,050 --> 00:02:15,222
and we have a very first code

30
00:02:15,276 --> 00:02:19,030
snippet sample function

31
00:02:19,100 --> 00:02:22,714
which has a parameter and our implicit n is

32
00:02:22,832 --> 00:02:26,666
disabled, or it's false, or it's not set up at

33
00:02:26,688 --> 00:02:30,134
all, which by default it's false. And by the way, this is how the presentation

34
00:02:30,182 --> 00:02:34,330
will start with each rule. On the top left corner

35
00:02:34,410 --> 00:02:38,320
you will see the compiler option and in the middle you will see

36
00:02:39,090 --> 00:02:42,554
the code we are talking about. But with no

37
00:02:42,612 --> 00:02:46,242
implicit any actually types would pop

38
00:02:46,296 --> 00:02:50,526
up as error that this parameter implicitly

39
00:02:50,558 --> 00:02:53,986
has can any type. By the way, maybe some of you have

40
00:02:54,008 --> 00:02:58,150
noticed, but this no implicit any flag has changed to

41
00:02:58,220 --> 00:03:01,462
true. So to helps you guys

42
00:03:01,516 --> 00:03:04,920
to map when what

43
00:03:05,370 --> 00:03:09,066
is being shown. For example with the true it will be always see on

44
00:03:09,088 --> 00:03:13,260
the screen that there is some kind of error or a warning at least.

45
00:03:14,190 --> 00:03:19,766
So here we can quickly see the implicit sample

46
00:03:19,798 --> 00:03:23,614
dont implicit whats can n type and we can quickly fix

47
00:03:23,652 --> 00:03:27,710
this by adding string to hotspot.

48
00:03:28,690 --> 00:03:31,886
Where was the problem? It was in the parameter and we

49
00:03:31,908 --> 00:03:36,002
have added string. Those is also how we follow up with other examples to

50
00:03:36,056 --> 00:03:39,554
hotspot which part of the code

51
00:03:39,592 --> 00:03:43,538
was problematic and how we fix this next one.

52
00:03:43,624 --> 00:03:47,142
Also related, no implicit this time

53
00:03:47,196 --> 00:03:50,630
this code

54
00:03:50,700 --> 00:03:54,550
as the first glance looks fine and maybe

55
00:03:54,620 --> 00:03:58,246
even before preparing

56
00:03:58,278 --> 00:04:01,962
those presentation I would also say, yeah, it's completely fine,

57
00:04:02,016 --> 00:04:05,898
but there is something which

58
00:04:05,984 --> 00:04:08,300
every now and then I have seen as my ide.

59
00:04:10,530 --> 00:04:14,174
But let's first enable the no implicit disk and now

60
00:04:14,212 --> 00:04:17,854
we can see what those

61
00:04:17,972 --> 00:04:21,166
id is complaining about,

62
00:04:21,348 --> 00:04:24,660
namely this implicitly Andor type.

63
00:04:26,390 --> 00:04:30,046
Yeah, and this actually is a little bit confusing

64
00:04:30,078 --> 00:04:33,874
because typing this might

65
00:04:33,912 --> 00:04:37,174
be a bit counterintuitive for many of us. And for me,

66
00:04:37,212 --> 00:04:40,790
for example, it also was I have to express,

67
00:04:41,770 --> 00:04:45,542
but there are actually two ways to fix this in a way

68
00:04:45,596 --> 00:04:49,580
that typescript will be satisfied as well

69
00:04:50,030 --> 00:04:54,090
with the no implicit enabled,

70
00:04:55,710 --> 00:05:00,314
the first option is to make an arrow

71
00:05:00,362 --> 00:05:04,426
function, and that's

72
00:05:04,458 --> 00:05:07,520
actually it, you don't have to do anything more.

73
00:05:08,450 --> 00:05:10,160
The problem was here,

74
00:05:13,010 --> 00:05:16,306
this was the hotspot I would say of the error, and we

75
00:05:16,328 --> 00:05:19,650
could fix it like that. Okay, simple.

76
00:05:19,720 --> 00:05:23,858
But there is another solution, maybe more intuitive some, I would say

77
00:05:24,024 --> 00:05:27,174
for me it is because I can quickly see that this

78
00:05:27,372 --> 00:05:31,206
is explicitly set to those total amount, which in

79
00:05:31,228 --> 00:05:37,078
this example is the class. And in

80
00:05:37,164 --> 00:05:41,098
that way we fix this error with setting this in

81
00:05:41,104 --> 00:05:42,940
the parentheses to total amount.

82
00:05:44,670 --> 00:05:47,962
No implicit returns. For returns follow the

83
00:05:48,016 --> 00:05:51,194
similar logic as no implicit n and

84
00:05:51,232 --> 00:05:54,574
those. So I have quite some rules to go

85
00:05:54,612 --> 00:05:57,982
through, so I will just skip this. But as you follow

86
00:05:58,036 --> 00:06:03,554
the first two examples, I'm pretty sure you can conclude what

87
00:06:03,592 --> 00:06:07,134
it is about no increase override.

88
00:06:07,182 --> 00:06:09,620
It's actually interesting one up.

89
00:06:11,510 --> 00:06:13,380
I wasn't. Yes,

90
00:06:14,390 --> 00:06:23,846
it opens up and

91
00:06:24,028 --> 00:06:31,354
up. It didn't go no, it here

92
00:06:31,392 --> 00:06:35,818
we are here maybe

93
00:06:35,904 --> 00:06:39,206
in typescript, actually we don't,

94
00:06:39,398 --> 00:06:43,040
it's not that intuitive or

95
00:06:44,450 --> 00:06:47,578
javascript was of course slightly different Java,

96
00:06:47,594 --> 00:06:51,182
but for Java guys they could quickly see whats they

97
00:06:51,236 --> 00:06:54,590
would realize what it is about. For Javascript,

98
00:06:55,010 --> 00:06:58,562
including myself, it might be something new

99
00:06:58,616 --> 00:07:01,746
sometimes. So this flag tells us that if

100
00:07:01,768 --> 00:07:05,102
we have a class and we

101
00:07:05,176 --> 00:07:08,706
override whats class like here, so we have another class which extend

102
00:07:08,738 --> 00:07:14,120
the class andor we override this, then basically

103
00:07:14,490 --> 00:07:17,830
with this no implicit override,

104
00:07:18,350 --> 00:07:21,414
we kind of cannot

105
00:07:21,462 --> 00:07:24,666
do this if there is the keyword override. So if we

106
00:07:24,688 --> 00:07:28,234
have overwrite set up and the flag is enabled and

107
00:07:28,272 --> 00:07:32,110
we try to override

108
00:07:34,690 --> 00:07:38,414
sorry, we basically, when we extend the class

109
00:07:38,612 --> 00:07:41,822
and we override, we have to explicitly say that

110
00:07:41,876 --> 00:07:45,970
we are overriding. So it's not like

111
00:07:46,120 --> 00:07:48,930
implicitly set, it has to be the keyword.

112
00:07:50,550 --> 00:07:54,034
We are getting back to the presentation now.

113
00:07:54,072 --> 00:07:58,450
Unused locals it's about not unused local

114
00:07:58,520 --> 00:08:02,214
variables. Once again I will move forward.

115
00:08:02,332 --> 00:08:05,814
The name says everything. I would say

116
00:08:05,932 --> 00:08:09,046
the same about no unused parameters

117
00:08:09,238 --> 00:08:11,978
and allow unreachable code.

118
00:08:12,064 --> 00:08:15,894
That's something which I would just copy paste what's

119
00:08:15,942 --> 00:08:19,098
from documentation here

120
00:08:19,264 --> 00:08:23,230
with this, like you don't have to do anything. By default it's undefined,

121
00:08:23,730 --> 00:08:28,782
which means you will get a warning in your ide that

122
00:08:28,836 --> 00:08:32,910
yeah, those is a code which is unreachable.

123
00:08:33,430 --> 00:08:37,394
It's a small synthetic improvement, but still we don't want

124
00:08:37,432 --> 00:08:41,790
words like that code aloe unused labels

125
00:08:41,950 --> 00:08:45,266
and once again I will take a little bit from the

126
00:08:45,288 --> 00:08:49,234
documentation. It's actually same

127
00:08:49,272 --> 00:08:52,466
as aloe. Any tribal code id will give you a documentation,

128
00:08:52,498 --> 00:08:58,694
but it's very rare that you will see it because in

129
00:08:58,732 --> 00:09:02,394
javascript we don't tend to use libraries that much.

130
00:09:02,592 --> 00:09:06,374
Maybe when you'll be working for object literals you might spot

131
00:09:06,422 --> 00:09:09,738
this. But even if you'll forget about this Andor most of

132
00:09:09,744 --> 00:09:12,830
probably you will about this compile option,

133
00:09:12,980 --> 00:09:16,782
then by default you will get a warning. It will

134
00:09:16,836 --> 00:09:19,870
still compile to Javascript, but you just get a warning.

135
00:09:20,770 --> 00:09:23,986
Stricter note checks so that's one

136
00:09:24,008 --> 00:09:28,386
of the reasons why I skipped this very simple flags simple

137
00:09:28,488 --> 00:09:32,900
options because there are some

138
00:09:33,830 --> 00:09:37,410
compile options which are more essential

139
00:09:37,490 --> 00:09:41,106
I would say, for this presentation. Andor first of them is stricter null

140
00:09:41,138 --> 00:09:45,606
checks. This code also

141
00:09:45,708 --> 00:09:49,800
like without

142
00:09:50,570 --> 00:09:54,920
this enabled, your id actually

143
00:09:55,390 --> 00:09:59,340
wouldn't help you, I would say wouldn't tip you.

144
00:10:00,210 --> 00:10:04,750
But more experienced or even middle experienced

145
00:10:05,410 --> 00:10:08,000
developers could quickly know that okay,

146
00:10:12,690 --> 00:10:16,178
those greeting whats a string? And now it's a null. So there

147
00:10:16,184 --> 00:10:20,066
is something phishing definitely. And it is because if

148
00:10:20,088 --> 00:10:23,458
you enable this we can quickly see that type null is

149
00:10:23,464 --> 00:10:26,546
not as enabled type string. So that's

150
00:10:26,738 --> 00:10:31,954
the first, let's say parasite stricter

151
00:10:32,002 --> 00:10:35,880
compiler option from typescript we spot on

152
00:10:36,650 --> 00:10:40,170
this part of the code which we fix this by adding

153
00:10:40,510 --> 00:10:45,420
an extra type.

154
00:10:46,430 --> 00:10:49,914
Yeah, of course writing to null might

155
00:10:49,952 --> 00:10:54,254
be like a bad practice in general or in

156
00:10:54,292 --> 00:10:58,254
most of the scenarios I would say. But from

157
00:10:58,292 --> 00:11:01,854
the compiler options, if you are writing to Nordis, how you can fix

158
00:11:01,892 --> 00:11:05,794
this? So we had the problem here and

159
00:11:05,832 --> 00:11:09,854
we have based data strict

160
00:11:09,902 --> 00:11:11,730
property initialization,

161
00:11:13,830 --> 00:11:15,300
very basic example.

162
00:11:18,890 --> 00:11:21,400
Many would say yeah, everything is fine.

163
00:11:23,450 --> 00:11:27,190
I think quite some would say yeah, we are missing initialization

164
00:11:27,870 --> 00:11:31,802
and if we will enable this

165
00:11:31,856 --> 00:11:34,380
rule, then something will pop up here.

166
00:11:35,950 --> 00:11:39,514
Little note, if you want to have to enable the

167
00:11:39,552 --> 00:11:42,954
strict properties initialization, you have

168
00:11:42,992 --> 00:11:46,006
to also enable strict null

169
00:11:46,038 --> 00:11:49,882
tracks. Basically if you put the strict prepared initialization

170
00:11:49,946 --> 00:11:53,200
to true, then you have

171
00:11:54,210 --> 00:11:57,458
pop up from id that to have this working you need

172
00:11:57,464 --> 00:12:00,834
to enable strict null checks. So they are working only both together.

173
00:12:00,952 --> 00:12:04,526
I mean stricter project initialization requires strict null

174
00:12:04,558 --> 00:12:07,160
checks. That's better to say.

175
00:12:07,770 --> 00:12:11,526
So with those two enabled we can see that

176
00:12:11,628 --> 00:12:16,230
property name has no initializer.

177
00:12:17,870 --> 00:12:21,722
Andor the fix is basically very

178
00:12:21,776 --> 00:12:25,846
trivial. We just need to initialize this. Those hotspot

179
00:12:25,878 --> 00:12:29,190
was here. We fix this by initializing

180
00:12:29,270 --> 00:12:33,230
string string functions type function

181
00:12:33,300 --> 00:12:36,560
types. So it's slowly become interesting I hope.

182
00:12:39,810 --> 00:12:43,074
Yes, this will be example go to

183
00:12:43,112 --> 00:12:46,514
our ide at.

184
00:12:46,552 --> 00:12:49,458
At first glance it looks completely fine,

185
00:12:49,544 --> 00:12:53,614
but maybe some of you would already notice

186
00:12:53,662 --> 00:12:56,258
that maybe string or number. String or number.

187
00:12:56,344 --> 00:13:00,726
String or number. And here we are passing number and

188
00:13:00,748 --> 00:13:05,414
we are putting this to lowercase. So watch

189
00:13:05,452 --> 00:13:08,966
out whats will be happening. Okay, let's enable strict

190
00:13:08,998 --> 00:13:12,554
function types to true. And we

191
00:13:12,592 --> 00:13:14,700
have actually pop up from our ide.

192
00:13:16,590 --> 00:13:19,500
It's complaining about the type okay,

193
00:13:21,250 --> 00:13:23,680
which means that there is something wrong.

194
00:13:26,050 --> 00:13:29,854
We will hotspot the place which we

195
00:13:29,892 --> 00:13:33,938
have to make the fix. Let's say fix. So we just.

196
00:13:34,024 --> 00:13:37,060
But the number here, okay,

197
00:13:38,310 --> 00:13:42,050
I'm sorry, let me get back. We put those number

198
00:13:42,120 --> 00:13:44,942
here Andor something different pops up now,

199
00:13:45,016 --> 00:13:48,614
okay, which means that if

200
00:13:48,652 --> 00:13:52,034
we follow those, as I said at the beginning,

201
00:13:52,082 --> 00:13:55,570
there is some fishy. We pass number and two lowercase,

202
00:13:55,650 --> 00:13:59,094
okay, and now we

203
00:13:59,212 --> 00:14:02,994
can see that the type C

204
00:14:03,052 --> 00:14:09,574
three compiler options helps us to avoid

205
00:14:09,622 --> 00:14:13,120
bugs actually, because here if we pass those number,

206
00:14:13,810 --> 00:14:17,598
even though here we are fine. Then thanks to

207
00:14:17,604 --> 00:14:21,514
the case that we have strict function types to true types

208
00:14:21,562 --> 00:14:25,154
shows us okay, here actually it doesn't look

209
00:14:25,192 --> 00:14:28,834
good because it's one of those, okay, if we put

210
00:14:28,872 --> 00:14:32,286
a number and to lowercase to lowercase

211
00:14:32,398 --> 00:14:34,210
works only on strings,

212
00:14:35,670 --> 00:14:40,510
okay. And with

213
00:14:40,680 --> 00:14:43,190
strict function types to false,

214
00:14:44,570 --> 00:14:48,410
it didn't say about this part anything about sample parameter

215
00:14:48,830 --> 00:14:51,610
and it didn't even say about two lowercase,

216
00:14:54,110 --> 00:14:57,462
which is actually the essential problem in this snippet

217
00:14:57,526 --> 00:15:01,994
cost snippet. So I'm

218
00:15:02,042 --> 00:15:07,242
highlighting, we have added the number Andor types

219
00:15:07,306 --> 00:15:10,606
help us to actually spot where is the

220
00:15:10,628 --> 00:15:13,780
real problem. And here I will have a very simple example.

221
00:15:20,390 --> 00:15:23,090
Let me put examples.

222
00:15:26,490 --> 00:15:30,440
Okay. I just open this for you guys.

223
00:15:30,810 --> 00:15:34,840
It's a quite small example, okay Andor

224
00:15:35,210 --> 00:15:39,154
let's disable this to false,

225
00:15:39,282 --> 00:15:42,874
okay, here everything will be fine and

226
00:15:42,912 --> 00:15:46,140
we will also wait, let me make it that way.

227
00:15:46,830 --> 00:15:50,702
So I will remove it here and we see that

228
00:15:50,756 --> 00:15:54,254
whats the error from the presentation and we

229
00:15:54,292 --> 00:15:56,480
make it false now. Okay.

230
00:15:57,490 --> 00:16:01,246
And takes time but

231
00:16:01,268 --> 00:16:05,534
yes it works. And what's happening now we'll compile the typescript

232
00:16:05,582 --> 00:16:09,762
file to Javascript it

233
00:16:09,816 --> 00:16:14,050
did. What will happen now? Let's say we deployed

234
00:16:14,890 --> 00:16:19,426
those part of the code somewhere and user

235
00:16:19,458 --> 00:16:23,046
has clicked there was some kind of place to

236
00:16:23,068 --> 00:16:26,310
put input and we try to but to

237
00:16:26,380 --> 00:16:30,342
input to change the number to lowercase

238
00:16:30,406 --> 00:16:33,420
and what will happen? Yes,

239
00:16:37,870 --> 00:16:41,914
our users might have a bit unpleasant experience because it may throw

240
00:16:41,962 --> 00:16:46,014
error and yeah,

241
00:16:46,052 --> 00:16:50,014
most of a bit is not what we are looking for here.

242
00:16:50,052 --> 00:16:53,438
It was a very nice example how typescript

243
00:16:53,614 --> 00:16:57,874
can hotspot thanks

244
00:16:57,912 --> 00:17:01,150
to the typing can hotspot actually bugs

245
00:17:01,310 --> 00:17:05,170
here. The embedded

246
00:17:06,010 --> 00:17:12,200
two lowercase typescript method actually

247
00:17:13,290 --> 00:17:17,414
expects a string because

248
00:17:17,452 --> 00:17:22,170
we will get back sorry,

249
00:17:22,240 --> 00:17:23,180
not here.

250
00:17:25,230 --> 00:17:29,254
So now we have the proper types, then we can see that okay, to lowercase

251
00:17:29,302 --> 00:17:32,960
doesn't exist. So before deploying most of probably

252
00:17:33,730 --> 00:17:36,480
to handle it somehow. Okay,

253
00:17:38,210 --> 00:17:40,430
let me get back to the presentation.

254
00:17:42,690 --> 00:17:46,062
Yes, this is what I said that were was a problem not spotted.

255
00:17:46,126 --> 00:17:50,254
And now here we have all the hotspots.

256
00:17:50,302 --> 00:17:54,242
So first type complain about this one. We had to change

257
00:17:54,296 --> 00:17:57,558
here. The parameter was problematic, but at the end of the

258
00:17:57,564 --> 00:18:00,866
day the lowercase, those lowercase,

259
00:18:00,898 --> 00:18:05,314
it was the problem where it whats actually the but strict

260
00:18:05,362 --> 00:18:09,642
bind call and apply this option.

261
00:18:09,696 --> 00:18:13,066
I will skip. It's a

262
00:18:13,088 --> 00:18:17,450
nice one, but we dont

263
00:18:17,790 --> 00:18:21,882
tend to use bind call and apply that often after the

264
00:18:21,936 --> 00:18:25,166
ecmascape six came. So if you

265
00:18:25,188 --> 00:18:29,182
want to check it out, just take a look into

266
00:18:29,236 --> 00:18:32,094
the documentation. It's explained quite well.

267
00:18:32,132 --> 00:18:36,290
There no fall through cases in switch.

268
00:18:36,950 --> 00:18:41,150
That's interesting. One we have switch

269
00:18:41,230 --> 00:18:44,994
and cases. Our fall through case

270
00:18:45,032 --> 00:18:48,662
in switch is disabled, but we enable this and what

271
00:18:48,716 --> 00:18:50,950
happens, we have a warning.

272
00:18:51,770 --> 00:18:56,022
Okay, and to

273
00:18:56,076 --> 00:18:59,910
fix this we just basically need to add break because

274
00:18:59,980 --> 00:19:03,786
type six spot us that. Okay, this case

275
00:19:03,888 --> 00:19:07,626
ends without break. And here I also have

276
00:19:07,648 --> 00:19:11,758
one little example because I think this one is much a

277
00:19:11,764 --> 00:19:18,030
bit easier to follow if you see those real example hub.

278
00:19:19,090 --> 00:19:22,550
Okay, so I will make it false.

279
00:19:22,730 --> 00:19:25,806
Okay and I will remove

280
00:19:25,838 --> 00:19:29,506
the break andor now

281
00:19:29,608 --> 00:19:34,610
I will compiler TSC, six ts

282
00:19:36,890 --> 00:19:40,886
and now we

283
00:19:40,908 --> 00:19:44,662
can see even at odd, even though the number is zero. So it should

284
00:19:44,716 --> 00:19:48,234
finish here. But there's four through

285
00:19:48,272 --> 00:19:50,060
so it goes actually to one.

286
00:19:53,870 --> 00:19:57,226
The log actually I

287
00:19:57,248 --> 00:20:00,906
could put here maybe two. So it would be even and odd as more logic.

288
00:20:00,938 --> 00:20:04,874
But I hope you guys realize

289
00:20:04,922 --> 00:20:08,286
that it's just naming the

290
00:20:08,308 --> 00:20:11,854
essential parties. This one and this

291
00:20:11,892 --> 00:20:16,222
one. And now if we will compile

292
00:20:16,286 --> 00:20:19,870
this one more time, or transcompile

293
00:20:19,950 --> 00:20:23,682
to be more precise, then we can have

294
00:20:23,736 --> 00:20:28,838
see only event which makes sense. We gave zero to

295
00:20:29,004 --> 00:20:32,054
double check. We are in Javascript. Yes we

296
00:20:32,092 --> 00:20:34,600
have break perfect.

297
00:20:36,010 --> 00:20:39,402
Okay, so here was the

298
00:20:39,456 --> 00:20:43,818
problem and we fixed it by adding break exact

299
00:20:43,984 --> 00:20:47,514
optional property types, so becomes interesting.

300
00:20:47,712 --> 00:20:50,682
It's not like stricter per se,

301
00:20:50,736 --> 00:20:54,174
but there are also quite some types I will cover which are a bit like

302
00:20:54,212 --> 00:20:57,742
a bonus. So this

303
00:20:57,796 --> 00:21:01,710
one, it's getting

304
00:21:01,780 --> 00:21:05,700
slowly advanced because

305
00:21:07,190 --> 00:21:11,490
if we have the h with

306
00:21:11,640 --> 00:21:15,446
question mark so which is like optional andor we put

307
00:21:15,468 --> 00:21:19,154
it to number, then actually it's equivalent to number or undefined.

308
00:21:19,282 --> 00:21:22,966
So those using this interface here

309
00:21:23,148 --> 00:21:28,294
with these properties actually without

310
00:21:28,412 --> 00:21:31,962
exact option. Now property types seems

311
00:21:32,016 --> 00:21:35,850
to be fine, but actually it's not.

312
00:21:36,000 --> 00:21:39,162
And here one more time for those compiler option,

313
00:21:39,216 --> 00:21:42,240
we also need to enable strict nutrition before.

314
00:21:43,250 --> 00:21:47,438
Once again if you will enable exec optional property

315
00:21:47,524 --> 00:21:52,000
types first, the IDE will

316
00:21:53,750 --> 00:21:57,170
guide you that you need to first enable strict note checks.

317
00:21:58,390 --> 00:22:02,340
Okay, so we have this enabled and we can see that there is

318
00:22:02,870 --> 00:22:06,740
little problem. Type undefined is not

319
00:22:07,130 --> 00:22:11,030
assignable to type number, which means

320
00:22:11,100 --> 00:22:14,614
that fix should be quite simple and it

321
00:22:14,652 --> 00:22:18,200
indeed is. We have the

322
00:22:18,570 --> 00:22:21,510
number and we can just add undefined.

323
00:22:22,490 --> 00:22:25,722
So those function like you have something optional but

324
00:22:25,856 --> 00:22:29,130
you really don't want to use it, you want to put undefined,

325
00:22:29,470 --> 00:22:32,762
that's fine. So this is actually

326
00:22:32,816 --> 00:22:36,894
more readable as

327
00:22:37,012 --> 00:22:40,030
use unknown in catch variables.

328
00:22:40,450 --> 00:22:43,906
Getting long right. This is can interesting one.

329
00:22:44,008 --> 00:22:47,614
It's a very common scenario we use try and catch

330
00:22:47,662 --> 00:22:50,910
of course, and if you enable

331
00:22:50,990 --> 00:22:55,022
this flag then what will happen? Something weird

332
00:22:55,086 --> 00:22:58,790
actually propertymessage does not exist on type unknown,

333
00:22:59,210 --> 00:23:01,510
which means error.

334
00:23:02,490 --> 00:23:04,630
Error is unknown.

335
00:23:06,250 --> 00:23:09,834
I think it actually makes sense because

336
00:23:09,952 --> 00:23:12,460
we don't know what kind of error will come up.

337
00:23:13,550 --> 00:23:17,930
For now it's unknown. Or let's say for now it's unknown.

338
00:23:22,050 --> 00:23:25,200
Sorry. To fix this we need to

339
00:23:28,050 --> 00:23:31,646
put this in an if statement and actually if the

340
00:23:31,668 --> 00:23:35,540
error is instance of error then

341
00:23:37,430 --> 00:23:40,578
it will be gone saying in a

342
00:23:40,584 --> 00:23:43,906
very simple words here we can see were was

343
00:23:43,928 --> 00:23:47,782
the missing part and we have had whats if error instead

344
00:23:47,836 --> 00:23:52,198
of error then I

345
00:23:52,284 --> 00:23:56,200
believe that most of the code bases are without this.

346
00:24:00,970 --> 00:24:04,726
While preparing the presentation I read that it might introduce

347
00:24:04,758 --> 00:24:08,058
some, those might be some problems without

348
00:24:08,144 --> 00:24:11,806
using the if with the

349
00:24:11,828 --> 00:24:13,630
if, it's definitely more readable,

350
00:24:15,250 --> 00:24:19,294
but how serious it

351
00:24:19,332 --> 00:24:22,958
is if we won't put the if error is.

352
00:24:23,044 --> 00:24:27,106
Actually, to be honest, I don't. I am not really sure if there's a

353
00:24:27,288 --> 00:24:31,122
major risk for your code, but once again

354
00:24:31,176 --> 00:24:34,546
if you would like to maybe discuss a little bit more, you can reach out

355
00:24:34,568 --> 00:24:39,170
to me now. Always stricter.

356
00:24:40,330 --> 00:24:41,080
Yes,

357
00:24:44,010 --> 00:24:47,590
for that we have documentation. I think

358
00:24:47,660 --> 00:24:51,370
now this part of protection will be quite a lot with documentation

359
00:24:53,230 --> 00:24:56,090
always stricter is basically about the use stricter,

360
00:24:58,350 --> 00:25:02,462
so it means you

361
00:25:02,516 --> 00:25:07,230
actually should have it enabled, because ustrick

362
00:25:10,290 --> 00:25:13,886
makes sure that your javascript is in a strict mode,

363
00:25:13,918 --> 00:25:17,780
not in a sloppy mode. Sloppy mode is the code which sweep out

364
00:25:18,630 --> 00:25:22,226
script and it follows bunch of rules making the

365
00:25:22,248 --> 00:25:25,090
javascript less error prone, et cetera.

366
00:25:25,990 --> 00:25:31,186
Strict enables

367
00:25:31,218 --> 00:25:35,138
wide range of type checkings, some of them we covered,

368
00:25:35,314 --> 00:25:38,842
right, for example stricter bind colon PI said

369
00:25:38,896 --> 00:25:42,778
yeah, I mean we don't use that often bind colon apply

370
00:25:42,864 --> 00:25:46,874
let's say anymore. So we skip those, but all the others

371
00:25:46,992 --> 00:25:49,420
we actually talk about.

372
00:25:51,230 --> 00:25:54,958
So you might think okay, you put strict to true and

373
00:25:55,044 --> 00:25:59,114
all the typescript compiler option will be enabled

374
00:25:59,162 --> 00:26:02,960
for you, so you won't introduce any bug. But actually

375
00:26:03,810 --> 00:26:07,294
if you would get back to one of the very first slides,

376
00:26:07,342 --> 00:26:10,866
you'd notice that okay, we had a bunch of doors, bunch of rules, and some

377
00:26:10,888 --> 00:26:14,354
of them are

378
00:26:14,392 --> 00:26:18,760
in type checking. Some of them actually are somewhat different andor

379
00:26:19,450 --> 00:26:21,560
some of them we still didn't talk about.

380
00:26:22,330 --> 00:26:23,400
So yeah,

381
00:26:25,370 --> 00:26:29,218
I don't expect everyone will go through the whole documentation

382
00:26:29,394 --> 00:26:33,286
to enable all types three compiler.

383
00:26:33,318 --> 00:26:35,946
But just to be aware, if you put strict to true,

384
00:26:36,048 --> 00:26:40,066
that's already progressed. But be aware

385
00:26:40,118 --> 00:26:43,374
that there are many other rules we talked about and we have

386
00:26:43,412 --> 00:26:47,038
still a little bit to talk about which

387
00:26:47,204 --> 00:26:52,834
are not enabled. So with

388
00:26:52,872 --> 00:26:57,394
stricter true your code won't be like ideal or absolutely

389
00:26:57,512 --> 00:26:59,570
zero error prone.

390
00:27:02,310 --> 00:27:05,458
So diving deeper imports

391
00:27:05,474 --> 00:27:09,206
not used as values I

392
00:27:09,228 --> 00:27:13,126
said I have documentation here for

393
00:27:13,148 --> 00:27:16,470
some of those triggers. Actually it's not always it to find example, to be honest.

394
00:27:16,540 --> 00:27:20,278
So for those part documentation

395
00:27:20,374 --> 00:27:26,074
covered quite nicely by

396
00:27:26,112 --> 00:27:30,506
default. If you have values

397
00:27:30,538 --> 00:27:34,320
of types important never use

398
00:27:35,330 --> 00:27:42,458
during complete

399
00:27:42,564 --> 00:27:45,986
translation, it will drop this. If you want

400
00:27:46,008 --> 00:27:50,322
to preserve this you can enable preserve, but I

401
00:27:50,376 --> 00:27:53,506
don't recommend this because it can introduce some

402
00:27:53,528 --> 00:27:58,610
side effects alternative.

403
00:27:58,690 --> 00:28:02,662
If you really want to preserve them, then you can set

404
00:28:02,716 --> 00:28:06,274
as error and then the typescript

405
00:28:06,322 --> 00:28:10,118
compiler will show you that yeah, you have imported

406
00:28:10,214 --> 00:28:14,460
some type or value, but it has been never used

407
00:28:15,790 --> 00:28:20,730
here it's more like information with the default

408
00:28:21,550 --> 00:28:25,338
remove you are fine. Skip lip check Andor

409
00:28:25,424 --> 00:28:29,854
Skip default lip check skip lip check points

410
00:28:29,892 --> 00:28:33,458
you to skip to default lip check Sorry Skip default leap check

411
00:28:33,544 --> 00:28:39,458
points you to skip leap check sometimes

412
00:28:39,544 --> 00:28:43,714
it might be case that the libraries which you're using

413
00:28:43,912 --> 00:28:49,234
define two different types and

414
00:28:49,352 --> 00:28:53,638
skip leap check will make

415
00:28:53,804 --> 00:28:57,654
sure that the type c will not

416
00:28:57,692 --> 00:29:01,574
check both of them. So actually that's a trade off between performance

417
00:29:01,622 --> 00:29:05,178
and strict so if you want keep kind of like a

418
00:29:05,184 --> 00:29:08,762
bit stricter rules. It's not strict per se,

419
00:29:08,816 --> 00:29:12,186
but it's kind of strict. So if you want to make sure that it

420
00:29:12,208 --> 00:29:15,294
will check dependency a

421
00:29:15,332 --> 00:29:19,422
and b, if the types are correct, then you just keep it. If you

422
00:29:19,556 --> 00:29:23,840
are looking for performance improvement then you can just put true. But basically

423
00:29:25,730 --> 00:29:29,166
whenever you are facing this issue, you mostly read about your resolution

424
00:29:29,198 --> 00:29:32,434
or overwrite. But this is also something

425
00:29:32,472 --> 00:29:35,762
which typescript has force

426
00:29:35,826 --> 00:29:37,990
consistent casing in file names.

427
00:29:39,130 --> 00:29:41,750
I think it's self explanatory.

428
00:29:43,610 --> 00:29:47,030
For example, your file will be

429
00:29:47,100 --> 00:29:52,780
file manager in

430
00:29:53,790 --> 00:29:55,420
upper camel case.

431
00:29:56,750 --> 00:30:00,442
I think for this for example will

432
00:30:00,576 --> 00:30:04,730
be very familiar for many people coming from react background

433
00:30:04,890 --> 00:30:08,734
because the ecosystem and documentation kind

434
00:30:08,772 --> 00:30:12,126
of guides you. But here if you

435
00:30:12,148 --> 00:30:15,760
can make it,

436
00:30:16,870 --> 00:30:20,914
you would like to make it more strict and have

437
00:30:20,952 --> 00:30:24,546
the check automatic, then you can

438
00:30:24,568 --> 00:30:28,630
also think about this. As you can see it's recommended

439
00:30:29,690 --> 00:30:34,726
no implicit use stricter. Actually you

440
00:30:34,748 --> 00:30:37,560
will never use this I believe,

441
00:30:40,350 --> 00:30:44,266
but this rule and

442
00:30:44,288 --> 00:30:48,540
the next one is just to be aware that there is something like that.

443
00:30:49,070 --> 00:30:53,134
If you would like to. If for

444
00:30:53,172 --> 00:30:56,574
some reason you don't want to have use strict when

445
00:30:56,612 --> 00:31:00,186
emitting a module to a non es six target that's

446
00:31:00,218 --> 00:31:04,466
actually important, then you can

447
00:31:04,568 --> 00:31:09,074
put it to true. But 99

448
00:31:09,272 --> 00:31:12,878
dont andor eleven 9% of you guys dont

449
00:31:12,894 --> 00:31:16,126
need it and I'm not going to use that. But it reads

450
00:31:16,158 --> 00:31:20,262
kind of too strict rules. I want to cover as much actually everything in

451
00:31:20,396 --> 00:31:24,070
presentation, so I did include those, but you're not going to need it.

452
00:31:24,220 --> 00:31:26,630
No. Typescript generic checks.

453
00:31:31,210 --> 00:31:32,280
Once again,

454
00:31:34,570 --> 00:31:38,326
this is good by default. This is set correctly by

455
00:31:38,348 --> 00:31:39,110
default.

456
00:31:42,270 --> 00:31:44,410
It protects you by default.

457
00:31:47,470 --> 00:31:50,714
I cannot imagine that someone would like to

458
00:31:50,752 --> 00:31:55,534
set it true, but for

459
00:31:55,572 --> 00:31:58,430
you to be aware that for these kinds of scenarios,

460
00:31:59,010 --> 00:32:02,400
typescript also protects you by default. That's nice.

461
00:32:03,650 --> 00:32:08,690
Another flag. Here we

462
00:32:08,760 --> 00:32:12,420
are in flags which actually are set

463
00:32:12,790 --> 00:32:16,594
nicely corrective for us by

464
00:32:16,712 --> 00:32:19,140
the TS config. Once again,

465
00:32:21,210 --> 00:32:24,578
typescript protects you from this kind of scenario

466
00:32:24,594 --> 00:32:28,680
when you have a type and you are trying to

467
00:32:29,210 --> 00:32:32,666
create a variable with this type,

468
00:32:32,848 --> 00:32:36,106
but with property inside which

469
00:32:36,128 --> 00:32:39,660
is not defined. This type, please keep it.

470
00:32:40,670 --> 00:32:44,114
Another one suppress implicit andor index

471
00:32:44,182 --> 00:32:45,070
errors.

472
00:32:49,970 --> 00:32:54,174
Here we

473
00:32:54,212 --> 00:32:56,900
are also protected by default because for example,

474
00:32:57,430 --> 00:33:01,460
imagine that we have can object and

475
00:33:02,870 --> 00:33:06,290
we are trying to access foo, which actually

476
00:33:06,360 --> 00:33:07,970
doesn't exist.

477
00:33:13,100 --> 00:33:16,936
Actually you

478
00:33:16,958 --> 00:33:20,516
can put this to true or put a TS ignore

479
00:33:20,548 --> 00:33:24,590
on this, but that's a really bad thing, so please don't do it.

480
00:33:25,680 --> 00:33:29,192
Once again, we can see that yet another scenario,

481
00:33:29,256 --> 00:33:33,244
typescript protects us by default disable fine

482
00:33:33,282 --> 00:33:35,900
line based system type acquisition.

483
00:33:37,940 --> 00:33:41,856
That's a very small thing actually, but it's relatively new.

484
00:33:41,878 --> 00:33:45,836
We have in typescript for one, since typescript

485
00:33:45,868 --> 00:33:49,556
for one. For example, if you

486
00:33:49,578 --> 00:33:53,952
have a jquery JS, then it will automatically

487
00:33:54,016 --> 00:33:57,540
download the types for jquery from definitely typed.

488
00:34:00,780 --> 00:34:08,104
So here I cannot come

489
00:34:08,142 --> 00:34:11,240
up with a scenario when actually

490
00:34:11,310 --> 00:34:15,416
I could think to use it because mostly I just install everyone

491
00:34:15,518 --> 00:34:19,390
just install the package and it automatically gets everything.

492
00:34:21,760 --> 00:34:26,224
But if for some reason you

493
00:34:26,262 --> 00:34:30,144
have js file and you don't want those types to

494
00:34:30,182 --> 00:34:33,010
be downloaded automatically, you can set this to true.

495
00:34:36,740 --> 00:34:40,368
What can I say more here? Very niche,

496
00:34:40,464 --> 00:34:41,670
that's a good word.

497
00:34:44,360 --> 00:34:48,704
Now we are outside typescript world, but typescript

498
00:34:48,752 --> 00:34:52,372
compiler options also has some rules

499
00:34:52,516 --> 00:34:55,832
related to JavaScript. For example, allow JS by

500
00:34:55,886 --> 00:34:59,556
default it's false. If you want to allow JS

501
00:34:59,748 --> 00:35:06,140
modules to be imported in your typescript

502
00:35:06,480 --> 00:35:10,728
project, you can set this to true. Another is check js.

503
00:35:10,744 --> 00:35:14,796
So for example if you allow js then actually it would make sense whats

504
00:35:14,898 --> 00:35:19,024
you also but checkjs to true because the check js will check if

505
00:35:19,062 --> 00:35:23,024
those imported JavaScript modules are fine. So actually

506
00:35:23,062 --> 00:35:26,956
you enable this only if allow JS is enabled.

507
00:35:27,148 --> 00:35:30,960
Same for max node modules js depth by default

508
00:35:31,120 --> 00:35:34,710
those is actually option about

509
00:35:35,640 --> 00:35:39,972
how deep you can go

510
00:35:40,026 --> 00:35:43,480
through node modules to import the JS module.

511
00:35:44,540 --> 00:35:48,388
And you would of course enable this only when allowed.

512
00:35:48,404 --> 00:35:53,770
JS is true because otherwise if you cannot allow js then what's those point to

513
00:35:55,260 --> 00:35:58,728
put this one, if you cannot import js

514
00:35:58,824 --> 00:36:02,364
files, the previous one

515
00:36:02,402 --> 00:36:06,064
allow js and checkgrid you might use sometimes, but this one

516
00:36:06,102 --> 00:36:09,970
I don't think so you will use it to offset, to be honest.

517
00:36:11,700 --> 00:36:16,130
Now we have a couple of even

518
00:36:19,400 --> 00:36:23,184
more advanced compiler

519
00:36:23,232 --> 00:36:25,990
one moment, sorry,

520
00:36:27,960 --> 00:36:30,950
no property, no property.

521
00:36:33,020 --> 00:36:37,370
I'm not sure why the hyperlinks are working really bad. Sorry for that.

522
00:36:39,100 --> 00:36:43,160
So what's happening here? We have interface

523
00:36:43,600 --> 00:36:47,310
and we are assuming that

524
00:36:50,240 --> 00:36:53,484
whatever is like here,

525
00:36:53,522 --> 00:36:57,120
it's unknown. Whatever comes extra to the interface

526
00:36:58,420 --> 00:37:01,536
then this is a

527
00:37:01,558 --> 00:37:05,248
string, okay, so we say

528
00:37:05,334 --> 00:37:08,432
yeah, for example string speed quality,

529
00:37:08,566 --> 00:37:12,368
it's there, it's there, so no problem. But what's happening when there is string username

530
00:37:12,464 --> 00:37:19,284
which is not here? And this is what

531
00:37:19,322 --> 00:37:21,110
the compile option is about.

532
00:37:22,760 --> 00:37:26,296
If you turn on the flag then okay, this is

533
00:37:26,318 --> 00:37:29,528
continuation of the previous code, okay, you can see speed quality,

534
00:37:29,694 --> 00:37:32,900
speed quality okay, and the interface is also here,

535
00:37:32,990 --> 00:37:36,796
don't worry. So we can see that those property username comes from

536
00:37:36,898 --> 00:37:41,470
an index signature, so it must be accessed with fusion. So if

537
00:37:44,320 --> 00:37:46,960
it comes from index signature.

538
00:37:50,420 --> 00:37:54,464
So if it's annoying the interface and you

539
00:37:54,502 --> 00:37:58,290
want to put something

540
00:38:00,420 --> 00:38:02,790
extra like property were,

541
00:38:03,320 --> 00:38:06,836
then for the case you

542
00:38:06,858 --> 00:38:10,596
can distinguish in the code that you are doing. So you

543
00:38:10,618 --> 00:38:13,610
have to access it differently, namely like this.

544
00:38:14,460 --> 00:38:17,752
In that scenario, while reviewing your code, you can actually

545
00:38:17,806 --> 00:38:21,784
see that because of course when equivalent object in JavaScript we

546
00:38:21,822 --> 00:38:25,676
can access the property via dot or

547
00:38:25,858 --> 00:38:29,630
via array, okay, and put some value

548
00:38:30,000 --> 00:38:33,740
because we can see that let's say those interface defines somewhat different

549
00:38:33,810 --> 00:38:37,376
file whatever and we are going like this,

550
00:38:37,478 --> 00:38:40,924
okay, then we see, okay, those two are defined,

551
00:38:40,972 --> 00:38:44,912
but when we see something like that, then we can distinguish that

552
00:38:45,046 --> 00:38:48,800
those is unknown for the interface.

553
00:38:54,680 --> 00:38:57,510
So we can actually conclude this very quickly.

554
00:38:58,600 --> 00:39:02,200
It's more like code quality

555
00:39:02,270 --> 00:39:06,116
improvement, I would say a bit advanced,

556
00:39:06,308 --> 00:39:09,624
very kind, sometimes niche, but this one actually might be used

557
00:39:09,662 --> 00:39:13,056
sometimes. Now no unchecked indexed

558
00:39:13,188 --> 00:39:17,000
access I will access it here because it's nearby.

559
00:39:17,160 --> 00:39:20,344
Again we have interface name OS

560
00:39:20,392 --> 00:39:23,848
inside. Again unknown properties are covered

561
00:39:23,864 --> 00:39:26,320
by this index signature.

562
00:39:27,460 --> 00:39:30,544
And what's happening here,

563
00:39:30,582 --> 00:39:33,452
this is not declared Andor it's still as a string,

564
00:39:33,516 --> 00:39:36,976
which kind of makes sense because this

565
00:39:36,998 --> 00:39:41,380
is how we time. But let's think about the unknown keyword

566
00:39:41,720 --> 00:39:45,184
with this flex enabled. Actually we would notice

567
00:39:45,232 --> 00:39:50,384
that this one is stringed or undefined because

568
00:39:50,442 --> 00:39:54,264
it was unknown, so it might be also undefined. Andor this

569
00:39:54,302 --> 00:40:00,330
compile option will help to spot this

570
00:40:02,640 --> 00:40:03,390
information.

571
00:40:07,040 --> 00:40:10,604
Allow synthetic default imports I will look

572
00:40:10,642 --> 00:40:15,020
like this synthetic default imports.

573
00:40:18,980 --> 00:40:22,480
So here is when you are importing

574
00:40:23,780 --> 00:40:27,680
a module and when the module doesn't have a default,

575
00:40:29,460 --> 00:40:33,124
which you can import. So if the module doesn't have those port,

576
00:40:33,162 --> 00:40:39,152
this flag will find this, but disable

577
00:40:39,216 --> 00:40:40,420
size limit.

578
00:40:43,420 --> 00:40:49,316
There are some memory related memory

579
00:40:49,508 --> 00:40:51,400
things in typescript.

580
00:40:55,180 --> 00:40:58,672
It's not related to your code, but it's actually related to testing

581
00:40:58,836 --> 00:41:06,464
behind the scenes or under the hood. And if

582
00:41:06,502 --> 00:41:10,290
you put this to true, which I wouldn't recommend,

583
00:41:11,700 --> 00:41:16,140
then you might run in memory

584
00:41:16,220 --> 00:41:19,440
related issues because otherwise,

585
00:41:19,520 --> 00:41:23,168
which is by default there is some kind of size limit which typescript

586
00:41:23,264 --> 00:41:27,008
allocates for the memory. So it's

587
00:41:27,024 --> 00:41:30,548
a really low level thing. Guys, if you want to

588
00:41:30,554 --> 00:41:34,228
read more about there are the official documentation,

589
00:41:34,404 --> 00:41:37,976
there are two links basically you can also

590
00:41:38,078 --> 00:41:42,084
check this one and at the end of the presentation

591
00:41:42,132 --> 00:41:46,172
I will just to go very quickly through single page

592
00:41:46,226 --> 00:41:51,036
application frameworks and how they integrate with strict we

593
00:41:51,058 --> 00:41:54,524
have react which by

594
00:41:54,562 --> 00:41:57,970
default has some rules enabled. Okay,

595
00:41:58,580 --> 00:42:02,144
and look guys, you remember how many of rules we went through

596
00:42:02,342 --> 00:42:06,192
it. Whats strict? So without taking this printation we think okay,

597
00:42:06,326 --> 00:42:09,836
everything is fine. And we even have no fault through cases

598
00:42:09,868 --> 00:42:13,590
in switch before it was so called a linter check.

599
00:42:14,120 --> 00:42:17,750
We also have some force consistent casing in file names. I said

600
00:42:18,120 --> 00:42:21,504
this might be familiar for people from react because this is actually enforced

601
00:42:21,552 --> 00:42:25,448
by default. If you are working with types of CSX in

602
00:42:25,534 --> 00:42:29,560
react, then yes,

603
00:42:29,630 --> 00:42:33,080
then it kind of enforce you. I think if you generate

604
00:42:38,400 --> 00:42:42,296
react code with Javascript, then it's also enabled the force

605
00:42:42,328 --> 00:42:45,916
consistent casing in file name. So that's

606
00:42:45,948 --> 00:42:49,104
a good thing for react. And we have also a couple of others,

607
00:42:49,302 --> 00:42:50,850
few others. Okay,

608
00:42:53,220 --> 00:42:57,004
you can generate probably create react

609
00:42:57,052 --> 00:43:00,760
app. But some of the frameworks, if you add flagstrikes,

610
00:43:00,940 --> 00:43:05,028
then they will generate a different ts config. I will show you very quickly

611
00:43:05,114 --> 00:43:07,510
here in react, the strict doesn't work.

612
00:43:08,680 --> 00:43:13,224
So we have those rules by default view

613
00:43:13,262 --> 00:43:17,108
js two strict skip blitz

614
00:43:17,124 --> 00:43:19,640
check and allow centering default imports.

615
00:43:22,060 --> 00:43:25,772
When I checked on view JS three, it's basically the same

616
00:43:25,906 --> 00:43:29,532
if you generate the view JS with typescript. There is just one

617
00:43:29,586 --> 00:43:36,916
extra not related to our presentation compile

618
00:43:36,968 --> 00:43:39,120
option angular.

619
00:43:39,780 --> 00:43:43,248
Angular came with typescript, so we would expect quite a

620
00:43:43,254 --> 00:43:46,464
lot actually here and that actually working in

621
00:43:46,502 --> 00:43:50,080
angular you can generate your project with

622
00:43:50,150 --> 00:43:53,280
Nginu and you can use the flag strict,

623
00:43:53,700 --> 00:43:58,150
which would add some strict rules. Without this it won't add anything.

624
00:43:58,760 --> 00:44:02,804
And here we have strict no implicit returns and no photo casing

625
00:44:02,852 --> 00:44:06,996
switch. Those two actually are the all, let's say linters force

626
00:44:07,028 --> 00:44:10,040
consistent casing in file names. It's also being added,

627
00:44:11,100 --> 00:44:14,508
and in those default one it's not.

628
00:44:14,674 --> 00:44:19,624
So here actually react

629
00:44:19,672 --> 00:44:22,190
did better job, to be honest.

630
00:44:23,920 --> 00:44:24,670
Sorry.

631
00:44:28,480 --> 00:44:32,104
In addition to that angular access also it's

632
00:44:32,152 --> 00:44:36,096
all compiled options. And when

633
00:44:36,118 --> 00:44:40,116
you run this with strict, it also will add something

634
00:44:40,298 --> 00:44:45,488
on top of this. So this is actually really strict

635
00:44:45,664 --> 00:44:49,392
programming. Relatively strict programming

636
00:44:49,456 --> 00:44:53,560
if compared to different single page application frameworks.

637
00:44:53,980 --> 00:44:57,380
But let's say if you would forget but enable the flag

638
00:44:57,540 --> 00:45:01,304
angular will ask you, hey, maybe you

639
00:45:01,342 --> 00:45:05,496
want to get rid of some bugs andor while writing your code.

640
00:45:05,678 --> 00:45:09,988
And that's the only one frameworks which will do it Svelter.

641
00:45:10,084 --> 00:45:13,612
Svelter doesn't mean anything. We just go

642
00:45:13,666 --> 00:45:17,276
through to config which is in

643
00:45:17,298 --> 00:45:22,956
the package, which is in the hidden,

644
00:45:22,988 --> 00:45:27,040
let's say. But if I open this, then I can only see stricter as false.

645
00:45:28,120 --> 00:45:32,004
I think Svelte still has to do a little

646
00:45:32,042 --> 00:45:36,416
bit more in the typescript ecosystem.

647
00:45:36,608 --> 00:45:40,004
So while seeing this thing, I can see,

648
00:45:40,042 --> 00:45:43,350
okay, svelte is maybe not the best place,

649
00:45:44,220 --> 00:45:49,044
not the best framework to kick off with typescript

650
00:45:49,172 --> 00:45:53,050
and here we have a comparison. Angular has

651
00:45:53,760 --> 00:45:57,960
enabled on or off strict. I meant only the strict

652
00:45:58,040 --> 00:46:01,532
per se. React and view also

653
00:46:01,586 --> 00:46:06,144
can have it on the

654
00:46:06,182 --> 00:46:10,144
linters. I name it Linter. It's according to those, let's say old

655
00:46:10,342 --> 00:46:13,808
fashioned how to say, let's say the extra

656
00:46:13,894 --> 00:46:17,776
stick rules. Angular has two react, one certain view,

657
00:46:17,878 --> 00:46:22,144
zero to wrap up types helps

658
00:46:22,192 --> 00:46:25,300
preventing bugs. It's not only Reddit

659
00:46:25,640 --> 00:46:29,350
or Stag, overshore or any other source. Those is actually

660
00:46:30,200 --> 00:46:33,972
scientific fact. So it

661
00:46:34,026 --> 00:46:37,992
helps to. In this research it was about

662
00:46:38,046 --> 00:46:41,812
15%, but for example, think it was TypeScript

663
00:46:41,876 --> 00:46:44,570
2.0. So it was quite some time back.

664
00:46:45,200 --> 00:46:49,244
And now imagine with a new typescript. And if you'd enable your

665
00:46:49,282 --> 00:46:52,808
stricter rules, that's one and two, if you'd enable

666
00:46:52,904 --> 00:46:56,528
all the strict rules, or at least half of them we went through

667
00:46:56,694 --> 00:47:00,290
today, then this number can go up.

668
00:47:01,860 --> 00:47:05,228
And this is what I actually really like saying, that you don't

669
00:47:05,244 --> 00:47:08,836
need types because you are an expert. It's the same as you

670
00:47:08,938 --> 00:47:12,870
saying you don't need tests because you don't write bug code

671
00:47:15,800 --> 00:47:19,088
at the end, maybe a very little note.

672
00:47:19,264 --> 00:47:23,012
I cannot imagine there were that many bugs at Airbnb,

673
00:47:23,076 --> 00:47:27,256
but apparently they have made kind

674
00:47:27,278 --> 00:47:30,596
of audit. If they introduce typescript,

675
00:47:30,708 --> 00:47:35,464
then the bugs will be reduced by 38%

676
00:47:35,502 --> 00:47:38,844
of the bugs could have been gone. It's a big number.

677
00:47:38,962 --> 00:47:42,728
It's a big number. And I'm really curious if they enable the stricter

678
00:47:42,744 --> 00:47:44,990
rules or even if they restrict it.

679
00:47:45,600 --> 00:47:49,388
So we can maybe see that in the research they didn't. And here they did

680
00:47:49,474 --> 00:47:53,100
some and we can see, kind of approximation,

681
00:47:54,640 --> 00:47:58,068
how our code can be improved. That's it.

682
00:47:58,194 --> 00:48:01,524
That's again the QR code. If you want to connect me, just hit

683
00:48:01,562 --> 00:48:05,412
me up. I'm really happy to hear some feedback and

684
00:48:05,546 --> 00:48:08,996
walk a little bit more in depth in some of them. Thank you so much.

685
00:48:09,018 --> 00:48:11,250
It was a pleasure to give this talk.

