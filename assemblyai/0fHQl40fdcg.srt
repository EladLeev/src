1
00:00:23,670 --> 00:00:26,806
Tejas Kumar and I'm a developer relations consultant.

2
00:00:26,918 --> 00:00:30,258
What that means is I work with developer oriented companies, companies in

3
00:00:30,264 --> 00:00:34,046
the past and present, including companies like liveblocks, Crab Nebula,

4
00:00:34,078 --> 00:00:37,826
Opensourced, Versailles, et cetera, do their best devrel work and

5
00:00:37,848 --> 00:00:41,106
reach developers effectively. To do that I need to be in touch with

6
00:00:41,128 --> 00:00:44,126
the industry and kind of be up to date with some of the things we're

7
00:00:44,158 --> 00:00:47,478
talking about. And that's why we're doing this video today. Today we're going to

8
00:00:47,484 --> 00:00:51,014
talk about react server components. It's going to be really exciting. We'll start

9
00:00:51,052 --> 00:00:54,934
from really first principles, thinking about what even is React really

10
00:00:55,132 --> 00:00:58,706
how was react in its early days back when the

11
00:00:58,828 --> 00:01:02,502
development tooling wasn't as mature like today we just npxvit

12
00:01:02,566 --> 00:01:05,226
but in the past we had to write webpack configs and so on. And I

13
00:01:05,248 --> 00:01:08,406
feel like server components is in that area where the tooling hasn't

14
00:01:08,438 --> 00:01:12,906
yet caught up. But it stands to be a fundamental shift. We'll explore

15
00:01:13,098 --> 00:01:16,446
the architecture of react, including server components and how

16
00:01:16,468 --> 00:01:20,122
react was ten years ago, how it is today and how it might be tomorrow.

17
00:01:20,266 --> 00:01:24,046
From there we'll dive into react server components themselves and we'll implement server

18
00:01:24,078 --> 00:01:27,858
components from scratch. From first principles we'll follow the guide that

19
00:01:27,864 --> 00:01:31,218
Dan Abramov wrote on GitHub. There's a link to that under the like button.

20
00:01:31,384 --> 00:01:35,518
Once we identify that, we look at some more architecture diagrams of how data flows.

21
00:01:35,694 --> 00:01:38,374
Well, we'll look at them. I mean we'll just examine them, we'll discuss them,

22
00:01:38,412 --> 00:01:41,734
we'll verbally look at them, we'll talk a little bit about how they work

23
00:01:41,772 --> 00:01:45,606
in terms of data flow and we'll ask the question is server components for

24
00:01:45,628 --> 00:01:50,070
everybody? Finally, we'll talk about how you can increase your adaptability,

25
00:01:50,150 --> 00:01:53,626
as it were, of server components, making sure you're in a good spot to make

26
00:01:53,648 --> 00:01:57,082
the shift if and when you choose. And finally, we'll highlight some

27
00:01:57,136 --> 00:01:59,926
community notes. This is going to be a really fun session and I'm really excited

28
00:01:59,958 --> 00:02:03,582
about it. But before we get started, I want to emphasize that this

29
00:02:03,636 --> 00:02:07,134
video and this channel is separate to my consultancy work and is really just

30
00:02:07,172 --> 00:02:10,346
part of my willingness and joy and effort in spreading knowledge

31
00:02:10,378 --> 00:02:13,458
to developer communities and helping us do our best work. And in keeping with that,

32
00:02:13,464 --> 00:02:16,402
I'd like to thank the sponsor of this video that makes all this possible.

33
00:02:16,536 --> 00:02:20,094
That sponsor is Crabnebula Dev. Crab Nebula

34
00:02:20,142 --> 00:02:23,926
is a great platform that deploys. Their mission is

35
00:02:23,948 --> 00:02:28,194
to make shipping, distributing and packaging applications

36
00:02:28,242 --> 00:02:32,018
securely and instantly worldwide, much like how versel

37
00:02:32,114 --> 00:02:35,586
has this git push and then your website is instantly live everywhere.

38
00:02:35,698 --> 00:02:39,066
Crab Nebula's platform aims to offer something similar where you get push and

39
00:02:39,088 --> 00:02:42,214
your native or mobile application is everywhere. Native desktop

40
00:02:42,262 --> 00:02:45,674
or mobile is everywhere instantly. This is from the team

41
00:02:45,712 --> 00:02:48,906
that built the towery project and I'm very excited about the project. So if you

42
00:02:48,928 --> 00:02:51,534
are interested as well, I'd encourage you. There's a link under the like button.

43
00:02:51,572 --> 00:02:55,310
Crabnebula Dev is who they are and what they're after. With that,

44
00:02:55,380 --> 00:02:58,526
let's get into server components. Let's talk about server components, and I want to talk

45
00:02:58,548 --> 00:03:02,386
about it by asking you a question. What is react to you?

46
00:03:02,408 --> 00:03:05,460
Like when I say react, what comes to your mind?

47
00:03:05,910 --> 00:03:09,378
It could be multiple things. A UI for building sorry, a library for

48
00:03:09,384 --> 00:03:12,914
building user interfaces. A framework for building many things. In fact,

49
00:03:12,952 --> 00:03:16,438
in the previous video where we built a makeshift next js from scratch, if you

50
00:03:16,444 --> 00:03:19,842
missed that, I'll leave a link up there. We identified some of this terminology,

51
00:03:19,906 --> 00:03:23,686
library framework, et cetera, and disambiguated a little bit. The thing

52
00:03:23,708 --> 00:03:27,398
about react is it's multiple things. It is a library, but above

53
00:03:27,414 --> 00:03:30,700
and beyond library, it's an architecture as well.

54
00:03:31,230 --> 00:03:34,634
And follow me a little bit, because react, when it started ten years

55
00:03:34,672 --> 00:03:38,154
ago, introduced JSX and with JSX

56
00:03:38,202 --> 00:03:42,058
introduced a way of shipping and building user interfaces.

57
00:03:42,154 --> 00:03:46,014
The formula view equals function of state and really

58
00:03:46,052 --> 00:03:50,026
championing what was called the flux architecture of one way data flow. Data starts

59
00:03:50,058 --> 00:03:53,518
at the top and kind of makes its way down. In that way. You can

60
00:03:53,524 --> 00:03:56,558
think of react as an architecture or a take on an architecture.

61
00:03:56,574 --> 00:04:00,306
That is the flux architecture. You can also think of react as an architecture in

62
00:04:00,328 --> 00:04:03,554
terms of the tooling that was in and around react at the time

63
00:04:03,592 --> 00:04:07,286
that wasn't widely used before React. Frankly, we did use gulp and

64
00:04:07,308 --> 00:04:11,346
grunt and things to bundle, but we never really had to use transpilers

65
00:04:11,378 --> 00:04:15,346
mainstream. But with the advent of JSX, we ended

66
00:04:15,378 --> 00:04:19,082
up adding more tools to our chain. Those tools, of course,

67
00:04:19,136 --> 00:04:22,854
were not as well developed as they are today because they weren't as widely

68
00:04:22,902 --> 00:04:26,262
used and it required some assembly,

69
00:04:26,326 --> 00:04:30,074
some assembly required. I remember myself writing a few webpack configs by

70
00:04:30,112 --> 00:04:33,638
hand and learning the difference between things like Babel, preset, envelope,

71
00:04:33,654 --> 00:04:37,414
preset, react, et cetera. I'm sure many of you have that also context,

72
00:04:37,462 --> 00:04:40,818
and if you do, let me know in the comments. But architecturally, there was a

73
00:04:40,824 --> 00:04:43,778
lot of stuff going on, a lot of tools that needed to be assembled the

74
00:04:43,784 --> 00:04:46,478
right way so you could do react. And this was one of the early criticisms,

75
00:04:46,494 --> 00:04:49,682
and to this day is some of the criticism. Right? A lot of the view

76
00:04:49,736 --> 00:04:52,994
community says you can just include view from a CDN over script tag.

77
00:04:53,042 --> 00:04:56,642
Boom, you have a view app, you don't need any tooling. So react

78
00:04:56,706 --> 00:05:00,390
does have architectural elements as well in terms of tooling.

79
00:05:00,890 --> 00:05:04,722
However, over time the tooling has matured

80
00:05:04,786 --> 00:05:08,218
so much that we forget it even exists today. I'm guilty of

81
00:05:08,224 --> 00:05:11,446
this myself. I'll create a basic client side react app and I'll

82
00:05:11,478 --> 00:05:14,634
do something like NPX vite and it

83
00:05:14,672 --> 00:05:18,026
will just work. And that's amazing. But I

84
00:05:18,048 --> 00:05:21,358
often don't recognize it as amazing and just take it for granted. Right? But the

85
00:05:21,364 --> 00:05:25,034
tooling has matured for client side and potentially server

86
00:05:25,082 --> 00:05:28,826
side react. And this is important as we dive into server

87
00:05:28,858 --> 00:05:32,386
components. So react ten years ago, had NPM install, you'd have to do

88
00:05:32,408 --> 00:05:35,358
react React Dom, but also Babel webpack,

89
00:05:35,454 --> 00:05:38,174
webpack plugin, Babel Babel plugin,

90
00:05:38,222 --> 00:05:41,726
React Babel preset, and we had to do all these things. And today it's NPM

91
00:05:41,758 --> 00:05:45,094
install react NPxvit done. And tomorrow it might be

92
00:05:45,212 --> 00:05:48,386
NPM install react React Dom next. And that's

93
00:05:48,418 --> 00:05:52,198
it. And next, the framework would handle this for you, including adding typescript and

94
00:05:52,204 --> 00:05:55,634
things as you need. So that's where we were,

95
00:05:55,692 --> 00:05:58,700
that's where we are, and that's where we're going. However,

96
00:05:59,230 --> 00:06:03,366
react server components introduces a whole new wave of tooling, next generation tooling

97
00:06:03,398 --> 00:06:06,618
that doesn't even exist in our session together, we're going

98
00:06:06,624 --> 00:06:10,526
to talk about why and how it does that and where we might be once

99
00:06:10,548 --> 00:06:13,806
the tooling catches up. But before we get into that, I want to quickly talk

100
00:06:13,828 --> 00:06:17,550
about what even is react server components or RSC.

101
00:06:18,210 --> 00:06:21,374
And just like we've talked about what React is, it is indeed a library.

102
00:06:21,422 --> 00:06:23,860
React server components is multiple things.

103
00:06:24,310 --> 00:06:28,446
Some would say that it's basically the react team's shipping suspense

104
00:06:28,478 --> 00:06:31,698
for data fetching. Really. I think it

105
00:06:31,704 --> 00:06:34,798
is that it is also a way to execute, I mean, mechanistically,

106
00:06:34,894 --> 00:06:38,754
react server components is a way to execute components on the server

107
00:06:38,882 --> 00:06:42,278
and on the client, but specifically the server, and then send the output of

108
00:06:42,284 --> 00:06:45,746
those components to the client and let the client do its job. The benefit

109
00:06:45,778 --> 00:06:49,338
of this, of course, is smaller bundle sizes, better data fetching, et cetera. We'll get

110
00:06:49,344 --> 00:06:52,698
into that, but it is that for sure. Above and beyond that, I think

111
00:06:52,704 --> 00:06:56,166
react server components, just like React, is an architecture.

112
00:06:56,358 --> 00:07:00,682
It is an architecture. It's a way of rendering and orchestrating

113
00:07:00,746 --> 00:07:04,494
applications and servers. And I do mean servers plural. We'll get into that

114
00:07:04,532 --> 00:07:08,510
such that your applications are performant and have better user experience.

115
00:07:08,660 --> 00:07:12,778
If we could write a long sentence about what react server components

116
00:07:12,794 --> 00:07:16,702
are, we would say react server components is an architecture

117
00:07:16,846 --> 00:07:20,926
built on next generation tooling that is still experimental

118
00:07:20,958 --> 00:07:24,594
and not yet production ready. That requires rethinking.

119
00:07:24,642 --> 00:07:28,198
React to go from client first to

120
00:07:28,284 --> 00:07:31,654
hybrid or server first, depending on who you ask.

121
00:07:31,772 --> 00:07:35,314
That includes the server at every level of the virtual

122
00:07:35,362 --> 00:07:39,078
DoM, so it's not currently as in before react server

123
00:07:39,094 --> 00:07:42,298
components, you could server render a page, but then all the components in

124
00:07:42,304 --> 00:07:46,106
the page are still client components. But with server components you can server render just

125
00:07:46,128 --> 00:07:49,340
like a single element, a card, a blog post,

126
00:07:49,710 --> 00:07:52,714
while the rest, maybe its parent, could be a client, et cetera.

127
00:07:52,762 --> 00:07:56,062
So you can really include the server where and when you need. For example,

128
00:07:56,116 --> 00:07:59,454
if you have a bulky thing like a date formatter or a

129
00:07:59,492 --> 00:08:02,878
markdown for something like that, you could then turn that into a server

130
00:08:02,894 --> 00:08:06,110
component. Again, we'll look at practically how we do that in a minute.

131
00:08:06,270 --> 00:08:09,422
So that includes the server at every level of the Dom.

132
00:08:09,486 --> 00:08:12,914
That unlocks tremendous benefits of which we'll explore.

133
00:08:12,962 --> 00:08:17,234
And finally, tremendous benefits for data fetching performance

134
00:08:17,362 --> 00:08:20,790
user experience. Data fetching performance user experience.

135
00:08:20,860 --> 00:08:24,498
So that's the sentence. I'll say it one more time. React Server components is

136
00:08:24,524 --> 00:08:27,834
an architecture built on next generation tooling that is

137
00:08:27,872 --> 00:08:31,206
still experimental and not production ready that requires rethinking.

138
00:08:31,238 --> 00:08:35,238
React that includes the server at every level of virtual Dom

139
00:08:35,414 --> 00:08:39,520
unlocking. Tremendous benefits for data fetching performance and user experience.

140
00:08:40,050 --> 00:08:44,234
Now I've reached the point in the video where I kind of realize,

141
00:08:44,282 --> 00:08:48,010
okay, I am talking too much and I'm starting to get bored. So let's

142
00:08:48,170 --> 00:08:51,406
create something with react server components together and then we'll

143
00:08:51,438 --> 00:08:54,738
talk about what we did and recap from there. To do that, we're going to

144
00:08:54,744 --> 00:08:58,450
go over to the computer. I've got this application

145
00:08:58,600 --> 00:09:01,938
called my dog site and you can see there's a

146
00:09:01,944 --> 00:09:05,254
list of dog breeds. If you've been part of the channel

147
00:09:05,292 --> 00:09:08,646
for any amount of time, this shouldn't surprise you. I really

148
00:09:08,668 --> 00:09:12,322
like these dog breed apps. What we have is a rotating doggo.

149
00:09:12,386 --> 00:09:15,670
Here we have a field for your name

150
00:09:15,820 --> 00:09:19,482
and we have server time. Okay, I don't know why I just did that.

151
00:09:19,616 --> 00:09:22,954
And indeed it navigates. So when you click on briard, you go

152
00:09:22,992 --> 00:09:26,346
see the briard. This once again is just a client app.

153
00:09:26,368 --> 00:09:30,106
So we're running NPX VT in case you're wondering. And if we

154
00:09:30,128 --> 00:09:33,358
look at the source code, we'll understand how it works. But what I want to

155
00:09:33,364 --> 00:09:37,626
highlight here is the navigation. There is no client router. The navigation is fully

156
00:09:37,738 --> 00:09:41,166
like multi page application style. So we're actually doing a full page reload every time.

157
00:09:41,188 --> 00:09:44,866
And you can tell by my state here being blown away tagis. And if

158
00:09:44,888 --> 00:09:48,194
I change the page, it goes away. And also this

159
00:09:48,232 --> 00:09:51,874
thing, as I navigate, resets its animation. So if I click here,

160
00:09:51,912 --> 00:09:55,334
it jumps. You see that it doesn't keep

161
00:09:55,372 --> 00:09:58,550
going in a smooth circle. That's kind of annoying. Okay,

162
00:09:58,700 --> 00:10:02,294
so let's look at the code now. So we have an

163
00:10:02,332 --> 00:10:06,006
index TSX. And what we're doing here is we

164
00:10:06,028 --> 00:10:09,242
get the breed and we communicate breed over search

165
00:10:09,296 --> 00:10:12,714
params. So that's why we get the breed and we hydrate the document with

166
00:10:12,752 --> 00:10:16,634
the layout. And we have a little basic router, meaning if the path matches list,

167
00:10:16,672 --> 00:10:19,678
we show list. Otherwise we show the detail page. Okay. And we pass in the

168
00:10:19,684 --> 00:10:22,874
breed. That's what's happening here. Let's look at our layout component.

169
00:10:23,002 --> 00:10:26,958
Our layout component is exactly what you'd expect. It's a layout. It has HTML head,

170
00:10:27,044 --> 00:10:30,926
everything here. It has our little doggo has the

171
00:10:30,948 --> 00:10:34,786
title with a link back to the root and input, and so on

172
00:10:34,888 --> 00:10:38,930
little date here. Let's go look at the list component.

173
00:10:39,430 --> 00:10:42,482
The list has some use state. So all of these are held in state.

174
00:10:42,536 --> 00:10:45,746
The breeds and the images you kind of see in the background are held in

175
00:10:45,768 --> 00:10:49,426
state. We fetch. Let me just give you some more space here.

176
00:10:49,448 --> 00:10:53,674
We fetch the dog API's list and

177
00:10:53,752 --> 00:10:56,886
then we get it. And this is the array.

178
00:10:56,918 --> 00:10:59,382
This is the array of breeds. But once we have the array of breeds,

179
00:10:59,526 --> 00:11:02,870
remove that. Once we have the array of breeds,

180
00:11:02,950 --> 00:11:06,826
we then also get an array of images per breed. And we return both

181
00:11:06,848 --> 00:11:10,958
of them breeds and images, and then we set them. Okay, it's a very long,

182
00:11:11,044 --> 00:11:14,846
very maybe inefficient way to do it, but here we are. And then

183
00:11:14,868 --> 00:11:19,450
we have some markup. So welcome to my dog site, P and Uls.

184
00:11:19,610 --> 00:11:23,314
Similarly, if we go into the detail page, what we'll see

185
00:11:23,352 --> 00:11:27,198
is, let's go to detail. It's similar. So we get the image.

186
00:11:27,374 --> 00:11:31,118
Adorable. We get the image and then set the image

187
00:11:31,134 --> 00:11:34,338
and so on. Okay, so there's of course some problems

188
00:11:34,424 --> 00:11:37,894
with this. For example, we are fetching only

189
00:11:37,932 --> 00:11:40,406
on the client side. Not only are we fetching only on the client side,

190
00:11:40,428 --> 00:11:44,454
we're rendering only on the client side. So if I come back here

191
00:11:44,652 --> 00:11:47,574
and view source, there's nothing,

192
00:11:47,692 --> 00:11:51,450
right? So we're fetching and rendering on the client side. And this isn't

193
00:11:51,870 --> 00:11:55,286
really ideal for search engine optimism, et cetera. We talked about this in the previous

194
00:11:55,318 --> 00:11:58,666
video on nextjs, and where we made a makeshift nextjs from scratch. I'll put

195
00:11:58,688 --> 00:12:02,094
a link at the top if you missed it. But step one,

196
00:12:02,132 --> 00:12:05,760
let's maybe add a server. Again, we're not going to do the whole deal,

197
00:12:06,610 --> 00:12:09,786
but we do need to benefit from a little bit of server rendering. So let's

198
00:12:09,818 --> 00:12:13,554
start wet our toes a little bit by adding a server. And then we'll add

199
00:12:13,592 --> 00:12:16,862
server components to the server. So if you've

200
00:12:16,926 --> 00:12:19,966
been around for the last video to add a server, we have server TSX.

201
00:12:19,998 --> 00:12:24,194
It's an empty file. We will import react from react.

202
00:12:24,322 --> 00:12:27,906
We'll import exprs from Exprs,

203
00:12:28,098 --> 00:12:31,606
we'll import render to string. We're using render to string just

204
00:12:31,628 --> 00:12:35,682
for simplicity you should be using something stream based. And then we'll

205
00:12:35,746 --> 00:12:39,354
start our, start our application. So we'll say const app is

206
00:12:39,392 --> 00:12:42,858
exprs and we'll listen to the public.

207
00:12:42,944 --> 00:12:46,374
We'll use the disk directory to get static

208
00:12:46,422 --> 00:12:50,318
assets. This is like things like CSS and images and stuff. Then we'll get

209
00:12:50,404 --> 00:12:54,394
on the root but we'll call it path here. And lastly

210
00:12:54,442 --> 00:12:58,480
we'll listen on port 3000 and we'll say

211
00:12:59,650 --> 00:13:03,194
server is listening on port 3000. Fantastic. Okay, so now we need to

212
00:13:03,252 --> 00:13:06,754
dynamically load, we need path based routing. And this is something, again this is something

213
00:13:06,792 --> 00:13:09,938
we did in the last video on Nextjs. The link will

214
00:13:09,944 --> 00:13:13,266
be in the description and I've put it up there a few times,

215
00:13:13,448 --> 00:13:16,806
path based routing. Let's go. So what we're going to do is we

216
00:13:16,828 --> 00:13:20,466
have two pages detail and list and they come along the query

217
00:13:20,498 --> 00:13:23,590
parameter path. So we'll turn this into an async function.

218
00:13:23,740 --> 00:13:27,466
And what we'll do is we'll say const page is

219
00:13:27,568 --> 00:13:30,794
we'll do a dynamic import and

220
00:13:30,832 --> 00:13:34,278
we'll join, I need to import join, don't I join?

221
00:13:34,454 --> 00:13:38,026
We'll join the current working directory with disk

222
00:13:38,138 --> 00:13:41,726
pages and the path just like that.

223
00:13:41,828 --> 00:13:45,086
And then when we have it we'll say const components is

224
00:13:45,268 --> 00:13:48,800
the default export. And we'll say the,

225
00:13:49,970 --> 00:13:53,586
we can just say the HTML is we render the layout and

226
00:13:53,608 --> 00:13:56,974
the component and we'll res end with the HTML.

227
00:13:57,022 --> 00:14:00,562
This should give us what we want, I think. Of course

228
00:14:00,616 --> 00:14:04,166
we also can do props. So let's just wrap props in the rec

229
00:14:04,268 --> 00:14:08,146
query save. So now we are server rendering

230
00:14:08,178 --> 00:14:11,734
a little bit also with path based stuff. Let's see what

231
00:14:11,772 --> 00:14:15,960
happens. So if we come here we'll NPM run

232
00:14:16,810 --> 00:14:19,320
build. If I can type,

233
00:14:20,030 --> 00:14:23,990
we'll start that server and it should start. And now let's go visit localhost

234
00:14:24,070 --> 00:14:26,620
3000 list.

235
00:14:27,150 --> 00:14:30,526
Great, it works. But we're not fetching data and that's because we don't

236
00:14:30,548 --> 00:14:34,398
have react on the client side. So we can easily fix that by

237
00:14:34,564 --> 00:14:38,926
adding maybe here script sources client and

238
00:14:38,948 --> 00:14:42,322
we'll rebuild the server. Okay, cool, it works.

239
00:14:42,376 --> 00:14:46,354
We have server rendering. But once again we have server rendering without

240
00:14:46,472 --> 00:14:49,714
data and notice the state is still

241
00:14:49,832 --> 00:14:53,426
blown away. So if I go here, yeah, it's not really good.

242
00:14:53,528 --> 00:14:57,234
Also we have some server rendering. For example, we have RSC

243
00:14:57,282 --> 00:15:01,302
thingy and stuff, but we don't have the list of dog breeds, we don't have

244
00:15:01,356 --> 00:15:04,806
the data. So our server rendering is a bit of a waste. Okay, now this

245
00:15:04,828 --> 00:15:08,230
is where in the last video we did some nextjs stuff with get serverside props.

246
00:15:08,310 --> 00:15:11,674
This is our opportunity to refactor this, to use server components and

247
00:15:11,712 --> 00:15:15,514
turn our components into async components. Okay, so let's do that

248
00:15:15,552 --> 00:15:18,746
now. So if we go to list, let's start

249
00:15:18,768 --> 00:15:22,782
with list. It would be great if we remove all this nonsense and just

250
00:15:22,836 --> 00:15:26,718
turn it into a nice async component and fetch. So let's get rid of this

251
00:15:26,804 --> 00:15:30,350
and we'll say const breeds is

252
00:15:30,420 --> 00:15:34,020
we just want this up to here. That's it. And then we can say

253
00:15:35,030 --> 00:15:38,338
const images is this right? And we

254
00:15:38,344 --> 00:15:42,710
can get rid of all of this noise. We need to close this bracket.

255
00:15:43,370 --> 00:15:46,934
Promise. All breeds map. This looks good.

256
00:15:46,972 --> 00:15:50,642
I don't know why you're complaining. What we need to await.

257
00:15:50,706 --> 00:15:54,434
Nice. I love typescript. Okay, so look at that. We simplified

258
00:15:54,482 --> 00:15:57,850
it a lot. And best of all, look at me. Best of all,

259
00:15:57,920 --> 00:16:01,162
watch this. We can do this. Amazing.

260
00:16:01,296 --> 00:16:04,874
Okay, so now we have an async component and logically it

261
00:16:04,912 --> 00:16:08,378
should work. Let's try, this is, by the way, a server components. This is a

262
00:16:08,384 --> 00:16:12,110
server component, an async component that can do cool data fetching stuff that you trust

263
00:16:12,180 --> 00:16:15,578
because it's on the server. Okay, but let's see if it'll run. So we'll

264
00:16:15,594 --> 00:16:18,926
save this, go here, kill our server, restart our

265
00:16:18,948 --> 00:16:22,494
server and everything and. Okay, we have a typescript

266
00:16:22,542 --> 00:16:26,078
issue because it doesn't know that components

267
00:16:26,094 --> 00:16:29,698
can be async. That's fine, we'll just say this is any for now, not a

268
00:16:29,704 --> 00:16:33,886
big deal. Okay, let's go back, reload and a

269
00:16:33,928 --> 00:16:37,394
massive crash. Because look at the error. Objects are not valid

270
00:16:37,442 --> 00:16:40,566
as a react child found object, promise. What it

271
00:16:40,588 --> 00:16:44,134
needs is a react element. So we need some way to

272
00:16:44,172 --> 00:16:47,962
turn objects and promises into what react recognizes as

273
00:16:48,016 --> 00:16:52,618
elements. How do we do that? Well, react has a special

274
00:16:52,704 --> 00:16:56,394
indicator on its elements, dollar, dollar type of, and its value is a symbol for

275
00:16:56,432 --> 00:16:58,874
react element. This is how it knows it's an element. So we need to take

276
00:16:58,912 --> 00:17:02,686
this promise somehow, await it, turn it into a react element and send

277
00:17:02,708 --> 00:17:05,440
it to the client. This is what server components do.

278
00:17:06,450 --> 00:17:09,134
A lot of people say they send HTML to the client. They don't do that.

279
00:17:09,172 --> 00:17:12,846
They send react elements, literally javascript objects, react elements to the

280
00:17:12,868 --> 00:17:16,126
client and then react on the client side can work with it. That's how server

281
00:17:16,158 --> 00:17:19,426
components work. You need to pay attention to that. So how do we go about

282
00:17:19,448 --> 00:17:23,078
this? How do we go about converting this promise and other things into

283
00:17:23,164 --> 00:17:26,178
react elements that we can then send over the wire,

284
00:17:26,274 --> 00:17:30,674
aka server components? Well, we need to start by transforming

285
00:17:30,722 --> 00:17:33,542
JSX into this tree. Okay,

286
00:17:33,596 --> 00:17:36,906
so let's do that through some functions. So if we come back to the code,

287
00:17:37,088 --> 00:17:41,482
what we're going to need on the server side is some type of function called

288
00:17:41,536 --> 00:17:46,010
like const, turn JSX into client

289
00:17:46,510 --> 00:17:50,134
object and we get JSX.

290
00:17:50,262 --> 00:17:54,320
And here we need to process this JSX somehow. We need to handle it.

291
00:17:55,090 --> 00:17:58,334
And JSX can be many things. What do I mean by JSX? I mean this.

292
00:17:58,372 --> 00:18:01,726
So it's an element here it's text here it could be

293
00:18:01,748 --> 00:18:05,106
a number, et cetera. So we need to basically just do a massive like if

294
00:18:05,208 --> 00:18:08,690
or switch and handle the different things JSX can be and process

295
00:18:08,760 --> 00:18:12,114
them. Okay, so let's do that. So what we're going to do is we'll start

296
00:18:12,152 --> 00:18:15,986
simple. If it doesn't exist, we'll return null, which is a valid react element

297
00:18:16,018 --> 00:18:19,090
type or a thing that react understands.

298
00:18:19,170 --> 00:18:23,174
If it's a string or a number or

299
00:18:23,212 --> 00:18:27,170
a boolean includes

300
00:18:27,250 --> 00:18:29,866
type of JSX, then we just return it as it is.

301
00:18:29,968 --> 00:18:33,686
Great. If it's an array, good. Thank you copilot,

302
00:18:33,798 --> 00:18:36,906
we'll return that. But we want this to be async because we want to await

303
00:18:36,938 --> 00:18:40,346
those things. So we'll just await promise

304
00:18:40,458 --> 00:18:43,758
all instead. Okay, this is good.

305
00:18:43,844 --> 00:18:47,840
Next if it's an object.

306
00:18:48,530 --> 00:18:52,126
Now it gets interesting because all react elements are objects, but not

307
00:18:52,148 --> 00:18:54,866
all objects are react elements. So how can we make sure that this is not

308
00:18:54,888 --> 00:18:58,034
just an object but an object that is a react element? We check the type

309
00:18:58,072 --> 00:19:02,510
off property. So if JSX

310
00:19:02,670 --> 00:19:06,366
dollar dollar typeoff equals the symbol

311
00:19:06,558 --> 00:19:10,454
for react element, then we

312
00:19:10,492 --> 00:19:13,926
need to do some things. Now a react element looks

313
00:19:13,948 --> 00:19:17,482
like this. So you have tag or type, which is either

314
00:19:17,536 --> 00:19:20,940
a div, you have props and you have children.

315
00:19:22,830 --> 00:19:26,662
If this is hard to grok, there's a video on YouTube of me teaching react

316
00:19:26,726 --> 00:19:30,186
from first principles called deconstructing react. I'll put a link up there and under

317
00:19:30,208 --> 00:19:33,754
the like button. But this is basically what your JSX becomes. It becomes

318
00:19:33,802 --> 00:19:37,214
type props, children. The thing is, type could be a string if it's a built

319
00:19:37,252 --> 00:19:41,114
in components like a div, or it could be someone else's

320
00:19:41,162 --> 00:19:44,978
react component like this, right? So you don't know what it

321
00:19:44,984 --> 00:19:47,794
is. And we need to account for both cases where type is a string and

322
00:19:47,832 --> 00:19:51,642
where type is a function. So we'll do that. So we'll say if JSX

323
00:19:51,726 --> 00:19:55,046
type is a string, that's actually not how we

324
00:19:55,068 --> 00:19:59,058
do that. We do type of string,

325
00:19:59,234 --> 00:20:02,920
then we do something. And also if it's a function,

326
00:20:03,370 --> 00:20:07,026
we do something else function. So let's

327
00:20:07,058 --> 00:20:09,818
handle the string case first. If it's a string case, we just need to return

328
00:20:09,984 --> 00:20:13,594
whatever it is, but also work with its props. Specifically, we need to

329
00:20:13,632 --> 00:20:16,986
process its props because its props might be children. So we need to

330
00:20:17,008 --> 00:20:20,474
turn those also into a client

331
00:20:20,522 --> 00:20:23,518
object. So that's done. Now we handle the function case.

332
00:20:23,684 --> 00:20:26,794
If it's a function, we get its JS. Like all react

333
00:20:26,842 --> 00:20:30,542
components that are functions like this return more JSX.

334
00:20:30,606 --> 00:20:33,700
So we need this stuff. We need the JSX. So we'll say const

335
00:20:34,390 --> 00:20:38,050
components is the type, is the function.

336
00:20:38,200 --> 00:20:41,598
And we have props, of course, is JSX props.

337
00:20:41,694 --> 00:20:45,094
We say const rendered thing is,

338
00:20:45,132 --> 00:20:48,646
we just call component with props. Now keep in mind, components can

339
00:20:48,668 --> 00:20:51,654
be async, remember? So we'll await that.

340
00:20:51,852 --> 00:20:55,222
And what do we return? We further recursively

341
00:20:55,286 --> 00:20:59,306
process those things. So rendered thing.

342
00:20:59,408 --> 00:21:02,806
We're just like recursively processing all these things until they're

343
00:21:02,838 --> 00:21:06,374
objects. We're going all the way down. Okay, fantastic.

344
00:21:06,502 --> 00:21:09,914
Lastly, if we're just doing this on props, and the

345
00:21:09,952 --> 00:21:13,486
props are not JSX, we need to handle that case as well. In this case,

346
00:21:13,508 --> 00:21:17,134
props are always an object. So if it's still an object, we'll come here

347
00:21:17,252 --> 00:21:20,462
and we'll say the keys. Well, we don't want keys, we want entries.

348
00:21:20,526 --> 00:21:24,514
Really, we want entries. And what we'll do is

349
00:21:24,632 --> 00:21:28,130
we'll say const processed

350
00:21:28,630 --> 00:21:32,802
entries is entries map.

351
00:21:32,866 --> 00:21:36,694
And we get here prop and value. And we'll just return

352
00:21:36,892 --> 00:21:39,670
prop and await.

353
00:21:40,890 --> 00:21:44,326
Exactly. And we'll process the value. Now, we can't await because this is not

354
00:21:44,348 --> 00:21:47,638
async. So we'll turn this into an async, turn this into an async

355
00:21:47,654 --> 00:21:51,770
function here. But now this needs to be promise Ald

356
00:21:53,230 --> 00:21:55,290
and it needs to be awaited.

357
00:21:56,350 --> 00:22:00,018
And lastly we can return object from entry.

358
00:22:00,054 --> 00:22:03,822
So we're just getting back an object again of processed entries. This looks good.

359
00:22:03,876 --> 00:22:07,834
So we have this thing that takes a bunch of JSX

360
00:22:07,882 --> 00:22:11,342
like this and turns it into a big react

361
00:22:11,486 --> 00:22:15,438
Javascript object. It's fully serialized, except functions

362
00:22:15,454 --> 00:22:18,546
aren't serializable. Maybe you won't get to that in this video, maybe the

363
00:22:18,568 --> 00:22:21,826
next one. But we've serialized into a big object and

364
00:22:21,848 --> 00:22:25,442
now if we send that object from the server to the client, then react

365
00:22:25,506 --> 00:22:28,966
can probably render it and do its job. Let's try.

366
00:22:29,148 --> 00:22:32,774
One thing to note is that client in the context of server components means

367
00:22:32,812 --> 00:22:36,166
anything that can consume the server component's output. That is the big

368
00:22:36,188 --> 00:22:39,526
JSX tree. You know what else can consume the server component's output outside of react

369
00:22:39,558 --> 00:22:42,874
on the client side, react on the server side, it can take this

370
00:22:42,912 --> 00:22:46,490
big JSX tree that we've made and turn it into

371
00:22:46,560 --> 00:22:49,982
HTML. So let's do that. But first let's see what we just did.

372
00:22:50,036 --> 00:22:53,902
So what I want to do is instead of render to string, we'll say

373
00:22:53,956 --> 00:22:57,610
const client JSX and we'll await

374
00:22:57,690 --> 00:23:01,522
turn JSX into client object and we'll just copy this into

375
00:23:01,576 --> 00:23:05,326
that instead. And we'll render

376
00:23:05,358 --> 00:23:09,330
this to string. But I want to also see, let's just

377
00:23:09,400 --> 00:23:13,234
for fun show what we serialized. So we'll do

378
00:23:13,272 --> 00:23:16,614
this and we'll run the server again. Hopefully it works

379
00:23:16,812 --> 00:23:19,894
good. And we'll go to port 3000 and what we'll see

380
00:23:19,932 --> 00:23:23,398
is this is what we get, a big tree. Let's look at the raw data.

381
00:23:23,484 --> 00:23:27,306
So it's just a big thing where it's type HTML, it's just a

382
00:23:27,328 --> 00:23:30,394
bunch of react. So yeah,

383
00:23:30,432 --> 00:23:34,122
it's just like a bunch of elements. So HTML has children,

384
00:23:34,176 --> 00:23:37,638
head, meta, et cetera, and then body. So it's

385
00:23:37,654 --> 00:23:40,910
just a big thing with type, props, et cetera. Just a big object.

386
00:23:40,980 --> 00:23:44,746
Okay, so anyway, let's come back here and take this object and under

387
00:23:44,778 --> 00:23:48,830
it to a string and then serve the client the string that this object

388
00:23:48,900 --> 00:23:52,530
becomes. So we'll kill the server again, restart it,

389
00:23:52,680 --> 00:23:55,774
and it's instantly replaced,

390
00:23:55,902 --> 00:23:58,866
notice. And that's because we're using react on the client side. So if we get

391
00:23:58,888 --> 00:24:02,726
rid of this for now, we'll restart the

392
00:24:02,748 --> 00:24:05,974
server and we should have, there we go.

393
00:24:06,012 --> 00:24:09,622
We have server rendered server components because

394
00:24:09,756 --> 00:24:13,506
the server consumes the RSCs and gives you output.

395
00:24:13,538 --> 00:24:16,806
So this is great. We have working server components. Does it

396
00:24:16,828 --> 00:24:20,602
work on the sub page? It doesn't. Probably for the same reason

397
00:24:20,736 --> 00:24:23,946
we need to go and update breed the detail page

398
00:24:23,968 --> 00:24:27,910
as well. So instead of all of this we'll say equals await.

399
00:24:28,070 --> 00:24:31,322
Say image URL alone equals await fetch.

400
00:24:31,466 --> 00:24:34,842
This looks good. And instead of calling set image URL,

401
00:24:34,986 --> 00:24:38,670
we'll just return this. Perfect. And again we can get rid of use effect,

402
00:24:38,740 --> 00:24:42,066
which is always nice. Okay, perfect. That's it. And this

403
00:24:42,088 --> 00:24:45,262
is async and we need to tell typescript not to worry.

404
00:24:45,406 --> 00:24:49,362
Okay, do this again. So now the detail page

405
00:24:49,416 --> 00:24:52,734
is also server rendered with server components and we can navigate.

406
00:24:52,862 --> 00:24:56,806
This is pretty nice. So we have it,

407
00:24:56,908 --> 00:24:59,878
but we don't have react on the client side. And it kind of defeats the

408
00:24:59,884 --> 00:25:04,242
point of react because what react does is it helps you persist

409
00:25:04,306 --> 00:25:08,390
state across things. It helps you have single page application like behavior.

410
00:25:08,470 --> 00:25:12,106
What I mean by that is this. Have a look. So if we come here

411
00:25:12,208 --> 00:25:15,878
and we enter some state, my name is Tejas, this is also spinning.

412
00:25:16,054 --> 00:25:20,174
If I navigate, I shouldn't lose that state. It should

413
00:25:20,212 --> 00:25:24,350
feel like a cohesive app experience. I think we can amplify this further by

414
00:25:24,420 --> 00:25:28,542
changing the background color. So we'll say the background color if the rec

415
00:25:28,596 --> 00:25:32,706
param path is list is white, otherwise the

416
00:25:32,728 --> 00:25:35,986
background color is black. Right. It should be a

417
00:25:36,008 --> 00:25:39,710
smooth transition. It shouldn't just jump

418
00:25:39,870 --> 00:25:43,202
like a legacy old website. So look, yuck.

419
00:25:43,266 --> 00:25:47,142
That's very abrupt. And also my state goes

420
00:25:47,196 --> 00:25:50,280
away. Not good. We can solve this

421
00:25:50,650 --> 00:25:54,134
using react on the client side. That's literally react on the client side's job.

422
00:25:54,172 --> 00:25:57,174
That's what we've used react for, for, I was going to say millions of years,

423
00:25:57,212 --> 00:26:00,426
but for the last ten years. So we need react on the client side.

424
00:26:00,608 --> 00:26:03,814
How do we do that? Well, we already have this RSC output, the server component

425
00:26:03,862 --> 00:26:07,434
output that the server side understands. We just need to get the client side to

426
00:26:07,472 --> 00:26:10,686
understand it. Let's look at how we do that. So if we look

427
00:26:10,708 --> 00:26:14,426
at our client side app calling hydrate root and we're using the components

428
00:26:14,458 --> 00:26:17,918
here, we need to use the RSC output here.

429
00:26:18,004 --> 00:26:21,230
So what we can do is we can fetch the RSC output,

430
00:26:21,390 --> 00:26:23,970
but that will introduce another network waterfall.

431
00:26:26,710 --> 00:26:30,190
Since we're already rendering the output here and including a script tag,

432
00:26:30,270 --> 00:26:34,166
let's include that script tag again. What we can do is just

433
00:26:34,268 --> 00:26:37,558
inline the RSC output, literally because we have it right.

434
00:26:37,644 --> 00:26:41,154
So we'll say we'll res end with HTML,

435
00:26:41,282 --> 00:26:45,206
but we'll also add script and we'll just inline

436
00:26:45,238 --> 00:26:49,130
the RSC output. So we'll say window RSC output

437
00:26:49,630 --> 00:26:53,770
is and we'll json stringify

438
00:26:54,110 --> 00:26:58,010
the client JSX look done.

439
00:26:58,160 --> 00:27:01,614
And while we're at it, we can also just load react just like

440
00:27:01,652 --> 00:27:05,178
this. Save. Did I change anything here? I don't

441
00:27:05,194 --> 00:27:09,186
think I did. Okay, save. Great, let's take a look. So I'll kill

442
00:27:09,208 --> 00:27:13,714
the server again, start it, reload. And it

443
00:27:13,752 --> 00:27:17,614
died. It died really badly because my network died.

444
00:27:17,662 --> 00:27:20,980
That's interesting. I'm being rate limited. Let's try this again.

445
00:27:21,430 --> 00:27:24,770
Okay, cool dog, Dusty. It was working, but our application crashes.

446
00:27:24,850 --> 00:27:28,790
And if we look at the console, lots of issues. Text content

447
00:27:28,860 --> 00:27:32,246
didn't match, objects are not. So it's the same thing.

448
00:27:32,428 --> 00:27:36,122
We found object promise, et cetera. It's just not really doing

449
00:27:36,176 --> 00:27:39,466
its job. And that's because we're not swapping the output here.

450
00:27:39,488 --> 00:27:43,098
So we'll do window dot since we're adding it on

451
00:27:43,104 --> 00:27:47,082
the server side, window RSC output instead

452
00:27:47,136 --> 00:27:50,750
of the components we import, and we can get rid of all the imports here.

453
00:27:50,900 --> 00:27:54,160
We can ts ignore this because we know it's there.

454
00:27:54,530 --> 00:27:57,230
Okay, so let's restart the server.

455
00:27:57,570 --> 00:28:01,246
Okay, so now we've gone from bad to worse, right? Because there's a lot

456
00:28:01,268 --> 00:28:04,306
failed to execute a pen child. Oh my gosh, oh my

457
00:28:04,328 --> 00:28:07,826
gosh, oh my gosh. There's just a lot of things going wrong. The reason for

458
00:28:07,848 --> 00:28:11,186
this is because what we're sending in the

459
00:28:11,208 --> 00:28:15,394
inline over the network isn't actually react elements

460
00:28:15,442 --> 00:28:19,094
anymore. Keep in mind, the identifier of something being a react element is

461
00:28:19,132 --> 00:28:22,386
the dollar dollar type of the symbol. But symbols don't

462
00:28:22,418 --> 00:28:26,354
go over the network when they're serialized. So in our JSON stringify

463
00:28:26,482 --> 00:28:29,986
off this tree, we need to somehow swap out the

464
00:28:30,028 --> 00:28:33,782
symbol for something the client can understand such that the client brings back the symbol.

465
00:28:33,846 --> 00:28:36,314
If this sounds a little bit weird, let's just write code, I'm sure it'll make

466
00:28:36,352 --> 00:28:40,320
sense. So what we'll do is we'll go back to the server, and instead of

467
00:28:40,770 --> 00:28:44,462
this JSon stringify, we need a function called

468
00:28:44,596 --> 00:28:47,886
Const sanitize JSON, and it gets the key and

469
00:28:47,908 --> 00:28:51,518
a value from the JSON object. And if the value is

470
00:28:51,684 --> 00:28:55,170
symbol four, this is the identifier of react elements.

471
00:28:56,150 --> 00:28:59,266
If it's that, notice we use that also here, right? So if

472
00:28:59,288 --> 00:29:02,286
it's a react element, we will return a new value, which is just the dollar

473
00:29:02,318 --> 00:29:05,654
sign. Otherwise we'll return and this could be anything. By the way, it doesn't matter

474
00:29:05,692 --> 00:29:09,506
otherwise we'll just return the value, sanitize JSon so we'll

475
00:29:09,698 --> 00:29:13,526
inline that instead. Similarly, on the client side, now we

476
00:29:13,548 --> 00:29:16,854
need to desanitize JSON or revive JSon.

477
00:29:16,902 --> 00:29:20,826
So we'll say revive JSON and if the value is

478
00:29:20,848 --> 00:29:25,034
the dollar sign we just basically do the other thing. We swap it and

479
00:29:25,072 --> 00:29:28,894
here we'll JSon parse the RSC output with

480
00:29:28,932 --> 00:29:31,982
the revive JSON function. Good.

481
00:29:32,116 --> 00:29:36,382
The second argument here just like swaps out values for other values, save that,

482
00:29:36,516 --> 00:29:40,318
restart the dev server and now there we

483
00:29:40,324 --> 00:29:43,922
go, we have it. We have react on the client side we have

484
00:29:43,976 --> 00:29:47,758
server components working, but unfortunately we're still blowing

485
00:29:47,774 --> 00:29:51,138
away the state. Look at this state and I click clumber and

486
00:29:51,144 --> 00:29:55,046
it goes away. It's not ideal. The final thing we

487
00:29:55,068 --> 00:29:58,566
have to do is override link clicks and

488
00:29:58,588 --> 00:30:01,826
use our own navigation client side navigation once client

489
00:30:01,858 --> 00:30:05,094
side react takes over and this will help persist the state and have a nice

490
00:30:05,132 --> 00:30:08,962
shared layout and give you a nice experience while also giving you multi page application

491
00:30:09,036 --> 00:30:12,186
performance. It gives you single page application user experience. Okay, how do

492
00:30:12,208 --> 00:30:15,318
we do that? This isn't going to take very long. Let's go. So what we're

493
00:30:15,334 --> 00:30:18,758
going to do is we will add an event listener

494
00:30:18,774 --> 00:30:22,430
on the window. This is react also does this, they wrap event listeners.

495
00:30:23,490 --> 00:30:26,698
And what we want to do, let's just say this is any, because I don't

496
00:30:26,714 --> 00:30:30,610
know what it is. And we'll say if e target tag name

497
00:30:30,760 --> 00:30:34,258
is not, if it's not an anchor link, then we don't do anything.

498
00:30:34,424 --> 00:30:36,850
Otherwise we prevent default.

499
00:30:37,510 --> 00:30:41,810
We maybe push state. So we'll push this onto the history stack

500
00:30:43,610 --> 00:30:47,586
and we'll navigate to e target

501
00:30:47,698 --> 00:30:51,542
href but of course this function doesn't exist, so let's define it.

502
00:30:51,676 --> 00:30:55,234
Navigate. You may recognize this from nextjs

503
00:30:55,282 --> 00:30:58,698
or something too, but anyway we'll navigate to where do we navigate to and what

504
00:30:58,704 --> 00:31:01,978
do we want to do? What we need to do now, whatever that

505
00:31:01,984 --> 00:31:05,382
is. We're not doing that. What we need to do now is fetch

506
00:31:05,446 --> 00:31:08,986
the JSX, the react tree for the

507
00:31:09,008 --> 00:31:12,858
next page and then rerender with that new output.

508
00:31:12,954 --> 00:31:15,690
Really, that's what we need to do. We need to fetch just the JSX tree

509
00:31:15,770 --> 00:31:18,794
and then rerender the page. We don't do a full navigation,

510
00:31:18,842 --> 00:31:22,066
so how do we do that? Well, in terms of pseudocode, we need to do

511
00:31:22,088 --> 00:31:26,290
const next page is await. So this is now async

512
00:31:26,790 --> 00:31:30,226
await fetch we'll say two and

513
00:31:30,248 --> 00:31:33,220
we'll maybe add a query param JSX true.

514
00:31:34,950 --> 00:31:39,266
And what we'll do is we'll get this as text and

515
00:31:39,288 --> 00:31:43,862
then what we'll do with that text is we'll say JSon

516
00:31:43,966 --> 00:31:47,740
parse the JSX using our

517
00:31:48,350 --> 00:31:51,626
revived JSON function. So now we have the next page and we just need

518
00:31:51,648 --> 00:31:55,046
to root. Keep in mind, we get the root from hydrate root,

519
00:31:55,078 --> 00:31:58,060
so root render the next page.

520
00:31:58,430 --> 00:32:02,078
That's it done. Fantastic. So everything's defined. Now we

521
00:32:02,084 --> 00:32:05,114
just need to add this to our server. So if we go to our server,

522
00:32:05,242 --> 00:32:09,034
we're already getting the JSON tree. So we'll say if rec

523
00:32:09,172 --> 00:32:12,180
query JSX is true,

524
00:32:13,030 --> 00:32:16,594
then we just return this, right?

525
00:32:16,632 --> 00:32:19,918
We just return the JSON string. That's it. Okay, we don't

526
00:32:19,934 --> 00:32:22,982
even need to return it, we just send it and do that.

527
00:32:23,036 --> 00:32:26,950
Perfect. This looks good. Kill it, start it again and

528
00:32:27,020 --> 00:32:30,934
reload. Okay, let's test. So now,

529
00:32:30,972 --> 00:32:34,714
logically, if I type something hello, this should

530
00:32:34,752 --> 00:32:37,610
persist between navigations. Indeed it does.

531
00:32:37,680 --> 00:32:41,942
Not only does it do that, the background color fades, it smoothly

532
00:32:42,006 --> 00:32:45,386
transitions instead of an abrupt change, and the good

533
00:32:45,408 --> 00:32:49,498
doggo never loses its rotating status. It's always

534
00:32:49,664 --> 00:32:53,246
continuous. So we have server components and

535
00:32:53,268 --> 00:32:56,526
we have them working on the client side. On the server side, we implemented an

536
00:32:56,548 --> 00:32:59,534
IRC server to turn them into this is how server components work.

537
00:32:59,652 --> 00:33:02,174
It takes a react JSX tree, turns it into an object,

538
00:33:02,292 --> 00:33:05,378
serializes it, sends it over the network, and then react. Picks it up

539
00:33:05,384 --> 00:33:08,610
on the client side and does what react does, which is make really nice updates

540
00:33:09,270 --> 00:33:12,514
that I hope was helpful. And with that, let's continue.

541
00:33:12,632 --> 00:33:16,002
So what we looked at was the interplay between react server components,

542
00:33:16,146 --> 00:33:19,478
client side rendering, and server side rendering. Client side rendering of

543
00:33:19,484 --> 00:33:23,346
course is pretty bad because you need to first download the Javascript bundle.

544
00:33:23,458 --> 00:33:27,302
It needs to parse, execute, run, and then

545
00:33:27,356 --> 00:33:30,186
if you need data, it will go fetch data. There's lots of waterfall. It's not

546
00:33:30,208 --> 00:33:33,642
ideal. Also, you don't ship a lot of markup to your users or search

547
00:33:33,696 --> 00:33:37,078
engines. It's highly problematic. The solution then is server

548
00:33:37,094 --> 00:33:40,406
side rendering. Indeed, that's what we did, although when it came to data fetching

549
00:33:40,438 --> 00:33:44,078
we server side rendered some parts, but we had like holes where the data was,

550
00:33:44,164 --> 00:33:48,142
which is what led us to require react server components. That fetches data

551
00:33:48,196 --> 00:33:51,718
nicely, turns it into a JSX tree, and feeds it into a client. A client

552
00:33:51,754 --> 00:33:55,118
can be a server that then sends a string to another client,

553
00:33:55,214 --> 00:33:58,542
or a client can be a browser client in the context of RC

554
00:33:58,606 --> 00:34:02,370
means both things. Let's talk lastly about

555
00:34:02,440 --> 00:34:05,758
how it actually works. We saw how

556
00:34:05,784 --> 00:34:09,206
it works in that sense, but I think the value is being able

557
00:34:09,228 --> 00:34:12,646
to have any element, any level in the tree, be async, so long

558
00:34:12,668 --> 00:34:16,330
as there's no interactivity there and you can fetch data wherever you want.

559
00:34:16,480 --> 00:34:20,454
So then the question becomes, okay, so are server components

560
00:34:20,582 --> 00:34:23,978
better than client components? Like if I use client, should I

561
00:34:23,984 --> 00:34:27,706
feel bad? Absolutely not. Client components have

562
00:34:27,728 --> 00:34:31,146
their place, server components have their place, and it's really on us to weave

563
00:34:31,178 --> 00:34:34,878
them together. Well, in keeping with that, I think it makes sense

564
00:34:34,964 --> 00:34:38,640
to draw this boundary between server and client components really well using

565
00:34:39,570 --> 00:34:43,982
adoption principles. I think if we talk about how we can gradually adopt

566
00:34:44,046 --> 00:34:48,238
server components, or how we can approach adopting server components, then we're

567
00:34:48,254 --> 00:34:51,726
in a better place to identify where client components

568
00:34:51,758 --> 00:34:55,026
fit in and where server components fit in. So with that, I'd like to give

569
00:34:55,048 --> 00:34:58,466
you three tools that you can use in moving towards server

570
00:34:58,498 --> 00:35:01,558
components. This will not help you go to server components overnight, but will put you

571
00:35:01,564 --> 00:35:04,390
in a good spot to adopt them once they're ready and stable.

572
00:35:05,210 --> 00:35:08,778
Number one is you want to fetch data early. You want to

573
00:35:08,784 --> 00:35:13,098
fetch data as early as possible, before any state is

574
00:35:13,184 --> 00:35:16,682
set. Before we talked about it also in the next JS video,

575
00:35:16,736 --> 00:35:20,526
again, link under the like button. You want to fetch data even at the

576
00:35:20,548 --> 00:35:23,946
server level, like before. And the earlier you fetch data, the better your chances

577
00:35:23,978 --> 00:35:27,166
are of adopting server components. Number two is you'd want to

578
00:35:27,188 --> 00:35:30,498
reconsider your interaction boundaries. What I mean by that is

579
00:35:30,664 --> 00:35:33,922
we usually have interactive pieces of our

580
00:35:34,056 --> 00:35:37,742
reactories currently that are interleaved with non interactive pieces.

581
00:35:37,886 --> 00:35:41,394
Consider like an application, like a blog post. You have the

582
00:35:41,432 --> 00:35:45,094
title, you have a paragraph and you have a little button. And from the most

583
00:35:45,132 --> 00:35:48,646
code bases I've seen, all of these are within a card. So you have card

584
00:35:48,748 --> 00:35:52,546
header, content button and all of these are one file

585
00:35:52,578 --> 00:35:55,926
because it's relatively short. The problem there is that

586
00:35:55,948 --> 00:35:59,738
the interaction boundary is only at the button. So the button in

587
00:35:59,744 --> 00:36:02,682
this case needs to be its own components. So you need to have a card,

588
00:36:02,736 --> 00:36:06,154
a header, a title and then a button not be part

589
00:36:06,192 --> 00:36:09,850
of this card component or the title and content,

590
00:36:09,920 --> 00:36:13,662
but be its own component. Meaning the onclick handler isn't a separate file basically.

591
00:36:13,716 --> 00:36:16,986
And the reason for that is because on click handlers cannot be serialized. Therefore buttons

592
00:36:17,018 --> 00:36:20,238
cannot be server components. And so you'd put yourself in a

593
00:36:20,244 --> 00:36:23,614
good spot to adopt server components. If your interactive

594
00:36:23,662 --> 00:36:27,214
things with handlers or functions or non serializable props

595
00:36:27,262 --> 00:36:30,846
like on click, et cetera, your interaction boundaries are in their own separate

596
00:36:30,878 --> 00:36:34,466
modules and those are as granular as possible. Number three, a lot

597
00:36:34,488 --> 00:36:38,230
of our applications use react context, and context is great for

598
00:36:38,300 --> 00:36:41,846
literally that, for providing context to your application. For example, who is the

599
00:36:41,868 --> 00:36:45,500
logged in user? What are their preferences? Do they like

600
00:36:46,670 --> 00:36:50,970
toast? Then show them YouTube videos about toast. Even we use context sometimes for personalization.

601
00:36:51,710 --> 00:36:55,190
On the server side, you don't get to use react context

602
00:36:55,270 --> 00:36:59,226
because that context is usually shared across multiple

603
00:36:59,258 --> 00:37:02,862
clients. And so the better alternative there is to use

604
00:37:02,916 --> 00:37:06,186
server side cache. You could have a cache namespaced

605
00:37:06,218 --> 00:37:09,934
by user, for example. You could really do the same things or similar things

606
00:37:09,972 --> 00:37:12,990
that you used to do with context with server side cache, and then you get

607
00:37:13,060 --> 00:37:16,766
that as well. I think these three tools will help you really adopt

608
00:37:16,798 --> 00:37:20,034
server components. If not, put yourself in a good position to adopt them once you

609
00:37:20,072 --> 00:37:22,930
feel like you can, and once they are more mainstream.

610
00:37:23,270 --> 00:37:26,726
And with that, I'd like to quickly come to the end of

611
00:37:26,828 --> 00:37:30,546
this video, but I wanted to address one thing before wrapping

612
00:37:30,578 --> 00:37:34,662
up, and that is we talked about a lot of what react server components

613
00:37:34,726 --> 00:37:38,250
are, an architecture, a way to fetch data, et cetera.

614
00:37:38,750 --> 00:37:42,646
I think one thing that RC is above

615
00:37:42,678 --> 00:37:46,314
and beyond all of that is that react server components is

616
00:37:46,352 --> 00:37:50,494
a community effort and by extension react itself is

617
00:37:50,532 --> 00:37:53,886
a community effort. And I think I would be remiss if I

618
00:37:53,908 --> 00:37:58,014
didn't mention and acknowledge the fact that we

619
00:37:58,052 --> 00:38:01,666
haven't been the best community. The react community has had some issues lately with

620
00:38:01,688 --> 00:38:05,566
the discourse getting more and more hostile and ultimately leading

621
00:38:05,598 --> 00:38:09,074
even the most patient and kind of us, Dan Abramov and others,

622
00:38:09,192 --> 00:38:12,866
to burn out and not really enjoy being here. It feels like

623
00:38:12,888 --> 00:38:16,866
an obligation instead of a joy, and that's pretty unfortunate

624
00:38:16,898 --> 00:38:19,894
for a community. And my hope is that in calling it out, it helps us

625
00:38:19,932 --> 00:38:23,206
take a moment to reflect and improve and really be the community

626
00:38:23,308 --> 00:38:26,646
that we wanted to be and that it once was, and that I believe it

627
00:38:26,668 --> 00:38:30,010
could be again. With that, as usual, we covered a lot of content.

628
00:38:30,080 --> 00:38:33,446
I'm really thankful that you stuck around if you did. If you're enjoying

629
00:38:33,478 --> 00:38:37,526
and or benefiting and learning from these videos, please subscribe

630
00:38:37,558 --> 00:38:40,686
to the channel, hit the bell and drop a like. It would really help and

631
00:38:40,708 --> 00:38:44,718
it's just a great easy way to support me. Also, if you found the content

632
00:38:44,804 --> 00:38:48,314
useful, I'd encourage you to share it on social media, LinkedIn, Twitter,

633
00:38:48,362 --> 00:38:51,842
blue sky, whatever you like, and really spread it

634
00:38:51,896 --> 00:38:55,634
so that people can understand react server components and learn. And also

635
00:38:55,752 --> 00:38:59,474
that I would feel supported and be more likely to make great content.

636
00:38:59,592 --> 00:39:03,074
Ideally, hopefully great content like this, all of this stuff

637
00:39:03,112 --> 00:39:05,506
is going to be in a GitHub repository that you can access as well.

638
00:39:05,528 --> 00:39:07,874
I'll put a link under the like button. And I want to say thank you

639
00:39:07,912 --> 00:39:11,554
for being here. Thank you for watching. Thank you for your interest in web

640
00:39:11,592 --> 00:39:15,500
technology and computer science. I'll catch you in the next one.

641
00:39:15,950 --> 00:39:16,230
Peace.

