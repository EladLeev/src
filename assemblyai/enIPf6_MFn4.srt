1
00:00:27,730 --> 00:00:30,854
Hello and a warm welcome to the presentation on

2
00:00:30,892 --> 00:00:34,326
effective Java with Groovy and Kotlin. I started

3
00:00:34,508 --> 00:00:38,134
using Java on several projects and after that I went

4
00:00:38,172 --> 00:00:41,874
on to use Groovy and Kotlin languages on few more JVM

5
00:00:41,922 --> 00:00:45,590
projects. This journey had some interesting

6
00:00:45,740 --> 00:00:49,558
lessons and I had some cool observations on how

7
00:00:49,644 --> 00:00:53,242
program languages influences developers to adopt

8
00:00:53,306 --> 00:00:56,846
good practices. And in this presentation I'm going to share them

9
00:00:56,868 --> 00:01:00,526
with you. My name is Naresha and I help teams to

10
00:01:00,548 --> 00:01:04,190
get better at applying technology to solve their business

11
00:01:04,260 --> 00:01:07,658
problems. Let's get started by setting up a common ground.

12
00:01:07,754 --> 00:01:11,442
You know, Java started as a platform independent technology.

13
00:01:11,576 --> 00:01:15,430
Do you remember that famous acronym Vora which meant for

14
00:01:15,500 --> 00:01:19,286
right ones run anywhere? Interestingly, Java was

15
00:01:19,388 --> 00:01:23,286
the only language that you could use to run

16
00:01:23,388 --> 00:01:27,598
or develop applications on top of JVM.

17
00:01:27,794 --> 00:01:31,898
But later that situation changed and

18
00:01:31,984 --> 00:01:35,814
we had more programming languages targeting

19
00:01:35,862 --> 00:01:39,302
JVM. Like Groovy is such a language.

20
00:01:39,366 --> 00:01:42,986
And later on we had Kotlin which is another language

21
00:01:43,098 --> 00:01:46,670
which could run on JVM. Now making

22
00:01:46,740 --> 00:01:50,254
the JVM a more promising place

23
00:01:50,372 --> 00:01:54,178
for developers because they could choose

24
00:01:54,264 --> 00:01:58,498
the language, what helps them better to create their

25
00:01:58,584 --> 00:02:02,338
application and the information

26
00:02:02,424 --> 00:02:06,150
or the key that JVM is. These most important

27
00:02:06,300 --> 00:02:10,210
piece in the whole ecosystem has been endorsed

28
00:02:10,290 --> 00:02:13,314
by people like James Gosling,

29
00:02:13,362 --> 00:02:16,754
who has been attributed as the father of Java.

30
00:02:16,882 --> 00:02:20,326
With that, let's move on to effective Java.

31
00:02:20,438 --> 00:02:23,910
I'm sure you would consider effective Java

32
00:02:23,990 --> 00:02:27,562
as one of the most influential books that

33
00:02:27,696 --> 00:02:31,326
helped Java developers. When I read it like

34
00:02:31,508 --> 00:02:34,974
15 years ago, it really changed the way

35
00:02:35,012 --> 00:02:38,078
I wrote Java programs. Not only that,

36
00:02:38,164 --> 00:02:41,482
it really changed some of my fundamental beliefs

37
00:02:41,546 --> 00:02:45,154
on what is the right approach or right technique for

38
00:02:45,272 --> 00:02:49,074
developing applications on JVM. A quick

39
00:02:49,112 --> 00:02:52,258
look at groovy programming language one of

40
00:02:52,264 --> 00:02:55,322
the problems faced by several developers

41
00:02:55,406 --> 00:02:59,046
when they were developing on Java language was

42
00:02:59,148 --> 00:03:03,058
that developer productivity developers weren't

43
00:03:03,154 --> 00:03:07,106
that productive because they were spending a lot of time writing

44
00:03:07,298 --> 00:03:10,298
a very mundane verbals code.

45
00:03:10,384 --> 00:03:13,974
So Groovy was an attempt to solve

46
00:03:14,102 --> 00:03:18,166
such problem. So here you could see what James

47
00:03:18,278 --> 00:03:21,806
Strachen who created Groovy language said,

48
00:03:21,908 --> 00:03:25,674
that the whole idea was to make developers

49
00:03:25,722 --> 00:03:29,994
really productivity with the new language and at that time the approach

50
00:03:30,042 --> 00:03:33,406
was dynamic language.

51
00:03:33,518 --> 00:03:37,166
On a similar note, Kotlin is another JVM

52
00:03:37,278 --> 00:03:41,118
language and jetbrains developed

53
00:03:41,214 --> 00:03:45,314
this language to make sure that their development experience

54
00:03:45,432 --> 00:03:49,462
on JVM is better. And they had certain

55
00:03:49,596 --> 00:03:52,930
things in mind when they developed this languages.

56
00:03:53,010 --> 00:03:56,774
And interestingly, it was at a later point

57
00:03:56,812 --> 00:04:00,662
in time than Ruby, so more of like static typing

58
00:04:00,726 --> 00:04:04,006
was the most widely preferred

59
00:04:04,038 --> 00:04:07,814
choice at that point in time. With that, let's explore

60
00:04:07,862 --> 00:04:11,434
a few wisdoms from effective Java and see how they're

61
00:04:11,482 --> 00:04:15,098
applicable in languages like Groovy and Kotlin.

62
00:04:15,194 --> 00:04:18,414
So here are a few icons that will help you

63
00:04:18,452 --> 00:04:22,126
to navigate this. In case you feel lost, you will

64
00:04:22,148 --> 00:04:25,726
always see these icons and that will help you to

65
00:04:25,748 --> 00:04:29,506
see where you are. So we will take this approach. We will start with

66
00:04:29,528 --> 00:04:33,902
these problem, right? When we have a problem, what do we do? Effective Java

67
00:04:33,966 --> 00:04:38,280
comes to the rescue. So let's go and check what does effective Java say

68
00:04:39,450 --> 00:04:42,854
in that context or how to solve that

69
00:04:42,892 --> 00:04:46,374
particular problem. Then we know what is said in

70
00:04:46,412 --> 00:04:50,614
effective Java is good for Java languages.

71
00:04:50,742 --> 00:04:53,866
But when we take those ideas or when

72
00:04:53,888 --> 00:04:57,606
we try to reuse these Java implementation in groovy or Kotlin,

73
00:04:57,638 --> 00:05:01,146
we might end up with the certain problems. Those are the traps what

74
00:05:01,168 --> 00:05:04,734
you need to be aware of. Then we will see for Groovy or

75
00:05:04,772 --> 00:05:08,494
Kotlin what is the idiomatic solution. And then

76
00:05:08,532 --> 00:05:11,594
finally we will see lessons what lessons

77
00:05:11,642 --> 00:05:15,438
did we learn by going through these good examples?

78
00:05:15,614 --> 00:05:19,582
Note here that effective Java was initially written

79
00:05:19,646 --> 00:05:23,522
to improve the Java implementation. And when

80
00:05:23,656 --> 00:05:27,746
languages like Groovy and Kotlin were developed, they were already aware

81
00:05:27,778 --> 00:05:31,366
of effective Java practices. So they incorporated lot

82
00:05:31,388 --> 00:05:33,960
of these ideas in the language itself.

83
00:05:34,330 --> 00:05:37,754
But in a way, when we look

84
00:05:37,792 --> 00:05:41,750
at how these effective Java suggestions

85
00:05:41,830 --> 00:05:45,786
are used in Groovy and Kotlin, we get

86
00:05:45,888 --> 00:05:50,326
another idea of how these languages, groovy and

87
00:05:50,448 --> 00:05:54,078
Kotlin make developers life

88
00:05:54,244 --> 00:05:58,378
easy and really encourage developers to embrace

89
00:05:58,474 --> 00:06:02,462
good practices. So let's take few examples and

90
00:06:02,596 --> 00:06:06,510
explore this since you would see good examples covering

91
00:06:06,590 --> 00:06:09,966
three languages. Here I have the icons

92
00:06:09,998 --> 00:06:13,346
of respective languages so that it becomes easy for you

93
00:06:13,368 --> 00:06:16,754
to identify which language has been used in writing

94
00:06:16,802 --> 00:06:20,598
that particular piece of code. So without further delay, let's get

95
00:06:20,684 --> 00:06:23,878
started with the first item. In this case,

96
00:06:23,964 --> 00:06:27,538
I have a class written in groovy, which is product

97
00:06:27,644 --> 00:06:30,694
which has three attributes, namely sku,

98
00:06:30,742 --> 00:06:35,030
description and price. So what I'm going to do is I'm creating

99
00:06:35,110 --> 00:06:39,034
two instances of the product class with

100
00:06:39,072 --> 00:06:42,222
the same set of attributes, and I'm trying

101
00:06:42,276 --> 00:06:45,566
to check if these two objects are

102
00:06:45,668 --> 00:06:49,882
equal. Please note that double

103
00:06:49,946 --> 00:06:53,322
equals in groovy is like similar to

104
00:06:53,396 --> 00:06:57,490
calling equals method in Java. So typically you would expect

105
00:06:57,640 --> 00:07:01,330
them to be equal, but they are not

106
00:07:01,400 --> 00:07:04,594
equals. On a very similar note, what I'm going to do

107
00:07:04,632 --> 00:07:08,134
is create hash map with

108
00:07:08,172 --> 00:07:11,686
the variable name as stock. Note the

109
00:07:11,868 --> 00:07:15,058
native syntax of hash map in groovy

110
00:07:15,154 --> 00:07:18,742
and I'm using book one as the key to store a value

111
00:07:18,796 --> 00:07:22,218
100 in that and then I'm trying to retrieve the

112
00:07:22,304 --> 00:07:25,098
value using boost two as these key.

113
00:07:25,264 --> 00:07:29,274
Ideally, since they have the same value, we would expect to

114
00:07:29,312 --> 00:07:32,766
retrieve the value 100, but that's not the case.

115
00:07:32,868 --> 00:07:37,600
I'm sure you have had these surprise before and

116
00:07:38,130 --> 00:07:42,602
you'd have rightly guessed it. The culprits are equals

117
00:07:42,666 --> 00:07:46,562
and hash code. I mean the developers, we are the culprits. We were

118
00:07:46,696 --> 00:07:50,900
supposed to override equals and hash code because

119
00:07:51,270 --> 00:07:55,170
hash code is unique for each instance and

120
00:07:55,320 --> 00:07:58,630
equals method by default would check

121
00:07:58,700 --> 00:08:02,438
if they are pointing to the same object, same instance. But in

122
00:08:02,444 --> 00:08:06,594
this case we had two instances, right? So it becomes our developer's

123
00:08:06,642 --> 00:08:10,422
responsibility to override these methods.

124
00:08:10,486 --> 00:08:13,974
So these are these related wisdoms

125
00:08:14,022 --> 00:08:17,786
from effective Java book. Essentially what you need to

126
00:08:17,808 --> 00:08:21,930
do is maintain that consistency between equals

127
00:08:22,010 --> 00:08:25,882
and hash code methods. That's like whenever two objects

128
00:08:25,946 --> 00:08:29,626
are equals, they should have the same hash

129
00:08:29,658 --> 00:08:33,134
code, which means that when we

130
00:08:33,172 --> 00:08:36,786
override equals and hash code method, they should

131
00:08:36,888 --> 00:08:40,654
depend on the same set of attributes. You can't have equals

132
00:08:40,702 --> 00:08:44,386
depending on few set of attributes and hash code depending on

133
00:08:44,408 --> 00:08:47,800
another set of attributes. The typical approach without

134
00:08:48,650 --> 00:08:52,614
or there are two approaches what you could take in

135
00:08:52,652 --> 00:08:56,614
Java. Approach one, ask your ide to generate the

136
00:08:56,652 --> 00:09:00,330
code approach. Two, use a library like

137
00:09:00,400 --> 00:09:04,822
Apache commerce language which will provide you something like equals builder

138
00:09:04,886 --> 00:09:08,940
and hash code builder. You would see an example of using

139
00:09:09,470 --> 00:09:13,690
equals builder in action here. Essentially you need to supply

140
00:09:13,850 --> 00:09:17,738
what are the fields that the equals method

141
00:09:17,834 --> 00:09:21,840
would depend upon. I see two problems

142
00:09:22,470 --> 00:09:25,634
here. One is like if you use IDE

143
00:09:25,752 --> 00:09:29,362
to generate the code, let's say take this example

144
00:09:29,496 --> 00:09:33,710
and now say I'm going to add one more attribute,

145
00:09:33,870 --> 00:09:37,894
date of manufacturer after some time, say the

146
00:09:37,932 --> 00:09:41,682
requirement changes and now I need to incorporate date of expiry.

147
00:09:41,746 --> 00:09:45,574
Also, who is going to update equals and

148
00:09:45,612 --> 00:09:49,082
hash code? Ide code generation works great for the first time.

149
00:09:49,216 --> 00:09:52,778
Then if the developer forgets to update or to

150
00:09:52,864 --> 00:09:56,650
regenerate that code, you will end up in

151
00:09:56,720 --> 00:10:00,778
trouble, right? That's the problem with the IDE code generation.

152
00:10:00,874 --> 00:10:04,462
On the other hand, what happens with the

153
00:10:04,516 --> 00:10:08,206
approach, what we are using is like if you use equals and

154
00:10:08,228 --> 00:10:11,770
hash code builder, there are duplicate representations,

155
00:10:11,850 --> 00:10:15,410
right? Since we told in order to maintain the consistency between

156
00:10:15,480 --> 00:10:19,406
equals and hash code, they should rely on the same set of attributes.

157
00:10:19,518 --> 00:10:22,814
However, there were two different classes, one equals

158
00:10:22,862 --> 00:10:26,374
builder and one hash code builder instead of a single

159
00:10:26,492 --> 00:10:30,086
equals and has code builder. That's what groovy does. And you

160
00:10:30,108 --> 00:10:34,374
would see that it

161
00:10:34,412 --> 00:10:38,102
looks like an annotation at equals and hash code,

162
00:10:38,156 --> 00:10:42,006
which is called as ast transformation in

163
00:10:42,108 --> 00:10:45,674
groovy. Now what happens is compiler will

164
00:10:45,712 --> 00:10:49,894
look at this instruction, that is the ast transformation equals

165
00:10:49,942 --> 00:10:53,594
and hash code, which will automatically generate the equals

166
00:10:53,642 --> 00:10:57,130
and hash code whenever you compile

167
00:10:57,210 --> 00:11:00,618
your code. Now just by adding

168
00:11:00,634 --> 00:11:03,818
that extra annotation we will rerun our

169
00:11:03,844 --> 00:11:07,154
code. Now you would see book one equals book two,

170
00:11:07,272 --> 00:11:11,138
and you would see that when we use the second

171
00:11:11,224 --> 00:11:15,138
object as these key, we are getting the right value

172
00:11:15,224 --> 00:11:18,274
and the code is working as expected.

173
00:11:18,322 --> 00:11:22,200
Now however, a couple of things that you need to be

174
00:11:22,570 --> 00:11:26,310
taking care. In the previous case the class,

175
00:11:26,380 --> 00:11:30,258
what we looked is more like value object has against an

176
00:11:30,284 --> 00:11:33,866
entity. But in the case of an entity what you

177
00:11:33,888 --> 00:11:37,386
would do is like say you might have can autogenerated id.

178
00:11:37,488 --> 00:11:40,986
So you have to be careful about the situation wherein

179
00:11:41,018 --> 00:11:44,878
like object before persisting versus object

180
00:11:44,964 --> 00:11:48,990
after persisting. So that's the reason why typically

181
00:11:49,410 --> 00:11:52,914
relying upon an auto generated key can lead you

182
00:11:52,952 --> 00:11:54,450
to trouble.

183
00:11:55,750 --> 00:11:59,822
Instead of using that, you should typically rely upon

184
00:11:59,966 --> 00:12:03,634
the business key, which in this case happens to be

185
00:12:03,672 --> 00:12:07,286
sKu, so that there is always consistency even if

186
00:12:07,308 --> 00:12:11,046
you perform a save in between. If you had question on how

187
00:12:11,068 --> 00:12:14,850
do I instruct these groovy compiler to generate

188
00:12:14,930 --> 00:12:18,326
equals and hash code methods based on subset

189
00:12:18,358 --> 00:12:21,930
of fields? I'm sure the example also

190
00:12:22,080 --> 00:12:26,390
tells you how to do that. Here I have used influences

191
00:12:26,550 --> 00:12:30,230
in a very similar way. You have excludes options

192
00:12:30,400 --> 00:12:33,690
as well. With that, let's move on to Kotlin

193
00:12:33,770 --> 00:12:37,694
and recreate a very similar situation here.

194
00:12:37,812 --> 00:12:42,170
You are very much familiar with this and what approach

195
00:12:42,250 --> 00:12:46,560
Kotlin takes as against groovy is that

196
00:12:47,250 --> 00:12:51,006
Kotlin uses more implicit approach.

197
00:12:51,118 --> 00:12:55,318
That is like you use data class. By default you get

198
00:12:55,404 --> 00:12:59,282
all the equals hash code methods generated

199
00:12:59,426 --> 00:13:02,966
for you. Now just by adding making it

200
00:13:02,988 --> 00:13:05,734
a data class rather than an ordinary class,

201
00:13:05,932 --> 00:13:09,574
it works as expected because compiler generates

202
00:13:09,702 --> 00:13:13,482
equals and hash code methods for you. And now

203
00:13:13,536 --> 00:13:17,750
let's move on to the second problem of customizing.

204
00:13:17,830 --> 00:13:21,658
In this case I wanted to have a field like Id

205
00:13:21,744 --> 00:13:25,074
which gets changed later on when you're

206
00:13:25,222 --> 00:13:29,280
saving the value. So now again you're back to the problem like

207
00:13:29,650 --> 00:13:33,598
both they are not equals and you're

208
00:13:33,614 --> 00:13:36,850
not retrieving the right value using the second object

209
00:13:36,920 --> 00:13:40,100
as these key. So how do we solve these kind of problems?

210
00:13:40,470 --> 00:13:43,682
Pretty simple. In Kotlin convention you

211
00:13:43,736 --> 00:13:46,902
use the fields that are to be considered for

212
00:13:46,956 --> 00:13:50,242
equals and hash code in your primary constructor,

213
00:13:50,386 --> 00:13:54,098
and the remaining fields you declare

214
00:13:54,194 --> 00:13:57,866
inside the body. That's the approach you have to

215
00:13:57,888 --> 00:13:58,460
take.

216
00:14:01,630 --> 00:14:05,478
With that, let's move on to see what lessons

217
00:14:05,574 --> 00:14:09,370
did we learn. So groovy used ASD transformation,

218
00:14:10,430 --> 00:14:14,026
you have to be explicit on what fields

219
00:14:14,058 --> 00:14:17,582
to be used for equals and hash code. You say that

220
00:14:17,636 --> 00:14:21,338
by default all fields are considered. If you just put the transformation

221
00:14:21,514 --> 00:14:25,246
unlike that, Kotlin uses

222
00:14:25,438 --> 00:14:28,514
more default convention like

223
00:14:28,552 --> 00:14:32,050
okay, data classes will generate equals and

224
00:14:32,120 --> 00:14:35,606
hash code with the fields to be considered are to

225
00:14:35,628 --> 00:14:38,998
be part of the primary constructor. That's the more like

226
00:14:39,084 --> 00:14:42,786
implicit approach of Kotlin versus slightly

227
00:14:42,818 --> 00:14:46,034
more explicit approach of groovy.

228
00:14:46,162 --> 00:14:49,862
And interesting point is, both these languages

229
00:14:50,006 --> 00:14:53,814
save you, the developers, from committing

230
00:14:53,862 --> 00:14:57,946
the mistake of violating dry principle, right? That's like

231
00:14:58,128 --> 00:15:02,238
single point of representation for any knowledge which

232
00:15:02,404 --> 00:15:05,918
you might commit in your Java code.

233
00:15:06,004 --> 00:15:09,374
That's the real benefit you are going to get. And that's how these two

234
00:15:09,412 --> 00:15:13,130
languages help you to embrace good practices.

235
00:15:13,210 --> 00:15:17,026
So the good practice here is dry principle and you

236
00:15:17,048 --> 00:15:20,514
have learned how groovy and Kotlin help you

237
00:15:20,552 --> 00:15:23,874
to embrace good practices. With that, let's move on

238
00:15:23,912 --> 00:15:27,238
to see these piece of code. Well, how does it look?

239
00:15:27,324 --> 00:15:31,042
Very complex, right? Why does it look complex?

240
00:15:31,186 --> 00:15:35,254
Because it has too many moving parts. I'm sure many times when

241
00:15:35,292 --> 00:15:40,006
we see our code we get the same feeling represented

242
00:15:40,038 --> 00:15:43,258
by these image. So let's take this code, piece of

243
00:15:43,264 --> 00:15:47,146
code simple like Java code, wherein we

244
00:15:47,248 --> 00:15:51,022
iterate through a list. What do you

245
00:15:51,076 --> 00:15:54,958
think is the problem or the difference between the first

246
00:15:55,044 --> 00:15:58,142
very conventional for loop versus the for

247
00:15:58,196 --> 00:16:01,406
each loop? You would readily notice that the

248
00:16:01,428 --> 00:16:05,646
second piece of code here has fewer moving parts compared

249
00:16:05,678 --> 00:16:10,002
to the first, which makes the second code simpler and

250
00:16:10,136 --> 00:16:13,166
less error prone. So what does effective

251
00:16:13,198 --> 00:16:17,218
Java say? It says prefer for each loop to traditional

252
00:16:17,394 --> 00:16:21,094
for loops. And let's move on

253
00:16:21,132 --> 00:16:25,042
to Kotlin this time. And let's

254
00:16:25,106 --> 00:16:29,366
use that for each loop. Very similar to that in Kotlin.

255
00:16:29,478 --> 00:16:33,002
You could use this piece of code. And now

256
00:16:33,056 --> 00:16:37,210
let's say we want to perform some sort of

257
00:16:37,360 --> 00:16:40,718
map operation, multiply each by two.

258
00:16:40,804 --> 00:16:44,640
So instead of using a typical loop, I'm using

259
00:16:45,490 --> 00:16:49,262
map transformation here. That's why you have higher order

260
00:16:49,316 --> 00:16:52,894
function map available which accepts closure

261
00:16:52,942 --> 00:16:56,146
as the argument. Very similar. I can perform a

262
00:16:56,168 --> 00:16:59,566
reduce operation using fold.

263
00:16:59,678 --> 00:17:03,294
Now groovy also provides a very similar operation.

264
00:17:03,342 --> 00:17:06,802
This is a regular like for each loop

265
00:17:06,946 --> 00:17:11,030
and I could use map transformation.

266
00:17:11,690 --> 00:17:15,702
The method is collect and very

267
00:17:15,756 --> 00:17:18,982
similar to fold. You have inject in groovy.

268
00:17:19,046 --> 00:17:21,690
So notice that in these languages,

269
00:17:23,230 --> 00:17:26,938
instead of for each loop, we could go on to the next level.

270
00:17:27,024 --> 00:17:30,666
So when it comes to interpreting favoring for

271
00:17:30,688 --> 00:17:34,494
each loop against traditional for loops in these

272
00:17:34,532 --> 00:17:38,106
languages, what we need to do is that we have to interpret

273
00:17:38,138 --> 00:17:41,680
it in a slightly better way. That is like

274
00:17:42,050 --> 00:17:46,062
what we need to do is we should favor internal iterators

275
00:17:46,126 --> 00:17:49,426
to external iterators, wherein you could

276
00:17:49,608 --> 00:17:53,490
make your code have even fewer moving

277
00:17:53,560 --> 00:17:57,462
parts. And what helps these languages to

278
00:17:57,516 --> 00:18:01,190
enable that is closures or

279
00:18:01,340 --> 00:18:05,142
higher order functions. Since Java nowadays also

280
00:18:05,196 --> 00:18:08,150
has support for lambda expressions.

281
00:18:08,510 --> 00:18:12,780
This advice is very much applicable to Java also.

282
00:18:13,390 --> 00:18:17,494
But in Java you'll have to use streams API

283
00:18:17,542 --> 00:18:21,534
to take advantage of this, while these

284
00:18:21,572 --> 00:18:26,142
languages have higher order functions supported right

285
00:18:26,196 --> 00:18:29,454
in their collections. With that,

286
00:18:29,492 --> 00:18:33,658
let's move on to these next item. If I ask you a

287
00:18:33,764 --> 00:18:37,700
question, what would be a million dollar or

288
00:18:38,550 --> 00:18:42,402
billion dollar effort spent in every

289
00:18:42,536 --> 00:18:46,642
Java project, or money wasted in Java

290
00:18:46,706 --> 00:18:50,006
presents writing redundant code? My favorite would be definitely

291
00:18:50,108 --> 00:18:53,602
null check, right? A lot of null checks

292
00:18:53,666 --> 00:18:57,106
people write, but still ending up with null pointer

293
00:18:57,138 --> 00:19:00,630
exception in several places. So let's

294
00:19:00,710 --> 00:19:04,282
see an example. Imagine I have

295
00:19:04,336 --> 00:19:09,078
a method called get speakers, which accepts a conference

296
00:19:09,254 --> 00:19:12,414
name, has arguments, and returns the list

297
00:19:12,452 --> 00:19:16,382
of speakers who speak at the conference. What I do

298
00:19:16,436 --> 00:19:20,410
is I go and return null directly

299
00:19:20,490 --> 00:19:23,970
from this method. What is the implication of this?

300
00:19:24,040 --> 00:19:27,438
Whenever a developers calls this method,

301
00:19:27,534 --> 00:19:31,090
he has to make sure that he checks if the written value

302
00:19:31,160 --> 00:19:35,118
is null, which is going to be very

303
00:19:35,224 --> 00:19:38,530
counterproductive, and every call would require

304
00:19:38,610 --> 00:19:41,890
a null check, which is not recommended.

305
00:19:41,970 --> 00:19:45,314
So as per effective, Java says return empty

306
00:19:45,362 --> 00:19:49,074
arrays are collections instead of nulls,

307
00:19:49,122 --> 00:19:52,730
right? So you should never return nulls whenever the return

308
00:19:52,800 --> 00:19:56,618
type is a collection. Let's call the same

309
00:19:56,704 --> 00:20:00,086
piece of code in groovy. So imagine in groovy you

310
00:20:00,128 --> 00:20:04,346
return null, and let's try to invoke

311
00:20:04,378 --> 00:20:08,058
that method. On that return method, we'll perform subsequent

312
00:20:08,234 --> 00:20:11,754
operations and see if we get null pointer

313
00:20:11,802 --> 00:20:16,078
exception, which is the main problem, right? So what I do is I invoke

314
00:20:16,174 --> 00:20:19,346
the collect method on the return value, which is

315
00:20:19,368 --> 00:20:23,474
null, which is like calling null collect, right? These again in

316
00:20:23,512 --> 00:20:27,862
the next line I'm calling null find

317
00:20:27,916 --> 00:20:31,846
all. And interestingly, you would note that I'm not

318
00:20:31,868 --> 00:20:35,414
going to get a null pointer exception, I'm going to get an

319
00:20:35,452 --> 00:20:38,860
empty collection, empty list in this case.

320
00:20:39,310 --> 00:20:42,874
Well, so now your friend is trying

321
00:20:42,912 --> 00:20:46,346
to create trouble for you by returning null in

322
00:20:46,368 --> 00:20:50,254
that method, but groovy is going to save you from all

323
00:20:50,292 --> 00:20:53,726
the trouble that your friend is going

324
00:20:53,748 --> 00:20:56,094
to cause to you. How did that happen?

325
00:20:56,212 --> 00:20:59,722
Groovy, instead of using the null literal,

326
00:20:59,786 --> 00:21:03,378
it replaced it with the null object. Null object.

327
00:21:03,464 --> 00:21:07,006
What it does is whenever you invoke iterator

328
00:21:07,198 --> 00:21:10,914
method on the null object, it returns an

329
00:21:11,032 --> 00:21:15,220
empty list. In this case, instead of

330
00:21:15,530 --> 00:21:18,994
ending up with these null pointer exception. If you invoke

331
00:21:19,042 --> 00:21:22,854
any other method it will

332
00:21:22,892 --> 00:21:26,914
throw a null pointer exception. So using null objects

333
00:21:26,962 --> 00:21:30,842
for instead of null literals saved you

334
00:21:30,896 --> 00:21:35,542
from a lot of trouble. Now in the case of Kotlin,

335
00:21:35,606 --> 00:21:39,574
let's see how different approach Kotlin

336
00:21:39,622 --> 00:21:43,230
takes. So you have these

337
00:21:43,300 --> 00:21:47,102
method get speakers returning a list of speakers and I say return

338
00:21:47,156 --> 00:21:51,214
null. What happens is that the code is not using to compile because by

339
00:21:51,252 --> 00:21:54,160
default type is not null level.

340
00:21:54,550 --> 00:21:58,254
If you think that these method can return null,

341
00:21:58,302 --> 00:22:01,762
then you should explicitly say that by

342
00:22:01,896 --> 00:22:05,202
suffixing the question mark in this case. In the second example

343
00:22:05,256 --> 00:22:08,758
it will allow you to return null. The first example it will not

344
00:22:08,844 --> 00:22:12,422
allow you to return null. So developer has to ask that

345
00:22:12,476 --> 00:22:16,674
question to himself, hey, do you really want to return null

346
00:22:16,722 --> 00:22:19,834
or not? Accordingly, the compiler will help

347
00:22:19,872 --> 00:22:23,482
you with the extra safety checks. So note that in this

348
00:22:23,536 --> 00:22:27,082
case groovy and Kotlin take quite

349
00:22:27,216 --> 00:22:30,070
different approach for you.

350
00:22:30,240 --> 00:22:33,210
Both were pretty much helpful to the developers,

351
00:22:33,290 --> 00:22:36,654
but they were fundamentally different

352
00:22:36,772 --> 00:22:40,718
in the approach they took. So what did we learn here?

353
00:22:40,804 --> 00:22:44,900
Technique used was null object pattern in case of groovy and

354
00:22:45,510 --> 00:22:49,314
type system itself, asking that question whether

355
00:22:49,352 --> 00:22:52,994
it should allow null or not. Null was what

356
00:22:53,032 --> 00:22:57,010
has been favored by Kotlin and essentially

357
00:22:57,090 --> 00:23:01,560
helping you to write fewer boilerplate code and more

358
00:23:02,250 --> 00:23:06,294
safety, which is the value what these

359
00:23:06,332 --> 00:23:10,170
features deliver to the users of these languages.

360
00:23:10,990 --> 00:23:14,726
And in fact, life is too short for null checks.

361
00:23:14,838 --> 00:23:18,774
You would rather spend it wisely for solving

362
00:23:18,822 --> 00:23:22,174
some real business problems. Well, what comes to

363
00:23:22,212 --> 00:23:25,774
your mind when you hear the word side effect?

364
00:23:25,892 --> 00:23:29,834
It's mutability, right? Interestingly, effective Java

365
00:23:29,882 --> 00:23:33,906
says minimize mutability. So in the beginning when I said

366
00:23:34,008 --> 00:23:37,166
effective Java fundamentally changed

367
00:23:37,358 --> 00:23:40,754
a lot of my thoughts about how to approach programming in

368
00:23:40,792 --> 00:23:44,430
JVM. Definitely minimizing mutability

369
00:23:44,510 --> 00:23:49,606
is one of them. I was really surprised to see this in

370
00:23:49,628 --> 00:23:54,626
the book, because before that I always used to think programming

371
00:23:54,658 --> 00:23:57,870
in Java is pretty much about mutability.

372
00:23:58,050 --> 00:24:02,598
However, reading this really changed

373
00:24:02,774 --> 00:24:06,346
my thought process and under that point

374
00:24:06,448 --> 00:24:10,140
the book talks about it gives list of

375
00:24:11,090 --> 00:24:15,050
a checklist how to make a class immutable,

376
00:24:15,130 --> 00:24:18,254
which is long enough as you would see.

377
00:24:18,372 --> 00:24:22,202
Usually what happens when such a prescription is given to the developers

378
00:24:22,266 --> 00:24:25,694
is that they happily ignore this, right? They don't

379
00:24:25,822 --> 00:24:29,986
implement that. That was these challenge happened with

380
00:24:30,168 --> 00:24:34,062
Java. So let's see how modern

381
00:24:34,126 --> 00:24:37,794
JVM languages like Groovy and Kotlin overcome

382
00:24:37,842 --> 00:24:41,574
this. Let's start with groovy in this case, as you would see,

383
00:24:41,772 --> 00:24:46,086
I could go and take

384
00:24:46,108 --> 00:24:49,734
the Java implementation and reuse it in groovy.

385
00:24:49,782 --> 00:24:53,514
But again I'll have to write a lot of code. And there

386
00:24:53,552 --> 00:24:57,660
is second challenge that the constructor has

387
00:24:58,590 --> 00:25:01,802
so many fields here, and in order to invoke

388
00:25:01,866 --> 00:25:05,278
that I have to remember the order of

389
00:25:05,364 --> 00:25:09,050
these parameters, which is like the second challenge,

390
00:25:09,130 --> 00:25:12,890
in addition to making fields final,

391
00:25:13,060 --> 00:25:17,214
et cetera. So groovy provides can est transformation

392
00:25:17,262 --> 00:25:20,706
which is called immutable here. So I apply that to

393
00:25:20,728 --> 00:25:24,098
my class rectangle and

394
00:25:24,264 --> 00:25:28,294
now all the fields are made final and

395
00:25:28,332 --> 00:25:32,214
there is no setters, there is only getter and

396
00:25:32,412 --> 00:25:35,922
the way in which I invoke the constructor.

397
00:25:35,986 --> 00:25:39,626
Also you could use something like in the

398
00:25:39,728 --> 00:25:43,082
named argument style, like length as

399
00:25:43,136 --> 00:25:48,266
ten and breadth as five. With this you really don't have to remember

400
00:25:48,448 --> 00:25:51,578
the order of parameters.

401
00:25:51,754 --> 00:25:55,322
Let's see how this works under these hood in groovy.

402
00:25:55,386 --> 00:25:58,734
So if you look at the generated code

403
00:25:58,852 --> 00:26:02,694
by groovy compiler, you would see that both length and breadth

404
00:26:02,762 --> 00:26:06,174
were made final and it generated

405
00:26:06,302 --> 00:26:09,150
regular constructor as expected.

406
00:26:09,310 --> 00:26:13,566
Note that it created constructor which takes a java util

407
00:26:13,598 --> 00:26:16,338
map as the argument.

408
00:26:16,514 --> 00:26:20,770
That's how my named argument style

409
00:26:20,850 --> 00:26:25,014
works. So whenever, especially you say you provide the

410
00:26:25,052 --> 00:26:29,254
named argument kind of syntax under the hood, it is converted

411
00:26:29,382 --> 00:26:33,290
to map and map constructor

412
00:26:33,630 --> 00:26:37,690
gets called. That's how groovy achieves

413
00:26:38,590 --> 00:26:42,698
not remembering the argument order part. Let's see

414
00:26:42,784 --> 00:26:46,362
what Kotlin does, which is very similar, but there is a slight

415
00:26:46,426 --> 00:26:49,774
change there. Of course you will have to use, I mean, by making

416
00:26:49,812 --> 00:26:53,578
it a data class you get immutability in

417
00:26:53,604 --> 00:26:57,726
addition to equals and hash code, what we saw in the beginning.

418
00:26:57,838 --> 00:27:01,134
But what happens is that again you would see the generate

419
00:27:01,182 --> 00:27:04,510
making the field final having only getters,

420
00:27:04,590 --> 00:27:08,226
no setters, and in this case you would see the regular constructs.

421
00:27:08,258 --> 00:27:12,082
You won't see a map constructor with the map argument

422
00:27:12,146 --> 00:27:15,686
here. But what happens is that whenever you invoke in

423
00:27:15,708 --> 00:27:19,674
a named argument style in this I say length 20 and

424
00:27:19,872 --> 00:27:23,174
breadth ten. Note that compiler

425
00:27:23,222 --> 00:27:26,938
took care of rearranging and calling the

426
00:27:26,944 --> 00:27:30,318
constructor in the right order. So that's the difference

427
00:27:30,404 --> 00:27:34,302
between Groovy and Kotlin. In groovy. What happened

428
00:27:34,356 --> 00:27:38,254
is it was map constructor, and in this

429
00:27:38,292 --> 00:27:41,946
case compiler took care of rearranging or rather deciding

430
00:27:41,978 --> 00:27:46,542
the order based on the named arguments what you providing

431
00:27:46,686 --> 00:27:50,046
to it. So ac transformation

432
00:27:50,238 --> 00:27:54,226
again is a predominant technique used in groovy as

433
00:27:54,328 --> 00:27:58,166
you would see repeatedly. And syntactic sugar is that

434
00:27:58,348 --> 00:28:01,842
of providing a named argument style

435
00:28:01,906 --> 00:28:05,894
in turn results in a map argument. That's what

436
00:28:05,932 --> 00:28:09,210
happens. That's a syntactic sugar and in

437
00:28:09,360 --> 00:28:13,254
Kotlin you would see the compiler

438
00:28:13,382 --> 00:28:16,698
doing the work and the area that

439
00:28:16,784 --> 00:28:20,370
this really helps is the readability aspect.

440
00:28:20,470 --> 00:28:24,682
Well it's just time for another question. What do you think is these golden

441
00:28:24,746 --> 00:28:28,670
hammer with respect to Java the language?

442
00:28:29,490 --> 00:28:32,378
Well most of you would have guessed it right,

443
00:28:32,484 --> 00:28:35,330
it's inheritance, right people,

444
00:28:35,480 --> 00:28:39,774
or I would say inheritance is the number one abused

445
00:28:39,822 --> 00:28:43,426
feature in Java language. So effective Java says

446
00:28:43,528 --> 00:28:47,814
favor composition over inheritance and

447
00:28:48,012 --> 00:28:51,350
let's take an example. So imagine I

448
00:28:51,420 --> 00:28:54,742
have a list of string here

449
00:28:54,796 --> 00:28:58,522
which I want to be considered as like phone

450
00:28:58,576 --> 00:29:02,490
numbers. So I want to perform all the operations that

451
00:29:02,560 --> 00:29:06,538
are available in a list. In addition to that

452
00:29:06,704 --> 00:29:11,290
I want it to have a few more operations

453
00:29:11,730 --> 00:29:15,646
like say I want to check if it is like a

454
00:29:15,668 --> 00:29:19,726
particular phone number belongs to indian. So what

455
00:29:19,828 --> 00:29:23,090
I could do is how would I design these

456
00:29:23,240 --> 00:29:27,266
phone numbers type, the first thought usually comes is

457
00:29:27,368 --> 00:29:31,362
okay, array list has all the implementations of list

458
00:29:31,416 --> 00:29:34,974
operations, why not I extend from array list and add

459
00:29:35,032 --> 00:29:38,198
that additional one method which I need.

460
00:29:38,284 --> 00:29:41,942
But if you look at it closely, right. The case

461
00:29:41,996 --> 00:29:45,446
for using inheritance is typically substitutability which

462
00:29:45,468 --> 00:29:48,810
is like Liskov substitution principle.

463
00:29:49,310 --> 00:29:52,726
These consumer doesn't have to know the details without knowing

464
00:29:52,758 --> 00:29:56,310
that it gets a common contract or interface

465
00:29:56,390 --> 00:30:00,070
and they can invoke with these different types of

466
00:30:00,240 --> 00:30:04,910
behavior getting executed. Not really to reuse

467
00:30:05,650 --> 00:30:09,390
something is available in case class in the check

468
00:30:09,460 --> 00:30:12,942
class. So typically the option is to use

469
00:30:13,076 --> 00:30:16,910
composition in this case. But you would know that writing a composition

470
00:30:16,990 --> 00:30:20,494
would involve typically writing lot of WordPress

471
00:30:20,542 --> 00:30:24,270
code when it comes to Java. Let's take these case of groovy.

472
00:30:24,350 --> 00:30:28,246
What you could do is you could use the delegate at

473
00:30:28,348 --> 00:30:31,734
delegate ast transformation. Now I have

474
00:30:31,772 --> 00:30:35,222
defined an instance variable called

475
00:30:35,276 --> 00:30:39,986
phone numbers of type list which is marked as delegate

476
00:30:40,098 --> 00:30:43,530
and whatever any other custom

477
00:30:43,600 --> 00:30:47,194
methods. What I need, I can write it

478
00:30:47,232 --> 00:30:51,294
inside the class. So now what happens is that even though my

479
00:30:51,332 --> 00:30:54,782
class four numbers does not implement any

480
00:30:54,836 --> 00:30:58,586
list methods on its own due to the delegate

481
00:30:58,618 --> 00:31:02,422
instruction, compiler will make sure that it generates the necessary

482
00:31:02,506 --> 00:31:06,830
code that is required to delegate into the realist

483
00:31:06,910 --> 00:31:10,558
implementation. That's what happens in groovy.

484
00:31:10,654 --> 00:31:14,206
And let's quickly check Kotlin.

485
00:31:14,238 --> 00:31:18,738
Kotlin also provides a very similar feature.

486
00:31:18,834 --> 00:31:22,950
So you would use the delegate like using that by

487
00:31:23,100 --> 00:31:27,366
keyword. That's what we are using it here. And when

488
00:31:27,388 --> 00:31:31,850
it comes to composition there is also a composition of

489
00:31:32,000 --> 00:31:36,006
behavior, something like called as trait

490
00:31:36,118 --> 00:31:39,190
in groovy which also is very much applicable.

491
00:31:39,270 --> 00:31:43,226
But I'll not be going to the details of composing

492
00:31:43,258 --> 00:31:47,098
through traits. So again groovy supports

493
00:31:47,274 --> 00:31:50,490
this feature with the ASD transformation.

494
00:31:50,570 --> 00:31:53,822
And essentially we need to

495
00:31:53,876 --> 00:31:57,666
make sure that developer doesn't have to write, or the language has

496
00:31:57,688 --> 00:32:01,666
to make sure that developers don't have to write a lot of code to

497
00:32:01,848 --> 00:32:05,606
achieve some simple tasks. In that case they

498
00:32:05,628 --> 00:32:09,158
might be discouraged, whereas if you simplify things for them,

499
00:32:09,244 --> 00:32:13,254
they might be really encouraged towards embracing good

500
00:32:13,292 --> 00:32:16,886
practices. Right, because the moment you say doing

501
00:32:17,068 --> 00:32:20,714
right thing is easy and doing

502
00:32:20,752 --> 00:32:24,762
the right thing is difficult and the wrong thing is easy, people might

503
00:32:24,816 --> 00:32:27,942
choose these wrong way, which is why we should be careful.

504
00:32:28,006 --> 00:32:31,606
And I'm happy that modern languages are really helping

505
00:32:31,638 --> 00:32:35,422
developers embrace good practices. Now let me conclude by

506
00:32:35,476 --> 00:32:38,846
summarizing the takeaways. Well, as you would

507
00:32:38,868 --> 00:32:42,942
have noticed that some of the effective Java suggestions

508
00:32:43,006 --> 00:32:47,582
are already baked into the language like Groovy and Kotlin,

509
00:32:47,726 --> 00:32:52,082
making it easy for the developers because that's available right

510
00:32:52,216 --> 00:32:55,622
out of the box. I understand that Java is also

511
00:32:55,676 --> 00:32:59,240
slowly catching up something like records for

512
00:33:00,010 --> 00:33:03,240
data classes. Kotlin what we saw,

513
00:33:03,770 --> 00:33:07,554
those are coming up. I mean these are already there,

514
00:33:07,612 --> 00:33:10,780
but not yet in the LTS version as such.

515
00:33:11,470 --> 00:33:15,020
So that's one of these benefit what

516
00:33:15,390 --> 00:33:19,066
you would see readily. And another aspect what

517
00:33:19,088 --> 00:33:22,558
we saw is that compiler generated code is

518
00:33:22,644 --> 00:33:29,818
much better than IDE generated because it's

519
00:33:29,834 --> 00:33:34,014
my firm belief that any practice that assumes

520
00:33:34,062 --> 00:33:37,326
that code does not change is fundamentally flawed

521
00:33:37,358 --> 00:33:40,834
in software development, because we know change is the only

522
00:33:40,872 --> 00:33:44,766
thing that is constant. If you use IDE to generate

523
00:33:44,798 --> 00:33:48,706
the code, you may not get an opportunity, or the IDE doesn't

524
00:33:48,738 --> 00:33:52,486
get an opportunity to update the code right, you will have to do it yourself.

525
00:33:52,668 --> 00:33:56,422
Whereas whenever you make a change, obviously you're going to compile your

526
00:33:56,476 --> 00:34:00,186
code. Compiler can regenerate the

527
00:34:00,208 --> 00:34:03,674
code as per these changes you have made.

528
00:34:03,792 --> 00:34:07,994
That's why I believe these

529
00:34:08,032 --> 00:34:11,862
days it's much better to favor compiler generated

530
00:34:11,926 --> 00:34:15,806
code than using the id generated code. And we

531
00:34:15,828 --> 00:34:19,850
have saw several examples where copying

532
00:34:19,930 --> 00:34:23,238
implementation from usage

533
00:34:23,274 --> 00:34:27,550
of effective Java, like the Java code into groovy or Kotlin,

534
00:34:27,710 --> 00:34:31,022
might not be the best practice. You may fall into traps.

535
00:34:31,086 --> 00:34:35,178
So understanding the idiomatic approach in these languages

536
00:34:35,294 --> 00:34:39,014
is really really important to be effective. And with

537
00:34:39,052 --> 00:34:43,074
several examples I'm sure you have understood that programming

538
00:34:43,122 --> 00:34:47,010
languages can really reduce these friction to implement

539
00:34:47,170 --> 00:34:50,870
good practices by making developers really

540
00:34:51,020 --> 00:34:54,730
productivity. And with this we saw that

541
00:34:54,880 --> 00:34:59,338
Kotlin and groovy in several cases achieve the same value

542
00:34:59,504 --> 00:35:03,690
with different set of approaches or different techniques,

543
00:35:04,530 --> 00:35:08,222
which really helps a developer to understand that there could be really

544
00:35:08,276 --> 00:35:12,026
multiple right solution. There's nothing like one perfect solution.

545
00:35:12,138 --> 00:35:15,710
So always what fits better in your context.

546
00:35:15,790 --> 00:35:20,034
You can go and pick one of such solutions which

547
00:35:20,072 --> 00:35:24,414
is really thing to consider when you are designing

548
00:35:24,462 --> 00:35:28,038
anything. And very important, the way we code

549
00:35:28,124 --> 00:35:31,734
right, is not just influenced by the

550
00:35:31,772 --> 00:35:35,334
language in which we write the code, but also depends on

551
00:35:35,452 --> 00:35:38,920
our knowledge of other languages, which will really

552
00:35:39,370 --> 00:35:43,446
open our mind towards new possibilities and new

553
00:35:43,548 --> 00:35:47,126
design. So even if you're not using Kotlin

554
00:35:47,158 --> 00:35:51,082
Groovy or any other language for your day to day work, knowing those languages

555
00:35:51,146 --> 00:35:55,098
will definitely help you to come up with better designs.

556
00:35:55,194 --> 00:35:58,810
And one thing what we saw is that while effective Java

557
00:35:58,890 --> 00:36:02,410
in the beginning was very, very helpful for

558
00:36:02,500 --> 00:36:06,002
Java developers to learn better ways of writing their

559
00:36:06,056 --> 00:36:09,938
Java code. But then what happened later

560
00:36:10,024 --> 00:36:14,958
is that these

561
00:36:15,144 --> 00:36:19,222
effective Java ideas helped language designers to

562
00:36:19,276 --> 00:36:22,966
develop languages in better ways. And today, as a

563
00:36:22,988 --> 00:36:25,750
developer, when you use these languages,

564
00:36:26,170 --> 00:36:29,606
I think an important question to ask is like can

565
00:36:29,628 --> 00:36:33,526
we use effective Java as litmus test for

566
00:36:33,628 --> 00:36:37,366
modern JVM languages? What do you think? With that, I hope I

567
00:36:37,388 --> 00:36:41,214
managed to give you a few thoughts to ponder up on later and you

568
00:36:41,252 --> 00:36:44,814
found them useful. I would like to thank the organizers of Conf

569
00:36:44,852 --> 00:36:47,966
42 Java for providing me this opportunity. Thank you

570
00:36:47,988 --> 00:36:49,530
one and all and happy coding.

