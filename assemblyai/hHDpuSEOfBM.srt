1
00:01:45,770 --> 00:01:49,198
Hello, thank you for attending Devsecops 2023. It's a real pleasure to

2
00:01:49,204 --> 00:01:52,638
be here. And today we have a talk called oops, there is somebody in

3
00:01:52,644 --> 00:01:56,206
my package manager hands, somebody is us. And we'll show you

4
00:01:56,228 --> 00:01:59,694
how to get into package managers. And if you're not familiar with

5
00:01:59,732 --> 00:02:03,486
the notion of package manager titled simply estimated that

6
00:02:03,508 --> 00:02:07,218
92% of all commercial software are using open source composer.

7
00:02:07,234 --> 00:02:10,342
So you need a way to manage these components, you need a way to install

8
00:02:10,396 --> 00:02:14,066
them, to update them, even to list them so you are not missing

9
00:02:14,098 --> 00:02:17,486
any of them. And this is something that we call package

10
00:02:17,538 --> 00:02:20,806
managers. And usually we have specific package managers

11
00:02:20,838 --> 00:02:25,334
depending on the current ecosystem. So for PHP developers

12
00:02:25,382 --> 00:02:28,694
are going to have PHP package managers for Rust,

13
00:02:28,742 --> 00:02:32,010
they will have a different one for all the rust packages.

14
00:02:32,930 --> 00:02:36,734
And today we're only going to focus on package managers for

15
00:02:36,772 --> 00:02:39,854
developers. So if you know a bit about

16
00:02:39,892 --> 00:02:43,214
systems, you will know that, I don't know on Ubuntu you may

17
00:02:43,412 --> 00:02:46,814
use DPKG or Apt to pull system packages,

18
00:02:46,862 --> 00:02:50,174
but this is not what we're going to look at today because it works slightly

19
00:02:50,222 --> 00:02:54,034
differently for software packages. It's most of the time things like front

20
00:02:54,072 --> 00:02:57,918
end libraries, back end

21
00:02:58,104 --> 00:03:02,040
APIs to interface with payment providers, any kind of

22
00:03:03,050 --> 00:03:06,514
things and features that you may need. And if you're a developer,

23
00:03:06,562 --> 00:03:09,994
you have probably already seen one of these logos. There is

24
00:03:10,032 --> 00:03:13,078
Python with Peep, there is Ruby with Ruby jams.

25
00:03:13,094 --> 00:03:16,634
There is PHP with pair and composer. On the JavaScript road,

26
00:03:16,672 --> 00:03:20,666
there is boa for Frontend and Yarn, and NPM. There is

27
00:03:20,688 --> 00:03:25,002
even one for latex called Mctech. So plenty of package managers

28
00:03:25,146 --> 00:03:27,710
for every one of these small ecosystems.

29
00:03:28,050 --> 00:03:31,434
And there is another notion that needs to be, to be known,

30
00:03:31,482 --> 00:03:34,846
which is something that we call supply chain. And it regroups all the

31
00:03:34,868 --> 00:03:38,322
processes, tools, software, which are part of the life of product.

32
00:03:38,376 --> 00:03:41,586
It's not only for software, it could be anything like if

33
00:03:41,608 --> 00:03:44,814
you have a physical product, shipping would be part of its supply chain.

34
00:03:44,942 --> 00:03:48,102
And as a result, software dependencies. It's only a small

35
00:03:48,156 --> 00:03:52,070
link, because if you push things really

36
00:03:52,140 --> 00:03:55,890
deeply, like even your laptop on which you're developing your software

37
00:03:55,970 --> 00:03:59,434
is part of its supply chain. So it's basically anything that searches your

38
00:03:59,472 --> 00:04:03,462
software that's part of its supply chain. Pretty famous KCD

39
00:04:03,526 --> 00:04:07,594
drawing on supply chain is this one. So it

40
00:04:07,632 --> 00:04:11,638
displays something that's called all modern digital infrastructure,

41
00:04:11,734 --> 00:04:15,534
made of small blocks put all together on top of each other.

42
00:04:15,652 --> 00:04:19,146
And one of the blocks that's really crucial for this modern

43
00:04:19,178 --> 00:04:23,562
infrastructure to work is a small blog that's called and it's written

44
00:04:23,706 --> 00:04:27,486
the project. Some random person in Nebraska has been Franklin maintaining

45
00:04:27,518 --> 00:04:31,202
since 20 or three. And in our case, this small project

46
00:04:31,336 --> 00:04:35,102
is going to be the back end servers behind package managers.

47
00:04:35,246 --> 00:04:38,806
And this backend servers is necessary because when you install a

48
00:04:38,828 --> 00:04:42,402
package, you install it by name hands. You need to have a way to tie

49
00:04:42,466 --> 00:04:46,418
this package name, this identifier, for instance, auto package

50
00:04:46,514 --> 00:04:50,086
to its location. So it could be HTTPs to some random server.

51
00:04:50,118 --> 00:04:53,900
It could be a GitHub repository that you need to clone, could be anything

52
00:04:54,590 --> 00:04:57,866
that the package manager supports. So if you

53
00:04:57,888 --> 00:05:01,678
composer the backend server that makes this association, you're going

54
00:05:01,684 --> 00:05:05,962
to be able to change this association between the name and destination, and attackers

55
00:05:06,026 --> 00:05:10,030
are going to be able to force you to download completely unintended

56
00:05:11,250 --> 00:05:15,022
archives and tofu dependencies. And it's likely to lead

57
00:05:15,076 --> 00:05:18,834
in the execution of arbitrary code, as you will run the code of this

58
00:05:18,872 --> 00:05:22,862
dependency at some point in time. So let's do it for a quick presentation,

59
00:05:23,006 --> 00:05:26,162
I'm going to be helped by Paul today. Paul is going to make the second

60
00:05:26,216 --> 00:05:30,038
half of the talk, and my name is Thomas and we're both primitive researchers in

61
00:05:30,044 --> 00:05:33,526
the sonar research and development team. We helped drive innovation by

62
00:05:33,548 --> 00:05:37,574
finding zero days in popular open source software. And if you don't know

63
00:05:37,612 --> 00:05:41,038
Sona, our mission is to enable developers

64
00:05:41,074 --> 00:05:45,046
to write clean code that means that are free of functional bugs

65
00:05:45,078 --> 00:05:48,970
and security vulnerabilities. And you probably know one of our products.

66
00:05:49,120 --> 00:05:52,806
We have Somacube doing this analysis on premise. We have Somacloud

67
00:05:52,838 --> 00:05:56,666
doing it in the cloud and Sonarlint doing it in your code editor.

68
00:05:56,858 --> 00:06:00,958
And for today we're going to show you the result of a research on

69
00:06:01,044 --> 00:06:04,446
security of packet managers and the backend servers for the

70
00:06:04,468 --> 00:06:07,826
PHP ecosystem. Because that's the one for which we have the most interesting

71
00:06:07,928 --> 00:06:11,102
results. And we're going to start by taking over packages,

72
00:06:11,246 --> 00:06:14,782
which is the main repository behind composer,

73
00:06:14,846 --> 00:06:17,790
the most popular package manager for PHP.

74
00:06:17,870 --> 00:06:20,598
And we did it twice. So we're going to show you how we did it.

75
00:06:20,684 --> 00:06:24,146
We're then going to present how we did it for pair, and we're

76
00:06:24,178 --> 00:06:27,910
going to try to give a few insight on how to try to reduce

77
00:06:28,250 --> 00:06:31,834
the impact of these attacks and try to prevent them in the future.

78
00:06:32,032 --> 00:06:35,190
So let's start by looking at composer and packages.

79
00:06:35,350 --> 00:06:38,710
Composer is the most popular PHP package manager.

80
00:06:38,790 --> 00:06:42,758
It's used by virtually any company running PHP somewhere.

81
00:06:42,854 --> 00:06:46,566
Like if you have a PHP application somewhere, you're probably

82
00:06:46,688 --> 00:06:50,394
using composer to fetch, install and update all its required

83
00:06:50,442 --> 00:06:53,866
dependencies. And it's using a central registry.

84
00:06:53,978 --> 00:06:57,826
So like we say, doing the name and the location of the

85
00:06:57,848 --> 00:07:00,910
packages hands its registry. It's called packages.

86
00:07:01,070 --> 00:07:05,210
Both projects, composer and packages, they are all open source and written in PHP,

87
00:07:05,310 --> 00:07:08,806
and they maintain and also public instance is maintained by a

88
00:07:08,828 --> 00:07:13,234
company called private packages, which is providing private hosting

89
00:07:13,282 --> 00:07:15,190
for packages.

90
00:07:16,170 --> 00:07:20,130
And to try to give a very rough estimate

91
00:07:20,210 --> 00:07:23,626
of composer architecture. So this is very unscientific, don't do

92
00:07:23,648 --> 00:07:26,794
it at home. But it's just to give an idea of how popular this

93
00:07:26,832 --> 00:07:29,914
is. It's kind of

94
00:07:29,952 --> 00:07:33,754
known that PHP is behind 78% of the Internet, which is still

95
00:07:33,792 --> 00:07:37,518
a got, even if its popularity kind of decreased for some time.

96
00:07:37,604 --> 00:07:41,470
It's not really back hands. WordPress alone is

97
00:07:41,540 --> 00:07:44,874
43% of that, and composer is not required

98
00:07:44,922 --> 00:07:48,786
to run it. So we have to remove this 43% of

99
00:07:48,808 --> 00:07:52,894
these 78%. And so we also did an estimation

100
00:07:52,942 --> 00:07:56,510
of how many PHP projects would use composer,

101
00:07:56,590 --> 00:08:00,486
and we found something like 70%. So we can say that there

102
00:08:00,508 --> 00:08:04,146
is a total of maybe 20% of world servers

103
00:08:04,338 --> 00:08:08,322
running composer in a well, another hands. This small graph

104
00:08:08,386 --> 00:08:11,962
comes from the official packages statistics, and we can see that

105
00:08:12,016 --> 00:08:15,782
there are monthly 2 billion packages which are downloaded from packages.

106
00:08:15,926 --> 00:08:19,206
So it's still pretty heavy use of these package

107
00:08:19,238 --> 00:08:22,734
managers. Even if everybody tried to tell you that PHP is dead, that's really not

108
00:08:22,772 --> 00:08:25,902
the case. And in the past

109
00:08:25,956 --> 00:08:29,278
years, we achieved to compromise packages twice. So this

110
00:08:29,364 --> 00:08:33,326
server, this back end server, we did twice. First time

111
00:08:33,348 --> 00:08:37,362
in April 2021 hands, second time in April 2022, a year

112
00:08:37,416 --> 00:08:40,562
later. And these two cpes, these are two very

113
00:08:40,616 --> 00:08:43,666
similar vulnerabilities in composer that we found. So we

114
00:08:43,688 --> 00:08:47,560
discovered and reported responsibly reported this vulnerability to

115
00:08:47,930 --> 00:08:51,958
the maintainers of composer and packages. So let's dive into it.

116
00:08:52,124 --> 00:08:56,578
First thing, when you get the packages interface,

117
00:08:56,674 --> 00:09:00,386
you're going to see this small page to submit a new package.

118
00:09:00,498 --> 00:09:03,974
And it's really simple. There is only one field where you put the URL

119
00:09:04,022 --> 00:09:07,770
of your package, and then you run check. It's going to check if this is

120
00:09:07,840 --> 00:09:11,434
indeed packages or composer package with

121
00:09:11,472 --> 00:09:15,102
the right format, the right manifest file, and then it's going to try to import

122
00:09:15,156 --> 00:09:18,074
it into package registry afterward.

123
00:09:18,122 --> 00:09:22,046
Any developer is going to be able to import this package and use

124
00:09:22,068 --> 00:09:26,098
it as any other. And to

125
00:09:26,184 --> 00:09:30,066
do this import, like to clone this folder, packages is

126
00:09:30,088 --> 00:09:33,826
going to RNS composer formless operation. It's going to check if

127
00:09:33,848 --> 00:09:37,458
the project contains a file called composer JSON, which is manifest,

128
00:09:37,554 --> 00:09:40,690
and it's also going to clone this repository,

129
00:09:40,850 --> 00:09:44,454
pass the manifest, create it into the database, and add the right

130
00:09:44,492 --> 00:09:48,018
metadata files. So next time somebody runs composer,

131
00:09:48,114 --> 00:09:51,942
they will be able to find this package and download the right source.

132
00:09:52,086 --> 00:09:55,210
And when we say that the remote repository is cloned,

133
00:09:55,790 --> 00:09:59,670
it's done with the logic that's already implemented in composer,

134
00:09:59,750 --> 00:10:03,406
say use composer as a library to not have to

135
00:10:03,428 --> 00:10:07,594
implement it again. And for every single supported

136
00:10:07,642 --> 00:10:11,166
version control implementation, it could be Maclio, that could be got, it could

137
00:10:11,188 --> 00:10:15,506
be subversion. It will check if it's an honor host because if the oil points

138
00:10:15,608 --> 00:10:18,894
to GitHub, it's always going to use git because they know it's

139
00:10:18,942 --> 00:10:22,546
ported. But for the other one they may have similar

140
00:10:22,648 --> 00:10:25,914
tricks. And is it matching the expected format?

141
00:10:25,982 --> 00:10:29,538
Like is there something that's missing? Is it missing

142
00:10:29,554 --> 00:10:33,414
to got at the end? Is it already present?

143
00:10:33,612 --> 00:10:36,822
So there is some small logic checks in there

144
00:10:36,956 --> 00:10:40,458
and then it's doing some further verification on the remote end.

145
00:10:40,544 --> 00:10:44,522
And to not implement everything in PHP because it needs

146
00:10:44,576 --> 00:10:48,118
you to understand all this protocol work. And it would be like it's

147
00:10:48,134 --> 00:10:51,306
already done, like binaries that

148
00:10:51,328 --> 00:10:53,980
we are all using, they already would do it for us.

149
00:10:54,290 --> 00:10:58,910
Simply run git remote hands hands, the URL

150
00:10:59,330 --> 00:11:03,142
that you just provided. Same with the version they run svN info

151
00:11:03,226 --> 00:11:06,674
with the URL you just provided, and same with

152
00:11:06,712 --> 00:11:09,330
Ha, which is a mercurial client.

153
00:11:09,670 --> 00:11:13,538
And if you look at these lines of code, there is something called process

154
00:11:13,624 --> 00:11:17,540
executor escape. So it's an escape function.

155
00:11:18,010 --> 00:11:21,954
And the role of this escape function is to prevent command injection

156
00:11:22,002 --> 00:11:25,602
vulnerabilities. If you're not familiar with command injection vulnerabilities,

157
00:11:25,666 --> 00:11:28,478
I'm going to quickly explain it to you and it's going to be really useful

158
00:11:28,514 --> 00:11:32,086
for what's coming next. So in that case, if in the controlled

159
00:11:32,118 --> 00:11:34,970
variable it's pseudocult, don't worry about the syntax.

160
00:11:36,910 --> 00:11:40,426
We put this weird sequence which is dollar and parentheses and

161
00:11:40,448 --> 00:11:44,286
dates. And in shell script, this sequence of dollar and

162
00:11:44,308 --> 00:11:48,206
parentheses is going to execute what's within the parentheses, in that

163
00:11:48,228 --> 00:11:52,046
case date, and put as a result as a string in

164
00:11:52,068 --> 00:11:56,350
the current script. So in the case, if you execute,

165
00:11:59,350 --> 00:12:02,558
it's going to take AJ hands PhP and our sequence.

166
00:12:02,654 --> 00:12:06,046
So it's going to see this comment abstraction sequence and it's

167
00:12:06,078 --> 00:12:10,294
going to execute it first, and then the

168
00:12:10,332 --> 00:12:13,926
resulting string will be used in the final command and it's going

169
00:12:13,948 --> 00:12:17,398
to run AJ identify. Tuesday, August 2 August 2

170
00:12:17,484 --> 00:12:21,178
it's pretty unsafe because date could have been anything else,

171
00:12:21,264 --> 00:12:25,194
it could have been rf star to

172
00:12:25,232 --> 00:12:28,714
remove everything from the file system. So to prevent that

173
00:12:28,752 --> 00:12:32,062
kind of comment injection, you need to use

174
00:12:32,116 --> 00:12:35,838
escape functions. And this escape function will surround data

175
00:12:35,924 --> 00:12:39,694
with single quotes. So the shell will see it

176
00:12:39,732 --> 00:12:43,534
as a string, literal and not as something it should try to

177
00:12:43,572 --> 00:12:47,026
evaluate in that case. Okay, gentify hands

178
00:12:47,048 --> 00:12:50,898
between single quotes. Our injection and it's going to just

179
00:12:50,984 --> 00:12:54,270
run AJ identify hands a string

180
00:12:54,350 --> 00:12:58,198
and the date command wouldn't be executed. But what happens

181
00:12:58,284 --> 00:13:02,326
if I try to put something like an

182
00:13:02,348 --> 00:13:05,974
option like can I maybe inject arguments? That case,

183
00:13:06,012 --> 00:13:10,282
the shell is going to run AJ identify and help

184
00:13:10,336 --> 00:13:13,766
in that case. And yes, it's going to pass the argument ALP

185
00:13:13,798 --> 00:13:17,370
to identify. And if you trace on the shell,

186
00:13:17,710 --> 00:13:21,742
the single quotes don't matter because the shell will remove the single

187
00:13:21,796 --> 00:13:25,434
quotes and do the call correctly with three arguments,

188
00:13:25,482 --> 00:13:28,480
AJ identify and help.

189
00:13:29,250 --> 00:13:32,670
And something interesting in that case, displaying the help is

190
00:13:32,740 --> 00:13:36,478
not so helpful as an attacker. But if you start looking

191
00:13:36,564 --> 00:13:39,906
through the material manual, you will see that it's possible to

192
00:13:39,928 --> 00:13:43,422
create aliases with the same name as the existing commands,

193
00:13:43,486 --> 00:13:47,254
which can override original definition. So that means that there is a way by

194
00:13:47,292 --> 00:13:50,742
passing an extra argument like something, it's already

195
00:13:50,796 --> 00:13:53,958
something we can do. In that case, we can change

196
00:13:54,044 --> 00:13:57,510
behavior of existing commands. So that's already pretty nice.

197
00:13:57,660 --> 00:14:01,818
And they also say that null, yes, can start with an exclamation point

198
00:14:01,984 --> 00:14:05,034
to make it a shell alias. So this thing would

199
00:14:05,072 --> 00:14:08,838
allow us to execute shell commands instead of the identify.

200
00:14:09,014 --> 00:14:13,082
So with a payload like config equals alias

201
00:14:13,146 --> 00:14:16,926
identify and exclamation point, we can put basically

202
00:14:17,028 --> 00:14:20,366
any shell command. So if we try to import

203
00:14:20,548 --> 00:14:24,206
a new URL whose format is

204
00:14:24,388 --> 00:14:27,886
config equals alias identify, it's going to execute arbitrary

205
00:14:27,918 --> 00:14:30,958
commands on the packages instance.

206
00:14:31,134 --> 00:14:34,434
And as a result we would be able to change

207
00:14:34,552 --> 00:14:37,410
any software dependencies that's hosted on the server.

208
00:14:37,830 --> 00:14:42,438
So that's something we reported and it was fixed with now in April 2021.

209
00:14:42,524 --> 00:14:45,926
So let's look at it. So let's start by showing you how

210
00:14:45,948 --> 00:14:49,266
we set up this test instance. So this terminal is

211
00:14:49,308 --> 00:14:53,446
root on a virtual machine at this IP address that we can ping

212
00:14:53,558 --> 00:14:57,242
from Alice, which is the attacker. So when we

213
00:14:57,296 --> 00:15:01,850
got on packages lo like local all this IP address, we reach

214
00:15:01,920 --> 00:15:05,614
the test instance, not the real one. So now Alice can go to this

215
00:15:05,652 --> 00:15:09,486
interface register as attacker like

216
00:15:09,668 --> 00:15:12,926
you could do as any other developer. And now you can go

217
00:15:12,948 --> 00:15:16,042
on the submit section and put the payload

218
00:15:16,106 --> 00:15:19,950
we just show you. So this config equals alias

219
00:15:20,030 --> 00:15:23,394
identify and then a shell command. And in that

220
00:15:23,432 --> 00:15:27,410
case, the shell command is going to be Netcat, and we're going to pipe

221
00:15:27,490 --> 00:15:30,946
all of Netcat's input output to bash

222
00:15:31,138 --> 00:15:35,202
which is going to grant Alice a remote shell

223
00:15:35,266 --> 00:15:39,110
on this host. So we can use socket to listen

224
00:15:39,260 --> 00:15:42,858
for the connection. Get back to us, we run check

225
00:15:43,024 --> 00:15:46,506
and now if we type comments like id, we're going to see that we

226
00:15:46,528 --> 00:15:50,138
run with the WW data identity. So this is

227
00:15:50,144 --> 00:15:53,726
not very interactive. So now Alice can use Python to get an

228
00:15:53,748 --> 00:15:57,054
interactive shell in this prompt. This is

229
00:15:57,092 --> 00:16:00,750
what's happening. And now as we see we have a will shell.

230
00:16:07,250 --> 00:16:11,454
And now let's authenticate. As Thomas so this is me, I'm a developer.

231
00:16:11,502 --> 00:16:14,526
I'm hosting an awesome package called stunning

232
00:16:14,558 --> 00:16:17,630
waffle on packages on this test instance.

233
00:16:17,790 --> 00:16:21,174
And as we can see there is only one version of this

234
00:16:21,212 --> 00:16:24,278
package, one release on dev main.

235
00:16:24,364 --> 00:16:28,306
So if I want to use it as a developer, I would type composer

236
00:16:28,338 --> 00:16:31,974
require and name of my username and then the name of this

237
00:16:32,012 --> 00:16:35,354
package and then it just works hands. Now I can use it.

238
00:16:35,392 --> 00:16:38,550
So it simply is playing some emojis with waffles,

239
00:16:38,630 --> 00:16:41,418
sparkles and a cook. And that's great.

240
00:16:41,504 --> 00:16:45,040
It's what I intended to have and that's why

241
00:16:45,890 --> 00:16:49,322
my package exists. But now at the same time Alice

242
00:16:49,386 --> 00:16:52,734
with this interactive shell that just add

243
00:16:52,772 --> 00:16:56,074
can go and try to modify the association

244
00:16:56,122 --> 00:16:59,838
between my name so the name of my package standing waffle

245
00:16:59,934 --> 00:17:03,774
with the source. In that case the source is a got

246
00:17:03,822 --> 00:17:06,782
repo. So if we change this JSON file,

247
00:17:06,846 --> 00:17:10,950
hands try to point to somewhere else. The next time somebody will

248
00:17:11,100 --> 00:17:14,422
use composer update or composer require. This is

249
00:17:14,556 --> 00:17:17,414
the arbitrary destination that will be fetched from.

250
00:17:17,532 --> 00:17:21,530
So in that case Alice can simply take

251
00:17:21,600 --> 00:17:25,014
a JSON file was modified beforehand,

252
00:17:25,062 --> 00:17:28,746
hands replace the one on the server by the one that

253
00:17:28,768 --> 00:17:32,170
was crafted. So now it's being replaced. And next time somebody

254
00:17:32,240 --> 00:17:35,818
types composer updates, we see that there is an update.

255
00:17:35,914 --> 00:17:39,550
And as a developer I did not push this update. So something

256
00:17:39,620 --> 00:17:43,294
happened differently. And if I run my main

257
00:17:43,412 --> 00:17:46,740
PhP file again, maybe something else will happen.

258
00:18:00,250 --> 00:18:02,954
Now let's look at how they chose to fix it.

259
00:18:03,152 --> 00:18:06,678
The only official way to fix such vulnerabilities

260
00:18:06,854 --> 00:18:10,742
is to use a dash dash sequence. And it may look a bit weird,

261
00:18:10,806 --> 00:18:14,398
but in the end it's part of the project specification and

262
00:18:14,484 --> 00:18:18,446
for any project's compliant argument passer, when you

263
00:18:18,468 --> 00:18:21,834
first encounter this, you have to ignore

264
00:18:21,882 --> 00:18:25,294
all the arguments that come next. They should be treated as appearance and not

265
00:18:25,332 --> 00:18:29,010
as arguments. So if you create a file called

266
00:18:29,160 --> 00:18:33,060
help and you try to ls help, it's not going to work because

267
00:18:33,430 --> 00:18:37,826
help is going to be treated as an argument. But if you then run ls

268
00:18:38,018 --> 00:18:43,414
space help, it's going to work because

269
00:18:43,452 --> 00:18:46,550
of support of this special argument.

270
00:18:47,130 --> 00:18:50,566
And the timeline is really cool. In that case, like when you

271
00:18:50,588 --> 00:18:53,766
report security vulnerabilities, you really wanted to get it fixed.

272
00:18:53,798 --> 00:18:57,194
And most of the time when it's so critical, you can't wait,

273
00:18:57,232 --> 00:19:00,714
you're just syncing your mails several times a day just

274
00:19:00,752 --> 00:19:04,038
to make sure you did not miss response.

275
00:19:04,134 --> 00:19:07,726
And in that case, we notified security@packages.org at

276
00:19:07,748 --> 00:19:11,406
01:00 a.m. And at 10:00 a.m. They released the odd fix on

277
00:19:11,428 --> 00:19:15,118
the public instance. That means that nobody could exploit it anymore for will

278
00:19:15,204 --> 00:19:19,010
if somebody already knows the vulnerability. And a few days after

279
00:19:19,080 --> 00:19:22,690
they released a patch version, like an official patch for composer

280
00:19:23,350 --> 00:19:26,526
and so also for packages, and they released

281
00:19:26,558 --> 00:19:29,846
the same day an official announcement and one year

282
00:19:29,868 --> 00:19:33,206
left later we're like okay, did we miss something?

283
00:19:33,308 --> 00:19:36,546
Is there anything left on packages? So let's

284
00:19:36,578 --> 00:19:39,782
try to identify a new vulnerability in packages just for fun.

285
00:19:39,916 --> 00:19:43,414
And a good thing is we are already familiar with this code base. Like we

286
00:19:43,452 --> 00:19:47,046
already paid the initial cost of entry of approaching

287
00:19:47,078 --> 00:19:51,494
a new target. We already contributed to the patch. We looked for bypasses,

288
00:19:51,622 --> 00:19:55,370
which mean that we come with the same set of assumptions and biases,

289
00:19:55,530 --> 00:19:58,766
but maybe there is still something. So what

290
00:19:58,788 --> 00:20:02,510
did we miss? The first thing, like we already

291
00:20:02,580 --> 00:20:04,750
know that vcs driver,

292
00:20:05,410 --> 00:20:09,214
there are wrappers around all dictionary command that's being run. So the git

293
00:20:09,262 --> 00:20:11,854
command, Sebastian command, Mercury Command,

294
00:20:11,982 --> 00:20:15,186
and this is where the first vulnerability happened,

295
00:20:15,288 --> 00:20:18,878
because they have to invoke third party external commands.

296
00:20:18,894 --> 00:20:22,446
And that's really risky either because you can introduce

297
00:20:22,638 --> 00:20:25,794
command injection or argument injections. So it's

298
00:20:25,842 --> 00:20:29,474
still target of choice for simul bugs. And is there any invocation

299
00:20:29,522 --> 00:20:33,254
without dash dash left that we knew that maybe that could be available to argument

300
00:20:33,302 --> 00:20:37,018
injections. And when we're using this code we noticed a

301
00:20:37,024 --> 00:20:40,438
few calls without this dash dash. So at risk of argument injection,

302
00:20:40,534 --> 00:20:43,950
and one of them looks really familiar because we

303
00:20:44,020 --> 00:20:47,578
tried to send a patch to correct these lines,

304
00:20:47,674 --> 00:20:51,342
but in fact it was removed from a suggestions like they

305
00:20:51,396 --> 00:20:54,954
explicitly removed these two dashes for the got

306
00:20:55,002 --> 00:20:58,690
and for the mercurial invocation and they said yeah, remove fix

307
00:20:58,760 --> 00:21:02,386
because it was breaking a feature and the culprit is in a

308
00:21:02,408 --> 00:21:07,138
function called get file content. So this get file content will allow for

309
00:21:07,304 --> 00:21:10,718
any wrapper around git mercurial version.

310
00:21:10,814 --> 00:21:14,566
It will allow to read a file content from the repo. So when

311
00:21:14,588 --> 00:21:17,846
you clone the repository, you don't need to have the work preview, you can

312
00:21:17,868 --> 00:21:21,334
clone a bare repository and then call this get file content

313
00:21:21,452 --> 00:21:25,340
that will call the right version control

314
00:21:25,710 --> 00:21:28,460
subcommand to get the file's content.

315
00:21:28,910 --> 00:21:32,138
And so you also can also get the file content

316
00:21:32,224 --> 00:21:35,662
at different revisions. So it could be on the main branch, or it could be

317
00:21:35,716 --> 00:21:38,830
some old historical branch, or it could be a doc branch.

318
00:21:39,410 --> 00:21:42,766
And when you run git show with the end of

319
00:21:42,788 --> 00:21:45,834
option, so with the two dashes it breaks,

320
00:21:45,882 --> 00:21:49,826
because in this comment it has special meaning that's different from the

321
00:21:49,848 --> 00:21:53,374
one of the spotic specification, and its goal is to separate

322
00:21:53,422 --> 00:21:56,578
revision from pass. And if we run git show,

323
00:21:56,664 --> 00:22:00,050
add colon composer Json, we get the content

324
00:22:00,120 --> 00:22:03,382
of composer JSOn. But if we put this, which should

325
00:22:03,436 --> 00:22:06,358
work per the project specification, there is nothing,

326
00:22:06,444 --> 00:22:10,038
it's just not working as intended. So that's why they removed

327
00:22:10,054 --> 00:22:14,330
this dash dash. And the thing is, the argument

328
00:22:14,750 --> 00:22:17,180
for call to this get file content.

329
00:22:17,710 --> 00:22:21,258
Like when the readme is being updated for display on the

330
00:22:21,264 --> 00:22:24,566
packages interface, the arguments come from composer JSON,

331
00:22:24,598 --> 00:22:28,522
so it comes from the manifest. The manifest can have a key called reADME

332
00:22:28,666 --> 00:22:32,202
to give a different reaDME than reaDME txt or ReaDME

333
00:22:32,266 --> 00:22:36,034
MD could be don't readMe md. It also works as long

334
00:22:36,072 --> 00:22:40,178
it's part of the manifest in the readme key and

335
00:22:40,264 --> 00:22:44,578
in the mercurial driver this

336
00:22:44,664 --> 00:22:48,600
value goes straight away. So it's escaped. So it's safe against

337
00:22:48,970 --> 00:22:52,338
command injections, but it's not safe against argument injections.

338
00:22:52,434 --> 00:22:55,574
So we have the exact same scenario as in the first

339
00:22:55,612 --> 00:22:59,554
vulnerability. We can add extra arguments to it. So the macro

340
00:22:59,602 --> 00:23:03,366
invocation. So to exploit it, we would need to create a project in

341
00:23:03,388 --> 00:23:07,206
a remote macro repository. We would need to set a malicious readme

342
00:23:07,238 --> 00:23:11,094
key in composer JSon. Then we would need to import package

343
00:23:11,142 --> 00:23:14,682
on packages, and we could use this vulnerability to maybe

344
00:23:14,736 --> 00:23:18,338
write an arbitrary file laboratory Php script to via

345
00:23:18,374 --> 00:23:21,982
WW packages. So under the web root and

346
00:23:22,036 --> 00:23:25,406
we can maybe try to use it to execute arbitrary PHp code,

347
00:23:25,508 --> 00:23:28,974
resulting in the same exploitation and the same impact

348
00:23:29,022 --> 00:23:32,738
as the first vulnerability researcher we presented earlier. So in

349
00:23:32,744 --> 00:23:36,226
the composer JSoN, the readme key would contain something like

350
00:23:36,328 --> 00:23:39,590
the usual config equal alias. This is a cat

351
00:23:39,660 --> 00:23:43,634
command. So we override cat and not identify.

352
00:23:43,762 --> 00:23:47,334
We put this exclamation point to say it's a shell command. And then

353
00:23:47,372 --> 00:23:51,038
we use since this other repository is icondas

354
00:23:51,074 --> 00:23:55,514
bear, we cannot just read payload sh from the local file system.

355
00:23:55,712 --> 00:23:59,478
So we use AJ mercurial client

356
00:23:59,574 --> 00:24:03,214
to read the content of a file called payload sh. We pipe it

357
00:24:03,252 --> 00:24:08,160
to the shell to execute it. And then there is a mandatory fix to

358
00:24:08,770 --> 00:24:12,330
reach the right code pass on packages so it executes

359
00:24:12,410 --> 00:24:15,802
our update when we call. So txt.

360
00:24:15,866 --> 00:24:19,566
In that case, let's see what it looked like. The setup is roughly

361
00:24:19,598 --> 00:24:23,006
the same, but this time we're going to need to host our repository somewhere.

362
00:24:23,118 --> 00:24:26,530
So I choose a source art because this is one of the only

363
00:24:26,600 --> 00:24:30,214
few mercurial hosting services that's left for free

364
00:24:30,252 --> 00:24:33,298
on the Internet. And on the right I have two windows.

365
00:24:33,474 --> 00:24:37,218
These are root shells on the packages test instance,

366
00:24:37,314 --> 00:24:40,802
and I'm trying to show and to see if the file

367
00:24:40,946 --> 00:24:44,602
main php in the web root and Tmp pond were

368
00:24:44,656 --> 00:24:48,458
created or not. And for now they still don't exist. So we're going

369
00:24:48,464 --> 00:24:52,060
to take the URL, the public URL of this repo and

370
00:24:52,510 --> 00:24:55,774
import it in packages. And in this repo we put

371
00:24:55,812 --> 00:24:59,486
composer JSon with a readme. That should remind you something, because this

372
00:24:59,508 --> 00:25:02,922
is a payload we just presented, and this is going to run payload

373
00:25:02,986 --> 00:25:06,686
sh, which is writing the output command Id in

374
00:25:06,708 --> 00:25:10,254
Tmp pond and the file main php under

375
00:25:10,292 --> 00:25:13,778
the web root. And in main Php is simply a

376
00:25:13,784 --> 00:25:17,506
Php script that will execute any command that we put into CMD

377
00:25:17,538 --> 00:25:21,400
parameter. So now let's start to

378
00:25:22,410 --> 00:25:25,638
log in and let's try to import it. So we have

379
00:25:25,644 --> 00:25:29,334
a user account, and now we simply put

380
00:25:29,372 --> 00:25:33,420
the public URL of our mercurial repository. We submit it

381
00:25:34,830 --> 00:25:38,438
and the import will happen. As for any other repository,

382
00:25:38,534 --> 00:25:42,506
nothing will go wrong for now. But as

383
00:25:42,528 --> 00:25:46,554
soon as we click update, we will reach the cut pass that was discussed

384
00:25:46,602 --> 00:25:49,690
earlier. And when the job succeeds,

385
00:25:49,850 --> 00:25:53,598
workers are starting to process all the imports. And as we see on

386
00:25:53,604 --> 00:25:57,134
the right, we have the output of the command Id in TMP

387
00:25:57,182 --> 00:26:00,946
pond, and we now have something in main Php under

388
00:26:01,048 --> 00:26:05,550
the web root. And if we try to go directly on this file

389
00:26:05,710 --> 00:26:09,206
and try to execute arbitrary commands like LS, we see

390
00:26:09,228 --> 00:26:12,806
that we have the output, and obviously with Id we get the

391
00:26:12,828 --> 00:26:16,818
same. And now we could do as interface demonstration,

392
00:26:16,914 --> 00:26:20,466
which is backdoor packages by modifying the JSON files

393
00:26:20,498 --> 00:26:23,626
of the semitad data. So now we can look at

394
00:26:23,648 --> 00:26:26,874
the timeline of this bug. So we first reported it on

395
00:26:26,912 --> 00:26:30,282
April 7 at 06:00 p.m. Which is a much better

396
00:26:30,336 --> 00:26:34,330
work hour. Then we got an acknowledgment

397
00:26:34,690 --> 00:26:38,574
like 1 hour after. So it's like pretty quick. We knew that we would

398
00:26:38,612 --> 00:26:42,826
be working on Oddfix right away. They could deploy Oddfix

399
00:26:42,858 --> 00:26:45,950
on the official packages instance the day after.

400
00:26:46,100 --> 00:26:49,726
So it's also like the most important part, like at least nobody

401
00:26:49,758 --> 00:26:53,300
could exploit it on the instant that's used by basically everybody.

402
00:26:53,670 --> 00:26:57,046
And a few days after they assigned cv did an

403
00:26:57,068 --> 00:27:00,386
official announcement to say that they did not identify any trace

404
00:27:00,418 --> 00:27:04,022
of exploitation on the brick instance except us.

405
00:27:04,156 --> 00:27:08,114
And they also released new composer versions

406
00:27:08,242 --> 00:27:11,466
to protect everybody that were trying to

407
00:27:11,488 --> 00:27:14,902
use this feature from composer and the patch.

408
00:27:15,046 --> 00:27:18,746
It was not really easy to elegantly fix it because there

409
00:27:18,768 --> 00:27:22,700
is this dash option that we need to inject so

410
00:27:23,630 --> 00:27:27,006
they couldn't put before it, otherwise it would break this

411
00:27:27,108 --> 00:27:30,702
dash option. So they simply prevented any

412
00:27:30,756 --> 00:27:34,702
branch name whose name start with a dash. It's not

413
00:27:34,756 --> 00:27:38,114
perfect, but I mean, at least it's pretty effective. So now

414
00:27:38,152 --> 00:27:42,334
Paul is going to guide you through similar vulnerabilities in another software

415
00:27:42,382 --> 00:27:46,002
package, managers for PHP called pair. Okay then,

416
00:27:46,056 --> 00:27:49,446
let's look at pair now. First of all,

417
00:27:49,628 --> 00:27:53,042
what is pair? Pair stands for PHP

418
00:27:53,106 --> 00:27:56,662
extension hands application repository, and it is the

419
00:27:56,716 --> 00:28:00,078
historical package manager of the PHP ecosystem.

420
00:28:00,274 --> 00:28:03,850
It was created in 1999, so quite old now,

421
00:28:04,000 --> 00:28:06,970
and today it's only moderately active anymore.

422
00:28:07,710 --> 00:28:11,334
Since its beginning it served almost 300 million package

423
00:28:11,382 --> 00:28:15,642
downloads, and nowadays there are roughly 50 popular

424
00:28:15,706 --> 00:28:19,274
packages. They are still being actively

425
00:28:19,322 --> 00:28:22,414
developed and published on pair, and among them

426
00:28:22,452 --> 00:28:25,502
are names like pair, console, getopt. Net,

427
00:28:25,556 --> 00:28:28,050
SMTP, and archive tar.

428
00:28:30,230 --> 00:28:33,790
First of all, before we look into the vulnerabilities of pair,

429
00:28:33,870 --> 00:28:37,006
or before we start to search for them, we have

430
00:28:37,048 --> 00:28:40,310
to think about the attack surface. And one big difference

431
00:28:40,380 --> 00:28:44,018
between packages and pair is that for pair,

432
00:28:44,194 --> 00:28:47,714
administrators have to manually validate all new accounts.

433
00:28:47,842 --> 00:28:51,180
So how do we really get an account?

434
00:28:51,630 --> 00:28:56,262
Well, we don't. We could try to trick an admin into accepting

435
00:28:56,326 --> 00:29:00,234
us, but we want to focus on the technical side and not trick people

436
00:29:00,272 --> 00:29:03,674
into something. So we have to start with the pre

437
00:29:03,712 --> 00:29:07,578
authenticated text service. This includes all the features

438
00:29:07,674 --> 00:29:11,054
that you can use before you even log in, and there are some

439
00:29:11,092 --> 00:29:15,374
features of that in pair. A historical

440
00:29:15,422 --> 00:29:19,554
package manager also probably means that it was built with

441
00:29:19,592 --> 00:29:22,894
historical best practices in mind that are nowadays considered

442
00:29:22,942 --> 00:29:26,574
deprecated, and it also has to support older

443
00:29:26,622 --> 00:29:30,022
PHP versions. So with this

444
00:29:30,076 --> 00:29:33,734
attack surface in mind, we started and we did

445
00:29:33,772 --> 00:29:37,320
this. We do what we always do when we start a new research project.

446
00:29:37,770 --> 00:29:40,150
We use our own tool, sonar cube,

447
00:29:40,570 --> 00:29:43,946
to scan the code of the target. Sonar cube is a

448
00:29:43,968 --> 00:29:48,090
static analysis tool, so it will look through the code and

449
00:29:48,160 --> 00:29:51,578
find dangerous places, for example, where user input lands in

450
00:29:51,584 --> 00:29:55,694
a dangerous function, or where certain functions are used

451
00:29:55,892 --> 00:29:59,146
in a bad way, or in general functions that are considered

452
00:29:59,178 --> 00:30:02,606
dangerous. And in this case, it gave

453
00:30:02,628 --> 00:30:06,318
us an issue about pseudorandum number generators,

454
00:30:06,414 --> 00:30:10,946
and that there's an unsafe one being used here you

455
00:30:10,968 --> 00:30:15,106
can see it down below. The function is empty rand and

456
00:30:15,128 --> 00:30:18,706
it is in the reset password function.

457
00:30:18,888 --> 00:30:22,662
And this is very interesting already, because this is

458
00:30:22,716 --> 00:30:25,926
exactly one of those features that can be used before you log in.

459
00:30:26,028 --> 00:30:28,840
If you lose your password, if you forget it,

460
00:30:29,530 --> 00:30:33,180
then you might want to reset it. And to do this you

461
00:30:33,630 --> 00:30:37,740
can't log in. So this is already a pre authenticated attack service.

462
00:30:38,510 --> 00:30:42,010
So we dug a little bit deeper into what

463
00:30:42,080 --> 00:30:45,402
happens here. And what a reset password

464
00:30:45,466 --> 00:30:48,666
function usually does is it generates a random

465
00:30:48,698 --> 00:30:52,094
token, then emails it to the user so the user can

466
00:30:52,132 --> 00:30:56,274
click on a reset link and then they can set

467
00:30:56,312 --> 00:31:00,114
a new password. So this function also does this.

468
00:31:00,232 --> 00:31:04,750
And the way it's done is like this. It takes four different values,

469
00:31:04,830 --> 00:31:08,022
combines them and then hashes them with MD five,

470
00:31:08,156 --> 00:31:10,470
and the result is the random token.

471
00:31:11,050 --> 00:31:14,754
But some of the values are easily

472
00:31:14,882 --> 00:31:17,442
predictable or known by the attacker.

473
00:31:17,586 --> 00:31:21,386
So the first part is a random number. This is

474
00:31:21,408 --> 00:31:24,922
the pseudorandom number generator function that

475
00:31:24,976 --> 00:31:29,194
was raised here. And the

476
00:31:29,232 --> 00:31:33,106
two arguments don't mean the length of the number, they are the interval.

477
00:31:33,158 --> 00:31:36,474
So this function will only generate nine different values

478
00:31:36,522 --> 00:31:39,994
between four and 13, which is not a lot and easily

479
00:31:40,042 --> 00:31:43,920
guessable. The second part is the username of the account

480
00:31:44,850 --> 00:31:48,258
that has the password that should be reset. So this is also

481
00:31:48,344 --> 00:31:51,406
from the request attacker controlled.

482
00:31:51,598 --> 00:31:55,106
The third part is the server's local time at

483
00:31:55,128 --> 00:31:58,982
the moment of the request. And this might not be

484
00:31:59,036 --> 00:32:03,106
so easily predictable, but the server always sends

485
00:32:03,138 --> 00:32:07,074
back a date header in its HTTP response that contains

486
00:32:07,202 --> 00:32:10,986
the local time. And the last thing is the

487
00:32:11,008 --> 00:32:14,150
new password that you want to set. So for pair,

488
00:32:14,310 --> 00:32:16,620
the password reset works like this.

489
00:32:17,710 --> 00:32:21,706
During the reset you already give your new password and

490
00:32:21,728 --> 00:32:25,134
once you get the link you basically accept that this is a new

491
00:32:25,172 --> 00:32:28,622
password. So as I said,

492
00:32:28,756 --> 00:32:32,302
the last three things are either directly controlled or

493
00:32:32,356 --> 00:32:36,494
can be known by the attacker,

494
00:32:36,622 --> 00:32:40,830
and only the first value is really the one that's

495
00:32:40,990 --> 00:32:44,894
random. But as I said, it can only have values

496
00:32:44,942 --> 00:32:48,926
between four and 13, so it's also very easily guessable.

497
00:32:49,118 --> 00:32:52,962
And with that we can reset about any accounts password

498
00:32:53,026 --> 00:32:56,306
on pair. So to sum

499
00:32:56,338 --> 00:33:00,422
up where we stand right now, we chain take over

500
00:33:00,476 --> 00:33:04,170
any account with about 50 tries. Sometimes we have to guess a little bit more.

501
00:33:04,240 --> 00:33:08,442
If the timestamp is few seconds off, or maybe

502
00:33:08,496 --> 00:33:12,202
the time zone, we don't know it and have to try it out. But 50

503
00:33:12,256 --> 00:33:15,854
tries should be enough for any account. And it's also

504
00:33:15,892 --> 00:33:19,360
very interesting because pair accounts are public.

505
00:33:20,450 --> 00:33:23,754
For a specific package, you know which user

506
00:33:23,802 --> 00:33:27,426
published it and you only need their user account and not their email to

507
00:33:27,448 --> 00:33:31,058
reset the password. So what we could do is find

508
00:33:31,224 --> 00:33:34,414
popular packages and target their developers

509
00:33:34,542 --> 00:33:38,098
and then release a new version of that package that has maybe a backdoor

510
00:33:38,114 --> 00:33:41,366
built in. What's also very interesting

511
00:33:41,468 --> 00:33:45,206
about this bug is that it was 15 years old when it was

512
00:33:45,228 --> 00:33:48,470
discovered. So the bug was actually

513
00:33:48,540 --> 00:33:52,086
in the reset password function, since this function was

514
00:33:52,188 --> 00:33:55,994
written the first time. So really a long time where

515
00:33:56,032 --> 00:33:59,500
people could have abused it if they found it,

516
00:34:00,830 --> 00:34:04,334
but we didn't want to stop there. Breaking over

517
00:34:04,372 --> 00:34:08,638
every developer's account creates a lot of noise and

518
00:34:08,724 --> 00:34:12,426
people could get suspicious and block

519
00:34:12,458 --> 00:34:15,818
the attempt or clean up after the attacker

520
00:34:15,834 --> 00:34:19,614
if they notice it. So is it possible to gain code execution

521
00:34:19,662 --> 00:34:23,554
on the servers and replace all the packages in a more

522
00:34:23,592 --> 00:34:27,380
stealthy way? This is what we wanted to find out.

523
00:34:27,910 --> 00:34:30,934
So we went ahead and looked what we could do.

524
00:34:30,972 --> 00:34:34,182
Now, now that we have new attack

525
00:34:34,236 --> 00:34:38,040
surface, because now we have an account, hands can use more features than before.

526
00:34:39,370 --> 00:34:42,890
We can see that packages that are submitted, new ones

527
00:34:42,960 --> 00:34:46,330
or updates are added to a work queue where then

528
00:34:46,400 --> 00:34:49,862
asynchronous workers will process them and eventually

529
00:34:49,926 --> 00:34:54,062
publish them. And this processing works like this. At first

530
00:34:54,116 --> 00:34:56,830
the package is extracted, hands validated,

531
00:34:57,250 --> 00:35:00,814
and afterward the documentation is generated using

532
00:35:00,852 --> 00:35:04,854
the PHP documenter tool. And finally the documentation

533
00:35:04,922 --> 00:35:08,802
and the package download are copied to the package page where you can now see

534
00:35:08,936 --> 00:35:12,850
the packages readme documentation and can download the package.

535
00:35:13,990 --> 00:35:15,940
And this also sounds really interesting.

536
00:35:17,130 --> 00:35:20,402
The extraction process and the documentation generation

537
00:35:20,466 --> 00:35:24,070
process sounds quite complex. A lot of

538
00:35:24,220 --> 00:35:28,200
file file system handling and also this tool,

539
00:35:28,730 --> 00:35:32,140
a lot of complexity where things can go wrong.

540
00:35:32,510 --> 00:35:36,060
So we looked into the code to see how all of this worked

541
00:35:36,910 --> 00:35:40,426
at first. Here's the code that extracts the

542
00:35:40,448 --> 00:35:43,694
file. So when you upload a package, you have to

543
00:35:43,812 --> 00:35:47,226
do it in the tar archive file format,

544
00:35:47,418 --> 00:35:51,434
and then this file is extracted with the archive tar

545
00:35:51,482 --> 00:35:54,350
package into a temporary directory.

546
00:35:56,050 --> 00:35:59,694
Then we had a look at the version that's being used of this archive

547
00:35:59,742 --> 00:36:03,650
tar package, and we noticed that the version was slightly out of date.

548
00:36:03,720 --> 00:36:07,640
They used version one four seven, and at that point

549
00:36:08,730 --> 00:36:12,406
we looked up to see if there's a known vulnerability in

550
00:36:12,428 --> 00:36:14,840
there. And in fact there was,

551
00:36:16,010 --> 00:36:19,618
there was CVE 2023 6193

552
00:36:19,804 --> 00:36:23,898
hands. We looked at the description to see what exactly this

553
00:36:24,064 --> 00:36:27,766
vulnerability was about. The description

554
00:36:27,878 --> 00:36:31,542
describes that it allows write operations with directory

555
00:36:31,606 --> 00:36:35,390
traversal due to inadequate checking of symbolic links.

556
00:36:35,810 --> 00:36:38,606
And it gets more and more interesting with this,

557
00:36:38,788 --> 00:36:42,634
because for once we now know that directory

558
00:36:42,682 --> 00:36:46,206
traversal has to be used and it has to do with symbolic links,

559
00:36:46,398 --> 00:36:51,694
but also writing files somewhere

560
00:36:51,822 --> 00:36:55,010
is very, very powerful in the PHP ecosystem,

561
00:36:55,510 --> 00:36:59,122
because once you chain write a PHP file

562
00:36:59,186 --> 00:37:03,234
to the web root of a server with controlled

563
00:37:03,282 --> 00:37:06,934
content, you can basically just browse there and

564
00:37:06,972 --> 00:37:10,234
the server will happily execute your code for you.

565
00:37:10,352 --> 00:37:14,140
And then you can do about everything that the server could do.

566
00:37:15,230 --> 00:37:19,754
So to find out exactly how this vulnerability has

567
00:37:19,792 --> 00:37:23,222
to be abused, we checked the patch

568
00:37:23,286 --> 00:37:27,226
of the vulnerability. This is a very commonly

569
00:37:27,258 --> 00:37:30,826
known technique to just look for the patch and then see what was changed,

570
00:37:30,858 --> 00:37:34,646
and then you know exactly what they now prevent,

571
00:37:34,698 --> 00:37:38,130
what was previously possible. So in this case,

572
00:37:38,280 --> 00:37:41,858
the patch added these few lines that

573
00:37:42,024 --> 00:37:45,566
add another check. So whenever a file is extracted,

574
00:37:45,598 --> 00:37:49,160
hands then contains an element that is a symbolic link.

575
00:37:50,330 --> 00:37:54,710
Type two in terms of the tar format.

576
00:37:56,010 --> 00:38:00,070
Then it will see if the symbolic link points inside

577
00:38:00,140 --> 00:38:03,866
of the extraction directory or outside of it. And if it

578
00:38:03,888 --> 00:38:07,142
points outside of it, then it will be blocked and an error

579
00:38:07,286 --> 00:38:10,458
will be displayed instead, because this is

580
00:38:10,464 --> 00:38:13,502
now forbidden. With this,

581
00:38:13,636 --> 00:38:16,974
we knew that we somehow had to use a symbolic link

582
00:38:17,012 --> 00:38:20,926
that points somewhere else. But symbolic links in themselves

583
00:38:21,108 --> 00:38:24,106
are not really dangerous, it's only a pointer.

584
00:38:24,138 --> 00:38:28,146
So somewhere else we still have to write there. And to

585
00:38:28,168 --> 00:38:31,726
do that, we crafted our own tar archive file,

586
00:38:31,918 --> 00:38:35,198
and it looks like this. The first element

587
00:38:35,294 --> 00:38:38,742
in the archive is a symbolic link called Sim

588
00:38:38,796 --> 00:38:41,846
link. It points to the web route and then to the

589
00:38:41,868 --> 00:38:45,110
file evil Php in this web route.

590
00:38:45,530 --> 00:38:49,046
The next item in the tar archive file is

591
00:38:49,068 --> 00:38:52,714
a regular file. As you can see, it has 49

592
00:38:52,752 --> 00:38:55,866
bytes of content, so there's some content in

593
00:38:55,888 --> 00:38:59,046
it, but it is also called Simlink.

594
00:38:59,238 --> 00:39:02,102
And then lastly we have package XML,

595
00:39:02,246 --> 00:39:06,206
which is a file that's needed by pair to do some more validations on

596
00:39:06,228 --> 00:39:09,486
the package. And if such a tar file is

597
00:39:09,508 --> 00:39:12,430
now extracted with the archive tar package,

598
00:39:12,850 --> 00:39:16,474
the following happens. What you can see here

599
00:39:16,532 --> 00:39:20,094
is a rough approximation of the file system of the pair

600
00:39:20,142 --> 00:39:24,158
server. At the top you have the web route called public HTML.

601
00:39:24,334 --> 00:39:27,370
It contains for example an index PhP file

602
00:39:27,390 --> 00:39:30,200
and other files that are reachable via the web.

603
00:39:30,570 --> 00:39:32,870
Below that you have a temporary directory.

604
00:39:33,530 --> 00:39:36,962
One of them is used for the actual uploads.

605
00:39:37,026 --> 00:39:40,954
So the tar files and the bottom one is

606
00:39:40,992 --> 00:39:44,634
used to extract the tar files there. In this

607
00:39:44,672 --> 00:39:48,282
case, our package is called my package and

608
00:39:48,336 --> 00:39:51,994
it gets extracted. So at first, the first element is

609
00:39:52,032 --> 00:39:55,322
extracted. This is the symbolic link called Sim

610
00:39:55,376 --> 00:39:58,606
link. It points to evil PhP in

611
00:39:58,628 --> 00:40:02,766
the web route. But the file evil Php does

612
00:40:02,788 --> 00:40:06,290
not exist yet, it's only the link that exists.

613
00:40:07,750 --> 00:40:10,734
Next, the second item is extracted,

614
00:40:10,862 --> 00:40:15,010
and this is the regular file that is also called Simlink.

615
00:40:15,350 --> 00:40:18,938
This causes the system to write to the file called Simlink,

616
00:40:18,974 --> 00:40:22,214
but because it is a symbolic link or was before,

617
00:40:22,412 --> 00:40:26,498
it writes to where the symbolic link points and not directly

618
00:40:26,674 --> 00:40:30,318
at the location where it is. So this causes

619
00:40:30,354 --> 00:40:34,234
the file evil PhP in the web route to be created and the

620
00:40:34,272 --> 00:40:38,266
content is arbitrary, the attacker can completely

621
00:40:38,448 --> 00:40:41,874
choose it. In this case it's a simple Php script

622
00:40:41,942 --> 00:40:45,726
that executes a command as a system command that

623
00:40:45,748 --> 00:40:49,390
is given via a get parameter,

624
00:40:50,530 --> 00:40:54,374
and then finally the package XML file is also extracted.

625
00:40:54,522 --> 00:40:57,714
But for the exploit this is not really

626
00:40:57,752 --> 00:40:59,090
important anymore.

627
00:41:00,470 --> 00:41:04,066
So let's put the pieces together. We chain both of

628
00:41:04,088 --> 00:41:07,726
the bugs to first take over an administrator's

629
00:41:07,758 --> 00:41:11,670
account with the reset password functionality. Then we

630
00:41:11,740 --> 00:41:15,542
used these new privileges to create a new package and

631
00:41:15,596 --> 00:41:18,806
automatically approve it so that it would get added to the

632
00:41:18,828 --> 00:41:24,506
work queue and extracted. And during this extraction the

633
00:41:24,528 --> 00:41:28,166
known CvE exploit in archive tar leads

634
00:41:28,198 --> 00:41:32,166
to the file write. And finally our own PHP

635
00:41:32,198 --> 00:41:35,550
script lands in the web route and we can just execute it.

636
00:41:35,620 --> 00:41:39,390
And with that we can compromise all the pair packages

637
00:41:39,810 --> 00:41:42,330
with very little noise.

638
00:41:42,490 --> 00:41:45,874
And yeah, basically that's it of the

639
00:41:45,912 --> 00:41:49,566
journey on the back end side, because there's

640
00:41:49,678 --> 00:41:53,090
no much more room for lateral movement

641
00:41:53,750 --> 00:41:57,542
on the server that hosts pair. There's only other

642
00:41:57,596 --> 00:42:00,738
stuff related to pair that's being hosted.

643
00:42:00,914 --> 00:42:05,110
So we could for example compromise the pair installers.

644
00:42:05,450 --> 00:42:09,334
But the real interesting thing for a real attacker would

645
00:42:09,372 --> 00:42:12,954
now be to backdoor all the packages and then

646
00:42:12,992 --> 00:42:16,394
wait until people install them and move into their

647
00:42:16,432 --> 00:42:20,234
network hands, install malware there. So to show

648
00:42:20,272 --> 00:42:23,706
it all, we now have a small demonstration about how to

649
00:42:23,728 --> 00:42:26,894
get a shell on the pair of server. All right,

650
00:42:26,932 --> 00:42:30,206
this is the third and last demonstration for today. So we

651
00:42:30,228 --> 00:42:33,342
have the same setup. We have a test instance of peer on the left,

652
00:42:33,396 --> 00:42:37,266
which is Austin on the vm with ip addresses on the screen

653
00:42:37,368 --> 00:42:41,074
below. This is just test one. Again not real

654
00:42:41,112 --> 00:42:45,054
production instance. And to make our life easier for the demonstration,

655
00:42:45,182 --> 00:42:48,942
we're going to start a cron job every 5 seconds on the wheel instance.

656
00:42:49,006 --> 00:42:52,246
It would I think take up to a day, but we don't want

657
00:42:52,268 --> 00:42:55,254
to wait for a day for a demonstration, so it's going to be quicker that

658
00:42:55,292 --> 00:42:58,438
way. So we know there is the admin account, but we

659
00:42:58,444 --> 00:43:01,962
don't know its password. So we can use the exploit to

660
00:43:02,016 --> 00:43:05,658
first fetch date of the server hands, try to

661
00:43:05,744 --> 00:43:09,606
bridge force, the only few reset

662
00:43:09,638 --> 00:43:13,206
tokens that may exist at that time. So we do a password

663
00:43:13,238 --> 00:43:16,798
reset request and then we use this date

664
00:43:16,964 --> 00:43:20,366
to try to guess there is a token and

665
00:43:20,388 --> 00:43:23,806
change the password. And now we see it succeeded and we can log in

666
00:43:23,828 --> 00:43:27,634
as admin and FuBaR. And this is super user. This is really cool.

667
00:43:27,672 --> 00:43:31,778
We can already start releasing backdrop releases for everybody,

668
00:43:31,944 --> 00:43:35,810
but we'll show you the second

669
00:43:35,880 --> 00:43:39,598
exploits that we found. So we create the malicious archive

670
00:43:39,694 --> 00:43:43,158
with two sim links. First sim link as a link, then sim link as a

671
00:43:43,164 --> 00:43:47,398
file, and then finally the package XML. We upload it and

672
00:43:47,564 --> 00:43:51,334
when it's done we see that the crown will trigger and

673
00:43:51,532 --> 00:43:55,062
it will write the evil PhP file under the web root.

674
00:43:55,126 --> 00:43:58,714
And if we access this file with the right parameter, we can

675
00:43:58,752 --> 00:44:01,740
execute arbitrary commands like id or your name.

676
00:44:04,210 --> 00:44:07,774
Okay, now let's have a quick look at the timeline of this

677
00:44:07,812 --> 00:44:10,954
disclosure. We reported

678
00:44:11,002 --> 00:44:14,406
this in summer last year to the pair

679
00:44:14,458 --> 00:44:18,558
maintainers, and a few days after they pushed

680
00:44:18,654 --> 00:44:22,420
commits to their GitHub that fixed this issue.

681
00:44:23,110 --> 00:44:26,818
But then it unfortunately took some months until these

682
00:44:26,904 --> 00:44:30,606
fixes were actually deployed to the pair instance.

683
00:44:30,798 --> 00:44:34,598
And in this timeframe people could have seen that there is

684
00:44:34,764 --> 00:44:38,454
a fix for a vulnerability and what it is and try

685
00:44:38,492 --> 00:44:40,780
out if it has been fixed on the server yet.

686
00:44:41,310 --> 00:44:45,366
Unfortunately, to our knowledge this did not happen. But it's

687
00:44:45,398 --> 00:44:49,066
always best if the fix and also the deployment of the

688
00:44:49,088 --> 00:44:53,310
fix are being done as fast as possible after

689
00:44:53,380 --> 00:44:56,720
another. If you can,

690
00:44:57,330 --> 00:45:01,482
you could consider moving to composer, because packages

691
00:45:01,546 --> 00:45:04,678
are also present on composer when they are at pair,

692
00:45:04,874 --> 00:45:07,140
at least for the very popular ones.

693
00:45:07,590 --> 00:45:11,618
And composer and packages have far more active community

694
00:45:11,704 --> 00:45:15,730
support and as we've seen, they are able to patch faster.

695
00:45:17,530 --> 00:45:21,346
Now let's have a step back hands think about how we could prevent

696
00:45:21,378 --> 00:45:24,200
these attacks in general.

697
00:45:25,610 --> 00:45:29,566
First of all, we have to admit that our ecosystems

698
00:45:29,698 --> 00:45:33,466
are not robust against these attacks. And this is not only a

699
00:45:33,488 --> 00:45:37,398
PHP problem, it's basically in most ecosystems

700
00:45:37,574 --> 00:45:41,498
that these central components are built by

701
00:45:41,584 --> 00:45:45,994
volunteers and also maintained and operated

702
00:45:46,042 --> 00:45:49,706
by volunteers. So there can be bugs in there and you can't

703
00:45:49,738 --> 00:45:52,800
really blame anybody if they do it in a free time, right?

704
00:45:53,890 --> 00:45:57,202
So in order to fix this, we want to focus

705
00:45:57,256 --> 00:46:01,570
on two actionable ideas that could help prevent these attacks.

706
00:46:02,070 --> 00:46:05,982
First, we could impact, do impact reduction

707
00:46:06,046 --> 00:46:09,346
reduce the impact by doing mandatory

708
00:46:09,378 --> 00:46:13,314
code signing of software artifacts. And secondly,

709
00:46:13,442 --> 00:46:16,726
we can reduce the risk by applying all

710
00:46:16,748 --> 00:46:20,682
the security best practices. For the first

711
00:46:20,736 --> 00:46:23,450
part, the impact reduction,

712
00:46:23,870 --> 00:46:27,626
we want to have code signing because in

713
00:46:27,648 --> 00:46:31,370
fact package managers don't have to be trusted. In the end

714
00:46:31,440 --> 00:46:35,022
they are just simple tubes, a tunnel that you reach through

715
00:46:35,076 --> 00:46:38,286
to get what you want. And you don't want to

716
00:46:38,308 --> 00:46:42,046
have to trust this, you only want to trust the

717
00:46:42,068 --> 00:46:45,838
thing that you are getting. So if the thing you

718
00:46:45,844 --> 00:46:49,246
are getting the artifact that you download is signed by the developer

719
00:46:49,278 --> 00:46:52,434
that wrote it. Then you

720
00:46:52,472 --> 00:46:56,270
only have to trust this developer's identity.

721
00:46:56,430 --> 00:47:00,358
And you get the identity via OSDC providers or

722
00:47:00,524 --> 00:47:04,520
via GPG keys, something like this. So that you can

723
00:47:05,130 --> 00:47:08,166
check the cryptographic signature of

724
00:47:08,188 --> 00:47:11,402
the thing you download. And if the signature is correct,

725
00:47:11,456 --> 00:47:15,254
then you know that it comes really from this developer.

726
00:47:15,382 --> 00:47:19,194
And then you only have to trust the developer and not the developer and the

727
00:47:19,232 --> 00:47:23,046
package manager. So this would already avoid

728
00:47:23,078 --> 00:47:25,870
many attacks on the package manager platforms.

729
00:47:26,450 --> 00:47:29,594
The worst thing that could happen now is you can't

730
00:47:29,642 --> 00:47:33,802
get a package because it's backdoor. But since you know that it's backdoor,

731
00:47:33,866 --> 00:47:37,714
because the signature doesn't match, you can just discard it and not

732
00:47:37,752 --> 00:47:41,682
use it. But all of this only works

733
00:47:41,736 --> 00:47:45,326
if it's mandatory. Otherwise there will always be holes

734
00:47:45,358 --> 00:47:49,030
in the system. For example, if package a is

735
00:47:49,100 --> 00:47:52,790
signed, then you would notice if it's being manipulated.

736
00:47:53,210 --> 00:47:57,030
But if package a depends on package b, and this package b

737
00:47:57,100 --> 00:48:00,854
is not signed, then you can't really use package

738
00:48:00,902 --> 00:48:03,946
a because you would have to download both of them in order to use the

739
00:48:03,968 --> 00:48:08,122
whole thing. But since you can control or

740
00:48:08,256 --> 00:48:11,674
check if package b is

741
00:48:11,712 --> 00:48:14,030
really the thing that the developer wrote.

742
00:48:14,450 --> 00:48:17,918
Yeah, the whole code signing thing doesn't work anymore, so it has

743
00:48:17,924 --> 00:48:19,230
to be mandatory.

744
00:48:21,490 --> 00:48:25,630
One project that wants to tackle this is Zixtor.

745
00:48:26,050 --> 00:48:29,946
Zixtor is basically a public append only

746
00:48:29,988 --> 00:48:33,998
ledger where signatures of all the artifacts of all the packages

747
00:48:34,174 --> 00:48:37,350
are being published at. And to

748
00:48:37,420 --> 00:48:41,302
sign the packages, only ephemeral keys are used

749
00:48:41,436 --> 00:48:45,186
for exactly the signing and storage. And it's

750
00:48:45,218 --> 00:48:48,630
kind of similar to TLS certificate transparency,

751
00:48:49,710 --> 00:48:53,370
where there are already these kinds of append only

752
00:48:53,440 --> 00:48:56,646
public ledgers where certificate

753
00:48:56,678 --> 00:49:00,586
authorities are publishing all

754
00:49:00,608 --> 00:49:04,666
of the tickets, not tickets, all of the certificates

755
00:49:04,778 --> 00:49:08,622
that they are issuing. So you could watch there and

756
00:49:08,676 --> 00:49:12,682
see if some CA is issuing a certificate

757
00:49:12,746 --> 00:49:15,760
for your domain that they're not supposed to do,

758
00:49:16,210 --> 00:49:19,906
and then you can intervene. And Sixto also

759
00:49:19,928 --> 00:49:23,522
has protection against downgrade attacks, which is also very good

760
00:49:23,576 --> 00:49:27,874
for the security of the whole system. And suddenly,

761
00:49:27,922 --> 00:49:31,574
if you use Sixdore, and if Sixdore would be integrated into your

762
00:49:31,612 --> 00:49:36,034
ecosystem of choice, you only have to trust the identity

763
00:49:36,082 --> 00:49:39,330
providers and not the

764
00:49:39,420 --> 00:49:43,094
ecosystem itself. And since the identity

765
00:49:43,142 --> 00:49:46,540
providers are usually big companies such as GitHub or Google,

766
00:49:47,630 --> 00:49:51,354
you know that they have much more money hands people to

767
00:49:51,392 --> 00:49:55,034
make sure that their systems are safe and not breached,

768
00:49:55,082 --> 00:49:58,250
and really only provide those identities

769
00:49:58,410 --> 00:50:00,080
to the people that they should.

770
00:50:01,890 --> 00:50:04,798
The second part is code security,

771
00:50:04,964 --> 00:50:07,630
applying code best practices.

772
00:50:08,770 --> 00:50:11,886
So most back end services of these package managers

773
00:50:11,918 --> 00:50:15,774
are open source. There are some exceptions

774
00:50:15,822 --> 00:50:19,458
to this rule. For example, NPM. There's only the client that's

775
00:50:19,474 --> 00:50:21,190
open source, but not the backend.

776
00:50:22,890 --> 00:50:26,338
And you might think, as with all open source software,

777
00:50:26,434 --> 00:50:30,306
yeah, open source is nice, and that is true. But you also might think,

778
00:50:30,428 --> 00:50:33,690
okay, yeah, it's open source. So surely some people

779
00:50:33,760 --> 00:50:36,570
have already looked at the code and made sure it's safe.

780
00:50:37,710 --> 00:50:40,842
But did really somebody do that?

781
00:50:40,976 --> 00:50:45,150
You don't really know. So who's auditing all this open source software?

782
00:50:46,450 --> 00:50:50,126
We do it, but we can't audit all of it.

783
00:50:50,308 --> 00:50:53,998
Hands code reviews take time, and they require money

784
00:50:54,084 --> 00:50:57,586
if you want to hire somebody to do it, and also paperwork and all

785
00:50:57,608 --> 00:50:59,300
this organizational stuff.

786
00:51:00,870 --> 00:51:04,354
So can some random open source project really come

787
00:51:04,392 --> 00:51:07,220
to a company and say, please audit our code?

788
00:51:08,890 --> 00:51:12,386
Also, there's bug bounty programs such as Internet bug

789
00:51:12,418 --> 00:51:15,746
bounty, and this particular one is supposed to pay out bug

790
00:51:15,778 --> 00:51:19,554
bounties to researchers that find vulnerabilities in

791
00:51:19,612 --> 00:51:23,514
popular software that's used all over the Internet. But for

792
00:51:23,552 --> 00:51:26,666
example, they didn't accept these bugs we presented today.

793
00:51:26,848 --> 00:51:30,620
So who would do it if not them?

794
00:51:31,470 --> 00:51:34,746
So there's maybe not that good of an incentive

795
00:51:34,778 --> 00:51:38,254
for other researchers to do it. And speaking of other

796
00:51:38,292 --> 00:51:42,334
researchers, we only know of less than ten people in

797
00:51:42,372 --> 00:51:46,014
general that publish bugs in these targets in other

798
00:51:46,052 --> 00:51:49,954
package managers. So that's really a small group of people who,

799
00:51:50,072 --> 00:51:53,298
even if they wanted to, would have a hard time covering all

800
00:51:53,304 --> 00:51:57,730
of the code that is part of these ecosystems.

801
00:51:59,290 --> 00:52:02,546
And finally, we, as outsiders,

802
00:52:02,578 --> 00:52:06,280
we don't have access to the infrastructure. We can only look at the code

803
00:52:06,970 --> 00:52:10,850
in the form that it's published, for example, on GitHub, set it up ourselves

804
00:52:10,930 --> 00:52:14,858
and see if there's a vulnerability in there. But we don't really know how

805
00:52:14,944 --> 00:52:18,458
the production system is set up and can't see if there's a

806
00:52:18,464 --> 00:52:22,574
misconfiguration or other issues that can only be found

807
00:52:22,692 --> 00:52:24,720
if you look at the actual system.

808
00:52:27,170 --> 00:52:30,718
Also, the security of clients is important.

809
00:52:30,884 --> 00:52:33,454
Today we spoke about the back end services,

810
00:52:33,652 --> 00:52:37,586
but there's also the client part. And one

811
00:52:37,608 --> 00:52:40,260
problem is that they don't have a clear threat model.

812
00:52:40,950 --> 00:52:44,994
Usually a developer uses the client, for example,

813
00:52:45,112 --> 00:52:48,550
the composer command line util,

814
00:52:49,290 --> 00:52:53,046
to download a package. But what assumptions can you

815
00:52:53,068 --> 00:52:56,902
make? Like, should the folder in which the command is run,

816
00:52:56,956 --> 00:53:00,586
does it have to be fully trusted and safe, or can it be

817
00:53:00,608 --> 00:53:02,090
in any directory?

818
00:53:03,550 --> 00:53:07,510
Can you trust project files or other integrations

819
00:53:07,590 --> 00:53:10,330
that are present in this environment?

820
00:53:10,670 --> 00:53:14,320
Nobody really set the threat model for this.

821
00:53:15,250 --> 00:53:18,798
We did some previous work on this topic, for example,

822
00:53:18,884 --> 00:53:23,470
git integrations in ides or in your favorite shell,

823
00:53:24,130 --> 00:53:27,790
and also other package managers. And the answers

824
00:53:27,870 --> 00:53:31,278
were really different. Some projects said, now we don't

825
00:53:31,294 --> 00:53:33,730
see this as a security vulnerability.

826
00:53:35,110 --> 00:53:38,594
If a user runs a

827
00:53:38,632 --> 00:53:42,242
command inside an untrusted directory, it's their fault.

828
00:53:42,306 --> 00:53:46,310
They have to make sure to only run this on trusted files.

829
00:53:47,130 --> 00:53:51,050
And others took our report and fixed the vulnerability,

830
00:53:52,110 --> 00:53:55,994
either because they said, okay, this is our threat model, or because

831
00:53:56,032 --> 00:53:59,402
they said it's maybe not, but let's be sure and still

832
00:53:59,456 --> 00:54:02,606
fix it. But yeah, the gist is that it's not

833
00:54:02,628 --> 00:54:05,886
really defined and people don't really agree on what the threat model should

834
00:54:05,908 --> 00:54:06,990
be for clients.

835
00:54:09,650 --> 00:54:13,626
And in general, clients are more likely to receive contributions

836
00:54:13,658 --> 00:54:17,586
than servers. Clients are what the people use

837
00:54:17,768 --> 00:54:21,394
day to day. So they might want to have more features in

838
00:54:21,432 --> 00:54:25,170
there to make their life easier. And running

839
00:54:25,240 --> 00:54:26,850
a repository, servers,

840
00:54:27,850 --> 00:54:30,280
yeah, way less people do that.

841
00:54:32,650 --> 00:54:37,078
So yeah. Let's conclude today's talk and

842
00:54:37,164 --> 00:54:40,858
come back first to the question that we asked in

843
00:54:40,864 --> 00:54:44,170
the beginning. Could we composer a good chunk of the Internet?

844
00:54:44,510 --> 00:54:47,878
Yes, we could. And it's really scary

845
00:54:48,054 --> 00:54:51,642
because the attacker level, I mean we are

846
00:54:51,696 --> 00:54:55,734
seasoned security experts, but there are a lot like us out there

847
00:54:55,872 --> 00:54:59,774
and even some that are not acting in good faith. So there

848
00:54:59,812 --> 00:55:03,470
are really some people who could have found this from a skill point of view

849
00:55:03,620 --> 00:55:05,280
and could have abused it.

850
00:55:06,530 --> 00:55:10,434
Looking at the time that it took to find the bugs, it was less

851
00:55:10,472 --> 00:55:13,746
than a week. So yeah, again, if somebody with the

852
00:55:13,768 --> 00:55:17,138
same skill level wants to find these bugs, they can.

853
00:55:17,304 --> 00:55:20,886
They just have to sit somewhere, look at code for

854
00:55:20,908 --> 00:55:24,360
some days and probably would have found it.

855
00:55:24,970 --> 00:55:28,294
And when we look at the money, it was not even

856
00:55:28,332 --> 00:55:32,090
relevant in this case. We didn't need big servers to

857
00:55:32,160 --> 00:55:35,946
do this attack or something like this, just download the code and

858
00:55:35,968 --> 00:55:37,020
read it. Really,

859
00:55:39,310 --> 00:55:42,622
this leads us to the usual suspects of open

860
00:55:42,676 --> 00:55:46,586
source software security. I already said there's

861
00:55:46,618 --> 00:55:49,886
this thing where people think, oh, it's open source, surely somebody has looked at

862
00:55:49,908 --> 00:55:53,280
it, but did somebody really do it?

863
00:55:54,370 --> 00:55:58,450
And there's always lack of maintainers and lack of security reviews.

864
00:55:59,430 --> 00:56:02,754
If you want a feature in an open source project, you can ask for

865
00:56:02,792 --> 00:56:07,006
it, but the maintainer doesn't owe you something,

866
00:56:07,128 --> 00:56:10,710
you don't pay them to include it,

867
00:56:10,860 --> 00:56:15,494
so it might not get added. And the same is

868
00:56:15,532 --> 00:56:18,902
true for security fixes and stuff like this.

869
00:56:18,956 --> 00:56:22,618
Most maintainers want to fix them, but maybe sometimes they don't have

870
00:56:22,624 --> 00:56:26,620
the time, they don't have the right know how. It's a difficult situation.

871
00:56:27,550 --> 00:56:31,194
So yeah, devsecops teams really have

872
00:56:31,232 --> 00:56:35,102
to apply all the supply chain best practices that they can,

873
00:56:35,156 --> 00:56:38,510
so they can make sure their environment is as strong

874
00:56:38,580 --> 00:56:42,506
as possible so that some vulnerability occur

875
00:56:42,618 --> 00:56:45,986
in some of the other parts. They don't have that

876
00:56:46,008 --> 00:56:49,730
much impact. But on the good side,

877
00:56:49,880 --> 00:56:52,994
we see initiatives like Sixdor that really look

878
00:56:53,032 --> 00:56:57,210
promising and are already being integrated into some ecosystems.

879
00:56:57,310 --> 00:57:00,230
And if this trend continues,

880
00:57:00,730 --> 00:57:03,986
at some point we won't have to trust the middlemen, the package managers

881
00:57:04,018 --> 00:57:08,166
anymore, and the whole ecosystem will be one

882
00:57:08,268 --> 00:57:11,762
step safer. And of course,

883
00:57:11,916 --> 00:57:15,322
if you can audit your package managers, if you have a

884
00:57:15,376 --> 00:57:18,780
security background, if you know a little bit about code and security,

885
00:57:19,550 --> 00:57:23,206
why not look into your package manager, into the package manager

886
00:57:23,238 --> 00:57:26,558
that you use all the time. Try to see if there's a

887
00:57:26,564 --> 00:57:30,350
vulnerability in there. And if you find something, please report

888
00:57:30,420 --> 00:57:34,560
it responsibly so that it can be fixed and

889
00:57:38,630 --> 00:57:41,330
everybody will be happier afterwards.

890
00:57:43,510 --> 00:57:47,650
Now we have to give big kudos to all the managers

891
00:57:48,170 --> 00:57:51,894
that helped us with these vulnerabilities. So for

892
00:57:51,932 --> 00:57:55,218
packages, that's Niels, Jordy and Stefan,

893
00:57:55,394 --> 00:57:59,394
who are really fast to fix and really

894
00:57:59,532 --> 00:58:03,146
pleasant to work with. For pear, it's Chuck, Ken and

895
00:58:03,168 --> 00:58:06,890
Mark who also helped us get this

896
00:58:06,960 --> 00:58:10,250
vulnerability fixed and then finally deployed.

897
00:58:10,750 --> 00:58:13,822
And yeah, I assume working on such a legacy code base

898
00:58:13,876 --> 00:58:17,280
is not that easy. So thanks to them.

899
00:58:17,650 --> 00:58:21,086
And if you want to support them, then you

900
00:58:21,108 --> 00:58:24,470
can do it via these links, via GitHub or OpenCollective.

901
00:58:24,650 --> 00:58:28,546
And if you are using any of their projects, especially in

902
00:58:28,568 --> 00:58:33,214
a commercial sense, then I would really appreciate

903
00:58:33,262 --> 00:58:36,866
if you would fund them. All parties would

904
00:58:36,888 --> 00:58:40,040
benefit from it because the software that you are using

905
00:58:40,490 --> 00:58:44,214
can get better and more secure if there's more funding to

906
00:58:44,332 --> 00:58:47,160
maintain them and maybe do an audit on them.

907
00:58:48,090 --> 00:58:51,590
If you need more or want more technical details,

908
00:58:51,670 --> 00:58:55,994
you can find them in our several blog posts on blog sonarsource.com

909
00:58:56,112 --> 00:58:59,178
or you can talk to us, message us. We will

910
00:58:59,184 --> 00:59:02,906
be happy to answer questions. And if you

911
00:59:02,928 --> 00:59:05,962
loved what you saw today, you can also join us

912
00:59:06,096 --> 00:59:09,994
in the journey of making the open source world more secure. We work

913
00:59:10,032 --> 00:59:12,890
on a lot of interesting targets.

914
00:59:14,550 --> 00:59:17,394
That's it from us. Thanks for listening to our talk.

915
00:59:17,512 --> 00:59:18,480
We hope you enjoyed it.

