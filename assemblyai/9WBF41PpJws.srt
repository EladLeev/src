1
00:00:00,410 --> 00:00:06,126
Jamaica make up real

2
00:00:06,148 --> 00:00:09,530
time feedback into the behavior of your distributed systems

3
00:00:09,610 --> 00:00:13,114
and observing changes exceptions errors

4
00:00:13,162 --> 00:00:16,666
in real time allows you to not only experiment with confidence,

5
00:00:16,778 --> 00:00:20,480
but respond instantly to get things working again.

6
00:00:24,610 --> 00:01:05,102
Close hello

7
00:01:05,156 --> 00:01:08,786
and welcome. Thanks for coming to my talk. It's a jungle out there. What's really

8
00:01:08,808 --> 00:01:12,046
going on inside your node modules folder? My name is Faross

9
00:01:12,078 --> 00:01:15,758
and I'm an open source maintainer. I started webtorint, which is a peer

10
00:01:15,774 --> 00:01:19,826
to peer file transfer protocol and standard JS, a linter that catches

11
00:01:19,858 --> 00:01:23,254
bugs and enforces code style. I've been doing

12
00:01:23,292 --> 00:01:27,510
open source since 2014 and have created over 100 npm packages.

13
00:01:28,010 --> 00:01:31,866
In the past, I volunteered on the node JS board of directors, and I

14
00:01:31,888 --> 00:01:34,970
also teach a class on web security at Stanford University.

15
00:01:35,390 --> 00:01:38,730
Now I'm the founder of a startup called Socket, which helps protect

16
00:01:38,800 --> 00:01:41,790
the open source ecosystem. Before we get started,

17
00:01:41,940 --> 00:01:44,922
let me tell you a story. On January 13,

18
00:01:44,986 --> 00:01:48,394
2012 over ten years ago, a developer

19
00:01:48,442 --> 00:01:52,058
named Fisal Salman published a new project to GitHub.

20
00:01:52,234 --> 00:01:56,318
It was called Uapser JS, and it parsed user

21
00:01:56,334 --> 00:01:59,570
agent strings. Now, lots of people found this project

22
00:01:59,640 --> 00:02:03,086
useful, and so over the next ten years, Fisal continued

23
00:02:03,118 --> 00:02:06,466
to develop the package. Along with the help from many open source

24
00:02:06,498 --> 00:02:09,794
contributors, he published 54 versions.

25
00:02:09,922 --> 00:02:14,226
As the package grew in popularity, it eventually

26
00:02:14,258 --> 00:02:17,080
grew to 7 million downloads per week,

27
00:02:17,550 --> 00:02:21,610
eventually being used by nearly 3 million GitHub repositories.

28
00:02:22,670 --> 00:02:25,260
Now let me tell you a different story.

29
00:02:26,830 --> 00:02:30,474
On October 5, 2021, on a notorious

30
00:02:30,522 --> 00:02:34,686
russian hacking forum, this post appeared a

31
00:02:34,708 --> 00:02:38,638
hacker was offering to sell the password to an NPM account

32
00:02:38,724 --> 00:02:42,350
that controlled a package with over 7 million weekly downloads.

33
00:02:42,710 --> 00:02:46,610
His asking price was $20,000 for this password.

34
00:02:47,910 --> 00:02:51,410
Now this is where the two stories intersect.

35
00:02:52,550 --> 00:02:56,342
Two weeks later, Uapars JS was compromised and

36
00:02:56,396 --> 00:02:59,974
three malicious versions were published. Malware was

37
00:03:00,012 --> 00:03:03,522
added to these packages that would execute immediately

38
00:03:03,586 --> 00:03:06,710
whenever anyone installed one of the compromised versions.

39
00:03:07,370 --> 00:03:10,266
So now let's take a look at what that malware does. So this is the

40
00:03:10,288 --> 00:03:12,730
package JSOn file for the compromised version,

41
00:03:13,710 --> 00:03:17,274
and you'll see that it uses a preinstalled script. So this means that

42
00:03:17,312 --> 00:03:20,998
this command will run automatically anytime this package is

43
00:03:21,024 --> 00:03:24,560
installed. So now let's look at what that script does.

44
00:03:25,490 --> 00:03:29,562
So the first thing you'll see is that it splits based on the operating

45
00:03:29,626 --> 00:03:32,506
system of the target. On Mac,

46
00:03:32,618 --> 00:03:35,438
nothing happens, which is lucky for Mac users.

47
00:03:35,614 --> 00:03:39,486
But Windows and Linux users aren't so lucky. And you'll see here that command

48
00:03:39,518 --> 00:03:43,858
prompt is spawned for each of these platforms using

49
00:03:43,944 --> 00:03:47,266
childprocess exec. So now let's take a look

50
00:03:47,288 --> 00:03:50,694
at what that preinstall sh script does. The very

51
00:03:50,732 --> 00:03:54,840
first line fetches the user's country and

52
00:03:55,530 --> 00:03:58,870
figures out whether the user is coming from Russia, Ukraine,

53
00:03:58,950 --> 00:04:02,570
Belarus, or Kazakhstan, and stores that in a variable.

54
00:04:03,390 --> 00:04:06,358
Now if the user comes from one of those countries,

55
00:04:06,534 --> 00:04:09,530
then the script exits without doing anything further.

56
00:04:09,890 --> 00:04:13,642
However, if you come from any other country, then the script proceeds

57
00:04:13,706 --> 00:04:17,226
to download an executable file from this IP

58
00:04:17,258 --> 00:04:20,858
address, mark that file as executable,

59
00:04:21,034 --> 00:04:24,538
and then run it. And now based on these command

60
00:04:24,554 --> 00:04:28,190
line flags, you can see here that this program is a Monero miner,

61
00:04:28,270 --> 00:04:31,950
which is going to be used to mine the monero cryptocurrency

62
00:04:32,110 --> 00:04:35,298
for the attacks. Now this is a script

63
00:04:35,314 --> 00:04:38,758
on Windows. It's very similar, so it starts off with

64
00:04:38,924 --> 00:04:42,258
downloading that same or similar monero minor,

65
00:04:42,354 --> 00:04:45,746
but it also downloads a DLL file

66
00:04:45,858 --> 00:04:48,060
as well and runs whats.

67
00:04:49,230 --> 00:04:52,614
And then here you can see it just starting up the Monero

68
00:04:52,662 --> 00:04:55,926
minor and registering the DlL file on Windows.

69
00:04:56,038 --> 00:04:58,620
Now what does this extra DlL file do?

70
00:04:59,070 --> 00:05:02,462
Well, it steals passwords from over 100 different

71
00:05:02,516 --> 00:05:05,646
programs on the Windows machine, as well as all

72
00:05:05,668 --> 00:05:08,922
the passwords in the Windows credential manager. So yikes,

73
00:05:08,986 --> 00:05:13,362
this is a really nasty piece of malware, and anyone

74
00:05:13,416 --> 00:05:17,106
unlucky enough to run this lost all their passwords and

75
00:05:17,128 --> 00:05:21,010
had to do kind of a complete reset of their online accounts.

76
00:05:22,230 --> 00:05:25,854
Not a fun time. So this is kind of the aftermath.

77
00:05:25,902 --> 00:05:29,766
So this package was published for about 4 hours, and the

78
00:05:29,788 --> 00:05:33,106
open source community was pretty diligent and reported it, and the maintainer

79
00:05:33,138 --> 00:05:36,710
was also quite diligent. And so anyone who happened to install it

80
00:05:36,780 --> 00:05:40,886
during the four hour window was compromised, but it was removed relatively

81
00:05:40,918 --> 00:05:44,474
quickly. Any software builds done in

82
00:05:44,512 --> 00:05:48,282
projects without using a lock file were compromised, and anyone who

83
00:05:48,336 --> 00:05:51,862
was unlucky enough to update to this new version

84
00:05:51,926 --> 00:05:55,646
of the package, or maybe who merged a bot pr to

85
00:05:55,668 --> 00:05:58,974
update to this new version during this time would have also

86
00:05:59,012 --> 00:06:02,746
been compromised. So this was big news in the JavaScript

87
00:06:02,778 --> 00:06:07,186
world, and I'm guessing that you may have already heard about this attack, but this

88
00:06:07,208 --> 00:06:10,770
is really just the tip of the iceberg. So we've been tracking

89
00:06:11,190 --> 00:06:15,138
packages that are removed from NPM for security reasons, and we've seen

90
00:06:15,304 --> 00:06:19,480
over 700 packages removed for security reasons in just the last 30 days.

91
00:06:19,850 --> 00:06:23,238
And I think this trend is accelerating as attackers take advantage of the

92
00:06:23,244 --> 00:06:26,534
open ecosystem and the trust that maintainers have for each other

93
00:06:26,572 --> 00:06:30,246
and the sort of liberal contribution policies that we've all sort of

94
00:06:30,268 --> 00:06:34,346
adopted in the modern open source era. So I think 2022

95
00:06:34,448 --> 00:06:38,134
will be the year of supply chain security, as the awareness

96
00:06:38,182 --> 00:06:41,818
of this issue is now coming to the fore. So one question you

97
00:06:41,824 --> 00:06:45,614
might ask is why is this happening now? I want to start

98
00:06:45,652 --> 00:06:48,766
by just pointing out that what we're trying to do here

99
00:06:48,948 --> 00:06:52,774
is kind of crazy. We're trying to download code from the Internet,

100
00:06:52,922 --> 00:06:56,258
written by unknown individuals that we haven't read,

101
00:06:56,424 --> 00:07:00,146
that we execute with full permissions on

102
00:07:00,168 --> 00:07:03,940
our laptops and our servers where we keep our most important data.

103
00:07:04,710 --> 00:07:08,118
So this is what we're doing every day when we

104
00:07:08,204 --> 00:07:12,102
use NPM install. And I just have to say really quickly that

105
00:07:12,236 --> 00:07:16,200
I personally think it's a miracle that this system works

106
00:07:16,970 --> 00:07:19,900
and that it's continued to mostly work for this long.

107
00:07:20,830 --> 00:07:23,482
It's a testament, I think, to how good most people are,

108
00:07:23,616 --> 00:07:27,366
but unfortunately not everyone is good. So let's dive

109
00:07:27,398 --> 00:07:31,194
into why this is happening now. The first

110
00:07:31,232 --> 00:07:34,750
reason is that 90% of your app's code comes from open source.

111
00:07:35,170 --> 00:07:38,746
So we're really standing on the shoulders of giants. And open source

112
00:07:38,778 --> 00:07:42,126
is the reason why we can get an app off the ground in hours

113
00:07:42,228 --> 00:07:45,906
and days instead of weeks or months. And it's the reason that

114
00:07:45,928 --> 00:07:49,390
we don't need to be an expert in cryptography or in time zones

115
00:07:49,470 --> 00:07:52,974
or the virtual dom to build a powerful modern

116
00:07:53,022 --> 00:07:56,766
web app. It's also the reason why your modules folder

117
00:07:56,798 --> 00:07:59,190
folder is one of the heaviest objects in the universe.

118
00:08:00,490 --> 00:08:04,070
Another reason is that we have lots and lots of transitive dependencies.

119
00:08:04,410 --> 00:08:08,322
The way that we write software has changed. We use dependencies

120
00:08:08,386 --> 00:08:12,070
a lot more liberally, and so installing even a single dependency

121
00:08:12,150 --> 00:08:15,306
often leads to many, many transitive dependencies that come

122
00:08:15,328 --> 00:08:18,666
in as well. A 2019 paper at

123
00:08:18,688 --> 00:08:21,786
the Usenix conference actually found that installing

124
00:08:21,818 --> 00:08:25,854
an average NPM packages package introduces an implicit trust on

125
00:08:25,892 --> 00:08:29,722
79 3rd party packages and 39 maintainers,

126
00:08:29,786 --> 00:08:32,830
creating a surprisingly large attack surface.

127
00:08:33,810 --> 00:08:37,060
And so what we have here is a visualization that

128
00:08:37,430 --> 00:08:41,314
my team at socket created that shows you what webpack looks

129
00:08:41,352 --> 00:08:44,638
like if you kind of go into the your modules

130
00:08:44,654 --> 00:08:48,054
folder and really look at what's inside. So each gray box

131
00:08:48,092 --> 00:08:51,974
here represents a package and each purple box represents a

132
00:08:52,012 --> 00:08:55,542
file or files inside of a package. And so as you

133
00:08:55,596 --> 00:08:59,106
take away each layer of the dependency tree, you'll see that you just keep finding

134
00:08:59,138 --> 00:09:03,206
more and more packages nested inside the top level package

135
00:09:03,318 --> 00:09:06,506
until you eventually get down to the bottom here. But this is just an

136
00:09:06,528 --> 00:09:10,042
insane number of files and just a lot of modules flying around

137
00:09:10,096 --> 00:09:13,840
here. The next reason is that no one really reads the code.

138
00:09:14,690 --> 00:09:18,382
There are some people who do, but by and large people

139
00:09:18,436 --> 00:09:21,390
don't look at the code that they're executing on their machines.

140
00:09:22,290 --> 00:09:25,806
One big reason is that NPM really doesn't make this very easy. If you

141
00:09:25,828 --> 00:09:29,106
go to the package page for Uapserjs and you click on the

142
00:09:29,128 --> 00:09:32,286
Explore tab here, you'll see that you can't even see the files

143
00:09:32,318 --> 00:09:35,646
of this package. So people have to resort to clicking

144
00:09:35,678 --> 00:09:39,014
the GitHub link and going and checking GitHub and hoping that the code

145
00:09:39,052 --> 00:09:42,994
on GitHub matches the code that's on NPM, which is not necessarily

146
00:09:43,042 --> 00:09:46,566
true. But that's okay. That's okay. We can rely on

147
00:09:46,588 --> 00:09:50,330
Linus's law that given enough eyeballs, all bugs are shallow.

148
00:09:51,070 --> 00:09:54,774
So if there is a security issue in a package or malware

149
00:09:54,822 --> 00:09:58,202
in a package, we can rely on others to find it,

150
00:09:58,336 --> 00:10:01,690
right? But if everyone does that,

151
00:10:01,760 --> 00:10:05,582
then who is finding the malware? And so maybe this is the reason

152
00:10:05,636 --> 00:10:09,870
why, on average, a malicious package is available for 209 days before

153
00:10:09,940 --> 00:10:13,354
it's publicly reported. This comes from

154
00:10:13,412 --> 00:10:16,530
a research paper by Omital.

155
00:10:17,430 --> 00:10:20,914
So that's 209 days during which the wrong NPM command can end

156
00:10:20,952 --> 00:10:24,530
extremely badly. And I find this number personally very shocking.

157
00:10:26,070 --> 00:10:29,974
A 2021 paper at NDSS, a prestigious security conference, also found

158
00:10:30,012 --> 00:10:33,506
similar results, including that 20% of these malware persist in package

159
00:10:33,538 --> 00:10:37,190
managers for over 400 days and have more than 1000 downloads.

160
00:10:38,330 --> 00:10:41,674
And the fourth reason is that popular tools give a false sense

161
00:10:41,712 --> 00:10:45,226
of security. A lot of popular tools scan for

162
00:10:45,248 --> 00:10:49,546
known vulnerabilities. So in 2022, I believe this

163
00:10:49,568 --> 00:10:52,766
is no longer sufficient. We can't just scan for known vulnerabilities and

164
00:10:52,788 --> 00:10:56,958
stop there. And yet, that's what the most popular supply chain security products

165
00:10:57,044 --> 00:11:00,622
do, leaving you vulnerable. The thing is, it can take weeks

166
00:11:00,676 --> 00:11:04,702
or months for a CVE or a known vulnerability to be discovered,

167
00:11:04,766 --> 00:11:08,162
reported, and detected by tools. And so

168
00:11:08,216 --> 00:11:11,666
it's just not fast enough. So it may

169
00:11:11,688 --> 00:11:15,022
be worth taking a minute here to just quickly distinguish between

170
00:11:15,176 --> 00:11:18,680
known vulnerabilities and malware, because they're very different.

171
00:11:19,530 --> 00:11:22,966
Vulnerabilities are accidentally introduced by maintainers, by the good

172
00:11:22,988 --> 00:11:26,834
guys, and they have varying levels of risk. So sometimes it's

173
00:11:26,882 --> 00:11:30,402
okay to intentionally ship a known vulnerability to production

174
00:11:30,466 --> 00:11:34,374
if it's low impact. Even if you have vulnerabilities

175
00:11:34,422 --> 00:11:37,818
in production, they may not be discovered or exploited before you update to a

176
00:11:37,824 --> 00:11:42,154
fixed version. So you have some time to address these kinds of issues, usually now.

177
00:11:42,192 --> 00:11:46,334
Malware, on the other hand, is quite different. Malware is intentionally introduced into

178
00:11:46,372 --> 00:11:50,078
a package by an attacker, almost never the maintainer, and it

179
00:11:50,084 --> 00:11:53,630
will always end badly if you ship malware to production. You don't have

180
00:11:53,700 --> 00:11:56,926
a few days or weeks to mitigate the issue. You need to really catch

181
00:11:56,958 --> 00:12:01,090
it before you install it on your laptop or on a production server.

182
00:12:02,710 --> 00:12:06,130
But in today's culture of fast development, a malicious dependency

183
00:12:06,210 --> 00:12:09,414
can be updated and merged in a very short amount

184
00:12:09,452 --> 00:12:11,030
of time. And so unfortunately,

185
00:12:13,850 --> 00:12:17,526
this leads to increased risk of supply chain attacks because

186
00:12:17,548 --> 00:12:20,646
the quicker you update your dependencies, the fewer eyeballs that have had a chance to

187
00:12:20,668 --> 00:12:24,346
look at the code. So I really think we need a new approach to

188
00:12:24,368 --> 00:12:27,834
detect and to block malicious dependencies. But before we get into

189
00:12:27,872 --> 00:12:31,306
that, let's look a little deeper into how a supply

190
00:12:31,338 --> 00:12:34,400
chain attack actually works and the mechanics of it.

191
00:12:35,010 --> 00:12:38,346
So we downloaded every package on NPM

192
00:12:38,458 --> 00:12:41,994
and we spent a few weeks poking around. The download

193
00:12:42,122 --> 00:12:46,450
was 100 gigs of metadata and 15 terabytes of packaged tarballs.

194
00:12:47,590 --> 00:12:50,786
And as we poked around this metadata and

195
00:12:50,808 --> 00:12:54,382
all these packages, we noticed a few trends

196
00:12:54,446 --> 00:12:57,758
in the types of attacks we saw. So I'm

197
00:12:57,774 --> 00:13:00,680
going to go over these attacks. These are what we found.

198
00:13:01,210 --> 00:13:04,706
So there are attack vectors, which is sort of how the attacker tricks

199
00:13:04,738 --> 00:13:07,206
you and gets you to run their code in the first place. And then there

200
00:13:07,228 --> 00:13:10,426
are attack tactics, which are whats the

201
00:13:10,448 --> 00:13:14,986
attack code actually does, or the techniques that the attacker uses to

202
00:13:15,008 --> 00:13:17,500
get their code or to hide their code.

203
00:13:18,190 --> 00:13:21,710
So let's talk about attack vectors. The first and the most common

204
00:13:21,780 --> 00:13:25,306
attack vector is typo squatting. So typo

205
00:13:25,338 --> 00:13:29,066
squatting is when an attacker publishes

206
00:13:29,098 --> 00:13:32,234
a package which has a very similar name to a legitimate and popular

207
00:13:32,282 --> 00:13:35,710
package. And so you can see here theyre are two packages here with very similar

208
00:13:35,780 --> 00:13:39,394
names, and one of these is malware and one of these is the real

209
00:13:39,432 --> 00:13:42,578
package. But I would guess that it would be hard for you to know that

210
00:13:42,664 --> 00:13:46,500
without actually cracking open these packages to see what's inside.

211
00:13:48,230 --> 00:13:51,318
So let's open up the malware package and take a look

212
00:13:51,324 --> 00:13:54,674
at whats it's doing. So you can see here again, it's using an install script,

213
00:13:54,722 --> 00:13:57,442
which is a very common technique that malware uses.

214
00:13:57,586 --> 00:14:00,614
And if you open up this install script to look at the code, you'll find

215
00:14:00,652 --> 00:14:04,106
that the file is heavily obfuscated. But I can tell you,

216
00:14:04,128 --> 00:14:07,066
even without knowing exactly what this code is doing, you can bet this is not

217
00:14:07,088 --> 00:14:08,890
something that you want to run on your machine.

218
00:14:11,330 --> 00:14:14,846
The next attack vector that

219
00:14:14,868 --> 00:14:18,346
we saw is called dependency confusion. So this is pretty closely

220
00:14:18,378 --> 00:14:22,634
related to typo squatting. Dependency confusion happens when a company publishes

221
00:14:22,682 --> 00:14:25,930
packages to an internal NPM registry and uses a

222
00:14:25,940 --> 00:14:29,406
name that hasn't been taken yet on the public NPM registry.

223
00:14:29,518 --> 00:14:33,086
And so later an attacker can come along and register

224
00:14:33,198 --> 00:14:36,482
a package with the same name as the public version and

225
00:14:36,536 --> 00:14:40,118
confuse internal tools so that internal tools will accidentally install

226
00:14:40,204 --> 00:14:43,800
the public version. So this is why it's called a dependency confusion attack.

227
00:14:44,570 --> 00:14:47,990
So looking through the recently deleted NPM packages, we were able to find

228
00:14:48,060 --> 00:14:51,622
a bunch of likely dependency confusion attacks and most of these packages

229
00:14:51,686 --> 00:14:55,466
had malicious code in them. So all these packages have names which

230
00:14:55,488 --> 00:14:58,838
appear to conflict with internal company package names.

231
00:14:58,934 --> 00:15:02,538
You can see here a whole bunch of different organizations, including governments,

232
00:15:02,634 --> 00:15:06,046
were affected by this. And here are

233
00:15:06,068 --> 00:15:09,646
a bunch more clearly targeting these specific companies here in

234
00:15:09,668 --> 00:15:13,150
this list. And finally,

235
00:15:13,220 --> 00:15:16,446
the third vector that we see a lot is hijacked

236
00:15:16,478 --> 00:15:19,538
packages. So these are the ones that you usually see in the news quite a

237
00:15:19,544 --> 00:15:23,534
lot. So criminals and thieves finding ways to infiltrate

238
00:15:23,582 --> 00:15:27,106
our communities and infect popular packages. Once they

239
00:15:27,128 --> 00:15:30,406
infect a popular package, once they get control of it and they can publish to

240
00:15:30,428 --> 00:15:34,386
it, they'll steal credentials or install backdoors or abuse

241
00:15:34,418 --> 00:15:37,800
compute resources for cryptocurrency mining. And so

242
00:15:42,170 --> 00:15:45,674
these happen for various reasons. So sometimes it's because

243
00:15:45,712 --> 00:15:48,886
the maintainer chooses a weak password or reuses the password,

244
00:15:49,078 --> 00:15:52,550
or maybe the maintainer gets malware on their laptops. This is

245
00:15:52,560 --> 00:15:55,930
also kind of not helped by the fact whats NPM doesn't

246
00:15:56,010 --> 00:15:59,646
enforce two FA for all accounts currently, although they

247
00:15:59,668 --> 00:16:03,070
are starting to enforce this for the most popular accounts.

248
00:16:03,810 --> 00:16:07,314
And finally, sometimes maintainers just get tricked and give

249
00:16:07,352 --> 00:16:11,026
access to a malicious actor. This is partially just

250
00:16:11,048 --> 00:16:14,254
due to the fact that maintainers are overworked and when someone offers

251
00:16:14,302 --> 00:16:18,246
a helping hand, it's sometimes hard to say no to

252
00:16:18,268 --> 00:16:21,686
the help. So this is also a big vector as

253
00:16:21,708 --> 00:16:25,350
well. So now let's talk about some attack

254
00:16:25,420 --> 00:16:29,240
tactics. So what does this attack code actually do?

255
00:16:29,630 --> 00:16:33,574
So as we mentioned, install scripts are a huge vector. Most malware

256
00:16:33,622 --> 00:16:37,066
is in install scripts. And so this

257
00:16:37,088 --> 00:16:40,690
is a quote from a paper we mentioned earlier. So most malicious packages

258
00:16:40,790 --> 00:16:44,798
actually 56% start their routines upon installation, which might be

259
00:16:44,804 --> 00:16:47,534
due to poor handling of arbitrary code during install.

260
00:16:47,732 --> 00:16:50,986
So in the NPM

261
00:16:51,018 --> 00:16:54,846
package manager, packages are allowed to just say, hey, when this package is

262
00:16:54,868 --> 00:16:58,834
installed we want to run some code. And so unfortunately though,

263
00:16:58,872 --> 00:17:02,050
install scripts do have some legitimate uses, so we can't just disable them.

264
00:17:02,200 --> 00:17:05,478
It's not an easy problem to solve. So let's take a

265
00:17:05,484 --> 00:17:09,190
look at just another example of an install script.

266
00:17:09,690 --> 00:17:13,240
Again, you'll see it right here in the package JSON file. Super common.

267
00:17:16,410 --> 00:17:20,090
The next is privileged API usage. So we see

268
00:17:20,240 --> 00:17:23,514
packages accessing the network, accessing the file system,

269
00:17:23,632 --> 00:17:27,882
and accessing environmental variables. This is very,

270
00:17:27,936 --> 00:17:31,594
very common, because when an attacker runs code, what theyre want to do

271
00:17:31,632 --> 00:17:35,630
usually is steal some secrets, and they need the network to exfiltrate those secrets.

272
00:17:36,850 --> 00:17:40,126
So this is a typical example of malware that does that. So you can see

273
00:17:40,148 --> 00:17:43,300
here that it's making an HTTP request to

274
00:17:45,350 --> 00:17:48,718
an IP address and it's sending

275
00:17:48,894 --> 00:17:52,100
some data. The data it happens to be sending is

276
00:17:52,550 --> 00:17:55,922
process n, which contains all the environment variables

277
00:17:56,066 --> 00:18:00,134
in the environment. And then

278
00:18:00,172 --> 00:18:03,842
here is actually another file that it includes, which is a different exfiltration

279
00:18:03,906 --> 00:18:07,398
technique that uses DNS instead of HTTP. So the

280
00:18:07,404 --> 00:18:11,546
way this works is it creates a DNS resolver, and then it

281
00:18:11,568 --> 00:18:15,290
gathers the environment variables, and then it does a DNS

282
00:18:15,790 --> 00:18:19,942
lookup with those variables as the subdomain.

283
00:18:20,006 --> 00:18:23,120
So it's just another way to get the data out of the system.

284
00:18:24,210 --> 00:18:26,720
And finally, we have obfuscated code.

285
00:18:27,250 --> 00:18:30,282
So we took a look at an example of this earlier.

286
00:18:30,426 --> 00:18:34,046
So obfuscated code like this is just obviously, it's really hard

287
00:18:34,068 --> 00:18:37,678
to see at a glance of what it's doing. Although there are tools to attempt

288
00:18:37,694 --> 00:18:40,882
to unoffiscate code like this, there's also another

289
00:18:40,936 --> 00:18:45,390
kind of obfuscation, which is attackers can publish different code to NPM

290
00:18:45,550 --> 00:18:49,014
than they do on GitHub. And so when

291
00:18:49,052 --> 00:18:52,294
they do that, as I mentioned earlier, NPM doesn't make it easy

292
00:18:52,332 --> 00:18:56,066
to see what code is actually in the NPM package.

293
00:18:56,178 --> 00:18:59,286
And so a lot of people who are trying to evaluate a package will rely

294
00:18:59,318 --> 00:19:02,346
on the code that's on GitHub, and there's no guarantee that that code

295
00:19:02,368 --> 00:19:05,322
is the same. Okay,

296
00:19:05,376 --> 00:19:08,060
so now let's talk about how you can protect your.

297
00:19:09,790 --> 00:19:13,482
You know, we asked ourselves this question when we were working

298
00:19:13,536 --> 00:19:16,890
on, my company was working on a product called Wormhole,

299
00:19:16,970 --> 00:19:20,366
which lets you share files with end to end encryption. And our

300
00:19:20,388 --> 00:19:23,690
goal was to try to build the most secure and private way to send files.

301
00:19:23,850 --> 00:19:26,980
So we did all the usual security things that we could think about.

302
00:19:28,070 --> 00:19:31,726
We thought about security early in the design process. We wrote tests, we enforced

303
00:19:31,758 --> 00:19:35,218
code reviews, and we were pretty thoughtful about the dependencies that we chose to use.

304
00:19:35,304 --> 00:19:38,966
But we still felt like we could

305
00:19:38,988 --> 00:19:42,502
do better. And so we started thinking really carefully about

306
00:19:42,556 --> 00:19:46,246
this problem and what we could do to make it better. So the

307
00:19:46,268 --> 00:19:50,410
first kind of thing I recommend is that you can just try choosing better dependencies.

308
00:19:51,870 --> 00:19:55,414
If you ship code to production, you are ultimately responsible

309
00:19:55,462 --> 00:19:58,854
for it. And as an industry, I think we need a mindset

310
00:19:58,902 --> 00:20:02,502
shift here, because people assume

311
00:20:02,566 --> 00:20:05,054
that they can just install stuff from the Internet and that it's going to be

312
00:20:05,092 --> 00:20:07,822
safe and it's not necessarily true.

313
00:20:07,956 --> 00:20:11,786
And if you're shipping code to production that includes open source

314
00:20:11,818 --> 00:20:14,878
code, then really ultimately that code is part of your app,

315
00:20:14,964 --> 00:20:18,882
and so you are ultimately responsible for the behavior of that code.

316
00:20:19,016 --> 00:20:22,382
And the most popular open source license, the MIT license,

317
00:20:22,446 --> 00:20:26,226
actually literally says this. In the license, it says that the open source code is

318
00:20:26,248 --> 00:20:29,678
provided as is with no warranty of any kind, and in no event shall the

319
00:20:29,704 --> 00:20:33,160
author be liable for any claim, damages or liability. And so

320
00:20:33,690 --> 00:20:37,078
while this is legally true, most people don't think of their open source this way.

321
00:20:37,084 --> 00:20:40,170
And I think we really do need a mindset shift.

322
00:20:41,390 --> 00:20:44,326
The other thing is, very few of us actually read the code that we're shipping

323
00:20:44,358 --> 00:20:48,634
to production, and so we

324
00:20:48,672 --> 00:20:51,894
rely on other heuristics to help pick dependencies.

325
00:20:52,022 --> 00:20:55,326
So maybe we look at does the code get the job done? Does it have

326
00:20:55,348 --> 00:20:59,146
an open source license, does it have good docs, does it have lots of downloads

327
00:20:59,178 --> 00:21:03,082
and GitHub stars, does it have recent commits, does it have types?

328
00:21:03,226 --> 00:21:07,234
And does it have tests? And we're not really cracking open the code to go

329
00:21:07,272 --> 00:21:10,706
much beyond this. So what that means is

330
00:21:10,728 --> 00:21:14,354
that we're sort of not aware of what the code

331
00:21:14,392 --> 00:21:18,286
may be doing. And so we built a tool at socket

332
00:21:18,318 --> 00:21:21,958
to help with this problem so you can quickly at a glance get an idea

333
00:21:22,044 --> 00:21:25,702
of the security of a package. And so this is what it looks like.

334
00:21:25,836 --> 00:21:29,442
So you can go to socket and look up packages

335
00:21:29,586 --> 00:21:33,706
to figure out what behavior the package has. And so in

336
00:21:33,728 --> 00:21:37,366
this example here, you can see that this package contains install scripts and that's

337
00:21:37,398 --> 00:21:40,602
called out very prominently on the page. So that's the first thing whats you see.

338
00:21:40,736 --> 00:21:44,474
And this package also happens to contain binary

339
00:21:44,602 --> 00:21:48,286
or native code, which means that it's not easy to audit the

340
00:21:48,308 --> 00:21:51,226
code. It's not like human readable.

341
00:21:51,338 --> 00:21:54,254
And so both of these issues are called out. And in this case it's not

342
00:21:54,292 --> 00:21:57,498
necessarily, and this is not a supply chain attack by any

343
00:21:57,524 --> 00:22:01,186
means, but it is nice that this is called out very prominently so

344
00:22:01,208 --> 00:22:03,778
that you can make an informed decision if you want to use this package or

345
00:22:03,784 --> 00:22:07,170
not. You can also see that we have very helpful quality

346
00:22:07,240 --> 00:22:10,040
scores that show up at the top of the page as well.

347
00:22:10,570 --> 00:22:14,178
Now let's take a look at another example. So this package here, angular calendar,

348
00:22:14,274 --> 00:22:17,662
is quite a useful package. It's a calendar component

349
00:22:17,746 --> 00:22:21,434
that shows up on the page and renders a little

350
00:22:21,472 --> 00:22:24,698
calendar. But if you dig into

351
00:22:24,784 --> 00:22:28,534
its dependencies you'll actually find that some of its dependencies

352
00:22:28,582 --> 00:22:31,866
are doing quite invasive things. So here you'll

353
00:22:31,898 --> 00:22:34,858
see that one of its dependencies contains install scripts.

354
00:22:35,034 --> 00:22:38,986
It also runs the shell scripts

355
00:22:39,178 --> 00:22:42,030
and accesses a file system and accesses the network.

356
00:22:42,610 --> 00:22:46,026
So this is probably not something that you would

357
00:22:46,068 --> 00:22:49,746
expect a component, a web component to be

358
00:22:49,768 --> 00:22:53,214
doing. And so it may be worth a little bit of further investigation

359
00:22:53,262 --> 00:22:55,970
to figure out what's going on here before you use this package.

360
00:22:57,430 --> 00:23:01,010
The other thing that we do that's quite cool is we can highlight

361
00:23:01,170 --> 00:23:04,454
when packages do these things and put

362
00:23:04,492 --> 00:23:07,558
that directly in line in the code. So in this package here, I opened it

363
00:23:07,564 --> 00:23:10,534
up to take a look at the files, and I could see here that the

364
00:23:10,572 --> 00:23:13,686
module is accessing the network as well as accessing environment variables.

365
00:23:13,718 --> 00:23:16,954
And I can see the exact lines where the package is doing each of these

366
00:23:16,992 --> 00:23:20,154
things. And so it makes it a little bit easier to get an idea

367
00:23:20,192 --> 00:23:22,780
of what a package is doing before you run it.

368
00:23:23,630 --> 00:23:27,614
So if you want to research packages on socket before you use

369
00:23:27,652 --> 00:23:31,038
them, this is the URL you can use, and I highly recommend you take a

370
00:23:31,044 --> 00:23:35,314
look at some packages there and use that information

371
00:23:35,432 --> 00:23:38,290
to make an informed decision before you select a package.

372
00:23:39,510 --> 00:23:43,886
Okay. The other thing you can do is think about updating

373
00:23:43,918 --> 00:23:46,370
your dependencies at the right cadence.

374
00:23:46,950 --> 00:23:50,818
So what do I mean by this? So there's

375
00:23:50,834 --> 00:23:54,006
a question about how quickly you should update your dependencies. And this is actually a

376
00:23:54,028 --> 00:23:56,520
question we struggled with on our team as well.

377
00:23:57,610 --> 00:24:00,986
So you can think of it as should we update slowly or

378
00:24:01,008 --> 00:24:04,214
should we update really really quickly and aggressively. If you update

379
00:24:04,262 --> 00:24:08,554
too slowly, you're exposed to known vulnerabilities and

380
00:24:08,592 --> 00:24:11,818
you're running code that's old and that may have issues, may have some

381
00:24:11,824 --> 00:24:15,006
bugs that have been fixed in the newer version. And so there's some downsides to

382
00:24:15,028 --> 00:24:18,702
updating too slowly. On the other hand, if you update too quickly,

383
00:24:18,836 --> 00:24:22,542
you expose yourself to supply chain attacks because you're now running code

384
00:24:22,596 --> 00:24:25,982
that may have been published literally yesterday or

385
00:24:26,036 --> 00:24:29,774
in the last couple of days, which means whats, you haven't had that many eyeballs

386
00:24:29,822 --> 00:24:33,186
able to look at the code. And so as

387
00:24:33,208 --> 00:24:37,014
you think about security, you have to balance this

388
00:24:37,052 --> 00:24:40,406
trade off. And there really is no perfect solution here.

389
00:24:40,588 --> 00:24:44,422
It's just a hard problem. Another idea

390
00:24:44,476 --> 00:24:48,746
is to audit every dependency. So if

391
00:24:48,768 --> 00:24:52,266
you're building a truly security critical application like we were

392
00:24:52,288 --> 00:24:55,914
doing with wormhole, then one option

393
00:24:55,952 --> 00:24:58,970
is to literally read every line of code of your dependencies.

394
00:24:59,550 --> 00:25:03,626
So if we chain put this on an axis

395
00:25:03,818 --> 00:25:07,134
of starting from full audit on the one hand

396
00:25:07,252 --> 00:25:10,800
reading every line of code to yoloing, on the other hand.

397
00:25:11,890 --> 00:25:15,726
By yoloing I mean like doing nothing. How closely should

398
00:25:15,748 --> 00:25:19,010
you audit your dependencies? And what you see here is we're in the same situation,

399
00:25:19,080 --> 00:25:22,754
we have trade offs and really no good solutions. So doing a full

400
00:25:22,792 --> 00:25:26,370
audit is something that only the biggest and

401
00:25:26,440 --> 00:25:30,034
richest companies seem to do in practice. It's a lot of

402
00:25:30,072 --> 00:25:33,526
work. Usually you need to have a security team looking at every one of

403
00:25:33,548 --> 00:25:37,126
these packages, and they also have to approve them one at a time and add

404
00:25:37,148 --> 00:25:40,246
them to can allow list, which is really slow. And this

405
00:25:40,268 --> 00:25:43,820
is expensive just because of the time and the effort that it takes.

406
00:25:44,430 --> 00:25:47,526
On the other hand doing nothing and just installing

407
00:25:47,558 --> 00:25:51,898
whatever you want without even looking at the code. Whats its downsides?

408
00:25:51,914 --> 00:25:56,026
So it means that you're vulnerable to supply chain attacks. It's risky,

409
00:25:56,138 --> 00:26:00,080
and a breach or bad security press

410
00:26:00,530 --> 00:26:03,598
can be expensive, especially as regulators start to crack down on

411
00:26:03,604 --> 00:26:07,058
this issue more. And so this is another difficult trade off.

412
00:26:07,144 --> 00:26:10,786
What do you do? And most teams I think, err on

413
00:26:10,808 --> 00:26:14,962
the side of doing nothing, but I think

414
00:26:15,096 --> 00:26:18,806
this is just a hard problem. So one thing that we tried to do when

415
00:26:18,828 --> 00:26:22,214
we were building wormhole is to sort of think about a happy

416
00:26:22,252 --> 00:26:25,974
medium. Is there a way to use automation to

417
00:26:26,012 --> 00:26:29,686
kind of do something in the middle? And so

418
00:26:29,868 --> 00:26:33,082
what we want to do, and what we ended up doing is using

419
00:26:33,136 --> 00:26:36,330
automation to automatically evaluate all of our dependencies.

420
00:26:36,750 --> 00:26:40,346
So we could use static analysis to look through packages to

421
00:26:40,368 --> 00:26:44,654
try to find malware, hidden code, typo, squatting attacks and

422
00:26:44,692 --> 00:26:47,882
this kind of thing. And that way we could manually audit

423
00:26:47,946 --> 00:26:51,550
only the most suspicious packages so we could spend our

424
00:26:51,620 --> 00:26:55,294
limited team resources looking at the code for

425
00:26:55,492 --> 00:26:59,218
the most suspicious packages. And that's the most high impact way that we

426
00:26:59,224 --> 00:27:02,946
could spend our time. And so this seems much better to me than an all

427
00:27:02,968 --> 00:27:06,706
or nothing approach where you either audit everything or you just hope for

428
00:27:06,728 --> 00:27:10,166
the best and look at nothing. And then the other thing we wanted to do

429
00:27:10,188 --> 00:27:13,750
is make sure that the security information was shown

430
00:27:14,090 --> 00:27:17,366
directly in pull requests, so that the developers on

431
00:27:17,388 --> 00:27:20,810
our team were empowered to solve the security issues that they saw

432
00:27:20,880 --> 00:27:25,050
before they deployed into production. So what does this actually

433
00:27:25,120 --> 00:27:29,414
look like? So this is the bot that we created. It's implemented

434
00:27:29,462 --> 00:27:32,858
as a GitHub app that you can install on your

435
00:27:33,024 --> 00:27:36,446
GitHub repository. And whenever it sees that

436
00:27:36,468 --> 00:27:40,202
the package JSON file or the yarn lock file has been modified,

437
00:27:40,346 --> 00:27:43,742
it will take a look at the new dependency that's been added and it will

438
00:27:43,876 --> 00:27:47,214
run a full health report against that dependency.

439
00:27:47,342 --> 00:27:51,006
And if there's any issues found in it, it will leave a comment

440
00:27:51,118 --> 00:27:54,174
with whatever the issue is that was discovered.

441
00:27:54,302 --> 00:27:57,638
And so that way the developer reviewing the pull request can

442
00:27:57,724 --> 00:28:01,254
look at it and have their attention drawn to this potential issue.

443
00:28:01,452 --> 00:28:05,282
In this screenshot here, you can see that I accidentally

444
00:28:05,346 --> 00:28:09,334
installed the package browser list instead of browsers

445
00:28:09,382 --> 00:28:12,780
list, which is actually a very easy mistake to make.

446
00:28:13,950 --> 00:28:17,814
And actually for that reason, browser list, the typo

447
00:28:17,862 --> 00:28:22,458
package actually has something like 700,000 downloads

448
00:28:22,474 --> 00:28:25,806
a year. So this is really, really helpful. This is the kind of

449
00:28:25,828 --> 00:28:28,622
thing that augments your review process,

450
00:28:28,676 --> 00:28:32,654
and it's very low cost since it only

451
00:28:32,692 --> 00:28:35,934
raises issues that are really worth your

452
00:28:35,972 --> 00:28:39,506
attention. And it runs automatically. So if you want

453
00:28:39,528 --> 00:28:43,138
to actually try this app out, we've actually published it for anyone to use.

454
00:28:43,304 --> 00:28:47,350
It's free, so you can install our GitHub app by just going to socket dev,

455
00:28:47,500 --> 00:28:51,320
and I recommend you give it a try and let me know what you think.

456
00:28:51,930 --> 00:28:55,480
It has a bunch of cool features, so it actually can

457
00:28:55,850 --> 00:28:59,158
block typo squats, which as I just showed

458
00:28:59,174 --> 00:29:03,226
you earlier, but also can block malware, detect hidden code,

459
00:29:03,328 --> 00:29:07,018
detect privileged API usage such as the use of

460
00:29:07,024 --> 00:29:10,574
file system, network, child process, et cetera. And also

461
00:29:10,612 --> 00:29:13,834
it can detect suspicious updates. So these are updates

462
00:29:13,882 --> 00:29:16,190
that significantly change the package's behavior.

463
00:29:17,490 --> 00:29:20,910
So we have a whole bunch of things we look for

464
00:29:20,980 --> 00:29:24,322
in packages. We actually have 70 detections in five

465
00:29:24,376 --> 00:29:28,510
different categories. So we have supply chain risk,

466
00:29:28,590 --> 00:29:32,302
quality, maintenance, known vulnerabilities and license.

467
00:29:32,446 --> 00:29:35,698
And we wrote, basically these are just all static analysis rules that we

468
00:29:35,704 --> 00:29:38,246
wrote. You can kind of think of this as a linter in a way.

469
00:29:38,268 --> 00:29:41,766
So it's sort of looking at the packages code and

470
00:29:41,788 --> 00:29:44,760
then looking for these different problems.

471
00:29:45,610 --> 00:29:49,546
We tried to focus all of the rules on problems which

472
00:29:49,648 --> 00:29:53,158
are something that you as a user

473
00:29:53,174 --> 00:29:57,606
of the package really want to know about and not things that require

474
00:29:57,718 --> 00:30:00,918
a lot of knowledge of the internals of the package.

475
00:30:01,014 --> 00:30:04,074
So the things that it finds need to be actionable

476
00:30:04,202 --> 00:30:07,642
to you as the developer choosing to use this package.

477
00:30:07,786 --> 00:30:11,760
And so that's what we tried to do in our rule development here.

478
00:30:12,290 --> 00:30:15,170
So yeah, if you want to try this out, if you want to poke around

479
00:30:15,320 --> 00:30:18,990
our website and look at these different issues, you can try it out at socket

480
00:30:19,070 --> 00:30:22,706
dev. And we have

481
00:30:22,728 --> 00:30:26,066
made it free for open source forever. And if

482
00:30:26,088 --> 00:30:28,950
you have a private repo, it's free while we're in beta.

483
00:30:29,450 --> 00:30:33,430
And I really do want people to give this a shot

484
00:30:33,770 --> 00:30:37,474
and share their feedback with us because this supply chain

485
00:30:37,522 --> 00:30:40,754
security problem is big and only getting bigger,

486
00:30:40,882 --> 00:30:44,166
and I really do want the community to share

487
00:30:44,188 --> 00:30:47,606
their feedback with me on this. I think together we can

488
00:30:47,708 --> 00:30:51,166
really do a good job improving supply chain security in

489
00:30:51,188 --> 00:30:54,894
2022 and making 2022 not the year

490
00:30:54,932 --> 00:30:58,174
that the supply chain is destroyed, but rather the year that

491
00:30:58,372 --> 00:31:02,106
it's protected better than ever. So please share your feedback

492
00:31:02,138 --> 00:31:05,966
with me. There's my email and my twitter, and also we're hiring at

493
00:31:05,988 --> 00:31:09,726
socket if you're interested in working on this project and

494
00:31:09,828 --> 00:31:13,406
helping to secure the software supply chain. Thanks for

495
00:31:13,428 --> 00:31:13,660
your time.

