1
00:00:17,450 --> 00:00:20,906
Hey everybody, this is Brian Sambodden. Welcome to extending

2
00:00:20,938 --> 00:00:24,866
Redis with Rust. I am a developer advocate with Redis.

3
00:00:25,018 --> 00:00:28,946
You can reach me at bsb@redis.com on Twitter at bsbodin.

4
00:00:28,978 --> 00:00:32,466
And you can also check out my GitHub repos. So Redis

5
00:00:32,578 --> 00:00:36,450
Redis, it's a popular data platform that it's

6
00:00:36,530 --> 00:00:39,714
mostly known as a very powerful and fast cache.

7
00:00:39,842 --> 00:00:42,458
But Redis is much more than that. So today I want to give you a

8
00:00:42,464 --> 00:00:46,054
quick tour of Redis before we look at how to extend Redis

9
00:00:46,102 --> 00:00:49,954
for your own benefit. So Redis stands for remote dictionary

10
00:00:50,022 --> 00:00:54,026
server. In Redis it's

11
00:00:54,058 --> 00:00:57,774
really an in memory first full blown database with

12
00:00:57,812 --> 00:01:00,670
optional persistence out of the box.

13
00:01:00,820 --> 00:01:04,366
Redis provides many data types. In Redis

14
00:01:04,398 --> 00:01:08,322
is classified as a key value database. But the difference

15
00:01:08,376 --> 00:01:12,226
between redis and most key value databases or key value

16
00:01:12,328 --> 00:01:15,734
stores is that the value part in redis can be

17
00:01:15,772 --> 00:01:20,230
anything you can dream of out of the box. You get strings,

18
00:01:20,890 --> 00:01:23,922
bitmaps, bit fields, hashes,

19
00:01:24,066 --> 00:01:26,770
list sets, sorted sets,

20
00:01:26,850 --> 00:01:30,842
geospatial indexes, hyperlog logs, funny name and

21
00:01:30,896 --> 00:01:34,346
streams. But there's more, and those are all

22
00:01:34,368 --> 00:01:38,074
the values that can be addressed as using a key in

23
00:01:38,112 --> 00:01:41,022
Redis. But like I said, there is much more than that.

24
00:01:41,076 --> 00:01:45,166
You can extend Redis by adding new

25
00:01:45,348 --> 00:01:49,562
data types and new commands to manipulate those data types

26
00:01:49,706 --> 00:01:53,198
ourselves as a company we promote seven different

27
00:01:53,284 --> 00:01:56,590
modules that extend redis with new data types and commands.

28
00:01:56,750 --> 00:01:59,614
Those are Redis JSON Redis search, redis,

29
00:01:59,662 --> 00:02:03,474
graph, time series, AI gears and bloom. And they

30
00:02:03,512 --> 00:02:06,590
extend Redis to basically behave like a document database,

31
00:02:06,670 --> 00:02:09,938
a full blown search engine, a graph database,

32
00:02:10,114 --> 00:02:13,174
et cetera. And now for a quick

33
00:02:13,212 --> 00:02:14,390
tour of redis.

34
00:02:16,650 --> 00:02:20,362
So before we get started with our module building, let's take a quick

35
00:02:20,416 --> 00:02:23,770
tour of redis by starting a Redis server.

36
00:02:24,430 --> 00:02:28,202
And I'm running Redis 7.0.4 which is running

37
00:02:28,256 --> 00:02:31,740
on port 63 79 which is the default Redis board.

38
00:02:32,190 --> 00:02:35,626
And on a separate terminal I'm going to start the Redis

39
00:02:35,658 --> 00:02:39,486
CLI which is the command line interface for Redis, and by

40
00:02:39,508 --> 00:02:43,486
default it connects to the localhost 62 79. So one

41
00:02:43,508 --> 00:02:46,706
of the basic data types or the most basic data type that you can keep

42
00:02:46,728 --> 00:02:50,734
in Redis, it's a string, and that is the basic

43
00:02:50,782 --> 00:02:54,722
level key that you have in Redis. So I'm going to

44
00:02:54,856 --> 00:02:58,786
create a key called actor column one

45
00:02:58,888 --> 00:03:02,946
and give it the value covey smolders. Now, in Redis,

46
00:03:03,058 --> 00:03:07,094
it's very typical to create your own namespace for your keys by

47
00:03:07,132 --> 00:03:10,346
using a separator like the column in my case.

48
00:03:10,448 --> 00:03:13,850
So I can retrieve my key back from

49
00:03:13,920 --> 00:03:17,290
Redis, and it gives me the string that I set

50
00:03:17,440 --> 00:03:21,038
copy's molders. And I can also inspect a key

51
00:03:21,124 --> 00:03:24,382
to see what value it's holding. In this case,

52
00:03:24,516 --> 00:03:28,462
it's a string. Let's set another key

53
00:03:28,516 --> 00:03:31,998
here. Actor two. Let's make this one.

54
00:03:32,084 --> 00:03:35,730
Karen Gillen. As you can see, I'm using

55
00:03:35,800 --> 00:03:39,954
Marvel characters in here, and again, I can retrieve the value

56
00:03:40,072 --> 00:03:41,220
of that key.

57
00:03:42,950 --> 00:03:46,754
And if, for example, I try to retrieve a value of a key that doesn't

58
00:03:46,802 --> 00:03:49,480
exist, I get a nil back.

59
00:03:50,330 --> 00:03:53,240
And you can also set, for example,

60
00:03:55,530 --> 00:03:59,642
encoded strings, escape strings. Pretty much

61
00:03:59,776 --> 00:04:04,074
any binary piece of data can be stored in a redis key.

62
00:04:04,272 --> 00:04:07,882
So I can say get actor three.

63
00:04:08,016 --> 00:04:11,882
And you can see my wonderful misspelling

64
00:04:11,946 --> 00:04:14,640
of Benedict Cumberbatch's name.

65
00:04:15,330 --> 00:04:19,230
You can see here that I can also pass.

66
00:04:19,300 --> 00:04:22,678
For example, I can set a key passing

67
00:04:22,714 --> 00:04:25,986
the nx flag that basically means set it if it

68
00:04:26,008 --> 00:04:29,954
doesn't exist. So in our case, that's going to

69
00:04:30,152 --> 00:04:33,460
have no effect on the original set value.

70
00:04:33,990 --> 00:04:37,990
But if I pass the xx flag,

71
00:04:38,410 --> 00:04:41,640
then it will override the value that was there before.

72
00:04:43,450 --> 00:04:47,118
So in Redis, I can list all the keys

73
00:04:47,314 --> 00:04:50,140
by passing the keys command in star.

74
00:04:50,750 --> 00:04:54,330
And that's obviously not recommended in production, since thread is

75
00:04:54,400 --> 00:04:57,878
meant to hold millions or billions of keys.

76
00:04:58,054 --> 00:05:01,422
But it's okay in debugging session like this.

77
00:05:01,556 --> 00:05:03,520
So I can also delete a key,

78
00:05:06,210 --> 00:05:09,406
and I can check if a key exists in

79
00:05:09,428 --> 00:05:10,160
the system.

80
00:05:13,910 --> 00:05:17,550
All right, so that is the most basic data type in redis.

81
00:05:17,710 --> 00:05:21,438
We also have hashes.

82
00:05:21,614 --> 00:05:26,262
In hashes. It's the very typical data

83
00:05:26,316 --> 00:05:30,466
type used for mapping programming language constructs

84
00:05:30,498 --> 00:05:34,018
like structs or classes objects

85
00:05:34,114 --> 00:05:38,274
to redis. So in these example, I'm going to use the hmset

86
00:05:38,322 --> 00:05:41,630
command, which sets multiple values on a hash,

87
00:05:41,810 --> 00:05:45,354
and I'm going to use the actor one key.

88
00:05:45,392 --> 00:05:48,378
So I'm going to override the key that we had in there, and I'm going

89
00:05:48,384 --> 00:05:52,394
to pass a name value pairs for an actor.

90
00:05:52,442 --> 00:05:56,074
And in this case, I'm passing the name Anthony Mackey.

91
00:05:56,202 --> 00:06:00,122
Year of birth, 1978. Place of birth, New Orleans, New Orleans,

92
00:06:00,186 --> 00:06:04,260
USA. All right, so I can now check my keys again,

93
00:06:05,030 --> 00:06:09,170
and I can do an h get all. So give me all the name value

94
00:06:09,240 --> 00:06:13,554
pairs from a hash actor one,

95
00:06:13,752 --> 00:06:17,170
and you can see that I gave my name value pairs

96
00:06:17,250 --> 00:06:18,200
back out.

97
00:06:21,930 --> 00:06:25,510
Hashes are kind of the workhorse of Redis. So, for example,

98
00:06:25,580 --> 00:06:29,930
I can say h

99
00:06:30,000 --> 00:06:30,730
exists,

100
00:06:35,150 --> 00:06:38,586
actor one, and pass

101
00:06:38,768 --> 00:06:42,510
the string character, and it will tell me whether

102
00:06:42,580 --> 00:06:45,726
that hash has been set, that value has

103
00:06:45,748 --> 00:06:49,006
been set in that hash. So, for example, now let's go ahead

104
00:06:49,028 --> 00:06:52,714
and set that individual value. So I'm doing

105
00:06:52,772 --> 00:06:56,766
a hn set actor one, passing the character

106
00:06:56,958 --> 00:07:00,834
key and the falcon value or falcon as the value.

107
00:07:00,952 --> 00:07:04,542
And now if I check again for existence of that flag,

108
00:07:04,686 --> 00:07:07,800
of that field, you can see that I get a one instead of a zero.

109
00:07:08,170 --> 00:07:12,582
And once again, I can do an h get

110
00:07:12,636 --> 00:07:15,670
all for that key, and I get all my values back.

111
00:07:15,820 --> 00:07:19,306
So knowing those two specific

112
00:07:19,488 --> 00:07:23,500
data types, it's all we need for our purposes today.

113
00:07:26,190 --> 00:07:29,706
Okay, so let's talk about the redis modules API. And the

114
00:07:29,728 --> 00:07:33,290
Redis modules API allows you to extend the functionality of redis

115
00:07:33,370 --> 00:07:36,350
by adding new data type or adding new commands.

116
00:07:37,250 --> 00:07:40,926
Until recently, the Redis modules API was only available to

117
00:07:40,948 --> 00:07:44,226
c programmers. But luckily for us, in the

118
00:07:44,248 --> 00:07:48,222
last couple of years, Redis has been developing a Redis modules API

119
00:07:48,286 --> 00:07:52,590
bridge in rust. And why rust?

120
00:07:52,670 --> 00:07:56,818
Because it shares the philosophy of extreme

121
00:07:56,994 --> 00:08:00,674
carefulness in memory management and performance.

122
00:08:00,802 --> 00:08:04,802
Redis modules run in the same memory space as Redis. Therefore, any memory

123
00:08:04,866 --> 00:08:08,186
leak can compromise the health of these redis server and create a

124
00:08:08,208 --> 00:08:11,334
catastrophic condition for the server. So safe memory

125
00:08:11,382 --> 00:08:14,570
management, it's a must. In Redis modules,

126
00:08:15,470 --> 00:08:19,226
there is a rust crate that wraps our

127
00:08:19,248 --> 00:08:22,766
Redis modules API bridge, and you can find that

128
00:08:22,788 --> 00:08:26,062
on crates IO. And we're going to be using that today to build

129
00:08:26,116 --> 00:08:29,550
our demo. We're going to create

130
00:08:29,620 --> 00:08:32,858
a finite state machine as a Redis module that's

131
00:08:32,874 --> 00:08:36,050
going to be in charge of managing state in Redis hashes,

132
00:08:36,390 --> 00:08:40,258
and we're going to name it Redis FSM, and we're going to use the

133
00:08:40,264 --> 00:08:43,650
Redis modules crate that we shown previously.

134
00:08:45,590 --> 00:08:49,286
So these finite state machine, it's an entity that models and

135
00:08:49,308 --> 00:08:52,678
controls behavior for an entity. So we define a set of possible

136
00:08:52,764 --> 00:08:55,906
states, the transitions between those states and the events

137
00:08:55,938 --> 00:08:59,514
that trigger those transitions. And why

138
00:08:59,552 --> 00:09:03,062
are we targeting redis hashes? Because redis hashes are typically

139
00:09:03,126 --> 00:09:06,966
used to map objects from a programming language into redis

140
00:09:06,998 --> 00:09:10,346
if you're using redis for persistence. So our redis

141
00:09:10,378 --> 00:09:13,806
FSM module will store a generic FSM definition that we

142
00:09:13,828 --> 00:09:17,470
would initially create as JSON, and these stored as

143
00:09:17,540 --> 00:09:20,080
a specific redis data type,

144
00:09:20,930 --> 00:09:25,042
the definition will contain the set of states which

145
00:09:25,096 --> 00:09:28,990
type of hashes it applies to by their prefix,

146
00:09:29,150 --> 00:09:32,514
the name of the field that will be used to persist the

147
00:09:32,552 --> 00:09:36,630
state into the hashes and the possible transitions and events.

148
00:09:38,330 --> 00:09:41,814
So imagine this simple state machine. We're going to be using the same

149
00:09:41,852 --> 00:09:45,270
one during the demos, we have three states,

150
00:09:45,340 --> 00:09:49,174
sleeping, running and cleaning. And notice that the events in green

151
00:09:49,292 --> 00:09:52,506
allow you to transition from a state to another. So for

152
00:09:52,528 --> 00:09:56,342
example, from sleeping to running, the run event triggers that transition.

153
00:09:56,486 --> 00:09:59,974
From running back to sleeping, the sleep event triggers a transition

154
00:10:00,102 --> 00:10:03,434
from cleaning to sleeping. The sleep event also triggers a transition,

155
00:10:03,482 --> 00:10:07,258
and from running to cleaning, the clean event triggers that transition.

156
00:10:07,434 --> 00:10:11,006
So here is a bigger picture of the

157
00:10:11,028 --> 00:10:14,834
scheme that we're setting up in here. So we have a definition of a

158
00:10:14,872 --> 00:10:18,334
state machine on the top left corner,

159
00:10:18,462 --> 00:10:22,126
which we're going to represent as JSON. That JSON

160
00:10:22,158 --> 00:10:26,194
is going to be turned into a binary redis

161
00:10:26,242 --> 00:10:30,098
type that's going to be stored by the module in Redis. And we're

162
00:10:30,114 --> 00:10:32,840
going to have two commands on the left,

163
00:10:33,290 --> 00:10:37,834
FSM create to create our finite state machine data

164
00:10:37,872 --> 00:10:41,866
type in redis and a FSM info to read it

165
00:10:41,888 --> 00:10:46,218
back as JSON again. Then we're going to have

166
00:10:46,384 --> 00:10:50,410
two commands to basically do most of the interaction with

167
00:10:50,560 --> 00:10:53,774
the state machine and the hashes that the state

168
00:10:53,812 --> 00:10:57,306
machine applies to. One of them is going to be FSM allowed,

169
00:10:57,338 --> 00:11:00,842
which is going to interrogate a state machine hash completion,

170
00:11:00,906 --> 00:11:03,986
whether a specific event can

171
00:11:04,008 --> 00:11:07,454
be applied to the system and one that actually applies

172
00:11:07,502 --> 00:11:10,882
the event, which would be FSM trigger and these.

173
00:11:11,016 --> 00:11:15,478
There will also be an implied event

174
00:11:15,564 --> 00:11:19,142
transition or initial state setting that

175
00:11:19,196 --> 00:11:22,402
will be done when a new hash,

176
00:11:22,466 --> 00:11:26,498
it's saved in the system into Redis and our module

177
00:11:26,514 --> 00:11:29,978
is going to detect that the state

178
00:11:30,064 --> 00:11:33,578
field is not in there and set the initial state

179
00:11:33,664 --> 00:11:37,402
of the hash. So that way we have the beginning of

180
00:11:37,456 --> 00:11:40,822
our state machine functionality.

181
00:11:40,886 --> 00:11:44,394
So in our case of the example on screen, it would be the

182
00:11:44,432 --> 00:11:48,474
sleeping state. So if a hash is saved to the system and the sleeping

183
00:11:48,522 --> 00:11:52,126
state is not set, or the state field is not set, then we set it

184
00:11:52,148 --> 00:11:55,774
to sleeping. And here's the JSON document

185
00:11:55,822 --> 00:11:58,530
for our sample FSM definition.

186
00:11:59,990 --> 00:12:03,950
All right, so we're going to kick off our demo by creating a new library

187
00:12:04,030 --> 00:12:07,794
using the cargo new command. We're going to pass the lib

188
00:12:07,842 --> 00:12:11,954
flag. I'm going to name my library Redis

189
00:12:12,082 --> 00:12:15,746
FSM for redis finite state machine,

190
00:12:15,938 --> 00:12:20,038
and I'm going to put it in a folder called redis FSM

191
00:12:20,134 --> 00:12:23,594
all in camel case. As you can

192
00:12:23,632 --> 00:12:28,038
see, we have the output of the library being created

193
00:12:28,214 --> 00:12:33,242
and let's CD to that folder and

194
00:12:33,296 --> 00:12:36,634
use these tree command to quickly inspect what we have. So we have a cargo

195
00:12:36,682 --> 00:12:40,586
tomo file and we have a lib rs file.

196
00:12:40,778 --> 00:12:45,694
Let's quickly take a look at those. I'm going to inspect

197
00:12:45,742 --> 00:12:49,182
the cargo tumble and we just have our package declaration for redis

198
00:12:49,246 --> 00:12:52,514
FSM. And let's do the same thing

199
00:12:52,632 --> 00:12:55,778
with the library file.

200
00:12:55,874 --> 00:12:59,254
And in that one we have

201
00:12:59,372 --> 00:13:03,410
a simple function to tdd two unsigned integers.

202
00:13:03,570 --> 00:13:07,142
And we have a simple test and we're going to get rid of that.

203
00:13:07,196 --> 00:13:10,620
But that's a good skeleton to get started.

204
00:13:16,320 --> 00:13:20,216
All right, so with our newly created library loaded in the code editor,

205
00:13:20,328 --> 00:13:23,856
we're going to open the cargo tumble which I already have open in

206
00:13:23,878 --> 00:13:27,296
here, and we're going to add the

207
00:13:27,318 --> 00:13:29,920
dependencies for these redis module toolkit.

208
00:13:30,660 --> 00:13:34,032
We are also going to

209
00:13:34,086 --> 00:13:37,684
set the crate type to cdylib so we can

210
00:13:37,722 --> 00:13:41,364
create a dynamic system library to be loaded in red

211
00:13:41,402 --> 00:13:42,500
FSM module.

212
00:13:45,800 --> 00:13:49,160
First we'll tackle the FSM create command.

213
00:13:49,580 --> 00:13:53,560
I'm going to open the rust code in lib rs.

214
00:13:54,060 --> 00:13:58,090
And in there you can see that I already have the

215
00:13:58,860 --> 00:14:02,572
external create redis module being

216
00:14:02,626 --> 00:14:06,604
used. And we're going to

217
00:14:06,722 --> 00:14:11,340
import from redis module a few structs,

218
00:14:11,760 --> 00:14:14,944
enums and types that we're going to be using down

219
00:14:14,982 --> 00:14:19,244
in the code. And our first skeleton

220
00:14:19,292 --> 00:14:22,896
code is going to be a function called FsN create. And this is going

221
00:14:22,918 --> 00:14:27,312
to be the function that backs up the

222
00:14:27,446 --> 00:14:30,544
FSM create command that we will be creating.

223
00:14:30,672 --> 00:14:34,384
And as you can see, it takes a context. The context

224
00:14:34,432 --> 00:14:38,040
is going to be a redis context. It's going to be passed to

225
00:14:38,110 --> 00:14:41,988
us by the modules API.

226
00:14:42,164 --> 00:14:46,436
And then we get a vector of arguments which are packaged

227
00:14:46,468 --> 00:14:49,536
as redis strings in the Ards

228
00:14:49,668 --> 00:14:54,056
argument. And each one of our module methods

229
00:14:54,088 --> 00:14:57,310
or our module functions returns a redis result.

230
00:14:59,280 --> 00:15:03,896
So inside of this we're going to skip

231
00:15:03,928 --> 00:15:07,760
the first argument. The FST argument is going to always be the command itself.

232
00:15:07,830 --> 00:15:11,808
So we want to ignore that. And we're going

233
00:15:11,814 --> 00:15:15,584
to grab the length of the arguments in here just to do a quick check.

234
00:15:15,782 --> 00:15:19,420
So it's, if the arguments arity

235
00:15:19,500 --> 00:15:22,784
it's greater than what you're expecting, you throw

236
00:15:22,832 --> 00:15:26,212
a redis error these I'm going to

237
00:15:26,266 --> 00:15:29,936
grab the actual argument

238
00:15:29,968 --> 00:15:32,900
that's being passed and I'm going to call that source src.

239
00:15:33,060 --> 00:15:36,984
And I'm doing that by using the intro iter. And then

240
00:15:37,022 --> 00:15:40,904
I'm going to use the next string which is going to return a string

241
00:15:40,952 --> 00:15:44,492
object. Next I'm going

242
00:15:44,546 --> 00:15:48,076
to take that source and I'm going to format it

243
00:15:48,098 --> 00:15:51,740
in a string with the format macro

244
00:15:52,080 --> 00:15:55,384
and I'm going to call that greet. So this is going to be our hello

245
00:15:55,442 --> 00:15:58,876
world example. So we're going to do this in the skeleton

246
00:15:58,908 --> 00:16:02,336
of this function so we can see how things work. And then we'll get

247
00:16:02,358 --> 00:16:05,604
into the more meaty stuff. All right,

248
00:16:05,642 --> 00:16:09,332
so now I'm going to create a response, and my response is going to be

249
00:16:09,386 --> 00:16:13,540
a vector from that greet string.

250
00:16:15,000 --> 00:16:18,490
And then we're going to wrap that whole thing into an okay.

251
00:16:19,660 --> 00:16:23,732
So we're going to be using the redis underscore module

252
00:16:23,796 --> 00:16:27,768
macro, which is going to be the block of code that's going to basically

253
00:16:27,854 --> 00:16:32,440
declare the module to redis.

254
00:16:33,180 --> 00:16:36,028
So inside of that we're going to have the name of our module, which is

255
00:16:36,034 --> 00:16:39,660
going to be FSM for finite state machine,

256
00:16:40,080 --> 00:16:42,590
and these we're going to give it a version of one.

257
00:16:43,860 --> 00:16:48,480
Right now we have no data types, so we have a block for our commands.

258
00:16:49,140 --> 00:16:52,432
And inside of that we're going to add our FSm create

259
00:16:52,566 --> 00:16:56,144
command. So notice that the name in

260
00:16:56,182 --> 00:17:00,180
the string, the first element in here, FSm create,

261
00:17:00,250 --> 00:17:03,876
is going to be the actual command that you type in the redis Cli or

262
00:17:03,898 --> 00:17:07,656
that you send with a redis client, and then it's going to be

263
00:17:07,678 --> 00:17:11,208
backed by our FSM underscore create function

264
00:17:11,294 --> 00:17:15,112
above. All right, so now that we have a

265
00:17:15,166 --> 00:17:18,472
basic hello world implementation inside of our

266
00:17:18,526 --> 00:17:21,272
FSM create command,

267
00:17:21,416 --> 00:17:25,160
let's start the redis server and load

268
00:17:25,240 --> 00:17:28,332
our newly created module. So before we do that,

269
00:17:28,386 --> 00:17:32,356
we need to compile the module. So I'm going to do a cargo

270
00:17:32,408 --> 00:17:36,064
build. And now

271
00:17:36,102 --> 00:17:38,720
we have the module has been compiled.

272
00:17:39,860 --> 00:17:44,480
It will be under the target debug

273
00:17:45,160 --> 00:17:48,628
folder, and you can see there that we have

274
00:17:48,714 --> 00:17:54,160
the lib redis underscore FSm dylib

275
00:17:54,320 --> 00:17:57,704
file. So now to load that intro our

276
00:17:57,742 --> 00:18:01,284
redis server, I'm going to invoke the redis server command

277
00:18:01,332 --> 00:18:04,676
again. And this time I'm going to pass a load module

278
00:18:04,788 --> 00:18:08,568
flag in these

279
00:18:08,654 --> 00:18:11,352
lib redis fsm file.

280
00:18:11,496 --> 00:18:15,096
So target debug lib

281
00:18:15,128 --> 00:18:18,540
redis fsm dylib.

282
00:18:19,200 --> 00:18:23,200
All right, so now we have the redis server running,

283
00:18:23,350 --> 00:18:26,384
and as you can see on the output, we have

284
00:18:26,422 --> 00:18:30,076
loaded the FSm module from the Dylib

285
00:18:30,108 --> 00:18:33,570
file. All right, so now with that in place,

286
00:18:34,100 --> 00:18:36,320
let's launch the redis Cli.

287
00:18:37,700 --> 00:18:40,916
And in the Redis Cli, one of the things we can do to verify to

288
00:18:40,938 --> 00:18:44,736
you that the module has been loaded is to do a module

289
00:18:44,848 --> 00:18:48,072
list. And you can see that we have

290
00:18:48,206 --> 00:18:51,480
only one module loaded in this instance of redis,

291
00:18:52,540 --> 00:18:56,100
mainly the FSM module that we just created.

292
00:18:56,260 --> 00:19:00,568
Right, and the redis cli kind of autocompletes commands.

293
00:19:00,664 --> 00:19:02,700
So if we do FSM,

294
00:19:03,840 --> 00:19:07,644
the only command loaded right now is FSm create and

295
00:19:07,682 --> 00:19:10,190
we can pass a string to it.

296
00:19:12,240 --> 00:19:16,050
And as you can see, we get the hello back.

297
00:19:16,500 --> 00:19:19,776
Notice that the emoji that we

298
00:19:19,798 --> 00:19:23,244
had in the code, it's actually encoded in the string.

299
00:19:23,292 --> 00:19:26,400
So I kind of wanted to show you that Redis

300
00:19:26,480 --> 00:19:30,416
basically stores everything in raw

301
00:19:30,448 --> 00:19:34,416
format. So now we see that we have a working command.

302
00:19:34,528 --> 00:19:38,376
Very simple command, doesn't do anything. Now let's go back

303
00:19:38,478 --> 00:19:40,170
and flesh it out.

304
00:19:43,460 --> 00:19:46,944
So the first thing I'm going to do is bring in

305
00:19:47,062 --> 00:19:50,920
the inserted JSON dependencies because we're

306
00:19:50,940 --> 00:19:54,612
going to be using JSon. And now back

307
00:19:54,666 --> 00:19:58,372
to the code. The first thing we're going to do is add

308
00:19:58,426 --> 00:20:00,660
a state machine struct.

309
00:20:01,720 --> 00:20:05,764
And as you can see here, I have a state machine

310
00:20:05,892 --> 00:20:08,680
that has a name, a prefix,

311
00:20:09,260 --> 00:20:12,184
a field, and a set of states.

312
00:20:12,382 --> 00:20:16,664
To transition from state to state, we need to have the definition

313
00:20:16,712 --> 00:20:21,096
of an event. So I'm going to create a struct that basically represents

314
00:20:21,128 --> 00:20:24,764
an event. And the events will have a name and it

315
00:20:24,802 --> 00:20:28,588
would have a state that they

316
00:20:28,674 --> 00:20:32,576
can transition to and also a collection of

317
00:20:32,598 --> 00:20:36,672
state that they can transition from. So we have an event in the

318
00:20:36,726 --> 00:20:40,336
state machine. We're going to add a vector of

319
00:20:40,358 --> 00:20:41,200
events.

320
00:20:44,040 --> 00:20:48,260
Now that we have our data structures for the state machine,

321
00:20:48,600 --> 00:20:53,012
the next thing we're going to do is

322
00:20:53,066 --> 00:20:56,664
add a few definitions that we're going to use to

323
00:20:56,702 --> 00:21:00,264
basically manage the registration of our

324
00:21:00,302 --> 00:21:04,056
state machine data type. Okay, so let

325
00:21:04,078 --> 00:21:07,840
me show you what we have in here. The first one, it's this redis

326
00:21:08,020 --> 00:21:11,276
FSM type name. That's going to be the name of the type in

327
00:21:11,298 --> 00:21:16,540
redis. And that has to be 123-45-6789

328
00:21:16,610 --> 00:21:20,656
characters. Specifically, it's one of the requirements of a

329
00:21:20,678 --> 00:21:23,820
redis data type that has to be exactly nine characters.

330
00:21:23,900 --> 00:21:27,388
So we're calling ours Redis FSM

331
00:21:27,564 --> 00:21:31,204
the version of our data type. It's version number

332
00:21:31,242 --> 00:21:35,172
one. You can basically have multiple versions. And then

333
00:21:35,226 --> 00:21:39,520
in your code you would basically have to manage backwards compatibility

334
00:21:39,680 --> 00:21:42,580
with older versions of your data types.

335
00:21:43,500 --> 00:21:47,304
If you choose to do so, then the

336
00:21:47,342 --> 00:21:51,252
actual type will be created under these redis

337
00:21:51,316 --> 00:21:55,096
FSM type. And then this is a redis type. You notice here

338
00:21:55,118 --> 00:21:59,164
we're invoking the new function and it

339
00:21:59,202 --> 00:22:02,796
takes the type name and the version and then

340
00:22:02,898 --> 00:22:06,252
a set of methods that

341
00:22:06,306 --> 00:22:10,384
basically initialize or

342
00:22:10,422 --> 00:22:14,044
manage how these data type lifecycle it's

343
00:22:14,092 --> 00:22:17,916
handled by Redis. So now we're

344
00:22:17,948 --> 00:22:22,664
going to make some modifications to our FSM

345
00:22:22,732 --> 00:22:26,164
create. And the first thing that

346
00:22:26,202 --> 00:22:30,070
I'm doing in here is that I've added this line right here

347
00:22:30,600 --> 00:22:34,344
that creates a variable called Redis key,

348
00:22:34,462 --> 00:22:38,504
which it's actually grabbing the context. Notice that I brought these

349
00:22:38,542 --> 00:22:41,268
context variable back into scope,

350
00:22:41,444 --> 00:22:45,128
and that context provides an open

351
00:22:45,214 --> 00:22:49,368
keywritable method. And that method

352
00:22:49,464 --> 00:22:53,100
basically takes a key definition, a redis key,

353
00:22:53,250 --> 00:22:56,812
and it's going to basically give us a slot in

354
00:22:56,866 --> 00:23:00,256
Redis to write something to it. So these, once we

355
00:23:00,278 --> 00:23:03,888
have that, we're going to create

356
00:23:03,974 --> 00:23:08,016
some JSON representation, a certain representation of

357
00:23:08,118 --> 00:23:11,744
our state machine. So notice that we have a JSON document here that

358
00:23:11,782 --> 00:23:15,396
has the main prefix field, the state for

359
00:23:15,418 --> 00:23:19,332
our state machine and definition of events. In this case,

360
00:23:19,386 --> 00:23:22,630
we have that simple state machine that we shown in the slides before,

361
00:23:23,500 --> 00:23:27,224
which has three states sleeping, running and cleaning. And it

362
00:23:27,262 --> 00:23:29,524
has three events,

363
00:23:29,652 --> 00:23:32,404
run, clean and sleep.

364
00:23:32,532 --> 00:23:36,248
And remember, run can transition from sleeping

365
00:23:36,264 --> 00:23:40,620
to running, clean from running to cleaning,

366
00:23:40,960 --> 00:23:45,100
and sleep from either running or cleaning to sleeping.

367
00:23:45,600 --> 00:23:49,772
And notice that I'm using the JSON macro from Certe

368
00:23:49,836 --> 00:23:52,610
to basically create a JSON object.

369
00:23:55,220 --> 00:23:57,890
And then once we have our JSON object,

370
00:23:58,580 --> 00:24:02,052
we're going to serialize, we're going to create

371
00:24:02,106 --> 00:24:05,668
a state machine from that JSON object. So notice in

372
00:24:05,674 --> 00:24:09,956
here I'm using the asserted from the string of

373
00:24:09,978 --> 00:24:13,636
the JSON that we created, and that is going to give

374
00:24:13,658 --> 00:24:16,520
me an instance of our state machine strut.

375
00:24:20,410 --> 00:24:23,558
So next, once we have a state machine object, we're going

376
00:24:23,564 --> 00:24:27,160
to use that redis key to write that value to the redis key,

377
00:24:28,670 --> 00:24:32,166
passing the specific type that we're writing, which is our redis

378
00:24:32,278 --> 00:24:37,260
FSM type, which we declared up here in

379
00:24:37,870 --> 00:24:39,850
that redis type block.

380
00:24:44,760 --> 00:24:47,720
Okay, so we wrote the key to Redis,

381
00:24:48,060 --> 00:24:51,850
and now we're going to get rid of that hello world part of the example,

382
00:24:52,220 --> 00:24:55,444
and we're going to return a boolean

383
00:24:55,492 --> 00:24:59,240
as an integer. True, if we were successful

384
00:24:59,320 --> 00:25:03,260
at writing that redis value to redis,

385
00:25:03,760 --> 00:25:07,304
that key value, the actual serialization of our state machine,

386
00:25:07,432 --> 00:25:10,992
and false otherwise. So that gives us now

387
00:25:11,046 --> 00:25:14,480
the ability to write our custom

388
00:25:14,550 --> 00:25:16,560
data type to redis.

389
00:25:21,720 --> 00:25:24,996
We also need to add the redis type to

390
00:25:25,018 --> 00:25:26,340
the module declaration.

391
00:25:27,880 --> 00:25:32,720
So noticing here that under the data types vector,

392
00:25:32,880 --> 00:25:35,510
I added the redis FSM type.

393
00:25:38,040 --> 00:25:42,116
And now that the FSM create

394
00:25:42,218 --> 00:25:46,410
its write into redis, we actually mark it with the

395
00:25:46,800 --> 00:25:49,900
modifier write, telling us that

396
00:25:50,050 --> 00:25:54,876
this commands writes to the database. And the

397
00:25:54,898 --> 00:25:58,664
three ones at the end in here represent the

398
00:25:58,802 --> 00:26:01,808
index of the first key, the key step,

399
00:26:01,894 --> 00:26:05,792
and the index of the last key. So since we only have one

400
00:26:05,846 --> 00:26:09,744
parameter, the main key, one key, actually we

401
00:26:09,782 --> 00:26:12,390
have one across the board.

402
00:26:14,280 --> 00:26:17,220
Now we will build the FSM info command.

403
00:26:20,120 --> 00:26:23,972
Okay, so now that we have a method that can write our custom data

404
00:26:24,026 --> 00:26:27,832
type to redis, we should probably add a method to read it back.

405
00:26:27,966 --> 00:26:31,156
So for that we're going to implement the FSM intro

406
00:26:31,188 --> 00:26:34,584
method, and the first thing I'm going to do is just

407
00:26:34,622 --> 00:26:38,152
add a skeleton for it. Just like the FSM

408
00:26:38,216 --> 00:26:42,232
create method, our FSM intro again takes a context

409
00:26:42,376 --> 00:26:46,044
instead of redis arguments, these redis strings and

410
00:26:46,082 --> 00:26:49,760
returns a result. We're starting with just a result,

411
00:26:49,910 --> 00:26:53,516
okay, with a null value, and now we're

412
00:26:53,548 --> 00:26:57,360
going to grab the arguments like we did before, and we're grabbing

413
00:26:57,940 --> 00:27:01,636
what's supposed to be the key as the

414
00:27:01,658 --> 00:27:03,910
first argument after the method name.

415
00:27:05,400 --> 00:27:08,436
And these we're going to again create

416
00:27:08,538 --> 00:27:12,470
a key. But this time we're going to open our key

417
00:27:12,840 --> 00:27:16,888
similar to what we did in the FSM create.

418
00:27:16,974 --> 00:27:20,472
So notice in here first I did a context open

419
00:27:20,526 --> 00:27:24,724
key writable, and in the FSM intro,

420
00:27:24,772 --> 00:27:28,216
since I'm only reading, I just did a context open key passing

421
00:27:28,248 --> 00:27:29,310
that key value.

422
00:27:32,800 --> 00:27:36,364
Then I'm going to bring in the guard crate so I

423
00:27:36,402 --> 00:27:41,550
can avoid having to have nested let

424
00:27:42,320 --> 00:27:45,664
in my code. So this is going to allow me to write a little bit

425
00:27:45,702 --> 00:27:49,056
cleaner code in my opinion. So with that

426
00:27:49,078 --> 00:27:52,404
in place, I'm going to create this guard where I'm basically

427
00:27:52,602 --> 00:27:56,512
trying to bring the state machine back from the JSON that's stored

428
00:27:56,576 --> 00:28:00,452
in the database in redis. So noticing here that

429
00:28:00,506 --> 00:28:03,892
I'm doing a guard and then a let.

430
00:28:04,026 --> 00:28:07,336
Okay, so there's going to be the redis response. So I want it to be

431
00:28:07,358 --> 00:28:10,952
a successful response that contains some

432
00:28:11,086 --> 00:28:14,808
object of type call FSM that I'm

433
00:28:14,814 --> 00:28:18,288
going to name FSM. And I get that from reading

434
00:28:18,324 --> 00:28:22,044
the value, casting it to a state machine using my

435
00:28:22,082 --> 00:28:26,184
redis FSM type that we declared previously. And if that fails,

436
00:28:26,232 --> 00:28:29,696
then I'm just going to return an error with a redis error that

437
00:28:29,718 --> 00:28:33,504
contains an error message. These very likely it's these

438
00:28:33,542 --> 00:28:37,184
errors that I couldn't find the key. Now with that

439
00:28:37,222 --> 00:28:40,956
in place, I'm going to use survey

440
00:28:40,988 --> 00:28:44,820
again to basically put the JSON back into

441
00:28:44,890 --> 00:28:48,644
string form and return that JSON wrapped in

442
00:28:48,682 --> 00:28:52,436
a redis value simple string with an

443
00:28:52,458 --> 00:28:56,250
okay around it. So with that in place,

444
00:29:00,130 --> 00:29:04,270
we need to add the command to our declaration like we did before

445
00:29:04,420 --> 00:29:08,094
with the FSm create. So in here I'm going to now add

446
00:29:08,132 --> 00:29:11,722
the FSm info. And again we have the FSm intro

447
00:29:11,786 --> 00:29:15,278
command being backed by

448
00:29:15,364 --> 00:29:18,738
the FSm info function. This one is a read only the

449
00:29:18,744 --> 00:29:21,918
other one was a write. And again, since we only have one key and it's

450
00:29:21,934 --> 00:29:25,446
the first key, we have ones across the board here in the

451
00:29:25,468 --> 00:29:28,840
definition. And now we can go and test this.

452
00:29:30,650 --> 00:29:34,410
Okay, so now that we have our two commands, the FSM create to write

453
00:29:34,480 --> 00:29:38,326
the JSON definition of the state machine to redis

454
00:29:38,438 --> 00:29:41,322
and these FSm info to read it back.

455
00:29:41,456 --> 00:29:44,502
Let's compile our library

456
00:29:44,566 --> 00:29:48,846
again our module, and let's launch the

457
00:29:48,868 --> 00:29:52,766
redis server again, loading our module. All right,

458
00:29:52,868 --> 00:29:59,282
and now again, let's go back to the redis Cli and

459
00:29:59,336 --> 00:30:03,250
let's see what keys we have in the system. Should be empty again.

460
00:30:03,400 --> 00:30:06,580
All right, so now we can do an FSM create.

461
00:30:08,150 --> 00:30:11,478
And in here I'm going to

462
00:30:11,644 --> 00:30:15,318
pass the key is going

463
00:30:15,324 --> 00:30:18,514
to be job FSM, which is kind of what we hard coded

464
00:30:18,562 --> 00:30:22,134
in the JSOn for now. So if I

465
00:30:22,172 --> 00:30:25,930
do that, notice that we get a one back. So that means that something

466
00:30:26,000 --> 00:30:28,570
went right.

467
00:30:28,720 --> 00:30:32,006
And now I'm going to list the keys

468
00:30:32,038 --> 00:30:35,642
again and notice that we have now one key,

469
00:30:35,696 --> 00:30:39,440
job FSM. And if I check the type of that key,

470
00:30:42,910 --> 00:30:47,254
we get our custom redis data type redis fsm.

471
00:30:47,382 --> 00:30:51,562
So now let's see if our redis command

472
00:30:51,626 --> 00:30:55,566
FSm info works correctly so I

473
00:30:55,588 --> 00:30:59,854
can pass the key that we just created and we

474
00:30:59,892 --> 00:31:01,920
get our XMl back.

475
00:31:02,450 --> 00:31:06,318
And the redis cli doesn't preprint the XML.

476
00:31:06,494 --> 00:31:09,806
So you could use Redis insight,

477
00:31:09,838 --> 00:31:14,290
for example, if you wanted to basically see a nicely colorized version

478
00:31:14,650 --> 00:31:18,760
of the JSON definition. So now

479
00:31:21,050 --> 00:31:24,658
we have a data type that implements our finite state machine

480
00:31:24,754 --> 00:31:28,700
and we have a command to create it and one to read it back.

481
00:31:31,470 --> 00:31:34,986
Okay, so now we have two commands, one that writes some

482
00:31:35,088 --> 00:31:38,970
JSON definition of an object and

483
00:31:39,040 --> 00:31:42,138
one that reads the definition in our lingua

484
00:31:42,154 --> 00:31:46,414
franca to store them. It's Json. So now what

485
00:31:46,452 --> 00:31:49,710
I'm going to do is now refactor that FSM create

486
00:31:49,860 --> 00:31:53,418
so we don't hard code the JSON because we really want to have the flexibility

487
00:31:53,514 --> 00:31:56,874
to have multiple state machine

488
00:31:56,922 --> 00:32:01,218
definitions there. So the first thing I'm going to do is

489
00:32:01,384 --> 00:32:04,478
rather than just reading a key, we're going to

490
00:32:04,504 --> 00:32:08,274
take the JSON. So I rename the first argument being read to FSM,

491
00:32:08,322 --> 00:32:13,030
underscore JSON. And then

492
00:32:13,100 --> 00:32:17,174
I added this block in here where I'm taking that

493
00:32:17,212 --> 00:32:20,742
JSoN, that raw JSon that is being passed from the command.

494
00:32:20,886 --> 00:32:24,714
And we're going to use these third JSON library to

495
00:32:24,752 --> 00:32:28,874
read it from a string, the two string of that FSN JSon which

496
00:32:28,912 --> 00:32:32,638
is a Redis string, and that's going to give us our state machine object

497
00:32:32,724 --> 00:32:36,622
back, rehydrated. And once

498
00:32:36,676 --> 00:32:40,490
again, now these key to write this to Redis

499
00:32:40,570 --> 00:32:43,906
is going to be the name property in the JSON. So what I'm doing in

500
00:32:43,928 --> 00:32:47,294
here is I'm taking the FSM instance

501
00:32:47,342 --> 00:32:51,314
that we just created from the JSON and grabbing the name to

502
00:32:51,352 --> 00:32:54,580
basically create our Redis key.

503
00:32:55,290 --> 00:32:59,574
Okay, so now we can test our refactor version of

504
00:32:59,612 --> 00:33:03,334
the FSM create method. So once again, I'm going

505
00:33:03,372 --> 00:33:07,174
to compile our library and I'm going

506
00:33:07,212 --> 00:33:11,900
to launch the Reddit server and

507
00:33:12,990 --> 00:33:16,730
also run the CLI.

508
00:33:17,790 --> 00:33:21,386
And now our FSM create method.

509
00:33:21,418 --> 00:33:26,058
Obviously it's a much more beefy method

510
00:33:26,154 --> 00:33:30,318
because now it takes the JSON payload and obviously

511
00:33:30,404 --> 00:33:34,126
I have it ready here to copy and paste. Notice that the JSON

512
00:33:34,158 --> 00:33:38,382
has to be scaped properly. So all the internal quotes

513
00:33:38,526 --> 00:33:41,250
have to be scaped with the backslash.

514
00:33:41,830 --> 00:33:45,394
And when you have large payloads to

515
00:33:45,432 --> 00:33:48,966
load in the CLI, rather than pasting them into the Cli, you can

516
00:33:48,988 --> 00:33:52,566
actually pull these from an external file. But since this is a quick

517
00:33:52,588 --> 00:33:56,006
and dirty example, I'm just pasting it on the Cli. And if

518
00:33:56,028 --> 00:34:00,054
you have it in a file, you don't have to do all this escaping maneuvering

519
00:34:00,102 --> 00:34:03,514
over here. So I'm going to run my FSM create now with

520
00:34:03,552 --> 00:34:07,062
the JSon being passed from the CLi.

521
00:34:07,206 --> 00:34:10,814
And again we can check once again

522
00:34:10,852 --> 00:34:14,846
that we have our key being created and that

523
00:34:14,868 --> 00:34:18,538
we can read it. So now we have a full run trip

524
00:34:18,634 --> 00:34:21,950
with a custom definition of our state machine.

525
00:34:24,550 --> 00:34:28,514
Okay, so now we're going to implement the actual functionality of our state

526
00:34:28,552 --> 00:34:32,450
machine. And one of the first things that we want to do is

527
00:34:32,600 --> 00:34:36,614
when a new hash matching the

528
00:34:36,652 --> 00:34:40,018
given prefix, it's added to Redis,

529
00:34:40,114 --> 00:34:44,760
we want to intercept that and set the initial state field

530
00:34:45,130 --> 00:34:48,534
given a state machine that matches the prefix of the hash.

531
00:34:48,662 --> 00:34:52,060
So to do that, first I'm going to add

532
00:34:52,510 --> 00:34:57,066
a function called on event. And this on event function

533
00:34:57,248 --> 00:35:01,274
takes a context again, but this time it takes

534
00:35:01,312 --> 00:35:05,422
an event type, which is a notify event and

535
00:35:05,476 --> 00:35:08,734
the actual event as a string and the key as

536
00:35:08,772 --> 00:35:12,402
a string and inside of it. For now we're just going to have

537
00:35:12,456 --> 00:35:15,922
a message that basically prints what the event was

538
00:35:16,056 --> 00:35:19,714
in the key and

539
00:35:19,912 --> 00:35:23,442
the event. So the event type, the key and the actual

540
00:35:23,496 --> 00:35:26,838
event, and we're going to log that to the context with the

541
00:35:26,844 --> 00:35:30,182
log notice login message. So once

542
00:35:30,236 --> 00:35:33,814
we have that in place, we have to register that event. So down in our

543
00:35:33,852 --> 00:35:37,850
redis module registration block,

544
00:35:38,590 --> 00:35:42,566
we add an event handlers vector

545
00:35:42,758 --> 00:35:46,522
that has inside an event

546
00:35:46,576 --> 00:35:49,914
handler of type hash. And we're pointing

547
00:35:49,962 --> 00:35:53,834
that to our on event function. So when a hash

548
00:35:53,962 --> 00:35:57,662
event is detected, we're going to get notified and

549
00:35:57,716 --> 00:36:01,750
our on event function is going to be invoked.

550
00:36:01,930 --> 00:36:05,922
Right. So with that in place, we can now

551
00:36:05,976 --> 00:36:08,530
test the event functionality.

552
00:36:12,710 --> 00:36:16,402
All right, so now let's compile our library

553
00:36:16,466 --> 00:36:20,054
again and

554
00:36:20,172 --> 00:36:21,880
let's launch it.

555
00:36:24,090 --> 00:36:26,750
And let's launch the CLI.

556
00:36:26,930 --> 00:36:30,826
Let's arrow so we can get to that FSM create. So we'll create

557
00:36:30,928 --> 00:36:34,410
our job

558
00:36:34,480 --> 00:36:38,010
FSM finite state machine.

559
00:36:38,590 --> 00:36:41,774
Let's make sure that the key is there again.

560
00:36:41,892 --> 00:36:44,640
Let's make sure that we can read it back.

561
00:36:45,170 --> 00:36:48,638
So it's job FSM. All right,

562
00:36:48,724 --> 00:36:53,058
so now what we're going to do is let's do an HM set.

563
00:36:53,224 --> 00:36:56,626
So we're going to create a key. Sorry. We're going to create a

564
00:36:56,648 --> 00:37:00,674
hash and we're going to use the prefix that

565
00:37:00,712 --> 00:37:06,854
we're listening for in our state

566
00:37:06,892 --> 00:37:10,102
machine. It doesn't really matter right now, but it will

567
00:37:10,156 --> 00:37:13,670
once we actually look for that prefix. But for now,

568
00:37:13,740 --> 00:37:18,170
any hash event should be detected by our event

569
00:37:18,240 --> 00:37:22,540
handler. So in here, I'm going to create this hash called job

570
00:37:22,910 --> 00:37:26,154
one. And let's give it a feel here,

571
00:37:26,192 --> 00:37:30,086
maybe employee. And this is going to be Brian.

572
00:37:30,198 --> 00:37:33,614
Okay, so now pay attention to the

573
00:37:33,652 --> 00:37:37,166
redis server tab. So I'm going to press return in

574
00:37:37,188 --> 00:37:40,762
here and notice that this is spinning because now we just receive

575
00:37:40,826 --> 00:37:45,246
our event. So in here we have received event hash

576
00:37:45,358 --> 00:37:48,914
on key job one via the event H

577
00:37:48,952 --> 00:37:52,210
set. So our event was an h set event.

578
00:37:52,360 --> 00:37:55,962
So that was the command that basically was triggered by the hmset.

579
00:37:56,046 --> 00:37:59,970
So each one of the writes to the hash.

580
00:38:00,050 --> 00:38:03,510
It's an H set event. And in here

581
00:38:03,580 --> 00:38:07,494
I get these key of the

582
00:38:07,532 --> 00:38:11,446
hash that was created and these event type was a hash.

583
00:38:11,638 --> 00:38:12,540
All right,

584
00:38:15,230 --> 00:38:19,046
so now we got a big refactor in our hands. We need to implement

585
00:38:19,158 --> 00:38:23,166
the on event function. So when a

586
00:38:23,188 --> 00:38:26,654
hash event arrives for a hash that has

587
00:38:26,692 --> 00:38:30,714
a key with a prefix matching any of the prefixes

588
00:38:30,762 --> 00:38:34,158
defined on any of the FSMs that we have stored

589
00:38:34,174 --> 00:38:37,634
in the system, we want to then check

590
00:38:37,672 --> 00:38:41,294
that hash. And if these state field it's

591
00:38:41,342 --> 00:38:44,882
empty on that hash, we're going to grab the initial state from the state

592
00:38:44,936 --> 00:38:48,966
machine that matches that prefix for that hash and we're going to set it

593
00:38:49,068 --> 00:38:52,950
up on the hash. So to do that, first we're going to start

594
00:38:53,100 --> 00:38:56,818
by grabbing the prefix for the

595
00:38:56,924 --> 00:39:00,906
hash for which we have received an event.

596
00:39:01,088 --> 00:39:05,034
So I'm going to split the keys by

597
00:39:05,072 --> 00:39:08,762
the column and then I'm going to grab the prefix as the

598
00:39:08,816 --> 00:39:12,910
first segment of that list of key parts,

599
00:39:13,570 --> 00:39:17,326
and I'm going to reappend the column in

600
00:39:17,348 --> 00:39:21,360
there to build my key prefix. So then

601
00:39:22,950 --> 00:39:27,140
if we go back to the FSM create,

602
00:39:31,110 --> 00:39:35,160
we need to basically have a way for,

603
00:39:36,730 --> 00:39:40,534
given a hash prefix, be able to find

604
00:39:40,732 --> 00:39:44,162
the FSM that matches that prefix.

605
00:39:44,306 --> 00:39:47,626
So there's many ways we can actually store that data. So we basically need

606
00:39:47,648 --> 00:39:52,102
a dictionary or a hash or a map between prefixes

607
00:39:52,246 --> 00:39:55,866
and finite state machines. And the

608
00:39:55,888 --> 00:39:59,546
way that I decided to implement it in this demo is to

609
00:39:59,568 --> 00:40:03,182
actually use Redis itself. So I'm going to use a Redis hash to store

610
00:40:03,236 --> 00:40:06,394
a mapping of prefixes to the keys

611
00:40:06,442 --> 00:40:10,698
of our fsms. So we're

612
00:40:10,714 --> 00:40:14,090
going to start here by refactoring this. So we were returning

613
00:40:14,250 --> 00:40:18,094
just a result of setting the value of the FSM

614
00:40:18,142 --> 00:40:21,218
when we wrote it to the database. Now we're just going to put that in

615
00:40:21,224 --> 00:40:25,046
an individual line with one of these guards. And in here's where I'm basically

616
00:40:25,228 --> 00:40:29,366
writing my state machine, my serialized state machine to the system.

617
00:40:29,548 --> 00:40:32,760
And then in between that and the return,

618
00:40:34,890 --> 00:40:39,066
first I'm going to create a constant that basically

619
00:40:39,168 --> 00:40:42,438
tells me the name of the hash where I'm going to keep my mappings,

620
00:40:42,534 --> 00:40:46,060
my mappings between, again, prefixes to

621
00:40:46,430 --> 00:40:50,320
FSM keys. So now I have that

622
00:40:51,170 --> 00:40:54,862
hash name that we're going to use. And down below here,

623
00:40:54,916 --> 00:40:58,926
notice that I'm using the

624
00:40:59,028 --> 00:41:02,462
context to call h set. So this

625
00:41:02,516 --> 00:41:06,722
h set, it's just a command, a redis command. And the

626
00:41:06,776 --> 00:41:10,350
redis context gives us access to those commands.

627
00:41:10,430 --> 00:41:13,726
So I'm going to call the h set command,

628
00:41:13,838 --> 00:41:17,474
and I'm going to write to this redis fsm hash key that we created

629
00:41:17,522 --> 00:41:22,086
here. And I'm going to write the prefix that

630
00:41:22,108 --> 00:41:25,862
is defined in the findingstate machine JSon. And I'm going to

631
00:41:25,916 --> 00:41:29,574
write also the key of my finite state machine

632
00:41:29,702 --> 00:41:33,100
as the value in there. So now with that in place,

633
00:41:35,870 --> 00:41:39,786
I can now make some modifications. So now we

634
00:41:39,808 --> 00:41:43,294
have a set that has those values. So let's go back to our

635
00:41:43,332 --> 00:41:47,406
on event and in here. Notice that now I can

636
00:41:47,588 --> 00:41:51,706
find the correct finite state machine for the key prefix.

637
00:41:51,738 --> 00:41:55,378
So what I'm doing in here is again, I'm using a guard again,

638
00:41:55,544 --> 00:41:58,942
and I'm looking for my fsm

639
00:41:59,006 --> 00:42:02,642
key by calling h get. So we did an h set

640
00:42:02,696 --> 00:42:06,110
to save the mapping upon creation of the state machine.

641
00:42:06,190 --> 00:42:09,490
And now when we get an event for a hash, we're going to use Hkit

642
00:42:09,570 --> 00:42:13,458
to look into that map to see if our event prefix,

643
00:42:13,554 --> 00:42:17,386
our hash prefix, matches any of the prefixes of

644
00:42:17,408 --> 00:42:21,414
our state machines. I'm also assuming that the prefixes

645
00:42:21,462 --> 00:42:25,114
are unique per state machine. So now with that

646
00:42:25,152 --> 00:42:25,900
in place,

647
00:42:29,330 --> 00:42:33,486
I can now create a key name,

648
00:42:33,668 --> 00:42:37,374
which is going to be, I'm using the context and my

649
00:42:37,412 --> 00:42:40,782
findingstate machine key and I am

650
00:42:40,836 --> 00:42:44,302
basically opening that key. So I'm reading the FSm

651
00:42:44,366 --> 00:42:49,490
back and then from the FSM here,

652
00:42:49,560 --> 00:42:53,234
which is basically my instance of definite state machine, which is going to be the

653
00:42:53,272 --> 00:42:57,026
struct that we defined before. So it's

654
00:42:57,058 --> 00:43:01,494
going to be one of these. So that

655
00:43:01,612 --> 00:43:04,886
state machine object, now it's loaded here at

656
00:43:04,908 --> 00:43:08,714
the end of the current implementation of our own event.

657
00:43:08,912 --> 00:43:11,660
So once I have the state machine object,

658
00:43:14,430 --> 00:43:17,734
I can grab the initial state, but I'm only going to grab the initial

659
00:43:17,782 --> 00:43:21,534
state if a call to try to

660
00:43:21,572 --> 00:43:25,246
retrieve the FSm field from the

661
00:43:25,268 --> 00:43:28,538
hash comes back no. So that means if the hash

662
00:43:28,634 --> 00:43:31,882
doesn't have the state field set, I'm going to

663
00:43:31,956 --> 00:43:36,322
initialize it to the initial value that is on

664
00:43:36,456 --> 00:43:39,954
the state machine. So notice in

665
00:43:39,992 --> 00:43:44,786
here one

666
00:43:44,808 --> 00:43:46,982
of the things I need to do is I need to have a way to

667
00:43:47,036 --> 00:43:50,294
retrieve that initial state. So how do I retrieve that initial state?

668
00:43:50,332 --> 00:43:54,566
That's going to be, if you remember our JSon object or

669
00:43:54,588 --> 00:43:58,614
the definition. So let's go back here to our

670
00:43:58,652 --> 00:44:02,550
state machine. This set of states, the first implements

671
00:44:02,630 --> 00:44:05,210
of this vector is going to be our initial state.

672
00:44:05,360 --> 00:44:08,918
So now let's add some logic to our state machine.

673
00:44:09,014 --> 00:44:12,494
So I'm going to add an input block for our state machine in these,

674
00:44:12,692 --> 00:44:16,062
and we're going to create an initial state

675
00:44:16,116 --> 00:44:19,434
field. So our initial state, this being a method,

676
00:44:19,482 --> 00:44:22,978
takes a pointer to self and these we're going

677
00:44:22,984 --> 00:44:26,434
to return an optional string. So that means if there

678
00:44:26,472 --> 00:44:30,418
are any states in here, we're going to return the first one

679
00:44:30,584 --> 00:44:34,180
or none. And with that in place,

680
00:44:36,570 --> 00:44:40,454
we can now go back to our on event

681
00:44:40,572 --> 00:44:44,150
implementation. So back here

682
00:44:44,220 --> 00:44:48,106
on the on event implementation. Now we can call that new method that we

683
00:44:48,128 --> 00:44:51,846
created on the state machine strut.

684
00:44:51,958 --> 00:44:54,922
So we're going to basically use a guard again,

685
00:44:55,056 --> 00:44:58,970
and I'm going to attempt to grab the initial state by calling

686
00:44:59,040 --> 00:45:03,534
the initial state on the FSM object that we retrieved up

687
00:45:03,572 --> 00:45:06,734
here. So once I have that, now I can call

688
00:45:06,772 --> 00:45:10,526
an h set. So I did an h get to find the

689
00:45:10,548 --> 00:45:14,030
correct mapping

690
00:45:14,190 --> 00:45:17,746
of prefix to state machine. Then I instantiated that

691
00:45:17,768 --> 00:45:21,218
state machine. If these field also

692
00:45:21,304 --> 00:45:25,426
was empty, I use another h, get to check if the state was set on

693
00:45:25,448 --> 00:45:29,174
the hash and if it wasn't set, now I can grab the initial state

694
00:45:29,212 --> 00:45:32,534
from the state machine and do another h set on the

695
00:45:32,572 --> 00:45:36,054
hash on the incoming hash on the

696
00:45:36,092 --> 00:45:39,654
field that was defined on the state machine as being these initial

697
00:45:39,702 --> 00:45:43,494
state and grabbing the initial state value from the state machine.

698
00:45:43,622 --> 00:45:48,646
So now with that in place, we should have a fully

699
00:45:48,678 --> 00:45:52,142
functioning step of the state machine that

700
00:45:52,196 --> 00:45:55,790
sets up the initial state on any matching hash.

701
00:45:59,570 --> 00:46:03,620
Okay, so let's build the application again

702
00:46:04,310 --> 00:46:07,666
and let's launch it so we

703
00:46:07,688 --> 00:46:11,940
can test our event handling code.

704
00:46:14,630 --> 00:46:16,470
So back on the CLI,

705
00:46:17,450 --> 00:46:22,118
let's reload our final

706
00:46:22,204 --> 00:46:26,710
state machine, finite state machine JSON,

707
00:46:28,030 --> 00:46:31,750
and let's do all these usual

708
00:46:31,830 --> 00:46:36,970
checking. So let's actually inspect the

709
00:46:37,040 --> 00:46:41,642
hash of mappings. So we'll do an h getall for

710
00:46:41,776 --> 00:46:47,390
redis FSm hash.

711
00:46:48,930 --> 00:46:53,380
And you can see that we have the job prefix that we

712
00:46:54,230 --> 00:46:57,406
set on our JSON specification,

713
00:46:57,598 --> 00:47:01,106
and it maps to the key for

714
00:47:01,208 --> 00:47:04,994
the FSM that we have in the system.

715
00:47:05,192 --> 00:47:09,666
So now let's do

716
00:47:09,768 --> 00:47:14,230
an hm set for

717
00:47:14,300 --> 00:47:17,354
a key matching our prefix. So again

718
00:47:17,392 --> 00:47:20,922
let's do job one and

719
00:47:21,056 --> 00:47:25,450
we're going to say again, employee Brian.

720
00:47:26,750 --> 00:47:29,994
And as you can see, the redis

721
00:47:30,032 --> 00:47:34,106
server detected the event. Notice that we have two events,

722
00:47:34,138 --> 00:47:38,190
one on the redis hash, but that one doesn't match our prefix,

723
00:47:38,530 --> 00:47:41,962
these redis hash that keeps the mapping of prefixes to

724
00:47:42,036 --> 00:47:46,018
fsms. And then for the actual data one, the job

725
00:47:46,184 --> 00:47:49,794
one. So now let's inspect the

726
00:47:49,832 --> 00:47:54,590
values. So we'll do an h get all for

727
00:47:54,680 --> 00:47:57,960
our job one.

728
00:47:58,330 --> 00:48:01,426
And as you can see now we have the initial

729
00:48:01,458 --> 00:48:04,882
fields that we set. Employee Brian, employee Brian.

730
00:48:04,946 --> 00:48:08,422
But we also have the state set to sleeping.

731
00:48:08,566 --> 00:48:12,454
And if you remember in our FSM

732
00:48:12,502 --> 00:48:16,426
definition, our first state is sleeping, which is

733
00:48:16,448 --> 00:48:19,930
our initial state. So our state machine

734
00:48:20,290 --> 00:48:23,680
initial state setting on events works.

735
00:48:25,410 --> 00:48:29,310
Now we can move on to implements the FSM allowed command.

736
00:48:30,530 --> 00:48:34,126
Okay, so now we're going to implements the method that allows

737
00:48:34,158 --> 00:48:37,394
us to check whether an event can be

738
00:48:37,432 --> 00:48:40,754
applied to an object to transition to

739
00:48:40,792 --> 00:48:44,526
a different state. And to do that,

740
00:48:44,648 --> 00:48:48,194
first we're going to create a skeleton for the FSM allowed

741
00:48:48,242 --> 00:48:52,406
method function, sorry. And has the same signature as

742
00:48:52,428 --> 00:48:53,560
the methods before.

743
00:48:58,590 --> 00:49:02,010
And we are also going to

744
00:49:02,080 --> 00:49:05,814
register that command in our Redis module

745
00:49:05,942 --> 00:49:09,386
command declaration. Module declaration. So I have

746
00:49:09,408 --> 00:49:13,242
my FSM allowed. It's going to be backed by that FSM allowed

747
00:49:13,386 --> 00:49:17,280
function that we created above. And again it's going to be a read only

748
00:49:17,650 --> 00:49:20,522
these first key parameter.

749
00:49:20,586 --> 00:49:24,374
It's a parameter in position one. But this one takes two keys.

750
00:49:24,442 --> 00:49:28,622
So the first key would be the key of the FSM

751
00:49:28,686 --> 00:49:32,162
of the final state machine, and then the second key would be

752
00:49:32,216 --> 00:49:35,778
a target hash for which we are checking whether an event can be

753
00:49:35,784 --> 00:49:36,820
applied to.

754
00:49:39,380 --> 00:49:43,596
All right, so now we're

755
00:49:43,628 --> 00:49:47,960
going to add a method to our final state machine struct.

756
00:49:48,140 --> 00:49:52,580
So let's go find the final state machine, the finite state machine.

757
00:49:54,920 --> 00:49:58,324
Here in our impulse block, we're going

758
00:49:58,362 --> 00:50:02,436
to add a method called allowed.

759
00:50:02,548 --> 00:50:05,848
And this one is going to return an event.

760
00:50:05,934 --> 00:50:11,412
And this event is going to be one of our event substructs.

761
00:50:11,556 --> 00:50:15,260
This one right here. The event that basically

762
00:50:15,330 --> 00:50:18,760
denotes an event that can be applied

763
00:50:18,840 --> 00:50:22,780
to the state machine, which will basically transition

764
00:50:24,400 --> 00:50:28,316
from a state in the from vector

765
00:50:28,508 --> 00:50:31,890
to the final state denoted by the two field.

766
00:50:32,740 --> 00:50:37,056
All right, so in our function right

767
00:50:37,078 --> 00:50:40,852
now, we're returning none. So the first thing we're going to do is

768
00:50:40,986 --> 00:50:42,820
load the hash,

769
00:50:44,280 --> 00:50:47,860
the hash that basically we're checking against in

770
00:50:48,010 --> 00:50:51,832
that hash. We're only interested in the state field.

771
00:50:51,966 --> 00:50:57,576
So we're using the

772
00:50:57,598 --> 00:51:01,048
finite state machine field, which you remember it's in

773
00:51:01,054 --> 00:51:04,812
our declaration right here to basically look for

774
00:51:04,866 --> 00:51:08,380
that specific state in that target hash.

775
00:51:09,040 --> 00:51:12,844
And if we find that

776
00:51:12,882 --> 00:51:16,616
state, that's going to be in response. So we're

777
00:51:16,648 --> 00:51:20,880
going to grab the value of that, which is going to be a redis value

778
00:51:20,950 --> 00:51:25,010
simple string, and we're going to put that value in the current state.

779
00:51:25,380 --> 00:51:28,916
And assuming that we can get that value

780
00:51:29,018 --> 00:51:32,070
out, then we're going to

781
00:51:32,840 --> 00:51:36,992
find the event object, the event struct

782
00:51:37,056 --> 00:51:41,360
that it's inside of our final state machine by iterating

783
00:51:41,440 --> 00:51:45,064
over the events and going to find the event with the name

784
00:51:45,262 --> 00:51:49,432
that matches the FSM event value that's being

785
00:51:49,486 --> 00:51:52,996
passed to us. So this is the event that we're checking whether

786
00:51:53,118 --> 00:51:56,396
that hash can transition to, right. So if

787
00:51:56,418 --> 00:52:00,510
we find that event, it's going to be in our event object.

788
00:52:02,320 --> 00:52:05,688
And then if the current state of the

789
00:52:05,714 --> 00:52:09,376
from field. So if the current state

790
00:52:09,478 --> 00:52:15,296
of the hash, it's one of the values in

791
00:52:15,318 --> 00:52:18,752
the event from vector,

792
00:52:18,896 --> 00:52:22,612
then we know that we can transition to the

793
00:52:22,666 --> 00:52:26,470
final state denoted by that event.

794
00:52:26,920 --> 00:52:29,350
So if that's the case,

795
00:52:34,300 --> 00:52:37,864
we can basically return that

796
00:52:37,902 --> 00:52:41,304
event. Otherwise we return none. And now if we

797
00:52:41,342 --> 00:52:47,580
go back to the FSM allowed method.

798
00:52:50,080 --> 00:52:51,230
Here we go.

799
00:52:52,480 --> 00:52:56,288
Now we can refactor this to

800
00:52:56,374 --> 00:52:59,964
extract the keys.

801
00:53:00,012 --> 00:53:03,760
So I'm going to extract the final state machine key as the first key.

802
00:53:03,910 --> 00:53:07,232
Then the next key would be the hash key.

803
00:53:07,366 --> 00:53:10,596
We're also loading our redis key.

804
00:53:10,778 --> 00:53:14,950
So we can read the final state machine value

805
00:53:17,320 --> 00:53:20,404
and these event would

806
00:53:20,442 --> 00:53:23,792
be the next argument. So remember there's only two keys.

807
00:53:23,936 --> 00:53:27,672
So there's the final state machine key, the hash key,

808
00:53:27,726 --> 00:53:31,464
and then the target event. So that's why we only have two

809
00:53:31,502 --> 00:53:35,268
keys denoted in our declaration

810
00:53:35,444 --> 00:53:38,764
down here. So that two means that there's two keys, even though we have three

811
00:53:38,802 --> 00:53:42,670
parameters. The third parameter, it's the event that we're checking against.

812
00:53:43,840 --> 00:53:46,560
All right, so back to the FSM allowed.

813
00:53:46,980 --> 00:53:50,976
Let's finish that implements. So in here I'm going to have that guard again

814
00:53:51,078 --> 00:53:54,784
where I extract the final state machine object by

815
00:53:54,822 --> 00:53:57,440
reimbing it from redis,

816
00:53:59,380 --> 00:54:02,852
giving its key. And then now

817
00:54:02,906 --> 00:54:06,736
that I have the final state machine, I can call the final state machine allowed

818
00:54:06,768 --> 00:54:09,728
method that we just implemented above, passing the context,

819
00:54:09,824 --> 00:54:14,520
since we're going to use that to basically read things

820
00:54:14,590 --> 00:54:18,490
from redis, the hash key and the event. And then

821
00:54:19,260 --> 00:54:22,872
if I get an event back, that means that we're good.

822
00:54:23,006 --> 00:54:26,040
So I don't need the event object in this specific method,

823
00:54:26,120 --> 00:54:29,464
but then I'm going to use it to determine whether to return true or false

824
00:54:29,512 --> 00:54:30,350
right here.

825
00:54:33,280 --> 00:54:36,556
So now let's recompile

826
00:54:36,668 --> 00:54:41,802
the code and

827
00:54:41,936 --> 00:54:47,146
let's restart our server, loading our module and

828
00:54:47,168 --> 00:54:48,890
then back on the CLI.

829
00:54:50,690 --> 00:54:53,854
Let's up arrow here to recreate what we've done

830
00:54:53,892 --> 00:54:57,470
before. We're going to load the FSM

831
00:55:01,670 --> 00:55:05,662
and let's set a hash

832
00:55:05,806 --> 00:55:09,650
again. Let's use these job one with employee Brian.

833
00:55:12,790 --> 00:55:16,582
Again, let's double check that our

834
00:55:16,636 --> 00:55:19,698
initial state has been set on the hash.

835
00:55:19,874 --> 00:55:23,218
You can see that the state is sleeping. So now I'm

836
00:55:23,234 --> 00:55:26,598
going to do an FSM and this is going

837
00:55:26,604 --> 00:55:30,426
to be allowed. Notice that the CLI autocompletes that.

838
00:55:30,608 --> 00:55:34,282
And these first key

839
00:55:34,336 --> 00:55:37,418
we're going to pass here. It's our job,

840
00:55:37,584 --> 00:55:41,390
FSM. And then the second

841
00:55:41,460 --> 00:55:44,442
one is going to be the hash,

842
00:55:44,586 --> 00:55:46,800
which is job one.

843
00:55:47,570 --> 00:55:51,930
And then let's test

844
00:55:52,020 --> 00:55:56,034
one of the events. So one of the events that we have

845
00:55:56,232 --> 00:55:59,278
in our final state machine,

846
00:55:59,454 --> 00:56:03,810
it's sleep. So sleep can transition from

847
00:56:03,880 --> 00:56:07,240
running or cleaning. So let's try that one.

848
00:56:08,490 --> 00:56:11,810
Since we are not on running or cleaning, we're in sleeping,

849
00:56:11,890 --> 00:56:15,990
we return false, because we cannot transition

850
00:56:16,670 --> 00:56:19,990
using sleep. So the sleep event is not allowed

851
00:56:20,150 --> 00:56:21,660
in this specific case.

852
00:56:23,550 --> 00:56:27,660
But running can.

853
00:56:29,330 --> 00:56:32,382
The event run can transition from

854
00:56:32,436 --> 00:56:36,462
sleeping to running. So let's see if run

855
00:56:36,516 --> 00:56:40,778
it's allowed. And as you can see, run it is allowed.

856
00:56:40,954 --> 00:56:44,418
All right, so now we have a way to check whether an event can be

857
00:56:44,504 --> 00:56:48,290
applied to a given hash.

858
00:56:50,870 --> 00:56:54,130
Finally, we can implements the FSM trigger command.

859
00:56:56,170 --> 00:56:59,890
All right, so now we actually are only missing

860
00:57:00,050 --> 00:57:03,990
the command that would allow us to actually transition

861
00:57:04,410 --> 00:57:07,542
a hash from one event

862
00:57:07,596 --> 00:57:11,114
to the other. So we have one to ask whether a transition or

863
00:57:11,152 --> 00:57:14,678
an event can be applied to a hash.

864
00:57:14,774 --> 00:57:18,202
And now we're going to have one that actually triggers that event.

865
00:57:18,336 --> 00:57:22,510
So to do that we're going to create a skeleton method

866
00:57:22,930 --> 00:57:27,150
for our new command. And this is going to be FSM trigger.

867
00:57:27,570 --> 00:57:31,402
We're grabbing basically the same arguments that we were grabbing

868
00:57:31,546 --> 00:57:34,754
with FSM allowed. So this whole block here,

869
00:57:34,792 --> 00:57:38,350
it's identical. We again are grabbing the state machine

870
00:57:38,510 --> 00:57:41,742
and this one is again going to return a boolean.

871
00:57:41,886 --> 00:57:45,910
So to actually do this, we now

872
00:57:45,980 --> 00:57:50,038
need to, as we did before, implements a

873
00:57:50,124 --> 00:57:53,570
method in our final state machine,

874
00:57:53,730 --> 00:57:58,470
finite state machine struct.

875
00:57:58,630 --> 00:58:03,178
So let's find our implementation up

876
00:58:03,264 --> 00:58:07,366
here. Okay, so we have there the allowed method

877
00:58:07,398 --> 00:58:11,466
that we implemented earlier, and now we're

878
00:58:11,498 --> 00:58:15,450
going to create a trigger method. And the trigger method, the implementation,

879
00:58:15,530 --> 00:58:18,974
it's very similar and it actually reuses the

880
00:58:19,012 --> 00:58:22,322
allowed method. So notice in here that again

881
00:58:22,376 --> 00:58:25,950
I am grabbing the key of the hash

882
00:58:26,030 --> 00:58:29,506
that I'm interested in applying an event against,

883
00:58:29,688 --> 00:58:32,434
and then I am going to grab the event.

884
00:58:32,552 --> 00:58:37,318
Only remember that we said allow to return the

885
00:58:37,404 --> 00:58:41,160
event that you need to use for that specific current

886
00:58:42,410 --> 00:58:45,686
event. And I use

887
00:58:45,708 --> 00:58:48,746
the allowed method above to grab that event,

888
00:58:48,928 --> 00:58:53,050
passing the context, the key of the

889
00:58:53,200 --> 00:58:56,874
final state machine, of the hash and

890
00:58:56,912 --> 00:59:00,094
the event. And then I'm going

891
00:59:00,132 --> 00:59:04,346
to now call h set on the target hash,

892
00:59:04,458 --> 00:59:08,110
and I'm going to set the event field

893
00:59:08,180 --> 00:59:11,390
or the state field to the event that they're interested

894
00:59:11,460 --> 00:59:14,850
in. And again, I have this guard right here that

895
00:59:15,000 --> 00:59:18,402
basically it's asking whether the event is allowed by using

896
00:59:18,456 --> 00:59:21,778
the allowed method. And if it's so I then change

897
00:59:21,864 --> 00:59:24,834
the value of that field on the hash.

898
00:59:24,962 --> 00:59:29,414
Then I basically just return to

899
00:59:29,452 --> 00:59:33,298
the caller if I get an okay response.

900
00:59:33,474 --> 00:59:37,194
So now once we have that

901
00:59:37,312 --> 00:59:41,162
trigger implemented in there in the final

902
00:59:41,216 --> 00:59:44,442
state machine, we can go back to our

903
00:59:44,496 --> 00:59:48,742
FSM trigger skeleton and finish the implementation

904
00:59:48,806 --> 00:59:52,330
in here by simply having an allowed variable

905
00:59:52,490 --> 00:59:57,050
that calls the trigger method

906
00:59:57,130 --> 01:00:01,226
in the finite state machine struct.

907
01:00:01,418 --> 01:00:05,950
And I use that to return that boolean

908
01:00:06,030 --> 01:00:09,650
as an integer in my redis value response

909
01:00:10,790 --> 01:00:14,078
redis result. So with that in place,

910
01:00:14,264 --> 01:00:18,358
then all we have left to do is

911
01:00:18,524 --> 01:00:22,146
register our method. So now I'm registering

912
01:00:22,178 --> 01:00:26,210
the trigger method with the redis module

913
01:00:26,290 --> 01:00:29,866
macro commands list. And again, this one,

914
01:00:29,968 --> 01:00:34,070
it's just like FSM created. It's a write method

915
01:00:34,230 --> 01:00:37,626
and it takes the first key, it's the

916
01:00:37,648 --> 01:00:41,406
key in position one, position zero, remember, is just the

917
01:00:41,508 --> 01:00:44,714
command itself. And it has two keys,

918
01:00:44,842 --> 01:00:47,150
the final state machine and the hash.

919
01:00:48,130 --> 01:00:51,840
So now with that in place, we can

920
01:00:53,590 --> 01:00:54,740
test again.

921
01:00:57,270 --> 01:01:01,006
So, okay, now we have completed the basic implementation

922
01:01:01,038 --> 01:01:04,934
of our toit state machine. So let's go ahead and compile the

923
01:01:04,972 --> 01:01:08,518
code again. And I'm going to

924
01:01:08,684 --> 01:01:10,310
launch the redis server.

925
01:01:11,770 --> 01:01:15,430
And then once again, let's get to the CLI

926
01:01:17,150 --> 01:01:20,730
and arrow to find our FSM create.

927
01:01:20,880 --> 01:01:24,860
Let's just test all of our methods. So when we run FSM create,

928
01:01:26,430 --> 01:01:29,998
remember that that creates the job

929
01:01:30,084 --> 01:01:33,550
FSM custom

930
01:01:33,620 --> 01:01:37,054
data type, which is a finite state machine data type. So when

931
01:01:37,092 --> 01:01:40,350
we check the type of it, we get redis fsm,

932
01:01:41,590 --> 01:01:44,370
these redis fsm hash.

933
01:01:45,190 --> 01:01:49,342
Once again, it's a native redis hash

934
01:01:49,486 --> 01:01:56,630
where we are keeping our mappings of mappings

935
01:01:57,210 --> 01:02:01,398
of prefixes or hash prefixes to

936
01:02:01,564 --> 01:02:04,390
finite state machine keys.

937
01:02:04,890 --> 01:02:08,746
So again, we have for the sample that we've been using,

938
01:02:08,928 --> 01:02:12,794
it's job for the prefix, and that maps to

939
01:02:12,912 --> 01:02:15,626
the job fsm key. All right,

940
01:02:15,728 --> 01:02:19,158
remember that we also implements the

941
01:02:19,264 --> 01:02:22,750
info so we can pass the

942
01:02:22,820 --> 01:02:26,378
name of a state machine and that will basically grab

943
01:02:26,474 --> 01:02:31,690
that native data type that's stored in redis and use cert

944
01:02:31,780 --> 01:02:35,534
JSON to convert that to a readable chunk

945
01:02:35,582 --> 01:02:39,778
of JSON. And if

946
01:02:39,944 --> 01:02:43,540
we create, let's create

947
01:02:44,090 --> 01:02:46,390
a hash.

948
01:02:47,450 --> 01:02:51,414
Here we go. We create a hash. And now we do

949
01:02:51,452 --> 01:02:54,950
an h get all on that hash.

950
01:02:55,370 --> 01:03:00,506
We should have our state

951
01:03:00,688 --> 01:03:04,218
set to the correct value, which is the initial state of

952
01:03:04,224 --> 01:03:07,850
the state machine sleeping. And then remember

953
01:03:07,920 --> 01:03:11,470
that we can ask the state machine

954
01:03:13,010 --> 01:03:17,310
whether we can transition to the different using

955
01:03:17,380 --> 01:03:21,006
different events. So we can ask whether we can run

956
01:03:21,188 --> 01:03:24,100
from sleeping. And it says yes.

957
01:03:24,470 --> 01:03:26,900
And what was the other one?

958
01:03:28,390 --> 01:03:32,180
The other one was sleep, and that's a no.

959
01:03:32,630 --> 01:03:36,710
So since we know that we are allowed to

960
01:03:36,780 --> 01:03:40,920
run, I'm going to trigger the

961
01:03:44,170 --> 01:03:48,294
run event on our target

962
01:03:48,342 --> 01:03:52,378
hash. And that responded with a true.

963
01:03:52,544 --> 01:03:55,242
So now if we do an h, get all,

964
01:03:55,376 --> 01:03:59,226
remember we were in these state sleeping, and now we are in the

965
01:03:59,248 --> 01:04:03,574
state running. So there we go. A simple toy

966
01:04:03,622 --> 01:04:06,910
state machine implemented as a Redis module.

967
01:04:08,930 --> 01:04:12,606
And of course, all the source code for today's demo can be found under my

968
01:04:12,628 --> 01:04:13,950
GitHub repositories.

969
01:04:16,130 --> 01:04:20,014
To learn more, visit us at Redis developer, which is

970
01:04:20,052 --> 01:04:23,178
located at developer redis.com. These we have tons

971
01:04:23,194 --> 01:04:26,662
of examples for pretty much every programming language for

972
01:04:26,716 --> 01:04:30,358
interesting things you can do with Redis. And also, if you want

973
01:04:30,364 --> 01:04:34,034
to learn more about Redis, come to Redis University, where there's a variety

974
01:04:34,082 --> 01:04:37,300
of courses that can help you become a Redis expert in no time.

