1
00:00:25,410 --> 00:00:29,446
You. Hello everyone. I want to talk to you today about how

2
00:00:29,468 --> 00:00:33,634
to break into blockchain development using the Reach programming language, which leverages

3
00:00:33,762 --> 00:00:37,702
JavaScript as the primary way of programming and

4
00:00:37,756 --> 00:00:40,710
leverages an existing JavaScript ecosystem.

5
00:00:41,050 --> 00:00:45,126
Now this talk will primarily be about what the idea of

6
00:00:45,148 --> 00:00:48,534
blockchain is, what the idea of reach is,

7
00:00:48,652 --> 00:00:52,640
and not like a tutor tutorial about how to program it. If you want to

8
00:00:53,090 --> 00:00:57,002
see a tutorial, you should go to our website docs

9
00:00:57,066 --> 00:01:00,640
reach sh, which I'll talk about again at the end.

10
00:01:01,090 --> 00:01:05,102
Now, to start off, I want to explain a little bit about what blockchain

11
00:01:05,166 --> 00:01:09,298
is to help get some context for this.

12
00:01:09,464 --> 00:01:13,374
Now, I think that lots of people, when they think blockchain, they simply

13
00:01:13,422 --> 00:01:18,018
think that we must be talking about cryptocurrencies. Weve cryptocurrencies

14
00:01:18,114 --> 00:01:21,254
are. I think that some

15
00:01:21,292 --> 00:01:25,058
people, they have kind of a bad reputation

16
00:01:25,234 --> 00:01:29,062
where they seem to be some sort of crazy speculative

17
00:01:29,126 --> 00:01:32,890
scheme. Other times, if you think about cryptocurrency,

18
00:01:33,710 --> 00:01:37,158
people think about them as this grand

19
00:01:37,254 --> 00:01:42,842
philosophical experiment in defeating

20
00:01:42,906 --> 00:01:46,126
government power or something like that. And I think

21
00:01:46,148 --> 00:01:50,014
that there is a lot to say about cryptocurrencies and they're a very

22
00:01:50,052 --> 00:01:53,938
interesting and rich area. But I want to emphasize today

23
00:01:54,024 --> 00:01:57,826
that cryptocurrencies are not the only thing that blockchain is.

24
00:01:57,928 --> 00:02:01,714
And when I talk about breaking into blockchain development, I'm not really

25
00:02:01,752 --> 00:02:06,360
talking about cryptocurrencies. I'm talking about the

26
00:02:06,970 --> 00:02:11,654
technical tool of blockchain, which I

27
00:02:11,692 --> 00:02:16,600
think that we will see enter

28
00:02:17,290 --> 00:02:20,854
our technical lexicon in the same way that client

29
00:02:20,902 --> 00:02:24,854
server programming has or asynchronous programming, there's simply

30
00:02:24,902 --> 00:02:28,822
a new category of programming that is based on decentralized

31
00:02:28,886 --> 00:02:33,166
applications and blockchains. And that is what we're talking about today.

32
00:02:33,348 --> 00:02:36,814
Now, what exactly am I referring to?

33
00:02:36,932 --> 00:02:40,160
What is blockchain for as this core technology?

34
00:02:41,090 --> 00:02:44,554
Let's think about a traditional infrastructure weve.

35
00:02:44,612 --> 00:02:48,258
You're going to have a web application or you're going to

36
00:02:48,264 --> 00:02:51,666
have some sort of server application, and clients, whether on the

37
00:02:51,688 --> 00:02:55,038
web or on your smartphone or something like

38
00:02:55,064 --> 00:02:59,174
that, where you're going to have some

39
00:02:59,212 --> 00:03:03,142
way of paying for something. So normally the way that this works is

40
00:03:03,196 --> 00:03:07,094
that your client has a front end. That front

41
00:03:07,132 --> 00:03:11,114
end speaks to your back end server and your back end server will

42
00:03:11,152 --> 00:03:15,050
say, all right, it's now time to buy something. And it will tell a payment

43
00:03:15,120 --> 00:03:19,338
processor, this client has to pay me $10 and then

44
00:03:19,424 --> 00:03:23,286
the frontend will then communicate with the payment processor.

45
00:03:23,478 --> 00:03:26,798
For instance, maybe there will be like another window that will pop up. That will

46
00:03:26,804 --> 00:03:30,286
go to PayPal or to stripe or something like that. And then the

47
00:03:30,308 --> 00:03:32,960
payment processor and the front end will communicate together.

48
00:03:33,330 --> 00:03:36,450
The payment processor will say, all right, you got your $10,

49
00:03:36,600 --> 00:03:40,562
and then it will tell the back end that, here's the money, that the money

50
00:03:40,616 --> 00:03:44,606
came, and the payment processor will basically intermediate

51
00:03:44,718 --> 00:03:48,178
between the bank, the back end, and the front end. Now, that's sort

52
00:03:48,184 --> 00:03:51,462
of like a modern way that a payment processor works, but it is also possible

53
00:03:51,596 --> 00:03:54,742
CTO have a payment processor where the front end

54
00:03:54,796 --> 00:03:58,310
communicates to the back end. The frontend actually shares their payment

55
00:03:58,380 --> 00:04:02,086
information with the back end, and the back end communicates that entirely

56
00:04:02,118 --> 00:04:06,250
to the payment processor. So this would be an example of an application where

57
00:04:06,400 --> 00:04:10,390
your client directly tells your server

58
00:04:10,470 --> 00:04:13,774
what the credit card information is, and then the back end

59
00:04:13,812 --> 00:04:18,190
gives that to a payment processor. So, in both of these situations,

60
00:04:19,810 --> 00:04:23,218
in the version where the front end directly gives the credit card information to the

61
00:04:23,224 --> 00:04:27,182
back end, this clearly feels

62
00:04:27,246 --> 00:04:31,070
untrustworthy to some. Well, feels risky

63
00:04:31,150 --> 00:04:34,978
to some clients, because they don't want to share their credit card information with everyone.

64
00:04:35,064 --> 00:04:38,662
And that's why we've moved to the second kind of

65
00:04:38,716 --> 00:04:42,642
payment processing, where the front end directly communicates to the payment processor.

66
00:04:42,786 --> 00:04:46,246
However, the payment processor is still not the actual

67
00:04:46,348 --> 00:04:50,214
bank. The front end and the back end cannot

68
00:04:50,262 --> 00:04:53,862
communicate directly with the bank. And this is mainly

69
00:04:53,926 --> 00:04:57,802
for technical reasons that they just don't speak

70
00:04:57,856 --> 00:05:01,630
the right. They don't use the same tools.

71
00:05:02,370 --> 00:05:05,440
There's not, like, a unified way. CTO,

72
00:05:07,410 --> 00:05:12,154
if my bank is Wells Fargo and your bank is chase

73
00:05:12,202 --> 00:05:15,298
or something like that, then there's not, like, one way to communicate with them.

74
00:05:15,304 --> 00:05:18,478
And that's basically the service that the payment processors are providing.

75
00:05:18,654 --> 00:05:20,370
But these payment processors,

76
00:05:21,430 --> 00:05:25,418
in providing this service of intermediating,

77
00:05:25,614 --> 00:05:30,070
it allows them to impose constraints

78
00:05:30,810 --> 00:05:35,270
on front ends and back ends. So, for instance, it allows them to charge fees.

79
00:05:35,690 --> 00:05:36,950
And those fees,

80
00:05:39,210 --> 00:05:42,934
they're providing a valuable service. I'm not saying that the fees are, like, inherently immoral

81
00:05:42,982 --> 00:05:46,890
or something like that. Built the fees, make it so that the payment

82
00:05:46,960 --> 00:05:51,020
processing is more expensive than it intrinsically has to be.

83
00:05:51,570 --> 00:05:55,102
Similarly, the payment processor is in a position

84
00:05:55,156 --> 00:05:58,638
of trust. So imagine if a back end says, I need to

85
00:05:58,644 --> 00:06:02,586
be paid $10, and the payment processor actually tells

86
00:06:02,618 --> 00:06:05,746
the front end that you need to pay me $15.

87
00:06:05,848 --> 00:06:08,340
And then what it does is it pockets that $5.

88
00:06:08,950 --> 00:06:12,914
Now, a payment processor that did this would

89
00:06:12,952 --> 00:06:16,982
be probably quickly found out, but it does have the power. CTO do this,

90
00:06:17,116 --> 00:06:21,110
and there's no way to enforce, as part of your system

91
00:06:21,180 --> 00:06:23,480
that a payment processor doesn't do that.

92
00:06:24,890 --> 00:06:28,850
So this scenario right here describes how

93
00:06:29,020 --> 00:06:32,826
payments typically work right now on the web.

94
00:06:33,008 --> 00:06:36,602
And what blockchain allows to happen is to

95
00:06:36,656 --> 00:06:40,826
remove the payment processor and CTO have the front end and back end directly communicate

96
00:06:40,938 --> 00:06:44,558
with, quote, the bank. Now there's another thing that

97
00:06:44,724 --> 00:06:48,590
blockchain allow you to do, which is to have trustless databases.

98
00:06:48,930 --> 00:06:52,818
So here's another scenario. A front end communicates with a

99
00:06:52,824 --> 00:06:55,010
back end that manages a database.

100
00:06:56,790 --> 00:07:01,086
This infrastructure obviously describes thousands

101
00:07:01,118 --> 00:07:04,994
and thousands of applications. And a key thing

102
00:07:05,032 --> 00:07:08,738
about this setup is that the front end does not directly communicate

103
00:07:08,754 --> 00:07:12,354
with the database because it doesn't directly communicate with the database.

104
00:07:12,482 --> 00:07:15,894
This provides the feature of the database being able to

105
00:07:15,932 --> 00:07:19,538
obey certain invariants, have certain performance characteristics and so

106
00:07:19,564 --> 00:07:22,826
on. So there's desirable reasons to do this, but the

107
00:07:22,848 --> 00:07:26,614
downside of this is that because the back end completely intermediates

108
00:07:26,662 --> 00:07:29,814
access to the database, the back end can control

109
00:07:29,952 --> 00:07:33,200
the database in a way that the front end

110
00:07:35,170 --> 00:07:40,494
may not like. So as an example, a social networking site does

111
00:07:40,532 --> 00:07:46,338
not provide you access to your

112
00:07:46,424 --> 00:07:49,774
social networking data like your photos and whatnot.

113
00:07:49,902 --> 00:07:53,074
It holds those for you. And so it can, for example,

114
00:07:53,192 --> 00:07:56,802
censor them, it can sell them to somebody else.

115
00:07:56,936 --> 00:08:00,310
It can change them behind your back without you knowing.

116
00:08:01,050 --> 00:08:04,390
It can sort of rewrite the past. So because

117
00:08:04,460 --> 00:08:07,654
the back end is the only one that has access to the database, it is

118
00:08:07,692 --> 00:08:10,620
in a position of trust. Now,

119
00:08:11,230 --> 00:08:15,162
this database, you can kind of think of this as being an example

120
00:08:15,296 --> 00:08:18,582
of the quote ledger that the bank is managing.

121
00:08:18,726 --> 00:08:21,802
The bank. What it does is it manages a database that says,

122
00:08:21,936 --> 00:08:24,830
jay has a certain amount of money, Chris had a certain amount of money,

123
00:08:24,900 --> 00:08:27,438
Sarah has a certain amount of money. And that is just a particular kind of

124
00:08:27,444 --> 00:08:30,858
database. And anytime

125
00:08:30,954 --> 00:08:34,866
that a database is centralized, that means that the central holder of

126
00:08:34,888 --> 00:08:38,226
the database has control over the data and can

127
00:08:38,248 --> 00:08:42,030
change it. And that means that if you use this database,

128
00:08:42,110 --> 00:08:46,102
you have to trust that the provider will not

129
00:08:46,236 --> 00:08:49,400
modify it in a way that you don't like.

130
00:08:50,170 --> 00:08:53,830
Blockchain is inherently a technology to create

131
00:08:53,900 --> 00:08:57,250
a situation like the following, where clients

132
00:08:57,330 --> 00:09:00,874
and quote servers are peers inside of a network where they

133
00:09:00,912 --> 00:09:04,534
communicate with each other and they communicate with a decentralized

134
00:09:04,582 --> 00:09:08,042
ledger. This decentralized ledger is

135
00:09:08,096 --> 00:09:11,706
just a database that stores information. And the database

136
00:09:11,738 --> 00:09:15,870
that stores your account balances is just a particular kind of database.

137
00:09:16,530 --> 00:09:21,402
And there is really interesting cryptography

138
00:09:21,466 --> 00:09:24,814
and technical techniques for how these databases

139
00:09:24,862 --> 00:09:28,466
and ledgers are managed. And if you're really curious about

140
00:09:28,488 --> 00:09:32,434
this, I encourage you to go learn about that. But as

141
00:09:32,472 --> 00:09:36,146
a blockchain programmer, you don't actually need to know the details of

142
00:09:36,168 --> 00:09:39,730
this, just like you can use an SQL database without knowing

143
00:09:39,810 --> 00:09:44,082
exactly how query optimization works. Maybe you know that query optimization

144
00:09:44,146 --> 00:09:47,238
exists, but you don't need to know exactly what the details are. And the

145
00:09:47,244 --> 00:09:52,086
same is true for blockchain programming. Now the reason that cryptocurrencies

146
00:09:52,278 --> 00:09:57,206
come in is because blockchain was originally discovered

147
00:09:57,238 --> 00:10:00,686
CTO manage a ledger of balances. And so that's why

148
00:10:00,708 --> 00:10:03,866
that was just kind of the first database. But blockchain programs

149
00:10:03,898 --> 00:10:07,310
have evolved to support arbitrary databases.

150
00:10:08,370 --> 00:10:09,390
Secondly,

151
00:10:11,890 --> 00:10:15,470
when you use blockchain as a payments platform, then you're

152
00:10:15,550 --> 00:10:19,394
paying in whatever the tokens are of

153
00:10:19,432 --> 00:10:23,220
that particular blockchain. And so that of course will enter into

154
00:10:23,590 --> 00:10:27,160
your calculus when you're designing your program. So for example,

155
00:10:27,530 --> 00:10:31,240
it's very obvious to sell books for us dollars.

156
00:10:32,010 --> 00:10:35,800
But if you want to sell books, for example

157
00:10:36,490 --> 00:10:39,926
Algorand tokens or Cardano tokens or Solana

158
00:10:39,958 --> 00:10:43,734
tokens, then just sort of your business becomes

159
00:10:43,782 --> 00:10:47,574
operationally more complicated because you have to make sure that you're not losing

160
00:10:47,622 --> 00:10:49,930
money in the conversions.

161
00:10:51,230 --> 00:10:54,942
But of course the trade off for this is that you get this

162
00:10:54,996 --> 00:10:57,520
trustless payments platform.

163
00:10:58,370 --> 00:11:02,362
My personal opinion is that the complex

164
00:11:02,426 --> 00:11:06,210
of managing the payments angle

165
00:11:07,030 --> 00:11:10,286
is unproven and risky

166
00:11:10,318 --> 00:11:13,854
because of the volatility of cryptocurrencies. But the trustless

167
00:11:13,902 --> 00:11:18,006
database, that technology is ready to be used right now for

168
00:11:18,028 --> 00:11:21,926
all sorts of interesting applications. All right, so this

169
00:11:21,948 --> 00:11:25,142
is what I mean by blockchain. This is the space that we're talking

170
00:11:25,196 --> 00:11:28,966
about. And what

171
00:11:28,988 --> 00:11:31,626
I want to do for the rest of the talk is tell you about what

172
00:11:31,648 --> 00:11:34,826
it's like to program on blockchain today and what

173
00:11:34,848 --> 00:11:38,794
are some of its difficulties and how we at reach have designed a

174
00:11:38,832 --> 00:11:42,730
programming language and platform that makes programming in this world easier.

175
00:11:42,890 --> 00:11:46,334
Now the first issue about blockchain programming is that

176
00:11:46,372 --> 00:11:49,466
it is extremely low level programming.

177
00:11:49,578 --> 00:11:52,030
Now what do I mean by low level programming?

178
00:11:52,690 --> 00:11:56,526
Kind of intuitively, I think that weve familiar with the idea that you have programming

179
00:11:56,558 --> 00:11:59,220
languages that are like JavaScript, that are very high level.

180
00:11:59,910 --> 00:12:03,474
Maybe we could even imagine that there's even a higher level than JavaScript. So for

181
00:12:03,512 --> 00:12:07,026
instance, if you're going to have SQL, an SQL

182
00:12:07,058 --> 00:12:10,520
program is at

183
00:12:11,290 --> 00:12:15,266
an even higher level of programming than JavaScript. And then you've got JavaScript,

184
00:12:15,378 --> 00:12:18,746
and then you have programming languages like C and C Plus plus,

185
00:12:18,848 --> 00:12:22,810
and then you have underlying machine languages like assembly.

186
00:12:23,790 --> 00:12:27,066
So there's this hierarchy of programming languages where we

187
00:12:27,088 --> 00:12:30,266
kind of intuitively understand that as you get closer to the

188
00:12:30,288 --> 00:12:33,982
hardware, it becomes more complicated. CTO write the programs because

189
00:12:34,036 --> 00:12:36,880
there are more details that you need to manage yourself.

190
00:12:37,490 --> 00:12:41,150
And ultimately, when you get down to the actual hardware,

191
00:12:41,570 --> 00:12:44,050
meaning like the circuits and whatnot,

192
00:12:44,870 --> 00:12:48,238
it's almost like the skills

193
00:12:48,254 --> 00:12:51,646
of programming don't even really apply in the same way, because you're

194
00:12:51,678 --> 00:12:55,694
not really designing a program, you're designing a circuit.

195
00:12:55,742 --> 00:12:59,410
Now, of course, if you understand circuits very deeply,

196
00:12:59,570 --> 00:13:02,470
you might be able to think about them as a special kind of program,

197
00:13:02,540 --> 00:13:06,422
but it's a very different kind of program. Now, the thing is

198
00:13:06,476 --> 00:13:10,594
that right now, the sort of the standard way of developing blockchain

199
00:13:10,642 --> 00:13:14,506
programs is very low level. And that's because the main thing

200
00:13:14,528 --> 00:13:17,446
that you need to think about when you write a blockchain program is you're designing

201
00:13:17,478 --> 00:13:21,546
a state machine. Now, I think that many of us are familiar with the concept

202
00:13:21,578 --> 00:13:25,194
of a state machine because we use them when we're

203
00:13:25,242 --> 00:13:28,602
designing reactive components

204
00:13:28,666 --> 00:13:32,320
and whatnot. But the basic idea of a state machine is that

205
00:13:34,470 --> 00:13:38,434
you have a particular set of finite states

206
00:13:38,552 --> 00:13:42,482
that describe what is

207
00:13:42,536 --> 00:13:46,386
relevant about a program, what is relevant about some

208
00:13:46,408 --> 00:13:50,182
data, and then you have edges or transitions that correspond to

209
00:13:50,236 --> 00:13:53,590
what actions users can take. And if a user takes

210
00:13:53,660 --> 00:13:56,280
a certain action, then you manipulate the state in one way.

211
00:13:56,970 --> 00:14:00,758
And when you program blockchain programs,

212
00:14:00,854 --> 00:14:04,202
typically what you need to do is you need CTo either

213
00:14:04,256 --> 00:14:08,390
explicitly or implicitly design this state machine

214
00:14:08,550 --> 00:14:13,470
where all the arrows that are the transition arrows basically become functions

215
00:14:14,050 --> 00:14:16,590
on what is called your smart contract.

216
00:14:17,330 --> 00:14:21,134
And because these functions are spread out across your

217
00:14:21,172 --> 00:14:24,746
entire program, they have to be programmed

218
00:14:24,778 --> 00:14:28,258
in a very particular way. They have to start off by double breaking to make

219
00:14:28,264 --> 00:14:31,570
sure that they are called. While the program is in the correct state,

220
00:14:31,720 --> 00:14:36,082
then they need to take the external actions that correspond

221
00:14:36,146 --> 00:14:39,720
to whatever this arrow does. Then they need to update the state.

222
00:14:40,570 --> 00:14:44,434
And because of the way that most programming languages

223
00:14:44,562 --> 00:14:48,134
for blockchain work, this state machine

224
00:14:48,182 --> 00:14:50,090
is entirely implicit,

225
00:14:51,070 --> 00:14:54,438
but you have to manually program all of the arrows.

226
00:14:54,534 --> 00:14:57,958
And so it's a very complicated style of programming.

227
00:14:58,134 --> 00:15:01,802
One of the most popular languages for blockchain programming right now is called

228
00:15:01,856 --> 00:15:04,894
solidity. I want to show you a little snippet of solidity code.

229
00:15:05,092 --> 00:15:09,262
So this right here is a little snippet of solidity code. It's a c

230
00:15:09,316 --> 00:15:12,806
like languages. And when I say c like language, I mean syntactically,

231
00:15:12,858 --> 00:15:14,580
it looks very similar. CTO C.

232
00:15:15,590 --> 00:15:18,798
And it's

233
00:15:18,814 --> 00:15:22,562
kind of a class oriented language where the state

234
00:15:22,616 --> 00:15:25,966
of your program is implicit in the instant variables

235
00:15:26,078 --> 00:15:28,790
of your objects, which are called contracts.

236
00:15:29,290 --> 00:15:32,406
And one of the things that you

237
00:15:32,428 --> 00:15:36,106
do, if you look here on this middle line where it says require, one of

238
00:15:36,108 --> 00:15:39,266
the things that you're constantly doing is each function in

239
00:15:39,308 --> 00:15:43,366
your contract corresponds to one of those transition functions.

240
00:15:43,558 --> 00:15:47,226
And the main thing that you do is you put at the start of a

241
00:15:47,248 --> 00:15:50,634
program, a start of a function, a whole bunch of

242
00:15:50,672 --> 00:15:54,266
checks to make sure that you're in the appropriate state. And then once you're

243
00:15:54,298 --> 00:15:57,466
in that appropriate state, you then make the modifications,

244
00:15:57,498 --> 00:16:01,742
and then you emit events so that others can tell that

245
00:16:01,876 --> 00:16:05,346
an event actually happened. Now, this program is a

246
00:16:05,368 --> 00:16:08,754
very, very small program to just give you kind of a sense about what

247
00:16:08,792 --> 00:16:13,038
the shape of a solidity program is. And programming

248
00:16:13,054 --> 00:16:17,010
in solidity feels like programming in a

249
00:16:17,160 --> 00:16:20,326
c lines low level programming language. And I say low

250
00:16:20,348 --> 00:16:23,990
level programming language because there are lots of low level

251
00:16:24,060 --> 00:16:28,274
details that you must think about all of the time when you're programming in solidity.

252
00:16:28,402 --> 00:16:31,962
For example, when you program in solidity, you have to make sure that you never

253
00:16:32,016 --> 00:16:35,466
use more than 16 local variables, because otherwise you

254
00:16:35,488 --> 00:16:38,906
will overflow the stack. So that's the

255
00:16:38,928 --> 00:16:42,314
sort of concern that normally you only think

256
00:16:42,352 --> 00:16:46,110
about when you're programming an assembly. But something like that is relevant to solidity.

257
00:16:46,450 --> 00:16:49,678
Now, this program that I have up here, we don't need to

258
00:16:49,684 --> 00:16:53,018
belabor the details, but this is a complete program that does something useful,

259
00:16:53,194 --> 00:16:56,446
but it's not really representative of the kinds of programs

260
00:16:56,478 --> 00:17:00,814
that people write. In contrast, you may have heard of the program Uniswap.

261
00:17:00,862 --> 00:17:04,754
Uniswap is one of the most popular programs right now on

262
00:17:04,792 --> 00:17:08,326
the Ethereum network. And here's a snippet of

263
00:17:08,348 --> 00:17:13,382
a single one of its functions. So this

264
00:17:13,436 --> 00:17:19,020
is a very large program that

265
00:17:22,030 --> 00:17:25,180
there's a lot going on here. And of course,

266
00:17:25,950 --> 00:17:29,146
I don't expect you CTO, be able to understand or

267
00:17:29,168 --> 00:17:32,610
follow this, but this is actually a copy from the real source

268
00:17:32,630 --> 00:17:36,334
code. I haven't really modified it anyway, I think I deleted three new

269
00:17:36,372 --> 00:17:39,534
lines in it. But even from

270
00:17:39,572 --> 00:17:42,970
this, I hope that you can get a sense that some complicated

271
00:17:43,050 --> 00:17:46,514
things are going on in this program. We have to be

272
00:17:46,552 --> 00:17:50,466
very particular about checking our state. The very first things that

273
00:17:50,488 --> 00:17:53,986
happen up here in the beginning of the program where

274
00:17:54,008 --> 00:17:57,286
it says require, require, this is us checking the state.

275
00:17:57,468 --> 00:18:01,622
And even though this program does fit on one screen,

276
00:18:01,756 --> 00:18:05,586
one of the things that you'll notice is that there's this little comment

277
00:18:05,618 --> 00:18:09,562
about halfway through that says scope for token zero and one

278
00:18:09,616 --> 00:18:12,682
avoid stack two deep errors. So that means that even

279
00:18:12,736 --> 00:18:14,300
in this small program,

280
00:18:15,630 --> 00:18:19,754
the issue about running out of stack space is relevant for

281
00:18:19,792 --> 00:18:22,954
the programmer of this function. So when I say that

282
00:18:22,992 --> 00:18:27,150
as a solid programmer, you need to pay attention to low level details,

283
00:18:27,810 --> 00:18:31,146
I hope that it's clear that I'm

284
00:18:31,178 --> 00:18:34,322
not being too flippant about this,

285
00:18:34,376 --> 00:18:38,418
and that normal programs that you find in the wild actually

286
00:18:38,504 --> 00:18:42,242
deal with these issues. And so what this means is that

287
00:18:42,376 --> 00:18:46,390
as a blockchain developer with traditional tools,

288
00:18:50,010 --> 00:18:53,254
you need to have a lot of expertise in this low level

289
00:18:53,292 --> 00:18:56,886
machinery. Now what's worse, in my

290
00:18:56,908 --> 00:18:59,942
opinion, is that CTO design this program,

291
00:19:00,076 --> 00:19:03,910
you really do need to have that state machine model in your brain

292
00:19:04,070 --> 00:19:07,542
built. The state machine is not actually in your program anywhere,

293
00:19:07,606 --> 00:19:11,430
because your program is simply the arrow, the transition arrows. It's not the

294
00:19:11,440 --> 00:19:14,586
state machine itself. Now I want to show you a little sample

295
00:19:14,618 --> 00:19:18,480
of reach code. This right here is a complete reach program

296
00:19:19,090 --> 00:19:23,338
that when you compile it corresponds to roughly,

297
00:19:23,434 --> 00:19:26,900
I don't know, one or 200 lines of solidity code.

298
00:19:27,590 --> 00:19:30,766
Now of course you don't know what this program means. I haven't explained

299
00:19:30,798 --> 00:19:33,490
it, and it's a very different program.

300
00:19:33,560 --> 00:19:37,526
But one of the key ideas inside of Reach is that

301
00:19:37,708 --> 00:19:42,018
when you write a reach program a you're programming in JavaScript.

302
00:19:42,114 --> 00:19:45,590
It's sort of like you're programming in JavaScript with kind of like a weird library.

303
00:19:47,050 --> 00:19:50,746
And in this library you

304
00:19:50,768 --> 00:19:54,614
take the perspective of a detached

305
00:19:54,662 --> 00:19:58,966
observer who is observing other entities

306
00:19:59,158 --> 00:20:03,466
participating in a communication, in a decentralized computation,

307
00:20:03,658 --> 00:20:06,560
where you say, oh, well, at this part of the program,

308
00:20:07,170 --> 00:20:10,366
Alice does these things, and at this part of the program over here, Bob does

309
00:20:10,388 --> 00:20:13,534
these things, and Alice is going to share this

310
00:20:13,572 --> 00:20:16,180
information and Bob is going to receive that.

311
00:20:17,510 --> 00:20:20,146
Rarely everyone is going to receive it, and then Bob is going CTO do this

312
00:20:20,168 --> 00:20:23,954
thing. And so when you write a reach

313
00:20:23,992 --> 00:20:27,630
program, it's almost like you're writing the Javascript of a play. You have

314
00:20:27,640 --> 00:20:31,414
this detached perspective where you say these people do these things, and you

315
00:20:31,452 --> 00:20:35,522
never explicitly have to manage or think about the state machine

316
00:20:35,666 --> 00:20:39,494
because the state machine is derived automatically from the

317
00:20:39,532 --> 00:20:42,598
interactions that are actually possible in your script.

318
00:20:42,774 --> 00:20:45,290
So by kind of an analogy,

319
00:20:45,710 --> 00:20:49,178
if you were to look at the rules of a board game, then the

320
00:20:49,184 --> 00:20:52,666
rules of the board game will say something like, oh, well, the white player does

321
00:20:52,688 --> 00:20:56,046
this, the black player does that, then the red player does these things,

322
00:20:56,068 --> 00:20:59,200
and here are the options that they can do, and it says what is possible.

323
00:20:59,810 --> 00:21:03,258
But if you were to take that rulebook and then try to

324
00:21:03,444 --> 00:21:07,102
make a concrete program that enforces those rules,

325
00:21:07,246 --> 00:21:11,806
it would be a major endeavor, which is why there's not sort of routinely

326
00:21:11,918 --> 00:21:15,794
digital versions of all board games. Essentially what reach is

327
00:21:15,912 --> 00:21:19,910
is it allows you to do that conversion process

328
00:21:19,980 --> 00:21:23,346
automatically, and that's what it does for you as part of its compiler.

329
00:21:23,458 --> 00:21:26,854
So it makes it so that you can ignore all of those low level

330
00:21:26,892 --> 00:21:30,242
details about how to set up your state machine,

331
00:21:30,306 --> 00:21:33,706
about how to verify that you're in the right state, how to set up the

332
00:21:33,728 --> 00:21:37,126
transition functions, how to worry about what the stap

333
00:21:37,238 --> 00:21:40,380
depth is. It does all of those things for you.

334
00:21:40,770 --> 00:21:44,080
But this is just talking about the

335
00:21:44,450 --> 00:21:48,350
level of abstraction that reach provides.

336
00:21:48,850 --> 00:21:52,382
Blockchain programmers are not only programming at a very low level,

337
00:21:52,436 --> 00:21:55,518
they're also programming something that is very, very complicated.

338
00:21:55,614 --> 00:22:00,850
In particular, they're using some of the most complicated things

339
00:22:00,920 --> 00:22:04,814
in programming. So what I mean by that is that

340
00:22:04,952 --> 00:22:08,278
there's a complex tool, which is a

341
00:22:08,284 --> 00:22:11,714
low level programming language like assembly or c or solidity,

342
00:22:11,842 --> 00:22:15,480
and then there is a complex domain. So as an example,

343
00:22:20,910 --> 00:22:24,922
if you're programming a picture breaking site,

344
00:22:25,056 --> 00:22:28,406
then this is a relatively simple domain. But if you're

345
00:22:28,438 --> 00:22:32,842
programming a picture editing

346
00:22:32,906 --> 00:22:35,918
suite, then this is a very complicated woman because you

347
00:22:35,924 --> 00:22:39,854
have to deal with all sorts of complicated ideas like, I don't know,

348
00:22:39,972 --> 00:22:43,486
gaussian blurs and retouching and contrast.

349
00:22:43,518 --> 00:22:47,294
So you have to learn about all sorts of intricate

350
00:22:47,342 --> 00:22:50,894
algorithms that correspond CTO, the domain

351
00:22:50,942 --> 00:22:55,018
that you're working in. And traditionally, blockchain programs

352
00:22:55,054 --> 00:22:57,350
are also using a complex domain.

353
00:22:57,850 --> 00:23:00,322
They integrate things like cryptography,

354
00:23:00,466 --> 00:23:04,146
where it's very common for blockchain programmers

355
00:23:04,258 --> 00:23:08,010
to have to have an intuitive grasp about

356
00:23:08,080 --> 00:23:12,630
things like private keys and signatures

357
00:23:12,710 --> 00:23:14,890
and producing hash functions.

358
00:23:20,370 --> 00:23:24,334
And that's because the low

359
00:23:24,372 --> 00:23:27,994
level languages that are typically associated with blockchain don't

360
00:23:28,042 --> 00:23:33,246
support the creation of a

361
00:23:33,268 --> 00:23:37,650
wide variety of libraries that deal with these things because

362
00:23:37,800 --> 00:23:41,410
they're basically focused on just like a different

363
00:23:41,480 --> 00:23:44,578
level of the problem. And so one of the things that we try to

364
00:23:44,584 --> 00:23:47,814
do in reach is we try to make it so that all of

365
00:23:47,852 --> 00:23:51,778
the key ideas in cryptography that are relevant

366
00:23:51,794 --> 00:23:55,826
to blockchain programming are described based on their features,

367
00:23:55,938 --> 00:23:59,066
not on their implementation. Let me just

368
00:23:59,088 --> 00:24:03,418
give you a tiny example of this. Something that shows up a lot in

369
00:24:03,584 --> 00:24:06,714
blockchain programming is that two people

370
00:24:06,752 --> 00:24:09,690
would like to share something simultaneously.

371
00:24:10,130 --> 00:24:14,000
Well, sharing something simultaneously is not possible on

372
00:24:16,130 --> 00:24:19,694
an actual network because one person is going to do

373
00:24:19,732 --> 00:24:23,166
something first. And if I want to share something, if we

374
00:24:23,188 --> 00:24:26,786
want to share something at the same time, then I

375
00:24:26,808 --> 00:24:29,858
could just wait for you to share it, read what you do,

376
00:24:29,944 --> 00:24:33,780
and then have my action be based on what you did.

377
00:24:35,130 --> 00:24:38,918
So the problem of simultaneity is a

378
00:24:38,924 --> 00:24:42,166
problem with computer networks. Well, cryptography has

379
00:24:42,188 --> 00:24:46,546
a solution for this, which is that we can break a simultaneous

380
00:24:46,658 --> 00:24:50,330
sharing into three steps. I share something

381
00:24:50,400 --> 00:24:54,534
secretly, you share something publicly, and then I reveal

382
00:24:54,582 --> 00:24:56,650
what I secretly decided earlier,

383
00:24:58,270 --> 00:25:01,882
since I have to share what I did first, secretly. That means

384
00:25:01,936 --> 00:25:04,880
that what I do cannot be based on what you did,

385
00:25:05,570 --> 00:25:08,766
since you have to share it before I do something,

386
00:25:08,868 --> 00:25:11,486
before I make it public. That means what you do can't be based on what

387
00:25:11,508 --> 00:25:16,110
I did. Therefore, we had CTO have made the decision simultaneously,

388
00:25:16,190 --> 00:25:19,506
even though we do not actually share it simultaneously. So this is

389
00:25:19,528 --> 00:25:23,106
called the cryptographic commitment pattern, and there's all sorts of interesting

390
00:25:23,208 --> 00:25:27,106
ideas about how to realize this on particular crypto networks.

391
00:25:27,218 --> 00:25:31,240
But in the reach programming language we simply have

392
00:25:31,770 --> 00:25:35,414
the make commitment and check commitment as

393
00:25:35,612 --> 00:25:39,190
concepts in the language. Another example

394
00:25:39,260 --> 00:25:42,722
of something that is complicated about cryptography is that

395
00:25:42,876 --> 00:25:46,042
complicated about blockchain programming is that to do

396
00:25:46,096 --> 00:25:50,034
blockchain programming you essentially have to be writing a concurrent

397
00:25:50,102 --> 00:25:53,294
program, a program that has to deal with the

398
00:25:53,412 --> 00:25:57,262
asynchronous sending and receiving of messages by

399
00:25:57,316 --> 00:26:01,200
many different parties, managing them as they code and go.

400
00:26:02,050 --> 00:26:05,822
And this is of course one of the most notoriously difficult things to

401
00:26:05,876 --> 00:26:09,294
program about. And I think of that actually, as you and I, as JavaScript

402
00:26:09,342 --> 00:26:12,926
programmers, we're some of the people who are most expert at this because we've

403
00:26:12,958 --> 00:26:16,606
been able to build promise libraries and

404
00:26:16,648 --> 00:26:20,550
many different concurrency primitives inside of our Javascript programs

405
00:26:20,970 --> 00:26:24,534
to deal with concurrency. And one of the things that reach does is

406
00:26:24,572 --> 00:26:28,570
it basically takes the Javascript model of concurrency and

407
00:26:28,640 --> 00:26:33,046
applies it to blockchain and covers

408
00:26:33,078 --> 00:26:37,254
over and abstracts all of the low level complexities

409
00:26:37,382 --> 00:26:40,886
that blockchain imposes with regards

410
00:26:40,918 --> 00:26:44,446
to concurrency. And a big part of that is that

411
00:26:44,548 --> 00:26:47,726
script participant based way of designing your program.

412
00:26:47,908 --> 00:26:51,754
So by saying that the way that my program works is that Alice

413
00:26:51,802 --> 00:26:55,614
does this, then Bob does this, and then we enter a phase where

414
00:26:55,732 --> 00:26:58,946
red and green can take turns doing something, or maybe they can do

415
00:26:58,968 --> 00:27:02,466
things simultaneously, and then when they're done it goes back and Alice does this other

416
00:27:02,488 --> 00:27:06,086
thing. And so by describing who can do what when and

417
00:27:06,108 --> 00:27:09,238
then deriving what the concurrent rules are

418
00:27:09,404 --> 00:27:13,590
for the programmer, we can greatly simplify their programming task.

419
00:27:14,170 --> 00:27:18,294
So these are two ways in which Reach provides

420
00:27:18,342 --> 00:27:22,234
these features, and the main tool that we use in

421
00:27:22,272 --> 00:27:25,718
reach to provide this is a compilation technique that's

422
00:27:25,734 --> 00:27:29,994
called Endpoint projection. Endpoint projection is

423
00:27:30,192 --> 00:27:34,058
a tool that I developed during my phd that's based on program slicing,

424
00:27:34,234 --> 00:27:38,190
where you take that JavaScript based program that has many

425
00:27:38,260 --> 00:27:42,026
perspectives simultaneously. And we split the program apart

426
00:27:42,058 --> 00:27:45,794
into a component for each actor. So as a

427
00:27:45,832 --> 00:27:48,926
simple example, imagine that you have a client server

428
00:27:48,958 --> 00:27:52,466
program where the client says a and then the

429
00:27:52,488 --> 00:27:54,994
server says b, and then the client says c.

430
00:27:55,192 --> 00:27:58,530
Well, you know that from this description,

431
00:27:58,690 --> 00:28:02,274
when the client says a, the server must expect to receive

432
00:28:02,322 --> 00:28:05,654
a, and if the server says b, then that means that the client must

433
00:28:05,692 --> 00:28:09,706
expect to receive b. So from a

434
00:28:09,728 --> 00:28:13,174
description that is detached, you can derive

435
00:28:13,302 --> 00:28:17,418
the component for each one of the participants where

436
00:28:17,504 --> 00:28:20,794
the actor who instigates something had

437
00:28:20,832 --> 00:28:24,254
sort of the active role and everyone else has a passive role. And we can

438
00:28:24,292 --> 00:28:28,234
generalize this idea to an arbitrary number of participants

439
00:28:28,362 --> 00:28:32,078
and an arbitrary number of actions, provided we have a way of defining what

440
00:28:32,084 --> 00:28:35,698
it means to be the, quote active person and the passive person.

441
00:28:35,864 --> 00:28:39,714
And so our compiler is based on this idea. All right,

442
00:28:39,752 --> 00:28:43,166
let's move on and talk about something else that's complex about blockchain programming,

443
00:28:43,278 --> 00:28:47,066
and that's that blockchain programming is inherently dangerous.

444
00:28:47,198 --> 00:28:50,358
Now when I say dangerous, I don't mean that it's like sharp and pointy and

445
00:28:50,364 --> 00:28:54,440
you're going to poke yourself. I mean that because a blockchain program

446
00:28:54,810 --> 00:28:58,650
is automatically providing access to

447
00:28:58,720 --> 00:29:02,458
something that is traditionally protected behind the

448
00:29:02,464 --> 00:29:06,454
scenes of a centralized server, for example, it's automatically providing

449
00:29:06,502 --> 00:29:10,546
access to a bank, bank funds, or it's automatically providing

450
00:29:10,598 --> 00:29:14,462
access to a database. That means that your blockchain program,

451
00:29:14,596 --> 00:29:18,190
if there is an error, you have now exposed the entire

452
00:29:18,340 --> 00:29:21,774
database to control by arbitrary people

453
00:29:21,812 --> 00:29:25,234
on the outside world. So imagine how bad an idea it would be

454
00:29:25,352 --> 00:29:31,586
if you and I could just log in to

455
00:29:31,608 --> 00:29:35,746
the redis database or to the DynamoDB

456
00:29:35,778 --> 00:29:38,966
database that manages Amazon. This would be a terrible idea because we

457
00:29:38,988 --> 00:29:42,822
could break things. So when you program

458
00:29:42,956 --> 00:29:46,694
on blockchain, you are basically doing that.

459
00:29:46,892 --> 00:29:50,006
But what the blockchain provides is

460
00:29:50,028 --> 00:29:53,366
not only does it provide access to the database in the ledger, but it provides

461
00:29:53,398 --> 00:29:56,858
access in a way that is constrained. So what I mean by that

462
00:29:56,944 --> 00:30:00,686
is that you can say that the only way that you're allowed to

463
00:30:00,708 --> 00:30:04,350
modify this database is if, for example, you only

464
00:30:04,420 --> 00:30:07,662
increment numbers. And so there's this field

465
00:30:07,716 --> 00:30:11,486
somewhere and anyone can change it, but they can only make

466
00:30:11,508 --> 00:30:15,090
it bigger. That would be an example of a really simple constraint

467
00:30:16,230 --> 00:30:20,020
that can be imposed on a blockchain program.

468
00:30:20,470 --> 00:30:24,514
But figuring out if you made the right constraints is

469
00:30:24,552 --> 00:30:27,842
very difficult. And you may have heard of a wide variety

470
00:30:27,986 --> 00:30:31,190
of attacks and losses that have code about

471
00:30:31,340 --> 00:30:34,694
because blockchain programs fail to do this

472
00:30:34,892 --> 00:30:38,886
correctly. So one category of those are losses

473
00:30:38,918 --> 00:30:42,666
of access, CTO funds. So because a blockchain program

474
00:30:42,768 --> 00:30:45,370
manages access to funds and a database,

475
00:30:45,950 --> 00:30:49,126
if the program enters a state where it will refuse

476
00:30:49,158 --> 00:30:52,558
to accept further messages, then that means all of

477
00:30:52,564 --> 00:30:56,046
the funds are completely inaccessible forever. Another thing

478
00:30:56,068 --> 00:30:59,834
that can happen is that there can just be an actual hack

479
00:30:59,882 --> 00:31:04,782
and loss where when you

480
00:31:04,836 --> 00:31:08,446
expected to only give away your money to Jay, but you accidentally

481
00:31:08,478 --> 00:31:12,546
made it. So you give away your money to Jay and Chris. And so

482
00:31:12,568 --> 00:31:16,040
that would be an example of a hack. The using is that

483
00:31:17,690 --> 00:31:21,174
blockchain programs, by their nature, are what's called

484
00:31:21,212 --> 00:31:25,046
immutable. You launch the program, and then you can't really update it because

485
00:31:25,148 --> 00:31:28,614
the program's source code and its compiled representation is

486
00:31:28,652 --> 00:31:32,186
like part of its identity. So what this means is

487
00:31:32,208 --> 00:31:35,414
that the risk of writing the wrong program is higher because you can't

488
00:31:35,462 --> 00:31:38,570
update the program later. Now,

489
00:31:38,640 --> 00:31:41,742
the way that people do this in practice is they use a tool

490
00:31:41,796 --> 00:31:45,710
that's called formal verification or verification.

491
00:31:46,130 --> 00:31:50,974
So, verification is a very straightforward idea because

492
00:31:51,012 --> 00:31:54,046
you're already doing it. When you write a program, you check to make sure

493
00:31:54,068 --> 00:31:57,186
that it works. There's a variety of ways that you can check

494
00:31:57,208 --> 00:32:01,250
to make sure your program works. You can write tests, you can write

495
00:32:01,320 --> 00:32:07,234
unit tests, you can write end to end tests. You can build experimental

496
00:32:07,282 --> 00:32:10,486
use cases that are like end CTO, end integration tests, or something like

497
00:32:10,508 --> 00:32:13,862
that. The problem with testing is that testing is,

498
00:32:13,916 --> 00:32:18,210
by definition, finite. So you either have written

499
00:32:18,290 --> 00:32:22,490
100 tests or 1000 or 10,000, but your program will be used

500
00:32:22,640 --> 00:32:25,930
in more situations than you could possibly test finitely.

501
00:32:26,830 --> 00:32:30,854
It is possible to do what's called property based testing, where, rather than writing

502
00:32:30,982 --> 00:32:34,534
a single test, you write a program that generates

503
00:32:34,582 --> 00:32:38,494
tests, but you can only run that program for a certain finite amount

504
00:32:38,532 --> 00:32:41,326
of time. So you only tested it for ten minutes, or you tested it for

505
00:32:41,348 --> 00:32:44,258
three days or something like that. But your program will actually be used in an

506
00:32:44,264 --> 00:32:47,774
infinite number of situations. The way that we typically

507
00:32:47,822 --> 00:32:51,538
do things in blockchain programming is

508
00:32:51,624 --> 00:32:55,794
by taking your program and turning it into a mathematical formula.

509
00:32:55,922 --> 00:32:59,106
And if that mathematical formula obeys some properties,

510
00:32:59,138 --> 00:33:01,730
then your program does or doesn't have an error.

511
00:33:01,890 --> 00:33:05,414
So maybe you have heard of

512
00:33:05,612 --> 00:33:08,994
gaussian elimination if you took, like, a linear algebra

513
00:33:09,122 --> 00:33:12,618
course when you were in college. But gaussian elimination is

514
00:33:12,624 --> 00:33:15,958
a really classic way of solving linear equations.

515
00:33:16,054 --> 00:33:19,446
So a linear equation would be something like x plus y is greater

516
00:33:19,478 --> 00:33:23,520
than ten, and three x plus three y

517
00:33:24,450 --> 00:33:28,238
is equal to, I don't know, 66 or

518
00:33:28,244 --> 00:33:31,418
something like that. I don't know if that's actually possible to solve.

519
00:33:31,594 --> 00:33:35,620
And then you can take this set of equations and solve it.

520
00:33:36,470 --> 00:33:40,626
Well, what formal verification basically does is

521
00:33:40,648 --> 00:33:43,794
it takes your program, turns it into a system

522
00:33:43,832 --> 00:33:47,830
of equations, and then tries to prove a property about those equations.

523
00:33:48,570 --> 00:33:51,254
One of the things that we do in reach is we make it so that

524
00:33:51,292 --> 00:33:54,534
your program is automatically turned into the system

525
00:33:54,572 --> 00:33:58,934
of equations. And we automatically prove

526
00:33:58,982 --> 00:34:02,534
that it does not have the hacking properties and the loss

527
00:34:02,582 --> 00:34:06,010
and the loss properties that we can guarantee that when your program

528
00:34:06,080 --> 00:34:09,786
runs, it will always obey certain

529
00:34:09,888 --> 00:34:13,454
basic properties that all blockchain programs should have. And we

530
00:34:13,492 --> 00:34:16,798
give a mechanism for you to add those to your program,

531
00:34:16,964 --> 00:34:19,806
add new unique ones to your program.

532
00:34:19,988 --> 00:34:23,498
So you can essentially write your program as if

533
00:34:23,524 --> 00:34:26,734
you were doing testing, as if you were doing property testing,

534
00:34:26,862 --> 00:34:31,054
and as if you were just including assertions

535
00:34:31,102 --> 00:34:34,526
in your code. But those assertions will not be complex

536
00:34:34,558 --> 00:34:38,134
into runtime checks. They will be compiled into compile time

537
00:34:38,172 --> 00:34:41,910
checks that will always be checked, or else your program will fail to compile.

538
00:34:42,490 --> 00:34:46,278
Now, Reach is providing this because

539
00:34:46,364 --> 00:34:49,030
it has that high weve way of programming.

540
00:34:49,690 --> 00:34:53,786
If you didn't have that high level way of programming and you just had the

541
00:34:53,888 --> 00:34:57,530
raw low level program, then you would actually need to create

542
00:34:57,600 --> 00:35:00,902
more artifacts. You would also need to create a state machine diagram.

543
00:35:00,966 --> 00:35:04,320
You would also need to create some sort of

544
00:35:04,930 --> 00:35:08,186
way of saying what paths through the state machine are valid.

545
00:35:08,298 --> 00:35:11,534
And then you would be proving properties relative to that

546
00:35:11,572 --> 00:35:14,786
state machine and relative to those properties. And so

547
00:35:14,808 --> 00:35:20,466
what this means is that doing verification is harder when

548
00:35:20,488 --> 00:35:24,322
you use one of the low level tools. And it's an optional step

549
00:35:24,376 --> 00:35:28,178
that you might not choose to do. And it's

550
00:35:28,194 --> 00:35:31,766
an optional step that you may not have the expertise to do. And so what

551
00:35:31,788 --> 00:35:35,906
this ultimately amounts to is that doing blockchain programming

552
00:35:36,098 --> 00:35:39,242
directly today without a high level language like reach,

553
00:35:39,296 --> 00:35:43,062
is very expensive. It's expensive because you need to have technical

554
00:35:43,126 --> 00:35:46,860
skills and expertise in using a low level program,

555
00:35:47,230 --> 00:35:51,354
programming in a complex domain, and being

556
00:35:51,392 --> 00:35:54,782
an expert in, say, formal verification. But what reach

557
00:35:54,836 --> 00:35:58,206
does is it removes all of these limitations. It makes it so that

558
00:35:58,228 --> 00:36:02,802
you can program at a high level of programming. You can program in

559
00:36:02,856 --> 00:36:06,434
a simplified woman, where we've produced abstractions that make

560
00:36:06,472 --> 00:36:10,274
sense for the domain, and you can program with a safety net

561
00:36:10,312 --> 00:36:12,770
that's guaranteeing that you're not making any mistakes.

562
00:36:15,830 --> 00:36:19,198
Another thing that happens with blockchain development that I

563
00:36:19,224 --> 00:36:22,454
feel that I need to talk about. It's not really a technical issue, but it

564
00:36:22,492 --> 00:36:26,486
is a relevant issue. And that is that blockchains tend to

565
00:36:26,508 --> 00:36:29,738
be very quote, tribal. Now what do I mean by that?

566
00:36:29,904 --> 00:36:34,330
Well, because each blockchain has its own cryptocurrency,

567
00:36:34,670 --> 00:36:38,058
there are basically people that have really bought into a particular

568
00:36:38,144 --> 00:36:41,754
cryptocurrency. So imagine that you have invested your life savings

569
00:36:41,802 --> 00:36:46,174
in JCoin and your

570
00:36:46,212 --> 00:36:49,050
friend invested their life savings in Chris Coin.

571
00:36:49,210 --> 00:36:52,554
Then regardless of whether or not JCoin or Chris Coin

572
00:36:52,602 --> 00:36:56,434
is actually better, or the J network, or the Chris network, or the

573
00:36:56,632 --> 00:37:00,562
know blockchain, you've already

574
00:37:00,616 --> 00:37:03,874
committed your assets to it. And so this means that you

575
00:37:03,912 --> 00:37:07,906
are going to support that chain hell or high water, and you're

576
00:37:07,938 --> 00:37:11,010
going to argue that all chains are terrible, all other chains are terrible,

577
00:37:11,090 --> 00:37:14,600
any limitations of the J chain are not so bad,

578
00:37:15,290 --> 00:37:19,130
and so on. And this is something that in fact

579
00:37:19,200 --> 00:37:22,730
actually happens right now with blockchain programming.

580
00:37:23,150 --> 00:37:26,870
And what's worse is that because each blockchain

581
00:37:26,950 --> 00:37:30,246
tends to have its own tools and low level languages.

582
00:37:30,438 --> 00:37:34,250
Earlier I mentioned solidity, and I'm not trying to pick on solidity.

583
00:37:34,330 --> 00:37:38,506
Solidity is just representative as the most popular way of doing blockchain programming

584
00:37:38,538 --> 00:37:42,526
right now. But there are a wide variety of other languages as well,

585
00:37:42,628 --> 00:37:45,982
and each one of them is basically tied to particular networks.

586
00:37:46,126 --> 00:37:49,906
And all of them are kind of,

587
00:37:50,088 --> 00:37:53,682
they're all cut from a very similar cloth, they're all low level, they all

588
00:37:53,736 --> 00:37:57,446
have, there's pros and cons to

589
00:37:57,468 --> 00:38:00,582
all of them. But those pros and cons are very

590
00:38:00,636 --> 00:38:04,150
hard to communicate about and collaborate on.

591
00:38:04,300 --> 00:38:08,322
Because the blockchain development community is not unified

592
00:38:08,386 --> 00:38:12,314
on the idea of blockchain. They tend to be focused on

593
00:38:12,352 --> 00:38:15,738
a particular network and a particular can in part because

594
00:38:15,824 --> 00:38:19,114
people's life savings are tied up in that

595
00:38:19,152 --> 00:38:23,006
particular cryptocurrency. One of the things that we try to do in reach

596
00:38:23,108 --> 00:38:26,602
is that when you program a reach program, you can actually compile

597
00:38:26,666 --> 00:38:30,846
to almost any back end blockchain platform.

598
00:38:31,028 --> 00:38:35,326
And so that allows people that are otherwise antagonistic

599
00:38:35,358 --> 00:38:39,074
to one another to collaborate, making reach

600
00:38:39,112 --> 00:38:43,054
programs and helping one another learn reach and learn blockchain ideas

601
00:38:43,182 --> 00:38:46,510
because they can communicate at this higher level of abstraction.

602
00:38:46,590 --> 00:38:49,734
And then of course when they go to deploy, they can deploy to whatever their

603
00:38:49,772 --> 00:38:53,606
favorite chain is. And so this is something that I think is a

604
00:38:53,708 --> 00:38:57,286
novel benefit to using a high level language like

605
00:38:57,308 --> 00:39:00,780
Reach, that we can eliminate some of that tribalism in the community.

606
00:39:02,110 --> 00:39:05,834
Now, in summary, I want to give you five take home points

607
00:39:05,872 --> 00:39:09,974
about Reach. When you program in Reach, you're programming in JavaScript syntax

608
00:39:10,022 --> 00:39:13,806
with something that is almost identical to JavaScript semantics. So if you are

609
00:39:13,828 --> 00:39:17,226
here at 42 as a JavaScript programmer,

610
00:39:17,338 --> 00:39:21,374
you basically already know Reach. The main thing that you need to learn

611
00:39:21,492 --> 00:39:25,806
is this high level semantics of orchestrating a decentralized

612
00:39:25,838 --> 00:39:29,346
computation. And that high level semantics is

613
00:39:29,528 --> 00:39:32,754
very similar to how you might currently think about

614
00:39:32,792 --> 00:39:36,626
doing client server programming. But rather than thinking about client server programming,

615
00:39:36,738 --> 00:39:40,342
you're using to be thinking about peer to peer programming of

616
00:39:40,476 --> 00:39:43,874
a wide variety of actors. Reach provides

617
00:39:43,922 --> 00:39:47,382
automatic formal verification that makes it so that you

618
00:39:47,436 --> 00:39:50,562
won't make mistakes. Or rather, if you do make mistakes,

619
00:39:50,626 --> 00:39:53,866
then Reach will catch you and make sure that those mistakes don't enter the

620
00:39:53,888 --> 00:39:57,606
final version of your program and put you and your assets, and your users assets

621
00:39:57,718 --> 00:40:01,258
at risk. Reach is blockchain agnostic,

622
00:40:01,354 --> 00:40:05,178
which means that we allow you to go above the tribalism

623
00:40:05,274 --> 00:40:09,166
that tends to exist in the blockchain world, and it

624
00:40:09,188 --> 00:40:14,990
makes it so that you can basically have diversification

625
00:40:15,330 --> 00:40:18,866
with regards to your expertise. Because if you go learn a

626
00:40:18,888 --> 00:40:22,878
low level tool and you learn that low level tool and the platform doesn't

627
00:40:22,894 --> 00:40:26,226
take off, then you just spent a lot of time and investment to gain some

628
00:40:26,248 --> 00:40:29,750
expensive skills that are not useful. But if you learn reach,

629
00:40:29,820 --> 00:40:33,458
then you'll be able to apply CTO whatever blockchain ends

630
00:40:33,474 --> 00:40:37,314
up being popular. Now finally, not only does reach have a javascript

631
00:40:37,362 --> 00:40:40,730
syntax for writing your reach program, but we actually provide

632
00:40:40,800 --> 00:40:44,410
a JavaScript based interface for interacting with your program.

633
00:40:44,560 --> 00:40:48,346
And this interface basically makes it so

634
00:40:48,368 --> 00:40:51,526
that reach integrates with any existing JavaScript library.

635
00:40:51,638 --> 00:40:55,322
If you look at our tutorial, we walk through building an automated

636
00:40:55,386 --> 00:40:59,518
test suite JavaScript program and then we take the exact same

637
00:40:59,604 --> 00:41:02,654
JavaScript program, sorry, the exact same reach program,

638
00:41:02,772 --> 00:41:06,046
the exact same JavaScript program, and then we just add some

639
00:41:06,068 --> 00:41:09,426
stuff around it to turn it not from an automated program, but turn into an

640
00:41:09,448 --> 00:41:12,882
interactive command line based one. And then we take that program

641
00:41:12,936 --> 00:41:16,822
and we adapt that to turn it into a web based program. And at no

642
00:41:16,876 --> 00:41:20,754
point in the transition from automated CTO interactive

643
00:41:20,882 --> 00:41:24,150
to web based do we have to introducing any new

644
00:41:24,300 --> 00:41:27,410
blockchain or reach ideas.

645
00:41:27,490 --> 00:41:31,434
Weve just applying normal JavaScript techniques. So our goal with

646
00:41:31,472 --> 00:41:35,434
Reach has been to make it so that any existing full

647
00:41:35,472 --> 00:41:39,466
stack developer has the expertise to get into the exciting world of

648
00:41:39,488 --> 00:41:43,310
blockchain and learn about how they can improve the programs

649
00:41:44,130 --> 00:41:48,206
and the features that their apps are providing by

650
00:41:48,308 --> 00:41:51,626
removing those trusted centralized parties, whether those trusted

651
00:41:51,658 --> 00:41:55,554
decentralized parties are providing payments or providing databases. If you want to get

652
00:41:55,592 --> 00:41:59,170
started with Reach then you should

653
00:41:59,240 --> 00:42:02,210
join our discord or read our documentation.

654
00:42:02,950 --> 00:42:06,802
Our documentation is at Docs Reach Sh and

655
00:42:06,856 --> 00:42:10,118
there you'll find a link to our discord server as well. When you

656
00:42:10,124 --> 00:42:13,654
join the discord server, be sure to introduce yourself as coming

657
00:42:13,692 --> 00:42:17,318
from Comp 42 and there will be lots of

658
00:42:17,324 --> 00:42:20,634
people there who will be excited to talk to you

659
00:42:20,672 --> 00:42:24,300
about why you're interested in blockchain and what you want to do with it.

660
00:42:24,830 --> 00:42:28,780
And when you go to our documentation, you'll see a very

661
00:42:29,390 --> 00:42:33,386
slow introductory tutorial that walks through the basic ideas of blockchain,

662
00:42:33,498 --> 00:42:37,470
the basic ideas of building and deploying and testing

663
00:42:37,890 --> 00:42:41,514
a reach program. If you try to learn blockchain programming

664
00:42:41,562 --> 00:42:44,878
some other way, you're going to have to learn low level tools. You're going to

665
00:42:44,884 --> 00:42:49,218
have to learn about exactly how to build a private test network for

666
00:42:49,384 --> 00:42:52,306
whatever chain you decide to use. You'll have to decide what chain to use.

667
00:42:52,408 --> 00:42:56,034
There's a lot of things that you need to do, but with Reach we've designed

668
00:42:56,082 --> 00:43:00,038
something that is a completely dockerized program where you're going to download a very

669
00:43:00,124 --> 00:43:03,686
small shell script and

670
00:43:03,708 --> 00:43:07,094
that is going to manage creating dev networks for you,

671
00:43:07,212 --> 00:43:10,930
compiling your programs, building test suites,

672
00:43:11,090 --> 00:43:14,262
integrating with existing tools like Reach,

673
00:43:14,396 --> 00:43:17,910
sorry, lines react or view and whatnot.

674
00:43:18,570 --> 00:43:22,094
So we're really excited to have you come and try

675
00:43:22,132 --> 00:43:26,554
out reach and start your journey into breaking into blockchain development.

676
00:43:26,682 --> 00:43:30,090
And I can't wait to talk to you on our discord.

677
00:43:30,250 --> 00:43:32,300
Thanks so much for your time today. Have a great day.

