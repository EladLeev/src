1
00:00:26,370 --> 00:00:30,258
Hi everybody. Thank you so much for joining into this presentation about secrets management.

2
00:00:30,354 --> 00:00:33,654
As you probably can tell, this is a pre recording and next to this we

3
00:00:33,692 --> 00:00:36,646
actually have a running discord server where you can find me to ask me any

4
00:00:36,668 --> 00:00:39,810
questions about this presentation or give me feedback.

5
00:00:39,890 --> 00:00:42,360
Shall we get started? Alright, let's go.

6
00:00:42,890 --> 00:00:46,626
Before we go to the actual content, a little bit about me I'm Jeroen Willemsen.

7
00:00:46,658 --> 00:00:50,310
I'm a security architect at Xebia and a Phil Stack developer.

8
00:00:51,330 --> 00:00:56,160
There's various ways you can reach out to me and I assemble all of those@allmylinks.com.

9
00:00:56,850 --> 00:01:00,222
One specific thing I would like to ask you is actually go over there

10
00:01:00,276 --> 00:01:04,010
and visit my trueq website where you can give me feedback about this presentation

11
00:01:04,090 --> 00:01:07,378
because I would really love to hear from you what you've thought of

12
00:01:07,384 --> 00:01:11,026
this presentation and how I can improve from this. That way

13
00:01:11,208 --> 00:01:14,562
I can learn from you in sharing knowledge and making it a better

14
00:01:14,616 --> 00:01:18,454
presentation next time. All right, thank you so much. Shall we get

15
00:01:18,492 --> 00:01:22,454
started? The major question that

16
00:01:22,652 --> 00:01:26,614
all of us possibly have faced already is can

17
00:01:26,652 --> 00:01:30,074
you keep a secret? Whether as children's playing together,

18
00:01:30,272 --> 00:01:33,430
whether it's growing towards becoming an adult,

19
00:01:33,590 --> 00:01:37,286
or when we joined information security or cybersecurity,

20
00:01:37,478 --> 00:01:40,986
because so many secrets were actually shared with us or

21
00:01:41,088 --> 00:01:44,010
shared on systems that we're maintaining or securing.

22
00:01:44,690 --> 00:01:48,174
Before we can actually start talking about how to do that and how to keep

23
00:01:48,212 --> 00:01:52,046
those secrets in a proper way, let's first quickly glance upon what type

24
00:01:52,068 --> 00:01:56,260
of secrets you might have. Of course,

25
00:01:56,630 --> 00:01:59,826
passwords are something that's always shared upon. Okay, this is

26
00:01:59,848 --> 00:02:03,566
a basic secret you should really secure, but there's so many more secrets

27
00:02:03,598 --> 00:02:06,978
out there. Think about your HMAC keys or your encryption keys.

28
00:02:07,074 --> 00:02:10,050
Think about your IM access keys for your cloud provider,

29
00:02:10,210 --> 00:02:14,178
QR codes that might allow you to access certain materials,

30
00:02:14,354 --> 00:02:17,538
your authentication links, your OTTP codes,

31
00:02:17,714 --> 00:02:21,210
your private signing key, your GPG key. There are so many different

32
00:02:21,280 --> 00:02:24,474
keys and passwords and different types of tokens that we should

33
00:02:24,512 --> 00:02:26,650
consider when we try to protect a secret.

34
00:02:27,950 --> 00:02:31,214
And now let's of course, as you can

35
00:02:31,252 --> 00:02:35,198
tell, all of these secrets can be pretty important

36
00:02:35,364 --> 00:02:39,246
and protecting those can be a very

37
00:02:39,348 --> 00:02:42,522
interesting experience because we can often see that as a journey.

38
00:02:42,586 --> 00:02:46,014
We start protecting them in one way. We learn from that and then we possibly

39
00:02:46,062 --> 00:02:48,850
have to change our strategy and how we protect these secrets.

40
00:02:49,910 --> 00:02:53,726
What we'd like to do is basically take you on a journey

41
00:02:53,918 --> 00:02:58,150
throughout various places where we see secrets being stored or shared

42
00:02:59,370 --> 00:03:02,822
and possibly somewhat secured. We'll start with

43
00:03:02,876 --> 00:03:06,406
secrets hard code application, go to configuration, then we'll move

44
00:03:06,428 --> 00:03:09,526
to containers, Docker containers that is.

45
00:03:09,548 --> 00:03:12,598
And then we'll talk a little bit about how secrets can be protected in pods

46
00:03:12,614 --> 00:03:16,442
or kubernetes the platform in this first place. And then we'll quickly

47
00:03:16,496 --> 00:03:20,166
touch upon things like a third party solution provider like Hashicorp fault.

48
00:03:20,278 --> 00:03:23,934
And last but not least, we'll talk about secrets being

49
00:03:23,972 --> 00:03:27,322
managed in AWS. As you can tell, this is a kubernetes

50
00:03:27,386 --> 00:03:31,390
driven talk a bit, but it doesn't really matter. I hope you'll

51
00:03:32,850 --> 00:03:36,382
find this an enjoyable presentation

52
00:03:36,446 --> 00:03:39,634
where you can basically learn from or in other ways get a little bit

53
00:03:39,672 --> 00:03:43,380
inspired about your own secrets management strategy. Shall we get started?

54
00:03:44,070 --> 00:03:47,330
Let's go. So the first one is basically secrets code.

55
00:03:48,390 --> 00:03:52,214
First of all, many people start laughing about that. Why do people have stuff hard

56
00:03:52,252 --> 00:03:55,894
coded? That should never happen. But what we often find ourselves in

57
00:03:55,932 --> 00:03:59,626
is that as a developer you try to prototype something into making it

58
00:03:59,648 --> 00:04:03,254
work. That prototype might actually need a certain password

59
00:04:03,302 --> 00:04:06,886
or whatever that's linked to some API being provided

60
00:04:06,918 --> 00:04:10,730
to make your prototype work. So what often happens first

61
00:04:10,800 --> 00:04:14,602
is that we just hard code over there and then we basically forget

62
00:04:14,666 --> 00:04:17,120
or don't find the time to clean that out.

63
00:04:17,970 --> 00:04:21,662
Notice that the code that's currently on the screen is in Java. All of our

64
00:04:21,716 --> 00:04:25,154
code is basically based on Java spring boot and anything beyond that.

65
00:04:25,192 --> 00:04:28,686
Basically. So here it is. Here's your public Java

66
00:04:28,718 --> 00:04:33,982
class called constants where we provide a public static stream password

67
00:04:34,126 --> 00:04:35,860
which has a certain value.

68
00:04:37,350 --> 00:04:41,106
Funny thing is that we often end up with discussions afterwards with

69
00:04:41,128 --> 00:04:44,278
developers saying hey, but this is running in the back end and nobody should be

70
00:04:44,284 --> 00:04:47,894
able to touch that. So why is hard coding a problem?

71
00:04:48,012 --> 00:04:50,300
We'll touch upon that a little bit later.

72
00:04:51,390 --> 00:04:56,342
Of course we can find various variants

73
00:04:56,406 --> 00:04:59,926
of how that is done. Another one is for instance where you use spring boot

74
00:04:59,958 --> 00:05:03,318
and you use certain annotations like the value annotation

75
00:05:03,414 --> 00:05:07,230
where you actually have then your application or properties, or another property

76
00:05:07,300 --> 00:05:10,558
file where you loaded the actual value of the secret in.

77
00:05:10,724 --> 00:05:14,206
Though this is not hard coded in the Java code directly, it's still in

78
00:05:14,228 --> 00:05:18,178
some sort of property files that's still committed to get next to the actual

79
00:05:18,264 --> 00:05:21,806
controller class where we put it in. So another hard coded

80
00:05:21,838 --> 00:05:25,782
secret. Luckily there is an easy

81
00:05:25,836 --> 00:05:28,994
way of overloading this into various other places which we'll

82
00:05:29,042 --> 00:05:32,854
cleanse upon a little bit later. But basically

83
00:05:32,972 --> 00:05:36,374
you'll easily find this type of secrets in

84
00:05:36,492 --> 00:05:40,106
your application code. Of course a way to override this

85
00:05:40,128 --> 00:05:43,786
is by using your docker container. So on the

86
00:05:43,968 --> 00:05:47,994
left over here you see our docker file where

87
00:05:48,032 --> 00:05:51,734
we have an argument based password and a environment

88
00:05:51,782 --> 00:05:55,502
based password and the argument based password has a default set. This can

89
00:05:55,556 --> 00:05:59,114
be changed and then we have an environment based password

90
00:05:59,162 --> 00:06:02,718
which says this is it. The nice thing is that when you basically build up

91
00:06:02,724 --> 00:06:06,538
the compatiner, you can use the arc based password to be overloaded

92
00:06:06,554 --> 00:06:09,794
as an argument, as a build argument. So you can, for instance, put something

93
00:06:09,832 --> 00:06:12,354
in like this is on my command line, as you can see here in the

94
00:06:12,392 --> 00:06:16,342
example below. And then you can compile a container or,

95
00:06:16,396 --> 00:06:19,830
sorry, build the container on the right hand side, you actually

96
00:06:19,900 --> 00:06:23,746
see how this could be consumed.

97
00:06:23,778 --> 00:06:28,022
So we have our arc based password and our docker anth password being

98
00:06:28,076 --> 00:06:31,542
loaded up as the values for

99
00:06:31,596 --> 00:06:35,130
the string arc based password and string hard coded NF password.

100
00:06:37,230 --> 00:06:40,442
This by itself already looks like, hey, but this is no longer really hard

101
00:06:40,496 --> 00:06:43,726
coding. It, is it now, because it's no longer in our Java classes or in

102
00:06:43,748 --> 00:06:46,766
our configuration stuff that's in code.

103
00:06:46,948 --> 00:06:50,222
Unfortunately, the M Docker password is still actually within

104
00:06:50,276 --> 00:06:53,522
the container. And what we'll also find out is that the build

105
00:06:53,576 --> 00:06:57,074
argument is also in the container. And that actually brings us

106
00:06:57,112 --> 00:07:00,402
to maybe having a short demo

107
00:07:00,456 --> 00:07:03,794
about this. We put all of these different

108
00:07:03,832 --> 00:07:08,002
samples in a project called Wrong Secrets, which has been created thanks

109
00:07:08,056 --> 00:07:11,846
to the lovely people Bendahan and Ana Byers together with

110
00:07:11,868 --> 00:07:15,430
me. And we're currently looking for new people that can help us out setting up

111
00:07:15,580 --> 00:07:19,138
more different type of secrets as well. So if you ever stumbled

112
00:07:19,154 --> 00:07:22,806
upon a funny way how a secret was stored within your company or somewhere

113
00:07:22,838 --> 00:07:26,362
else, get in touch with us. The wrong secrets project

114
00:07:26,416 --> 00:07:29,898
is basically a simple website, as you can see over here,

115
00:07:29,984 --> 00:07:33,246
where we provide various challenges where you have to

116
00:07:33,268 --> 00:07:37,646
put in, where you have to find the secret and basically put it in.

117
00:07:37,828 --> 00:07:41,310
This goes all the way from Docker secrets, kubernetes secrets and stuff

118
00:07:41,380 --> 00:07:42,750
stored in AWS.

119
00:07:44,610 --> 00:07:48,754
You find your challenges, you'll be able to get

120
00:07:48,792 --> 00:07:52,626
some scoring based on providing the solutions. And that way you can do

121
00:07:52,648 --> 00:07:55,170
your secrets hunts throughout these different challenges.

122
00:07:56,090 --> 00:07:59,318
But before we keep on

123
00:07:59,404 --> 00:08:03,320
talking about that, let's go into a little demo actually, shall we?

124
00:08:04,730 --> 00:08:09,002
So over here we actually see the system being

125
00:08:09,056 --> 00:08:13,034
started up. So we'll run a container locally with

126
00:08:13,072 --> 00:08:14,860
the first secrets loaded inside.

127
00:08:16,270 --> 00:08:27,254
We see the spring boot application being starting up and

128
00:08:27,292 --> 00:08:30,380
once it's started up, we want to go into the presentation actually.

129
00:08:32,430 --> 00:08:35,210
So let's go over to the first challenge,

130
00:08:36,590 --> 00:08:39,050
which is the hard coded password.

131
00:08:39,470 --> 00:08:42,638
So as you can tell, the question here is,

132
00:08:42,724 --> 00:08:46,254
can you find a hard code password? And if you just

133
00:08:46,292 --> 00:08:49,642
try something, you'll see it doesn't work. But let's go back to our presentation

134
00:08:49,706 --> 00:08:53,300
and take the default password that we found over there.

135
00:08:53,670 --> 00:08:57,506
So once it's copied, apologies, copy pasting was a bit

136
00:08:57,688 --> 00:09:01,300
of a problem during the pre recording over here.

137
00:09:01,670 --> 00:09:05,334
And let's put it in and say submit. That's the

138
00:09:05,372 --> 00:09:09,394
actual password, the one from the code. Let's do another challenge,

139
00:09:09,442 --> 00:09:12,950
shall we? So now one of the Docker based challenges,

140
00:09:14,650 --> 00:09:17,890
and let's take the actual arc based password.

141
00:09:18,050 --> 00:09:23,062
So let's currently put into the command line copying

142
00:09:23,126 --> 00:09:26,314
that in. Now going to the challenge, which is about

143
00:09:26,352 --> 00:09:29,760
that, and then putting it in,

144
00:09:30,290 --> 00:09:34,014
submitting it. And now the nice thing is that, well,

145
00:09:34,052 --> 00:09:37,406
this of course looks kind of unsolvable in the first place,

146
00:09:37,588 --> 00:09:40,750
but it actually isn't because you could actually

147
00:09:40,820 --> 00:09:44,722
find these secrets very easily. But before we run into that,

148
00:09:44,776 --> 00:09:48,034
let's go over and discuss a little bit of the troubles that we actually

149
00:09:48,072 --> 00:09:51,518
have here. First of all, we run into visibility

150
00:09:51,614 --> 00:09:55,102
problems. A lot of people can actually see the secrets

151
00:09:55,246 --> 00:09:58,786
because the secrets in your docker container are right now part of the docker

152
00:09:58,818 --> 00:10:02,806
layers that you can easily access, so you can tell what the actual values are.

153
00:10:02,908 --> 00:10:06,246
The secrets in code can also be easily accessed the moment you

154
00:10:06,268 --> 00:10:09,606
actually have access to git, or the moment you can download the container and decompile

155
00:10:09,638 --> 00:10:12,220
it, and then you can easily find the values inside.

156
00:10:13,550 --> 00:10:17,066
Apart from the visibility of the secret, we have a rotational issue.

157
00:10:17,168 --> 00:10:20,846
Because the moment you need to rotate a secret, for instance, a password to a

158
00:10:20,868 --> 00:10:24,398
certain API, and you rotated that at the API while

159
00:10:24,564 --> 00:10:26,960
still having to rotate it in your code,

160
00:10:27,570 --> 00:10:31,038
you'll run with an outdated password, possibly locking up the

161
00:10:31,044 --> 00:10:34,702
account at the API. Or worse, when you actually have variants of the code

162
00:10:34,756 --> 00:10:38,098
which do have the proper password, and variants of the code that do not have

163
00:10:38,104 --> 00:10:41,106
the proper password, we end up in problems as well.

164
00:10:41,288 --> 00:10:45,346
Then of course, there's reachability and authorization. Anybody who

165
00:10:45,368 --> 00:10:48,530
has access to the Docker container has access to the secrets.

166
00:10:48,610 --> 00:10:52,034
Anybody who has access to the code has access to the Java

167
00:10:52,082 --> 00:10:55,382
and the configuration secrets. That also inclines some

168
00:10:55,436 --> 00:10:59,034
sort of an authorization problem, because often the spread of

169
00:10:59,072 --> 00:11:03,180
how you can access this docker container is way beyond the actual

170
00:11:04,830 --> 00:11:08,694
amount of people that actually are allowed to actually see that secret or consume

171
00:11:08,742 --> 00:11:12,074
it. What possibly could happen as well? If you

172
00:11:12,112 --> 00:11:16,426
actually drill down the authorization part in terms of the Docker container registry,

173
00:11:16,538 --> 00:11:20,206
it could still be the case that an ex employee that still has the

174
00:11:20,228 --> 00:11:23,926
containers on his computer then shouldn't be authorized,

175
00:11:23,978 --> 00:11:27,202
but can still use those secrets to still gain access

176
00:11:27,256 --> 00:11:29,700
to the systems you should no longer be able to use.

177
00:11:30,230 --> 00:11:34,290
Then of course there's a problem of history, because given

178
00:11:34,360 --> 00:11:37,890
various instances of the Docker container and given various versions of the

179
00:11:37,960 --> 00:11:41,734
code in git, we actually capture every variant of the secrets, which sometimes

180
00:11:41,852 --> 00:11:45,366
actually makes it unfortunately a bit predictable what the next version of the

181
00:11:45,388 --> 00:11:49,482
secret might be. And then there's of course, the auditability problem.

182
00:11:49,616 --> 00:11:53,226
Can you actually tell who has access these secrets at

183
00:11:53,248 --> 00:11:57,094
which moment and from where? If somebody just downloads it container,

184
00:11:57,142 --> 00:12:00,886
of course you can't. Last but not least, we throughout

185
00:12:00,918 --> 00:12:04,382
this code actually have an identification challenge in terms of

186
00:12:04,436 --> 00:12:07,518
can you actually identify where the secrets were for in the first place?

187
00:12:07,604 --> 00:12:11,002
Because just shouting password or end based argument

188
00:12:11,066 --> 00:12:14,434
won't really help you to actually ascertain where the secret was used

189
00:12:14,472 --> 00:12:18,126
for. That even makes it harder if you want to clean this up and migrate

190
00:12:18,158 --> 00:12:21,842
it, because are we still using this password? And if so,

191
00:12:21,896 --> 00:12:25,794
what? For now, many people will say, let's use the beeping system by just

192
00:12:25,832 --> 00:12:29,206
wiping it out, and then possibly something goes wrong, which is our beep to say,

193
00:12:29,228 --> 00:12:32,726
hey, let's put it back in. Unfortunately, that can lead

194
00:12:32,748 --> 00:12:36,760
to very problematic solutions, so it's better to actually know what's happening.

195
00:12:37,450 --> 00:12:40,938
So how can we detect and prevent this? So for this, we actually have a

196
00:12:40,944 --> 00:12:44,474
bunch of open source tools that can help you. Two that are specifically easy

197
00:12:44,512 --> 00:12:48,374
to use are Trufflehawk and Dockle. Let's first go over to Trufflehawk.

198
00:12:48,502 --> 00:12:51,742
Trufflehawk allows you to basically scan code and

199
00:12:51,796 --> 00:12:55,246
find the secrets defined in that code. Over here you can

200
00:12:55,268 --> 00:12:59,534
see that trifleh nicely found our public string password and some

201
00:12:59,572 --> 00:13:02,686
static new key. Not sure what that is for yet, but for

202
00:13:02,708 --> 00:13:06,142
now at least, we found the password which

203
00:13:06,196 --> 00:13:09,886
actually will help you to try to do this secret

204
00:13:09,918 --> 00:13:13,426
hunting yourself for the wrong secrets project by trying this tool,

205
00:13:13,528 --> 00:13:16,760
and you'll actually find the answer to solution one and four.

206
00:13:17,370 --> 00:13:21,110
But more importantly, you can also run this tool at your own code base

207
00:13:21,180 --> 00:13:24,760
and see if there's any secrets leaked inside of the

208
00:13:26,490 --> 00:13:30,394
git repository. And then you can use stuff like BFG eight or other

209
00:13:30,432 --> 00:13:33,834
tools to actually nicely wipe that out. But be

210
00:13:33,872 --> 00:13:37,462
careful with rewriting history in git, it can become very hurtful,

211
00:13:37,526 --> 00:13:41,498
so make sure you have a backup standing by. But that's

212
00:13:41,514 --> 00:13:45,310
only just for the git. Decoding git. How about your container for that?

213
00:13:45,380 --> 00:13:49,070
Tools like dockle can help. Dockle will easily identify certain

214
00:13:49,140 --> 00:13:52,078
suspicious end keys found like they found over here.

215
00:13:52,164 --> 00:13:57,246
Arcbase password Dockerf password. So these type of warnings

216
00:13:57,278 --> 00:14:01,374
or errors or fatals should actually help you to identify certain environment

217
00:14:01,422 --> 00:14:05,574
variables that you might not want to trust. So that

218
00:14:05,612 --> 00:14:08,550
basically covered the first part of the docker containers.

219
00:14:09,290 --> 00:14:11,160
So did we detect everything?

220
00:14:12,570 --> 00:14:16,326
Maybe you want to try decided wrong secrets and

221
00:14:16,348 --> 00:14:19,818
see if we detected really everything, or whether there's still secrets left inside

222
00:14:19,904 --> 00:14:23,334
that we kept there. Maybe not even used anymore in the current version.

223
00:14:23,462 --> 00:14:27,770
But you can at least understand that these tools don't cover everything because

224
00:14:27,840 --> 00:14:30,426
secrets can be moved to caps,

225
00:14:30,458 --> 00:14:34,206
concatenated, encoded, enriched with funny salts or

226
00:14:34,228 --> 00:14:38,366
whatever in the naming to make it harder to be detected by SAS tools or

227
00:14:38,388 --> 00:14:42,202
just actually be encrypted with another key that's harder to detect,

228
00:14:42,346 --> 00:14:45,618
for which the key can actually still be at the same site as

229
00:14:45,704 --> 00:14:49,554
within the docker container, within the source control. So for this

230
00:14:49,592 --> 00:14:52,894
there's a bunch of tools you could try out, like CoQl and GitHub

231
00:14:52,942 --> 00:14:56,430
or Trufflehawk or many other tools. And I would really encourage you to

232
00:14:56,440 --> 00:14:59,878
try those different tools out, like your own repository, and see if you

233
00:14:59,884 --> 00:15:02,950
can actually find stuff you shouldn't or didn't want to commit.

234
00:15:03,690 --> 00:15:06,806
Knowing what you know right now so

235
00:15:06,828 --> 00:15:10,618
much about code and containers, it's pretty clear that that's not the

236
00:15:10,624 --> 00:15:14,186
direction to go. So what about Kubernetes configuration maps? So over

237
00:15:14,208 --> 00:15:18,006
here, the right hand side, you can see config map definitions with some funny

238
00:15:18,038 --> 00:15:21,886
data entry where we actually have a secret hidden for you. So this

239
00:15:21,908 --> 00:15:26,026
is not in code of the app, but config mobs are often committed

240
00:15:26,058 --> 00:15:28,906
to git, so therefore it's still hard coded in a repository.

241
00:15:29,098 --> 00:15:32,714
And config maps by default are easily accessible unless

242
00:15:32,762 --> 00:15:35,966
you really start doing your AbEC or RBAC

243
00:15:35,998 --> 00:15:39,426
correctly. That means you need to set up additional configuration for your

244
00:15:39,448 --> 00:15:43,982
Kubernetes cluster, which is often pretty challenges

245
00:15:44,046 --> 00:15:45,970
if you don't think it through properly.

246
00:15:47,830 --> 00:15:51,522
By default, config marks are not encrypted and they're just in the storage

247
00:15:51,666 --> 00:15:55,622
called ETCD by default. And if you want to secure that,

248
00:15:55,676 --> 00:15:59,500
you still have to start encrypting eTCD, which requires additional work.

249
00:16:00,110 --> 00:16:03,738
And over here you can really recommend to put some metadata in.

250
00:16:03,824 --> 00:16:06,982
That's actually something you can put in there easily.

251
00:16:07,046 --> 00:16:10,822
You already see some metadata, but luckily you can add additional

252
00:16:10,966 --> 00:16:14,430
free fields as well locally where you can actually identify where this

253
00:16:14,580 --> 00:16:17,630
secret is for. So migration comes a little bit easier.

254
00:16:18,130 --> 00:16:21,166
If you want to know a bit more about this or try this out and

255
00:16:21,188 --> 00:16:24,610
see how this could possibly go wrong, please try challenge number

256
00:16:24,680 --> 00:16:27,380
five of the wrong secrets application.

257
00:16:28,230 --> 00:16:30,850
So config maps are really not the way to go.

258
00:16:31,000 --> 00:16:34,820
Kubernetes secrets have been actually created to do this

259
00:16:35,270 --> 00:16:38,726
with the single purpose of holding a secret on the

260
00:16:38,748 --> 00:16:42,882
right hand side. Again, an example of a Kubernetes secret.

261
00:16:42,946 --> 00:16:46,194
The nice thing is, as you can see at the data and the variable funnier,

262
00:16:46,242 --> 00:16:49,786
which is holding a secret that by default all of these secrets are base

263
00:16:49,808 --> 00:16:52,954
64 encoded, which means that it becomes very

264
00:16:52,992 --> 00:16:55,500
easy to actually put something encrypted over there.

265
00:16:56,510 --> 00:17:00,694
And the nice thing is that it's really making sense because isolating

266
00:17:00,742 --> 00:17:04,478
secrets makes sense in terms of files and using your abaC or

267
00:17:04,484 --> 00:17:08,046
RBEC correctly and making sure that this Kubernetes secret can only be

268
00:17:08,068 --> 00:17:11,860
used in the namespace by the services that actually require it.

269
00:17:12,790 --> 00:17:16,302
That still requires quite some effort, but it becomes easier

270
00:17:16,366 --> 00:17:19,954
to think of it in the ways that you are

271
00:17:20,152 --> 00:17:24,334
recommended to by the people behind Kubernetes secrets

272
00:17:24,382 --> 00:17:27,870
can be encrypted, but that's again a bit challenging if it comes to, for instance,

273
00:17:27,950 --> 00:17:32,070
key lifecycle and other stuff that happens within protecting it properly.

274
00:17:32,410 --> 00:17:35,762
And the problem is still when your kubernetes cluster

275
00:17:35,826 --> 00:17:39,206
is compromised, it's still easy to obtain the secret

276
00:17:39,238 --> 00:17:42,730
then, which basically means that

277
00:17:42,800 --> 00:17:46,458
you have to secure your cluster in a proper way and that you continuously have

278
00:17:46,464 --> 00:17:49,562
to audit it for making sure that there's no easy step

279
00:17:49,616 --> 00:17:53,658
up from compromising a pod all the way to its secret,

280
00:17:53,834 --> 00:17:57,486
or secrets from other pods for that matter. And of course

281
00:17:57,508 --> 00:18:00,894
we still have our identification rotation and expiry challenges because

282
00:18:00,932 --> 00:18:04,370
we have to make sure that the secret itself actually contains the right value,

283
00:18:04,440 --> 00:18:08,082
that we have enough metadata inside that we know where the secret is for,

284
00:18:08,216 --> 00:18:12,094
and that the moment that the secret expires, that we do update our Kubernetes

285
00:18:12,142 --> 00:18:15,634
secrets. That sounds already a bit

286
00:18:15,672 --> 00:18:20,066
easier than having stuff directly in code because given the

287
00:18:20,088 --> 00:18:23,574
whole rbug abug, we can actually solve the authorization problem. We can have proper

288
00:18:23,612 --> 00:18:27,238
access logging in place so we know who actually visited the secret. So there's a

289
00:18:27,244 --> 00:18:30,646
lot we can do with this, which makes this a great basis for your secrets

290
00:18:30,678 --> 00:18:34,406
management in the first place. Given all the errors

291
00:18:34,438 --> 00:18:37,642
you can make. I would like to invite you to try challenge six

292
00:18:37,696 --> 00:18:40,974
from the wrong secrets project, where you can see how easily you can mess this

293
00:18:41,012 --> 00:18:44,874
up. So if you want to stick to kubernetes secrets,

294
00:18:45,002 --> 00:18:48,960
make sure you configure airbug. Well, that means

295
00:18:49,890 --> 00:18:53,454
you lose your list privileged principle. Make sure people just

296
00:18:53,492 --> 00:18:56,946
can't access secrets directly. Make sure that services

297
00:18:57,048 --> 00:19:00,514
can only run the namespace they're designed to and make sure that

298
00:19:00,712 --> 00:19:04,020
pods only are in the place that they really need to be.

299
00:19:04,630 --> 00:19:07,894
And on top of that, make sure that secrets can only be

300
00:19:07,932 --> 00:19:11,542
accessed by those entities that actually consume or produce them and nothing

301
00:19:11,596 --> 00:19:15,190
else. Have your secrets metadata in place

302
00:19:15,260 --> 00:19:18,758
so it becomes easier to migrate this towards some other solution because

303
00:19:18,844 --> 00:19:21,782
everything in it of course is a bit in flux.

304
00:19:21,926 --> 00:19:25,626
And when you actually migrate away from a certain app that

305
00:19:25,648 --> 00:19:28,614
you need a secret for that, you know that you can ditch this specific secret

306
00:19:28,662 --> 00:19:31,962
because you know it's related to this API. Make sure that your

307
00:19:32,016 --> 00:19:35,694
basic storage called ECD is encrypted. Make sure that you

308
00:19:35,732 --> 00:19:39,274
actually enforce a string and security context with emission controllers.

309
00:19:39,322 --> 00:19:42,766
Or if you're still an older version of kubernetes, have psps in

310
00:19:42,788 --> 00:19:45,902
place to make sure that whenever a pod is compromised,

311
00:19:45,966 --> 00:19:49,714
it doesn't mean that the worker code gets compromised immediately, or that

312
00:19:49,752 --> 00:19:53,298
it's easy to do other type of lateral movement towards other secrets than those

313
00:19:53,384 --> 00:19:55,990
that should have been exposed to the compromised pod.

314
00:19:56,970 --> 00:19:59,942
Harden your worker nodes. That's very important.

315
00:20:00,076 --> 00:20:03,442
But I don't want to make this a presentation about hardening Kubernetes.

316
00:20:03,586 --> 00:20:07,146
There are plenty of beautiful resources out there to watch out for.

317
00:20:07,248 --> 00:20:10,826
Please just google them and you'll find your way. And if

318
00:20:10,848 --> 00:20:14,746
you can automate the rotation of your secrets, make sure they

319
00:20:14,768 --> 00:20:18,362
don't get steeled. Last but not least,

320
00:20:18,416 --> 00:20:21,334
have regular security validations of your complete setup.

321
00:20:21,462 --> 00:20:25,054
Your secrets are the diamonds in your cluster, and at some

322
00:20:25,092 --> 00:20:28,366
point they're just the key to the other diamonds in your cluster, which is

323
00:20:28,388 --> 00:20:31,630
the actual data that we're trying to protect. All right,

324
00:20:31,700 --> 00:20:35,006
so much for Kubernetes secret. A lovely place to be in, a lovely

325
00:20:35,038 --> 00:20:38,322
place to work with, with some challenges that can actually be quite

326
00:20:38,376 --> 00:20:42,020
well managed. How about third party providers like

327
00:20:42,630 --> 00:20:45,826
Iccorp fault? So here you can see a little bit of an example of an

328
00:20:45,848 --> 00:20:49,974
iccorp fault setup. And before we go into details over

329
00:20:50,012 --> 00:20:53,478
how isucopa fault works, let's just go over a few of the things that it

330
00:20:53,484 --> 00:20:56,514
can do for you. It can do secret management where it can manage your static

331
00:20:56,562 --> 00:20:59,994
secrets or dynamic secrets that can easily be changed. It actually

332
00:21:00,032 --> 00:21:03,740
has credentials as a service we can configure backend to

333
00:21:05,310 --> 00:21:10,102
connect to it. For instance, you can use your database

334
00:21:10,246 --> 00:21:14,506
secrets backend with which you can let vault create temporal

335
00:21:14,538 --> 00:21:17,978
credentials for users of that database.

336
00:21:18,074 --> 00:21:21,274
There's a PKI provider packed in it. There is an encryption as a service.

337
00:21:21,332 --> 00:21:22,690
If a transit backend,

338
00:21:24,150 --> 00:21:27,342
the secrets by itself are versioned. There is a huge auditing

339
00:21:27,406 --> 00:21:30,658
system involved which allows it, which allows it

340
00:21:30,744 --> 00:21:34,422
to make it, which makes it very easy

341
00:21:34,476 --> 00:21:35,240
to basically,

342
00:21:40,810 --> 00:21:44,546
which makes it very easy to see what has happened with the vault secrets

343
00:21:44,578 --> 00:21:48,566
backend in the first place. Which makes it

344
00:21:48,588 --> 00:21:52,042
very easy to see what has happened with the vault in the first place.

345
00:21:52,096 --> 00:21:56,070
And you can seal the vault, which basically means nothing goes in or out anymore.

346
00:21:56,150 --> 00:21:59,566
So you can first resolve the security issue you're having and then move

347
00:21:59,588 --> 00:22:03,322
ahead again. So how does it authenticate users?

348
00:22:03,466 --> 00:22:07,866
So one way to do that is basically for a user to authenticate

349
00:22:07,898 --> 00:22:11,166
with LDOP credentials through vault, which then goes to

350
00:22:11,188 --> 00:22:13,998
your actual identity provider and verifies those credentials.

351
00:22:14,094 --> 00:22:17,410
And based on that, it basically attaches policy to a token,

352
00:22:17,830 --> 00:22:21,490
which is then returned to a user for which it can do various actions.

353
00:22:22,070 --> 00:22:25,666
Something similar can happen on a pod running on Kubernetes,

354
00:22:25,778 --> 00:22:29,446
for instance. A pod basically is deployed with

355
00:22:29,468 --> 00:22:32,758
a service account token, which is an offer to the

356
00:22:32,764 --> 00:22:35,954
application. The application can then authenticate the watch fault

357
00:22:36,002 --> 00:22:39,786
using the service account token, which then in return

358
00:22:39,888 --> 00:22:43,462
is validated by vault by asking the Kubernetes

359
00:22:43,526 --> 00:22:46,922
API, hey, is this token okay? Can we really move ahead with this?

360
00:22:47,056 --> 00:22:50,602
And based on that, vault returns a token that

361
00:22:50,656 --> 00:22:54,654
the application can then use to from there onward start

362
00:22:54,692 --> 00:22:56,030
consuming secrets.

363
00:22:57,410 --> 00:23:00,782
Hold on. So right now we used vault multiple times

364
00:23:00,836 --> 00:23:04,094
as something in the mean to manage secrets.

365
00:23:04,142 --> 00:23:07,998
How does this pattern work in general? So this doesn't

366
00:23:08,014 --> 00:23:11,618
just apply to hashicopfall, but to quite some secrets management services

367
00:23:11,704 --> 00:23:15,926
in the first place. Also for those in the cloud, basically we

368
00:23:15,948 --> 00:23:19,382
have a consumer of a solution that could be your service that

369
00:23:19,436 --> 00:23:22,614
requires a password or an access key

370
00:23:22,652 --> 00:23:26,598
towards a database. Then we have a solution that requires authentication.

371
00:23:26,694 --> 00:23:29,450
For instance that given database,

372
00:23:30,030 --> 00:23:33,846
the main secret management solution basically provides

373
00:23:33,878 --> 00:23:37,594
the authentication means towards the consumer of the solution to

374
00:23:37,792 --> 00:23:41,562
let it authenticate towards the solution that requires that authentication

375
00:23:41,626 --> 00:23:45,946
in the first place. That is often done by providing

376
00:23:45,978 --> 00:23:49,790
temporal credentials set up by the main secret management solution. At the solution

377
00:23:50,130 --> 00:23:53,634
requiring outsourcing into the database gets a temporal role which

378
00:23:53,672 --> 00:23:56,210
can then be provided back towards the consumer.

379
00:23:57,110 --> 00:24:00,590
But in order to do that, the main secrets management solution

380
00:24:00,670 --> 00:24:04,734
needs some sort of temp credential solution that's

381
00:24:04,782 --> 00:24:08,530
based on a longer living credential.

382
00:24:08,690 --> 00:24:12,358
Because if you want to create new temporal comes for the consumer of

383
00:24:12,364 --> 00:24:15,938
the database, that means that you as a secrets provider need to

384
00:24:15,964 --> 00:24:19,194
have a longer living credential living at the

385
00:24:19,232 --> 00:24:22,250
actual database in order to create those various rules.

386
00:24:23,950 --> 00:24:28,022
So yes, we can easily now rotate secrets

387
00:24:28,086 --> 00:24:31,150
for the consumer of the database,

388
00:24:31,970 --> 00:24:35,114
but it gets a bit harder to rotate those secrets

389
00:24:35,162 --> 00:24:40,126
for the actual database itself, then of course the

390
00:24:40,148 --> 00:24:44,434
main secret solution itself, for instance, vault or your

391
00:24:44,472 --> 00:24:48,066
cloud provider has its own access keys as

392
00:24:48,088 --> 00:24:51,650
well, which are required to create users.

393
00:24:52,390 --> 00:24:56,266
For that, you basically need a secondary secrets management solution

394
00:24:56,398 --> 00:25:00,162
that will hold the root credentials for your main system. Because otherwise,

395
00:25:00,226 --> 00:25:04,070
if everything breaks down at your main secrets management solution system,

396
00:25:04,220 --> 00:25:08,470
there's no way to access it anymore if you don't have comes break loss procedure.

397
00:25:08,630 --> 00:25:12,860
Therefore, we now ended up with two secret management solutions in the first place.

398
00:25:13,550 --> 00:25:17,066
All right, don't forget about that. And again,

399
00:25:17,168 --> 00:25:20,826
there it holds. Make sure you can easily spot

400
00:25:20,858 --> 00:25:24,286
how it's been used, by who it's been used, that it's auditable, that you can

401
00:25:24,308 --> 00:25:28,510
rotate the secrets inside the secondary secrets management solution.

402
00:25:29,570 --> 00:25:32,914
But enough to think of

403
00:25:32,952 --> 00:25:36,482
in the future, let's see how we can actually use

404
00:25:36,536 --> 00:25:39,938
vault, shall we? So here we have a short demo

405
00:25:40,024 --> 00:25:43,714
of the key value backend being used

406
00:25:43,752 --> 00:25:47,862
by the Java spring boot cloud application where

407
00:25:47,916 --> 00:25:52,182
we basically have a vault password that

408
00:25:52,236 --> 00:25:55,462
we want to obtain using a lot of different

409
00:25:55,516 --> 00:25:59,020
auto configuration parts. Shall we take a short demo?

410
00:26:00,910 --> 00:26:03,994
So if you look at the wrong secrets repository, you can basically see

411
00:26:04,032 --> 00:26:07,290
how to start this up. But let's just after

412
00:26:07,360 --> 00:26:11,538
a script has been fully started, you see that there's the secrets

413
00:26:11,574 --> 00:26:15,502
challenge application being launched. And at 8200

414
00:26:15,556 --> 00:26:19,390
we export. We actually have vault running or listening

415
00:26:19,970 --> 00:26:23,860
for you to sign in. Now here in the vault administration back end

416
00:26:24,310 --> 00:26:25,890
or management.

417
00:26:34,230 --> 00:26:37,666
So as you can see over here we actually have the secret

418
00:26:37,698 --> 00:26:41,702
management solution running. And at port number 8200 we also

419
00:26:41,756 --> 00:26:45,314
have the port exposed for vault

420
00:26:45,442 --> 00:26:50,426
where you can actually go into the

421
00:26:50,448 --> 00:26:53,786
administration. There you can see that there

422
00:26:53,808 --> 00:26:57,446
is a secret created and there's Kubernetes

423
00:26:57,638 --> 00:27:00,480
authentication configured as well.

424
00:27:02,450 --> 00:27:05,742
So we have comes basic default configuration set up over here.

425
00:27:05,796 --> 00:27:10,222
And there's a secret challenge application role which can access

426
00:27:10,356 --> 00:27:13,646
certain secrets. Then on

427
00:27:13,668 --> 00:27:17,426
the policy to basically make sure that that role can access that stuff,

428
00:27:17,608 --> 00:27:21,822
we allow the secret challenge to read two different paths

429
00:27:21,886 --> 00:27:25,506
where we basically store your secrets. On that path,

430
00:27:25,538 --> 00:27:29,158
the secret challenges path you can find a full password which has a

431
00:27:29,164 --> 00:27:30,040
given value.

432
00:27:32,570 --> 00:27:35,826
Then once we

433
00:27:35,868 --> 00:27:39,878
take this value note

434
00:27:39,894 --> 00:27:43,702
it's base 64 encoded.

435
00:27:43,766 --> 00:27:46,890
And this is actually an old version of the secrets

436
00:27:47,390 --> 00:27:50,654
challenge app when we used it for our

437
00:27:50,692 --> 00:27:55,646
all day DevOps talk from code to vault and

438
00:27:55,668 --> 00:27:59,642
then we submitted over there you can see, hey, that's the correct solution.

439
00:27:59,786 --> 00:28:01,890
Basically the raw entry in vault,

440
00:28:04,150 --> 00:28:08,242
as you can tell over here there's the deployment and then here

441
00:28:08,296 --> 00:28:12,722
there's some bunch of bootstrap properties and

442
00:28:12,776 --> 00:28:16,434
the actual configuration

443
00:28:16,482 --> 00:28:20,486
code required to put it in. Note that

444
00:28:20,508 --> 00:28:23,670
this is already a bit older, but over you can see we use the service

445
00:28:23,740 --> 00:28:27,238
account token to authenticate towards a given vault instance. As you

446
00:28:27,244 --> 00:28:30,886
can see, you can also use the vault token to directly authenticate

447
00:28:30,918 --> 00:28:34,154
the word vault, but that's something I really don't recommend. Make sure

448
00:28:34,192 --> 00:28:37,100
you actually leverage what Kubernetes offers you over there.

449
00:28:43,690 --> 00:28:47,480
And for now, for the sake of time, let's move ahead a little bit

450
00:28:48,170 --> 00:28:51,480
more of it will be explained at the wrong secrets project itself.

451
00:28:52,010 --> 00:28:57,398
The nice thing, because the service basically leverages

452
00:28:57,414 --> 00:29:01,306
the Kubernetes service token offered to it, we can now make

453
00:29:01,328 --> 00:29:05,222
sure that we actually, from a service perspective, covered authentication

454
00:29:05,286 --> 00:29:08,906
authorization and nice thing is that with

455
00:29:08,928 --> 00:29:12,206
fault. We can also make sure that from a consumer level we can

456
00:29:12,228 --> 00:29:15,626
also do authentication authorization a proper way because you have to authenticate

457
00:29:15,658 --> 00:29:19,102
towards and give an LDAP. Note that in our demo we're using

458
00:29:19,156 --> 00:29:22,754
vault tokens directly that are generated when setting up vault in the first

459
00:29:22,792 --> 00:29:26,274
place. That's of course a very bad idea because

460
00:29:26,312 --> 00:29:29,682
a token doesn't tell anything about who has set it up and whether

461
00:29:29,736 --> 00:29:33,010
he's still authorized to access that particular secret.

462
00:29:34,230 --> 00:29:37,462
We have auditability in place, of course, not during this demo,

463
00:29:37,516 --> 00:29:40,358
but what you could normally do is forward all of that stuff to elk and

464
00:29:40,364 --> 00:29:43,718
there you can see what happens. And a nice thing is you can also

465
00:29:43,884 --> 00:29:48,742
audit the actual configuration because everything

466
00:29:48,796 --> 00:29:52,058
is covered. The whole configuration of fault is covered in HCL and

467
00:29:52,064 --> 00:29:55,050
with that you can actually configure the policies,

468
00:29:55,970 --> 00:29:59,978
the resources and a lot of other different things that allows

469
00:29:59,994 --> 00:30:03,994
for easy auditing. We also have temporarily

470
00:30:04,122 --> 00:30:07,966
covered because by default some of

471
00:30:07,988 --> 00:30:12,626
those temporal secrets are actually only there to be for

472
00:30:12,648 --> 00:30:16,514
a given session and then invalidated again. And a nice thing

473
00:30:16,552 --> 00:30:20,180
is that it's also very easy to actually rotate the secrets in the

474
00:30:20,630 --> 00:30:24,520
KV backend and make sure that they're versioned so you can move ahead.

475
00:30:25,690 --> 00:30:29,414
And another nice thing about that is that you can also put metadata inside so

476
00:30:29,452 --> 00:30:32,280
you can see what is going on with them.

477
00:30:32,650 --> 00:30:36,150
Blast radius is still something that you have to take care of yourself

478
00:30:36,220 --> 00:30:39,514
that's not really related to word fault. It just

479
00:30:39,552 --> 00:30:43,194
basically means you need to make sure that you

480
00:30:43,392 --> 00:30:47,390
make sure that the secret itself is not consumable by other

481
00:30:47,540 --> 00:30:50,750
platforms, aka just don't reuse your passwords.

482
00:30:53,090 --> 00:30:56,302
So there's a lot of other things you can do with fault as well.

483
00:30:56,436 --> 00:30:59,962
You could, for instance, allow template access to AWS or another cloud provider.

484
00:31:00,026 --> 00:31:03,730
Make sure you have template credentials for your services and users of databases.

485
00:31:04,630 --> 00:31:07,746
Use PKI there's so many things you can do with that.

486
00:31:07,848 --> 00:31:11,174
So that makes it actually quite of an interesting one stop

487
00:31:11,212 --> 00:31:14,822
shop for all your secrets management. The problem of course with that

488
00:31:14,876 --> 00:31:18,246
is that it can become quite challenging because if

489
00:31:18,268 --> 00:31:22,994
you put all of these different secret

490
00:31:23,042 --> 00:31:26,310
management procedures into one product,

491
00:31:26,460 --> 00:31:30,374
you end up with an extensive HCL rable, additional kubernetes

492
00:31:30,422 --> 00:31:34,074
or terraform code to further provision it in the future, or other type of code.

493
00:31:34,112 --> 00:31:36,890
In terms of how you can configure or deploy it correctly,

494
00:31:38,190 --> 00:31:41,930
integrating the different outback ends can be safely

495
00:31:42,010 --> 00:31:46,174
actually requires a lot of attention because it's easy to make mistakes in

496
00:31:46,212 --> 00:31:49,646
terms of how do you expose the credentials, how do you make sure that

497
00:31:49,668 --> 00:31:52,978
the roles get revoked properly, and how the temporary credentials can

498
00:31:52,984 --> 00:31:56,846
be cleaned up in the first place. And not every DevOps

499
00:31:56,878 --> 00:32:00,866
consumer, as in your developer, knows how to work with that.

500
00:32:00,968 --> 00:32:04,486
It takes quite some training. If you

501
00:32:04,508 --> 00:32:08,326
still like this solution a lot, make sure that

502
00:32:08,348 --> 00:32:12,070
you store enough metadata about the secret where you store the actual secret.

503
00:32:12,650 --> 00:32:16,442
Make sure that you have backups in place because the storage where vault is running

504
00:32:16,496 --> 00:32:19,820
on could be damaged as well.

505
00:32:22,590 --> 00:32:26,266
Like I mentioned earlier, we're using root tokens to use the

506
00:32:26,288 --> 00:32:29,498
vault in the wrong secrets project. Make sure you don't

507
00:32:29,514 --> 00:32:33,102
need those root tokens anymore because they're too powerful and they

508
00:32:33,156 --> 00:32:35,710
are not related to any personal in the first place.

509
00:32:35,860 --> 00:32:39,780
And even when they are in a certain way,

510
00:32:40,230 --> 00:32:43,650
it's still hard to track whether that's actually being used by that person

511
00:32:43,720 --> 00:32:46,210
or by somebody else who has obtained the root token.

512
00:32:47,670 --> 00:32:51,790
So get ready for having your monster secrets secured

513
00:32:51,870 --> 00:32:54,450
in your secondary secrets management setup.

514
00:32:55,190 --> 00:32:59,238
And you still need to harden the environment where vault runs on. That means

515
00:32:59,324 --> 00:33:02,246
if vault runs on kubernetes, well, we just talked about that,

516
00:33:02,268 --> 00:33:05,466
right? What you have to do over there, even if it just runs as a

517
00:33:05,488 --> 00:33:09,126
cluster somewhere else, make sure you harden the cluster, the network

518
00:33:09,158 --> 00:33:13,962
and everything that's provisioned on site with it and

519
00:33:14,016 --> 00:33:17,514
credential related backends can still be challenging. And there are so many

520
00:33:17,552 --> 00:33:21,102
more things that can actually be challenging with this. That doesn't mean

521
00:33:21,156 --> 00:33:24,474
it's a bad solution. Similar like Kubernetes

522
00:33:24,522 --> 00:33:28,094
secrets, it can be used very well, but you do have to take

523
00:33:28,132 --> 00:33:31,714
into consideration all the different challenges that you might have ended up with and

524
00:33:31,752 --> 00:33:34,850
prepare for those. And well,

525
00:33:34,920 --> 00:33:39,342
as a little bit of a show how problematic

526
00:33:39,406 --> 00:33:42,866
it can be. If we scroll down on what we just showed

527
00:33:42,898 --> 00:33:46,726
previously, you'll see that there's actually

528
00:33:46,828 --> 00:33:50,502
a lot more being committed to git. In fact,

529
00:33:50,556 --> 00:33:53,426
we committed some of our root tokens for vault.

530
00:33:53,618 --> 00:33:57,034
So you can see that you're possibly not the only one that

531
00:33:57,072 --> 00:34:00,010
might have have root tokens for vault in git.

532
00:34:01,150 --> 00:34:05,402
Make sure you get rid of those, invalidate them. So enough

533
00:34:05,456 --> 00:34:09,066
about vault. Let's move to something else, shall we?

534
00:34:09,088 --> 00:34:12,826
Move to the cloud. So the examples

535
00:34:12,858 --> 00:34:16,478
we're going to discuss today are based on AWS. Of course Google and Azure are

536
00:34:16,484 --> 00:34:18,990
on their way for the wrong secrets project in OWAsp,

537
00:34:19,590 --> 00:34:23,726
but they're kind of similar. Let's talk about the solutions

538
00:34:23,758 --> 00:34:27,266
that we have so you can store

539
00:34:27,368 --> 00:34:31,006
secrets in the AWS SSM parameter store showed

540
00:34:31,038 --> 00:34:35,058
on the left, or use the AWS secrets management

541
00:34:35,154 --> 00:34:37,480
as showed its icon on the right.

542
00:34:39,450 --> 00:34:42,786
Both are covered in the wrong secret project with their own challenges.

543
00:34:42,978 --> 00:34:46,280
The idea is basically that the secret lives over there,

544
00:34:46,670 --> 00:34:50,038
and there's a few common challenges with these systems

545
00:34:50,054 --> 00:34:53,146
when you store the secrets over there. First of all,

546
00:34:53,328 --> 00:34:56,698
you need to make sure that the values are encrypted properly, for which you have

547
00:34:56,704 --> 00:35:00,186
to leverage AWS KMs and configure the keys

548
00:35:00,218 --> 00:35:03,946
that are used to encrypt that correctly, or use alternatives for encryption.

549
00:35:03,978 --> 00:35:07,546
In that sense, then you have to take care of rotationing and versioning

550
00:35:07,578 --> 00:35:11,026
the secrets in a proper way. And of

551
00:35:11,048 --> 00:35:14,158
course the AWS SSM parameter store and secrets

552
00:35:14,174 --> 00:35:17,806
manager work a little bit different in terms of how they expose

553
00:35:17,838 --> 00:35:22,050
the secret and how you can regulate the access towards the secret.

554
00:35:22,630 --> 00:35:26,406
Then of course you shouldn't forget to monitor the access of these two services

555
00:35:26,508 --> 00:35:29,782
using cloud trail. And like already

556
00:35:29,836 --> 00:35:33,046
mentioned with all the previous solutions, make sure you store some

557
00:35:33,068 --> 00:35:36,390
metadata about the secret because even if you move it to the cloud,

558
00:35:36,460 --> 00:35:39,820
it becomes very easy to forget where the secret was for in the first place.

559
00:35:40,270 --> 00:35:43,306
And of course there's many other things you have to take care of,

560
00:35:43,488 --> 00:35:47,778
but this is only on how to store the secret. Another important challenge

561
00:35:47,814 --> 00:35:51,278
is of course should you be allowed to access it.

562
00:35:51,444 --> 00:35:55,198
So for that in AWS you can use sts to authenticate against

563
00:35:55,364 --> 00:35:59,346
the service and get some sort of credential for

564
00:35:59,368 --> 00:36:01,620
which you can see the sorry.

565
00:36:02,550 --> 00:36:06,658
So for that you can use AWS SDS again.

566
00:36:06,824 --> 00:36:10,530
So for that you can use AWS SDs to authenticate against

567
00:36:10,600 --> 00:36:13,590
and then you get some temporal credential like a role.

568
00:36:14,250 --> 00:36:17,922
Luckily you can see all these type of authentication

569
00:36:17,986 --> 00:36:21,250
attempts in cloud trail. That role, an IAM

570
00:36:21,330 --> 00:36:25,178
role has its own definitions in

571
00:36:25,184 --> 00:36:28,762
terms of the role itself and the attached policies which tell

572
00:36:28,816 --> 00:36:32,666
whether the authenticated entity is actually allowed to

573
00:36:32,688 --> 00:36:36,590
go to AWS SSM parameter store or the AWS secret manager,

574
00:36:38,130 --> 00:36:41,934
and by that you can carefully design your

575
00:36:41,972 --> 00:36:46,014
system in terms of access rights, whether a certain given entity should

576
00:36:46,052 --> 00:36:49,626
be allowed to read a secret. On top of that, the secrets manager

577
00:36:49,658 --> 00:36:53,138
also has its own resource policies to define whether somebody or something

578
00:36:53,224 --> 00:36:55,780
should be allowed to access the secret in the first place.

579
00:36:56,390 --> 00:37:00,446
The only problem with both of these, as in the secrets manager's

580
00:37:00,558 --> 00:37:03,814
resource policies as well as the IAM policies in the first

581
00:37:03,852 --> 00:37:07,046
place, is that it's easy to try to run off

582
00:37:07,068 --> 00:37:09,560
as fast as possible to make it work in the cloud,

583
00:37:10,410 --> 00:37:14,134
and then basically create two broad policies

584
00:37:14,182 --> 00:37:17,530
or two broad definitions in terms of the roles,

585
00:37:18,430 --> 00:37:21,926
which ends up in two powerful entities that are allowed

586
00:37:21,958 --> 00:37:26,006
to do too many different things in order to eventually easily

587
00:37:26,038 --> 00:37:29,246
obtain a secret in the first place. For that, I would

588
00:37:29,268 --> 00:37:32,894
like to welcome you to try challenge eleven from the wrong secrets project and

589
00:37:32,932 --> 00:37:34,960
find out what we mean by this.

590
00:37:35,890 --> 00:37:40,254
So good

591
00:37:40,292 --> 00:37:43,698
to keep in mind, make sure you have fine grade policies in place and

592
00:37:43,704 --> 00:37:46,770
that you don't attach all of those policies to a single role.

593
00:37:47,430 --> 00:37:50,766
And then of course the question is, if you look at your

594
00:37:50,888 --> 00:37:55,110
setup in AWS, assuming some sort of ets or fargate solution,

595
00:37:56,090 --> 00:37:59,538
at what level is an entity allowed

596
00:37:59,554 --> 00:38:02,822
to go? There is a worker node which

597
00:38:02,876 --> 00:38:06,794
hosts a bunch of pods and services allowed to

598
00:38:06,832 --> 00:38:10,678
go to the SSM parameter store or to the secrets manager.

599
00:38:10,774 --> 00:38:14,810
Or that you do this on a Kubernetes role level. Or do you specify

600
00:38:15,150 --> 00:38:19,098
your authentication authorization means on the pod level? There's a

601
00:38:19,104 --> 00:38:22,494
few things you can take away for that. The first thing is the closer the

602
00:38:22,532 --> 00:38:26,158
authentication is done towards the actual back end service in

603
00:38:26,164 --> 00:38:29,914
place. So for instance, the specific pod that hosts the container

604
00:38:30,042 --> 00:38:33,406
that requires the secret, the more secure it

605
00:38:33,428 --> 00:38:36,786
becomes because it harder becomes to compromise. This also means you

606
00:38:36,808 --> 00:38:40,446
have more work to do because you need to set up those fine grade

607
00:38:40,478 --> 00:38:43,958
access policies. You need to make sure that the specific back end servers running in

608
00:38:43,964 --> 00:38:47,238
that pod is actually able to get the secret. So there's a

609
00:38:47,244 --> 00:38:49,640
lot more work involved. Next,

610
00:38:50,970 --> 00:38:54,586
you have to make sure that the secret is of course only exposed to the

611
00:38:54,608 --> 00:38:57,580
pod that really requires it.

612
00:39:01,390 --> 00:39:04,138
Of course, the next thing that we need to take care of is how do

613
00:39:04,144 --> 00:39:07,360
we instruct the cloud to create, setup and configure these services,

614
00:39:08,050 --> 00:39:11,470
as in am Sts wrong?

615
00:39:11,620 --> 00:39:14,922
The secrets manager, the parameter store in your eks cluster.

616
00:39:15,066 --> 00:39:18,186
You can do that by clicking around in the console, but it's

617
00:39:18,218 --> 00:39:21,940
a far better way to use infrastructure as code to do so.

618
00:39:22,950 --> 00:39:24,050
Unfortunately,

619
00:39:26,310 --> 00:39:29,954
there might be a few problems with that because you might

620
00:39:29,992 --> 00:39:34,390
also try to use infrastructure as code to actually insert the secret.

621
00:39:35,290 --> 00:39:38,998
This can be done in various ways with

622
00:39:39,084 --> 00:39:42,678
various providers for infrastructure as code to actually

623
00:39:42,764 --> 00:39:46,620
resolve this in a proper way. But we created nice

624
00:39:47,470 --> 00:39:51,370
challenge number nine in the wrong secrets project, which shows

625
00:39:51,440 --> 00:39:54,906
how to not do this. Basically go ahead and try it out and see

626
00:39:55,008 --> 00:39:58,414
what actually happens in terraform. If your secrets end up in terraform state,

627
00:39:58,452 --> 00:40:02,320
for instance, and then of course,

628
00:40:03,650 --> 00:40:06,926
how do you authenticate? And there we go back

629
00:40:06,948 --> 00:40:10,546
to the old problem. If you want to authenticate to basically set up

630
00:40:10,568 --> 00:40:14,190
the infrastructure, you again need to store those secrets somewhere.

631
00:40:14,270 --> 00:40:17,826
Do you see how this continuously keeps on moving? Make sure that

632
00:40:17,848 --> 00:40:21,298
you secure those secrets. And that's also

633
00:40:21,384 --> 00:40:25,430
one of the things. For instance, if you use infrastructure as code from, for instance,

634
00:40:25,500 --> 00:40:28,726
a pipeline to make this work, you also have

635
00:40:28,748 --> 00:40:32,326
to secure your pipeline in order to, or your

636
00:40:32,348 --> 00:40:35,826
CI CD pipeline, with which you basically provide the instructions

637
00:40:35,858 --> 00:40:38,330
to your cloud provider to set up the infrastructure.

638
00:40:39,390 --> 00:40:42,726
As you can tell from our wrong secrets project, we didn't include

639
00:40:42,758 --> 00:40:46,150
those in the GitHub actions because it's easy to make mistakes

640
00:40:46,230 --> 00:40:49,870
and it's very easy to let the secrets slide somewhere so that other people

641
00:40:49,940 --> 00:40:53,774
in name of the CI CD pipeline can use

642
00:40:53,812 --> 00:40:57,386
those secrets to then build up infrastructure within your own cloud or destroy

643
00:40:57,418 --> 00:41:00,766
it. That doesn't mean it's a bad idea to

644
00:41:00,788 --> 00:41:04,322
use a CI CD pipeline to set up your infrastructure. It's actually

645
00:41:04,376 --> 00:41:07,506
a great idea, but it requires careful attention based

646
00:41:07,528 --> 00:41:11,018
on the stuff that we just shared with you to make sure that the secrets

647
00:41:11,054 --> 00:41:14,402
used to authenticate towards your cloud provider to set up your infrastructure

648
00:41:14,546 --> 00:41:17,190
are kept well and kept secret.

649
00:41:18,730 --> 00:41:22,066
So let's just dive into one of those infrastructure

650
00:41:22,098 --> 00:41:25,370
as code challenges, shall we? So going back

651
00:41:25,440 --> 00:41:28,810
to our little wrong secrets project,

652
00:41:28,960 --> 00:41:32,220
let's do a little challenge. Challenge number nine.

653
00:41:33,550 --> 00:41:38,102
So over here, we basically use terraform to provision

654
00:41:38,246 --> 00:41:41,914
our environment in AWS, which is a great idea because it comes

655
00:41:41,962 --> 00:41:45,726
very reproducible. Just to make sure it is really not

656
00:41:45,748 --> 00:41:49,374
a hard coding joke. No, it's not. Okay, so let's open up our

657
00:41:49,412 --> 00:41:53,074
terraform state that for this sample is stored on our local hard

658
00:41:53,112 --> 00:41:56,974
drive. Of course, it's not the recommended way to do it normally in your enterprise

659
00:41:57,022 --> 00:42:00,670
environment, but for now, for the demo, it's the easiest way to work with.

660
00:42:00,760 --> 00:42:04,710
So we open visual studio and

661
00:42:04,780 --> 00:42:08,390
open the secret. And then we start looking for the password.

662
00:42:09,450 --> 00:42:12,278
Here we found actually some password. Okay,

663
00:42:12,364 --> 00:42:16,086
that's strange. So while generating it through terraform, we actually

664
00:42:16,188 --> 00:42:20,170
generated the secret itself, which is actually the correct secret.

665
00:42:21,230 --> 00:42:24,634
So the reason that that worked is

666
00:42:24,672 --> 00:42:29,182
because we used the terraform provider for the secrets manager and

667
00:42:29,236 --> 00:42:32,666
the AWS SSM parameter store that does not encrypt

668
00:42:32,698 --> 00:42:36,526
the secret. Luckily, there's alternative providers that actually have a

669
00:42:36,548 --> 00:42:40,420
configuration to encrypt the secret in a proper way.

670
00:42:40,790 --> 00:42:44,580
Use those when you really have to provide secrets through

671
00:42:46,150 --> 00:42:48,420
infrastructure as code in this way.

672
00:42:49,270 --> 00:42:53,026
So that's a lot of small chunks everywhere. Shall we try to

673
00:42:53,048 --> 00:42:55,910
cover what we've covered today in terms of lessons learned?

674
00:42:56,330 --> 00:42:59,446
First of all, as you can tell, there are so many ways how we can

675
00:42:59,468 --> 00:43:03,122
mess up secrets management, and there's really no single solution

676
00:43:03,186 --> 00:43:06,922
that will always work and always cater to your needs. Because face it,

677
00:43:06,976 --> 00:43:10,362
you can make mistakes. So make sure you can and

678
00:43:10,416 --> 00:43:13,706
will rotate your secrets, not only because of the

679
00:43:13,728 --> 00:43:16,966
risks of course involved, but as well because the APIs

680
00:43:17,078 --> 00:43:20,426
where you might need those secrets for, or any other type of system that requires

681
00:43:20,458 --> 00:43:23,678
the secret might enforce you to rotate it in the

682
00:43:23,684 --> 00:43:27,610
first place. Label your secrets so migration

683
00:43:27,690 --> 00:43:31,154
will not hurt that much, or cleaning up or

684
00:43:31,192 --> 00:43:33,940
improving your service landscape won't hurt that much.

685
00:43:34,710 --> 00:43:38,354
Make sure you create a small blast radius, aka make

686
00:43:38,392 --> 00:43:41,934
sure that the secret that you're using is not reused in some other context,

687
00:43:42,062 --> 00:43:45,254
and that the secret actually still only opens up

688
00:43:45,292 --> 00:43:48,486
a least privilege role at the system where it's required to.

689
00:43:48,588 --> 00:43:52,086
So you can make sure that when the secret gets compromised, not your

690
00:43:52,108 --> 00:43:53,750
full system gets compromised.

691
00:43:55,150 --> 00:43:58,566
Make sure that the creation, consumption and monitoring of your secrets

692
00:43:58,598 --> 00:44:01,914
is easy. If anybody in your organization that

693
00:44:01,952 --> 00:44:05,020
needs to work of this has troubles understanding it,

694
00:44:05,790 --> 00:44:08,970
start revising your secrets management solution.

695
00:44:09,050 --> 00:44:12,606
Start revising your security procedures around them and see if you

696
00:44:12,628 --> 00:44:15,902
can make it workable and simple. Because if it's not simple

697
00:44:15,956 --> 00:44:19,706
to everybody, it becomes hard to use. People actually try to bypass

698
00:44:19,738 --> 00:44:24,158
it and you possibly might find those beautiful yellow stickies attached to monitors

699
00:44:24,254 --> 00:44:27,634
at people's desks, at home or in the office. When we're all

700
00:44:27,672 --> 00:44:31,506
returned again after Covid with the actual secret in

701
00:44:31,528 --> 00:44:35,522
there. Make sure you have security and break loss procedures

702
00:44:35,586 --> 00:44:38,854
in place whenever this primary secrets management solution starts to

703
00:44:38,892 --> 00:44:43,240
fill. Make sure that your secrets are actually short lived where possible.

704
00:44:44,490 --> 00:44:47,894
And of course, there's so many other things. Storing secrets encrypted

705
00:44:47,942 --> 00:44:51,546
is one thing, using the right access controls and policies is

706
00:44:51,568 --> 00:44:55,318
another. Not locking them directly is a good idea, not copying

707
00:44:55,334 --> 00:44:58,554
them locally to your computer or to your git repository is a good

708
00:44:58,592 --> 00:45:00,720
idea, and there's so many others with them.

709
00:45:01,250 --> 00:45:05,086
Moving to the cloud infrastructure as code is great,

710
00:45:05,188 --> 00:45:09,330
but be careful with secrets in the state of the infrastructure as code provisioner,

711
00:45:10,070 --> 00:45:13,666
use a solution that works for you, but be careful how you

712
00:45:13,688 --> 00:45:17,266
manage it. That holds for the whole secrets management solution in

713
00:45:17,288 --> 00:45:20,834
the first place. Secret management is,

714
00:45:20,872 --> 00:45:24,406
in that case actually type of, kind of the result of your

715
00:45:24,428 --> 00:45:28,386
infosecurity program. That means how you set up your iam, your hardening

716
00:45:28,418 --> 00:45:31,654
policies, your procedures, how you make sure your code

717
00:45:31,692 --> 00:45:34,360
is in a good shape, and all the other things.

718
00:45:35,210 --> 00:45:38,966
So that basically means it's

719
00:45:38,998 --> 00:45:42,842
a journey. You always have to upgrade, you always have to improve because there's always

720
00:45:42,896 --> 00:45:46,218
stuff that you might made it a little bit too easy to obtain the

721
00:45:46,224 --> 00:45:50,186
secret. And you will always need a secondary secrets

722
00:45:50,218 --> 00:45:54,026
management system because you need to of course, secure the root secrets

723
00:45:54,058 --> 00:45:58,398
of your primary secrets management system in the first place and

724
00:45:58,484 --> 00:46:02,462
learn from us, from our GitHub actions. If you don't have time to harden

725
00:46:02,526 --> 00:46:05,454
the pipeline that is your CI CD pipeline,

726
00:46:05,502 --> 00:46:09,506
secrets have no place in there. Luckily, there are various resources on

727
00:46:09,528 --> 00:46:12,338
how to harden your CI CD pipeline in a proper way,

728
00:46:12,424 --> 00:46:16,034
which will then allow you to easily inject the secrets over there and start

729
00:46:16,072 --> 00:46:18,450
using your pipeline to its fullest potential.

730
00:46:19,350 --> 00:46:22,738
If you have any questions, feel free to ask them through discord as you

731
00:46:22,744 --> 00:46:25,882
can find it this page. If you want to have the slides in a later

732
00:46:25,936 --> 00:46:29,306
stage, just we'll also be sharing them at the conference and

733
00:46:29,328 --> 00:46:32,522
we'll share them via Twitter. Feel free to get in touch with us.

734
00:46:32,656 --> 00:46:33,880
Thank you so much for your time.

