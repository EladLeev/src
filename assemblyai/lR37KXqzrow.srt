1
00:00:00,410 --> 00:00:06,174
Jamaica real

2
00:00:06,212 --> 00:00:09,578
time feedback into the behavior of your distributed systems

3
00:00:09,674 --> 00:00:12,538
and observing changes exceptions.

4
00:00:12,634 --> 00:00:16,746
Errors in real time allows you to not only experiment with confidence,

5
00:00:16,858 --> 00:00:20,480
but respond instantly to get things working again.

6
00:00:24,610 --> 00:00:47,770
Cloud hello

7
00:00:47,840 --> 00:00:51,190
everyone, and welcome to development productivity in a post serverless

8
00:00:51,270 --> 00:00:54,378
world. I want to start with the story,

9
00:00:54,544 --> 00:00:58,106
so you may be wondering, why am I showing

10
00:00:58,138 --> 00:01:01,726
you a slide with a scooter or

11
00:01:01,748 --> 00:01:05,374
a moped, as they call in the UK, and what apparently

12
00:01:05,422 --> 00:01:08,530
looks like a computer or a server?

13
00:01:09,190 --> 00:01:13,314
So this is a story of 20 years ago when

14
00:01:13,352 --> 00:01:17,558
I was working for a telecommunication company back home

15
00:01:17,644 --> 00:01:21,286
in Naples. And what

16
00:01:21,308 --> 00:01:26,322
we were doing in that company was we were providing authentication

17
00:01:26,466 --> 00:01:30,346
for some of the biggest broadband provider in

18
00:01:30,368 --> 00:01:34,026
the area. So we did not have the infrastructure to

19
00:01:34,048 --> 00:01:37,050
actually run and provide the broadband ourselves,

20
00:01:37,550 --> 00:01:42,042
but those kind of broadband provider, they would offload authentication

21
00:01:42,106 --> 00:01:45,806
to us. So when somebody will try

22
00:01:45,828 --> 00:01:50,186
to connect to the Internet from their home via

23
00:01:50,218 --> 00:01:53,886
their router, a request will come to us to say, should I authenticate this

24
00:01:53,908 --> 00:01:57,002
user? Should I authorize this user to actually go over the Internet

25
00:01:57,066 --> 00:02:00,850
or to access the Internet or not? And then based on

26
00:02:00,920 --> 00:02:05,006
accounts and all the information that we had, we would either authorize or

27
00:02:05,048 --> 00:02:06,470
deny the request.

28
00:02:07,930 --> 00:02:11,926
Now, all of these was handled by a

29
00:02:11,948 --> 00:02:15,640
serverless called Argo. So actually, Argo was

30
00:02:16,890 --> 00:02:21,062
a server that we have had for some time.

31
00:02:21,196 --> 00:02:24,938
It was actually living in our office, it was connected to the

32
00:02:24,944 --> 00:02:29,146
Internet. Argo was actually living in a room where

33
00:02:29,168 --> 00:02:32,446
there was air conditioner to make sure it didn't get

34
00:02:32,468 --> 00:02:35,966
too hot. And Argo looked very much like the computer you can

35
00:02:35,988 --> 00:02:41,070
see here on the slide. And everyone

36
00:02:41,140 --> 00:02:44,506
knew Argo. He has been with us for

37
00:02:44,628 --> 00:02:48,066
a few years. We would regularly look after him. We will

38
00:02:48,088 --> 00:02:49,890
regularly patch Argo,

39
00:02:51,190 --> 00:02:54,306
and we relied on Argo to be there to

40
00:02:54,328 --> 00:02:57,526
do his job of authorizing or denying requests to

41
00:02:57,548 --> 00:03:00,390
allow people to go over the Internet.

42
00:03:01,210 --> 00:03:04,486
Now, one day what happened was that there was

43
00:03:04,508 --> 00:03:08,250
a power cut into the area, and therefore,

44
00:03:10,030 --> 00:03:14,042
once we had a backup generator to give power

45
00:03:14,096 --> 00:03:17,606
to Argo, we could not keep Argo alive

46
00:03:17,798 --> 00:03:21,718
for a long time. And actually we did

47
00:03:21,744 --> 00:03:25,342
not have another argo. So Argo was the only server that we had

48
00:03:25,476 --> 00:03:29,358
to handle the job. We could not recreate a

49
00:03:29,444 --> 00:03:33,154
new Argo in a reasonable amount of time. We did not

50
00:03:33,192 --> 00:03:36,594
know what was on Argo. Argo was a few

51
00:03:36,632 --> 00:03:40,174
years old, and during that time, he was patched,

52
00:03:40,222 --> 00:03:44,046
he was reconfigured, updates were applied,

53
00:03:44,158 --> 00:03:47,862
so we didn't really know what was going on. We did not have either

54
00:03:47,916 --> 00:03:51,446
the hardware or the knowledge to recreate a

55
00:03:51,468 --> 00:03:54,486
new Argo in time. So what did I do?

56
00:03:54,588 --> 00:03:58,178
I unplugged Argo. I took Argo on

57
00:03:58,204 --> 00:04:02,090
my scooter with me, and I did

58
00:04:02,160 --> 00:04:05,866
drive in the traffic of Naples as quickly, as fast as I

59
00:04:05,888 --> 00:04:08,970
could to take Argo to my house.

60
00:04:09,040 --> 00:04:12,410
Actually, it was my parents house at the time, in my bedroom.

61
00:04:12,570 --> 00:04:15,902
So I arrived in my bedroom, I plugged Argo back

62
00:04:15,956 --> 00:04:18,590
in, I connected it to the Internet.

63
00:04:19,090 --> 00:04:22,534
I phoned up our broadband provider partners,

64
00:04:22,602 --> 00:04:26,114
I gave them the ip address of my house so they

65
00:04:26,152 --> 00:04:29,362
could redirect requests back to

66
00:04:29,416 --> 00:04:31,700
Argo. And job done.

67
00:04:32,950 --> 00:04:36,706
We were back in business. Actually, Argo was

68
00:04:36,728 --> 00:04:40,690
very noisy. He had a very big fan

69
00:04:40,770 --> 00:04:44,566
to kind of keep it cool. So one night I couldn't really sleep with

70
00:04:44,588 --> 00:04:48,406
the noise that Argo was making. So I unplugged it again and I moved it

71
00:04:48,428 --> 00:04:51,766
in my living room. And so my appeals changed

72
00:04:51,798 --> 00:04:55,318
and that kind of caused a little bit of downtime

73
00:04:55,414 --> 00:04:58,666
in service, but there you go. Why am

74
00:04:58,688 --> 00:05:02,654
I telling you this in a boost serverless talk?

75
00:05:02,772 --> 00:05:06,894
I'm telling you this because there was a time in which servers were

76
00:05:06,932 --> 00:05:10,766
not ephemeral, they were very important,

77
00:05:10,868 --> 00:05:15,026
they were long lived. And entire

78
00:05:15,128 --> 00:05:18,722
businesses were actually built and would

79
00:05:18,776 --> 00:05:22,866
rely on physical servers to

80
00:05:22,888 --> 00:05:24,340
actually keep going.

81
00:05:26,650 --> 00:05:30,114
So my name is Domenico, I'm a principal engineer at economics.

82
00:05:30,242 --> 00:05:34,166
Recently we kind of rebranded ourselves and

83
00:05:34,188 --> 00:05:37,686
now we called Hardall. So those are some of the things that

84
00:05:37,708 --> 00:05:41,434
I do and some of the things that I

85
00:05:41,472 --> 00:05:45,658
really can't do. So I've been in the industry for more than 20 years.

86
00:05:45,744 --> 00:05:48,570
I still cannot write a simple,

87
00:05:48,640 --> 00:05:50,170
regular expression.

88
00:05:53,010 --> 00:05:56,798
So what I want to talk to you, but today is two things.

89
00:05:56,884 --> 00:06:00,478
One, I want to talk about how did we get from

90
00:06:00,644 --> 00:06:04,498
serverless, like Argo, to running functions into the

91
00:06:04,504 --> 00:06:08,190
cloud? So what has the journey like to move from physical

92
00:06:08,270 --> 00:06:11,986
servers to AWS Lambda and azure function

93
00:06:12,088 --> 00:06:15,606
and all of that kind of good stuff? And also, I want to talk,

94
00:06:15,628 --> 00:06:19,126
but a little bit about infrastructure as code and what kind

95
00:06:19,148 --> 00:06:22,440
of role I think that's going to play into the future.

96
00:06:24,810 --> 00:06:28,982
So let's start from servers to serverless.

97
00:06:29,046 --> 00:06:32,614
So initially, back in the days, we had physical

98
00:06:32,662 --> 00:06:36,298
servers like Argo. I mean, they were much better looking than

99
00:06:36,384 --> 00:06:39,706
Argo. So they were flat and

100
00:06:39,728 --> 00:06:43,774
they could fit in rack space, and then

101
00:06:43,972 --> 00:06:47,502
those were leaving kind of data center. And then you had,

102
00:06:47,636 --> 00:06:52,030
traditionally you had the development, the developers, kind of software engineers

103
00:06:52,530 --> 00:06:56,742
on one side, and then you had kind of the operational engineers

104
00:06:56,826 --> 00:07:00,562
on the other side. And kind of the words between these two was

105
00:07:00,616 --> 00:07:04,270
very different. Kind of the tools that they were using, the day to day activities

106
00:07:04,350 --> 00:07:08,066
that they would perform were very different developers. Whats will

107
00:07:08,088 --> 00:07:11,766
write a code. They had little to no idea what was going

108
00:07:11,788 --> 00:07:15,400
on into the production environment. They would hand over the course,

109
00:07:15,850 --> 00:07:19,686
sometimes in the form of a package to kind of operation, which would

110
00:07:19,708 --> 00:07:24,022
then go ahead and deploy the software onto the server and

111
00:07:24,076 --> 00:07:27,658
the operation they were looking after, patching and maintaining not just

112
00:07:27,744 --> 00:07:31,418
the configuration of the servers, but also kind of procuring the hardware

113
00:07:31,594 --> 00:07:34,974
issue, replacement parts and whats kind of stuff.

114
00:07:35,092 --> 00:07:38,622
And so the distance between the two worlds was very big,

115
00:07:38,676 --> 00:07:42,094
like significantly two different jobs with two different

116
00:07:42,132 --> 00:07:44,560
kind of skill sets. Whats you will need.

117
00:07:45,970 --> 00:07:50,500
Then virtualization came in

118
00:07:51,350 --> 00:07:55,414
and this is where I guess the distance between

119
00:07:55,452 --> 00:07:59,186
the two words started to reduce

120
00:07:59,298 --> 00:08:02,950
a little bit because here you'd have things like starting

121
00:08:03,020 --> 00:08:06,722
to do some scripting and potentially some configuration

122
00:08:06,786 --> 00:08:10,026
as code over those machines. I mean there was still

123
00:08:10,048 --> 00:08:13,898
like a physical hardware potentially owned and run

124
00:08:14,064 --> 00:08:18,410
by operation. And the service here are still long lived.

125
00:08:19,310 --> 00:08:22,894
But I see it in terms of tooling, it will

126
00:08:22,932 --> 00:08:27,360
start to kind of reduce the distance between the two teams because

127
00:08:28,610 --> 00:08:31,710
both operation and development might start to do

128
00:08:31,860 --> 00:08:35,700
some bashing or some scripting. And developers started to

129
00:08:36,390 --> 00:08:40,082
get a little bit more information and knowledge around

130
00:08:40,216 --> 00:08:44,562
what kind of the virtual machine looked like. And potentially they would also do

131
00:08:44,616 --> 00:08:48,486
some of the configuration on those machines themselves to actually run their

132
00:08:48,508 --> 00:08:52,706
own software. And so like I said, the distance kind of shrink

133
00:08:52,738 --> 00:08:55,974
down a little bit. And then

134
00:08:56,012 --> 00:09:00,570
Docker came in and I think this was like the most significant

135
00:09:01,790 --> 00:09:05,290
shift in terms of reducing the distance

136
00:09:05,630 --> 00:09:08,918
between development and operation,

137
00:09:09,094 --> 00:09:13,546
because here is where kind of the environment

138
00:09:13,738 --> 00:09:16,778
in which the software runs becomes ephemeral.

139
00:09:16,874 --> 00:09:21,002
We don't talk anymore in terms of servers

140
00:09:21,066 --> 00:09:24,526
and we don't give those servers names. They're not long lived

141
00:09:24,558 --> 00:09:28,242
anymore. But we talk about in terms of processes and maybe

142
00:09:28,296 --> 00:09:32,050
amount of memory I need to run my application and the number of cpus.

143
00:09:34,230 --> 00:09:37,314
But we also change

144
00:09:37,352 --> 00:09:40,790
the way that we write code and we stop relying on

145
00:09:40,860 --> 00:09:43,922
service being long lived and configuration being applied

146
00:09:44,066 --> 00:09:48,060
upfront. And this is also where I guess in terms of

147
00:09:48,670 --> 00:09:52,106
tooling and ecosystem brought those two words together,

148
00:09:52,208 --> 00:09:55,626
because now developers can deploy their

149
00:09:55,648 --> 00:09:59,622
own application much more easily. Tooling is kind of shared,

150
00:09:59,686 --> 00:10:03,294
for example, in the kind of Kubernetes world. If you use

151
00:10:03,332 --> 00:10:06,654
that as an orchestrator, you might use kind of

152
00:10:06,692 --> 00:10:11,166
helm as a tool shared between operational and

153
00:10:11,188 --> 00:10:14,894
development. And even

154
00:10:14,932 --> 00:10:17,706
if you think about activities like scaling, for example,

155
00:10:17,828 --> 00:10:21,074
developers started to take ownership around some of

156
00:10:21,112 --> 00:10:24,194
those, because now it's a much easier thing to do

157
00:10:24,232 --> 00:10:29,720
in terms of the tooling and in the ecosystem. And so the

158
00:10:30,330 --> 00:10:34,530
distance between the kind of activity, the tooling, the skills,

159
00:10:34,610 --> 00:10:38,454
I guess between those two words significantly reduced

160
00:10:38,582 --> 00:10:41,530
at this time with the advent of Docker.

161
00:10:42,350 --> 00:10:46,502
And then after that serverless came in specifically

162
00:10:46,566 --> 00:10:49,420
function as a service. So the idea that you write some code,

163
00:10:50,690 --> 00:10:54,558
you push that code into a cloud environment and

164
00:10:54,644 --> 00:10:58,480
that code magically runs for you.

165
00:10:59,570 --> 00:11:03,514
And this had I guess an impact in terms of reducing

166
00:11:03,562 --> 00:11:06,882
the distance between the two words. But I guess in absolute terms,

167
00:11:06,936 --> 00:11:10,254
in absolute values, it was not, in my opinion,

168
00:11:10,382 --> 00:11:13,938
as impactful as the advent of

169
00:11:14,024 --> 00:11:18,306
Docker. And whilst here we don't have server

170
00:11:18,338 --> 00:11:21,926
to manage, and we now talk about

171
00:11:22,108 --> 00:11:25,254
business logic, write them processes, and we talk

172
00:11:25,292 --> 00:11:28,200
about events that triggers those function.

173
00:11:28,970 --> 00:11:32,218
The distance between the two world, I think is still there

174
00:11:32,304 --> 00:11:36,262
even in function as a service. And why do I think there is still distance

175
00:11:36,326 --> 00:11:39,866
there? It's because for once, for example, the kind

176
00:11:39,888 --> 00:11:43,580
of tooling and languages that we use

177
00:11:44,270 --> 00:11:47,994
for the infrastructure to run serverless and write the serverless

178
00:11:48,042 --> 00:11:51,118
function, the business logic itself is still different. So for example,

179
00:11:51,204 --> 00:11:54,914
here you can see on the right hand side we have an example

180
00:11:55,032 --> 00:11:58,254
of an AWS lambda function written

181
00:11:58,302 --> 00:12:01,762
with typescript. And on the left hand side

182
00:12:01,896 --> 00:12:05,542
you see kind of this yaml configuration file which

183
00:12:05,596 --> 00:12:09,314
is used to provide kind of the serverless ecosystem

184
00:12:09,362 --> 00:12:12,934
on which that lambda functions run. Now this particular example is

185
00:12:12,972 --> 00:12:16,674
using the serverless framework as a packaging

186
00:12:16,722 --> 00:12:19,594
tool for lambda based application.

187
00:12:19,792 --> 00:12:24,390
But you can see that there is still the notion of infrastructure versus

188
00:12:24,550 --> 00:12:27,434
application. And the way that we define the tool,

189
00:12:27,552 --> 00:12:32,714
it's still using two different languages. So we

190
00:12:32,752 --> 00:12:36,106
still need to have to understand the yaml, we still need to understand what's

191
00:12:36,138 --> 00:12:39,806
behind it, and we still need to understand typescript and whats is still two

192
00:12:39,828 --> 00:12:41,950
different tooling.

193
00:12:43,590 --> 00:12:46,980
Now the question for me is what's coming next?

194
00:12:47,910 --> 00:12:51,854
Have we reached kind of the plateau in terms of reducing

195
00:12:51,902 --> 00:12:55,886
that distance and therefore maximizing the productivity

196
00:12:56,078 --> 00:12:59,462
and the speed in which we can write application?

197
00:12:59,596 --> 00:13:02,694
Or is there anything else? And if so, what is the

198
00:13:02,732 --> 00:13:06,374
next thing that is going to reduce the distance between the two

199
00:13:06,412 --> 00:13:10,394
world even further? Is it going to allow us to actually be

200
00:13:10,432 --> 00:13:14,010
even faster at creating systems

201
00:13:14,430 --> 00:13:18,122
and application? Okay,

202
00:13:18,176 --> 00:13:21,850
and with that, so let's move on a little bit on that and

203
00:13:21,920 --> 00:13:25,786
try to explore what might be coming next and talking about infrastructure

204
00:13:25,818 --> 00:13:28,560
as code and what kind of role it might play.

205
00:13:29,410 --> 00:13:33,598
So actually I think whats, there's not going to be infrastructure as code

206
00:13:33,684 --> 00:13:37,474
anymore, or at least infrastructure as code is not

207
00:13:37,512 --> 00:13:42,020
going to exist in the same sense,

208
00:13:42,550 --> 00:13:46,966
in the same way that he exists today,

209
00:13:47,148 --> 00:13:50,326
because I think going forward we're going to move to

210
00:13:50,348 --> 00:13:53,906
a world where we think more and more about systems

211
00:13:54,018 --> 00:13:57,170
as a whole over

212
00:13:57,340 --> 00:14:01,190
differentiating infrastructure and infrastructure

213
00:14:01,270 --> 00:14:05,114
and application. And so what we called

214
00:14:05,232 --> 00:14:09,034
it's going to be the system as in something that

215
00:14:09,072 --> 00:14:12,206
produce values, the business and solves a problem,

216
00:14:12,388 --> 00:14:16,286
rather than thinking about this is the application and this

217
00:14:16,308 --> 00:14:19,200
is the infrastructure on which the application run.

218
00:14:19,650 --> 00:14:23,060
The two things are kind of going to be merged together.

219
00:14:25,430 --> 00:14:28,738
So actually the real thing I want to talk about

220
00:14:28,824 --> 00:14:33,134
is in our agenda is forget

221
00:14:33,182 --> 00:14:37,086
about infrastructure as code and talk. But I think two emerging patterns

222
00:14:37,118 --> 00:14:41,426
that I see more and more when talking to people and companies implementing,

223
00:14:41,458 --> 00:14:45,206
which I think is going to play a bigger role into the future. I mean,

224
00:14:45,228 --> 00:14:48,554
of course that's my bet. I might be wrong, but this is where I would

225
00:14:48,592 --> 00:14:50,540
kind of put my money on.

226
00:14:51,630 --> 00:14:55,286
And one is platform code and the other one is infrastructure

227
00:14:55,318 --> 00:14:58,602
as code. Now, I think the best way

228
00:14:58,656 --> 00:15:02,880
to talk about those pattern is to actually see some code

229
00:15:07,650 --> 00:15:11,134
and code something and write something. And for that

230
00:15:11,172 --> 00:15:14,610
I'm going to use some specific tools and libraries.

231
00:15:15,910 --> 00:15:21,182
Just a little bit of a disclaimer here. I have no commercial

232
00:15:21,246 --> 00:15:24,594
relationship whatsoever with the tools I'm going to show you. I'm not trying to sell

233
00:15:24,632 --> 00:15:28,198
you anything. I just think that those two tools I'm going

234
00:15:28,204 --> 00:15:32,054
to show you are a good example of an implementation of those

235
00:15:32,092 --> 00:15:35,366
patterns. But you can achieve the same things, I'm sure,

236
00:15:35,388 --> 00:15:43,354
with many different other tools. Okay, so the

237
00:15:43,392 --> 00:15:46,698
first pattern we're going to be talking about is platform

238
00:15:46,784 --> 00:15:50,182
has code, and with platform has code.

239
00:15:50,256 --> 00:15:53,600
I guess the idea for me is that

240
00:15:54,930 --> 00:15:58,254
there are three main characteristics, I guess that those

241
00:15:58,292 --> 00:16:02,400
type of systems would have. The first one is that

242
00:16:02,790 --> 00:16:06,018
the language that you use to code

243
00:16:06,104 --> 00:16:10,180
your system essentially is the same. You code the platform

244
00:16:12,230 --> 00:16:15,394
over thinking about either the infrastructure or the application,

245
00:16:15,512 --> 00:16:18,806
and you do that by using a single language. So there is no Yaml or

246
00:16:18,828 --> 00:16:22,454
typescript anymore. There is only one thing. And also is

247
00:16:22,492 --> 00:16:26,310
that from a deployment perspective,

248
00:16:27,530 --> 00:16:30,754
it's kind of an atomic system, it's a deployment unit.

249
00:16:30,882 --> 00:16:34,374
And you deploy the system has a whole in a single CI CD

250
00:16:34,422 --> 00:16:37,786
pipeline, so you no longer deploy the infrastructure and then you deploy the

251
00:16:37,808 --> 00:16:41,774
application on top of that. So with these three characteristics in mind,

252
00:16:41,892 --> 00:16:44,942
let's see how this look,

253
00:16:44,996 --> 00:16:49,018
I guess, concretely. And for that we're

254
00:16:49,034 --> 00:16:52,574
going to be using Pulumi again as a tool

255
00:16:52,612 --> 00:16:55,886
that I think is a good implementation of this pattern and particularly

256
00:16:55,998 --> 00:16:59,806
the metaprogramming aspect of Pulumi. So whilst you can use Pulumi

257
00:16:59,918 --> 00:17:03,774
to just create the infrastructure like you will do with terraform or CDK

258
00:17:03,822 --> 00:17:06,866
or cloudformation. Pulumi has some interesting,

259
00:17:06,968 --> 00:17:10,550
I guess, metaprogramming characteristics which allow

260
00:17:10,620 --> 00:17:14,454
us to kind of meet the three, have the three

261
00:17:14,492 --> 00:17:17,658
characteristics that I'm outlining here on

262
00:17:17,664 --> 00:17:21,194
the slide. Okay, so let's move to write

263
00:17:21,232 --> 00:17:22,380
some code then.

264
00:17:27,450 --> 00:17:32,010
Okay, so what we have here is, as you can see, is an empty

265
00:17:33,230 --> 00:17:36,618
kind of application. So what I'm going

266
00:17:36,624 --> 00:17:40,380
to do, I'm going to create an

267
00:17:41,790 --> 00:17:45,738
application in Pulumi. So we're

268
00:17:45,754 --> 00:17:49,486
going to say Pulumi new typescript. So what is this going to

269
00:17:49,508 --> 00:17:53,440
do? This is actually, okay, we need to

270
00:17:53,890 --> 00:17:57,442
make this empty. So what this is actually

271
00:17:57,496 --> 00:17:58,420
going to do.

272
00:18:18,320 --> 00:18:21,804
Okay, so we're going to create a new application

273
00:18:22,002 --> 00:18:25,656
with Pulumi. So Pulumi new typescript. I'm just instructed Pulumi,

274
00:18:25,768 --> 00:18:28,960
let's create a new typescript application. Let's give it a project name.

275
00:18:29,110 --> 00:18:37,890
I'm going to call test conf fourty two dollars

276
00:18:39,400 --> 00:18:49,074
and let's run this dev

277
00:18:49,112 --> 00:18:52,740
name for the stack. And now it's installing a bunch of

278
00:18:53,770 --> 00:18:58,198
dependencies, a bunch of

279
00:18:58,364 --> 00:19:01,654
NPM packages. So I'm using typescript here because that's kind

280
00:19:01,692 --> 00:19:05,240
of one of the language I'm used to.

281
00:19:05,610 --> 00:19:09,238
But of course Pulumi supports a

282
00:19:09,244 --> 00:19:13,666
bunch of different languages. So this was now created.

283
00:19:13,698 --> 00:19:17,110
So if we do Pulumi app, this is going now

284
00:19:17,180 --> 00:19:21,440
to create an application.

285
00:19:22,210 --> 00:19:25,482
So you can see he's asking me, I'm going to get a new stack.

286
00:19:25,626 --> 00:19:28,800
Do you want to create the application? Not, I'm going to say yes.

287
00:19:31,010 --> 00:19:35,026
And now this is happening in my own kind

288
00:19:35,048 --> 00:19:38,082
of account, right?

289
00:19:38,136 --> 00:19:41,634
So I still own kind of the

290
00:19:41,672 --> 00:19:45,080
cloud infrastructure under which this will run.

291
00:19:46,570 --> 00:19:50,454
So you can see this now is an empty application. I have a single

292
00:19:50,652 --> 00:19:54,786
index TS file, which is kind of standard for kind of typescript

293
00:19:54,978 --> 00:19:59,158
or node based application in general. And this

294
00:19:59,164 --> 00:20:02,540
is empty at the moment. So there's nothing in this application. So let's try to

295
00:20:03,470 --> 00:20:07,180
put something. Okay, so I'm just going to copy and paste this code.

296
00:20:07,550 --> 00:20:10,686
Now, what I'm creating here is a simple,

297
00:20:10,788 --> 00:20:14,926
I guess, HTTP rest API with

298
00:20:14,948 --> 00:20:18,814
the root on hello, which is going to return some

299
00:20:18,852 --> 00:20:23,010
JSon. So you can see here, I'm not defining any

300
00:20:23,080 --> 00:20:26,340
API gateway or any infrastructure as such.

301
00:20:26,710 --> 00:20:29,570
If you're familiar with Express as a framework, for example,

302
00:20:29,640 --> 00:20:33,026
this looks very much like Express, and I'm using

303
00:20:33,128 --> 00:20:37,974
one single file, one single language to create my

304
00:20:38,012 --> 00:20:41,366
application. Now I think before we can actually run this, I need to

305
00:20:41,388 --> 00:20:44,742
install the NPM package that I'm using here.

306
00:20:44,796 --> 00:20:48,938
So Pulumi cloud and

307
00:20:49,024 --> 00:20:52,220
let's try to run it. If you do pull me up.

308
00:20:52,990 --> 00:20:56,620
So this now will try to

309
00:20:58,110 --> 00:21:01,262
create the application for me.

310
00:21:01,316 --> 00:21:03,120
So let's give this a second,

311
00:21:13,210 --> 00:21:16,520
perform this update. I'm going to say yes.

312
00:21:23,370 --> 00:21:27,704
It say

313
00:21:27,742 --> 00:21:28,330
yes.

314
00:21:32,220 --> 00:21:49,672
And okay,

315
00:21:49,726 --> 00:21:53,156
so you can see that he did not manage to update

316
00:21:53,188 --> 00:21:56,796
this because he's asking for the cloud provider. And this

317
00:21:56,818 --> 00:22:00,348
is because I own this infrastructure. So I

318
00:22:00,354 --> 00:22:03,692
need to tell Pulumi on which cloud provider I want this

319
00:22:03,746 --> 00:22:07,072
application to be created. So I'm going to be doing that

320
00:22:07,126 --> 00:22:10,000
by saying the cloud provider I want to use is AWS.

321
00:22:14,900 --> 00:22:18,772
Okay. And then because of that I also

322
00:22:18,826 --> 00:22:22,980
need to install the AWS

323
00:22:23,720 --> 00:22:41,758
NPM package and

324
00:22:41,924 --> 00:22:46,074
I'm going to need to also tell in which region

325
00:22:46,122 --> 00:22:49,434
I want to run the application. So I need to give it some

326
00:22:49,492 --> 00:22:52,958
configuration about my WS environment. So I'm

327
00:22:52,974 --> 00:22:58,226
using EU west one and now I

328
00:22:58,248 --> 00:23:03,618
should be able to actually deploy

329
00:23:03,714 --> 00:23:04,600
the application.

330
00:23:08,650 --> 00:23:12,134
So you can see that this is now telling me

331
00:23:12,172 --> 00:23:15,514
it's going to create a number of

332
00:23:15,712 --> 00:23:19,114
AWS specific resources like

333
00:23:19,152 --> 00:23:22,326
API gateway and rest API and permission

334
00:23:22,518 --> 00:23:26,186
and staging. So pulumic is inferring what

335
00:23:26,288 --> 00:23:30,000
kind of the infrastructure should be

336
00:23:31,010 --> 00:23:34,526
based on the application I want to create. But if

337
00:23:34,548 --> 00:23:36,910
you look at this, this is like a single file,

338
00:23:39,830 --> 00:23:42,450
it's a single language.

339
00:23:43,190 --> 00:23:46,658
I haven't specified any infrastructure myself.

340
00:23:46,744 --> 00:23:50,546
I didn't talk about lambda at all. I'm just saying this is

341
00:23:50,568 --> 00:23:53,766
my code for the application. So I am given a

342
00:23:53,788 --> 00:23:57,494
URL while the application is

343
00:23:57,532 --> 00:24:01,480
running. So let's have a look at that. So let me share,

344
00:24:04,190 --> 00:24:06,540
let me share this so you can see,

345
00:24:11,390 --> 00:24:16,506
okay, so if I do hello, here you

346
00:24:16,528 --> 00:24:20,094
can see my hello world. So my application was

347
00:24:20,132 --> 00:24:24,160
deployed. Okay, let's see something more that we can actually do

348
00:24:27,490 --> 00:24:30,654
here. So another thing, for example that

349
00:24:30,692 --> 00:24:36,002
we could do would be to actually maybe

350
00:24:36,056 --> 00:24:39,746
define a queue. So if

351
00:24:39,768 --> 00:24:43,358
I want something to actually happen asynchronously.

352
00:24:43,454 --> 00:24:46,470
So you can see here I can define a queue,

353
00:24:47,050 --> 00:24:50,854
and here I'm being explicit about there is like an

354
00:24:50,892 --> 00:24:54,840
AWS queue and what the queue is. But then I can say

355
00:24:56,330 --> 00:25:00,086
when there is an event on this queue, I want to run some code,

356
00:25:00,188 --> 00:25:03,802
this console log, it's my code here.

357
00:25:03,856 --> 00:25:07,146
And again, this is usually like for example a callback function,

358
00:25:07,248 --> 00:25:11,146
which as a typescript or JavaScript developer you might be very familiar

359
00:25:11,178 --> 00:25:14,906
with. Also the thing that I can do here, I can share code

360
00:25:14,938 --> 00:25:20,858
between you. I can say I have a constant of variable

361
00:25:21,034 --> 00:25:24,466
and this is const of dummy and

362
00:25:24,488 --> 00:25:28,500
this has some value and actually

363
00:25:28,870 --> 00:25:33,860
you can go ahead and use this dummy value

364
00:25:34,570 --> 00:25:38,230
everywhere. You can use it in here or you can use it in here.

365
00:25:38,300 --> 00:25:41,990
As you can see it's one application, one file,

366
00:25:46,410 --> 00:25:50,842
I guess one thing. So I can actually go

367
00:25:50,896 --> 00:25:54,140
ahead and then run this.

368
00:25:56,110 --> 00:25:59,322
And now behind the scene this is going to

369
00:25:59,376 --> 00:26:03,146
create for me an sqs queue, and I'm

370
00:26:03,178 --> 00:26:06,586
assuming a lambda function with the trigger on that sqs queue.

371
00:26:06,698 --> 00:26:11,182
But you can see I've done all of this using one

372
00:26:11,236 --> 00:26:15,370
single language, no terraform,

373
00:26:15,450 --> 00:26:18,702
no yaml, no cdk. My entire

374
00:26:18,756 --> 00:26:22,798
application is in one file. So what I coded is

375
00:26:22,964 --> 00:26:26,374
the platform, the system rather than the

376
00:26:26,412 --> 00:26:29,986
infrastructure on one hand and then the application on the other hand. And I'm

377
00:26:30,018 --> 00:26:34,470
using construct and paradigms that as a developer

378
00:26:36,410 --> 00:26:39,100
I'm very familiar with.

379
00:26:40,270 --> 00:26:43,654
And this is just I guess an abstraction

380
00:26:43,702 --> 00:26:48,906
layer on top of the application because all of this is still running in

381
00:26:48,928 --> 00:26:54,014
my own AWS environment. And you can see there

382
00:26:54,052 --> 00:26:58,394
is some knowledge about infrastructure

383
00:26:58,442 --> 00:27:01,710
because here you are defining a queue explicitly.

384
00:27:04,230 --> 00:27:04,980
Okay,

385
00:27:09,310 --> 00:27:13,722
so hopefully you would have seen how

386
00:27:13,856 --> 00:27:17,840
something like the metaprogramming language of Plumi could help

387
00:27:19,410 --> 00:27:22,622
writing an application like this and thinking

388
00:27:22,676 --> 00:27:25,600
about the platform rather than infrastructure and application.

389
00:27:27,490 --> 00:27:32,574
I guess the next pattern

390
00:27:32,622 --> 00:27:36,354
I want to talk about is infrastructure from code. And I guess

391
00:27:36,392 --> 00:27:40,354
it's an evolution on top of platform s code that we

392
00:27:40,392 --> 00:27:44,418
just discussed. And the idea is whats we're

393
00:27:44,434 --> 00:27:47,974
going to have, application driven system. So all we

394
00:27:48,012 --> 00:27:52,002
think about is the application. So we forget

395
00:27:52,066 --> 00:27:55,354
about the cloud or the

396
00:27:55,392 --> 00:27:58,506
infrastructure that we even need to run the application.

397
00:27:58,688 --> 00:28:02,714
And that infrastructure just becomes a

398
00:28:02,752 --> 00:28:07,134
sub resource of the application, it gets inferred from

399
00:28:07,172 --> 00:28:10,654
the application. So the

400
00:28:10,692 --> 00:28:14,382
application is scared at first and then the infrastructure becomes a side effect

401
00:28:14,516 --> 00:28:18,894
of that application. And the idea here would be that the

402
00:28:18,932 --> 00:28:22,414
system whats I built, it's decoupled from any cloud provider.

403
00:28:22,462 --> 00:28:26,610
Like I write some code and I run this code somewhere

404
00:28:27,670 --> 00:28:31,102
I don't own anymore, I guess the cloud provider on which this code

405
00:28:31,176 --> 00:28:33,974
is running. Okay,

406
00:28:34,012 --> 00:28:38,280
so let's use again

407
00:28:39,210 --> 00:28:43,080
a tool to show this,

408
00:28:43,390 --> 00:28:47,146
and the tool I want to use to show

409
00:28:47,168 --> 00:28:51,450
you this is serverless cloud. So serverless cloud is a new offering

410
00:28:52,350 --> 00:28:56,170
from the same company whats runs the serverless framework.

411
00:28:56,750 --> 00:29:00,478
And I think again, it's just for me a good implementation of

412
00:29:00,644 --> 00:29:04,318
the infrastructure from code pattern that I want to show you.

413
00:29:04,404 --> 00:29:07,806
So let's see, we start again from

414
00:29:07,828 --> 00:29:11,390
an empty directory. So I've pasted

415
00:29:11,550 --> 00:29:14,898
some code snippets to run. Okay, so the

416
00:29:14,904 --> 00:29:18,434
first thing we're going to do, we are actually going to run create

417
00:29:18,472 --> 00:29:22,066
a new application cloud is kind of a

418
00:29:22,088 --> 00:29:25,766
little cli to kind of manage serverless cloud application.

419
00:29:25,868 --> 00:29:29,158
I'm going to say create a new one. I want to create a new application

420
00:29:29,244 --> 00:29:33,886
in typescript. So yes, I want to create a new one. I confirm

421
00:29:34,018 --> 00:29:41,366
I want to use typescript,

422
00:29:41,478 --> 00:29:50,918
I give it a name bigger.

423
00:29:51,014 --> 00:29:54,620
So let's call it cloud 42.

424
00:29:55,630 --> 00:29:58,380
Now this is installing a bunch of things.

425
00:30:00,430 --> 00:30:03,814
So you can see already kind of a structure emerged

426
00:30:03,862 --> 00:30:07,790
here, again with an index ts kind of file, again very

427
00:30:07,940 --> 00:30:11,006
similar to what we've done before. And one of the things that is

428
00:30:11,028 --> 00:30:17,314
interesting here, if it is like it's connecting to

429
00:30:17,352 --> 00:30:21,442
my personal sandbox. So I'm already without

430
00:30:21,576 --> 00:30:25,070
doing anything, without configuring any AWS or azure environment,

431
00:30:25,150 --> 00:30:28,934
I was given a URL in which my

432
00:30:28,972 --> 00:30:32,370
application is running, so they are hosting

433
00:30:32,530 --> 00:30:36,614
the infrastructure for the infrastructure for

434
00:30:36,652 --> 00:30:39,818
me. So let's try to write some code.

435
00:30:39,904 --> 00:30:43,066
So maybe what we

436
00:30:43,088 --> 00:30:46,826
can do is I'm going to get rid of all of these and

437
00:30:46,848 --> 00:30:51,100
I'm going to have a very simple

438
00:30:52,670 --> 00:30:56,158
hello word. So you

439
00:30:56,164 --> 00:31:00,458
can see this is very much like express

440
00:31:00,634 --> 00:31:03,886
like kind of structure when I

441
00:31:03,908 --> 00:31:07,518
just give it a URL and then define

442
00:31:07,534 --> 00:31:11,026
my API and this is what I'm going to monitor on. So the

443
00:31:11,048 --> 00:31:14,642
interesting thing is that the moment I save this, this gets

444
00:31:14,696 --> 00:31:18,210
updated in my kind of remote cloud test environment.

445
00:31:18,290 --> 00:31:21,266
So if I open up this URL,

446
00:31:21,458 --> 00:31:24,854
maybe let's open up the browser as well here. So you can see if I

447
00:31:24,892 --> 00:31:31,994
open up this URL and

448
00:31:32,032 --> 00:31:33,500
I do hello.

449
00:31:36,590 --> 00:31:39,914
So you can see, I don't know if you can see this, but I

450
00:31:39,952 --> 00:31:43,710
have my hello word, my hello word

451
00:31:43,780 --> 00:31:47,118
here responded. And again,

452
00:31:47,204 --> 00:31:52,030
no cloud configuration words whatsoever.

453
00:31:52,610 --> 00:31:56,002
I just defined the API and they're running

454
00:31:56,056 --> 00:31:59,602
this for me. So let's look at some more interesting things

455
00:31:59,656 --> 00:32:02,100
that maybe we can do.

456
00:32:02,710 --> 00:32:06,466
So you can see here, you get the primitive, so you get an

457
00:32:06,488 --> 00:32:10,174
API, you can deal with some data, you can do some scheduling,

458
00:32:10,222 --> 00:32:13,906
and you can have some kind of environmental parameters as well.

459
00:32:14,008 --> 00:32:17,586
And those kind of primitives are the ones on top of

460
00:32:17,608 --> 00:32:21,114
which I can build essentially my

461
00:32:21,152 --> 00:32:24,460
application. So maybe let's look at some data. One,

462
00:32:25,950 --> 00:32:29,174
so I'm just coming to copy those kind of two API

463
00:32:29,222 --> 00:32:32,682
here where you have an endpoint here to store the data

464
00:32:32,736 --> 00:32:36,590
and one to get the data. So you can see that I can use

465
00:32:36,660 --> 00:32:40,446
the primitive data here to kind of store

466
00:32:40,548 --> 00:32:44,418
some data and then I'm going to

467
00:32:44,424 --> 00:32:47,362
get some data. So the moment I save this again,

468
00:32:47,416 --> 00:32:54,530
look how fast this is. This is already kind of synced

469
00:32:55,110 --> 00:32:59,174
with my cloud environment. So if we're going to open this

470
00:32:59,212 --> 00:33:03,030
one up again, so let's look at the browser.

471
00:33:04,730 --> 00:33:08,040
So we have get data, store data. So if I do get data,

472
00:33:09,770 --> 00:33:13,034
since this is returning nothing because I haven't stored the data yet,

473
00:33:13,072 --> 00:33:14,620
and then if I do store data,

474
00:33:16,750 --> 00:33:20,220
the value is stored, and then if I do get data again,

475
00:33:22,030 --> 00:33:26,218
I get the value back. So again, you can see that here I'm

476
00:33:26,234 --> 00:33:29,418
dealing already with data. I haven't defined any database myself, I don't

477
00:33:29,434 --> 00:33:33,530
even know what the database is. I'm assuming it's dynamodb running in

478
00:33:33,540 --> 00:33:37,506
AWs. But I have no idea and nor I care at

479
00:33:37,528 --> 00:33:42,034
this stage because this is all run for

480
00:33:42,072 --> 00:33:45,170
me behind the scene.

481
00:33:45,690 --> 00:33:49,800
The other interesting thing that we can look at is

482
00:33:52,170 --> 00:33:55,782
scheduling. For example, the other primitive that we have available here

483
00:33:55,836 --> 00:33:59,450
is scheduling. So you can see I can schedule something

484
00:33:59,520 --> 00:34:04,074
to happen every minute and if

485
00:34:04,112 --> 00:34:08,010
I save this, this will be deployed and you will also get

486
00:34:08,080 --> 00:34:11,950
direct logging

487
00:34:12,850 --> 00:34:16,000
in your console, in your terminal here.

488
00:34:16,930 --> 00:34:21,070
And so this I guess also solves some of the problem

489
00:34:21,220 --> 00:34:25,134
with serverless around the local development

490
00:34:25,182 --> 00:34:28,642
story, which is not, I guess,

491
00:34:28,776 --> 00:34:32,914
the boost in terms of tooling and

492
00:34:32,952 --> 00:34:36,630
ecosystem. But of course you can do, I guess,

493
00:34:36,700 --> 00:34:40,374
more complex things like with the

494
00:34:40,412 --> 00:34:42,280
data. So for example,

495
00:34:44,410 --> 00:34:47,942
one of the other things that we can look

496
00:34:47,996 --> 00:34:51,890
at is here,

497
00:34:52,060 --> 00:34:55,450
this would allow you to do query, for example.

498
00:34:55,520 --> 00:34:59,386
So if you look at something like an API like

499
00:34:59,408 --> 00:35:02,906
this, SS users, where you can get the data from

500
00:35:02,928 --> 00:35:06,334
the user, and here we're getting all of the users, but here you could write

501
00:35:06,372 --> 00:35:09,614
query. So this does give

502
00:35:09,652 --> 00:35:13,722
you ability to actually operate with dagger, a little bit more complex

503
00:35:13,866 --> 00:35:17,458
data structure. And you can see here I'm getting also the logs for the

504
00:35:17,464 --> 00:35:20,722
scheduler function I've created before and

505
00:35:20,776 --> 00:35:23,762
all I has to do is just to save it and everything is running behind

506
00:35:23,816 --> 00:35:27,586
the scene. And again, this is a step forward on what

507
00:35:27,608 --> 00:35:31,106
we talked about before. No, it's still a single language,

508
00:35:31,218 --> 00:35:34,486
it's all typescript or c sharp or go,

509
00:35:34,508 --> 00:35:38,082
whatever language you want to go for, but I only care.

510
00:35:38,156 --> 00:35:42,150
But those primitives, I don't even know now what kind of infrastructure

511
00:35:42,230 --> 00:35:47,626
or cloud environment this

512
00:35:47,648 --> 00:35:51,290
is running on. I guess some interesting

513
00:35:51,360 --> 00:35:55,034
thing that you can do here. This is kind of my now local development

514
00:35:55,082 --> 00:35:59,902
environment which is running to the cloud, but I can actually create

515
00:35:59,956 --> 00:36:03,434
a copy of that environment by sharing

516
00:36:03,482 --> 00:36:07,106
it with someone. I can type this kind of share command here.

517
00:36:07,208 --> 00:36:10,770
And what this is doing behind the scene is creating a new copy

518
00:36:11,590 --> 00:36:15,406
of the environment and it will give me a new URL

519
00:36:15,598 --> 00:36:19,286
and then I can share that URL with a team member or a

520
00:36:19,308 --> 00:36:22,662
QA. And the interesting idea here is that as

521
00:36:22,716 --> 00:36:26,790
part of that new environment that is getting created,

522
00:36:30,170 --> 00:36:34,326
it also contains the data. So whatever data I've

523
00:36:34,358 --> 00:36:37,914
created so far, and I think I've created one entry with the

524
00:36:37,952 --> 00:36:41,318
kind of store data, that data will be there. And in fact, if I'm

525
00:36:41,334 --> 00:36:44,558
going to open now this new URL which I was given,

526
00:36:44,724 --> 00:36:48,426
let me show you the browser. And I do on this new URL

527
00:36:48,538 --> 00:36:51,934
get data. You see, I already

528
00:36:52,052 --> 00:36:56,434
the value in because also the data was

529
00:36:56,472 --> 00:36:59,746
actually copied over. And of

530
00:36:59,768 --> 00:37:02,814
course, I guess from here I can then do deployment.

531
00:37:02,862 --> 00:37:06,210
So I can actually do deploy to prod.

532
00:37:07,270 --> 00:37:10,946
And now that I am deploying in

533
00:37:10,968 --> 00:37:15,926
prod, actually one

534
00:37:15,948 --> 00:37:19,002
thing that we're going to see is that data will not be synced, right?

535
00:37:19,056 --> 00:37:23,290
Because when you deploy in an actual environment,

536
00:37:25,070 --> 00:37:29,242
you only want to have the actual code or

537
00:37:29,296 --> 00:37:33,134
application deployed, but not the

538
00:37:33,172 --> 00:37:37,114
data itself. Now, because the product environment does not exist

539
00:37:37,162 --> 00:37:41,054
for this application. Again, behind the scene, this is also creating the environment for

540
00:37:41,092 --> 00:37:45,010
me. It will give me a new URL

541
00:37:45,430 --> 00:37:48,802
and that's now kind of the production URL. And then any

542
00:37:48,856 --> 00:37:53,070
change I will be doing on my local environment here, it will not affect

543
00:37:53,230 --> 00:37:56,790
production. That's still my local environment.

544
00:37:59,370 --> 00:38:00,600
Okay, cool.

545
00:38:02,650 --> 00:38:06,086
Yeah. So hopefully you may have seen that how

546
00:38:06,188 --> 00:38:09,734
something like this, I guess, can help us implementing the infrastructure

547
00:38:09,782 --> 00:38:13,306
from code pattern, where we do

548
00:38:13,328 --> 00:38:16,474
a step forward and really think

549
00:38:16,512 --> 00:38:19,866
about the application as the main thing that

550
00:38:19,888 --> 00:38:24,334
we code rather than the infrastructure that

551
00:38:24,372 --> 00:38:28,302
runs it. And in this case, with this particular tool, we are also

552
00:38:28,356 --> 00:38:32,894
offloading against the run of the infrastructure to

553
00:38:32,932 --> 00:38:34,020
somebody else.

554
00:38:36,150 --> 00:38:39,700
That is everything I had for you for today.

555
00:38:40,150 --> 00:38:43,778
So if you have any questions or you are interested

556
00:38:43,864 --> 00:38:47,314
in understanding more about some

557
00:38:47,352 --> 00:38:50,466
of the patterns that we discussed today, please drop me an

558
00:38:50,488 --> 00:38:53,982
email or follow me on Twitter at mimotzo.

559
00:38:54,046 --> 00:38:57,486
And I'm happy to engage in conversation about those topics.

560
00:38:57,678 --> 00:38:59,800
Thank you, you very much and you have a good rest of your day.

