1
00:00:00,250 --> 00:00:04,830
Are you an SRE, a developer,

2
00:00:06,610 --> 00:00:09,754
a quality engineer who wants to tackle the challenge

3
00:00:09,802 --> 00:00:13,274
of improving reliability in your DevOps? You can enable

4
00:00:13,322 --> 00:00:16,510
your DevOps for reliability with chaos native.

5
00:00:16,930 --> 00:00:19,530
Create your free account at Chaos native.

6
00:00:19,610 --> 00:01:17,398
Litmus Cloud hi,

7
00:01:17,564 --> 00:01:20,806
I'm Yushai with Linearb and today I'm going to talk

8
00:01:20,828 --> 00:01:24,182
about cycle time. I'm going to talk about what is cycle time

9
00:01:24,236 --> 00:01:27,714
and how do you use that to measure and help your dev teams improve.

10
00:01:27,842 --> 00:01:31,146
I'm going to talk about why cycle time should be

11
00:01:31,168 --> 00:01:34,806
the first metric you should be looking at when you're just beginning

12
00:01:34,838 --> 00:01:38,250
to introduce metrics and measurements to your dev process.

13
00:01:38,400 --> 00:01:42,570
And finally, I'm going to talk about why just measuring and

14
00:01:42,640 --> 00:01:46,586
collecting information and metrics and dashboards is a good first step,

15
00:01:46,688 --> 00:01:50,094
but is not enough to really push your dev team

16
00:01:50,132 --> 00:01:53,534
and your dev process to its best. I'm going to show the

17
00:01:53,572 --> 00:01:57,086
next steps beyond metrics and how you can use them to really improve

18
00:01:57,118 --> 00:02:00,526
your dev team. Linearb is a startup that's

19
00:02:00,558 --> 00:02:04,546
all about improving dev teams and improving the dev process.

20
00:02:04,728 --> 00:02:08,646
We deliver software delivery intelligence by

21
00:02:08,748 --> 00:02:11,926
providing dev teams with the right information at

22
00:02:11,948 --> 00:02:15,926
the right time in the right place so that they can improve without an

23
00:02:15,948 --> 00:02:20,314
effort. So let's start talking about the

24
00:02:20,352 --> 00:02:24,410
problem or the goal of measuring the engineering process.

25
00:02:24,480 --> 00:02:27,642
Why do we need to measure things? So I think it's pretty

26
00:02:27,696 --> 00:02:31,574
common, that common knowledge that you can't really improve

27
00:02:31,622 --> 00:02:35,150
anything if you're not able to measure it, if you're not able to compare,

28
00:02:35,650 --> 00:02:39,370
how was I doing or how was the team doing yesterday?

29
00:02:39,450 --> 00:02:42,218
How we're doing now? What has changed?

30
00:02:42,394 --> 00:02:45,874
Once you have some baseline and you have some numbers

31
00:02:45,992 --> 00:02:49,362
that you can use to describe some

32
00:02:49,416 --> 00:02:53,838
model of your dev process, you can start talking about improving,

33
00:02:54,014 --> 00:02:57,750
about making these numbers look better and reflecting

34
00:02:58,730 --> 00:03:03,190
the improvement that your team is making by adopting better process,

35
00:03:03,610 --> 00:03:07,882
by removing obstacles and

36
00:03:07,936 --> 00:03:12,074
blockages during the process. So measuring is

37
00:03:12,112 --> 00:03:15,930
important, but how do we measure the work of developers

38
00:03:16,670 --> 00:03:20,300
and development teams without really

39
00:03:20,850 --> 00:03:24,320
falling into traps? Like measuring the wrong things,

40
00:03:25,330 --> 00:03:29,150
like creating a culture problem where people

41
00:03:29,220 --> 00:03:32,910
feel they're being measured for the raw output.

42
00:03:34,230 --> 00:03:38,740
We've all seen previous cases where

43
00:03:39,270 --> 00:03:42,994
you measure the wrong thing. You get people optimizing for

44
00:03:43,032 --> 00:03:47,270
things like code lines or pull requests

45
00:03:47,690 --> 00:03:51,400
or comment in the code. That's not the thing you want to get.

46
00:03:51,850 --> 00:03:56,022
And it creates a really bad culture of big

47
00:03:56,076 --> 00:04:00,666
Brother. I'm being stack ranked against the other developers and

48
00:04:00,688 --> 00:04:04,294
we all know that development is can artistic or creative

49
00:04:04,342 --> 00:04:08,054
process where measuring raw output

50
00:04:08,102 --> 00:04:11,020
is probably not going to get you what you want.

51
00:04:11,790 --> 00:04:15,022
So on one hand, you want to start measuring things.

52
00:04:15,076 --> 00:04:18,714
On the other hand, you want to make sure you're measuring

53
00:04:18,762 --> 00:04:22,222
the right thing. And the right thing in development is

54
00:04:22,276 --> 00:04:25,860
the team and the process. Instead of focusing on

55
00:04:26,310 --> 00:04:31,150
individual metrics, instead of focusing on technical

56
00:04:31,230 --> 00:04:35,650
metrics like code lines, like commits,

57
00:04:36,070 --> 00:04:39,922
things that are easy to game and that don't really get you any benefit,

58
00:04:40,066 --> 00:04:43,782
you should be measuring the process. You should be looking at how is the team

59
00:04:43,836 --> 00:04:47,618
working? Can we find places where

60
00:04:47,724 --> 00:04:52,166
the process is not efficient? Can we shine

61
00:04:52,198 --> 00:04:55,414
a light on things that kill productivity?

62
00:04:55,542 --> 00:04:59,366
And I'm showing here three of the top productivity killers

63
00:04:59,398 --> 00:05:03,066
in dev teams. One of them is context switches.

64
00:05:03,178 --> 00:05:07,434
Can we eliminate or reduce needless

65
00:05:07,482 --> 00:05:11,470
context switching where people have to switch between tasks,

66
00:05:12,950 --> 00:05:15,570
load some new context into their brains,

67
00:05:16,230 --> 00:05:19,394
then drop that context for doing something else, then go

68
00:05:19,432 --> 00:05:24,434
back. There's a huge cognitive load and

69
00:05:24,552 --> 00:05:28,290
a real productivity tax. When you switch between tasks

70
00:05:28,370 --> 00:05:31,670
and when you finish working on something, then start

71
00:05:31,820 --> 00:05:35,922
looking at a new thing and then go back to your initial or original

72
00:05:36,066 --> 00:05:39,738
task, you're going to spend a lot of time. Some research puts that

73
00:05:39,744 --> 00:05:43,914
at least 20 minutes just to get back into something that you

74
00:05:43,952 --> 00:05:47,126
may have been working on earlier this morning or yesterday.

75
00:05:47,238 --> 00:05:50,374
So context switching is a well known

76
00:05:50,422 --> 00:05:53,726
pain in the development process. There is the

77
00:05:53,748 --> 00:05:57,098
issue of work in progress, and it's

78
00:05:57,194 --> 00:06:01,102
kind of a dual to context switching, where people

79
00:06:01,156 --> 00:06:04,722
like CTO start things. There's always a lot of things to do.

80
00:06:04,776 --> 00:06:08,526
Dev teams are always busy and it feels

81
00:06:08,558 --> 00:06:11,662
good to start thing to get something started on an item.

82
00:06:11,726 --> 00:06:15,478
Typically that's the interesting part of working on an issue

83
00:06:15,564 --> 00:06:18,550
or a fix of a bug or some new feature,

84
00:06:19,610 --> 00:06:23,590
whereas pushing something to completion requires

85
00:06:24,570 --> 00:06:28,242
collaboration with other people to get code reviews. CTO eventually

86
00:06:28,306 --> 00:06:32,186
merge your code and to deploy it. So a

87
00:06:32,208 --> 00:06:35,658
lot of teams eventually end up with a lot of things

88
00:06:35,744 --> 00:06:39,322
happening together, a lot of work in progress, and it really takes

89
00:06:39,376 --> 00:06:43,360
discipline and mindfulness to be

90
00:06:44,530 --> 00:06:47,630
able to keep the work in progress low

91
00:06:47,780 --> 00:06:51,038
and focus on finishing things before starting new things.

92
00:06:51,124 --> 00:06:54,894
So a lot of work in progress will cause context switching,

93
00:06:54,942 --> 00:06:59,074
will increase risk of delivery, and is

94
00:06:59,112 --> 00:07:02,274
another well known pain around dev

95
00:07:02,312 --> 00:07:05,906
team productivity. And finally, there's what

96
00:07:05,928 --> 00:07:09,170
we call dead value. You worked on can item.

97
00:07:09,250 --> 00:07:12,822
It could be a bug fix or a new feature. You had

98
00:07:12,876 --> 00:07:16,342
your pull request reviewed, you made some changes, you finally

99
00:07:16,396 --> 00:07:19,994
got this approved and you merged the code. But now this

100
00:07:20,032 --> 00:07:24,378
is waiting to be deployed. In some places this could be hours,

101
00:07:24,464 --> 00:07:28,282
days, weeks, even months. At the high

102
00:07:28,336 --> 00:07:31,630
end of the scale. This is value

103
00:07:31,700 --> 00:07:35,646
that has been created, but it's sitting there until it's deployed and

104
00:07:35,748 --> 00:07:39,354
actually helping customers actually live in production.

105
00:07:39,482 --> 00:07:43,122
This is dead value and you're not learning anything.

106
00:07:43,256 --> 00:07:46,994
The team is not learning anything. The company is not learning anything by

107
00:07:47,032 --> 00:07:50,622
having that code sit there in your master

108
00:07:50,686 --> 00:07:54,158
or development branch but not deployed.

109
00:07:54,334 --> 00:07:57,542
Your risk when deploying things, the more

110
00:07:57,596 --> 00:08:00,434
code that is waiting to be deployed, the higher the risk.

111
00:08:00,562 --> 00:08:04,646
So being able to ship code all the way

112
00:08:04,748 --> 00:08:08,314
into production rapidly, as again, a well

113
00:08:08,352 --> 00:08:11,626
known source of increased productivity and

114
00:08:11,648 --> 00:08:15,146
having dead value in your code base, is a well

115
00:08:15,168 --> 00:08:19,386
known pain. So how do we measure the

116
00:08:19,408 --> 00:08:23,694
process and the way the team works to eliminate these and

117
00:08:23,732 --> 00:08:27,486
similar productivity killers? Notice that I'm not focusing at

118
00:08:27,508 --> 00:08:31,902
all about individual developers or about

119
00:08:31,956 --> 00:08:35,550
output. This is about looking at the process and highlighting

120
00:08:35,630 --> 00:08:39,582
inefficiencies, highlighting opportunities

121
00:08:39,646 --> 00:08:43,214
to improve. So the single metric

122
00:08:43,262 --> 00:08:46,354
that I'm proposing that you start with

123
00:08:46,392 --> 00:08:50,306
if you're not measuring anything today, or that you add to your metrics,

124
00:08:50,338 --> 00:08:53,686
if you already are measuring things, is cycle time.

125
00:08:53,788 --> 00:08:57,850
Cycle time is a pretty well known metric. It's got

126
00:08:57,920 --> 00:09:01,642
some recent attention in the

127
00:09:01,696 --> 00:09:05,334
past few years. You can look at the accelerate

128
00:09:05,382 --> 00:09:09,100
book or look at the Dora metrics and

129
00:09:09,550 --> 00:09:13,914
in different variations. Cycle time has become a

130
00:09:13,952 --> 00:09:18,042
pretty well known standard for modern measurement

131
00:09:18,106 --> 00:09:21,230
of modern dev teams and dev processes.

132
00:09:21,570 --> 00:09:25,460
So what is cycle time? Cycle time focuses on

133
00:09:25,830 --> 00:09:29,906
how long does it take the team CTO deliver a piece of work end

134
00:09:29,928 --> 00:09:33,746
to end, starting with when we first start to code

135
00:09:33,848 --> 00:09:36,646
against an issue.

136
00:09:36,748 --> 00:09:40,566
It could be fixing a bug, introducing a

137
00:09:40,588 --> 00:09:43,560
new feature, doing some non functional work,

138
00:09:44,730 --> 00:09:48,106
but we begin to code it. Typically this lives as a

139
00:09:48,128 --> 00:09:51,850
branch or a set of branches that progress

140
00:09:52,670 --> 00:09:55,914
and the code base and eventually the

141
00:09:55,952 --> 00:09:59,562
product and the deployed services are

142
00:09:59,616 --> 00:10:02,174
modified through a change in the code,

143
00:10:02,372 --> 00:10:05,374
some form of code review,

144
00:10:05,572 --> 00:10:09,114
typically a pull request or a merge request that gets reviewed

145
00:10:09,242 --> 00:10:11,920
by peers in my team,

146
00:10:12,710 --> 00:10:16,110
after some back and forth, it gets approved,

147
00:10:16,270 --> 00:10:18,260
it gets merged. CTO,

148
00:10:19,590 --> 00:10:23,662
the main code base, and eventually gates deployed

149
00:10:23,726 --> 00:10:27,670
to serve its purpose in production settings.

150
00:10:28,330 --> 00:10:32,438
The time it takes from the beginning CTO, the end of this entire process

151
00:10:32,604 --> 00:10:36,358
is what we call cycle time. And when you measure that across

152
00:10:36,444 --> 00:10:40,410
all of your bits and pieces of work, all of your branches and

153
00:10:40,480 --> 00:10:44,282
pull requests, you get some idea

154
00:10:44,336 --> 00:10:48,140
of how quickly the team is able to turn around value.

155
00:10:49,070 --> 00:10:53,646
And it turns out in a lot of research in the

156
00:10:53,668 --> 00:10:57,326
accelerate book and others shows that there

157
00:10:57,348 --> 00:11:00,730
is a very high correlation between consistently

158
00:11:00,810 --> 00:11:04,370
reducing and having short cycle time to

159
00:11:04,440 --> 00:11:08,306
well performing and elite performing teams. Let me

160
00:11:08,408 --> 00:11:12,786
drill down a bit into the four main segments of

161
00:11:12,808 --> 00:11:15,940
the cycle time and why each of them is important.

162
00:11:16,810 --> 00:11:21,320
CTO measure and to understand as a separate part of cycle time.

163
00:11:21,690 --> 00:11:25,446
So the first piece is coding. Typically a

164
00:11:25,468 --> 00:11:28,746
developer begins to work on a new piece of

165
00:11:28,768 --> 00:11:31,786
work by creating a branch and starting CTO code.

166
00:11:31,968 --> 00:11:35,846
The changes and the additions required to serve

167
00:11:36,038 --> 00:11:39,740
the purpose of this change. They could be

168
00:11:40,850 --> 00:11:44,254
fixing some existing code or refactoring. They could be adding new

169
00:11:44,292 --> 00:11:48,320
code, adding tests, whatever is needed to get this change

170
00:11:48,690 --> 00:11:53,106
into the code base. This is typically the

171
00:11:53,128 --> 00:11:57,250
work of a single person. Again, there's no always

172
00:11:57,400 --> 00:12:01,442
in code development, but typically this is a single person working

173
00:12:01,496 --> 00:12:05,246
on a slice or a piece of functionality

174
00:12:05,358 --> 00:12:07,400
that's being added to the code base.

175
00:12:08,090 --> 00:12:11,720
When that is done, and when the developer feels this is ready for review,

176
00:12:14,650 --> 00:12:17,826
the developer basically creates a pull request or a merge request

177
00:12:17,858 --> 00:12:21,562
or a similar process, and the coding phase is

178
00:12:21,616 --> 00:12:24,970
over. So coding measures the time it takes for me to

179
00:12:25,120 --> 00:12:28,540
begin working on something until it's ready for review.

180
00:12:29,390 --> 00:12:32,954
The next phase is pickup, where my pull request

181
00:12:33,082 --> 00:12:35,680
is waiting for someone to take a look at it.

182
00:12:36,050 --> 00:12:40,218
Pickup is basically a dead there's

183
00:12:40,234 --> 00:12:43,714
no value happening in this segment. It's all about

184
00:12:43,752 --> 00:12:47,602
waiting for someone to begin reviewing. So once

185
00:12:47,656 --> 00:12:51,346
someone actually picks up the pull request and begins to

186
00:12:51,448 --> 00:12:55,394
create some review, begins to review my code, provide some

187
00:12:55,432 --> 00:12:59,266
comments, that is when pickup ends and the review process begins.

188
00:12:59,378 --> 00:13:02,982
So pickup is how long does it take for the team to

189
00:13:03,116 --> 00:13:07,350
pick up a piece of change that I have requested

190
00:13:07,790 --> 00:13:11,420
review on and begin to actually review it?

191
00:13:12,110 --> 00:13:15,914
Then the review phase is about the

192
00:13:15,952 --> 00:13:19,542
entire back and forth dance between multiple

193
00:13:19,606 --> 00:13:23,274
people, at least the original coder

194
00:13:23,322 --> 00:13:26,414
and one reviewer, sometimes in many cases more

195
00:13:26,452 --> 00:13:30,462
than one reviewer, commenting, making additional changes

196
00:13:30,516 --> 00:13:35,166
to the code and eventually reaching a

197
00:13:35,188 --> 00:13:38,546
decision that the change is good enough and can be merged to the

198
00:13:38,568 --> 00:13:42,290
code base. So the review phase ends when the

199
00:13:42,360 --> 00:13:45,814
code is merged back to the code base and the change is

200
00:13:45,852 --> 00:13:49,974
accepted. So review captures the time it takes

201
00:13:50,012 --> 00:13:54,134
for the team to actually look at

202
00:13:54,172 --> 00:13:57,930
a piece of change to the code base, discuss it

203
00:13:58,000 --> 00:14:01,530
either asynchronously or in other means,

204
00:14:01,680 --> 00:14:05,130
and reach a conclusion that this is accepted,

205
00:14:05,550 --> 00:14:09,258
and actually merge it back to the code base. Finally,

206
00:14:09,344 --> 00:14:12,586
the deploy phase talks about how long does

207
00:14:12,608 --> 00:14:16,160
it take the teams to take this piece of code that it's already

208
00:14:17,170 --> 00:14:20,606
back in the code base, the code base has already changed. How long

209
00:14:20,628 --> 00:14:23,870
does it take the team to actually get this to work in production,

210
00:14:23,950 --> 00:14:27,058
to actually serve its purpose by

211
00:14:27,144 --> 00:14:30,500
improving the users or customers

212
00:14:30,950 --> 00:14:36,146
experience, by improving some other non functional goal,

213
00:14:36,258 --> 00:14:38,870
by fixing a bug, et cetera.

214
00:14:39,450 --> 00:14:42,994
And once we have completed that, the entire cycle,

215
00:14:43,042 --> 00:14:46,486
time for this piece of change can

216
00:14:46,508 --> 00:14:50,410
now be measured from end to end. And when we look at this across

217
00:14:50,480 --> 00:14:53,894
all of the changes the team is pushing, you get a measure

218
00:14:54,022 --> 00:14:57,418
that really captures the ability of the

219
00:14:57,424 --> 00:15:01,126
team to quickly deliver work by

220
00:15:01,168 --> 00:15:04,462
having pieces of work take less time. End to end, you get

221
00:15:04,516 --> 00:15:08,286
less context switches because you're not

222
00:15:08,308 --> 00:15:11,454
going to have as many things in play at the same

223
00:15:11,492 --> 00:15:14,562
time, you're going to have the team focus on starting

224
00:15:14,616 --> 00:15:16,820
and finishing things quickly.

225
00:15:18,070 --> 00:15:21,490
You will get much less work in progress.

226
00:15:21,990 --> 00:15:25,890
Reduce context switches and by having

227
00:15:25,960 --> 00:15:30,038
smaller bits that are deployed, you're going to reduce your

228
00:15:30,204 --> 00:15:33,766
team's risk around deploying code. And of course,

229
00:15:33,868 --> 00:15:37,634
dead value. If the deploy time is short, then dead value in my code

230
00:15:37,692 --> 00:15:39,450
base is going to be minimal.

231
00:15:40,990 --> 00:15:44,854
So having talked about the four segments of cycle

232
00:15:44,902 --> 00:15:48,938
time, let me drill down a bit and talk about how

233
00:15:48,944 --> 00:15:53,310
do we actually improve, how do we improve on each of these segments?

234
00:15:53,970 --> 00:15:57,886
And they each have different dynamics, which is why it's interesting to

235
00:15:57,908 --> 00:16:01,274
measure them separately as part of the combined

236
00:16:01,322 --> 00:16:04,702
cycle time, and why improving

237
00:16:04,766 --> 00:16:08,786
each of these segments leads to better outcomes for

238
00:16:08,808 --> 00:16:12,546
the team. And it's only worth measuring if

239
00:16:12,648 --> 00:16:16,114
you can improve by improving the measure. So,

240
00:16:16,152 --> 00:16:19,954
coding, again, this is how long that takes a developer

241
00:16:20,002 --> 00:16:23,206
from starting to work on something until it's ready for

242
00:16:23,228 --> 00:16:27,218
review. And what we typically see is that coding tends

243
00:16:27,234 --> 00:16:31,574
to the time it takes to code something blows

244
00:16:31,622 --> 00:16:34,794
up for

245
00:16:34,992 --> 00:16:37,370
some very well known reasons.

246
00:16:37,710 --> 00:16:40,854
First is to have good requirements.

247
00:16:40,982 --> 00:16:43,760
It's very common. If the requirements are not great,

248
00:16:45,090 --> 00:16:48,414
I begin to work on something, I start coding and then

249
00:16:48,452 --> 00:16:51,614
I hit it a wall where some edge cases are not well

250
00:16:51,652 --> 00:16:55,274
defined, the requirements are not clear. What really happened

251
00:16:55,332 --> 00:16:58,606
in each of these cases, I need to go back CTO product or to whoever

252
00:16:58,638 --> 00:17:03,518
owns requirements and negotiate some clarifications.

253
00:17:03,614 --> 00:17:07,498
This is going to take longer. Like by definition, it's going to increase

254
00:17:07,534 --> 00:17:10,930
the time it takes me to code this. Notice that we're not measuring

255
00:17:11,090 --> 00:17:14,694
actual work time spent, we're measuring calendar time

256
00:17:14,732 --> 00:17:17,558
or clock time. So if I started to work,

257
00:17:17,724 --> 00:17:21,500
I wrote some code for 2 hours and then I had to start

258
00:17:22,190 --> 00:17:26,682
talking with product for better requirements. That is going to take maybe

259
00:17:26,736 --> 00:17:30,490
a few more hours, maybe a day or two. Coding time is going to explode.

260
00:17:31,070 --> 00:17:34,654
So having great requirements upfront, being able

261
00:17:34,692 --> 00:17:38,826
to maybe begin my work by checking

262
00:17:38,858 --> 00:17:42,654
out the requirements and really reading through and understanding that

263
00:17:42,692 --> 00:17:46,366
they're fleshed enough, is a great way to

264
00:17:46,388 --> 00:17:49,950
get coding time down and will also

265
00:17:50,020 --> 00:17:54,978
naturally reduce waste

266
00:17:55,034 --> 00:17:58,834
it work. If I've started to code something and it's not the right direction

267
00:17:58,882 --> 00:18:02,200
and the requirements are changing because they're not fleshed out

268
00:18:02,570 --> 00:18:03,960
as they should have been.

269
00:18:07,210 --> 00:18:10,490
These are all things we can gain by having better requirements upfront.

270
00:18:12,590 --> 00:18:16,566
The other obvious way to reduce coding

271
00:18:16,598 --> 00:18:20,554
time and cycle time in general is to cut down the item

272
00:18:20,602 --> 00:18:24,334
of work that I can start and finish working on. So instead

273
00:18:24,372 --> 00:18:28,350
of doing a huge change, a huge feature,

274
00:18:29,410 --> 00:18:33,118
let's just take one thing, one small thing that we can code

275
00:18:33,204 --> 00:18:36,690
review, merge and deploy as a standalone

276
00:18:37,110 --> 00:18:40,674
slice of what we need. If we can do that,

277
00:18:40,712 --> 00:18:44,098
we have chopped down our work. Our pull requests are going to

278
00:18:44,104 --> 00:18:47,378
be smaller and everything coding obviously,

279
00:18:47,464 --> 00:18:50,866
but also the rest of the phases are going to be much shorter

280
00:18:50,898 --> 00:18:53,910
because it's much easier to push through a small change,

281
00:18:54,060 --> 00:18:58,466
get it reviewed quickly, get it merged, and smaller

282
00:18:58,498 --> 00:19:01,690
risk to deploy it than it is to take a huge thing.

283
00:19:01,760 --> 00:19:05,098
So if you're working on something and you can

284
00:19:05,104 --> 00:19:09,210
chop it down to smaller items that can be individually

285
00:19:09,810 --> 00:19:13,422
delivered all the way, then that is almost always

286
00:19:13,476 --> 00:19:15,600
a win for the team.

287
00:19:17,330 --> 00:19:20,526
Much better predictability about being able to deliver these

288
00:19:20,548 --> 00:19:24,174
things, much lower risk and a faster cycle

289
00:19:24,222 --> 00:19:27,620
altogether. And finally,

290
00:19:30,390 --> 00:19:33,620
the third contributor to long coding time is

291
00:19:34,550 --> 00:19:37,478
areas in my code base, which are very hard and difficult,

292
00:19:37,644 --> 00:19:41,334
where every change that I'm making that touches those

293
00:19:41,372 --> 00:19:44,950
areas is going to take longer because

294
00:19:45,020 --> 00:19:48,522
everything breaks because it's brittle. So by

295
00:19:48,576 --> 00:19:52,154
refactoring places in the code that are very difficult to

296
00:19:52,192 --> 00:19:56,570
touch, I can improve coding time for the next items

297
00:19:57,150 --> 00:20:01,102
and pieces of code and changes to my code base that need to happen.

298
00:20:01,236 --> 00:20:05,118
So sometimes by being proactive and refactoring code, we can

299
00:20:05,204 --> 00:20:08,800
reduce coding time for the next

300
00:20:09,490 --> 00:20:13,650
tasks that we have. So coding again,

301
00:20:13,720 --> 00:20:16,834
if we are able to push that down, we are typically going to end up

302
00:20:16,872 --> 00:20:21,282
with smaller pieces of work and probably

303
00:20:21,416 --> 00:20:25,118
with a better process for requirements. Otherwise it's

304
00:20:25,134 --> 00:20:28,120
going to be very hard to drive coding time down.

305
00:20:29,130 --> 00:20:33,426
The next segment is pickup, and pickup is all about communication

306
00:20:33,538 --> 00:20:37,046
and coordination in the team. Remember, nothing happens in

307
00:20:37,068 --> 00:20:40,470
pickup. It's all about a pull request or a merge request

308
00:20:40,550 --> 00:20:44,154
waiting to get picked up by someone in the team.

309
00:20:44,272 --> 00:20:48,266
So by improving the way we communicate around it,

310
00:20:48,368 --> 00:20:52,110
so the people know that they need to look at my change

311
00:20:52,180 --> 00:20:56,080
and look at my code, and by

312
00:20:56,450 --> 00:20:59,774
having some processes in the team to coordinate around this, so that

313
00:20:59,812 --> 00:21:03,486
no one forgets to review code, so that I don't have to

314
00:21:03,508 --> 00:21:08,114
nag others to look at my code, so I don't forget that

315
00:21:08,152 --> 00:21:11,726
my code is waiting for someone. All of these measures

316
00:21:11,758 --> 00:21:16,470
are going to help push things through faster and by

317
00:21:16,540 --> 00:21:19,382
providing feedback on my changes quickly,

318
00:21:19,516 --> 00:21:22,920
I'm able to act while it's still fresh in my mind.

319
00:21:23,370 --> 00:21:27,206
If I get your comments on my pr within,

320
00:21:27,308 --> 00:21:30,394
I don't know, an hour or two after writing my code, I'm in a much

321
00:21:30,432 --> 00:21:34,794
better place to address this quickly and efficiently than

322
00:21:34,832 --> 00:21:38,378
I am if I get these comments tomorrow or in three days after the

323
00:21:38,384 --> 00:21:42,478
weekend. The other thing that can help with

324
00:21:42,644 --> 00:21:46,634
pickup is to think about context switching in a deliberate

325
00:21:46,682 --> 00:21:50,602
way. Typically, people are coding. Most of my peers

326
00:21:50,666 --> 00:21:53,726
in the dev team are going CTO be coding and busy with their own tasks,

327
00:21:53,838 --> 00:21:57,780
and then code review is going to be a context switch for them.

328
00:21:58,710 --> 00:22:02,354
By being deliberate about when do I context switch to help review other

329
00:22:02,392 --> 00:22:05,526
people's changes, we can be much more

330
00:22:05,548 --> 00:22:08,614
efficient. For example, if I'm beginning my

331
00:22:08,652 --> 00:22:12,422
day by taking some code reviews instead

332
00:22:12,476 --> 00:22:16,054
of jumping into my

333
00:22:16,252 --> 00:22:18,220
prs and my code changes,

334
00:22:19,070 --> 00:22:23,386
I'm just starting my day so I can go

335
00:22:23,408 --> 00:22:27,050
and do some reviews without paying tax of a context switch if I'm

336
00:22:27,630 --> 00:22:31,600
getting back from lunch, it's the same story.

337
00:22:34,290 --> 00:22:37,358
If I just finished a meeting. And again,

338
00:22:37,444 --> 00:22:41,034
these are all context switches that already happened. I can be deliberate

339
00:22:41,082 --> 00:22:44,898
and piggyback on those to

340
00:22:45,064 --> 00:22:48,626
take some code reviews while

341
00:22:48,728 --> 00:22:51,858
not incurring a context switch tax just for the review.

342
00:22:51,944 --> 00:22:55,334
So by being deliberate and by being

343
00:22:55,372 --> 00:22:58,626
aware of the importance CTO drive pickup

344
00:22:58,658 --> 00:23:01,814
time down, teams can be really

345
00:23:01,932 --> 00:23:05,282
learn to be efficient and get a great turnaround

346
00:23:05,346 --> 00:23:09,206
and help each other finish things by

347
00:23:09,388 --> 00:23:12,762
starting and jumping on reviews quickly instead

348
00:23:12,816 --> 00:23:16,300
of having them languish and need to nag and be

349
00:23:17,230 --> 00:23:19,990
the task that I'm always pushing to the end of the day and then I

350
00:23:20,000 --> 00:23:23,694
don't have time and so on. The next

351
00:23:23,892 --> 00:23:28,126
segment is the review process, and the review process is

352
00:23:28,308 --> 00:23:31,390
perhaps the most complex or elaborate

353
00:23:31,970 --> 00:23:35,474
segment here because it typically involves two

354
00:23:35,512 --> 00:23:39,454
or more people. It's multiple

355
00:23:39,502 --> 00:23:43,262
stages where people review the code, have some comments,

356
00:23:43,326 --> 00:23:46,902
then the original coder needs CTo get back to this and make some changes

357
00:23:46,956 --> 00:23:47,990
or respond.

358
00:23:49,850 --> 00:23:53,846
And the way to drive review

359
00:23:53,948 --> 00:23:57,554
time down to have all this dance of

360
00:23:57,612 --> 00:24:01,882
people coordination, communication and

361
00:24:01,936 --> 00:24:06,346
context switching all happen in a shorter time frame and in

362
00:24:06,368 --> 00:24:11,706
a more predictable way, is first of all to instill

363
00:24:11,738 --> 00:24:15,054
a culture that getting something done is

364
00:24:15,092 --> 00:24:18,990
worth much more than starting something. So by helping

365
00:24:19,410 --> 00:24:23,266
and by really focusing on finishing reviews that I'm part of,

366
00:24:23,368 --> 00:24:26,990
either as the PR owner or one of the reviewers,

367
00:24:27,150 --> 00:24:31,140
or even jumping into help to help a review

368
00:24:33,670 --> 00:24:37,506
get finished and get some agreement on what's

369
00:24:37,538 --> 00:24:41,174
needed to be able to merge this by focusing on

370
00:24:41,212 --> 00:24:45,238
done instead of starting things, people in

371
00:24:45,244 --> 00:24:49,002
the team can really help reviews start be

372
00:24:49,056 --> 00:24:52,854
effective and finish quickly. Sometimes there is a bottleneck.

373
00:24:52,902 --> 00:24:56,950
Some teams have dedicated reviewers or dedicated

374
00:24:57,030 --> 00:25:00,890
reviewers for parts of the code, and a long review

375
00:25:00,960 --> 00:25:04,574
time as measured as part of cycle time will

376
00:25:04,612 --> 00:25:07,450
indicate that I have a bottleneck. I don't have enough reviewers,

377
00:25:07,530 --> 00:25:11,482
and there's a lot of reviews waiting for a few people. So by deliberately

378
00:25:11,546 --> 00:25:15,602
adding more reviewers, by reducing or

379
00:25:15,736 --> 00:25:19,380
relaxing the requirements to review,

380
00:25:20,310 --> 00:25:24,338
I can make sure that review time remains short and there's not

381
00:25:24,424 --> 00:25:31,286
too much onus of reviews on just

382
00:25:31,308 --> 00:25:34,520
a few people in the teams. And finally,

383
00:25:35,050 --> 00:25:38,454
in some cases, the review process for a pull request

384
00:25:38,502 --> 00:25:41,882
is going to be long because the original code in that

385
00:25:41,936 --> 00:25:44,698
change is done the wrong way.

386
00:25:44,784 --> 00:25:48,346
It's not well designed. Maybe the

387
00:25:48,368 --> 00:25:52,330
choices made by the developer need to be reversed or revisited.

388
00:25:52,490 --> 00:25:55,920
So by improving the design,

389
00:25:56,770 --> 00:26:00,622
maybe having an explicit design phase when

390
00:26:00,676 --> 00:26:04,820
coding or getting some review before writing all the code.

391
00:26:05,750 --> 00:26:09,314
In some cases, at least in those cases where the actual code

392
00:26:09,352 --> 00:26:12,130
changes need to be heavily edited,

393
00:26:12,630 --> 00:26:16,674
doing that upfront, getting more feedback on my directions

394
00:26:16,722 --> 00:26:20,466
and the way I'm suggesting to solve

395
00:26:20,498 --> 00:26:23,974
the problem or to make the code change is more

396
00:26:24,012 --> 00:26:27,670
effective in the coding phase than it is in the review phase

397
00:26:28,270 --> 00:26:31,946
because it's going to be less wasted work and more informed work

398
00:26:31,968 --> 00:26:36,058
while I'm coding. So these are the main contributors to

399
00:26:36,224 --> 00:26:39,420
review time. And by driving review time down,

400
00:26:40,530 --> 00:26:45,360
we can get to these better outcomes of having more

401
00:26:46,530 --> 00:26:49,440
emphasis on done versus started,

402
00:26:49,970 --> 00:26:54,770
better code to begin with, and avoiding bottlenecks

403
00:26:55,190 --> 00:26:58,050
around reviewers. Finally,

404
00:26:58,120 --> 00:27:01,940
the deploy phase. This is a pretty well known pain

405
00:27:02,550 --> 00:27:06,594
and also a well known gain where modern teams

406
00:27:06,722 --> 00:27:09,922
strive to have streamlined deployment,

407
00:27:09,986 --> 00:27:14,150
where there's zero or close to zero time and effort needed

408
00:27:14,300 --> 00:27:17,786
from when a piece of code change has made it and has

409
00:27:17,808 --> 00:27:21,686
been merged to the code base and until it's deployed

410
00:27:21,718 --> 00:27:25,754
and is live in product. It's obviously not easy or possible in

411
00:27:25,792 --> 00:27:29,878
all scenarios, but it's

412
00:27:29,894 --> 00:27:33,966
a pretty common understanding that the shorter the time is and the smaller the

413
00:27:33,988 --> 00:27:37,626
effort is to deploy code, we're going to be in a better shape.

414
00:27:37,738 --> 00:27:41,566
So things that improve our deploy are

415
00:27:41,588 --> 00:27:45,650
obviously CI and CD systems, having reliable

416
00:27:45,990 --> 00:27:49,586
tests, comprehensive tests that give us confidence to

417
00:27:49,608 --> 00:27:52,946
be able to deploy code that has been

418
00:27:52,968 --> 00:27:56,994
merged, and of course to have smaller

419
00:27:57,042 --> 00:28:00,226
work items, smaller prs, smaller changes that are focused

420
00:28:00,258 --> 00:28:03,986
on just one thing, much easier to test, much easier to deploy,

421
00:28:04,098 --> 00:28:05,880
much easier to roll back,

422
00:28:06,970 --> 00:28:10,954
lower the risk of deploying. And that typically lends to

423
00:28:10,992 --> 00:28:14,154
faster deploys because we're willing CTO take on

424
00:28:14,192 --> 00:28:18,170
more deploys when we know the risk is smaller.

425
00:28:19,150 --> 00:28:23,280
So I've looked at the four segments of cycle time,

426
00:28:23,890 --> 00:28:28,378
and how each segment has different behaviors

427
00:28:28,394 --> 00:28:32,190
and different dynamics that lead to longer times and

428
00:28:32,260 --> 00:28:35,662
different ways to address so that we can shorten each of the segments

429
00:28:35,726 --> 00:28:39,426
and end up with a short cycle time across the

430
00:28:39,448 --> 00:28:43,586
board. So some

431
00:28:43,608 --> 00:28:47,154
of the benefits that elite teams get when they really reduce cycle

432
00:28:47,202 --> 00:28:51,058
time consistently across all of the code changes that they're

433
00:28:51,234 --> 00:28:55,334
driving. So these are like

434
00:28:55,372 --> 00:28:58,646
all over. I'm going to talk about a few. So first

435
00:28:58,668 --> 00:29:00,730
of all, there is the issue of predictability.

436
00:29:02,190 --> 00:29:05,526
Regardless of the way you manage your development work, this could be scrum

437
00:29:05,558 --> 00:29:08,410
or kanban or a variety of other methods.

438
00:29:09,230 --> 00:29:12,586
By having shorter cycles, smaller pieces

439
00:29:12,618 --> 00:29:16,270
of work that start and finish more quickly instead

440
00:29:16,340 --> 00:29:20,574
of longer, and more

441
00:29:20,612 --> 00:29:24,430
work in progress. Where each item takes longer, you get better

442
00:29:24,580 --> 00:29:28,420
predictability. You get the ability to

443
00:29:29,190 --> 00:29:32,866
say or estimate when this will land becomes much better.

444
00:29:32,968 --> 00:29:36,634
When your items are smaller and they're shorter

445
00:29:36,782 --> 00:29:41,062
in their cycle, you have a much more

446
00:29:41,196 --> 00:29:45,640
efficient and short learning cycle. If you are able to deploy those changes,

447
00:29:46,170 --> 00:29:49,318
you're making a small change, you get it deployed quickly.

448
00:29:49,484 --> 00:29:52,886
You can now learn from how that behaves in production.

449
00:29:52,998 --> 00:29:56,214
Did it give you the right benefit or the right deliver

450
00:29:56,262 --> 00:29:59,786
the goal that you needed? How are customers responding to this if this is

451
00:29:59,808 --> 00:30:02,430
a new feature or capability?

452
00:30:03,890 --> 00:30:07,930
Did this actually deliver the cpu load reduction

453
00:30:08,010 --> 00:30:11,226
or the database load reduction that you were aiming

454
00:30:11,258 --> 00:30:15,314
for? The faster you get this out and actually running in

455
00:30:15,352 --> 00:30:18,610
production on real data with real usage,

456
00:30:18,950 --> 00:30:22,962
the faster you will be able to learn and make another change,

457
00:30:23,016 --> 00:30:26,294
or make the next change that relies on the first one.

458
00:30:26,412 --> 00:30:30,406
So learning cycle is an obvious wins with

459
00:30:30,508 --> 00:30:33,350
shorter cycle time all the way to production.

460
00:30:34,650 --> 00:30:37,754
By definition, you will have improved the way

461
00:30:37,792 --> 00:30:42,394
your team works, communicates and coordinates with

462
00:30:42,432 --> 00:30:46,118
now everyone being remote or hybrid, remote communication

463
00:30:46,294 --> 00:30:49,546
has become even more difficult. It's no

464
00:30:49,568 --> 00:30:52,686
longer a question of swiveling in the chair and hollering, CTO, someone,

465
00:30:52,788 --> 00:30:58,046
can you take a look at my code? So you

466
00:30:58,068 --> 00:31:03,438
cannot really improve cycle time if your team communicates

467
00:31:03,534 --> 00:31:06,718
or coordinates inefficiently. So this is going to force

468
00:31:06,894 --> 00:31:09,860
the way you communicate. CTo be much better.

469
00:31:11,430 --> 00:31:15,054
You will have reduced the work in progress. You have

470
00:31:15,112 --> 00:31:18,070
less items in play and more items delivered,

471
00:31:18,810 --> 00:31:23,350
which typically reduces risk and reduces again,

472
00:31:23,420 --> 00:31:26,294
context switching. You have less things in play.

473
00:31:26,332 --> 00:31:29,766
You need to switch context between less things.

474
00:31:29,868 --> 00:31:33,834
And even when context switching, this is within a

475
00:31:33,872 --> 00:31:36,730
shorter time frame. So things are still fresh in your mind.

476
00:31:36,800 --> 00:31:40,390
If I'm able to write my code, get some comments,

477
00:31:40,470 --> 00:31:43,982
respond to these comments, make some changes, and eventually finish

478
00:31:44,036 --> 00:31:48,142
my work in a day. This is so much better in terms

479
00:31:48,196 --> 00:31:51,994
of my cognitive load and being able CTO returning

480
00:31:52,042 --> 00:31:55,454
back to things than if the same process is spread or

481
00:31:55,492 --> 00:31:59,186
the same net time of work is spread across two or three days.

482
00:31:59,368 --> 00:32:02,866
It's the same effort, but then I have to remember and go back to

483
00:32:02,888 --> 00:32:06,502
things that I've already left behind, and that will add up time and

484
00:32:06,556 --> 00:32:10,514
cognitive load. And then by having much smaller

485
00:32:10,562 --> 00:32:14,834
chunks of work, which is almost a requirement for great cycle

486
00:32:14,882 --> 00:32:17,910
time, you will reduce the delivery risk.

487
00:32:18,350 --> 00:32:21,882
Every item is a well defined change,

488
00:32:22,016 --> 00:32:25,574
very small, much lower risk to deliver,

489
00:32:25,702 --> 00:32:30,374
easy CTO revert in case you need to compare

490
00:32:30,422 --> 00:32:34,030
that to having huge changes accrued

491
00:32:34,930 --> 00:32:38,874
with a lot of dead value in my code base until I eventually deploy.

492
00:32:38,922 --> 00:32:42,430
Something that is going to be a huge risk to deploy

493
00:32:43,970 --> 00:32:47,790
will require much more elaborate testing

494
00:32:48,390 --> 00:32:51,890
to be sure that this change does not break anything, and a much

495
00:32:51,960 --> 00:32:56,242
harder thing to revert once deployed.

496
00:32:56,306 --> 00:32:59,766
So these are all just some of the benefits

497
00:32:59,868 --> 00:33:02,710
that lead teams get when really driving cycle time down.

498
00:33:02,780 --> 00:33:05,960
And I've been talking with some of our customers.

499
00:33:07,370 --> 00:33:12,906
We have some customers that are able to drive cycle time down to a

500
00:33:12,928 --> 00:33:15,500
day or even less for a typical change,

501
00:33:16,350 --> 00:33:20,150
and really are reaping the benefits of having this

502
00:33:20,240 --> 00:33:24,602
predictable, short, small items approach

503
00:33:24,666 --> 00:33:27,120
to delivering code changes.

504
00:33:28,530 --> 00:33:31,742
So some of the numbers that we are seeing

505
00:33:31,796 --> 00:33:34,420
across this is from Linearb B's customers.

506
00:33:37,270 --> 00:33:40,514
These numbers are here to show that, yes, it is

507
00:33:40,632 --> 00:33:44,226
very, very possible to improve cycle time dramatically by

508
00:33:44,248 --> 00:33:48,194
just paying attention, by measuring it with the right tools,

509
00:33:48,322 --> 00:33:52,342
by thinking about the four segments and

510
00:33:52,476 --> 00:33:56,342
applying improvements across each segment as a result

511
00:33:56,396 --> 00:33:59,786
of what we are seeing in our measurements. If I'm seeing, we have

512
00:33:59,808 --> 00:34:03,340
a lot of, if our pickup time is high,

513
00:34:04,110 --> 00:34:07,926
we can invest in improving our communication or creating

514
00:34:07,958 --> 00:34:11,370
a schedule to review code twice a day across the team.

515
00:34:11,520 --> 00:34:15,966
If our coding time is high, we can look at the

516
00:34:15,988 --> 00:34:19,854
sizes of our prs, the sizes of our code changes and our

517
00:34:19,892 --> 00:34:23,742
requirements, and so on, like I've described earlier. So by measuring

518
00:34:23,886 --> 00:34:27,106
and then paying attention to what I'm getting across the

519
00:34:27,128 --> 00:34:30,354
segments, our customers are able to

520
00:34:30,392 --> 00:34:33,966
really rapidly

521
00:34:33,998 --> 00:34:38,454
improve the average cycle time by

522
00:34:38,652 --> 00:34:42,070
50%, even by up to 75%,

523
00:34:42,140 --> 00:34:46,482
which is, that's like a four x shorter cycle time. Instead of typically

524
00:34:46,546 --> 00:34:49,914
taking, I don't know, four days, your work can

525
00:34:49,952 --> 00:34:53,034
start and finish, your typical items can finish in a day,

526
00:34:53,152 --> 00:34:56,630
which is, this is a huge gain for productivity,

527
00:34:56,790 --> 00:35:01,134
for developer well being, and for

528
00:35:01,332 --> 00:35:03,120
predictability across.

529
00:35:04,530 --> 00:35:06,800
How quickly can I deliver something?

530
00:35:08,530 --> 00:35:11,630
That kind of insight really becomes easier when your

531
00:35:11,700 --> 00:35:16,162
items are smaller and begin and end within

532
00:35:16,216 --> 00:35:19,940
a day. Compared to a week or four or five days and so on.

533
00:35:20,950 --> 00:35:24,514
So I've talked about measuring the dev

534
00:35:24,552 --> 00:35:28,006
process. I've talked about focusing on the process

535
00:35:28,108 --> 00:35:31,414
rather than individuals, and by focusing on

536
00:35:31,452 --> 00:35:34,886
cycle time and its segments, how we

537
00:35:35,068 --> 00:35:39,414
can start learning about the main productivity killers like context

538
00:35:39,462 --> 00:35:42,940
switching and work in progress and dead value.

539
00:35:44,910 --> 00:35:48,314
But I'm going to say that, yeah, measuring is a great first

540
00:35:48,352 --> 00:35:52,042
step. You need to start measuring to be able to improve.

541
00:35:52,186 --> 00:35:56,494
It's almost like otherwise you're flying blind. And it's very hard

542
00:35:56,612 --> 00:35:59,898
for dev teams to consistently improve

543
00:36:00,074 --> 00:36:04,210
without measurements. But measurements

544
00:36:04,550 --> 00:36:08,226
is a great first step, but it's not enough. And that

545
00:36:08,248 --> 00:36:12,450
is something that here at Linearb V, we've learned by working

546
00:36:12,520 --> 00:36:14,100
with our customers,

547
00:36:15,670 --> 00:36:17,350
hundreds of dev teams,

548
00:36:18,650 --> 00:36:22,198
and we've seen that there is the first step that you take.

549
00:36:22,284 --> 00:36:25,846
You begin to measure, you begin to improve based on these measurements. You've seen the

550
00:36:25,868 --> 00:36:28,826
numbers, this gets you so far,

551
00:36:29,008 --> 00:36:33,286
but there is so much more you can do when you go beyond measurements.

552
00:36:33,398 --> 00:36:37,354
So why is just measuring typically gives

553
00:36:37,392 --> 00:36:39,770
you some numbers that go into a dashboard.

554
00:36:40,850 --> 00:36:44,640
Again, great basis to start improving, but why is it not enough?

555
00:36:45,010 --> 00:36:49,486
Because by the time you have a

556
00:36:49,508 --> 00:36:53,326
measurement that highlights a problem, for example,

557
00:36:53,508 --> 00:36:57,298
if I have a measurement in a dashboard that someone visits every two or

558
00:36:57,304 --> 00:37:01,106
three weeks, and it shows that my pickup time is high,

559
00:37:01,208 --> 00:37:04,530
our team typically takes two or three days

560
00:37:04,600 --> 00:37:06,920
to begin reviewing a PR.

561
00:37:07,770 --> 00:37:11,954
By that time, it's already too late for those prs, and it's a lagging

562
00:37:12,002 --> 00:37:15,430
indicator of where my problem is.

563
00:37:15,580 --> 00:37:19,480
Another reason where measurements alone are not enough

564
00:37:20,030 --> 00:37:23,898
to really help the team improve is that the problems

565
00:37:23,984 --> 00:37:27,802
and the delays are not evenly spread. It's not all prs that will take

566
00:37:27,856 --> 00:37:31,118
two, three days. It's some of the prs that are going to

567
00:37:31,124 --> 00:37:37,134
be very quickly addressed and reviewed and stream cruise

568
00:37:37,332 --> 00:37:40,702
quickly, and then have a short cycle time and some

569
00:37:40,756 --> 00:37:44,526
other part of the prs or some other piece of my

570
00:37:44,548 --> 00:37:48,098
code changes are going to be delayed, are going to be forgotten, are going

571
00:37:48,104 --> 00:37:51,586
to be roadblocked. So like anything else in

572
00:37:51,608 --> 00:37:54,946
life, this is an 80 20 case or a 90 ten. And being able

573
00:37:54,968 --> 00:37:57,910
to know where my problems are is very important.

574
00:37:58,060 --> 00:38:02,466
So having a metric is great. But now, to really solve

575
00:38:02,498 --> 00:38:05,110
the problem and improve,

576
00:38:05,450 --> 00:38:08,934
I need something that shines a light on the specific PR,

577
00:38:09,052 --> 00:38:12,598
the specific code changes that are stuck, that are going

578
00:38:12,604 --> 00:38:16,454
to have a long cycle time and are going to affect the overall

579
00:38:16,502 --> 00:38:19,402
average or median or whatever metric I'm looking at.

580
00:38:19,536 --> 00:38:23,354
So by moving from a metric CTO, an insight,

581
00:38:23,402 --> 00:38:27,066
and then highlighting the specific items

582
00:38:27,098 --> 00:38:30,990
that need attention. We can start talking about taking action

583
00:38:31,810 --> 00:38:34,866
on specific prs, on specific code changes,

584
00:38:35,048 --> 00:38:38,366
not just retrospect action on a measurement

585
00:38:38,398 --> 00:38:42,098
or on a metric. And at the end of this,

586
00:38:42,264 --> 00:38:45,974
at the very high end of solving these problems,

587
00:38:46,092 --> 00:38:51,734
you get to automation. And I'm showing here in this slide just

588
00:38:51,932 --> 00:38:55,894
two examples of how we

589
00:38:55,932 --> 00:38:59,846
help dev teams improve by moving from metrics

590
00:38:59,878 --> 00:39:03,930
and measurements to proactive action and automation.

591
00:39:04,270 --> 00:39:08,794
For example, if a specific PR is

592
00:39:08,832 --> 00:39:12,986
waiting to be reviewed, pickup time begins to accrue.

593
00:39:13,098 --> 00:39:16,894
We don't have to wait until to wait

594
00:39:16,932 --> 00:39:19,840
two weeks and look at the metric to know that we have a problem.

595
00:39:20,370 --> 00:39:24,640
Once this PR has been waiting for some

596
00:39:25,990 --> 00:39:29,314
predetermined threshold of time, we can now alert the team

597
00:39:29,352 --> 00:39:32,866
and say, hey, this PR looks stuck. This PR is waiting for someone to

598
00:39:32,888 --> 00:39:36,742
review. It's already been open for, I don't know, 5 hours, 10 hours.

599
00:39:36,796 --> 00:39:39,974
Whatever your threshold is, you can now

600
00:39:40,092 --> 00:39:44,454
take action and improve this

601
00:39:44,492 --> 00:39:48,054
specific PR, improve the eventual cycle

602
00:39:48,102 --> 00:39:50,794
time across all of your work.

603
00:39:50,992 --> 00:39:54,086
So by highlighting where a problem is beginning

604
00:39:54,118 --> 00:39:58,106
to happen, you can let the team address this in

605
00:39:58,128 --> 00:40:01,006
real time. Curb the problem,

606
00:40:01,108 --> 00:40:04,622
curb the growth of pickup or

607
00:40:04,756 --> 00:40:07,710
review time or any other parts of the cycle,

608
00:40:08,130 --> 00:40:11,450
and eventually your metric will be much will improve

609
00:40:11,610 --> 00:40:15,770
even more. But by solving and automating the way you solve

610
00:40:15,850 --> 00:40:19,406
the specific prs, you're not waiting to see a metric

611
00:40:19,438 --> 00:40:22,834
and then think about what went wrong. We can tell you what went wrong or

612
00:40:22,872 --> 00:40:27,794
what is starting to go wrong in a specific item,

613
00:40:27,842 --> 00:40:31,734
which could be a branch or a pull request, a very specific

614
00:40:31,852 --> 00:40:34,840
piece of code change that your team is working on.

615
00:40:36,170 --> 00:40:40,220
So by highlighting and looking in real time,

616
00:40:40,910 --> 00:40:44,438
what is actually in play right now, what begins to look like it's

617
00:40:44,454 --> 00:40:47,370
stuck or delayed, highlight that.

618
00:40:47,440 --> 00:40:51,358
Give that context to the team in

619
00:40:51,364 --> 00:40:54,958
the right place, not in a dashboard, but like a slack alert or similar,

620
00:40:55,044 --> 00:40:59,134
where this goes to where the

621
00:40:59,172 --> 00:41:02,994
team is already living there and communicating there and in

622
00:41:03,032 --> 00:41:06,770
real time. Now the team can respond and just organically

623
00:41:07,190 --> 00:41:10,946
start reviewing that pr or fix the problem and

624
00:41:10,968 --> 00:41:11,780
move along.

625
00:41:14,150 --> 00:41:17,534
We see that in our customer data, and this improves cycle

626
00:41:17,582 --> 00:41:20,806
time by yet another huge jump. So like the

627
00:41:20,828 --> 00:41:23,974
first jump is when you start measuring things, and then the next

628
00:41:24,012 --> 00:41:27,626
jump, which really puts you into or gives you a chance to go

629
00:41:27,648 --> 00:41:31,258
into the elite land, is by automating and

630
00:41:31,424 --> 00:41:35,050
finding and fixing the problems when they just begin to happen

631
00:41:35,200 --> 00:41:40,622
on specific prs, on specific code changes with

632
00:41:40,676 --> 00:41:44,830
very focused alerts and very focused automation

633
00:41:45,890 --> 00:41:49,194
to solve those or remove those roadblocks

634
00:41:49,242 --> 00:41:50,800
when they just begin to happen.

635
00:41:52,770 --> 00:41:55,902
So to summarize we've talked about cycle

636
00:41:55,966 --> 00:41:59,122
time, why this is a great measure to look at the dev

637
00:41:59,176 --> 00:42:02,162
process, and why if you're not measuring anything,

638
00:42:02,216 --> 00:42:03,700
that's where you should start.

639
00:42:04,970 --> 00:42:08,294
Culturally, it focuses on the process, not on

640
00:42:08,412 --> 00:42:12,806
finger planning to anyone or stack ranking developers. It's about

641
00:42:12,988 --> 00:42:16,690
can we find and empower the team to remove

642
00:42:16,770 --> 00:42:20,614
inefficiencies in the process? Focusing on context switching

643
00:42:20,662 --> 00:42:24,618
on work in progress, on dead value in the code base.

644
00:42:24,784 --> 00:42:28,250
We've looked at the four segments across

645
00:42:28,320 --> 00:42:31,758
cycle time. We're focusing on

646
00:42:31,764 --> 00:42:35,166
the coding segment where the developer is

647
00:42:35,188 --> 00:42:38,974
working on the code, then the pickup segment where the

648
00:42:39,012 --> 00:42:43,430
team or the change is waiting for someone to begin reviewing

649
00:42:43,450 --> 00:42:47,026
it. Then the review process, which is about people

650
00:42:47,128 --> 00:42:50,946
collaborating to get the code change to

651
00:42:50,968 --> 00:42:55,006
a state where it can be merged and actually merging it and finally deploying

652
00:42:55,038 --> 00:42:59,140
it into production. All of these segments together.

653
00:42:59,990 --> 00:43:03,318
If we can drive the time it takes for a single piece of

654
00:43:03,324 --> 00:43:06,310
work to go through each of these segments, if we can drive that down,

655
00:43:06,460 --> 00:43:09,706
we will have improved our cycle time, improved our

656
00:43:09,728 --> 00:43:13,370
productivity, removed cognitive load and context switching.

657
00:43:14,110 --> 00:43:17,494
And then after looking at measurements,

658
00:43:17,622 --> 00:43:21,360
I've shown the next step beyond measurements and metrics, which is

659
00:43:22,290 --> 00:43:26,174
driving insights and automation that

660
00:43:26,212 --> 00:43:30,110
really helps the team focus on the specific changes,

661
00:43:30,180 --> 00:43:33,834
the specific items that begin to look stuck,

662
00:43:33,962 --> 00:43:37,570
that roadblocks that are beginning to happen address

663
00:43:37,640 --> 00:43:41,794
them in real time instead of waiting for what the metric will

664
00:43:41,832 --> 00:43:45,114
say in two weeks or three weeks and doing some retrospect

665
00:43:45,182 --> 00:43:48,582
thinking. And I've shown how by

666
00:43:48,636 --> 00:43:51,910
taking these steps, dev teams are able to

667
00:43:52,060 --> 00:43:55,654
really slice and slash down their

668
00:43:55,692 --> 00:43:59,814
cycle time by up to four x improvement

669
00:43:59,862 --> 00:44:03,702
in their cycle time in a very short time by adopting

670
00:44:03,766 --> 00:44:05,980
a measurement tool and an automation tool.

671
00:44:07,390 --> 00:44:10,926
I'm inviting everyone listening to this to

672
00:44:11,108 --> 00:44:14,702
join our dev underrated community. We have a very

673
00:44:14,756 --> 00:44:18,670
lively discord community with over 1500 dev leaders

674
00:44:19,970 --> 00:44:23,706
discussing anything and everything that is interesting to development

675
00:44:23,738 --> 00:44:28,430
leaders. We're obviously hiring

676
00:44:28,930 --> 00:44:32,046
aggressively, so I'm welcoming everybody to take a

677
00:44:32,068 --> 00:44:36,486
look and find your dream position at Leonard and

678
00:44:36,588 --> 00:44:40,054
Linearb is free for dev team. Sir, you're more than

679
00:44:40,092 --> 00:44:43,334
welcome to jump on and begin

680
00:44:43,372 --> 00:44:47,314
measuring your cycle time. Begin improving by measuring your cycle

681
00:44:47,362 --> 00:44:51,000
time by introducing automation to your dev process

682
00:44:52,170 --> 00:44:55,490
and really go all the way to how elite

683
00:44:55,570 --> 00:44:57,700
dev teams work. Thank you.

