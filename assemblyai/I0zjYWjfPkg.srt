1
00:00:17,290 --> 00:00:21,054
Hello everyone. I hope you are having a great time at

2
00:00:21,092 --> 00:00:24,654
conf fourty two. Welcome to the obscure part

3
00:00:24,692 --> 00:00:28,534
of the conference where I will show you some non obvious aspects of

4
00:00:28,572 --> 00:00:32,482
swift. So grab a cup of tea or coffee

5
00:00:32,626 --> 00:00:36,482
or a glass of your favorite beverage, and let's lift the obscuring

6
00:00:36,546 --> 00:00:40,170
shroud of mystery. Two words about myself

7
00:00:40,320 --> 00:00:43,862
my name is Pavo and I am currently working at Glovo.

8
00:00:44,006 --> 00:00:47,930
I've been doing iOS related things for around nine years

9
00:00:48,080 --> 00:00:51,530
and I've started using Swift since its third version.

10
00:00:51,690 --> 00:00:55,866
Recently I took a great interest in exploring its underbelly,

11
00:00:55,978 --> 00:00:59,630
or more precisely, the seal level of compilation.

12
00:01:00,370 --> 00:01:04,046
So what is Swift intermediate language?

13
00:01:04,238 --> 00:01:08,126
As the name suggests, it's one of the intermediate steps

14
00:01:08,238 --> 00:01:11,746
that your high level code gets transformed into

15
00:01:11,928 --> 00:01:15,766
before it is finally compiled into binary form.

16
00:01:15,948 --> 00:01:19,606
Apart from applying some optimizations, this step is

17
00:01:19,628 --> 00:01:23,794
also responsible for synthesizing the automatically

18
00:01:23,842 --> 00:01:27,190
generated parts like codable conformances.

19
00:01:27,710 --> 00:01:31,482
So it will take this little structure and turn

20
00:01:31,536 --> 00:01:35,222
it into its final form with synthesized default

21
00:01:35,286 --> 00:01:38,762
conformances of codable requirements. That's pretty

22
00:01:38,816 --> 00:01:42,218
cool if you ask me to work with Seal.

23
00:01:42,314 --> 00:01:45,946
I have been using Seal Inspector by Alex Blevit,

24
00:01:46,058 --> 00:01:49,790
which he built bite some time ago for his stock Swift two

25
00:01:49,860 --> 00:01:53,006
under the hood. It's a pretty simple app, but it

26
00:01:53,028 --> 00:01:56,514
gets the job done. One thing worth noting is

27
00:01:56,552 --> 00:01:59,854
that for me it didn't work when run from Xcode,

28
00:01:59,982 --> 00:02:03,874
but getting the build binary and running it as a standalone app

29
00:02:03,992 --> 00:02:06,360
does the trick and everything works.

30
00:02:06,890 --> 00:02:10,930
Recently I have also learned about compiler Explorer

31
00:02:11,010 --> 00:02:14,898
by Matt Godbolt. It's available via web browser

32
00:02:14,994 --> 00:02:18,486
and it's also open source. It supports multiple languages,

33
00:02:18,598 --> 00:02:22,246
not only Swift, and has some pretty nice features,

34
00:02:22,438 --> 00:02:26,214
especially when working with assembly where it highlights

35
00:02:26,262 --> 00:02:30,250
code and related assembly instructions. That's pretty powerful.

36
00:02:30,590 --> 00:02:34,446
All SIL samples in this presentation are based on the

37
00:02:34,468 --> 00:02:38,142
output of SIL inspector using swift version five five

38
00:02:38,196 --> 00:02:41,470
one running on 2019 Intel MacBook Pro

39
00:02:41,540 --> 00:02:46,530
on macOS bite eleven five okay,

40
00:02:46,680 --> 00:02:50,020
so what does obscure actually mean?

41
00:02:50,390 --> 00:02:53,502
Following definition from Merriam Webster Dictionary,

42
00:02:53,646 --> 00:02:57,454
it's something that is relatively unknown, not clearly

43
00:02:57,502 --> 00:03:00,694
seen, and today we will talk about such things

44
00:03:00,732 --> 00:03:04,006
in the swift language we are using to take these four things

45
00:03:04,108 --> 00:03:07,970
that most of you probably have used or interfaced with already,

46
00:03:08,140 --> 00:03:12,458
do some twisting and turning to try to break them, and finally,

47
00:03:12,624 --> 00:03:16,234
we'll shine light on those seemingly broken parts to

48
00:03:16,272 --> 00:03:19,580
see how and why they actually work.

49
00:03:20,590 --> 00:03:23,754
Our first topic of the day and these subject,

50
00:03:23,882 --> 00:03:27,850
or to be more precise, the interoperability between swift

51
00:03:27,930 --> 00:03:31,550
and objective c. Some parts of it are quite obvious,

52
00:03:31,700 --> 00:03:34,862
some not really, or at least not at first glance,

53
00:03:35,006 --> 00:03:39,506
I'm not going to keep you waiting anymore. Let's dive in to

54
00:03:39,528 --> 00:03:42,802
quickly set the ground for this topic. Let's recap what base

55
00:03:42,856 --> 00:03:46,758
types we have within those languages, and how we can store

56
00:03:46,924 --> 00:03:50,294
anything in a variables in objective C,

57
00:03:50,412 --> 00:03:54,834
everything bar some exceptions like nsproxy inherits

58
00:03:54,882 --> 00:03:58,506
from NS object. As we all know in swift there

59
00:03:58,528 --> 00:04:02,090
is no base type. If you declare a class

60
00:04:02,160 --> 00:04:05,974
without inheritance, then it is just that a standalone

61
00:04:06,022 --> 00:04:10,300
class struct obviously also don't inherit from anything.

62
00:04:10,850 --> 00:04:14,522
Now if you wanted to have a property capable of storing

63
00:04:14,586 --> 00:04:18,094
anything then in objective c you could use

64
00:04:18,132 --> 00:04:21,534
the id type. In Swift there are two

65
00:04:21,572 --> 00:04:26,018
possibilities, any which can hold truly anything,

66
00:04:26,184 --> 00:04:29,362
struct classes closures, and any

67
00:04:29,416 --> 00:04:33,154
object which is dedicated for class types only.

68
00:04:33,352 --> 00:04:37,046
And don't take my word for it. Here is a snippet straight from the

69
00:04:37,068 --> 00:04:40,454
docs. Okay,

70
00:04:40,572 --> 00:04:44,278
so let's see this in action. First line is obvious.

71
00:04:44,444 --> 00:04:47,474
This is our core truth. Any is

72
00:04:47,532 --> 00:04:51,002
any and we can safely assign anything to it.

73
00:04:51,136 --> 00:04:54,220
In this case a plain static integer value.

74
00:04:54,750 --> 00:04:58,906
Now let's see if we can do it using any object.

75
00:04:59,088 --> 00:05:03,226
And unsurprisingly, the compiler throws a nice error

76
00:05:03,338 --> 00:05:07,440
that follows what was explained in the docs. So far so good.

77
00:05:07,810 --> 00:05:11,262
Now, since this part is supposed to be all about

78
00:05:11,316 --> 00:05:14,622
nsobject and has, we know some swift

79
00:05:14,686 --> 00:05:17,934
type that aren't classes can be breached

80
00:05:17,982 --> 00:05:21,666
into their class counterparts. In objective C this

81
00:05:21,688 --> 00:05:25,086
is true, for example for strings and NS strings arrays and

82
00:05:25,128 --> 00:05:28,920
ns arrays and as in our example numbers.

83
00:05:29,370 --> 00:05:32,706
So let's see what happens if we try casting

84
00:05:32,738 --> 00:05:36,470
our integer to NS number. First of all,

85
00:05:36,620 --> 00:05:40,106
it succeeds. This is where the bridging kicks in.

86
00:05:40,208 --> 00:05:42,620
We'll take a deeper look at it in a second.

87
00:05:43,390 --> 00:05:46,938
Let's see, what type does it have? Is it an

88
00:05:46,944 --> 00:05:50,800
NS number or an int? It's both.

89
00:05:51,250 --> 00:05:54,654
So while we moved our integer to class and

90
00:05:54,692 --> 00:05:58,762
objective seaWorld, we still retain information about the underlying

91
00:05:58,826 --> 00:06:01,998
type. Let's check one more thing.

92
00:06:02,164 --> 00:06:05,170
What do you think? Should it be a float?

93
00:06:05,830 --> 00:06:09,140
It is a float. This is kinda okay.

94
00:06:09,590 --> 00:06:13,902
Even though Swift doesn't perform automatic type promotion,

95
00:06:14,046 --> 00:06:17,686
all integers can be converted into floating point numbers.

96
00:06:17,868 --> 00:06:21,894
So let's allow this minor inconsistency with this

97
00:06:21,932 --> 00:06:25,400
bridging, but let's do a quick sanity check.

98
00:06:27,130 --> 00:06:31,180
What about now? Should float object be an int?

99
00:06:31,790 --> 00:06:35,562
Thankfully it's not. There are additional checks going

100
00:06:35,616 --> 00:06:39,946
on under the hood that ensure that in case of NS numbers,

101
00:06:40,128 --> 00:06:43,546
the value when cases to various numeric types in swift

102
00:06:43,658 --> 00:06:47,722
can be properly represented there. And we don't lose precision.

103
00:06:47,866 --> 00:06:51,514
So the checks don't really mean is the original

104
00:06:51,562 --> 00:06:55,074
value of int type, but rather can

105
00:06:55,112 --> 00:06:58,306
the underlying value be represented as an int.

106
00:06:58,488 --> 00:07:01,620
Okay, so how does all this happen?

107
00:07:02,550 --> 00:07:05,766
This is pretty simple. When we cases to NS number,

108
00:07:05,868 --> 00:07:09,526
the compiler is smart enough to simply convert this to

109
00:07:09,548 --> 00:07:13,186
a direct call to a matching NS number initializer

110
00:07:13,218 --> 00:07:16,694
at seal level. Pretty nice as it

111
00:07:16,732 --> 00:07:20,054
turns out, though I haven't shown it in previous slide.

112
00:07:20,182 --> 00:07:24,138
We can also cases our integer directly to NS object.

113
00:07:24,304 --> 00:07:27,654
The results are the same. The dynamic type will be NS

114
00:07:27,702 --> 00:07:31,180
number, though the method used is a little bit different.

115
00:07:31,790 --> 00:07:35,066
Instead of directly going to NS number init,

116
00:07:35,178 --> 00:07:38,494
it rather calls a breaching method on int itself.

117
00:07:38,692 --> 00:07:41,998
Make note of that method, as we will be seeing it again in a

118
00:07:42,004 --> 00:07:45,422
moment. Armed with all that knowledge

119
00:07:45,486 --> 00:07:49,474
from the docs and the quick little experiments we did, let's now

120
00:07:49,512 --> 00:07:53,394
ask the real questions. What happens if we

121
00:07:53,432 --> 00:07:56,710
tried to do all that with our custom types?

122
00:07:57,050 --> 00:08:00,502
What do you think? What should be the result of these

123
00:08:00,556 --> 00:08:03,766
assignments? Obviously the first one works.

124
00:08:03,868 --> 00:08:07,010
It's a class after all. And as the doc stated,

125
00:08:07,090 --> 00:08:11,174
we can freely assign it to any object. And for

126
00:08:11,212 --> 00:08:14,140
these struct we get the same error as before.

127
00:08:14,910 --> 00:08:18,742
But I have a small confession to make. I obscured

128
00:08:18,806 --> 00:08:21,886
part of the error previously. It actually has

129
00:08:21,908 --> 00:08:25,726
a fixit available that suggests a direct cases to

130
00:08:25,748 --> 00:08:29,520
any object. Let's see what happens if we apply it.

131
00:08:30,130 --> 00:08:33,518
The compiler won't complain and will allow it.

132
00:08:33,604 --> 00:08:36,978
Before we dig into why it allowed us to do so,

133
00:08:37,144 --> 00:08:40,206
let's ask another question. A little bizarre

134
00:08:40,238 --> 00:08:43,666
one at first sight. So what do you

135
00:08:43,688 --> 00:08:46,610
think should be the result of those type checks?

136
00:08:47,370 --> 00:08:51,254
Okay, so the first one is false. We didn't inherit our

137
00:08:51,292 --> 00:08:55,014
class from NSobject. We didn't mark it at objective C.

138
00:08:55,132 --> 00:08:58,280
We didn't cast it to anything. That's good.

139
00:08:58,590 --> 00:09:01,130
Let's see about our struct.

140
00:09:01,790 --> 00:09:05,462
What? Why is it an NSobject all of a sudden?

141
00:09:05,606 --> 00:09:09,962
Let's see what happens under the hood. So our

142
00:09:10,016 --> 00:09:13,146
cast to NS object looks like this. In Seal,

143
00:09:13,258 --> 00:09:17,294
it looks like there is a generic method that can bridge anything

144
00:09:17,412 --> 00:09:20,654
to objective c for us at this moment,

145
00:09:20,772 --> 00:09:24,926
Sil stops being useful in this case, since the implementation

146
00:09:24,958 --> 00:09:28,980
of this method is only referenced from there, we are left

147
00:09:29,830 --> 00:09:33,646
with only one choice. Then we need to look at swift source

148
00:09:33,678 --> 00:09:37,378
code. When searching the source for that method,

149
00:09:37,474 --> 00:09:41,000
we find this beautiful comment that explains everything.

150
00:09:41,530 --> 00:09:45,398
If our generic type is a class type, then it basically

151
00:09:45,484 --> 00:09:49,130
gets transferred into objective c as is.

152
00:09:49,280 --> 00:09:52,810
That code may not be able to interact with our class,

153
00:09:52,960 --> 00:09:56,490
but other than that, it's left unchanged. That's why

154
00:09:56,560 --> 00:10:00,154
our check of if NSobject returned false for

155
00:10:00,192 --> 00:10:03,514
our custom class. If our

156
00:10:03,552 --> 00:10:06,698
type conforms to the special private protocol,

157
00:10:06,874 --> 00:10:10,458
then it's breached according to the provided implementation.

158
00:10:10,634 --> 00:10:15,350
This is what we saw when we cast ints and floats into NSobject.

159
00:10:15,530 --> 00:10:18,738
Conformances to this protocol are the powerhouse of

160
00:10:18,744 --> 00:10:22,546
the breaching mechanism. And last but definitely

161
00:10:22,648 --> 00:10:26,166
not least, is our case. If the value cannot be

162
00:10:26,188 --> 00:10:29,686
breached into objective c, it gets boxed in

163
00:10:29,788 --> 00:10:33,414
an objective c class. Which explains why our

164
00:10:33,532 --> 00:10:37,154
custom pure swift struct became an NS

165
00:10:37,202 --> 00:10:41,146
object. The box is simultaneously simple

166
00:10:41,248 --> 00:10:45,274
and complex. Its definition is super simple,

167
00:10:45,392 --> 00:10:48,406
basically just an NSobject subclass.

168
00:10:48,598 --> 00:10:51,882
The way it's constructed though is quite complex

169
00:10:52,026 --> 00:10:55,134
since there are runtime shenanigans happening and some

170
00:10:55,172 --> 00:10:59,054
custom memory alignment. From what I could tell, if you feel

171
00:10:59,092 --> 00:11:03,086
confident reading advanced c plus plus code, I encourage

172
00:11:03,118 --> 00:11:06,930
you to explore that part so we know how

173
00:11:07,000 --> 00:11:10,850
this works, but still a question of why remains.

174
00:11:11,910 --> 00:11:15,382
At the beginning of this part we recapped some info about base

175
00:11:15,436 --> 00:11:19,158
types and how to represent anything. Let's focus

176
00:11:19,244 --> 00:11:23,234
on the anything part to support interoperability

177
00:11:23,362 --> 00:11:26,742
between the languages, there needed to be a way

178
00:11:26,796 --> 00:11:29,658
to bridge those anything types between them,

179
00:11:29,824 --> 00:11:33,178
especially since in objective C a

180
00:11:33,184 --> 00:11:37,002
lot of places relied on the use of id, for example

181
00:11:37,136 --> 00:11:40,938
to represent heterogeneous collections like those under info

182
00:11:40,954 --> 00:11:43,440
dictionaries in NS errors. For example,

183
00:11:44,130 --> 00:11:47,226
before Swift free id was breached

184
00:11:47,258 --> 00:11:51,294
into swift as any object, which makes sense,

185
00:11:51,492 --> 00:11:55,378
both types can be used to hold any class type.

186
00:11:55,544 --> 00:11:58,814
Apparently this created some friction

187
00:11:58,942 --> 00:12:02,338
since if you wanted to use strikes in Swift but

188
00:12:02,424 --> 00:12:06,374
still had to interface with objective C code, you would either need

189
00:12:06,412 --> 00:12:10,150
to refactor your code to use cases or create

190
00:12:10,220 --> 00:12:13,000
a boxing mechanism yourself.

191
00:12:14,250 --> 00:12:17,342
So in swift evolution 116

192
00:12:17,506 --> 00:12:21,446
this behavior was chance. Now id was breached

193
00:12:21,478 --> 00:12:25,354
into swift as any type so we could use our

194
00:12:25,392 --> 00:12:29,530
struct directly without the need to jump through extra hoops.

195
00:12:30,050 --> 00:12:33,662
Basically this has enabled this code to compile just

196
00:12:33,716 --> 00:12:36,938
fine. That struct gets automatically

197
00:12:37,114 --> 00:12:40,906
breached into objective C. If you were to print the contents

198
00:12:40,938 --> 00:12:44,034
of that user info dictionary, you'd get just

199
00:12:44,072 --> 00:12:47,650
the module and type name, unless you conform to custom

200
00:12:47,720 --> 00:12:51,460
string convertible and implemented the description property.

201
00:12:52,150 --> 00:12:56,170
Next up, autoclosure. This simple annotation

202
00:12:56,350 --> 00:13:00,002
is pretty powers, but also hides a small secret

203
00:13:00,066 --> 00:13:04,070
if you aren't careful. Let's take a closer look at it.

204
00:13:04,220 --> 00:13:07,490
Let's start this part with a small quiz of sorts.

205
00:13:07,650 --> 00:13:11,830
Take a look at this code snippet. We have a super simple struct

206
00:13:11,910 --> 00:13:14,938
that takes in an autoclosure and stores it.

207
00:13:15,104 --> 00:13:18,922
The question is what should be the values of call

208
00:13:18,976 --> 00:13:22,846
counter at marked places there is a hint from

209
00:13:22,868 --> 00:13:26,202
Xcode at line 16 on how the signature

210
00:13:26,266 --> 00:13:29,742
of Foo Initializer looks like. Let's take a couple

211
00:13:29,796 --> 00:13:32,030
seconds to consider the snippet.

212
00:13:36,140 --> 00:13:40,292
Okay, so time to show the answers. At line 19

213
00:13:40,356 --> 00:13:44,570
we have zero, and at line 23 we have one.

214
00:13:45,020 --> 00:13:48,872
If that zero feels unexpected to you, then don't worry,

215
00:13:49,016 --> 00:13:51,710
we will see what's going on in a second.

216
00:13:52,320 --> 00:13:56,620
Let's take a look at what the docs say about autoclosures.

217
00:13:56,960 --> 00:14:00,604
So it's an annotation that automatically wraps

218
00:14:00,652 --> 00:14:04,544
our expression in a closure, and that part is key.

219
00:14:04,662 --> 00:14:08,316
It's the entire expression that gets wrapped before it's

220
00:14:08,348 --> 00:14:12,028
evaluated. This is a huge difference at

221
00:14:12,054 --> 00:14:15,780
this point. The obscure part is actually not

222
00:14:15,850 --> 00:14:19,536
technical, but more habitual or perceptive

223
00:14:19,568 --> 00:14:23,492
one. To explain what I mean by that, let's return

224
00:14:23,546 --> 00:14:27,124
to our snippet. Most of us, or so I'd assume,

225
00:14:27,252 --> 00:14:30,568
would expect our snippet and these chance part

226
00:14:30,654 --> 00:14:34,632
to be equivalent. Whenever we see a method being called,

227
00:14:34,766 --> 00:14:37,600
we assume that it happens immediately.

228
00:14:37,780 --> 00:14:41,656
Autoclosure breaks that assumption in a well defined

229
00:14:41,768 --> 00:14:45,804
but a little invisible way. Worst thing, at least

230
00:14:45,842 --> 00:14:49,004
for me, is that Xcode doesn't help with

231
00:14:49,042 --> 00:14:52,400
autocompletion. As you can see on the left side

232
00:14:52,470 --> 00:14:56,064
in the commented line, these autocomplete hints that

233
00:14:56,102 --> 00:14:58,988
this method expects a plain string.

234
00:14:59,164 --> 00:15:02,676
Nothing indicates that it will get wrapped in a clover for

235
00:15:02,698 --> 00:15:06,832
us. Now, at this point, these is all pretty academical,

236
00:15:06,896 --> 00:15:10,644
so to speak, but let's imagine that the full

237
00:15:10,682 --> 00:15:14,188
struct is provided by a closed source framework.

238
00:15:14,384 --> 00:15:18,980
Now, I can easily imagine myself scratching my head and debugging

239
00:15:19,140 --> 00:15:22,788
why wasn't the method called? Or possibly worse,

240
00:15:22,964 --> 00:15:26,324
why was it called more than once? If internals

241
00:15:26,372 --> 00:15:29,964
of that closed source framework did require to evaluate it

242
00:15:30,002 --> 00:15:33,612
more than once to spice things up,

243
00:15:33,746 --> 00:15:36,764
let's adjust our sample snippet a little bit.

244
00:15:36,962 --> 00:15:40,312
Assume that code above framework boundary

245
00:15:40,456 --> 00:15:44,096
is closed source for us, so we also don't see that

246
00:15:44,118 --> 00:15:47,824
the expression is wrapped in a closure. We now moved into

247
00:15:47,862 --> 00:15:51,712
the world of reference semantics, and this sample is

248
00:15:51,766 --> 00:15:55,396
a little step closer to what we could see in real code.

249
00:15:55,578 --> 00:15:59,344
We have a class that handles interactions with some external

250
00:15:59,392 --> 00:16:03,012
SDK, setting it up on init. Can you tell

251
00:16:03,066 --> 00:16:06,484
what's the problem with this code? There is a retain

252
00:16:06,532 --> 00:16:09,944
cycle here. As we learned just a second ago,

253
00:16:10,062 --> 00:16:14,020
the autoclosure annotation wraps the entire expression

254
00:16:14,100 --> 00:16:17,512
in a closure, and since that expression

255
00:16:17,576 --> 00:16:21,336
references a method on self, it also gets implicitly

256
00:16:21,368 --> 00:16:24,952
captured. Once we expand this wrapping,

257
00:16:25,096 --> 00:16:28,984
it becomes really apparent. We see that the SDK

258
00:16:29,032 --> 00:16:33,324
initializer captured self strongly, and we also retain

259
00:16:33,372 --> 00:16:35,120
the SDK strongly.

260
00:16:36,740 --> 00:16:40,096
Fortunately, we are well equipped to deal with these kind

261
00:16:40,118 --> 00:16:43,252
of things. Handling retain cycles and using quick

262
00:16:43,306 --> 00:16:46,912
features is something we do with our eyes closed.

263
00:16:47,056 --> 00:16:50,836
So let's apply this here. For a low price of

264
00:16:50,858 --> 00:16:54,860
a default value, we get a compiler error,

265
00:16:55,040 --> 00:16:59,572
and it makes sense. Our external SDK expects

266
00:16:59,636 --> 00:17:03,352
an expression that returns string, and the

267
00:17:03,406 --> 00:17:06,768
expression we have now returns a closure

268
00:17:06,884 --> 00:17:09,628
that returns a string. Remember,

269
00:17:09,794 --> 00:17:14,296
the entire highlighted part would get wrapped in another closure

270
00:17:14,408 --> 00:17:16,430
so the types don't match.

271
00:17:17,200 --> 00:17:20,912
Now, if we simply called our closure right here,

272
00:17:21,046 --> 00:17:24,160
we'd make the error go away, since now

273
00:17:24,230 --> 00:17:27,600
our autoclosure expression returns these result

274
00:17:27,670 --> 00:17:31,004
of running our closure, which is of an unexpected

275
00:17:31,052 --> 00:17:33,776
type of string. Unfortunately,

276
00:17:33,888 --> 00:17:37,670
this doesn't solve our retain cycle. Let's see why.

277
00:17:38,680 --> 00:17:43,088
Looking at SIL, we see that the closure we defined ourselves

278
00:17:43,264 --> 00:17:46,650
does capture itself weekly as we want it.

279
00:17:47,100 --> 00:17:50,692
But once we take a look at the generated autoclosure,

280
00:17:50,836 --> 00:17:54,340
it still implicitly captured self strongly.

281
00:17:54,500 --> 00:17:57,820
So the compiler was smart enough

282
00:17:57,890 --> 00:18:01,516
to see that our inner closure needs a reference to

283
00:18:01,538 --> 00:18:05,100
self, so the outer autoclosure needs

284
00:18:05,170 --> 00:18:09,064
to capture it at the same time it missed the capture

285
00:18:09,112 --> 00:18:12,400
semantics, defaulting to strong capture.

286
00:18:12,900 --> 00:18:17,324
To fully break this retain cycle, we need to extract our closure

287
00:18:17,452 --> 00:18:21,040
outside of the autoclosure expression.

288
00:18:22,920 --> 00:18:26,832
Checking again with SIL, we see that our extracted closure

289
00:18:26,896 --> 00:18:29,908
still captures self weekly. That's great.

290
00:18:30,074 --> 00:18:33,364
And the generated autoclosure now has

291
00:18:33,402 --> 00:18:37,092
no direct dependency on self, it only captures

292
00:18:37,156 --> 00:18:41,108
another closure type, the one we defined and rightfully

293
00:18:41,204 --> 00:18:44,424
doesn't care what is going on in that

294
00:18:44,462 --> 00:18:48,396
captured closure. To sum up this part,

295
00:18:48,498 --> 00:18:53,192
my aim was definitely not to discourage you from using autoclosure,

296
00:18:53,336 --> 00:18:56,840
but to provide deeper understanding their mechanics.

297
00:18:57,000 --> 00:19:00,400
For me, the worst part about all of this is that

298
00:19:00,470 --> 00:19:05,084
Xcode doesn't hint in any way that in those particular cases,

299
00:19:05,212 --> 00:19:08,800
the expression will not be evaluated directly, but rather

300
00:19:08,870 --> 00:19:12,144
captured for future execution, or no execution at

301
00:19:12,182 --> 00:19:16,192
all. Fortunately, if you are injecting your dependencies

302
00:19:16,256 --> 00:19:20,116
and hiding them behind protocols, then it will be trivial to

303
00:19:20,138 --> 00:19:23,284
detect such cases. If you will generate the protocol based

304
00:19:23,322 --> 00:19:26,570
on public interface, the signatures won't match.

305
00:19:27,420 --> 00:19:30,804
In the end, this newcomers the issue of proper API

306
00:19:30,852 --> 00:19:34,024
design. If you decide to make an autoclosure also

307
00:19:34,062 --> 00:19:37,256
an escaping one, maybe it would be worth naming the

308
00:19:37,278 --> 00:19:40,792
parameter in a way that would indicate that intent

309
00:19:40,856 --> 00:19:44,380
to the end users. As Phil Carton said,

310
00:19:44,530 --> 00:19:48,312
there are only two hard things in computer science, cache invalidation

311
00:19:48,376 --> 00:19:52,684
and name things. Now let's

312
00:19:52,732 --> 00:19:56,636
take a look at a pretty powerful swift feature. The possibility

313
00:19:56,748 --> 00:20:00,080
to provide default values in function declarations.

314
00:20:01,780 --> 00:20:05,556
Consider this simple class. It just prints the date that

315
00:20:05,578 --> 00:20:09,316
is passed to it, and it quite makes sense to

316
00:20:09,338 --> 00:20:12,864
leverage the possibility of adding a default argument to this method

317
00:20:12,912 --> 00:20:16,452
call. Since possibly a lot of places may want to print

318
00:20:16,516 --> 00:20:20,250
current date, so why shouldn't we make it easier for them?

319
00:20:20,620 --> 00:20:24,516
And it works as expected. Now let's

320
00:20:24,548 --> 00:20:28,100
say that for whatever reasons, we may also want to print

321
00:20:28,180 --> 00:20:32,348
epoch date. And since all other parts of our system already

322
00:20:32,434 --> 00:20:36,456
know how to work with date printer, we may decide to subclass

323
00:20:36,488 --> 00:20:40,764
it and provide an overridden implementation of print date together

324
00:20:40,882 --> 00:20:45,276
with new default value to fit the new requirement of the subclass.

325
00:20:45,468 --> 00:20:49,484
Swift allows these, and if we check epoch date printer,

326
00:20:49,612 --> 00:20:53,636
we will see that we get what we want. Now a

327
00:20:53,658 --> 00:20:57,296
small question for you. What will the snippet

328
00:20:57,328 --> 00:20:58,020
print?

329
00:21:01,080 --> 00:21:04,752
Well, first half of the printed statement is correct,

330
00:21:04,906 --> 00:21:08,424
but the second looks wrong, doesn't it? It looks

331
00:21:08,462 --> 00:21:12,250
as if Swift stitched these two methods together.

332
00:21:13,260 --> 00:21:17,868
To understand what is going on, let's check sil first

333
00:21:17,954 --> 00:21:21,836
interesting part could be the method definition. The important

334
00:21:21,938 --> 00:21:25,436
part here to notice is that at seal level,

335
00:21:25,538 --> 00:21:29,096
the default value is not present at method definition

336
00:21:29,208 --> 00:21:32,944
and implementation, though the method expects an

337
00:21:32,982 --> 00:21:36,684
argument of type date. So where does the default

338
00:21:36,732 --> 00:21:40,284
value live? Looking further into seal,

339
00:21:40,412 --> 00:21:44,660
we see that default value is actually defined in a separate place,

340
00:21:44,810 --> 00:21:48,576
and is wrapped in a function that takes no arguments

341
00:21:48,688 --> 00:21:52,724
and produces our expected type. So how does

342
00:21:52,762 --> 00:21:56,304
this all work together? At the call bite, the first

343
00:21:56,362 --> 00:21:59,704
three lines in this last snippet are responsible for

344
00:21:59,742 --> 00:22:03,736
getting our default value, but of that method we just so and

345
00:22:03,758 --> 00:22:07,116
the next two just call the implementation retrieved from the

346
00:22:07,138 --> 00:22:10,476
class. It's important to note that the

347
00:22:10,498 --> 00:22:14,700
class method instruction here retrieves the implementation based

348
00:22:14,770 --> 00:22:18,492
on the dynamic type of the object. So what

349
00:22:18,546 --> 00:22:21,360
chance when we introduce the subclass,

350
00:22:22,500 --> 00:22:26,160
we obviously still have our default argument getter for the cases

351
00:22:26,230 --> 00:22:29,852
class, and unsurprisingly, another one appeared

352
00:22:29,916 --> 00:22:31,680
dedicated for the subclass.

353
00:22:32,360 --> 00:22:35,684
Now the interesting thing that happens is

354
00:22:35,722 --> 00:22:39,600
at the call side, because apparently nothing changed.

355
00:22:39,760 --> 00:22:43,444
The call side still looks exactly the same. If we

356
00:22:43,482 --> 00:22:47,040
look at some earlier parts, though, we'll see that Swift

357
00:22:47,120 --> 00:22:50,648
knew that it was dealing with a subclass and

358
00:22:50,734 --> 00:22:53,784
stored it in a variable typed to a base class.

359
00:22:53,982 --> 00:22:57,836
So what we learned from all this is that while the method to call

360
00:22:57,938 --> 00:23:01,532
is found dynamically, the default value is

361
00:23:01,586 --> 00:23:05,356
still inferred statically based on what type information we

362
00:23:05,378 --> 00:23:08,300
have at the moment of calling the method.

363
00:23:08,800 --> 00:23:12,256
So what to do with it? Is this a

364
00:23:12,278 --> 00:23:15,424
bug or a feature? Hard to say.

365
00:23:15,622 --> 00:23:19,212
Kotlin, for example, explicitly disallows providing

366
00:23:19,276 --> 00:23:23,316
default values in overridden methods, so this short snippet will

367
00:23:23,338 --> 00:23:25,620
throw a nice and descriptive error.

368
00:23:27,640 --> 00:23:31,728
And what about Swift? Should it be explicitly disallowed

369
00:23:31,824 --> 00:23:35,680
or improved? For me, both of those options

370
00:23:35,770 --> 00:23:39,176
sound good. This behavior is around since the

371
00:23:39,198 --> 00:23:42,904
very first versions of Swift, and apparently there was

372
00:23:42,942 --> 00:23:46,664
some will to tackle. This has mentioned in this blog post from

373
00:23:46,702 --> 00:23:50,376
2014, but since that time these mentioned and linked

374
00:23:50,408 --> 00:23:54,396
foreign thread is no longer available. It's definitely one

375
00:23:54,418 --> 00:23:58,056
of those behaviors that may not happen often, but it's

376
00:23:58,168 --> 00:24:01,664
good to have knowledge of it in the back of your mind when it does

377
00:24:01,702 --> 00:24:05,420
occur. Fortunately, these are other approaches

378
00:24:05,500 --> 00:24:09,324
to achieving similar behavior to what was shown in these somewhat

379
00:24:09,372 --> 00:24:14,144
forced code samples, like using protocols instead of inheritance

380
00:24:14,272 --> 00:24:18,336
to support different date printers. Last topic

381
00:24:18,368 --> 00:24:21,840
of the day extensions or more precisely,

382
00:24:21,920 --> 00:24:25,764
protocol extensions. This is again a great language

383
00:24:25,812 --> 00:24:29,668
feature that can help us, but as you probably imagine,

384
00:24:29,764 --> 00:24:32,948
there is a small catch under stamp circumstances.

385
00:24:33,124 --> 00:24:36,836
Let's extend our focus a little bit and let me show

386
00:24:36,878 --> 00:24:40,796
you what I'm talking about. To prepare the

387
00:24:40,818 --> 00:24:44,892
ground for this, let's quickly recap how overloading works

388
00:24:44,946 --> 00:24:48,072
in Swift so we are free to overload

389
00:24:48,136 --> 00:24:51,712
methods, meaning we can have multiple methods with the same

390
00:24:51,766 --> 00:24:55,104
name that differ on these return type or

391
00:24:55,142 --> 00:24:58,604
on the argument types they accept. This isn't

392
00:24:58,652 --> 00:25:02,244
true for properties though. As soon as we create a second

393
00:25:02,282 --> 00:25:05,524
property with the same name, we are getting an

394
00:25:05,562 --> 00:25:07,700
invalid redeclaration error.

395
00:25:08,840 --> 00:25:13,364
Another thing to recap protocol extensions in

396
00:25:13,402 --> 00:25:17,112
objective C we could have marked some protocol requirements with

397
00:25:17,166 --> 00:25:20,980
add optional annotation which allowed conforming types

398
00:25:21,060 --> 00:25:24,756
to not provide implementation for them, but the call bite

399
00:25:24,788 --> 00:25:28,492
had to check if that method was implemented which created some

400
00:25:28,546 --> 00:25:32,168
amount of boilerplate code. Pure Swift

401
00:25:32,264 --> 00:25:35,676
doesn't allow us to make protocol requirements optional in

402
00:25:35,698 --> 00:25:39,320
the same sense as objective seeded, but we can still

403
00:25:39,410 --> 00:25:43,132
create an extension that will provide a default

404
00:25:43,196 --> 00:25:46,480
implementation of a requirement. It may not always

405
00:25:46,550 --> 00:25:50,096
make sense to have a default that hugely depends on

406
00:25:50,118 --> 00:25:54,300
your domain, but when it does you can allow conforming types

407
00:25:54,380 --> 00:25:58,132
to skip implementing those methods. They can still

408
00:25:58,186 --> 00:26:02,388
do it, and if they do, the specialized one will be used.

409
00:26:02,554 --> 00:26:07,000
So let's see how this works with property requirements.

410
00:26:07,340 --> 00:26:10,948
Let us consider this snippet. We have a printer method

411
00:26:11,044 --> 00:26:14,516
that expects a string and just well prints

412
00:26:14,548 --> 00:26:17,956
it. We have a simple value provider with optional

413
00:26:17,988 --> 00:26:21,864
string value and a default implementation for it that returns

414
00:26:21,912 --> 00:26:25,324
nil. Finally, we have a conforming type

415
00:26:25,442 --> 00:26:28,270
with a specialized implementation for that property.

416
00:26:29,040 --> 00:26:32,768
So what do you think? What should be the result

417
00:26:32,854 --> 00:26:34,370
of running this program?

418
00:26:38,020 --> 00:26:41,968
If your intuition said that it should fail to compile because

419
00:26:42,054 --> 00:26:46,164
printer expects a nonopional string and value in

420
00:26:46,202 --> 00:26:49,632
value provider is defined as optional. Then congrats.

421
00:26:49,776 --> 00:26:52,980
You spotted the first tricky part of the sample,

422
00:26:53,400 --> 00:26:56,836
but actually this code does compile

423
00:26:57,028 --> 00:27:00,584
and it will print foo. To understand why,

424
00:27:00,702 --> 00:27:04,472
let's check two things. First, adding two

425
00:27:04,526 --> 00:27:08,464
variables with explicit type, first nonoptional,

426
00:27:08,532 --> 00:27:12,236
the second one optional. This immediately gives us

427
00:27:12,258 --> 00:27:16,124
a hint to what is going on. We actually have two

428
00:27:16,162 --> 00:27:19,150
properties with the same name but different type.

429
00:27:19,680 --> 00:27:24,050
When we thought we overrode the default implementation of value property,

430
00:27:24,420 --> 00:27:27,964
we actually didn't. The compiler inferred

431
00:27:28,012 --> 00:27:31,020
our type to be nonoptional string,

432
00:27:31,180 --> 00:27:34,912
and since it also saw that there is a default implementation

433
00:27:34,976 --> 00:27:38,244
for the optional one, it happily synthesized it for

434
00:27:38,282 --> 00:27:41,412
us. But didn't we just

435
00:27:41,466 --> 00:27:44,576
see that property overloading is not permitted in

436
00:27:44,618 --> 00:27:48,056
swift? Before we dive deeper to see how

437
00:27:48,078 --> 00:27:51,688
this works, let me also show you a second way to access

438
00:27:51,774 --> 00:27:55,320
both properties. Depending on static type

439
00:27:55,390 --> 00:27:59,556
known to the compiler, it will also those either the nonopional

440
00:27:59,588 --> 00:28:03,308
value defined in these struct or the optional one defined in

441
00:28:03,314 --> 00:28:07,544
the protocol and its extension. For the rest of this topic we'll

442
00:28:07,592 --> 00:28:11,536
focus on this part, accessing the property when

443
00:28:11,558 --> 00:28:14,850
we have different information about the object's type.

444
00:28:16,020 --> 00:28:19,068
Now this is a little tricky to show on slides,

445
00:28:19,164 --> 00:28:22,472
but I hope I'll be able to explain this properly.

446
00:28:22,636 --> 00:28:26,128
We'll look at how the default property is synthesized

447
00:28:26,224 --> 00:28:30,196
and accessed, starting from a very simplified example,

448
00:28:30,378 --> 00:28:34,512
and then we'll build our understanding from there. These first

449
00:28:34,586 --> 00:28:38,308
case is the simplest one, no custom overriding.

450
00:28:38,404 --> 00:28:42,196
We just declare the conformance and let the default implementation

451
00:28:42,308 --> 00:28:45,860
do its thing first. Interesting thing in SIL

452
00:28:45,940 --> 00:28:49,516
is the implementation of the default value. It looks

453
00:28:49,618 --> 00:28:53,452
like it's not tied to the conforming type in any way and

454
00:28:53,506 --> 00:28:57,288
lives in its own static context of value provider.

455
00:28:57,464 --> 00:29:01,196
These information is important, so let's keep it handy

456
00:29:01,308 --> 00:29:04,592
and just for reference let's highlight the seal name

457
00:29:04,646 --> 00:29:07,888
of this and these signature. Another important

458
00:29:07,974 --> 00:29:11,184
thing to notice is that at this point there is

459
00:29:11,222 --> 00:29:14,240
no reference to value in terms of our struct,

460
00:29:14,400 --> 00:29:17,350
since it doesn't have that property itself.

461
00:29:18,600 --> 00:29:22,496
So when we try to access the property directly on foo,

462
00:29:22,608 --> 00:29:25,888
the compiler is smart enough to know that the

463
00:29:25,914 --> 00:29:29,540
only candidate is the one from the protocol extension,

464
00:29:29,620 --> 00:29:34,360
so it can optimize a little bit and call that implementation directly.

465
00:29:34,860 --> 00:29:38,516
If we try to access it on the protocol, things get a little

466
00:29:38,558 --> 00:29:42,076
more complicated. First of all, since we lost the

467
00:29:42,098 --> 00:29:45,484
information of the actual type, we need to reach into the

468
00:29:45,522 --> 00:29:49,336
existential to find it again and then find the method

469
00:29:49,368 --> 00:29:53,280
we are looking for. These type information is preserved here

470
00:29:53,430 --> 00:29:56,204
and since we are looking for a witness method,

471
00:29:56,332 --> 00:29:59,452
let's open that existential and look at the witness

472
00:29:59,516 --> 00:30:02,740
table. The witness table is pretty

473
00:30:02,810 --> 00:30:06,404
simple. It defines just the getter for our property,

474
00:30:06,602 --> 00:30:10,688
since that's all that our protocol defines and requires.

475
00:30:10,864 --> 00:30:14,632
The entry in the witness table points at a method that just

476
00:30:14,686 --> 00:30:18,056
calls our default implementation, which makes sense

477
00:30:18,158 --> 00:30:21,370
since it's the only possible candidate to do it.

478
00:30:22,300 --> 00:30:25,816
Next step, we provide a proper implementation of

479
00:30:25,838 --> 00:30:29,432
the protocol requirement by explicitly stating

480
00:30:29,576 --> 00:30:33,756
that we want value to be of optional string type.

481
00:30:33,938 --> 00:30:37,116
So what changed in seal? First of

482
00:30:37,138 --> 00:30:40,716
all, our struct finally got a dedicated getter

483
00:30:40,748 --> 00:30:44,240
for the value property. The call site to get value

484
00:30:44,310 --> 00:30:48,464
directly from foo instance now looks a little different.

485
00:30:48,662 --> 00:30:51,936
It's simple, direct access to a value stored at

486
00:30:51,958 --> 00:30:55,612
an address in memory. And the last part that chance

487
00:30:55,676 --> 00:30:59,636
is the witness method implementation. Now it showed that

488
00:30:59,658 --> 00:31:02,960
there is a magic candidate in the conforming struct,

489
00:31:03,120 --> 00:31:06,052
so instead of calling the default implementation,

490
00:31:06,196 --> 00:31:09,016
it will now call the specialized one.

491
00:31:09,198 --> 00:31:13,080
Finally, by removing the explicit type annotation, we reach

492
00:31:13,150 --> 00:31:16,896
our original sample. The call sites have not chance

493
00:31:16,948 --> 00:31:20,584
from this. Accessing the property directly on foo

494
00:31:20,712 --> 00:31:24,536
still just extracts it from the struct and accessing

495
00:31:24,568 --> 00:31:28,060
it on the protocol still reaches into the existential.

496
00:31:28,560 --> 00:31:32,156
These first change that happened in seal is in the value getter

497
00:31:32,188 --> 00:31:36,032
on our struct. It is still there, obviously, but its type

498
00:31:36,086 --> 00:31:40,044
has changed. It no longer returns an optional string,

499
00:31:40,172 --> 00:31:43,232
but just a plain string. The compiler

500
00:31:43,296 --> 00:31:47,296
inferred the type for us and that change led

501
00:31:47,328 --> 00:31:50,756
to another since there wasn't a matching candidate in

502
00:31:50,778 --> 00:31:53,888
the struct anymore for our protocol requirement,

503
00:31:54,064 --> 00:31:58,052
since the types didn't match the witness method implementation,

504
00:31:58,196 --> 00:32:01,044
those the only other matching candidate.

505
00:32:01,172 --> 00:32:04,616
The default implementation leading to the behavior we

506
00:32:04,638 --> 00:32:08,140
saw earlier and the fact that we have two properties,

507
00:32:08,960 --> 00:32:12,456
there is actually a way to detect this. If you define

508
00:32:12,488 --> 00:32:16,044
your protocol conformance in an extension, you will get

509
00:32:16,082 --> 00:32:20,136
a nice near miss warning, which is great for functions.

510
00:32:20,248 --> 00:32:23,708
But since we cannot have stored properties in extensions,

511
00:32:23,884 --> 00:32:27,008
a pattern that I quite often see, and to be honest, one that I

512
00:32:27,014 --> 00:32:31,676
also use myself, is to provide protocol property requirements

513
00:32:31,788 --> 00:32:35,584
in the cases type definition to be able to fulfill

514
00:32:35,632 --> 00:32:39,040
them using stored properties. While this sample

515
00:32:39,120 --> 00:32:42,560
may seem like something that isn't that probable

516
00:32:42,640 --> 00:32:46,292
to happen in your code, or maybe something that would get caught

517
00:32:46,356 --> 00:32:49,992
during code review, it definitely gets more possible once

518
00:32:50,046 --> 00:32:53,736
the protocol and its default implementation come from a

519
00:32:53,758 --> 00:32:58,264
third party framework and we would be unaware of it at all.

520
00:32:58,462 --> 00:33:02,136
Or once generics get mixed up with this. I encountered

521
00:33:02,168 --> 00:33:05,996
this behavior when a colleague of mine mentioned it on Twitter with a

522
00:33:06,018 --> 00:33:09,748
little more complex code. Sample one involving protocols

523
00:33:09,784 --> 00:33:13,664
with associated type, where the compiler inferred not only

524
00:33:13,702 --> 00:33:17,404
the property type, but also the type for the associated

525
00:33:17,452 --> 00:33:20,480
type, which made the entire thing a lot

526
00:33:20,550 --> 00:33:24,870
trickier. To understand and see what is actually going on,

527
00:33:25,320 --> 00:33:28,980
check out the first link if you are interested to see that sample.

528
00:33:29,560 --> 00:33:33,364
This was raised on the swift forums, where you can also read more

529
00:33:33,402 --> 00:33:36,836
about it. While originally reported as a back

530
00:33:36,938 --> 00:33:40,356
it turns, but it's not one, since this possibility to

531
00:33:40,378 --> 00:33:43,812
do that is required to be supported to allow for

532
00:33:43,866 --> 00:33:46,340
seamless language and library evolution.

533
00:33:47,280 --> 00:33:50,952
And that's all. Thank you for listening.

534
00:33:51,096 --> 00:33:54,524
I hope you found these cases at least half as interesting

535
00:33:54,722 --> 00:33:58,030
as they were for me to investigate and research.

536
00:33:58,560 --> 00:34:02,248
If you'd have any questions, feel free to reach out and chat.

537
00:34:02,424 --> 00:34:03,960
Enjoy the rest of the conference.

