1
00:00:27,890 --> 00:00:31,526
Hi there, I'm Joshua Arvin Lat and I'm going

2
00:00:31,548 --> 00:00:34,514
to talk about pragmatic state management in react,

3
00:00:34,642 --> 00:00:37,986
angular and UGS applications.

4
00:00:38,178 --> 00:00:41,830
So in this session we will share

5
00:00:41,900 --> 00:00:45,526
some practical tips and techniques that I've learned over these past couple of

6
00:00:45,548 --> 00:00:48,950
years when dealing with these libraries and frameworks.

7
00:00:49,610 --> 00:00:53,840
So so before we start, I'm going to introducing myself.

8
00:00:54,450 --> 00:00:58,010
I am Joshua Arvin Lat. I am the chief technology officer

9
00:00:58,090 --> 00:01:02,186
of Nuworks Interactive Labs. We build a lot of websites,

10
00:01:02,218 --> 00:01:05,726
we build a lot of applications, and I'm going to use

11
00:01:05,748 --> 00:01:09,218
some of the things that we've learned there along with some of the things that

12
00:01:09,224 --> 00:01:13,294
I've learned in my previous companies. Also these we use all of these libraries

13
00:01:13,342 --> 00:01:16,774
and frameworks to build basic to more

14
00:01:16,812 --> 00:01:20,994
complex websites and applications. I'm also an AWS

15
00:01:21,042 --> 00:01:24,626
machine learning hero and I'm the author of the book Machine

16
00:01:24,658 --> 00:01:26,950
Learning with Amazon Sagemaker Cookbook.

17
00:01:30,010 --> 00:01:33,340
So if you would like to take a look at my book,

18
00:01:33,710 --> 00:01:37,306
you'll probably find there things that you need in order to get

19
00:01:37,328 --> 00:01:40,314
your machine learning applications working in the cloud.

20
00:01:40,432 --> 00:01:44,110
So yeah, feel free to check it out. However, for today

21
00:01:44,180 --> 00:01:48,026
we're going to talk about web application development with react,

22
00:01:48,138 --> 00:01:51,434
Vuejs and angular and all the other state management

23
00:01:51,482 --> 00:01:56,642
libraries. So let's start so

24
00:01:56,696 --> 00:02:00,546
let's say that we were given a

25
00:02:00,568 --> 00:02:04,450
project, a project that involves let's say about

26
00:02:04,520 --> 00:02:09,062
four developers, maybe one product managing one

27
00:02:09,116 --> 00:02:12,120
QA and then one DevOps person,

28
00:02:13,210 --> 00:02:16,680
and we are supposed to build an e commerce application.

29
00:02:17,370 --> 00:02:20,566
So after about maybe one to two months of planning,

30
00:02:20,678 --> 00:02:24,454
your team has decided CTO use these certain tech stack.

31
00:02:24,502 --> 00:02:28,070
And then after a bit of research also you have decided

32
00:02:28,150 --> 00:02:31,390
to use a state management library to

33
00:02:31,460 --> 00:02:35,386
further improve the overall organization and architecture

34
00:02:35,418 --> 00:02:36,320
of your application.

35
00:02:38,610 --> 00:02:41,518
So in the first couple of weeks,

36
00:02:41,684 --> 00:02:46,370
the team is super excited trying out these new tools because almost

37
00:02:46,440 --> 00:02:49,726
everyone has never used the shiny new tools,

38
00:02:49,758 --> 00:02:52,914
especially the state management libraries. But of course,

39
00:02:52,952 --> 00:02:56,562
you did some research before you got started and you did tell

40
00:02:56,616 --> 00:03:00,938
everyone that yeah, after reading some blog posts,

41
00:03:01,134 --> 00:03:05,142
a lot of people did get successful using

42
00:03:05,276 --> 00:03:07,190
the state management libraries.

43
00:03:08,670 --> 00:03:13,658
However, after two months using

44
00:03:13,744 --> 00:03:17,558
these different tools and libraries, you've realized

45
00:03:17,654 --> 00:03:21,760
that things are not working out and

46
00:03:23,250 --> 00:03:26,954
you initially thought that the project would be easier using these tools.

47
00:03:27,002 --> 00:03:30,286
However, the tools seem to

48
00:03:30,308 --> 00:03:33,774
be making things much harder than it's supposed to be and

49
00:03:33,812 --> 00:03:37,682
there's no going back because the tool is being used in different

50
00:03:37,736 --> 00:03:41,442
parts of your application. And if you were to refactor things

51
00:03:41,496 --> 00:03:45,166
again and remove the usage of these certain libraries and tools,

52
00:03:45,198 --> 00:03:48,454
these, it might add an additional, let's say one

53
00:03:48,492 --> 00:03:51,960
month CTo, two months just to get it back to a stable state.

54
00:03:52,570 --> 00:03:55,942
So this is probably how your team looks

55
00:03:55,996 --> 00:03:59,270
like after it has encountered a lot of blockers,

56
00:03:59,350 --> 00:04:03,018
especially if the tool is not helping you. And instead

57
00:04:03,104 --> 00:04:06,506
it's, yeah, like I said earlier, giving you a much harder time to

58
00:04:06,528 --> 00:04:08,010
get things rolling.

59
00:04:10,850 --> 00:04:14,714
So the question here is, and this is a really tricky

60
00:04:14,762 --> 00:04:18,682
question to answer, is when do we use an additional

61
00:04:18,746 --> 00:04:21,790
state management library? And before we answer that,

62
00:04:21,940 --> 00:04:25,186
let's ask ourselves what a state management library and

63
00:04:25,208 --> 00:04:29,810
what is state? So when you're dealing with applications,

64
00:04:31,430 --> 00:04:35,380
the UI, the thing that you see would always be

65
00:04:36,310 --> 00:04:40,182
rendered there and it's a function of

66
00:04:40,236 --> 00:04:43,478
the data in the state. So if, let's say that this is

67
00:04:43,484 --> 00:04:46,694
your value and then this is going to be your UI. So if

68
00:04:46,732 --> 00:04:50,380
your value changes, then the UI should update as well.

69
00:04:50,750 --> 00:04:54,022
As we have more components in our site, the usual

70
00:04:54,086 --> 00:04:57,446
challenge here is how do we make these components communicate

71
00:04:57,478 --> 00:05:01,338
with each other? How do we manage state? And even when we're

72
00:05:01,354 --> 00:05:05,230
already using react, view and angular, we do feel

73
00:05:05,300 --> 00:05:09,520
that after the code gets a bit messier and data

74
00:05:10,290 --> 00:05:13,998
is being passed through the different props and different things,

75
00:05:14,164 --> 00:05:17,538
we start to think about is there a better way to do this?

76
00:05:17,704 --> 00:05:20,754
And a lot of us would say, yeah, maybe let's use

77
00:05:20,792 --> 00:05:22,530
a state management library.

78
00:05:23,830 --> 00:05:27,526
So here are some of the options available, and of course this is not an

79
00:05:27,548 --> 00:05:30,280
exhaustive list, there are so many options out there.

80
00:05:30,810 --> 00:05:35,954
But let's say you have NGRX, you have MoBX, you have redux,

81
00:05:36,082 --> 00:05:39,994
recoil, viewx and more. And the

82
00:05:40,032 --> 00:05:44,678
question here now is when do we use an additional state management libraries

83
00:05:44,854 --> 00:05:48,454
to support our needs when using the libraries

84
00:05:48,502 --> 00:05:52,366
and frameworks that we have. So the

85
00:05:52,388 --> 00:05:56,746
next couple of minutes would be focused

86
00:05:56,778 --> 00:06:00,238
on answering that. But let's start first with

87
00:06:00,324 --> 00:06:03,060
this simple examples.

88
00:06:03,750 --> 00:06:06,258
So if we have a very simple application,

89
00:06:06,424 --> 00:06:09,826
these, we have one parent component and then we

90
00:06:09,848 --> 00:06:13,650
have two child components where these child component

91
00:06:13,990 --> 00:06:17,542
needs to do some

92
00:06:17,596 --> 00:06:21,094
sort of action or modification on

93
00:06:21,132 --> 00:06:23,590
child number two on a sibling.

94
00:06:24,970 --> 00:06:28,760
So one way to do it is for

95
00:06:30,170 --> 00:06:34,134
child one to communicate CTO parent to its parents

96
00:06:34,182 --> 00:06:38,138
and then finding a way for the parent to

97
00:06:38,304 --> 00:06:40,880
send that message to child number two.

98
00:06:41,490 --> 00:06:44,986
So this seems pretty straightforward and we can technically survive

99
00:06:45,018 --> 00:06:49,230
without using any sort of additional state management layer.

100
00:06:49,810 --> 00:06:53,742
And this is usually one of these easier examples there

101
00:06:53,796 --> 00:06:56,946
because yeah, the code will not

102
00:06:56,968 --> 00:07:00,526
be as complex and it's also something that's

103
00:07:00,558 --> 00:07:03,714
readable and easy to debug. So if there's something wrong with, let's say,

104
00:07:03,752 --> 00:07:07,698
child number one, and we need to fix it. It's easy to find everything that's

105
00:07:07,714 --> 00:07:09,400
connected to child number one.

106
00:07:10,570 --> 00:07:14,630
However, once things get a bit more complicated,

107
00:07:16,970 --> 00:07:20,554
and especially if our needs would involve, let's say,

108
00:07:20,592 --> 00:07:23,980
having a grandchild, let's say, as seen in this image here,

109
00:07:24,510 --> 00:07:28,186
one of the grandchildren of child one needs to

110
00:07:28,208 --> 00:07:31,806
talk to one of the grandchildren of child two. So if

111
00:07:31,828 --> 00:07:35,790
we need to cases that message or pass

112
00:07:35,860 --> 00:07:39,680
that event to the other

113
00:07:41,010 --> 00:07:45,822
grandchild, which is not directly accessible

114
00:07:45,966 --> 00:07:49,918
from the first grandchild, then we have to do some sort of prop drilling

115
00:07:49,934 --> 00:07:53,394
mechanism where grandchild passes its

116
00:07:53,432 --> 00:07:57,174
data to child one, goes to the parent, goes to child two,

117
00:07:57,212 --> 00:08:00,934
and then goes CTO the grandchild. And yeah, you're probably

118
00:08:00,972 --> 00:08:05,222
aware that the more levels we have here, and the more things

119
00:08:05,276 --> 00:08:08,442
that's happening internally, the more complex the

120
00:08:08,496 --> 00:08:12,250
code becomes. And instead of us being able to make the most

121
00:08:12,320 --> 00:08:15,674
out of this concept of being able to

122
00:08:15,712 --> 00:08:19,446
identify which things are interconnected

123
00:08:19,478 --> 00:08:22,906
or related to each other, it's using to look like some

124
00:08:22,928 --> 00:08:26,494
sort of a spaghetti code, especially if some of the grandchildren will not

125
00:08:26,532 --> 00:08:30,254
really make use of the data which the other grandchildren would

126
00:08:30,292 --> 00:08:34,066
need. And there are different ways to solve this. And one of the

127
00:08:34,088 --> 00:08:38,094
major issues that teams encounter

128
00:08:38,142 --> 00:08:40,878
is that these immediately jump into solutions.

129
00:08:41,054 --> 00:08:44,334
Especially when they encounter this prop drilling scenario,

130
00:08:44,462 --> 00:08:47,602
they automatically decide

131
00:08:47,666 --> 00:08:51,910
to use a state management library. And that's

132
00:08:52,810 --> 00:08:56,118
a wrong thing to do. Why? Because you can

133
00:08:56,284 --> 00:08:59,450
technically solve this with other solutions,

134
00:09:00,030 --> 00:09:01,420
which we'll see later.

135
00:09:03,790 --> 00:09:06,938
So what's our overall objective anyway? If we were to

136
00:09:06,944 --> 00:09:10,654
take a step back? Our goal is to be able

137
00:09:10,692 --> 00:09:14,126
to manage this mess. And whenever the

138
00:09:14,148 --> 00:09:19,598
team is growing, whenever we have to deal with a

139
00:09:19,604 --> 00:09:23,470
code base that has its size increasing

140
00:09:23,550 --> 00:09:27,490
every single day, and the separation of

141
00:09:27,560 --> 00:09:30,914
code and the functions and the

142
00:09:30,952 --> 00:09:34,562
different things that's happening inside start to get more

143
00:09:34,696 --> 00:09:38,534
blurry, then we need some way to organize things a bit,

144
00:09:38,572 --> 00:09:42,694
so that when we need to look for something, it's easy to find where

145
00:09:42,732 --> 00:09:43,800
to fix the problem.

146
00:09:45,850 --> 00:09:49,394
And one of the things that people are talking about

147
00:09:49,452 --> 00:09:53,386
when using state managing libraries is that in

148
00:09:53,408 --> 00:09:57,002
most cases, you're going to deal with a lot of boilerplate code.

149
00:09:57,136 --> 00:10:00,942
And in the beginning, when you're talking about 20 lines of code,

150
00:10:01,076 --> 00:10:05,694
without those additional state management libraries, people complain that,

151
00:10:05,892 --> 00:10:09,550
yeah, those 20 lines will become 20

152
00:10:09,620 --> 00:10:12,586
lines plus ten, plus ten, plus ten, total of 50 lines.

153
00:10:12,618 --> 00:10:16,146
And that's just one example of this. And even for

154
00:10:16,168 --> 00:10:19,774
the simple things, we need to add a lot of boilerplate

155
00:10:19,822 --> 00:10:22,978
code, which already affects people,

156
00:10:23,064 --> 00:10:26,430
because they're going to put and add a lot of files,

157
00:10:26,510 --> 00:10:30,006
they're going to add a lot of code, which may not make sense, especially at

158
00:10:30,028 --> 00:10:32,440
the start when the project is still small.

159
00:10:33,130 --> 00:10:36,918
Of course, when the project gets bigger, you'll start to realize, okay,

160
00:10:37,004 --> 00:10:40,602
maybe that makes sense, but this really depends on the project.

161
00:10:40,656 --> 00:10:43,610
This really depends on the type of state that you're dealing with,

162
00:10:43,760 --> 00:10:46,700
and there are a lot of factors we need to consider.

163
00:10:50,180 --> 00:10:54,180
So if we were to understand what's really happening here, it's like

164
00:10:54,250 --> 00:10:57,716
if we're just dealing with a really small application, let's say on

165
00:10:57,738 --> 00:11:01,140
the left side, we have a refrigerator and

166
00:11:01,290 --> 00:11:05,528
we need to manage and

167
00:11:05,614 --> 00:11:08,676
organize things a bit where to put the vegetables,

168
00:11:08,708 --> 00:11:12,040
the fruits and everything inside the refrigerator.

169
00:11:12,540 --> 00:11:15,908
If we try to over engineer things a bit accidentally,

170
00:11:16,004 --> 00:11:19,436
we may end up having this sort of container system

171
00:11:19,618 --> 00:11:23,470
where most of these would be empty space and we would have more

172
00:11:24,080 --> 00:11:27,612
boilerplate code than the actual relevant code

173
00:11:27,746 --> 00:11:31,504
itself, which is a bad thing. And the goal here is for us

174
00:11:31,542 --> 00:11:36,000
to understand when's the best time to

175
00:11:36,150 --> 00:11:39,632
use these layers to keep things

176
00:11:39,686 --> 00:11:43,776
organized. So the

177
00:11:43,798 --> 00:11:47,124
first thing we need to do is to try solving this by

178
00:11:47,162 --> 00:11:50,756
making the most out of what we have first. What do

179
00:11:50,778 --> 00:11:54,740
we mean by that? Let's try not installing additional

180
00:11:54,820 --> 00:11:58,696
libraries first, because in most cases you

181
00:11:58,718 --> 00:12:02,376
will be surprised that these libraries and frameworks may be more

182
00:12:02,398 --> 00:12:04,410
than enough to get things done.

183
00:12:05,740 --> 00:12:09,484
I'll repeat again, in most cases we'll most

184
00:12:09,522 --> 00:12:12,728
likely be able to get this done with these libraries and frameworks.

185
00:12:12,744 --> 00:12:16,844
So view angular and react even

186
00:12:16,882 --> 00:12:19,684
without installing, let's say recoil, redux,

187
00:12:19,752 --> 00:12:20,720
Mobex,

188
00:12:22,820 --> 00:12:26,144
NgrX, rxgs and so on,

189
00:12:26,342 --> 00:12:29,616
we'll be able to manage things a bit. Because sometimes

190
00:12:29,718 --> 00:12:32,856
people think, okay, we need to manage redox,

191
00:12:32,988 --> 00:12:36,864
when in fact these libraries and frameworks already have its own internal

192
00:12:36,912 --> 00:12:40,790
mechanisms to get things organized and

193
00:12:41,160 --> 00:12:45,044
dynamic. So here are

194
00:12:45,082 --> 00:12:48,664
some of the things that you can use. And let's say

195
00:12:48,702 --> 00:12:52,424
that if you were to use use context and use effect and use ref and

196
00:12:52,462 --> 00:12:55,912
use state with react, you'll be able

197
00:12:55,966 --> 00:12:59,944
to take on the basic to medium sized projects

198
00:13:00,072 --> 00:13:04,488
even without using redux or other state management

199
00:13:04,584 --> 00:13:07,816
libraries with angular. Given that you're

200
00:13:07,848 --> 00:13:12,204
dealing here with a framework with a lot of things already installed

201
00:13:12,252 --> 00:13:16,210
there and ready for you to use, you can use a shared service

202
00:13:18,260 --> 00:13:21,810
instead of NgRX first. Maybe a shared service

203
00:13:22,180 --> 00:13:25,892
where different components are able to talk to that shared service

204
00:13:26,026 --> 00:13:29,876
would do the trick, especially for projects that are

205
00:13:29,898 --> 00:13:33,868
being converted which are getting a bit more complex but still considered

206
00:13:33,904 --> 00:13:37,288
medium sized. And then yeah, with a bit

207
00:13:37,294 --> 00:13:40,788
of dependency injection. Also, you can combine

208
00:13:40,804 --> 00:13:44,376
that with the different strategies inside angular to

209
00:13:44,398 --> 00:13:48,424
keep things organized in your angular app and then

210
00:13:48,462 --> 00:13:51,656
for view js. Maybe you can start first with

211
00:13:51,838 --> 00:13:55,052
the mentals, the foundational building

212
00:13:55,106 --> 00:13:58,952
blocks of Vuejs, and then yeah, try to implement also some

213
00:13:59,026 --> 00:14:03,056
other techniques like using a simple global store and maybe

214
00:14:03,238 --> 00:14:06,880
a global event bus and understanding how

215
00:14:06,950 --> 00:14:10,736
these things work, you would be able to

216
00:14:10,838 --> 00:14:14,372
organize things better. And it does not

217
00:14:14,426 --> 00:14:17,716
involve a lot of boilerplate code, especially yeah,

218
00:14:17,898 --> 00:14:21,204
in the similar examples earlier where you're just

219
00:14:21,242 --> 00:14:24,660
dealing with basic to medium sized applications.

220
00:14:25,800 --> 00:14:29,176
There are other techniques which I will not share here,

221
00:14:29,278 --> 00:14:32,424
so feel free to take a look because the goal here is to

222
00:14:32,462 --> 00:14:36,088
be able to maximize the tools first before

223
00:14:36,174 --> 00:14:39,900
introducing new ones. Because the moment you introduce new

224
00:14:39,970 --> 00:14:43,916
tools in your arsenal and in your project,

225
00:14:44,098 --> 00:14:47,308
all developers of that project involved in

226
00:14:47,314 --> 00:14:51,248
that project needed to learn these new tools as well.

227
00:14:51,414 --> 00:14:54,720
So the familiarity level takes

228
00:14:54,790 --> 00:14:57,964
time. Being able to be more familiar with these tools

229
00:14:58,012 --> 00:15:01,480
take time and as much as possible, try to limit

230
00:15:01,500 --> 00:15:04,630
the tools, especially when the other tools are not yet needed.

231
00:15:08,840 --> 00:15:12,528
So here we can see that if we were to use react

232
00:15:12,624 --> 00:15:16,144
and redux, when the

233
00:15:16,202 --> 00:15:19,304
project is somewhat smaller at the

234
00:15:19,342 --> 00:15:23,048
start, you will start to feel that, yeah, there's a

235
00:15:23,054 --> 00:15:26,344
lot of boilerplate code and the relevant logic code is just a piece

236
00:15:26,382 --> 00:15:29,636
of it. So you'll probably feel when it's

237
00:15:29,668 --> 00:15:34,684
best to use redox. And one of the

238
00:15:34,722 --> 00:15:38,344
technique that can be used here would be to use, let's say something like redux

239
00:15:38,392 --> 00:15:41,984
toolkit to reduce the boilerplate code. So do some

240
00:15:42,022 --> 00:15:45,884
research first before taking things on, because there might be newer

241
00:15:45,932 --> 00:15:49,232
solutions as we go along when you're using certain

242
00:15:49,286 --> 00:15:53,168
tools and frameworks, because that's one of the known weaknesses

243
00:15:53,344 --> 00:15:56,260
of using this state management libraries.

244
00:15:58,040 --> 00:16:01,892
What if, let's say we use Mobex to

245
00:16:01,946 --> 00:16:05,064
replace Redux? So for one thing,

246
00:16:05,102 --> 00:16:10,936
people think that redux and react are

247
00:16:10,958 --> 00:16:14,410
the partners when it cases to state management in react. However,

248
00:16:15,820 --> 00:16:19,844
that part is interchangeable and we can use other state management

249
00:16:19,892 --> 00:16:23,772
libraries with react. So for Mobex, for example,

250
00:16:23,906 --> 00:16:26,696
there's more magic when using Mobex.

251
00:16:26,808 --> 00:16:30,240
And of course the assumptions are a bit different here because the way it works

252
00:16:30,310 --> 00:16:34,476
is super, is kind of different as with redux.

253
00:16:34,668 --> 00:16:38,832
So there's definitely less boilerplate code. And when your team

254
00:16:38,886 --> 00:16:42,672
size is maybe somewhat smaller than

255
00:16:42,726 --> 00:16:46,012
what you have compared to when you're dealing with Redux,

256
00:16:46,076 --> 00:16:49,344
then maybe Mobix is for you. But of course there's more magic,

257
00:16:49,472 --> 00:16:53,364
things are less explicit and so on. So you have to understand

258
00:16:53,562 --> 00:16:57,272
the concepts here as the assumptions are different,

259
00:16:57,326 --> 00:16:59,000
like what I mentioned earlier.

260
00:17:01,720 --> 00:17:05,236
So now, one of the

261
00:17:05,258 --> 00:17:09,256
things which would make it easier for you to choose would be time,

262
00:17:09,438 --> 00:17:13,192
because time will affect everything,

263
00:17:13,326 --> 00:17:16,760
it will affect the budget, it will affect

264
00:17:17,740 --> 00:17:21,112
the launch dates, it will affect the things

265
00:17:21,166 --> 00:17:24,570
that you can do. And this will affect also

266
00:17:24,940 --> 00:17:28,296
the debugging time that you have. So what do I mean by

267
00:17:28,318 --> 00:17:32,052
that? When you have a more complex

268
00:17:32,116 --> 00:17:35,552
setup, it will take more time to build

269
00:17:35,606 --> 00:17:39,010
it. If you have more developers in your team,

270
00:17:40,260 --> 00:17:44,096
you need to manage everyone's time. So if you

271
00:17:44,118 --> 00:17:46,770
have a 30 man team versus a five man team,

272
00:17:48,260 --> 00:17:51,956
it's important to be able to manage complexity while reducing the

273
00:17:51,978 --> 00:17:55,236
overall time to deploy things, because it's super expensive when

274
00:17:55,258 --> 00:17:58,536
you're dealing with a much larger team compared to a smaller one. So if

275
00:17:58,558 --> 00:18:03,188
you have a smaller one and the timeline is a bit tough

276
00:18:03,364 --> 00:18:06,840
and you need to deploy things, let's say, next month,

277
00:18:06,990 --> 00:18:10,584
then doing something the elegant way may not

278
00:18:10,622 --> 00:18:14,492
be the right way to do things. Maybe try to do something that's somewhere there

279
00:18:14,546 --> 00:18:18,444
in the middle. That's why you need to be able to

280
00:18:18,482 --> 00:18:22,396
research first what options are available for you and what are the

281
00:18:22,418 --> 00:18:25,724
constraints that you have. So let's say that you're using view js

282
00:18:25,772 --> 00:18:29,440
already in your project, and if you want to migrate it to react,

283
00:18:30,740 --> 00:18:34,364
you need to take note of the skill level of your developers,

284
00:18:34,412 --> 00:18:38,152
also the amount of time it takes to migrate your project from view to react,

285
00:18:38,236 --> 00:18:41,604
and so on. And if you want to use, let's say,

286
00:18:41,642 --> 00:18:45,156
recoil and everyone else has used redux, then you have

287
00:18:45,178 --> 00:18:49,780
to also take into account the time it takes for people to learn recoil

288
00:18:49,940 --> 00:18:53,892
and these amount of time that you need to standardize

289
00:18:53,956 --> 00:18:58,132
things. Because even if you have this state management library, it will not automatically

290
00:18:58,196 --> 00:19:02,392
make your code cleaner. You need to be able to use those libraries

291
00:19:02,456 --> 00:19:06,190
properly before you can get a polished application.

292
00:19:09,250 --> 00:19:12,862
Another question we have to ask ourselves. Do we want more

293
00:19:12,916 --> 00:19:16,466
magic or do we want less magic? Let's say when

294
00:19:16,488 --> 00:19:20,260
you're using Mobix, a lot of magic is being done

295
00:19:21,750 --> 00:19:24,494
because of mobex, right? And in some cases,

296
00:19:24,622 --> 00:19:27,802
when we're using redux, things are more explicit.

297
00:19:27,886 --> 00:19:31,522
So when there's a problem, of course it's much easier

298
00:19:31,586 --> 00:19:35,158
to see where the but probably is,

299
00:19:35,324 --> 00:19:39,314
right. And when you have more members in the team, there are less assumptions

300
00:19:39,362 --> 00:19:42,460
to make and you can just see, okay,

301
00:19:42,910 --> 00:19:46,202
there's a problem with this function, or I can just probably

302
00:19:46,256 --> 00:19:49,862
look in these certain files, certain set of files,

303
00:19:50,006 --> 00:19:53,706
and just modify and tweak things a bit there to fix the

304
00:19:53,728 --> 00:19:57,566
problem when you're using more magic, of course, when there

305
00:19:57,588 --> 00:20:01,694
are issues and bugs. And when you're checking things on why it's not working,

306
00:20:01,892 --> 00:20:05,730
sometimes it's harder to debug and troubleshoot. So being

307
00:20:05,880 --> 00:20:09,778
aware of how to troubleshoot these issues is

308
00:20:09,864 --> 00:20:13,314
very important. And knowing the differences between the one day

309
00:20:13,352 --> 00:20:16,494
data binding concepts and two way data binding is crucial.

310
00:20:16,542 --> 00:20:20,050
Also, along with the usage of different tools,

311
00:20:20,210 --> 00:20:24,246
let's say the browser plugins, you need to be able to research

312
00:20:24,348 --> 00:20:27,606
what's available out there. And let's say there's a time

313
00:20:27,628 --> 00:20:31,260
travel mechanism these how can you use it

314
00:20:31,790 --> 00:20:38,020
to debug what's happening inside here?

315
00:20:39,190 --> 00:20:42,954
It's important for us to note that strong assumptions yield

316
00:20:43,022 --> 00:20:47,142
strong guarantees. So if we're using

317
00:20:47,196 --> 00:20:49,938
this certain concept, let's say immutability,

318
00:20:50,114 --> 00:20:55,122
if we're going to enforce certain architecture

319
00:20:55,186 --> 00:20:59,238
patterns in our application, then there's

320
00:20:59,254 --> 00:21:02,698
going to be a trade off. We're using to, let's say,

321
00:21:02,864 --> 00:21:06,042
have more code and more files. But when there

322
00:21:06,096 --> 00:21:09,674
are issues already, in some cases

323
00:21:09,722 --> 00:21:12,814
the issues are prevented and much more

324
00:21:12,852 --> 00:21:16,830
manageable. And those are some of the stronger guarantees

325
00:21:17,970 --> 00:21:21,602
which are results from having strong

326
00:21:21,656 --> 00:21:24,962
assumptions or strong rules. So when you're dealing with

327
00:21:25,016 --> 00:21:28,594
super complex applications, of course you needed to

328
00:21:28,632 --> 00:21:31,662
have this stronger rules,

329
00:21:31,726 --> 00:21:35,638
stronger set of rules to make things more manageable. And of course, if your

330
00:21:35,724 --> 00:21:38,854
application is much smaller and you

331
00:21:38,892 --> 00:21:42,274
are okay to have a higher level of risk,

332
00:21:42,322 --> 00:21:45,766
because you know that this project will probably not evolving

333
00:21:45,798 --> 00:21:49,034
into something larger in the future, then maybe use something that

334
00:21:49,072 --> 00:21:50,620
has more magic in it.

335
00:21:54,190 --> 00:21:58,254
Another thing to check would

336
00:21:58,292 --> 00:22:01,520
be the capability and experience of your entire team.

337
00:22:02,450 --> 00:22:06,302
Whenever there's a meeting. The usual problem these

338
00:22:06,356 --> 00:22:10,430
is that people think that they are masters

339
00:22:11,810 --> 00:22:16,210
of a certain tech stack. Let's say that they have used angular and

340
00:22:16,280 --> 00:22:19,540
NGRX to create a hello world application.

341
00:22:21,190 --> 00:22:24,614
So they create a button and

342
00:22:24,652 --> 00:22:28,242
then use this, it emits something and then something subscribe

343
00:22:28,306 --> 00:22:31,222
or something like that and it works,

344
00:22:31,356 --> 00:22:35,270
right? And these, they add another button and then another component

345
00:22:36,650 --> 00:22:38,360
changes. Because of that,

346
00:22:40,090 --> 00:22:43,834
they assume that they're already experts using angular and

347
00:22:43,872 --> 00:22:47,066
NGRX. However, when we start using

348
00:22:47,168 --> 00:22:50,958
and installing different things there,

349
00:22:51,044 --> 00:22:54,766
let's say that there's an API and then

350
00:22:54,948 --> 00:22:57,680
there are a lot of events happening all over the place,

351
00:22:58,770 --> 00:23:02,626
then that's these. You'll see that there's some sort of gap when

352
00:23:02,648 --> 00:23:06,370
it comes to capability and experience because your team

353
00:23:06,440 --> 00:23:10,658
is unable to resolve something, which is supposedly very easy

354
00:23:10,824 --> 00:23:13,822
when you're just using plain, angular or plain,

355
00:23:13,966 --> 00:23:17,142
let's say even jquery, right? So if you're trying

356
00:23:17,196 --> 00:23:19,080
to complexity things a bit,

357
00:23:19,770 --> 00:23:23,606
using a new layer then

358
00:23:23,628 --> 00:23:27,482
maybe it's time to step back a bit and check, do we really

359
00:23:27,536 --> 00:23:31,034
need these tools? And if you need these tools, do we need CTO?

360
00:23:31,072 --> 00:23:35,238
Make sure that we're trained first and capable

361
00:23:35,334 --> 00:23:38,954
of solving more complex problems so that

362
00:23:38,992 --> 00:23:41,600
things won't be implemented the wrong way.

363
00:23:42,370 --> 00:23:46,046
So there. So the goal here is for the team to

364
00:23:46,148 --> 00:23:49,706
make less mistakes or no mistakes, so that they'll

365
00:23:49,738 --> 00:23:51,570
be able to use the tools properly.

366
00:23:53,030 --> 00:23:56,898
One way to do this is to give an exam to your

367
00:23:56,984 --> 00:24:00,258
team members so that it's very easy to see

368
00:24:00,344 --> 00:24:04,606
if they're really capable of building a medium sized complex applications

369
00:24:04,718 --> 00:24:08,342
with these tech stacks, because it's easy to say, yeah, I can build

370
00:24:08,396 --> 00:24:11,910
something like that. But if you were to do things hands on,

371
00:24:12,060 --> 00:24:15,202
and if you're going to build a clone

372
00:24:15,266 --> 00:24:18,714
of what you're supposed to do, something that's more isolated and

373
00:24:18,752 --> 00:24:22,298
something that's easier to perform in, let's say 8 hours,

374
00:24:22,464 --> 00:24:26,346
then that would be your way

375
00:24:26,528 --> 00:24:30,078
to identify if your project is going to succeed with this text

376
00:24:30,164 --> 00:24:31,870
using this certain roster.

377
00:24:34,790 --> 00:24:38,866
In addition to this, it's important for us to identify and note the

378
00:24:38,888 --> 00:24:42,454
different types of state and why do we need to know these things.

379
00:24:42,652 --> 00:24:46,840
For one thing, there's a tendency of team members to put everything

380
00:24:48,810 --> 00:24:53,026
in the store using the state management libraries,

381
00:24:53,218 --> 00:24:56,922
and in most cases that's going to be overkill. There are only

382
00:24:56,976 --> 00:25:00,140
certain types of state that we need to put in the store,

383
00:25:00,990 --> 00:25:05,194
and it's not just that. We also need to know

384
00:25:05,312 --> 00:25:09,214
the different ways to control the state and to know

385
00:25:09,252 --> 00:25:12,586
where to store the state. Also, for example, in server state that's

386
00:25:12,618 --> 00:25:16,560
stored in the server, you will not need

387
00:25:17,250 --> 00:25:20,666
the more advanced and complex solutions

388
00:25:20,698 --> 00:25:24,258
there, especially if the operations are pretty straightforward. Let's say that

389
00:25:24,264 --> 00:25:27,746
you have a form and you just need to submit the form. Does it

390
00:25:27,768 --> 00:25:31,394
need to go through all this complex code just to send

391
00:25:31,432 --> 00:25:33,670
a post request to the server?

392
00:25:34,250 --> 00:25:38,406
And maybe you can store also the state in the router and

393
00:25:38,428 --> 00:25:43,014
so on. So being able to identify the different types of state would

394
00:25:43,052 --> 00:25:47,002
help us identify which state can

395
00:25:47,056 --> 00:25:51,226
be stored inside in

396
00:25:51,248 --> 00:25:54,726
the store of the state management libraries, for example, local UI state, you don't

397
00:25:54,758 --> 00:25:58,960
really need that stored in the global state then yeah,

398
00:26:00,450 --> 00:26:04,478
it's better if it's just there in the

399
00:26:04,644 --> 00:26:06,510
scope of that component.

400
00:26:10,070 --> 00:26:13,714
So why do we have an image of

401
00:26:13,752 --> 00:26:17,410
a hammer here? Because if all you have is a hammer,

402
00:26:17,990 --> 00:26:22,020
everything becomes a nail. And if you try to use

403
00:26:22,710 --> 00:26:26,486
these certain tools and text tags in all of your applications, you'll start to

404
00:26:26,508 --> 00:26:30,006
realize it's not going to work for all of it. If you try to

405
00:26:30,028 --> 00:26:34,040
read a blog post saying yeah, it works for us, this certain

406
00:26:34,410 --> 00:26:38,074
tooling works for us in our project, and you start

407
00:26:38,112 --> 00:26:41,706
copying their text app without thinking about the

408
00:26:41,728 --> 00:26:44,966
implications and how it would really work in your own context

409
00:26:44,998 --> 00:26:48,426
and application, then yeah, you'll encounter

410
00:26:48,458 --> 00:26:51,854
a lot of problems there. So the first step here

411
00:26:51,892 --> 00:26:55,066
is to check what's out there and what's

412
00:26:55,098 --> 00:26:59,190
available and try to select which tools

413
00:26:59,370 --> 00:27:02,900
are most suitable for your context for your own application.

414
00:27:04,630 --> 00:27:08,482
So for example, for project one and

415
00:27:08,616 --> 00:27:11,918
it's already using Vuejs, then yeah, just use vuejs.

416
00:27:12,094 --> 00:27:15,346
If it's not going to evolve into something that's super large,

417
00:27:15,528 --> 00:27:19,046
then Vuejs would do the trick. And maybe there's no need to

418
00:27:19,068 --> 00:27:22,630
use vuejs there. For project number two,

419
00:27:22,780 --> 00:27:26,650
you're using Vuejs there and you start to realize actually

420
00:27:26,720 --> 00:27:30,780
the code is getting much, much bigger. The team

421
00:27:33,150 --> 00:27:37,102
needs to use view x then yeah, these use viewx for that and

422
00:27:37,156 --> 00:27:40,378
make sure that Viewx is used properly and you're

423
00:27:40,394 --> 00:27:44,254
just using viewx for the state that is

424
00:27:44,452 --> 00:27:48,730
supposedly in, that is supposed to be in viewx

425
00:27:48,890 --> 00:27:52,034
because you can use both view the view way of things

426
00:27:52,072 --> 00:27:55,540
and the viewx way of things when dealing with state in an application.

427
00:27:56,070 --> 00:27:59,874
There's no need to be pure when choosing these

428
00:27:59,912 --> 00:28:03,926
types of things because whatever works for your team should

429
00:28:03,948 --> 00:28:06,998
do the trick. For project number three,

430
00:28:07,164 --> 00:28:10,486
let's say that your team is using react and

431
00:28:10,508 --> 00:28:14,434
then your team decides to use recoil instead of redux,

432
00:28:14,562 --> 00:28:18,314
then go for it. Just make sure that you don't change your

433
00:28:18,432 --> 00:28:22,026
minds midway and decide to use redux so that

434
00:28:22,048 --> 00:28:25,434
you have to refactor everything and start again

435
00:28:25,472 --> 00:28:28,746
from scratch just to realize let's use redux or

436
00:28:28,768 --> 00:28:31,920
mobile instead. And for project number four,

437
00:28:32,690 --> 00:28:35,886
maybe you decided to use angular for that. Or the client may

438
00:28:35,908 --> 00:28:39,246
be already be using angular for it, and then you're supposed to

439
00:28:39,268 --> 00:28:42,594
build on top of the existing framework then yeah,

440
00:28:42,632 --> 00:28:46,626
use angular. If you think that it makes sense to use NGRx or

441
00:28:46,648 --> 00:28:50,402
other options, then yeah, test things, but first

442
00:28:50,456 --> 00:28:53,826
and identify how it would affect the timeline and

443
00:28:53,848 --> 00:28:57,270
how it would affect the happiness of these developers and also their productivity.

444
00:29:00,800 --> 00:29:03,484
So this is one good example on how to take a look at it.

445
00:29:03,522 --> 00:29:07,916
People think that oh yeah, these moment the project becomes a

446
00:29:07,938 --> 00:29:11,296
bit complex, maybe somewhere around medium complexity. That's the

447
00:29:11,318 --> 00:29:14,972
time I need to start using the state management libraries.

448
00:29:15,036 --> 00:29:19,010
But like I said, in most cases you may not need it.

449
00:29:20,260 --> 00:29:23,364
The best way to do it is to start checking all of the

450
00:29:23,402 --> 00:29:26,516
features and functionalities of the

451
00:29:26,538 --> 00:29:30,180
library or framework that you're using. For example, angular. It has

452
00:29:30,250 --> 00:29:33,716
services there. By using, let's say, the angular CLI, you'll be able

453
00:29:33,738 --> 00:29:37,032
to get a service. And these, you can just have the different

454
00:29:37,086 --> 00:29:40,424
components talk to each other using a service as one example.

455
00:29:40,622 --> 00:29:44,008
But once things get a bit more complex and you start to realize that you

456
00:29:44,014 --> 00:29:47,608
need to manage how the data is being managed

457
00:29:47,704 --> 00:29:51,148
and how the data flows. Cto the different components these, yeah,

458
00:29:51,234 --> 00:29:54,988
feel free to introducing NGRX, especially on a certain

459
00:29:55,154 --> 00:29:59,520
complexity level where you have a single page application and a lot of components

460
00:30:00,020 --> 00:30:02,480
are interconnected.

461
00:30:06,020 --> 00:30:10,012
Other considerations we needed to take note of would be managing the performance

462
00:30:10,076 --> 00:30:13,564
issues, because when you're using state management libraries,

463
00:30:13,692 --> 00:30:17,188
it's easy to get things started when you're doing a hello world project.

464
00:30:17,274 --> 00:30:20,624
But when you're dealing with a real project, you will realize

465
00:30:20,672 --> 00:30:24,048
that some parts of your application will be slow. So when you're,

466
00:30:24,064 --> 00:30:27,144
let's say, rendering a certain page, you do not want

467
00:30:27,182 --> 00:30:30,490
to accidentally trigger certain parts of your application,

468
00:30:30,860 --> 00:30:34,376
and then there's a chain reaction, and then this certain component, for some

469
00:30:34,398 --> 00:30:38,460
reason loads really slow, or sometimes

470
00:30:38,610 --> 00:30:42,024
it flickers. We also need to deal with memory

471
00:30:42,072 --> 00:30:45,756
leaks, especially when you're dealing with components and you

472
00:30:45,778 --> 00:30:49,816
need to do some cleanup. It needs to be implemented

473
00:30:49,848 --> 00:30:53,120
properly using the library or framework of choice.

474
00:30:53,700 --> 00:30:56,956
We also need to take note of how to reduce the boilerplate

475
00:30:56,988 --> 00:31:00,576
code, and there are ways to do that, especially in my example earlier where we

476
00:31:00,598 --> 00:31:04,544
use redux toolkit to reduce the overall boilerplate

477
00:31:04,592 --> 00:31:07,924
code to speed things up a bit. Also, and also CTO.

478
00:31:07,962 --> 00:31:11,444
Add more CTo be more straightforward in terms

479
00:31:11,482 --> 00:31:14,564
of like, instead of choosing

480
00:31:14,612 --> 00:31:18,324
something over the other. Sometimes having a more rigid

481
00:31:18,372 --> 00:31:21,220
set of timelines would do the trick.

482
00:31:21,380 --> 00:31:24,872
And then also we need to identify antipatterns when using

483
00:31:24,926 --> 00:31:28,156
these differences, libraries and frameworks, because these antipatterns would be

484
00:31:28,178 --> 00:31:31,368
different, because these libraries and frameworks

485
00:31:31,384 --> 00:31:33,470
have their own ways of doing things.

486
00:31:36,540 --> 00:31:40,296
Finally, why do we have a picture

487
00:31:40,328 --> 00:31:44,300
of a playground here? Don't use your real projects

488
00:31:45,040 --> 00:31:49,550
as a playground. Create a small pet project,

489
00:31:50,240 --> 00:31:54,304
or maybe create your own personal website or something like that, and use that

490
00:31:54,342 --> 00:31:57,404
as your pet project where you would try out these tools.

491
00:31:57,452 --> 00:32:01,612
Do not experiment on the actual projects

492
00:32:01,756 --> 00:32:05,316
because you do not have any room for mistakes or

493
00:32:05,338 --> 00:32:09,190
failures there. You are not supposed to learn

494
00:32:09,640 --> 00:32:13,236
and apply things at the same time and expect

495
00:32:13,338 --> 00:32:16,484
things to be clean when

496
00:32:16,522 --> 00:32:19,656
it comes to implementation. As much as possible,

497
00:32:19,758 --> 00:32:23,336
you would do your learning in

498
00:32:23,358 --> 00:32:26,792
a different environment where you can write messy code

499
00:32:26,846 --> 00:32:30,376
without having to worry about the implications because once you need

500
00:32:30,398 --> 00:32:33,836
to implement things in a real project, it needed to be

501
00:32:33,858 --> 00:32:37,944
clean, and you need to worry about the constraints like the timeline, the budget,

502
00:32:38,072 --> 00:32:41,564
and the people that you work with. You do not want to introduce a new

503
00:32:41,602 --> 00:32:44,896
tool to a project where all the other developers in your

504
00:32:44,918 --> 00:32:48,690
team have no idea what you're going to introducing. So again,

505
00:32:49,700 --> 00:32:53,292
in summary, do not use your real projects

506
00:32:53,356 --> 00:32:57,324
as pet projects where you will introducing fancy

507
00:32:57,372 --> 00:32:59,760
new tools just to add to your resume.

508
00:33:01,700 --> 00:33:05,872
And that's pretty much it. Thank you again for

509
00:33:05,926 --> 00:33:09,384
listening to my my talk and hope you learned something new. And again,

510
00:33:09,502 --> 00:33:13,432
I am Joshua Arvin Lat. You've learned a few things about

511
00:33:13,486 --> 00:33:16,452
pragmatic state management in react,

512
00:33:16,596 --> 00:33:19,976
angular and UGS application.

513
00:33:20,158 --> 00:33:23,270
Thank you again and have a productive day ahead.

