1
00:00:01,290 --> 00:00:04,554
Hi, my name is Ismael Hommani. I am cloud cloud native developer

2
00:00:04,602 --> 00:00:08,574
GDE Wescale. In today's talk we are going to present you with

3
00:00:08,612 --> 00:00:12,254
clement a comparison between Argo and Flux, which are two

4
00:00:12,292 --> 00:00:15,230
GitHub's tools in the Kubernetes landscape.

5
00:00:15,730 --> 00:00:19,262
First of all, we want you to be aware that it is not a

6
00:00:19,316 --> 00:00:22,734
basic comparaison we want to make, but something that go

7
00:00:22,772 --> 00:00:26,834
beyond a simple benchmarking. It's about describing

8
00:00:26,882 --> 00:00:30,086
these difference of philosophy when it

9
00:00:30,108 --> 00:00:33,478
comes to consider Githubs in the

10
00:00:33,564 --> 00:00:36,760
flux mind or ArgoCD mind.

11
00:00:38,670 --> 00:00:42,074
So our comparison criteria will first

12
00:00:42,272 --> 00:00:46,650
be based on the model, that is to say the different entities and relationship

13
00:00:46,800 --> 00:00:50,198
with one another. It will allows us to

14
00:00:50,304 --> 00:00:53,822
deeply understand how flux and ArgoCD consider

15
00:00:53,956 --> 00:00:58,014
the GitHub's approach and will give you the

16
00:00:58,052 --> 00:01:01,642
right insight when it comes to make the choose

17
00:01:01,706 --> 00:01:05,522
between those two tools. Then we will present you the

18
00:01:05,576 --> 00:01:09,202
different user experience you can expect. Is it easy

19
00:01:09,256 --> 00:01:12,514
to install, how to do it, how to update it,

20
00:01:12,552 --> 00:01:15,300
how to debug it, and so on.

21
00:01:15,690 --> 00:01:19,414
Last but not least, benchmarking will give you a quick

22
00:01:19,452 --> 00:01:22,934
overview of what kind of expectation you can have in terms

23
00:01:22,972 --> 00:01:26,550
of cpu and memory consumption.

24
00:01:27,550 --> 00:01:31,114
We wanted to compare flux and Argosidoi because when it

25
00:01:31,152 --> 00:01:34,794
comes to Githubs in Kubernetes landscape, we have two

26
00:01:34,832 --> 00:01:38,090
clear winners, ArgocD and Flux.

27
00:01:38,670 --> 00:01:42,558
They have a wide recognition and community and

28
00:01:42,644 --> 00:01:46,346
adoption. But the question remains,

29
00:01:46,458 --> 00:01:50,190
what tools should I install? And usually we see

30
00:01:50,340 --> 00:01:53,490
comparaison in terms of performance and not

31
00:01:53,560 --> 00:01:57,390
philosophy. That's why we wanted to compare

32
00:01:57,470 --> 00:01:59,700
Flux and ArgoCD today.

33
00:02:01,030 --> 00:02:05,534
Before comparing those two tools, let's recap what Githubs

34
00:02:05,582 --> 00:02:09,650
is. Traditionally, we consider the CI CD approach

35
00:02:09,730 --> 00:02:14,162
with a monolithic pipeline where a file will imperatively

36
00:02:14,226 --> 00:02:17,800
describe how two deploy inside a target platform,

37
00:02:18,110 --> 00:02:21,546
which means that the runtime will need to provide

38
00:02:21,648 --> 00:02:25,210
the different tools we need to interact with these platform.

39
00:02:25,360 --> 00:02:29,190
First point, let's say for instance Kubectl.

40
00:02:29,350 --> 00:02:33,206
Second point, we have to provide these

41
00:02:33,248 --> 00:02:37,130
tools with credentials inside the pipeline,

42
00:02:37,210 --> 00:02:40,542
which means potential data leakage. And third

43
00:02:40,596 --> 00:02:43,634
point, if we want to deploy on another platform, we would

44
00:02:43,672 --> 00:02:46,946
have to provide with new credentials and

45
00:02:47,048 --> 00:02:50,270
modify neroprone file,

46
00:02:50,430 --> 00:02:54,242
which is rather not really good. In fact,

47
00:02:54,376 --> 00:02:58,102
we oppose this approach two the CI and

48
00:02:58,156 --> 00:03:02,098
CD. That is to say GitHub's approach,

49
00:03:02,274 --> 00:03:05,666
which is a continuous

50
00:03:05,698 --> 00:03:09,626
deployment pattern where a deployment agent will take in

51
00:03:09,648 --> 00:03:13,674
charge all the deployment step. We at

52
00:03:13,712 --> 00:03:17,930
no point describe how to deploy our manifests

53
00:03:18,270 --> 00:03:22,654
onto the platform. It is up to the agent to

54
00:03:22,692 --> 00:03:25,886
do it, and that's why we say that the

55
00:03:25,908 --> 00:03:29,514
GitHub's approach is purely declarative.

56
00:03:29,642 --> 00:03:33,458
It will fetch from your sources the different

57
00:03:33,544 --> 00:03:36,900
manifest and apply it on the platform,

58
00:03:38,070 --> 00:03:42,274
although that it is not linked by

59
00:03:42,392 --> 00:03:45,800
definition to the Kubernetes platform.

60
00:03:46,410 --> 00:03:50,598
We can say that Kubernetes is well adapted to the GitHub's approach because

61
00:03:50,764 --> 00:03:54,534
first, it provides a declarative model through the

62
00:03:54,572 --> 00:03:58,380
different resource definition that we

63
00:03:59,230 --> 00:04:02,330
describe in YaML file manifest.

64
00:04:02,910 --> 00:04:06,454
And second, we have infinite

65
00:04:06,502 --> 00:04:10,054
reconciliation loop that these deployment agent

66
00:04:10,192 --> 00:04:14,174
can rely on when it will apply

67
00:04:14,292 --> 00:04:17,566
the different manifested watch

68
00:04:17,748 --> 00:04:21,760
from the repository into the platform.

69
00:04:22,390 --> 00:04:25,874
In terms of credential. By design, when we

70
00:04:25,912 --> 00:04:29,138
install a deployment agent, we provide it

71
00:04:29,224 --> 00:04:33,010
with the credential to access the

72
00:04:33,080 --> 00:04:36,814
platform so that we don't have any more

73
00:04:36,952 --> 00:04:40,674
the issue of providing into the pipeline

74
00:04:40,802 --> 00:04:42,070
the credential.

75
00:04:46,970 --> 00:04:50,874
So let's have an overview of Argo CD and

76
00:04:50,912 --> 00:04:54,982
Flux. Both are open source and donated

77
00:04:55,126 --> 00:04:58,886
to the CNCF respectively by WeWork

78
00:04:59,078 --> 00:05:00,990
and intuit.

79
00:05:01,730 --> 00:05:05,310
Both are graduated and both

80
00:05:05,380 --> 00:05:09,354
have broad community on GitHub

81
00:05:09,402 --> 00:05:13,186
in term of stars. Last but

82
00:05:13,208 --> 00:05:17,186
not least, we strongly discourage you to install

83
00:05:17,288 --> 00:05:20,830
both on Kubernetes cluster.

84
00:05:20,990 --> 00:05:25,926
What we may find on the Internet when

85
00:05:25,948 --> 00:05:29,574
we compare two tools is that okay, they are complementary and

86
00:05:29,612 --> 00:05:34,214
we can take both of them to make the

87
00:05:34,252 --> 00:05:37,754
perfect tool. But no, don't do that.

88
00:05:37,792 --> 00:05:39,980
It's not a good idea.

89
00:05:45,390 --> 00:05:48,698
Let's focus on the model. So what we understand

90
00:05:48,784 --> 00:05:52,654
by the model is the different entities and relationship that

91
00:05:52,692 --> 00:05:55,966
would be considered by a given tool, flux or

92
00:05:55,988 --> 00:05:59,854
Argocd. It is important to have it in mind because it

93
00:05:59,892 --> 00:06:03,854
will help you to understand the deep

94
00:06:03,982 --> 00:06:07,794
philosophy, the deep understanding of how

95
00:06:07,912 --> 00:06:11,362
those tools understand Githubs and will help

96
00:06:11,416 --> 00:06:15,878
you later in the usage of these tools and especially

97
00:06:16,044 --> 00:06:19,910
in these decision of whether flux or argo.

98
00:06:20,810 --> 00:06:23,810
Before going into the description,

99
00:06:23,970 --> 00:06:27,994
let's remind you what is an operator pattern on

100
00:06:28,032 --> 00:06:31,914
Kubernetes. Kubernetes is a platform that allows you to

101
00:06:32,032 --> 00:06:36,042
industrialize the deployment of your application through

102
00:06:36,176 --> 00:06:39,542
different entities like pod

103
00:06:39,606 --> 00:06:42,800
deployment, job services and so on.

104
00:06:43,250 --> 00:06:47,386
Which means that Kubernetes understands

105
00:06:47,498 --> 00:06:51,242
its business logic. Business being deploying

106
00:06:51,306 --> 00:06:55,074
an application. Now what if you want kubernetes to

107
00:06:55,112 --> 00:06:59,170
understand your own logic, your own business logic, for instance

108
00:06:59,990 --> 00:07:03,790
githubs. Well, with the operator pattern

109
00:07:03,870 --> 00:07:08,470
you are able to define your own custom resource

110
00:07:08,810 --> 00:07:12,358
with an associated controller so that each time

111
00:07:12,524 --> 00:07:14,950
you create a manifest foo,

112
00:07:15,530 --> 00:07:19,354
you will trigger a controller that will

113
00:07:19,472 --> 00:07:23,194
later interact with Kubernetes to do

114
00:07:23,392 --> 00:07:27,222
this and that. That is two say Kubernetes

115
00:07:27,286 --> 00:07:30,490
is now able to understand your own logic.

116
00:07:35,490 --> 00:07:39,150
It is interesting to know about this operator pattern because

117
00:07:39,220 --> 00:07:42,960
both Flux and ArgocD relies on it.

118
00:07:43,890 --> 00:07:48,222
The flux model an overview is this schema,

119
00:07:48,286 --> 00:07:51,554
but it has not many sense if we don't know about

120
00:07:51,592 --> 00:07:55,098
the different customer resource definitions. So let's go back on this schema

121
00:07:55,134 --> 00:07:59,234
later. The first resource

122
00:07:59,282 --> 00:08:03,270
to consider is the source. The source is where

123
00:08:03,340 --> 00:08:07,454
flux should be monitoring the synchronization.

124
00:08:07,602 --> 00:08:11,830
To do so we have several kind of it several types,

125
00:08:11,910 --> 00:08:15,030
git repositories, bucket OCI repository,

126
00:08:15,110 --> 00:08:18,810
and also ELM charts and repositories.

127
00:08:21,650 --> 00:08:25,370
We can describe it through basic manifest

128
00:08:25,450 --> 00:08:29,040
with their own API version and own kind.

129
00:08:29,490 --> 00:08:33,018
It's quite obvious in term

130
00:08:33,034 --> 00:08:36,686
of specification. Here we define URL

131
00:08:36,878 --> 00:08:40,942
corresponding to this git repository and tells Flux

132
00:08:41,006 --> 00:08:44,354
to cons it at the master branch every five

133
00:08:44,392 --> 00:08:47,974
minutes. We have the same kind of consideration for

134
00:08:48,012 --> 00:08:51,318
an ELM repository and for the elm shard kind

135
00:08:51,484 --> 00:08:55,154
we have this specific sourceref tag

136
00:08:55,282 --> 00:08:59,062
which points to another ELM repository

137
00:08:59,206 --> 00:09:02,774
here, a repository named Pod

138
00:09:02,822 --> 00:09:05,020
info that we can find here,

139
00:09:05,950 --> 00:09:08,698
but alone a source is not enough,

140
00:09:08,864 --> 00:09:12,734
it only tells Flux where to watch

141
00:09:12,852 --> 00:09:16,126
but not what to synchronize. And for

142
00:09:16,148 --> 00:09:20,458
this we have the customization which relies on the customized

143
00:09:20,634 --> 00:09:24,930
Kubernetes tool to not overcomplicify

144
00:09:25,270 --> 00:09:28,706
this presentation. I will only tell that the

145
00:09:28,728 --> 00:09:32,638
customization is a way to specify to flux

146
00:09:32,814 --> 00:09:36,854
what path to consider in the

147
00:09:37,052 --> 00:09:40,646
previous source. So for instance here we

148
00:09:40,668 --> 00:09:44,966
have a customization telling Flux that you

149
00:09:44,988 --> 00:09:48,310
have to synchronize the entities

150
00:09:48,390 --> 00:09:52,326
you will find into the pod git repository

151
00:09:52,438 --> 00:09:54,970
under the path customize.

152
00:09:56,670 --> 00:10:00,734
Of course we also have resource corresponding to an

153
00:10:00,772 --> 00:10:04,670
ELM release which is a wrapper of

154
00:10:04,740 --> 00:10:08,526
an elmorelize and you manipulate it

155
00:10:08,628 --> 00:10:12,314
through Yaml file which

156
00:10:12,452 --> 00:10:14,530
definition is quite basic.

157
00:10:15,110 --> 00:10:18,610
You have the specific API version and kind

158
00:10:18,760 --> 00:10:22,674
then a spec that will tell you the interval of

159
00:10:22,712 --> 00:10:26,338
installation, the version and most important

160
00:10:26,504 --> 00:10:29,266
the source reference which is here.

161
00:10:30,882 --> 00:10:35,030
And of course you have the values needed to

162
00:10:35,180 --> 00:10:40,346
render the chart template in

163
00:10:40,368 --> 00:10:44,506
terms of organization of those

164
00:10:44,608 --> 00:10:49,798
different custom resource definitions. We have at

165
00:10:49,984 --> 00:10:53,582
higher level a source which

166
00:10:53,636 --> 00:10:57,566
will be pointed by a customization but also an

167
00:10:57,588 --> 00:11:01,822
ELM release. And the customization will

168
00:11:01,956 --> 00:11:06,558
tell Flux where to find the different Kubernetes

169
00:11:06,654 --> 00:11:10,610
entities and custom definition to synchronize

170
00:11:11,030 --> 00:11:14,738
with your cluster. An interesting point

171
00:11:14,824 --> 00:11:18,786
is that inside those entities

172
00:11:18,978 --> 00:11:22,790
we can find also other sources

173
00:11:23,130 --> 00:11:26,680
and you begin to understand that in fact we can

174
00:11:27,550 --> 00:11:31,562
create a directed acyclic graph that

175
00:11:31,616 --> 00:11:36,198
would represent the entire state of your Kubernetes

176
00:11:36,294 --> 00:11:40,054
cluster. Something that

177
00:11:40,112 --> 00:11:43,802
we have to watch for is that we can create cycle,

178
00:11:43,946 --> 00:11:48,014
and if cycle is created, the customization that

179
00:11:48,052 --> 00:11:50,750
is at the origin of these cycle,

180
00:11:51,890 --> 00:11:55,954
the synchronization of this synchronization of this customization will

181
00:11:55,992 --> 00:11:59,730
fail. We also

182
00:11:59,880 --> 00:12:04,446
have the capacity to define explicitly

183
00:12:04,558 --> 00:12:08,680
dependencies between same sort of kind.

184
00:12:09,370 --> 00:12:12,838
For instance, we can say that a customization two

185
00:12:12,924 --> 00:12:16,482
depends on customization one, effort flux.

186
00:12:16,546 --> 00:12:20,380
It means that customization one

187
00:12:20,750 --> 00:12:25,350
should be installed before customization

188
00:12:25,430 --> 00:12:29,578
two. And we have the same kind of relation with

189
00:12:29,664 --> 00:12:31,280
the nmolis also.

190
00:12:33,890 --> 00:12:37,646
So we are back to our overview and

191
00:12:37,748 --> 00:12:41,642
what will happen in normal flow flux

192
00:12:41,706 --> 00:12:45,234
flow is that you will push source on your

193
00:12:45,272 --> 00:12:48,820
repo source kind which will be

194
00:12:50,070 --> 00:12:54,930
pushed on the Kubernetes API by flux.

195
00:12:55,450 --> 00:12:59,430
The source will trigger a source controller

196
00:13:00,010 --> 00:13:03,462
which will read the

197
00:13:03,516 --> 00:13:07,870
specification and see that it has to clone a GitHub repository.

198
00:13:08,050 --> 00:13:13,050
The cloning will happen inside the pod under

199
00:13:13,120 --> 00:13:17,226
the source controller. Then we

200
00:13:17,248 --> 00:13:21,166
also pushed a customization that is

201
00:13:21,348 --> 00:13:25,406
referencing these very same sources at

202
00:13:25,508 --> 00:13:29,770
a given path. So the customized controller

203
00:13:29,930 --> 00:13:33,454
will read these cons repository

204
00:13:33,582 --> 00:13:37,870
and explore at the path specified in the customization

205
00:13:38,030 --> 00:13:41,666
the different manifest that

206
00:13:41,688 --> 00:13:46,034
it would find and each manifest will be applied

207
00:13:46,082 --> 00:13:49,666
to the Kubernetes API and a namespace controller

208
00:13:49,778 --> 00:13:53,654
will take action, airbag controller take

209
00:13:53,692 --> 00:13:56,934
action, and so on. And we can also find a

210
00:13:56,972 --> 00:14:00,970
releases that would trigger a name controller

211
00:14:01,710 --> 00:14:06,506
which reference a name repository and

212
00:14:06,608 --> 00:14:10,300
would be able to fetch the right

213
00:14:10,610 --> 00:14:14,190
version and install the right release into

214
00:14:14,340 --> 00:14:15,390
the cluster.

215
00:14:19,250 --> 00:14:23,110
Let's focus on the ArgoCD model. The ArgoCD

216
00:14:23,130 --> 00:14:26,500
model is a very different one from the flux model.

217
00:14:27,590 --> 00:14:32,206
In this model we only care about one central CRD

218
00:14:32,318 --> 00:14:35,734
called application. The application represents the

219
00:14:35,772 --> 00:14:39,030
synchronization part of the GitHub's approach.

220
00:14:39,610 --> 00:14:42,902
It's an all in one CRD where

221
00:14:42,956 --> 00:14:46,562
you define sources which can be plain YML files,

222
00:14:46,626 --> 00:14:50,780
customize Elm or chisonet, but also

223
00:14:51,550 --> 00:14:55,580
the target which can be defined as a different

224
00:14:55,950 --> 00:15:00,490
cluster than the one where argoCD is installed.

225
00:15:01,330 --> 00:15:05,054
In a sense we can say that this model is

226
00:15:05,092 --> 00:15:08,538
simpler than flux because we only have one CRD,

227
00:15:08,714 --> 00:15:12,126
but because we have much more parameter to

228
00:15:12,148 --> 00:15:15,554
play with. We can also say that this model is

229
00:15:15,592 --> 00:15:17,620
more complex than the flux one.

230
00:15:19,750 --> 00:15:23,314
As usual, we have manifest with

231
00:15:23,352 --> 00:15:27,062
its own API version and kind here

232
00:15:27,116 --> 00:15:31,298
application these we define

233
00:15:31,394 --> 00:15:34,438
a project which is a notion we will see later,

234
00:15:34,604 --> 00:15:38,202
but most importantly the source these

235
00:15:38,256 --> 00:15:42,346
a git repository with a path to

236
00:15:42,528 --> 00:15:46,342
explore in order to synchronize the sources

237
00:15:46,406 --> 00:15:50,158
we will find into, and a

238
00:15:50,164 --> 00:15:53,850
destination which represents a Kubernetes

239
00:15:53,930 --> 00:15:57,790
cluster. Where to make these synchronization wave.

240
00:15:58,690 --> 00:16:02,582
On the right side we have an alternative

241
00:16:02,666 --> 00:16:06,066
specification where we specify a

242
00:16:06,088 --> 00:16:10,354
NAM repository and

243
00:16:10,392 --> 00:16:13,826
we want to synchronize a dedicated chart called

244
00:16:13,928 --> 00:16:14,850
Argo.

245
00:16:17,370 --> 00:16:21,590
Sometimes you may want to specify another kind of sources.

246
00:16:22,570 --> 00:16:27,234
You can enhance these application capabilities

247
00:16:27,362 --> 00:16:30,594
with config management plugin

248
00:16:30,722 --> 00:16:34,314
that would allows you to specify other kind

249
00:16:34,352 --> 00:16:37,580
of resources. And this is

250
00:16:38,030 --> 00:16:41,354
interesting because you can benefit from the

251
00:16:41,392 --> 00:16:45,458
community which provide many ArgoCD

252
00:16:45,494 --> 00:16:49,182
plugins. You also

253
00:16:49,236 --> 00:16:53,078
have the capabilities to synchronize

254
00:16:53,274 --> 00:16:56,610
these synchronization of different applications.

255
00:16:57,270 --> 00:17:01,234
That pattern is called app of applications where

256
00:17:01,272 --> 00:17:03,940
you define a root application,

257
00:17:04,390 --> 00:17:09,202
which sources will point to other application CRD,

258
00:17:09,346 --> 00:17:13,062
so that once you synchronize this root application,

259
00:17:13,196 --> 00:17:17,350
you will trigger the application of the subservices.

260
00:17:20,670 --> 00:17:24,838
An interesting point is synchronization hooks.

261
00:17:25,014 --> 00:17:28,358
In fact the synchronization have a lifecycle

262
00:17:28,534 --> 00:17:32,586
with phases and each phases can be hooked

263
00:17:32,698 --> 00:17:36,414
with a job computation so

264
00:17:36,452 --> 00:17:40,542
that for instance you can has a precinct job

265
00:17:40,676 --> 00:17:44,434
create a database needed for

266
00:17:44,472 --> 00:17:45,890
the sync phases.

267
00:17:50,070 --> 00:17:53,842
If you remember, in the last application manifest we

268
00:17:53,896 --> 00:17:57,510
has this default project setting which

269
00:17:57,580 --> 00:18:00,886
in fact points to an application project

270
00:18:01,068 --> 00:18:04,886
resource definition which represent in a

271
00:18:04,908 --> 00:18:08,394
way the federation we want to apply on

272
00:18:08,432 --> 00:18:12,442
a group of applications. These federation means

273
00:18:12,576 --> 00:18:15,978
what kind of permission we would apply

274
00:18:16,144 --> 00:18:20,102
on the synchronized resources, but also where

275
00:18:20,176 --> 00:18:23,614
we can deploy in term of namespace or

276
00:18:23,652 --> 00:18:27,454
cluster or what kind of entities the

277
00:18:27,492 --> 00:18:31,262
application under these project are allowed to

278
00:18:31,316 --> 00:18:35,380
deploy. So in term of dependency model

279
00:18:35,910 --> 00:18:39,234
we have this CRD which

280
00:18:39,272 --> 00:18:41,730
is to my opinion secondary,

281
00:18:42,790 --> 00:18:46,226
which will point to so a project

282
00:18:46,408 --> 00:18:50,538
which will point to application which is a central customerial

283
00:18:50,574 --> 00:18:53,750
definition of the ArgoCD model

284
00:18:53,900 --> 00:18:56,310
and which represents the synchronization.

285
00:18:56,810 --> 00:19:01,114
And an application we have seen can

286
00:19:01,312 --> 00:19:05,174
points to other application, it's an app of apps pattern,

287
00:19:05,302 --> 00:19:09,260
but in these end an application, a leaf application

288
00:19:09,710 --> 00:19:14,026
will point to Kubernetes entities, or ELm

289
00:19:14,058 --> 00:19:17,680
charts or Gsonet and so on.

290
00:19:19,970 --> 00:19:23,838
So now we understand the model of both tools,

291
00:19:23,934 --> 00:19:27,234
let's wrap up our findings. I like to

292
00:19:27,272 --> 00:19:31,442
say that Flux and ArgoCd are

293
00:19:31,496 --> 00:19:35,610
an answer to the same question, which is how do you implement

294
00:19:35,790 --> 00:19:39,318
Githubs on Kubernetes? If you ask

295
00:19:39,404 --> 00:19:43,042
someone which is interested and well versed

296
00:19:43,106 --> 00:19:46,482
into kubernetes, it will tell you flux,

297
00:19:46,626 --> 00:19:49,558
because flux is keep it simple, stupid.

298
00:19:49,654 --> 00:19:53,322
It already depends rely on

299
00:19:53,456 --> 00:19:57,370
existing entities from the Kubernetes environment.

300
00:19:58,350 --> 00:20:01,742
An enrollment release is nothing new, a customization is nothing new.

301
00:20:01,796 --> 00:20:04,858
And now that we have a terraform operator also on flex,

302
00:20:05,034 --> 00:20:08,910
it's nothing new. On the other hand, we have

303
00:20:08,980 --> 00:20:12,802
ArgocD, which provides you with a new

304
00:20:12,856 --> 00:20:16,622
model, a kind of logical

305
00:20:16,686 --> 00:20:20,190
layer that render kubernetes

306
00:20:20,270 --> 00:20:24,146
as a detail of implementation in the

307
00:20:24,168 --> 00:20:27,446
GitHub's padding. And this is interesting for

308
00:20:27,468 --> 00:20:31,640
people such as developers who are not interested

309
00:20:32,010 --> 00:20:35,686
into kubernetes. And also

310
00:20:35,788 --> 00:20:39,534
I think it explains why by default Argocd

311
00:20:39,682 --> 00:20:43,002
has a user interface because it really needs

312
00:20:43,056 --> 00:20:46,780
it in order to express these

313
00:20:47,310 --> 00:20:50,380
model in term of application and app project,

314
00:20:51,170 --> 00:20:55,786
contrary to flux which already rely

315
00:20:55,978 --> 00:20:59,962
which purely rely on Kubernetes

316
00:21:00,026 --> 00:21:04,018
entities that we already can handle through

317
00:21:04,104 --> 00:21:07,010
knnice in term of user interface.

318
00:21:07,350 --> 00:21:11,602
So it is interesting to have it in mind when

319
00:21:11,656 --> 00:21:15,570
you want to choose between flux and ArgoCd.

320
00:21:18,520 --> 00:21:22,528
Let's conclude our comparison with multi clustering and multi tenancy.

321
00:21:22,704 --> 00:21:25,956
First, multi clustering we understand from

322
00:21:25,978 --> 00:21:30,056
a GitHub's perspective these multi clustering has the capacity to synchronize application

323
00:21:30,158 --> 00:21:34,264
on several clusters while using a single tool application

324
00:21:34,462 --> 00:21:38,824
for flux. This is not possible because each

325
00:21:38,942 --> 00:21:42,648
cluster we want to synchronize has to be installed

326
00:21:42,744 --> 00:21:46,236
with a flux instance, meaning that if

327
00:21:46,258 --> 00:21:50,920
we want to deploy application synchronize deployments

328
00:21:51,000 --> 00:21:54,460
on cluster one, cluster two, cluster three of

329
00:21:54,530 --> 00:21:58,144
all of these three must have a flux installation on them.

330
00:21:58,262 --> 00:22:01,804
But we can emulate the multiclustering

331
00:22:01,852 --> 00:22:05,532
approach by creating a central flux

332
00:22:05,596 --> 00:22:09,380
installation root repository that would contain

333
00:22:09,880 --> 00:22:14,128
the installation source of each flux

334
00:22:14,224 --> 00:22:18,244
installation. That way those installation would

335
00:22:18,282 --> 00:22:22,376
be able to monitor themselves and

336
00:22:22,478 --> 00:22:26,468
later we would have inside the same root repository

337
00:22:26,644 --> 00:22:30,296
sources and customization that would point to application

338
00:22:30,398 --> 00:22:34,184
repo that would later replicate on each cluster.

339
00:22:34,312 --> 00:22:37,852
So in a sense we have a control plane which

340
00:22:37,906 --> 00:22:41,404
is distributed, but still that we can

341
00:22:41,442 --> 00:22:45,100
centrally manage through a flux installation

342
00:22:45,180 --> 00:22:49,328
root repository containing the source installation of each

343
00:22:49,414 --> 00:22:53,344
flux clusters on

344
00:22:53,382 --> 00:22:57,876
Argocd we have the multi clustering approach. By design.

345
00:22:58,058 --> 00:23:02,160
We have a single cluster on which Argo is installed

346
00:23:02,320 --> 00:23:06,484
and the target of the applications we define could

347
00:23:06,522 --> 00:23:10,704
be very well other clusters. My Argo

348
00:23:10,752 --> 00:23:17,776
installation has access to multi

349
00:23:17,808 --> 00:23:21,172
tenancy. Now let's call a tenant a segregation

350
00:23:21,236 --> 00:23:24,776
quantum multitenancy from a GitHub's perspective would be a

351
00:23:24,798 --> 00:23:29,048
tenant bonded to a namespace and also to permission

352
00:23:29,144 --> 00:23:32,956
to that namespace only from a

353
00:23:32,978 --> 00:23:36,416
flux perspective we don't have by design,

354
00:23:36,518 --> 00:23:39,680
once again the multitenancy, but we can

355
00:23:39,750 --> 00:23:43,820
also emulate it by reusing

356
00:23:43,980 --> 00:23:47,972
already existing entities from Kubernetes but

357
00:23:48,026 --> 00:23:52,150
also from git. Basically we would create

358
00:23:53,240 --> 00:23:56,976
repository, a git repository where only operative

359
00:23:57,088 --> 00:24:00,468
would have access two, and inside this repository

360
00:24:00,564 --> 00:24:04,440
we would define tenants as namespaces,

361
00:24:05,020 --> 00:24:09,160
Erbac, but also sources and customization

362
00:24:09,580 --> 00:24:13,852
that points to other repository which

363
00:24:13,906 --> 00:24:17,356
contains the infrastructure of a specific application.

364
00:24:17,538 --> 00:24:21,532
But this time this tenant repository would

365
00:24:21,586 --> 00:24:24,972
only allow a dev team to have access

366
00:24:25,106 --> 00:24:28,212
to. So we see that the multitenancy

367
00:24:28,296 --> 00:24:31,488
rely on two notions. First one being

368
00:24:31,574 --> 00:24:35,488
Kubernetes Rbac and second one being

369
00:24:35,654 --> 00:24:38,900
the GitHub or GitLab Rbac.

370
00:24:41,000 --> 00:24:44,708
From an ArgoCD perspective, it is

371
00:24:44,874 --> 00:24:47,540
already rooted inside the tool,

372
00:24:47,690 --> 00:24:51,240
as the app project gives you the necessary

373
00:24:52,300 --> 00:24:56,024
tools to create your tenant, in what

374
00:24:56,062 --> 00:24:59,688
kind of namespace your application can be deployed on,

375
00:24:59,774 --> 00:25:03,912
with what right, what kind of entities

376
00:25:04,056 --> 00:25:07,452
kubernetes, entities you can manipulate, and so on.

377
00:25:07,586 --> 00:25:11,228
And also we can note that airbag and

378
00:25:11,314 --> 00:25:15,004
single sign on is supported by the

379
00:25:15,042 --> 00:25:17,180
user interface of argocd.

380
00:25:18,420 --> 00:25:21,650
So now we are going to see the user experience

381
00:25:22,020 --> 00:25:24,480
which will be presented by Clement.

382
00:25:25,620 --> 00:25:26,870
You are live.

383
00:25:30,800 --> 00:25:34,332
Thanks ismail. So now that we have seen how

384
00:25:34,386 --> 00:25:37,948
Argo and Flux were designed, let's see how this relates to

385
00:25:37,954 --> 00:25:38,990
the user experience.

386
00:25:42,660 --> 00:25:46,844
We have two kinds of users for GitHub tools. These administrator

387
00:25:46,892 --> 00:25:50,576
team in charge of deploying and maintaining the infrastructure, including the

388
00:25:50,598 --> 00:25:54,144
GitHub tools, and the user team, mostly composed

389
00:25:54,192 --> 00:25:58,116
of developers who are not expected. Two have as

390
00:25:58,138 --> 00:26:01,860
deep knowledge on kubernetes on the GitHub tool than the

391
00:26:01,930 --> 00:26:02,870
starter team.

392
00:26:05,340 --> 00:26:09,204
Before installing or using or even choosing our GitHub

393
00:26:09,252 --> 00:26:12,648
tool, we must first talk

394
00:26:12,734 --> 00:26:16,516
about different things we need to implement on the GitHub's

395
00:26:16,548 --> 00:26:20,104
architecture. We must talk about,

396
00:26:20,142 --> 00:26:23,912
for example, whether we want a multi repository or a mono repository

397
00:26:23,976 --> 00:26:28,008
for the deployment code. If we want a multi repository,

398
00:26:28,104 --> 00:26:31,330
what scope should each repository have?

399
00:26:32,180 --> 00:26:35,616
We should also talk about how the code should be put into each

400
00:26:35,718 --> 00:26:39,356
repository. For example, do we want multiple

401
00:26:39,388 --> 00:26:42,816
folder for GCP, Azure or a

402
00:26:42,838 --> 00:26:47,104
single one? We must also talk about who owns

403
00:26:47,152 --> 00:26:50,836
the code for the repository and who has the right to modify it.

404
00:26:51,018 --> 00:26:54,388
For example, the developers will probably have the right to

405
00:26:54,394 --> 00:26:58,324
modify the code in the GitHub repository to deploy

406
00:26:58,372 --> 00:27:02,136
on the old cluster. But also these SRE team should have

407
00:27:02,158 --> 00:27:05,624
access to this repository in case something went

408
00:27:05,662 --> 00:27:08,170
wrong in production and they need to fix it quick.

409
00:27:09,340 --> 00:27:12,424
We must also talk about how can we protect the production.

410
00:27:12,552 --> 00:27:16,376
By that I mean how do we implement for example, or git

411
00:27:16,408 --> 00:27:19,916
flux or git flow? Like if

412
00:27:19,938 --> 00:27:22,812
we want to deploy first in these development, then QA,

413
00:27:22,876 --> 00:27:26,928
then production. That's something that needs to be discussed before

414
00:27:27,014 --> 00:27:30,480
and implemented if you want to, but some protection on the branch.

415
00:27:31,620 --> 00:27:35,236
So these issue is that these really need to be discussed before putting a

416
00:27:35,258 --> 00:27:38,948
GitHub solution or you may need to refactor these

417
00:27:38,954 --> 00:27:42,592
code base in the future. They're not mandatory

418
00:27:42,656 --> 00:27:46,516
I would say, but it's still nice to do it before implementing

419
00:27:46,548 --> 00:27:47,130
it.

420
00:27:53,000 --> 00:27:56,916
So let's begin with flux. A Redmissrazer team wants

421
00:27:56,938 --> 00:28:00,712
to install it on these cluster to do so

422
00:28:00,766 --> 00:28:04,424
they have two official choices. Either install flux with

423
00:28:04,462 --> 00:28:07,656
a CLI which will bootstrap the installation on

424
00:28:07,678 --> 00:28:11,636
the cluster and create the initial synchronization between the cluster

425
00:28:11,748 --> 00:28:14,956
and these provided root repository provided by you,

426
00:28:14,978 --> 00:28:18,844
I mean. Or you can use terraform which do

427
00:28:18,882 --> 00:28:22,684
the same thing has in CLI but with terraform which is

428
00:28:22,722 --> 00:28:26,428
useful. When for example, you are using managed cluster

429
00:28:26,524 --> 00:28:28,400
on AWS or GCP.

430
00:28:30,740 --> 00:28:34,272
There also exists a community mshat that will

431
00:28:34,406 --> 00:28:38,736
install the core component of flux on your cluster,

432
00:28:38,928 --> 00:28:42,420
but will not create any initial synchronization between

433
00:28:42,570 --> 00:28:45,460
the cluster and git repository.

434
00:28:49,000 --> 00:28:52,276
So like I said, flux manifests will be committed to the root

435
00:28:52,308 --> 00:28:55,796
repository. That means that if flux detects,

436
00:28:55,828 --> 00:28:59,544
for example, that there is a change between the git repository, only its own

437
00:28:59,582 --> 00:29:02,970
installation flux can correct this change by itself.

438
00:29:04,560 --> 00:29:08,008
So now that you have installed flux on your cluster

439
00:29:08,184 --> 00:29:11,736
and that flux is doing the initial synchronization

440
00:29:11,848 --> 00:29:15,852
between its root repository on the cluster, you should know that

441
00:29:15,906 --> 00:29:19,596
you can put your manifest on the root repository before installing

442
00:29:19,628 --> 00:29:23,232
flux. That means that for example, if you have

443
00:29:23,286 --> 00:29:26,892
all your manifests already on your GitHub repository,

444
00:29:26,956 --> 00:29:30,348
for example from a production cluster, and you want to put them on a pre

445
00:29:30,374 --> 00:29:33,270
production cluster, you can do so really quickly.

446
00:29:38,720 --> 00:29:42,796
So we have installed flux on the cluster. We have the initial synchronization

447
00:29:42,908 --> 00:29:46,976
ready between git repository or root repository and

448
00:29:47,078 --> 00:29:50,640
the cluster. Now we want to add over

449
00:29:50,710 --> 00:29:54,064
multiple application on the cluster to

450
00:29:54,102 --> 00:29:57,460
do so. It's quite easy as long as you follow the documentation.

451
00:29:57,960 --> 00:30:01,524
You have really four custom resources that will Internet you

452
00:30:01,642 --> 00:30:05,636
the git repo, the customization, the amplitude and the

453
00:30:05,658 --> 00:30:09,556
narrative. And using these four customization custom resources,

454
00:30:09,668 --> 00:30:13,720
you will be able to deploy all your application on the cluster quite easily.

455
00:30:14,780 --> 00:30:17,944
Like the CRD, they really

456
00:30:17,982 --> 00:30:21,996
only do one thing, but they do it really well. There are no

457
00:30:22,018 --> 00:30:25,272
option on the CRD to really drastically

458
00:30:25,336 --> 00:30:28,190
change the way they function,

459
00:30:29,040 --> 00:30:32,336
but you can still do some minor configuration. For example,

460
00:30:32,438 --> 00:30:36,304
change the synchronization interval used by

461
00:30:36,342 --> 00:30:39,760
your different custom resources.

462
00:30:45,560 --> 00:30:49,760
So now we have our flux installation

463
00:30:49,840 --> 00:30:53,156
ready on the cluster. We have all application running on the

464
00:30:53,178 --> 00:30:56,664
cluster by flux. Let's see what

465
00:30:56,702 --> 00:30:59,816
happens if our developer teams want to

466
00:30:59,918 --> 00:31:03,240
modify something in the cluster.

467
00:31:04,060 --> 00:31:07,988
So to do so, it's quite simple. They really only have to commit

468
00:31:08,004 --> 00:31:11,464
a change in git on flux will handle everything else.

469
00:31:11,662 --> 00:31:15,576
So if you want to do an update, you write your commit, you merge

470
00:31:15,608 --> 00:31:19,240
it in the main branch. For example, influx will detect

471
00:31:19,320 --> 00:31:22,604
the change and apply it on the cluster. If the

472
00:31:22,642 --> 00:31:26,636
change is not up to your standard, you can revert

473
00:31:26,668 --> 00:31:30,064
the change using a git revert, commit it once again on

474
00:31:30,102 --> 00:31:33,692
the main branch and the flux will change the modification

475
00:31:33,756 --> 00:31:37,300
of your cluster. Now like I said,

476
00:31:37,370 --> 00:31:40,870
flux really only does one thing, it's one thing,

477
00:31:41,880 --> 00:31:43,620
it is synchronizing.

478
00:31:50,060 --> 00:31:53,896
So now we have flux running in the cluster. We have the

479
00:31:53,918 --> 00:31:57,640
different developer application also deployed on the cluster using

480
00:31:57,710 --> 00:32:01,460
flux. Let's see what happens if the developers want to modify

481
00:32:01,540 --> 00:32:05,228
one of the application. So the developer for example

482
00:32:05,314 --> 00:32:08,524
created a new version of the application and want to deploy it

483
00:32:08,562 --> 00:32:12,176
on these cluster two do so they will create a commit on one

484
00:32:12,198 --> 00:32:15,600
of the GitHub's git repository,

485
00:32:16,340 --> 00:32:20,124
merge the commit in one of the master branches and flux

486
00:32:20,172 --> 00:32:24,116
will detect the changes and apply it to the

487
00:32:24,138 --> 00:32:24,820
cluster.

488
00:32:27,400 --> 00:32:30,736
So to deploy a change on the cluster release,

489
00:32:30,768 --> 00:32:33,984
developer only have one tool to know it's git.

490
00:32:34,112 --> 00:32:37,436
They only need to know about a git commit git revert.

491
00:32:37,568 --> 00:32:39,130
That's all they need to know.

492
00:32:41,340 --> 00:32:45,012
If for a reason or another you want to pose

493
00:32:45,076 --> 00:32:48,484
the flux synchronization for a component between git

494
00:32:48,532 --> 00:32:52,108
and the cluster. For example, you deployed manually a change on the

495
00:32:52,114 --> 00:32:55,452
cluster and you needed to stay that way until you've committed it.

496
00:32:55,506 --> 00:32:59,144
Two git well you can use an annotation

497
00:32:59,272 --> 00:33:01,820
on the cumulative object of flux.

498
00:33:04,560 --> 00:33:08,636
So now that the developer has released its new version

499
00:33:08,668 --> 00:33:13,040
on git, he wants to check what is happening in the cluster.

500
00:33:14,180 --> 00:33:18,336
Well to do so, flux does not provide any UI out of

501
00:33:18,358 --> 00:33:21,600
the box. So these developer will need to have access to the cluster

502
00:33:21,680 --> 00:33:25,750
and check what is happening with flux and with its application.

503
00:33:26,680 --> 00:33:30,424
If there's an issue with the deployment, he will need to go

504
00:33:30,462 --> 00:33:34,136
check on the flux. Custom resources what is happening for example on

505
00:33:34,158 --> 00:33:37,716
the customization there may be an issue if one of the Kubernetes

506
00:33:37,748 --> 00:33:39,240
object is malformed.

507
00:33:40,800 --> 00:33:44,456
If the administrator team has properly

508
00:33:44,488 --> 00:33:47,884
configured it, the developers can use Grafana to check

509
00:33:47,922 --> 00:33:50,510
what is happening on flux with their application.

510
00:33:53,040 --> 00:33:56,968
There also exists web UI developed

511
00:33:56,984 --> 00:34:00,336
by withworks that will allow these developer to check what

512
00:34:00,358 --> 00:34:03,988
is happening with flux and whether its application is deployed on

513
00:34:03,994 --> 00:34:07,584
these cluster. Quite simply this web UI is not included

514
00:34:07,632 --> 00:34:11,060
in the box, but you can deploy it quite simply using Elm.

515
00:34:20,850 --> 00:34:25,022
So now from these point of view of the administrator,

516
00:34:25,166 --> 00:34:28,130
when you want to upgrade a flux installation,

517
00:34:29,510 --> 00:34:32,820
the way to do it depends the way you install it.

518
00:34:33,530 --> 00:34:37,286
If you install it with a CLI, well there is a command CLI to

519
00:34:37,308 --> 00:34:41,414
upgrade your application that

520
00:34:41,452 --> 00:34:44,680
is quite simple to use, but you need to remember

521
00:34:45,130 --> 00:34:49,146
the arguments you pass to the first command to

522
00:34:49,168 --> 00:34:51,610
the flux install command.

523
00:34:52,670 --> 00:34:56,166
If you're using terraform, it's quite simple, you just need to upgrade

524
00:34:56,198 --> 00:35:00,174
the version of the data source you are using and flux will do the

525
00:35:00,212 --> 00:35:04,030
rest. I want to put these little

526
00:35:04,100 --> 00:35:07,786
point of intention on the fact we use githubs

527
00:35:07,818 --> 00:35:11,822
to upgrade the Githubs tool. It can be dangerous to use

528
00:35:11,956 --> 00:35:15,570
GitHub to upgrade the same tool that is monitoring itself

529
00:35:15,720 --> 00:35:19,230
because if something were to run wrong in the update,

530
00:35:19,310 --> 00:35:22,882
well the tool will not be available to do a

531
00:35:22,936 --> 00:35:26,386
revat on itself and you would need to go on the cluster to upgrade

532
00:35:26,418 --> 00:35:29,810
it. So if you want to upgrade

533
00:35:29,890 --> 00:35:33,718
GitHub using GitHubs, I would recommend to use another

534
00:35:33,804 --> 00:35:37,160
GitHub tool to upgrade the first GitHub tools.

535
00:35:45,950 --> 00:35:49,280
So now let's see how ago CD works.

536
00:35:49,970 --> 00:35:53,166
So our team wants to install Argocd on their

537
00:35:53,188 --> 00:35:57,086
cluster. To do so they can use either helm or

538
00:35:57,268 --> 00:36:00,766
directly use Kubernetes manifest. It can be

539
00:36:00,788 --> 00:36:03,250
installed with Kubestall applied or customized.

540
00:36:05,430 --> 00:36:09,086
There is no initial git repository required when you are installing

541
00:36:09,118 --> 00:36:12,706
argocd. That means you only install the RSD core components and there

542
00:36:12,728 --> 00:36:16,614
is no initial synchronization done. There are

543
00:36:16,652 --> 00:36:20,434
three installation type that you can use, either highly available installation

544
00:36:20,482 --> 00:36:23,382
type, a nonlivariable insertion type,

545
00:36:23,516 --> 00:36:27,594
or a core only installation type that does not

546
00:36:27,632 --> 00:36:30,726
include the web UI. I would recommend using the non

547
00:36:30,758 --> 00:36:33,100
reliable installation one.

548
00:36:35,310 --> 00:36:38,866
So like I said, the OCD will not monitor

549
00:36:38,918 --> 00:36:42,126
itself. So that means that if you remove one

550
00:36:42,148 --> 00:36:46,030
of AGD components from kinesis it would not auto.

551
00:36:50,140 --> 00:36:54,152
So now we have our ArgoCD installation completed

552
00:36:54,216 --> 00:36:58,190
on the cluster. Let's see how we can install a different application.

553
00:36:58,880 --> 00:37:02,664
So IOCD will only use one custom resource

554
00:37:02,712 --> 00:37:06,350
to deploy these object on your cluster. It's these application

555
00:37:07,920 --> 00:37:12,340
so the application can deploy everything customize Internet

556
00:37:12,360 --> 00:37:16,128
catanet it's nice, but that means that there is a lot of different

557
00:37:16,214 --> 00:37:19,588
options you can use depending on your application on what you need to do.

558
00:37:19,754 --> 00:37:23,076
That means that the configuration of this custom resource can

559
00:37:23,098 --> 00:37:27,232
be quite complex. For example, by default

560
00:37:27,376 --> 00:37:31,944
these application will not remove anything from your cluster even

561
00:37:31,982 --> 00:37:35,880
if it's removed from git. Or if you remove the application from your cluster,

562
00:37:36,460 --> 00:37:40,090
you should also check which wave your

563
00:37:40,540 --> 00:37:43,996
application should be. That means whether your application depends on these one

564
00:37:44,018 --> 00:37:47,596
or not. So there is a lot of different options to

565
00:37:47,618 --> 00:37:51,512
use. But that can be simplified when you're using the web UI

566
00:37:51,576 --> 00:37:53,180
provided with AgoCD.

567
00:37:58,440 --> 00:38:01,664
Now our ArgoCD cluster is running on the Kubernetes

568
00:38:01,712 --> 00:38:05,192
cluster. The different developer applications are

569
00:38:05,246 --> 00:38:08,804
running using ArgoCD and the developer wants to upgrade

570
00:38:08,852 --> 00:38:12,584
one of its application to do so. He will need to commit

571
00:38:12,632 --> 00:38:16,568
his change to one of the monitored kit branches

572
00:38:16,744 --> 00:38:21,176
and then depending on how the application is configured on ArgoCD,

573
00:38:21,368 --> 00:38:24,668
it will either be automatically applied on these cluster

574
00:38:24,844 --> 00:38:28,672
or it will require human

575
00:38:28,726 --> 00:38:31,490
interaction. So a button to deploy it.

576
00:38:32,420 --> 00:38:36,080
The button will be quite nice for example for production scenario.

577
00:38:37,700 --> 00:38:41,716
So now the user has deployed these application on

578
00:38:41,738 --> 00:38:44,596
the cluster and he wants to check what is happening.

579
00:38:44,778 --> 00:38:48,440
Well, he can use the ArgoCD web UI to see if

580
00:38:48,510 --> 00:38:51,480
its application is deployed as he wants or not.

581
00:38:51,630 --> 00:38:55,610
It will indicate, for example if the application has

582
00:38:56,060 --> 00:38:59,240
issues running, for example if a pod is failing.

583
00:39:03,260 --> 00:39:06,200
Now from the point of view of the administrator,

584
00:39:06,620 --> 00:39:10,164
if you want to upgrade an ArgoCD

585
00:39:10,212 --> 00:39:13,576
cluster, it's quite simple. You can upgrade it

586
00:39:13,598 --> 00:39:17,160
using either Elm or customize.

587
00:39:17,680 --> 00:39:22,076
You really just need to apply the new version of

588
00:39:22,098 --> 00:39:25,790
the ArgoCD manifest and it will be modified as you want.

589
00:39:26,240 --> 00:39:29,976
I just want to remind you that when you are applying an upgrade on Weatherflux

590
00:39:30,008 --> 00:39:33,344
orgo CD, you should really read the release note to

591
00:39:33,382 --> 00:39:35,330
check if there are any breaking changes.

592
00:39:40,340 --> 00:39:43,444
So to summarize, ArgoCd is quite easy

593
00:39:43,482 --> 00:39:46,480
to install using standard Kubernetes tools.

594
00:39:46,640 --> 00:39:50,468
To configure, it is a little bit more complex since its customer

595
00:39:50,554 --> 00:39:56,616
source has a lot of options that will modify its behavior to

596
00:39:56,638 --> 00:40:00,356
use. From the developer point of view, it's quite simple. The web UI

597
00:40:00,388 --> 00:40:02,330
will help a lot in that regard.

598
00:40:03,660 --> 00:40:06,868
Also, AGC has a lot of sane options that will

599
00:40:06,894 --> 00:40:10,748
prevent it from breaking your cluster. For example,

600
00:40:10,834 --> 00:40:14,120
it will not remove anything from your cluster

601
00:40:14,280 --> 00:40:18,172
and it will always require an human interaction before applying something

602
00:40:18,226 --> 00:40:19,180
on the cluster.

603
00:40:21,380 --> 00:40:25,472
For flux, on the other hand, it's a little bit more complex. To install

604
00:40:25,606 --> 00:40:29,804
you need two give flux permission to access your repository

605
00:40:29,852 --> 00:40:33,712
to commit things in it, etc. To configure.

606
00:40:33,776 --> 00:40:37,284
It's simple. Each customer resource does one thing and it does

607
00:40:37,322 --> 00:40:39,940
it without modifying its behavior.

608
00:40:42,040 --> 00:40:45,844
Two, the usage. I would say it's still simple to use for

609
00:40:45,882 --> 00:40:49,956
the users, but it requires your users to be a little more experienced

610
00:40:49,988 --> 00:40:53,236
in Kubernetes. As there are no safety ads in flux.

611
00:40:53,348 --> 00:40:57,180
Everything committed in git will be deployed in kubernetes and everything

612
00:40:57,250 --> 00:41:01,164
kubernetes is in git. So what that means is that if you were to

613
00:41:01,202 --> 00:41:05,180
remove manifest in git, it will be removed in kubernetes.

614
00:41:10,500 --> 00:41:13,520
All right, so now let's talk performances.

615
00:41:14,500 --> 00:41:18,256
We wanted to see how angle CD and flux would handle a medium

616
00:41:18,288 --> 00:41:20,500
sized cluster of 200 deployments.

617
00:41:21,720 --> 00:41:25,840
These two Android deployments will come from both distinct git repositories

618
00:41:26,000 --> 00:41:29,844
and different embraces. That it will really match these

619
00:41:29,882 --> 00:41:32,680
standard Kubernetes installs that you can see in the wild.

620
00:41:34,780 --> 00:41:38,452
The different point of comparison we will use will be the time to deploy

621
00:41:38,516 --> 00:41:42,600
an object on the different processes used in the different lifecycle

622
00:41:42,680 --> 00:41:46,060
of the tool. We're talking before installing everything,

623
00:41:46,210 --> 00:41:49,984
when we've installed everything and it's monitoring the default object,

624
00:41:50,102 --> 00:41:52,210
and when it's removing these object,

625
00:41:53,860 --> 00:41:57,776
only the core components will be considered for the benchmark. So we

626
00:41:57,798 --> 00:42:00,370
didn't install any other tool than.

627
00:42:05,610 --> 00:42:09,622
All right, so our setup we are

628
00:42:09,676 --> 00:42:13,270
testing our benchmark on an AWS lacks cluster and

629
00:42:13,340 --> 00:42:17,650
everyone of our GitHub tool has run git repository

630
00:42:17,730 --> 00:42:21,240
already synced into which we will push our default changes.

631
00:42:22,730 --> 00:42:26,326
In terms of installation, ArgoCD has been installed

632
00:42:26,358 --> 00:42:29,498
with a non highly available installation,

633
00:42:29,594 --> 00:42:33,038
so that means we still have the web UI available. We are

634
00:42:33,044 --> 00:42:36,030
using these version two 60 for aquacid.

635
00:42:37,330 --> 00:42:41,806
For flux we used the standard installation with CLI

636
00:42:41,998 --> 00:42:45,074
and we are using the latest version available for us which is

637
00:42:45,112 --> 00:42:49,186
00:38 these in

638
00:42:49,208 --> 00:42:54,566
term of initial resources taken when

639
00:42:54,588 --> 00:42:57,794
we did not deploy anything else other than the initial git repository,

640
00:42:57,922 --> 00:43:01,526
we can see that they are both nearly identical in term of

641
00:43:01,708 --> 00:43:05,446
resources. So first the

642
00:43:05,468 --> 00:43:08,658
timelines. We can see that flex before the

643
00:43:08,684 --> 00:43:11,898
installation of all our components is not taking a

644
00:43:11,904 --> 00:43:16,038
lot of resources. Then when we're installing these components we can see a little peak

645
00:43:16,134 --> 00:43:19,866
in both cpu and memory usage and that taken average

646
00:43:19,898 --> 00:43:23,070
out to not a lot of resources before the removal.

647
00:43:23,730 --> 00:43:27,834
We can see that for flux the components taking the most resources

648
00:43:27,962 --> 00:43:32,814
is these Elm controller for

649
00:43:32,852 --> 00:43:36,226
COCD, same thing I would say we do not

650
00:43:36,248 --> 00:43:39,730
take a lot of resources at the start of ArgoCD then

651
00:43:39,880 --> 00:43:43,246
insertion a huge peak we are averaging.

652
00:43:43,278 --> 00:43:47,122
But again our cpu and memory memory consumption little

653
00:43:47,176 --> 00:43:49,380
peak at the end when we are removing things.

654
00:43:50,230 --> 00:43:54,246
Fargo CD the component that is taking the most resources is the

655
00:43:54,268 --> 00:43:55,670
application controller.

656
00:43:59,960 --> 00:44:03,144
So let's compare our deployment. We can see that

657
00:44:03,182 --> 00:44:07,044
as a first synchronization. These ArgoCD will take nearly

658
00:44:07,092 --> 00:44:09,370
twice the resources in flux does.

659
00:44:10,560 --> 00:44:14,316
The time to deploy all objects is identical for both of

660
00:44:14,338 --> 00:44:17,788
them. So it's not here a good comparison point I

661
00:44:17,794 --> 00:44:21,196
would say on the day to

662
00:44:21,218 --> 00:44:24,896
day operations we can see that now obviously on

663
00:44:24,918 --> 00:44:29,292
flux both have reduced their resources usages

664
00:44:29,436 --> 00:44:32,960
and now they both have the same point.

665
00:44:33,030 --> 00:44:36,788
I would say in term of CPU consumption, but ICOCD now consumes a

666
00:44:36,794 --> 00:44:41,030
lot more resources in term of memory than flux does.

667
00:44:41,800 --> 00:44:45,284
So this metric is the most important to you I think since

668
00:44:45,322 --> 00:44:51,256
this is what will be on your cluster 99% of the time on

669
00:44:51,278 --> 00:44:55,336
the production side, we can see that ArgoCD took a

670
00:44:55,358 --> 00:44:58,404
little bit more time than flux, but it's not consequential

671
00:44:58,452 --> 00:45:02,112
I would say, and that once again ago CD

672
00:45:02,196 --> 00:45:04,300
took more resources than flux.

673
00:45:08,760 --> 00:45:12,752
So the results we can see that in terms of deployment speed,

674
00:45:12,896 --> 00:45:16,776
both ArgoCD and Flux are fast. These will

675
00:45:16,798 --> 00:45:20,040
be faster than anything you can code in your CD pipelines.

676
00:45:22,380 --> 00:45:26,136
In terms of resources consumption, we can see that ArgoCD is

677
00:45:26,158 --> 00:45:29,356
taking a lot more resources than flux. We think

678
00:45:29,378 --> 00:45:33,532
it comes from the architectural choices Daco city took in that

679
00:45:33,586 --> 00:45:37,624
its application is doing everything its application custom resource.

680
00:45:37,672 --> 00:45:41,568
I mean in our experience,

681
00:45:41,734 --> 00:45:45,452
this memory consumption of ArgOCD

682
00:45:45,516 --> 00:45:49,020
is really impacted by the number of objects it is tracking in Kubernetes.

683
00:45:49,180 --> 00:45:52,532
So if you are having a large cluster ago CD will be

684
00:45:52,586 --> 00:45:54,660
needing a lot of memory.

685
00:45:58,760 --> 00:46:02,016
So we have arrived at these end of our talk. I hope we've

686
00:46:02,048 --> 00:46:05,640
given you the necessary point to compare both OCD and flux.

687
00:46:07,740 --> 00:46:10,996
So two recap OCD will be better suited

688
00:46:11,028 --> 00:46:14,536
for you. If you need to ensure that your users need to

689
00:46:14,558 --> 00:46:18,328
use a button, for example to push two production. They don't need a full auto

690
00:46:18,344 --> 00:46:22,108
GitHub CD pipeline. If you want to give

691
00:46:22,274 --> 00:46:26,076
your users a rich web UI so that they can see what

692
00:46:26,098 --> 00:46:29,464
is happening on the Kubernetes cluster under the CD pipelines,

693
00:46:29,592 --> 00:46:33,008
ArgOCD is a better tool and if you want

694
00:46:33,014 --> 00:46:36,812
to protect your production, by that I mean ensure that only some users

695
00:46:36,876 --> 00:46:39,996
can push the changes to the Kubernetes cluster

696
00:46:40,108 --> 00:46:44,108
and that these changes will not remove anything from the Kubernetes cluster.

697
00:46:44,204 --> 00:46:47,812
ArgoCD is better suited for you. On the other

698
00:46:47,866 --> 00:46:51,328
one, if your users are experts in Kubernetes,

699
00:46:51,504 --> 00:46:54,708
if they understand that everything that is happening on

700
00:46:54,714 --> 00:46:58,400
the git repository will be reproduced

701
00:46:58,480 --> 00:47:02,740
to the Kubernetes cluster, and that these git and Kubernetes

702
00:47:02,820 --> 00:47:06,228
airbag are good enough for you, well then flux will be

703
00:47:06,254 --> 00:47:07,550
better suited for you.

704
00:47:10,400 --> 00:47:13,592
We want to end this talk with some encouragement.

705
00:47:13,656 --> 00:47:16,908
Two, the whiskey team that helped us a lot to

706
00:47:16,994 --> 00:47:20,092
create these talk on these.

707
00:47:20,146 --> 00:47:23,576
Mainly Basin Fergie who gave us a lot of advice

708
00:47:23,688 --> 00:47:27,340
on how to handle ArgoCD on orchester.

709
00:47:28,000 --> 00:47:31,970
I hope you've learned something today. Thanks for listening two.

