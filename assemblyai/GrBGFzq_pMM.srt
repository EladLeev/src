1
00:00:23,050 --> 00:00:26,894
Hello everyone. Thanks for joining the session today, where we'll be

2
00:00:26,932 --> 00:00:30,534
talking about the genuine hat at Mercloud of implementing a

3
00:00:30,572 --> 00:00:34,402
multitenant front end architecture for our ecommerce

4
00:00:34,466 --> 00:00:38,434
platform. But let me start by introducing

5
00:00:38,482 --> 00:00:41,734
myself. My name is Gilermi. I'm the CTO and co

6
00:00:41,772 --> 00:00:45,110
founder at Mercloud, currently based in London,

7
00:00:45,190 --> 00:00:49,066
and I've been working for 17 years in the industry, most of

8
00:00:49,088 --> 00:00:52,506
those as a software engineer. If you'd like to reach out to

9
00:00:52,528 --> 00:00:56,030
me or simply follow the content

10
00:00:56,100 --> 00:00:59,786
I'm always sharing online, you can find here on this slide the links

11
00:00:59,818 --> 00:01:03,422
to my social media. Also, let me

12
00:01:03,556 --> 00:01:07,410
talk to you about Mercloud. What we do here,

13
00:01:07,560 --> 00:01:11,106
we develop an ecommerce platform that specializes for the b two

14
00:01:11,128 --> 00:01:14,658
B market that handles all the complexities of

15
00:01:14,744 --> 00:01:18,194
sales between companies. We work with companies

16
00:01:18,312 --> 00:01:21,730
across different industries to help them to provide a digital

17
00:01:21,810 --> 00:01:25,590
sales channel to their customers where they can

18
00:01:25,660 --> 00:01:29,062
have access to the catalog of products and also make

19
00:01:29,116 --> 00:01:32,502
and manage their orders. If you're interested to

20
00:01:32,556 --> 00:01:36,140
know a bit more about our company and the product we built,

21
00:01:36,510 --> 00:01:39,990
we can check that out on our website, mercloud IO.

22
00:01:40,070 --> 00:01:42,780
Or you can also reach out to me on my social media.

23
00:01:43,550 --> 00:01:46,734
All right, let's start understanding what exactly is

24
00:01:46,772 --> 00:01:50,126
a b two B ecommerce? When we talk about ecommerce, the first

25
00:01:50,148 --> 00:01:53,566
thing that comes our mind is the traditional b to C model

26
00:01:53,748 --> 00:01:57,666
where I'll give you an example. I want

27
00:01:57,688 --> 00:02:00,914
to buy a product. I go to an online shop,

28
00:02:01,112 --> 00:02:04,034
browse some products, compare different options,

29
00:02:04,232 --> 00:02:08,146
prices, add to my basket, make the payment, and after a

30
00:02:08,168 --> 00:02:11,590
few days I get it delivered at my doorstep.

31
00:02:12,410 --> 00:02:17,174
On a B two B scenario, the actor behind the

32
00:02:17,212 --> 00:02:20,914
purchase, it's a person on

33
00:02:20,972 --> 00:02:24,394
behalf of a company. Let's say you

34
00:02:24,432 --> 00:02:28,902
have a store where you sell electronics. So you need to constantly

35
00:02:28,966 --> 00:02:32,300
reach out to your suppliers to buy

36
00:02:32,750 --> 00:02:36,318
products to refuel your stock as you're selling your products.

37
00:02:36,484 --> 00:02:40,170
That's a B two B ecommerce scenario,

38
00:02:40,330 --> 00:02:43,498
where the goal here is often to establish

39
00:02:43,594 --> 00:02:46,962
a long term relationship with your customers rather

40
00:02:47,016 --> 00:02:51,074
than a one time transaction. If I

41
00:02:51,112 --> 00:02:53,330
go online and buy a television,

42
00:02:55,030 --> 00:02:58,718
I won't be coming back to that same online store

43
00:02:58,904 --> 00:03:02,182
to buy another television in a couple of years.

44
00:03:02,316 --> 00:03:06,342
But if I'm refilling stock for my store,

45
00:03:06,476 --> 00:03:08,680
I'll be using that very often.

46
00:03:11,310 --> 00:03:14,746
On a b two B ecommerce, we need to

47
00:03:14,768 --> 00:03:18,842
handle complex topics like

48
00:03:18,976 --> 00:03:22,042
customized pricing models based

49
00:03:22,096 --> 00:03:25,722
on customer profile. And the profile

50
00:03:25,786 --> 00:03:28,938
here can be the geolocation, the customer tier.

51
00:03:29,034 --> 00:03:32,830
You might have a customer that's vip where you apply special

52
00:03:32,900 --> 00:03:37,010
pricing to it. There's also complex tax regimes

53
00:03:37,350 --> 00:03:40,738
where the policies and the rates are based

54
00:03:40,904 --> 00:03:44,610
on the product and the customer who is buying.

55
00:03:45,030 --> 00:03:48,850
I might have a product that has a reduced VAT

56
00:03:48,930 --> 00:03:52,920
rate, for example, or it might have

57
00:03:53,290 --> 00:03:57,160
extra taxes applied on top of that. And also

58
00:03:58,410 --> 00:04:02,138
because we're talking about refilling in stock, we're talking about

59
00:04:02,224 --> 00:04:06,346
big transactions. The volume of these orders are quite big

60
00:04:06,448 --> 00:04:10,614
and they usually involve multilayered approval

61
00:04:10,662 --> 00:04:14,510
process. People need to approve each transactions

62
00:04:16,050 --> 00:04:19,950
in the chain. And who exactly

63
00:04:20,020 --> 00:04:23,934
are these customers of such a solution? And to understand who

64
00:04:23,972 --> 00:04:27,774
they are, first we need to understand how the product supply chain

65
00:04:27,822 --> 00:04:31,326
looks like, from getting the raw material

66
00:04:31,438 --> 00:04:35,006
to the manufacturer and then distributing

67
00:04:35,038 --> 00:04:38,930
the products to retailers and wholesaler suppliers

68
00:04:39,690 --> 00:04:43,558
who will then sell these products to the final customers.

69
00:04:43,724 --> 00:04:46,680
And all these transactions we see here,

70
00:04:47,610 --> 00:04:50,966
before reaching out the final transactions, they are b

71
00:04:50,988 --> 00:04:55,030
two b transactions. And here is where b two B ecommerce

72
00:04:55,110 --> 00:04:58,586
is used. The final one is the traditional one that we

73
00:04:58,608 --> 00:05:02,586
know that's a b two c. So that's another

74
00:05:02,688 --> 00:05:05,280
type of ecommerce that we're talking about.

75
00:05:06,610 --> 00:05:10,080
All right, so let's see where we started.

76
00:05:10,530 --> 00:05:14,682
The first version of our solution was a very traditional react

77
00:05:14,746 --> 00:05:18,210
application where we wanted to take advantage of things like

78
00:05:18,280 --> 00:05:22,334
server side rendering and caching on the CDN

79
00:05:22,382 --> 00:05:26,354
level. And the architecture of

80
00:05:26,392 --> 00:05:29,958
our mvp looked like this. We had it

81
00:05:30,124 --> 00:05:33,362
deployed on AWS. The react

82
00:05:33,426 --> 00:05:36,866
application was running on a Fargate cluster,

83
00:05:37,058 --> 00:05:41,110
and in front of the load balancer we had a CDN.

84
00:05:41,470 --> 00:05:45,030
And also we had our static

85
00:05:45,110 --> 00:05:48,902
asset, not only Javascript but also images

86
00:05:48,966 --> 00:05:52,726
of products hosted on s three that we could serve

87
00:05:52,838 --> 00:05:57,002
to the users. That was a quite simple architecture,

88
00:05:57,066 --> 00:06:00,206
but there were constraints. We had to

89
00:06:00,228 --> 00:06:03,520
replicate this stack once per customer

90
00:06:04,850 --> 00:06:08,622
and that was causing us to have high costs. Each tenant,

91
00:06:08,686 --> 00:06:12,718
they had to have their own infrastructure with their own resources,

92
00:06:12,814 --> 00:06:17,454
and each of these resources they had to be sized

93
00:06:17,502 --> 00:06:21,320
to accommodate the demand of each of those customers.

94
00:06:23,210 --> 00:06:27,190
This was also making our onboarding process rather complicated,

95
00:06:28,010 --> 00:06:31,498
not only deploying a new stack per customer,

96
00:06:31,584 --> 00:06:35,162
but also configuring it. And you can see that this

97
00:06:35,216 --> 00:06:38,682
was getting harder. By the time

98
00:06:38,816 --> 00:06:42,730
as this architecture was growing, it was harder to get it

99
00:06:42,800 --> 00:06:46,414
fully automated and also was challenging us to deliver new

100
00:06:46,452 --> 00:06:50,174
features with a very slow deployment process because

101
00:06:50,212 --> 00:06:53,470
we had all these tags to maintain to update

102
00:06:53,810 --> 00:06:57,554
and on top of that was also difficult to

103
00:06:57,592 --> 00:07:01,620
monitor. And we also had some poor performance numbers.

104
00:07:03,110 --> 00:07:05,986
Even though this was not perfect,

105
00:07:06,088 --> 00:07:10,200
it was pretty okay for our mvp and helped us to onboard our first customers.

106
00:07:10,730 --> 00:07:14,614
But the next step was for us to think

107
00:07:14,652 --> 00:07:18,898
about the next generation of this application and reimagine

108
00:07:18,994 --> 00:07:22,618
the architecture. And we wanted

109
00:07:22,704 --> 00:07:26,202
to rebuild an application, not only to modernize it,

110
00:07:26,256 --> 00:07:29,818
but also to support increasing customer base.

111
00:07:29,904 --> 00:07:33,354
We had, and the main points we wanted to

112
00:07:33,392 --> 00:07:37,306
focus on this re architecture were increasing

113
00:07:37,338 --> 00:07:40,618
the scalability and reduce the management overhead,

114
00:07:40,714 --> 00:07:44,782
have less things to maintain and

115
00:07:44,836 --> 00:07:48,894
configure. And also we wanted to have an architecture

116
00:07:48,942 --> 00:07:52,706
that would allow us to have quicker deployments and also

117
00:07:52,888 --> 00:07:55,060
a faster onboarding experience.

118
00:07:55,990 --> 00:07:59,542
We also wanted to reduce the latency of

119
00:07:59,596 --> 00:08:03,718
our customers. We had customers spread across

120
00:08:03,804 --> 00:08:07,670
different regions in the globe. We have many customers

121
00:08:07,740 --> 00:08:11,358
in South America, us, and also few in Europe.

122
00:08:11,474 --> 00:08:14,954
So we wanted the data and the

123
00:08:14,992 --> 00:08:17,820
service as close as possible to our customers.

124
00:08:18,350 --> 00:08:22,166
We also wanted to increase the observability

125
00:08:22,278 --> 00:08:26,000
to understand better what was going on on our application.

126
00:08:27,410 --> 00:08:30,702
The solution to simplify this architecture was

127
00:08:30,756 --> 00:08:35,360
then to transform it into a multitenant one.

128
00:08:36,710 --> 00:08:41,090
Okay, what exactly is a multitenant architecture?

129
00:08:41,830 --> 00:08:45,854
It's an architecture where you have a single instance of your application serving

130
00:08:45,902 --> 00:08:49,302
multiple customers. And these customers, they are known as

131
00:08:49,356 --> 00:08:53,154
tenants. This model will help you to maximize

132
00:08:53,202 --> 00:08:56,742
the resource utilization in an efficient way,

133
00:08:56,876 --> 00:09:00,406
because you're sharing the same infrastructure with all

134
00:09:00,428 --> 00:09:04,106
your customers. Here we have an example where

135
00:09:04,128 --> 00:09:07,498
we can compare the two different models. The single tenant one on

136
00:09:07,504 --> 00:09:10,954
the left, where each of our customers are

137
00:09:10,992 --> 00:09:14,974
tenants, they have their own installation, their own instance of the application,

138
00:09:15,172 --> 00:09:18,320
and that's talking to their own data.

139
00:09:19,170 --> 00:09:22,462
On the right one, we have the multitenant one,

140
00:09:22,516 --> 00:09:26,026
where you can see that we have one single instance of the application

141
00:09:26,148 --> 00:09:30,242
serving everyone, but we can still keep

142
00:09:30,296 --> 00:09:33,170
that data isolated from each other.

143
00:09:33,320 --> 00:09:37,678
And talking about data isolation, this is a quite complex

144
00:09:37,854 --> 00:09:41,110
topic, but it's something very important that

145
00:09:41,180 --> 00:09:45,378
you need to consider when building such a solution.

146
00:09:45,554 --> 00:09:48,866
We need to pick an isolation strategy,

147
00:09:48,978 --> 00:09:52,390
and you can start from a fully isolated

148
00:09:52,470 --> 00:09:55,930
model where everything is

149
00:09:56,080 --> 00:10:00,170
isolated from each other, they don't talk to between

150
00:10:00,240 --> 00:10:03,866
them. Or you can go to a fully shared one

151
00:10:03,968 --> 00:10:07,594
where you have instances of, for example, your database, your data lake,

152
00:10:07,642 --> 00:10:11,038
and you're sharing that with all your customers. In the middle,

153
00:10:11,124 --> 00:10:14,880
you can have also a hybrid model where you share

154
00:10:17,090 --> 00:10:20,546
only a few of these resources. You have

155
00:10:20,568 --> 00:10:24,386
to pick the best strategy. But this is not only based on your

156
00:10:24,408 --> 00:10:27,854
own needs, this will also be based on your tenants

157
00:10:27,982 --> 00:10:31,010
needs. For example, compliance,

158
00:10:31,090 --> 00:10:35,000
GDPR. So this is something you really need to consider

159
00:10:35,610 --> 00:10:38,520
and pick the better strategy for that.

160
00:10:39,930 --> 00:10:43,446
Let's talk about the benefits of a multitenant architecture.

161
00:10:43,558 --> 00:10:47,114
First, it's cost efficient because

162
00:10:47,232 --> 00:10:50,838
we have resources that are shared among

163
00:10:50,934 --> 00:10:54,954
those tenants. We no longer need to deploy

164
00:10:55,002 --> 00:10:58,650
a different stack for each of them. It's also scalable.

165
00:10:58,810 --> 00:11:02,990
You can scale horizontally to accommodate the increase

166
00:11:03,810 --> 00:11:07,874
of demand, not only for new

167
00:11:07,912 --> 00:11:11,298
tenants, but also the increased demands of your current

168
00:11:11,384 --> 00:11:14,994
ones. Is you also

169
00:11:15,112 --> 00:11:18,638
have usually one single pipeline that will

170
00:11:18,664 --> 00:11:22,822
handle the deployment of this whole architecture. So this

171
00:11:22,876 --> 00:11:26,840
allows you to be more efficient and deploy quicker your changes

172
00:11:27,290 --> 00:11:30,830
and also helps with security and compliance

173
00:11:31,010 --> 00:11:34,262
because you end up having a centralized management

174
00:11:34,326 --> 00:11:38,890
solution with uniform policies that are just applied

175
00:11:39,310 --> 00:11:41,180
across all your customers.

176
00:11:42,990 --> 00:11:47,050
This kind of solution also increases your developer productivity.

177
00:11:47,130 --> 00:11:50,494
Like I said, you have one single pipeline that you

178
00:11:50,612 --> 00:11:53,962
handle the full deployment and in most cases

179
00:11:54,026 --> 00:11:58,638
you also end up with a single code base. It's easier for you to iterate.

180
00:11:58,814 --> 00:12:03,266
That also increases the business agility. It will

181
00:12:03,448 --> 00:12:06,786
allow you to adapt to new demands in a

182
00:12:06,808 --> 00:12:10,870
rapid way and also quickly launch these new features

183
00:12:11,210 --> 00:12:15,746
in a short period of time. Okay, so let's

184
00:12:15,778 --> 00:12:18,966
talk now about the technology choices we had for

185
00:12:18,988 --> 00:12:23,186
this project. To develop it, we chose

186
00:12:23,298 --> 00:12:27,290
NextJs. And the reasons why we chose next JS

187
00:12:29,070 --> 00:12:32,618
initially because it has a great

188
00:12:32,704 --> 00:12:35,978
dev experience with zero config

189
00:12:36,074 --> 00:12:40,202
in a matter of minutes. You can clone a template

190
00:12:40,266 --> 00:12:43,966
repository and start coding and deploy it

191
00:12:43,988 --> 00:12:47,442
in a matter of few minutes. That's great. There's not

192
00:12:47,496 --> 00:12:50,962
much management involved to it. It also comes

193
00:12:51,016 --> 00:12:55,234
with a simplified routing solution building

194
00:12:55,432 --> 00:12:59,014
and also other tools that helps on your

195
00:12:59,052 --> 00:13:03,030
day by day as a developer. For example hot code reloading.

196
00:13:03,850 --> 00:13:08,118
It also comes with rich building features that helps you

197
00:13:08,284 --> 00:13:12,250
with server side rendering and also static generation.

198
00:13:13,390 --> 00:13:17,114
Also because we already had react expertise in house,

199
00:13:17,232 --> 00:13:20,666
was easier for us to stick to the ecosystem and

200
00:13:20,688 --> 00:13:22,410
just keep using react.

201
00:13:23,410 --> 00:13:27,454
Next JS also comes with some

202
00:13:27,572 --> 00:13:31,422
performance optimization out of the box. For example,

203
00:13:31,556 --> 00:13:35,342
automatic code splitting. That's something that you usually

204
00:13:35,476 --> 00:13:39,074
would need to do manually with webpack. It also

205
00:13:39,112 --> 00:13:42,498
comes with image optimization and

206
00:13:42,584 --> 00:13:46,050
URL prefetching. And not to mention

207
00:13:46,120 --> 00:13:49,906
that they also have a big community and great documentation.

208
00:13:50,018 --> 00:13:53,830
It's very easy to find resources online and

209
00:13:53,900 --> 00:13:56,422
examples. Okay,

210
00:13:56,476 --> 00:13:59,974
so we chose next JS to build it and

211
00:14:00,092 --> 00:14:04,070
to run it. To deploy it, we decided to

212
00:14:04,140 --> 00:14:08,058
use Versaille. First reason is that Versaille is the company

213
00:14:08,144 --> 00:14:11,580
behind NextJs. So we can expect

214
00:14:13,150 --> 00:14:16,954
this marriage to take the most advantage

215
00:14:17,002 --> 00:14:20,190
of both solutions. But not only that,

216
00:14:20,260 --> 00:14:23,786
we also wanted to take advantage of compute

217
00:14:23,818 --> 00:14:27,362
at the edge. The global edge network will allow

218
00:14:27,416 --> 00:14:30,818
us to deploy to multiple locations and

219
00:14:30,984 --> 00:14:34,194
this will come with multi availability zones and

220
00:14:34,232 --> 00:14:36,660
automatic failover out of the box.

221
00:14:37,750 --> 00:14:40,934
So this way we can ensure that our application

222
00:14:41,052 --> 00:14:45,442
will be running as close as possible to the geographical

223
00:14:45,506 --> 00:14:49,346
location of our users. There's also no infrastructure

224
00:14:49,378 --> 00:14:52,922
as code to maintain, it's just code. All you need to do is to connect

225
00:14:52,976 --> 00:14:56,970
your GitHub repo to Versaille, and then you get automatically

226
00:14:57,790 --> 00:15:01,542
deployments with cache invalidation. And my favorite

227
00:15:01,606 --> 00:15:05,422
one that is the preview deployments. How do they

228
00:15:05,476 --> 00:15:08,622
work? Every time you create a new

229
00:15:08,676 --> 00:15:12,606
branch on your repo and you push changes to it,

230
00:15:12,708 --> 00:15:16,510
Versailles will create a new isolated environment,

231
00:15:16,590 --> 00:15:20,190
deploy that code and provide you a temporary URL

232
00:15:20,270 --> 00:15:24,370
where you can use to validate your deployment and also for testing.

233
00:15:24,950 --> 00:15:28,618
And also, another thing that Versailles

234
00:15:28,654 --> 00:15:32,594
helps us is to stick to our serverless first approach

235
00:15:32,642 --> 00:15:36,054
that we had. Mercloud. For those

236
00:15:36,092 --> 00:15:40,246
who are not familiar what serverless is, it's a

237
00:15:40,268 --> 00:15:44,390
way to run your application in the cloud without the need of servers.

238
00:15:44,810 --> 00:15:48,982
There are servers, of course, but you just don't need

239
00:15:49,116 --> 00:15:52,754
to manage them. You have your small units

240
00:15:52,802 --> 00:15:56,778
of code that are your functions

241
00:15:56,874 --> 00:16:00,654
and they are triggered by events, and you only pay

242
00:16:00,692 --> 00:16:04,814
for what you use. So if you have an idle application

243
00:16:04,932 --> 00:16:08,926
because you have few customers, it's overnight, the weekend,

244
00:16:09,038 --> 00:16:13,390
so you're not paying for it because you're not consuming.

245
00:16:13,550 --> 00:16:16,900
And serverless comes with some good benefits.

246
00:16:17,510 --> 00:16:21,206
It helps you to focus on business logic and let the

247
00:16:21,228 --> 00:16:24,614
cloud manage the infrastructure for you. This also

248
00:16:24,652 --> 00:16:28,294
increases your team agility, and not

249
00:16:28,332 --> 00:16:32,410
to mention that you have automatic scalability.

250
00:16:32,750 --> 00:16:36,470
The cloud will manage that for you. You don't need to worry

251
00:16:36,630 --> 00:16:40,074
about this. Usually, of course this

252
00:16:40,112 --> 00:16:44,650
is not a universal solution, but works pretty well in many situations.

253
00:16:44,990 --> 00:16:48,686
All right, so after the technology choices, we came up

254
00:16:48,708 --> 00:16:52,154
with a draft idea of how our new architecture

255
00:16:52,202 --> 00:16:55,486
would look like. So we can see here that we

256
00:16:55,508 --> 00:16:58,210
have a frontend sitting behind the CDN.

257
00:17:00,310 --> 00:17:03,822
So this is running as close as possible to the users.

258
00:17:03,966 --> 00:17:07,010
And this next JS application will be

259
00:17:07,080 --> 00:17:10,786
communicating with our API. So this API

260
00:17:10,818 --> 00:17:14,774
was already built and deployed and

261
00:17:14,812 --> 00:17:18,594
hosted to AWS. So all we had to do was to consume

262
00:17:18,642 --> 00:17:22,186
it. But before starting to code anything, we had

263
00:17:22,208 --> 00:17:25,882
to solve some challenges. And the first one was how could

264
00:17:25,936 --> 00:17:28,790
we identify each of our tenants?

265
00:17:28,950 --> 00:17:32,906
It's pretty common to see out the SaaS products

266
00:17:33,008 --> 00:17:36,938
to handle multitenants by providing each of the tenants

267
00:17:37,034 --> 00:17:41,466
a subdomain. So every time you need to identify which tenants belongs

268
00:17:41,498 --> 00:17:45,310
to a particular request, you parse

269
00:17:45,910 --> 00:17:49,634
the host header of the request and then you can

270
00:17:49,672 --> 00:17:53,026
simply extract the tenant identification from

271
00:17:53,048 --> 00:17:56,354
that domain. But in

272
00:17:56,392 --> 00:18:00,214
our case, our customers are exposing this application to their

273
00:18:00,252 --> 00:18:03,794
own customers. So we wanted to allow them to configure

274
00:18:03,842 --> 00:18:08,210
and run it with their own domains. So this approach

275
00:18:08,290 --> 00:18:12,374
will no longer work because we cannot just parse the URL

276
00:18:12,422 --> 00:18:15,514
and extract that tenant identification from it.

277
00:18:15,632 --> 00:18:19,334
We also have the situation where we need to handle

278
00:18:19,382 --> 00:18:22,518
multiple domains pointing to the same tenant.

279
00:18:22,694 --> 00:18:26,554
And to handle this we will need to have a mapping

280
00:18:26,602 --> 00:18:29,866
table where we can correlate which domain

281
00:18:29,898 --> 00:18:33,086
belongs to what tenant. So every time I need

282
00:18:33,108 --> 00:18:36,926
to identify what tenant request belongs

283
00:18:36,958 --> 00:18:40,290
to, I can simply do a lookup on this table and

284
00:18:40,360 --> 00:18:44,226
get the correlation there. And the

285
00:18:44,248 --> 00:18:47,986
way our tenants they can configure their custom domain for

286
00:18:48,008 --> 00:18:51,398
this setup is by using your admin application.

287
00:18:51,564 --> 00:18:55,350
Once they configure a domain, we save this information

288
00:18:55,500 --> 00:18:58,694
on that mapping table I just showed you and this

289
00:18:58,732 --> 00:19:03,050
will trigger a routine that will configure this custom domain in Versailles

290
00:19:03,390 --> 00:19:07,174
using the domains API. What exactly is this domains

291
00:19:07,222 --> 00:19:11,050
API? If you have used Versailles already

292
00:19:11,200 --> 00:19:14,746
and you go to the settings of your project, you see there are a tab

293
00:19:14,778 --> 00:19:18,366
where you can configure custom domains for

294
00:19:18,388 --> 00:19:23,738
your project. And this is the same API we're

295
00:19:23,754 --> 00:19:26,974
using on the solution. And once you link

296
00:19:27,012 --> 00:19:31,694
a new domain, you need to somehow validate

297
00:19:31,742 --> 00:19:35,854
that you own that domain. And the way you can do this with Vercel

298
00:19:35,902 --> 00:19:39,582
is by creating a CNA entry to the DNS of configuration

299
00:19:39,646 --> 00:19:44,018
of the domain and then you have your traffic redirect

300
00:19:44,114 --> 00:19:48,166
to that installation to that project. You might

301
00:19:48,188 --> 00:19:51,606
be wondering if this API, these domains APIs of

302
00:19:51,628 --> 00:19:55,130
Versailles, has any limit. And if you haven't used this in the past,

303
00:19:55,200 --> 00:19:58,410
you probably have heard or faced the issue

304
00:19:58,480 --> 00:20:02,554
where there was a limit of the number of domains. You could point

305
00:20:02,672 --> 00:20:06,062
to a single Versaille project, but this is no longer the case.

306
00:20:06,116 --> 00:20:10,942
It's been almost two years now that this

307
00:20:10,996 --> 00:20:14,762
limit has been removed. So now you can use unlimited

308
00:20:14,826 --> 00:20:18,180
domains on a single project.

309
00:20:19,670 --> 00:20:23,454
All right, so here we can visually see what happens when a user

310
00:20:23,502 --> 00:20:27,166
makes a request to an application. The user

311
00:20:27,198 --> 00:20:30,434
will type the URL into their browser and then the browser

312
00:20:30,482 --> 00:20:34,146
will reach out to the DNS server over the Internet

313
00:20:34,258 --> 00:20:37,862
to find out which IP is linked to that

314
00:20:37,916 --> 00:20:41,366
web address. And then once it knows,

315
00:20:41,398 --> 00:20:45,814
the IP will do the request to the correct server.

316
00:20:45,942 --> 00:20:50,230
This is a very simplified overview

317
00:20:50,310 --> 00:20:54,210
of this process and we know it's in reality it's

318
00:20:54,230 --> 00:20:58,238
a bit more complex than this, but this illustration help us

319
00:20:58,324 --> 00:21:02,670
to understand the basic flow of this dense

320
00:21:03,730 --> 00:21:07,506
cool. But on a multitenant scenario we will

321
00:21:07,528 --> 00:21:11,780
end up with multiple domains resolving to the same ip address.

322
00:21:12,310 --> 00:21:16,194
And then once our application receives this traffic, we start

323
00:21:16,232 --> 00:21:20,386
questioning all right, so what tenants belongs

324
00:21:20,418 --> 00:21:23,894
to that domain? The domain of this request I

325
00:21:23,932 --> 00:21:27,254
just received and to solve this problem,

326
00:21:27,372 --> 00:21:30,614
we need to add some intelligence to our application to be

327
00:21:30,652 --> 00:21:35,222
able to resolve this information and tell what tenant belongs

328
00:21:35,366 --> 00:21:37,610
to that particular request.

329
00:21:38,990 --> 00:21:42,822
For this we use the nextjs

330
00:21:42,886 --> 00:21:46,126
middleware middleware. They allow you to

331
00:21:46,148 --> 00:21:48,906
run code before a request is completed.

332
00:21:49,018 --> 00:21:52,874
So this sits in front of your application, runs in the edge,

333
00:21:53,002 --> 00:21:57,170
and you can use it to modify

334
00:21:58,150 --> 00:22:01,662
the request and the response by doing, rewriting,

335
00:22:01,726 --> 00:22:05,650
redirecting or simply modifying the request headers.

336
00:22:06,470 --> 00:22:10,374
And here's an illustration of how we

337
00:22:10,412 --> 00:22:14,086
do this in Mercloud. So our middleware will be

338
00:22:14,108 --> 00:22:17,654
responsible to extract the host header of the

339
00:22:17,692 --> 00:22:21,006
request and then do a request

340
00:22:21,058 --> 00:22:24,506
to our API. And this API will do the

341
00:22:24,528 --> 00:22:28,186
lookup on that mapping table I showed you before.

342
00:22:28,368 --> 00:22:32,406
And once it knows what tenant that domain belongs

343
00:22:32,438 --> 00:22:36,090
to, we inject a header on that request.

344
00:22:36,170 --> 00:22:39,502
So now every time my application needs to know

345
00:22:39,556 --> 00:22:43,134
which tenant that request belongs to, all it needs to do is to check the

346
00:22:43,172 --> 00:22:47,346
header on the request. And this is how

347
00:22:47,528 --> 00:22:50,834
our middleware implementation looks like. You can see

348
00:22:50,872 --> 00:22:54,434
here that we extract the host of the request, we make

349
00:22:54,472 --> 00:22:58,878
that fetch request, and then if that result that succeeds

350
00:22:58,974 --> 00:23:03,534
we simply inject the tenant in the header

351
00:23:03,662 --> 00:23:07,350
online. 13 one of the questions that people

352
00:23:07,420 --> 00:23:11,582
usually ask about this is is it really performatic?

353
00:23:11,666 --> 00:23:15,430
Is a best practice to do fetch requests on middleware?

354
00:23:15,590 --> 00:23:19,482
Of course, everything you do here just

355
00:23:19,536 --> 00:23:22,890
adds to the latency of that response

356
00:23:23,410 --> 00:23:26,880
and something that we recommend here.

357
00:23:28,130 --> 00:23:32,394
If you're doing any API fetching requests

358
00:23:32,442 --> 00:23:36,314
here, you should be caching this response

359
00:23:36,442 --> 00:23:39,938
so you can use something like a key value store

360
00:23:40,024 --> 00:23:44,066
on the edge as well. So you only reach out to the

361
00:23:44,088 --> 00:23:47,666
real API if you don't have that information cache. So this

362
00:23:47,688 --> 00:23:51,320
is a good performance tip I can give you here.

363
00:23:53,770 --> 00:23:57,702
All right, and the next thing we had to think about was

364
00:23:57,836 --> 00:24:01,394
how to do the routing of our application. But first let's

365
00:24:01,442 --> 00:24:05,090
understand how the built in router of NextJs

366
00:24:05,170 --> 00:24:09,158
works. Next uses a file system based router

367
00:24:09,254 --> 00:24:12,870
where folders are used to define the routes,

368
00:24:13,030 --> 00:24:17,326
and files are used to create the UI that's shown for

369
00:24:17,348 --> 00:24:21,440
that route segments. We can also use some

370
00:24:22,130 --> 00:24:25,630
special notation to define dynamic route paths

371
00:24:26,070 --> 00:24:29,006
that are based on a path parameter.

372
00:24:29,198 --> 00:24:32,482
So as we can see here on the products,

373
00:24:32,616 --> 00:24:35,922
and once that is compiled you

374
00:24:35,976 --> 00:24:39,090
get nested routes with a path parameter.

375
00:24:39,590 --> 00:24:42,854
This router is pretty simple to use and allows us to

376
00:24:42,892 --> 00:24:46,534
do caching as well. And the way we can do

377
00:24:46,572 --> 00:24:50,166
caching is a user makes a request to

378
00:24:50,188 --> 00:24:54,298
a page and that gets rendered on the server side.

379
00:24:54,464 --> 00:24:57,754
And before we return this response to the

380
00:24:57,792 --> 00:25:02,086
user, we will cache that application, that response, that output.

381
00:25:02,198 --> 00:25:05,530
So the next time a request is made to that same URL,

382
00:25:05,610 --> 00:25:09,678
we can serve that cache content. So I

383
00:25:09,684 --> 00:25:13,134
don't need to regenerate the page. But here on

384
00:25:13,172 --> 00:25:16,630
the cloud we do something more sophisticated.

385
00:25:16,810 --> 00:25:20,510
It's called incremental static regeneration.

386
00:25:20,670 --> 00:25:24,146
The principle is pretty much the same, but you can also set a

387
00:25:24,168 --> 00:25:27,358
TTL on that cached response.

388
00:25:27,534 --> 00:25:31,094
So next time a user makes a request to that

389
00:25:31,132 --> 00:25:34,070
same URL and this TTL has expired,

390
00:25:34,890 --> 00:25:39,874
we will still serve that old stale version

391
00:25:39,922 --> 00:25:43,530
of the page built in the background. It will trigger a process

392
00:25:43,680 --> 00:25:47,222
that will refresh the cached

393
00:25:47,286 --> 00:25:50,826
content of the page. And next time a user comes and

394
00:25:50,848 --> 00:25:54,698
make a request to that same URL, then you'll

395
00:25:54,714 --> 00:25:57,982
be served with the new version. This works

396
00:25:58,036 --> 00:26:01,434
pretty cool, it's great. But let's bring this to the context

397
00:26:01,482 --> 00:26:05,230
of multitenancy. So I might have

398
00:26:05,300 --> 00:26:08,994
user one here that belongs to tenant a and you

399
00:26:09,032 --> 00:26:13,330
make that request, so you get served

400
00:26:14,230 --> 00:26:17,938
the old version of the page and the background process

401
00:26:18,024 --> 00:26:21,862
will be triggered. And now I have a user two that comes

402
00:26:21,916 --> 00:26:25,286
and access that same URL. And the

403
00:26:25,308 --> 00:26:28,854
question here, what version of the page will

404
00:26:28,892 --> 00:26:30,600
be served to user two?

405
00:26:33,070 --> 00:26:37,270
The answer here is user two will be served the version

406
00:26:37,350 --> 00:26:40,934
of the page that was generated for user one that belongs to tenant

407
00:26:40,982 --> 00:26:44,270
a, a different tenant. So this is

408
00:26:44,420 --> 00:26:49,886
not good, because now we're mixing content of two

409
00:26:49,908 --> 00:26:53,194
different tenants so they have private

410
00:26:53,242 --> 00:26:56,510
data, they shouldn't be shared, they should be isolated.

411
00:26:57,250 --> 00:27:00,626
But we having the risk here of sharing the

412
00:27:00,648 --> 00:27:03,570
wrong content of that page to the wrong user.

413
00:27:04,470 --> 00:27:08,580
How can we fix this issue? Is there a way to fix it?

414
00:27:09,770 --> 00:27:13,014
The first step here is to look again how we

415
00:27:13,052 --> 00:27:16,774
structure the routing and think, how could I

416
00:27:16,812 --> 00:27:21,022
make each route be tenant aware so it knows

417
00:27:21,186 --> 00:27:24,874
which tenant context it

418
00:27:24,912 --> 00:27:28,362
belongs to? And the solution here is

419
00:27:28,416 --> 00:27:32,598
to add a dynamic path segment

420
00:27:32,774 --> 00:27:36,538
to the very root of our router,

421
00:27:36,714 --> 00:27:40,110
so every route underneath it,

422
00:27:40,180 --> 00:27:42,750
it's under the context of that tenant.

423
00:27:43,250 --> 00:27:47,166
So now I can say that safe

424
00:27:47,198 --> 00:27:50,834
to cache any content, because even if a

425
00:27:50,872 --> 00:27:54,146
different tenant ends up with a

426
00:27:54,168 --> 00:27:56,370
request on the same URL,

427
00:27:58,070 --> 00:28:01,446
I know that my content is cached in a

428
00:28:01,468 --> 00:28:04,930
different path segment in a different context.

429
00:28:05,090 --> 00:28:08,514
So we will avoid mixing cached

430
00:28:08,562 --> 00:28:10,870
resources from multiple tenants.

431
00:28:12,410 --> 00:28:15,574
This is how this routing configuration will

432
00:28:15,612 --> 00:28:18,790
look like in the URL. We can clearly see that

433
00:28:18,860 --> 00:28:22,690
now that we're adding a new path parameter

434
00:28:22,770 --> 00:28:26,654
to a route. The tenant identification will

435
00:28:26,692 --> 00:28:30,240
be shown here. And this is not

436
00:28:30,610 --> 00:28:33,566
something we really want because remember,

437
00:28:33,668 --> 00:28:37,586
we giving our tenants the possibility to use their own domains on

438
00:28:37,608 --> 00:28:40,754
the platform. So why do we still need

439
00:28:40,792 --> 00:28:44,590
to identify put an identification

440
00:28:44,750 --> 00:28:48,786
on the URL? For sure we can improve this. There is quite

441
00:28:48,808 --> 00:28:53,126
a long discussion about this topic on the next Js GitHub that

442
00:28:53,228 --> 00:28:56,726
took quite a while to get an official answer on how to

443
00:28:56,748 --> 00:28:59,878
solve this, and the recommendation is to use

444
00:28:59,964 --> 00:29:03,834
some sort of identification on the route, like how

445
00:29:03,872 --> 00:29:08,262
we did. And here on this example they're suggesting

446
00:29:08,326 --> 00:29:11,850
you to use the hostname of that request.

447
00:29:12,590 --> 00:29:15,914
And this does exactly the same way we

448
00:29:15,952 --> 00:29:20,338
do with the tenant. But here they using the hostname

449
00:29:20,534 --> 00:29:23,774
of the request. It works exactly the same

450
00:29:23,812 --> 00:29:27,282
way because it's a unique identifier for each

451
00:29:27,336 --> 00:29:30,466
tenant. And also yes,

452
00:29:30,648 --> 00:29:33,874
you see that on that thread that they mentioned that this

453
00:29:33,912 --> 00:29:37,278
will be reflected, this will be shown on the URL,

454
00:29:37,454 --> 00:29:40,566
but luckily there is a solution for that. We can

455
00:29:40,588 --> 00:29:43,960
use URL rewrites to handle that dirt job.

456
00:29:44,730 --> 00:29:48,822
So the rewrite will be responsible for adding that

457
00:29:48,876 --> 00:29:53,066
identifier to the router, but we will also mask the

458
00:29:53,088 --> 00:29:55,846
URL that's presented to the user.

459
00:29:55,878 --> 00:29:59,414
So the request is still routed

460
00:29:59,462 --> 00:30:02,762
to the correct segment, but it's simply not

461
00:30:02,816 --> 00:30:06,542
shown on the browser for the user. The way you can do

462
00:30:06,596 --> 00:30:10,986
URL rewrites in nextjs is by setting

463
00:30:11,018 --> 00:30:14,442
these rules on your next config

464
00:30:14,506 --> 00:30:18,558
file, or you can also use midos

465
00:30:18,734 --> 00:30:22,498
to do that if you want. And after we

466
00:30:22,584 --> 00:30:26,462
apply these changes, the rewrite changes. Here are the results.

467
00:30:26,526 --> 00:30:30,882
So we no longer have the tenant identification

468
00:30:31,026 --> 00:30:36,534
on the URL path, but the

469
00:30:36,572 --> 00:30:40,790
request still being routed to the correct path segment.

470
00:30:41,550 --> 00:30:44,938
I've prepared a quick demo here to show you this working,

471
00:30:45,024 --> 00:30:48,218
so let's hope everything works

472
00:30:48,304 --> 00:30:48,940
fine.

473
00:30:50,830 --> 00:30:54,060
So let me change my screen.

474
00:30:55,570 --> 00:30:59,134
So we have a repo here with

475
00:30:59,172 --> 00:31:02,080
a very simple nextjs application.

476
00:31:03,250 --> 00:31:06,850
You can see here in our router we have that

477
00:31:06,920 --> 00:31:10,926
dynamic route that represents the tenant,

478
00:31:11,118 --> 00:31:15,346
and we have a page here. And all this page

479
00:31:15,448 --> 00:31:19,382
does is it makes a request to this time

480
00:31:19,436 --> 00:31:23,560
API that will return us what the current time is.

481
00:31:23,930 --> 00:31:27,526
And you'll print this on the screen.

482
00:31:27,708 --> 00:31:31,642
So we'll print hello, we'll say

483
00:31:31,696 --> 00:31:35,514
which tenant that

484
00:31:35,712 --> 00:31:38,986
session is and we'll print what time this page has

485
00:31:39,008 --> 00:31:42,262
been generated. We also have a middleware

486
00:31:42,326 --> 00:31:46,578
here where based on the host header

487
00:31:46,614 --> 00:31:50,174
of that request, we identify which tenant is.

488
00:31:50,292 --> 00:31:53,566
So this is a very dummy example here. I'm just checking if we

489
00:31:53,588 --> 00:31:56,846
have tenant a or B, and then we're setting it,

490
00:31:57,028 --> 00:32:00,642
and otherwise if it can resolve that we'll just set

491
00:32:00,696 --> 00:32:04,418
as a default tenant. And also in

492
00:32:04,504 --> 00:32:07,922
our next config file we have

493
00:32:07,976 --> 00:32:11,510
the rewrite rules for it.

494
00:32:11,580 --> 00:32:15,590
So you can see here that we get pretty much

495
00:32:15,660 --> 00:32:19,880
anything on the request and then we'll proxy that

496
00:32:20,250 --> 00:32:23,914
to a tenant path and the

497
00:32:23,952 --> 00:32:27,450
tenant will be extracted by this header,

498
00:32:27,950 --> 00:32:31,498
the x tenant. And this is exactly

499
00:32:31,584 --> 00:32:35,454
the header we're setting here. So if

500
00:32:35,492 --> 00:32:39,646
I run this application now running

501
00:32:39,748 --> 00:32:43,470
and I go to my browser and I do localhost,

502
00:32:44,210 --> 00:32:47,698
you can see here that, okay, I got a hello word,

503
00:32:47,784 --> 00:32:51,474
the default tenant and the

504
00:32:51,512 --> 00:32:54,830
date and time that this page has been generated.

505
00:32:54,910 --> 00:32:58,466
And if I refresh, you can see the time is

506
00:32:58,488 --> 00:33:02,530
not refreshing. So this proves that I'm serving that cached version.

507
00:33:05,690 --> 00:33:08,982
But how can I identify multiple tenants here

508
00:33:09,036 --> 00:33:13,082
based on a domain if I'm using running

509
00:33:13,136 --> 00:33:16,294
this on localhost? So what I've

510
00:33:16,342 --> 00:33:19,898
done here on my machine, I created two

511
00:33:19,984 --> 00:33:23,322
local domains that they point to local

512
00:33:23,376 --> 00:33:26,910
host, so I can use them to simulate

513
00:33:28,610 --> 00:33:32,366
other domains. So if I access that,

514
00:33:32,548 --> 00:33:36,298
my application, okay, I forgot to

515
00:33:36,324 --> 00:33:40,290
set a port. All right, so you can see here that

516
00:33:40,360 --> 00:33:43,742
now it's able to identify which tenant

517
00:33:43,806 --> 00:33:46,610
that request belongs to, the domain,

518
00:33:46,950 --> 00:33:50,610
and the time that page was generated.

519
00:33:50,770 --> 00:33:54,342
And then if I do this the same with the other

520
00:33:54,396 --> 00:33:58,118
tenant, you see now that I have tenant b

521
00:33:58,284 --> 00:34:02,186
and this is the time that the page was generated. So you

522
00:34:02,208 --> 00:34:06,118
can see here for each of the tenants, including the default,

523
00:34:06,214 --> 00:34:10,010
it's a different time that the page was generating.

524
00:34:10,750 --> 00:34:14,398
And if I keep refreshing this, I'm getting

525
00:34:14,484 --> 00:34:18,174
served that cache version of the

526
00:34:18,212 --> 00:34:21,950
page. And on this

527
00:34:22,100 --> 00:34:23,600
solution as well,

528
00:34:25,570 --> 00:34:29,134
we setting a TTL of 60 seconds.

529
00:34:29,182 --> 00:34:33,010
So if I come back to this page after 60 seconds

530
00:34:33,990 --> 00:34:37,374
and do a request, that background

531
00:34:37,422 --> 00:34:40,854
process of regenerating the page will be

532
00:34:40,892 --> 00:34:43,718
triggered. And then if I refresh the browser again,

533
00:34:43,804 --> 00:34:47,254
I'll get a new version of this page.

534
00:34:47,372 --> 00:34:50,898
And it's what happened here with the first request we

535
00:34:50,924 --> 00:34:53,660
can see that it just got updated again.

536
00:34:55,470 --> 00:35:01,306
All right, so that was the demo. And this

537
00:35:01,328 --> 00:35:04,606
is a public repo. You can find it on

538
00:35:04,628 --> 00:35:07,966
this URL or QR code and you can use

539
00:35:07,988 --> 00:35:11,566
it to create a multitenant application as a template to

540
00:35:11,588 --> 00:35:15,440
create this kind of application.

541
00:35:15,810 --> 00:35:19,666
And there you'll find two branches on

542
00:35:19,688 --> 00:35:23,570
this repo. The one I showed you is called using

543
00:35:23,640 --> 00:35:27,330
middleware. So we solve this problem

544
00:35:27,400 --> 00:35:31,478
by using the middleware like we do at Mercloud, but you also have

545
00:35:31,564 --> 00:35:35,222
on the main branch you find a solution where we

546
00:35:35,356 --> 00:35:38,806
simply use the host header of

547
00:35:38,828 --> 00:35:42,106
the request and identify different tenants. So we don't need a

548
00:35:42,128 --> 00:35:45,626
middleware there. Feel free to use

549
00:35:45,808 --> 00:35:49,782
this repo and raise any pull requests of improvements.

550
00:35:49,846 --> 00:35:53,770
If you have any contribution will be very appreciated.

551
00:35:54,530 --> 00:35:58,078
All right, but if today you do a research

552
00:35:58,164 --> 00:36:01,520
on how to built a multi tenant application on NextJs,

553
00:36:01,890 --> 00:36:05,466
we'll quickly hear about the Versailles platform starter

554
00:36:05,498 --> 00:36:09,246
kit. It's a template for a

555
00:36:09,268 --> 00:36:13,282
full stack next js application with multi tenancy and

556
00:36:13,336 --> 00:36:16,994
custom domain support. This is great,

557
00:36:17,112 --> 00:36:20,520
but well, a bit too late for us.

558
00:36:21,610 --> 00:36:25,122
When this came out we had implemented

559
00:36:25,186 --> 00:36:28,646
our solution, but even though we said okay,

560
00:36:28,828 --> 00:36:32,586
let's check it out and see how they implement it and how

561
00:36:32,608 --> 00:36:36,154
they solve these problems we had. And then we

562
00:36:36,192 --> 00:36:39,734
found out that they do the domain

563
00:36:39,782 --> 00:36:41,050
based routing.

564
00:36:42,590 --> 00:36:46,186
That's pretty much what we do with the tenant.

565
00:36:46,298 --> 00:36:49,866
Slightly different way they do URL

566
00:36:49,898 --> 00:36:53,470
rewrite using the middleware. We use the

567
00:36:53,540 --> 00:36:57,006
next config file for that. And one

568
00:36:57,028 --> 00:37:00,514
of the reasons we don't use middleware for that is

569
00:37:00,552 --> 00:37:04,260
that the first iteration of this application,

570
00:37:05,430 --> 00:37:09,614
we made it with next ten version

571
00:37:09,662 --> 00:37:13,382
ten midos weren't a thing yet.

572
00:37:13,516 --> 00:37:17,910
So once we migrated to the latest version of NextJs,

573
00:37:18,570 --> 00:37:22,230
we didn't bother refactoring this part of the rewrite.

574
00:37:22,590 --> 00:37:26,426
That's the main reason why we don't use middleware. And we

575
00:37:26,448 --> 00:37:30,294
found out on this solution that they also use the Versailles domains API.

576
00:37:30,422 --> 00:37:33,900
So we're pretty happy and

577
00:37:34,210 --> 00:37:37,658
we thought, okay, we did a great job here. We didn't

578
00:37:37,754 --> 00:37:41,870
do anything that was completely different from their solution

579
00:37:42,530 --> 00:37:47,022
and where we landed. So this is a high overview

580
00:37:47,086 --> 00:37:50,674
of our architecture today. So you can see that the front

581
00:37:50,712 --> 00:37:54,660
end is hosted on the Versaille infrastructure where

582
00:37:55,670 --> 00:37:59,746
we didn't cover on this talk, but we handle authentication with

583
00:37:59,928 --> 00:38:03,910
off zero and the middleware talks to

584
00:38:03,980 --> 00:38:07,494
our API on the back end. We have everything hosted on

585
00:38:07,532 --> 00:38:11,962
AWS, but we

586
00:38:12,016 --> 00:38:15,802
have multiple versions of this API hosted in different

587
00:38:15,936 --> 00:38:19,414
regions. That's for compliance and data isolation

588
00:38:19,462 --> 00:38:24,190
for our customers. But we have one API,

589
00:38:24,690 --> 00:38:29,130
that's the tenant API that runs on a global region, and that's the API

590
00:38:29,290 --> 00:38:33,374
that the midower uses in order to

591
00:38:33,412 --> 00:38:37,326
do the correlation between the host header

592
00:38:37,358 --> 00:38:40,866
of a request, the domain of that request, and do

593
00:38:40,888 --> 00:38:45,010
the mapping with attendance. All right, the outcomes of

594
00:38:45,080 --> 00:38:49,346
our implementation we got great improvements in performance.

595
00:38:49,538 --> 00:38:53,506
We're taking advantage of the edge networking

596
00:38:53,618 --> 00:38:55,670
and the CDN caching.

597
00:38:56,810 --> 00:39:01,030
Also because we're running on the edge now, we reduce a lot the latency

598
00:39:01,390 --> 00:39:05,594
so the servers are much closer to our users. We also

599
00:39:05,632 --> 00:39:08,314
increase the agility of our dev team.

600
00:39:08,432 --> 00:39:12,150
We no longer need to maintain a very compliant infrastructure

601
00:39:12,230 --> 00:39:16,158
and multiple deployment pipelines. It's much easier today

602
00:39:16,244 --> 00:39:19,518
for us to build and release new features without

603
00:39:19,604 --> 00:39:23,742
any overhead. And today is also much

604
00:39:23,796 --> 00:39:27,934
easier for us to onboard new tenants and this process is fully

605
00:39:27,982 --> 00:39:31,586
automated. All we need to do is add

606
00:39:31,688 --> 00:39:34,910
a record to an admin

607
00:39:34,990 --> 00:39:39,142
system. We had that and automatically we just

608
00:39:39,276 --> 00:39:42,470
create all the resources required for that tenant.

609
00:39:45,370 --> 00:39:49,160
And the lessons learned from this journey for us was

610
00:39:49,530 --> 00:39:53,034
the first one. Always look

611
00:39:53,072 --> 00:39:56,234
into adapting tools and technologies that will help you

612
00:39:56,272 --> 00:39:59,850
to focus on business value rather than

613
00:39:59,920 --> 00:40:04,080
having to spend days, weeks of

614
00:40:04,690 --> 00:40:08,254
the time in the beginning of the project just to set up

615
00:40:08,292 --> 00:40:12,554
a very complex infrastructure and structure

616
00:40:12,602 --> 00:40:16,074
of your code. Look into adapting these

617
00:40:16,132 --> 00:40:19,922
tools that with very minimal effort will

618
00:40:19,976 --> 00:40:23,454
allow you to jump straight into coding

619
00:40:23,502 --> 00:40:27,380
and you can easily deploy them.

620
00:40:27,990 --> 00:40:31,474
Also, think about your users,

621
00:40:31,522 --> 00:40:35,874
they want the best. Experience and performance

622
00:40:35,922 --> 00:40:39,640
is the main thing you need to consider to achieve this.

623
00:40:40,010 --> 00:40:43,226
You want to serve pages as fast as possible to your

624
00:40:43,248 --> 00:40:46,954
users. And for this you need to take advantage of

625
00:40:46,992 --> 00:40:50,810
things like gen stack and incremental static generation

626
00:40:51,230 --> 00:40:55,222
like we do here, mercloud. And just be careful

627
00:40:55,286 --> 00:40:58,542
about server side rendering. Anything you do that will

628
00:40:58,596 --> 00:41:02,702
slow your page load because it needs to be re

629
00:41:02,756 --> 00:41:06,354
executed on every request. And this will

630
00:41:06,392 --> 00:41:09,682
make much difficult, much more difficult for you to

631
00:41:09,736 --> 00:41:13,138
cache the response. Also,

632
00:41:13,224 --> 00:41:16,834
observability, it's a must and it

633
00:41:16,872 --> 00:41:20,950
also needs to be tenant aware. So create

634
00:41:21,020 --> 00:41:24,262
consumption metrics that will help

635
00:41:24,316 --> 00:41:28,034
you to identify who's

636
00:41:28,082 --> 00:41:31,882
using what and how much of that are they using.

637
00:41:32,016 --> 00:41:35,114
So when you're monitoring the health of your application, you can

638
00:41:35,152 --> 00:41:38,490
easily identify who's using more resources.

639
00:41:38,830 --> 00:41:42,010
And remember, each tenant

640
00:41:43,310 --> 00:41:46,842
you on board will bring with them a different Persona

641
00:41:46,986 --> 00:41:50,734
and also different usage patterns. So you

642
00:41:50,772 --> 00:41:54,606
have very small tenants that

643
00:41:54,708 --> 00:41:56,820
they don't require much,

644
00:41:57,990 --> 00:42:01,538
but you also have big ones that will bring

645
00:42:01,624 --> 00:42:05,634
a huge demand to your application. So you want

646
00:42:05,672 --> 00:42:08,802
to easily identify who the noisy tenants are.

647
00:42:08,856 --> 00:42:13,160
Let's say one of your tenants is going under a DDoS attack

648
00:42:13,610 --> 00:42:17,654
and suddenly the performance of your whole application is

649
00:42:17,692 --> 00:42:20,878
being impacted. And this is impacting other tenants.

650
00:42:20,994 --> 00:42:23,994
So you want to identify who the noisy tenants are there.

651
00:42:24,032 --> 00:42:28,282
So you can quickly identify and mitigate any

652
00:42:28,336 --> 00:42:31,260
bottlenecks that are being caused by them.

653
00:42:31,790 --> 00:42:35,630
And also to wrap it up. A very important

654
00:42:35,780 --> 00:42:39,342
recommendation we can give you is don't do early

655
00:42:39,396 --> 00:42:42,734
optimization. You probably get it wrong and you

656
00:42:42,772 --> 00:42:44,480
have to redo it later.

657
00:42:45,910 --> 00:42:49,922
Use metrics to drive it. So first have

658
00:42:49,976 --> 00:42:53,314
the problem, and then the metrics will tell

659
00:42:53,352 --> 00:42:56,882
you where your problems are, where your bottlenecks are,

660
00:42:57,016 --> 00:43:00,774
and then you can use this information to attack the

661
00:43:00,812 --> 00:43:04,470
problem once you have it, instead of trying to

662
00:43:04,540 --> 00:43:07,480
guess what your future problems will be.

663
00:43:08,730 --> 00:43:12,774
Yes, and that's the end

664
00:43:12,812 --> 00:43:16,706
of the session today. Hope you have enjoyed.

665
00:43:16,818 --> 00:43:20,694
Please feel free to reach out to me on my social media and

666
00:43:20,732 --> 00:43:24,094
also check our website at Mercloud IO. Thank you very

667
00:43:24,132 --> 00:43:26,078
much. It was a pleasure to share this with you.

