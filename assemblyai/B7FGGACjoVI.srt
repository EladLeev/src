1
00:00:38,930 --> 00:00:42,178
Hello everyone, and welcome to this talk. The MariaDB evolution,

2
00:00:42,354 --> 00:00:46,134
is it just a fork of MySQL? Well, spoiler alert, it is not.

3
00:00:46,172 --> 00:00:49,998
It's a bit more than that. My name is Alejandro Duarte and I work in

4
00:00:50,044 --> 00:00:53,278
developer relations for MariaDB plc. I'm a

5
00:00:53,284 --> 00:00:56,542
software engineer. I have been writing code for almost 30 years,

6
00:00:56,596 --> 00:01:00,510
I believe, and I published these three books about web

7
00:01:00,580 --> 00:01:03,706
development with Java and a framework called Vidin,

8
00:01:03,738 --> 00:01:07,122
which is very, very interesting. But I'm working on a new book right now

9
00:01:07,176 --> 00:01:10,530
called MariaDB for developers. So if you're interested,

10
00:01:10,680 --> 00:01:14,238
take the screenshot of these and you'll get a notification

11
00:01:14,334 --> 00:01:18,386
when the book becomes available. But today we're going to talk about the MariaDB

12
00:01:18,498 --> 00:01:21,846
ecosystem, the clion ecosystem. So we're going to see

13
00:01:21,868 --> 00:01:25,714
the historical context in which both MySQL and MariaDB were born.

14
00:01:25,762 --> 00:01:28,642
We're going to also talk about storage engines,

15
00:01:28,706 --> 00:01:32,534
right? So a bit more technical stuff. We're going to talk about MariaDB

16
00:01:32,582 --> 00:01:35,894
Enterprise because that's what you want to use when you move to production,

17
00:01:36,022 --> 00:01:39,690
especially if you want to automate things such as failovers.

18
00:01:40,270 --> 00:01:44,682
We are going to briefly touch also on the present and future of MariaDB

19
00:01:44,746 --> 00:01:48,746
and migration. And who uses MariadB. Okay, so let's

20
00:01:48,778 --> 00:01:52,478
start with the history of relational databases, and it's going to

21
00:01:52,484 --> 00:01:56,290
be very brief. So it all

22
00:01:56,360 --> 00:02:00,222
started in the 60s with General Electric and the integrated

23
00:02:00,286 --> 00:02:03,906
data store ids. That's the very first database we know of.

24
00:02:04,008 --> 00:02:07,766
It is not a relational database, it's another kind of database. But that was

25
00:02:07,788 --> 00:02:11,414
the very first one. And that led to the development of something

26
00:02:11,452 --> 00:02:14,882
called the Codasil database model, which basically were extensions

27
00:02:14,946 --> 00:02:18,102
to the cobalt programming languages so that developers

28
00:02:18,166 --> 00:02:22,166
can query the databases using nested loops

29
00:02:22,198 --> 00:02:25,802
and pointers. So they need to think about data

30
00:02:25,856 --> 00:02:29,514
structures, algorithms, all this kind of stuff. That means they

31
00:02:29,552 --> 00:02:33,530
have to rewrite this codasil code on every schema

32
00:02:33,610 --> 00:02:37,310
change. So Edgar code realizes this

33
00:02:37,460 --> 00:02:41,440
and proposes the relational model, which is

34
00:02:42,050 --> 00:02:46,014
oversimplifying, is like tables. So you have columns

35
00:02:46,062 --> 00:02:49,870
and then you have rows. That's what the modern database

36
00:02:49,950 --> 00:02:53,470
use. And he was a mathematician, so he formalized

37
00:02:53,550 --> 00:02:57,906
these through something called relational calculus and relational algebra,

38
00:02:57,938 --> 00:03:00,662
which is what actually database use.

39
00:03:00,716 --> 00:03:04,562
Although modern databases, they are not just purely relational

40
00:03:04,706 --> 00:03:08,618
algebra based, they have some more concepts there.

41
00:03:08,704 --> 00:03:13,226
But this is the basis. All right? And these

42
00:03:13,248 --> 00:03:16,794
kind of theories allows you to demonstrate that it is possible to

43
00:03:16,832 --> 00:03:20,382
build query optimizers. And yes, they build also

44
00:03:20,436 --> 00:03:24,094
these query optimizers that all relational databases have.

45
00:03:24,212 --> 00:03:28,106
And a database, it contains tons

46
00:03:28,138 --> 00:03:32,014
of algorithms and data structures, right? Like trees and hash tables and so

47
00:03:32,052 --> 00:03:35,266
forth. And it knows your data, so it

48
00:03:35,288 --> 00:03:38,802
can make very, very good decisions on the

49
00:03:38,856 --> 00:03:42,382
plan to access that data on disk.

50
00:03:42,526 --> 00:03:46,280
Much better than what a programmer would be able to do.

51
00:03:46,890 --> 00:03:50,774
Now all these is theory until the first implementations start

52
00:03:50,812 --> 00:03:54,054
to appear. So more or less at the mid

53
00:03:54,092 --> 00:03:57,506
of the 70s in IBM, for example,

54
00:03:57,628 --> 00:04:01,850
CSMR, which more than a product is a project,

55
00:04:02,000 --> 00:04:05,638
it's a research project investigating,

56
00:04:05,734 --> 00:04:09,660
researching databases. So they started to implement these,

57
00:04:10,210 --> 00:04:14,282
to experiment with these ingress in the University of California,

58
00:04:14,346 --> 00:04:16,510
the precursor of PostgreSQL,

59
00:04:17,730 --> 00:04:21,566
Oracle very famous database Mimer, another academic project

60
00:04:21,668 --> 00:04:25,010
in Sweden, the University of Upsala, I believe.

61
00:04:25,160 --> 00:04:29,314
And the predominant query language was

62
00:04:29,432 --> 00:04:32,882
called QL. So let's try to remember this

63
00:04:32,936 --> 00:04:36,614
word there, QL, that is querying using the

64
00:04:36,652 --> 00:04:39,734
english language, all right? That was the main language there.

65
00:04:39,852 --> 00:04:43,222
Now later at the end, by end of 70s,

66
00:04:43,276 --> 00:04:45,800
maybe at the beginning of the 80s,

67
00:04:49,050 --> 00:04:52,586
through the years, don't pay too much attention of the exact location of

68
00:04:52,608 --> 00:04:54,490
this vertical line in the timeline.

69
00:04:56,670 --> 00:04:59,786
The scientists at IBM and the researchers and

70
00:04:59,808 --> 00:05:03,374
programmers at IBM started to think

71
00:05:03,412 --> 00:05:07,390
about what would be the best way to query

72
00:05:08,770 --> 00:05:12,506
databases. Relational databases. So what's the best way

73
00:05:12,548 --> 00:05:16,418
to specify queries using a

74
00:05:16,504 --> 00:05:20,254
relational environment? That's what square stands

75
00:05:20,302 --> 00:05:23,922
for. And more than a language, it was kind of a game

76
00:05:23,976 --> 00:05:27,234
they had. Like I said before, they are trying to figure out, hey, I found

77
00:05:27,272 --> 00:05:30,870
out this way, maybe I come up with this idea how we can

78
00:05:30,940 --> 00:05:34,210
combine these and yeah, maybe it was also a language

79
00:05:34,370 --> 00:05:37,890
but they were using this scientific notation, right? So it's subindices

80
00:05:37,970 --> 00:05:41,830
and super indices. This is hard to introduce in a keyboard,

81
00:05:41,910 --> 00:05:45,834
computer keyboard. So they redefine these and create something

82
00:05:45,872 --> 00:05:49,126
called SQL, which is the SQL of Quill, right. So they are playing

83
00:05:49,158 --> 00:05:52,786
with the words, this is like an improved version of Quill.

84
00:05:52,838 --> 00:05:56,814
Maybe they named it like that. Now this

85
00:05:56,852 --> 00:06:00,110
can be implemented and used in computers. However,

86
00:06:00,260 --> 00:06:04,098
SQL was a trademark in some company in

87
00:06:04,104 --> 00:06:07,442
the UK, I think it was some aircraft related company.

88
00:06:07,576 --> 00:06:11,282
So they cannot use his name, but they removed the vowels in this

89
00:06:11,336 --> 00:06:14,546
word and well, SQL is

90
00:06:14,568 --> 00:06:18,034
born. So even though it is spelled as SQL,

91
00:06:18,162 --> 00:06:21,506
you still pronounce it SQL. We still pronounce it SQL.

92
00:06:21,618 --> 00:06:25,414
Some of us, some pronounce it SQL. It doesn't really

93
00:06:25,452 --> 00:06:28,602
matter. It is here today. It's the

94
00:06:28,656 --> 00:06:32,426
best. It's not perfect, but so far nobody has come

95
00:06:32,448 --> 00:06:35,450
up with a better language than SQL.

96
00:06:35,790 --> 00:06:38,666
Now IBM DB two,

97
00:06:38,688 --> 00:06:42,400
Oracle and database, the main database in the market started to

98
00:06:42,930 --> 00:06:46,714
adopt this language, SQL, and it became

99
00:06:46,842 --> 00:06:50,974
a standard. I believe in 1986 or seven or

100
00:06:51,012 --> 00:06:54,190
around those two years, NC and ISO.

101
00:06:54,350 --> 00:06:58,018
Now to give you some bit of a perspective on what's going on

102
00:06:58,024 --> 00:07:01,474
in the industry, by the late 80s,

103
00:07:01,592 --> 00:07:04,594
open source is pretty well established with,

104
00:07:04,632 --> 00:07:07,826
for example, the Gunu project. They created

105
00:07:07,858 --> 00:07:09,990
something called the General Public License,

106
00:07:11,130 --> 00:07:15,190
which means that if you release a software with the GPL,

107
00:07:15,530 --> 00:07:19,170
you have to provide also the source code

108
00:07:19,260 --> 00:07:22,346
and people can modify it, but if they modify it,

109
00:07:22,448 --> 00:07:25,718
they have also to publish that source code. So it's

110
00:07:25,734 --> 00:07:29,750
like the source code is going to be available always.

111
00:07:29,920 --> 00:07:33,226
That's the GPL. Now Linux is being developed here in Finland

112
00:07:33,258 --> 00:07:36,766
by Linux Torbox. It was published at some

113
00:07:36,788 --> 00:07:38,990
point under the GPL.

114
00:07:39,570 --> 00:07:41,754
Postgres in the University of California,

115
00:07:41,802 --> 00:07:45,794
Berkeley is the academic project trying

116
00:07:45,832 --> 00:07:48,638
to build this relational database is under development.

117
00:07:48,734 --> 00:07:52,626
Unfortunately, it doesn't use

118
00:07:52,648 --> 00:07:57,990
the GPL. It is still open source and it's a very permissive

119
00:07:58,570 --> 00:08:02,242
license. However, there are no free SQL

120
00:08:02,306 --> 00:08:06,370
databases because postgres wasn't designed to support SQL.

121
00:08:06,530 --> 00:08:10,426
This changes with the very first free SQL database that

122
00:08:10,448 --> 00:08:13,050
was called MySQL or mini SQL.

123
00:08:14,510 --> 00:08:17,994
It offered better performance than postgresgres and

124
00:08:18,032 --> 00:08:21,450
SQL. It is still in use in embedded devices.

125
00:08:21,530 --> 00:08:25,134
In fact, the latest version was published well

126
00:08:25,172 --> 00:08:29,120
that date. So it's not very active in development where it's still in use.

127
00:08:29,730 --> 00:08:33,742
However, there's no open source SQL database

128
00:08:33,806 --> 00:08:36,814
because this one, yeah, you can use SQL,

129
00:08:36,862 --> 00:08:40,114
but you cannot see the source code, so you have that option.

130
00:08:40,232 --> 00:08:44,002
This changes with MySQL and its

131
00:08:44,056 --> 00:08:47,522
creator, Mikael Videnio. So he was working

132
00:08:47,576 --> 00:08:51,094
with his company and his colleagues and he wanted just know, provide good

133
00:08:51,132 --> 00:08:54,694
services and good products to his customers.

134
00:08:54,892 --> 00:08:58,150
And he created something called Unirec to manage databases.

135
00:08:58,230 --> 00:09:02,278
And on top of that, he started to develop its own SQL

136
00:09:02,374 --> 00:09:06,298
layer, so to speak. And later they called it

137
00:09:06,384 --> 00:09:10,460
MySQL and published the source code,

138
00:09:12,430 --> 00:09:16,014
opened the source code. It's a very fast database. He wanted

139
00:09:16,052 --> 00:09:19,854
a very fast database performant, easy to use.

140
00:09:20,052 --> 00:09:23,562
Two things that you can still see today on MySQL,

141
00:09:23,626 --> 00:09:27,166
in MySQL and MariaDB. Yeah, then in

142
00:09:27,188 --> 00:09:30,706
the 90s it had its limitations, but it turned out to

143
00:09:30,728 --> 00:09:33,646
be a great fit for a website. So we can say that it helped shape

144
00:09:33,678 --> 00:09:37,206
the Internet as we know it today. And it was released at some

145
00:09:37,228 --> 00:09:41,314
point under the GPL license. That means it cannot be closed

146
00:09:41,362 --> 00:09:44,918
again. So MySQL gains popularity very quickly in

147
00:09:44,924 --> 00:09:48,738
the next decade. A company called Inobase

148
00:09:48,834 --> 00:09:52,794
produces or develops this module for MySQL. Let's call it

149
00:09:52,832 --> 00:09:56,614
like that module, Enodbeam, that solves

150
00:09:56,662 --> 00:10:00,678
the limitations and a company is created

151
00:10:00,854 --> 00:10:04,406
to write services and that kind of stuff. But then Oracle

152
00:10:04,438 --> 00:10:07,902
buys Inobase, which is like I said, employs the

153
00:10:07,956 --> 00:10:11,694
developers who are writing the code for

154
00:10:11,732 --> 00:10:15,170
EnodB. Oracle bought that, okay,

155
00:10:15,320 --> 00:10:18,594
that was in 2005. Then later Sun

156
00:10:18,632 --> 00:10:21,758
Microsystems buys MySQL,

157
00:10:21,854 --> 00:10:24,466
the company MySQL Finland AB in 2008.

158
00:10:24,488 --> 00:10:28,486
And then I guess some of you remember what happened

159
00:10:28,588 --> 00:10:32,102
next or kind of guess where this is going.

160
00:10:32,236 --> 00:10:35,010
Oracle buys Sun Microsystems.

161
00:10:35,170 --> 00:10:38,326
So that was announced in 2009 and effective in

162
00:10:38,348 --> 00:10:41,706
2010, I believe in January or something like that.

163
00:10:41,888 --> 00:10:45,526
And now Oracle at this point owns not only the Oracle database,

164
00:10:45,558 --> 00:10:49,002
which is the most successful commercial database, but also

165
00:10:49,056 --> 00:10:52,058
the most popular open source database, MySQL.

166
00:10:52,234 --> 00:10:56,330
So the community and especially Mikhail Vidanius

167
00:10:56,410 --> 00:11:00,506
realizes that this is our risk for the project, for MySQL,

168
00:11:00,698 --> 00:11:04,634
and at least there could be some conflict of interests,

169
00:11:04,762 --> 00:11:07,934
right? That's just natural. And this

170
00:11:07,972 --> 00:11:11,810
could maybe even hide the project or maybe stop

171
00:11:11,880 --> 00:11:15,118
innovation or reduce it. I'm not going to be the judge of that, but I'm

172
00:11:15,134 --> 00:11:20,310
going to show you this conversation also on the official MySQL

173
00:11:22,010 --> 00:11:25,654
community, slack whatever. I didn't see

174
00:11:25,692 --> 00:11:29,786
much innovation in the 8.1 innovation release notes there

175
00:11:29,808 --> 00:11:33,574
are plenty of deprecations. Is that the new definition of innovation

176
00:11:33,622 --> 00:11:37,574
at Oracle? Well, of course they are joking and I'll let you decide

177
00:11:37,622 --> 00:11:42,030
where there is truth in these jokes.

178
00:11:42,530 --> 00:11:46,174
Props to Oracle because the project is still alive and they are still

179
00:11:46,212 --> 00:11:49,120
innovating. I'm not sure how much though,

180
00:11:50,050 --> 00:11:52,190
but the project is alive.

181
00:11:53,750 --> 00:11:57,522
However, Michael Vineyards forks this code. That is,

182
00:11:57,576 --> 00:12:02,846
he takes the code and copies and publish it somewhere

183
00:12:02,878 --> 00:12:05,942
else in another repository and creates a new project.

184
00:12:06,076 --> 00:12:09,106
And many of the developers of MySQL,

185
00:12:09,138 --> 00:12:12,294
the original developers of MySQL, then they moved to this new

186
00:12:12,332 --> 00:12:16,182
project, to Mariadb. Right, so that's how

187
00:12:16,236 --> 00:12:20,098
MariaDb was born, as a fork of MySQL. Indeed, it was a

188
00:12:20,124 --> 00:12:24,006
fork of MySQL and it was supposed to be a drop pin replacement for MySQL

189
00:12:24,038 --> 00:12:26,378
and it was for some time.

190
00:12:26,464 --> 00:12:29,734
Nowadays, let's say they are highly compatible.

191
00:12:29,782 --> 00:12:33,790
There are not two other database that are as compatible as MySQL and MariaDb.

192
00:12:34,450 --> 00:12:37,566
However, projects have diverged. Right. And as

193
00:12:37,588 --> 00:12:41,040
you can see, the way I see it at least is that

194
00:12:42,930 --> 00:12:46,434
these are the guys who built MySQL. They are working now

195
00:12:46,552 --> 00:12:50,146
with Mariadb. So it's more like a change in the name and

196
00:12:50,168 --> 00:12:53,538
then the other company continue to keep the name and obviously some of

197
00:12:53,544 --> 00:12:57,506
the developers and stuff and both projects benefit

198
00:12:57,538 --> 00:13:01,254
from each other, I would say at the development level

199
00:13:01,372 --> 00:13:05,960
anyway, the first release was Mariadb 5138.

200
00:13:06,410 --> 00:13:10,038
We are on eleven something, so it's

201
00:13:10,134 --> 00:13:14,182
been a long ride since then. It has to honor the GPL

202
00:13:14,246 --> 00:13:17,434
license, obviously. And so that

203
00:13:17,472 --> 00:13:21,386
means it's going to continue to be protected just like MySQL,

204
00:13:21,498 --> 00:13:25,040
at least in terms of availability of the source code.

205
00:13:25,490 --> 00:13:28,830
About development, we don't know, right? I mean,

206
00:13:28,980 --> 00:13:32,254
you saw the conversation on slack. Now in the

207
00:13:32,292 --> 00:13:35,806
case of Marie bees, it gained popularity

208
00:13:35,918 --> 00:13:39,294
very quickly and it became the default

209
00:13:39,342 --> 00:13:42,686
database in many Linux distributions.

210
00:13:42,798 --> 00:13:46,630
And you can see it here, for example in the Debian popcorn popularity

211
00:13:47,050 --> 00:13:49,190
contest, which kind of sends,

212
00:13:50,890 --> 00:13:53,926
you have to install this package on Linux on your

213
00:13:53,948 --> 00:13:57,758
machine and then it sends data on what packages you have installed.

214
00:13:57,794 --> 00:14:01,302
So you see the MariaDb server package gaining

215
00:14:01,366 --> 00:14:05,162
and taking over MySQL in number of

216
00:14:05,216 --> 00:14:08,934
installations. And it's not just on Linux, also on windows

217
00:14:08,982 --> 00:14:12,266
you see more and more installations. This tells

218
00:14:12,298 --> 00:14:16,094
me, in my opinion that more developers are using

219
00:14:16,292 --> 00:14:19,434
MariaDB as well. So not only in production,

220
00:14:19,482 --> 00:14:22,270
but developers are choosing Mariadb.

221
00:14:22,790 --> 00:14:26,850
Now. The MariaDB foundation was created

222
00:14:27,510 --> 00:14:30,674
to protect the source code of

223
00:14:30,712 --> 00:14:35,374
being controlled by one large entity. So that innovation continues

224
00:14:35,422 --> 00:14:39,090
to happen. Also the MariaDB Corporation was

225
00:14:39,160 --> 00:14:42,710
founded. Now it's called MariaDB plc. And they offered

226
00:14:44,170 --> 00:14:47,798
services but also products and most of them open source. For example,

227
00:14:47,884 --> 00:14:51,674
faster connectors, connectors like drivers or APIs for

228
00:14:51,792 --> 00:14:54,970
Java or Node JS, C,

229
00:14:55,120 --> 00:14:58,294
Python to connect to Mariadb. And they are faster

230
00:14:58,342 --> 00:15:01,146
than those in MySQL.

231
00:15:01,338 --> 00:15:04,714
Now they also created additional storage engines.

232
00:15:04,762 --> 00:15:08,314
So what is that? Storage engines. Let's talk a little bit about storage

233
00:15:08,362 --> 00:15:11,866
engines. And there are many, many storage engines

234
00:15:12,058 --> 00:15:15,774
here you see in NoDB again, right? So in fact

235
00:15:15,892 --> 00:15:18,894
I said it's a module and yeah, that's true, it's a module for MariaDB.

236
00:15:18,942 --> 00:15:22,306
So it's something you put in Mariadb. MariaDB comes with several of

237
00:15:22,328 --> 00:15:25,826
these, not all of these, some of these already when you install it, but you

238
00:15:25,848 --> 00:15:28,820
can put more there or remove them if you want.

239
00:15:29,750 --> 00:15:33,686
InoDB comes there. That's the one that you are going to use most

240
00:15:33,708 --> 00:15:37,490
of the time. Ironically, you have horizontally

241
00:15:37,570 --> 00:15:41,206
column store right in the middle for analytical workloads.

242
00:15:41,318 --> 00:15:44,986
So that's for the average of

243
00:15:45,008 --> 00:15:49,318
the numbers in these columns. It's going to be much faster than other storage engines.

244
00:15:49,414 --> 00:15:53,326
So for reporting analytics you can do these with

245
00:15:53,348 --> 00:15:57,370
MariaDB as well. You have myrocks

246
00:15:57,450 --> 00:16:01,658
initially created by Facebook for workloads

247
00:16:01,674 --> 00:16:05,358
that are write heavy. You have tons of writes

248
00:16:05,534 --> 00:16:09,300
and maybe the opposite area, which is like Maria without the M

249
00:16:09,670 --> 00:16:14,014
many reads but very few writes.

250
00:16:14,142 --> 00:16:17,510
You can store it in memory, as you can see there, CSV,

251
00:16:17,850 --> 00:16:21,238
you have a spider for database charting. That is

252
00:16:21,244 --> 00:16:24,434
like dividing the data in multiple nodes so that your database

253
00:16:24,482 --> 00:16:27,846
can grow even. You can optimize on

254
00:16:27,868 --> 00:16:31,322
the cloud with s three and many others.

255
00:16:31,376 --> 00:16:34,554
Okay, so let me show you this. So let's say we have an application

256
00:16:34,752 --> 00:16:38,262
in which people can make tons of comments,

257
00:16:38,326 --> 00:16:42,186
right? And then we expect quite a lot

258
00:16:42,208 --> 00:16:45,866
of those. So we create a table, comments, some columns

259
00:16:45,898 --> 00:16:49,082
there, and then we say engine equals my rocks don't.

260
00:16:49,146 --> 00:16:53,520
This is optimized for write.

261
00:16:54,050 --> 00:16:57,470
We're going to save money probably on this storage.

262
00:16:57,630 --> 00:17:00,222
Now in the same database we have categories,

263
00:17:00,366 --> 00:17:03,746
some columns there, but categories, they don't change ever. Maybe they

264
00:17:03,768 --> 00:17:07,294
change every ten years or whatever. So we can say engines equals

265
00:17:07,342 --> 00:17:11,318
area. To be honest, you will use probably InoDB here, but you

266
00:17:11,324 --> 00:17:14,886
can use any of the others, even memory, and then just load them when

267
00:17:14,908 --> 00:17:18,838
the database starts or, I don't know, use any kind of

268
00:17:19,004 --> 00:17:22,446
strategy. You can do this with memory DB,

269
00:17:22,498 --> 00:17:26,442
you can have in the same database, these two kind of tables with different

270
00:17:26,496 --> 00:17:30,466
storage engines. And since they are on the same server, the same database,

271
00:17:30,518 --> 00:17:33,546
you can run a query like select some columns,

272
00:17:33,578 --> 00:17:37,482
let's say all the columns from comments join categories

273
00:17:37,546 --> 00:17:41,566
at mixing this data, add a condition to filter the

274
00:17:41,588 --> 00:17:45,322
data. And as you can see, we have in the same SQL query,

275
00:17:45,386 --> 00:17:48,498
we have two storage engines. That's pretty cool.

276
00:17:48,584 --> 00:17:51,554
Okay, if you want to learn a little bit more about the kind of different

277
00:17:51,592 --> 00:17:55,230
workloads that MariaDB offers and what makes MariaDB unique,

278
00:17:55,390 --> 00:17:58,438
this is a good video where I quickly, it's a very short video where I

279
00:17:58,444 --> 00:18:01,922
quickly mention some of these things. Anyway, so let's talk about production,

280
00:18:01,986 --> 00:18:05,826
because production is very important, right? So MariadB

281
00:18:05,858 --> 00:18:09,366
Enterprise is made for that. And it's built on top of open source

282
00:18:09,398 --> 00:18:15,146
software. Okay, now I

283
00:18:15,168 --> 00:18:18,794
call it enterprise subscription and it includes something called

284
00:18:18,832 --> 00:18:22,586
MariadB Enterprise server which is based on the community server

285
00:18:22,618 --> 00:18:26,480
which is free. And it offers more

286
00:18:27,730 --> 00:18:31,230
larger maintenance window,

287
00:18:31,650 --> 00:18:35,234
up to eight years. I believe the community server is like one year or so,

288
00:18:35,272 --> 00:18:38,466
don't believe me, but check

289
00:18:38,488 --> 00:18:42,020
the policies online. But it got to be something like that.

290
00:18:42,710 --> 00:18:46,894
It's a big difference in the maintenance window. It offers

291
00:18:46,942 --> 00:18:50,146
also the possibility to run non blocking backups

292
00:18:50,178 --> 00:18:53,426
so that operations continue. Even if you are taking a backup,

293
00:18:53,618 --> 00:18:57,366
you need to stop operations. Enterprise audit, if you have

294
00:18:57,388 --> 00:19:01,946
to comply with some certifications or

295
00:19:02,048 --> 00:19:04,220
this kind of stuff. Same with security,

296
00:19:05,710 --> 00:19:10,154
any kind of, what's the word for know?

297
00:19:10,192 --> 00:19:13,210
You have to comply with some policies or standards.

298
00:19:13,710 --> 00:19:17,470
Mariadb Enterprise offers more options for this

299
00:19:17,620 --> 00:19:21,034
now. It also offers something called Maxscale,

300
00:19:21,082 --> 00:19:25,438
which is a database proxy by the way. So MySQL,

301
00:19:25,534 --> 00:19:29,410
the name Mai comes from Mikhail Vidani's

302
00:19:29,990 --> 00:19:33,826
daughter. So he has a daughter called Mai. I don't know,

303
00:19:33,848 --> 00:19:37,554
maybe in Swedish it would be like me, let me know. You speak Swedish,

304
00:19:37,602 --> 00:19:39,320
how you would pronounce that?

305
00:19:40,250 --> 00:19:43,494
And he also has another daughter called

306
00:19:43,532 --> 00:19:47,478
Maria. So you have Maria Dubi and he also has a son called

307
00:19:47,564 --> 00:19:51,754
Max. And so you have Max scale. So that's interesting fact

308
00:19:51,872 --> 00:19:55,878
right there for you. Let's talk about the Max scale

309
00:19:55,894 --> 00:19:59,078
then. It's a database proxy. That means that it's

310
00:19:59,094 --> 00:20:03,066
something that sits between a client, in this case a web server

311
00:20:03,098 --> 00:20:06,810
with an application, web application and the database.

312
00:20:06,970 --> 00:20:10,526
But the web server or the application is talking to the

313
00:20:10,548 --> 00:20:14,546
proxy, but directly physically to proxy. But it thinks it's talking to the

314
00:20:14,568 --> 00:20:17,758
database or the server, right? Database server.

315
00:20:17,854 --> 00:20:21,218
And the server or the database thinks it's replying to the client. That's what

316
00:20:21,224 --> 00:20:25,874
a proxy generally speaking is. And I

317
00:20:25,912 --> 00:20:29,846
call it intelligent because it understands SQL. So it

318
00:20:29,868 --> 00:20:33,474
can make decisions on, for example, where to send a query if it's a cluster

319
00:20:33,522 --> 00:20:36,946
of multiple database servers, or what to reply

320
00:20:36,978 --> 00:20:41,034
if I need to modify the

321
00:20:41,072 --> 00:20:45,366
results somehow. This is all configurable.

322
00:20:45,478 --> 00:20:49,270
That's the idea of a database proxy. It also understands

323
00:20:49,350 --> 00:20:52,846
SQL. So you have maybe a web application in Java or

324
00:20:52,868 --> 00:20:55,946
node JS and it uses the MongoDB driver.

325
00:20:56,058 --> 00:21:00,026
So now it has to use MQL. So the MongoDB

326
00:21:00,058 --> 00:21:03,646
query language. So instead of using MongoDB you can send those

327
00:21:03,668 --> 00:21:07,086
queries to Maxscale and Maxscale translates that to SQL

328
00:21:07,118 --> 00:21:10,626
and stores the data in MariaDB. That's pretty cool.

329
00:21:10,648 --> 00:21:14,862
So you have all the data in a relational database. The advantage

330
00:21:14,926 --> 00:21:19,110
being that if you have other applications that use

331
00:21:19,260 --> 00:21:23,170
relational database, you have all the data in one single database.

332
00:21:23,250 --> 00:21:27,510
So you can use one single query to join the data from multiple

333
00:21:28,090 --> 00:21:31,770
applications that use kind of a different nature like

334
00:21:31,840 --> 00:21:35,386
SQL and NoSQL in one single query. That's pretty cool.

335
00:21:35,408 --> 00:21:39,194
If you want to experiment with these, I have this video where you get

336
00:21:39,232 --> 00:21:42,750
access to this docker compose file and

337
00:21:42,820 --> 00:21:47,838
it spins up all the services, max scale and you

338
00:21:47,844 --> 00:21:51,626
don't have to do much. You can just run a query using MongoDB

339
00:21:51,738 --> 00:21:55,822
query language and then another one using SQL, but you don't have MongoDB

340
00:21:55,886 --> 00:22:00,206
really. And then you can combine the data, both SQL

341
00:22:00,238 --> 00:22:03,634
and NoSQL, so to speak, data in a single SQL query. It's pretty

342
00:22:03,672 --> 00:22:07,474
cool. Did I mention that MariaDB B Max scale

343
00:22:07,522 --> 00:22:11,570
was intelligent? Well, it also understands Kafka.

344
00:22:11,650 --> 00:22:14,760
Now here I put the database server on the other side.

345
00:22:15,370 --> 00:22:18,634
And basically what you can do here, what this

346
00:22:18,672 --> 00:22:22,790
enables is something like change data capture, that is sending

347
00:22:22,870 --> 00:22:26,266
database change events, events like changing the

348
00:22:26,288 --> 00:22:30,134
schema or in data from Kafka

349
00:22:30,182 --> 00:22:33,978
to any other kind of system, including MariaDB. You can

350
00:22:33,984 --> 00:22:37,486
send it out to another MariaDB database if you want it. For example one

351
00:22:37,508 --> 00:22:41,326
that has column store while this one has inodb. That one would be for

352
00:22:41,348 --> 00:22:44,862
analytics. I don't know, there are many possibilities.

353
00:22:45,006 --> 00:22:49,134
So CDC and you can do the opposite. You can do a data ingestion

354
00:22:49,182 --> 00:22:52,338
that is storing data that comes through Kafka in

355
00:22:52,424 --> 00:22:56,498
MariaDB. Pretty cool. Now this is a very interesting use case

356
00:22:56,584 --> 00:23:00,082
read, write splitting. So let's say you have these two database servers

357
00:23:00,146 --> 00:23:03,958
right here and then you configure MariaDB replication, which you

358
00:23:03,964 --> 00:23:07,254
can learn with this video, this one, this code takes you to the

359
00:23:07,292 --> 00:23:10,538
channel so you can just subscribe. There are plenty of interesting videos,

360
00:23:10,624 --> 00:23:14,214
especially by my colleagues. I have to say they're top notch

361
00:23:14,262 --> 00:23:17,610
experts in the database, in database technology I would say.

362
00:23:17,760 --> 00:23:21,798
Anyway, so you have configured this, you put Maxcale here, you configure

363
00:23:21,814 --> 00:23:24,302
it. So that sends the rights, it's very easy,

364
00:23:24,356 --> 00:23:27,646
actually sends the rights to the primary and

365
00:23:27,668 --> 00:23:31,406
the reads to the replica. So everything you write in the primary because

366
00:23:31,428 --> 00:23:34,718
of MariaDB replication is going to be available in replica.

367
00:23:34,814 --> 00:23:38,674
So you can read from the replica instead from

368
00:23:38,712 --> 00:23:42,034
the primary. And then your web application or

369
00:23:42,072 --> 00:23:45,634
your applications just send the SQL or connect to the

370
00:23:45,672 --> 00:23:49,474
max scale proxy. Remember it's a proxy. So the

371
00:23:49,512 --> 00:23:53,142
application thinks it's talking to a database and it thinks it's talking to one

372
00:23:53,196 --> 00:23:56,438
database. In fact the connection string, in the case of Java, that's example,

373
00:23:56,524 --> 00:24:00,280
but similar. In other programming languages the parameters would be similar.

374
00:24:00,730 --> 00:24:04,202
It thinks it's just one endpoint. That's it, I'm going there.

375
00:24:04,256 --> 00:24:07,674
It's one. But actually there are two nodes. In fact we can add a new

376
00:24:07,712 --> 00:24:11,514
one and the web application. You don't need to restart it, you need

377
00:24:11,552 --> 00:24:14,842
to stop it. Nothing. It continues to work.

378
00:24:14,896 --> 00:24:18,702
It's just now can work more

379
00:24:18,836 --> 00:24:23,034
efficiently with reads. In this case we are scaling reads horizontally

380
00:24:23,082 --> 00:24:26,258
and you can remove also the replicas later when you don't need them to

381
00:24:26,264 --> 00:24:29,586
save money, for example in the cloud. In fact you can change the whole

382
00:24:29,608 --> 00:24:33,710
thing. You can change these to now three different clusters or availability

383
00:24:33,790 --> 00:24:37,206
zones or even clouds if you want. And data is

384
00:24:37,228 --> 00:24:40,754
replicated there, I don't know, with inoDB and column

385
00:24:40,802 --> 00:24:45,234
store nodes for analytics, the replication

386
00:24:45,362 --> 00:24:48,914
still doesn't know. It continues to use the same connection string. It thinks it's one

387
00:24:48,972 --> 00:24:52,554
logical database. In fact there are many nodes, as you can see there.

388
00:24:52,672 --> 00:24:57,206
So this is topology isolation, it's isolated that it can evolve,

389
00:24:57,398 --> 00:25:00,342
it can be evolved. Okay, so automatic failure,

390
00:25:00,406 --> 00:25:03,680
which is pretty cool. Let's say this is the primary server in this cloud,

391
00:25:04,370 --> 00:25:07,614
and this one is managing all the

392
00:25:07,652 --> 00:25:10,270
writes. So if it fails,

393
00:25:10,770 --> 00:25:14,750
then we cannot write data anymore. That's bad. But Max scale detects

394
00:25:14,830 --> 00:25:17,618
this automatically. You don't have to do anything.

395
00:25:17,784 --> 00:25:21,874
And then it picks another one, reconfigures it and

396
00:25:22,072 --> 00:25:26,054
promotes it as a new primary. That means that the web

397
00:25:26,092 --> 00:25:28,966
application continues to write data.

398
00:25:29,068 --> 00:25:32,566
Maybe there's a slight short delay in some

399
00:25:32,588 --> 00:25:35,814
of the write operations while this configuration is taking place,

400
00:25:35,932 --> 00:25:39,002
but it doesn't fail. Then later

401
00:25:39,136 --> 00:25:42,774
maybe the failed node recovers

402
00:25:42,822 --> 00:25:45,978
or you restart it, or it restarts automatically, whatever.

403
00:25:46,144 --> 00:25:49,306
Maxiscale detects these and now reconfigures it

404
00:25:49,328 --> 00:25:52,874
as a new replica. So all of a sudden you have the same capacity.

405
00:25:52,922 --> 00:25:56,286
Assuming nodes have the same capacity and they are identical, you can do

406
00:25:56,308 --> 00:25:59,578
the switch over through a UI that Maxscale offers,

407
00:25:59,754 --> 00:26:03,490
a web based GUI or GUI

408
00:26:03,990 --> 00:26:07,726
or the command line or your own script

409
00:26:07,838 --> 00:26:11,506
or configuration files to always use to kind

410
00:26:11,528 --> 00:26:14,446
of restore it to where it was before, manually.

411
00:26:14,638 --> 00:26:17,842
You can do that, that was automatic failover.

412
00:26:17,906 --> 00:26:20,994
Let's talk a little bit about the present future of Mariadb.

413
00:26:21,122 --> 00:26:24,210
Today you can deploy MariadB anywhere.

414
00:26:24,370 --> 00:26:27,558
So Docker for example, I deployed with docker swarm I

415
00:26:27,564 --> 00:26:30,866
believe was this deployment of MariadB

416
00:26:30,898 --> 00:26:34,682
in this raspberry PI cluster that I built. I didn't have it close

417
00:26:34,736 --> 00:26:38,106
to me right now, but it's pretty cool because you can

418
00:26:38,208 --> 00:26:42,110
disconnect one of these cables, the whole thing continues to operate.

419
00:26:42,450 --> 00:26:45,866
Maxiscale is replicated, I think I have two nodes, I think it's

420
00:26:45,898 --> 00:26:49,674
the two top nodes there. I installed Maxiscale

421
00:26:49,722 --> 00:26:53,482
there and it replicates the configuration.

422
00:26:53,546 --> 00:26:57,700
So I configure one, the other one changes accordingly. So it's pretty cool.

423
00:26:59,190 --> 00:27:03,058
You can deploy in the cloud, obviously any cloud. Looking into the future,

424
00:27:03,144 --> 00:27:06,690
the teams are working a lot on kubernetes,

425
00:27:06,770 --> 00:27:11,474
deployments and orchestration and AI capabilities.

426
00:27:11,522 --> 00:27:14,486
I'm not going to talk too much about it, so stay tuned for news on

427
00:27:14,508 --> 00:27:18,238
these two fronts. Migrating to MariaDB

428
00:27:18,274 --> 00:27:21,638
is actually very easy if you for example do it from MySQL.

429
00:27:21,814 --> 00:27:25,622
And these are the main servers,

430
00:27:25,686 --> 00:27:29,578
other servers that we see that people migrate from the most

431
00:27:29,664 --> 00:27:32,886
to Mariadb. But this is boring. This documentation, what I wanted

432
00:27:32,928 --> 00:27:35,806
to show you, it's actually a feature that MariaDB has.

433
00:27:35,908 --> 00:27:39,790
So you can say set SQL mode equals oracle or

434
00:27:39,940 --> 00:27:44,110
put this in a configuration file somewhere with a different, slight different syntax.

435
00:27:44,450 --> 00:27:48,366
Now MariaDB understands Oracle well, it doesn't understand all the dialect

436
00:27:48,398 --> 00:27:51,874
of Oracle. That would be crazy. But it helps with migration a

437
00:27:51,912 --> 00:27:55,886
lot because you get closer to it, so you need to change less

438
00:27:55,928 --> 00:27:59,746
things. The same with PostgreSQL and the same with SQL

439
00:27:59,778 --> 00:28:03,970
server. So that's pretty cool tool for migration.

440
00:28:04,130 --> 00:28:07,938
Who uses all this cool stuff? Well, here you see some usage around

441
00:28:07,964 --> 00:28:10,650
the world. So you see Asia, United States,

442
00:28:10,720 --> 00:28:13,558
Germany, Brazil, Mexico.

443
00:28:13,734 --> 00:28:17,046
Well there are many. These are the countries with more downloads,

444
00:28:17,078 --> 00:28:20,390
right? But they are used. Meridi is used everywhere,

445
00:28:20,470 --> 00:28:23,962
globally. And remember, it's open source and it's backed up with these

446
00:28:24,016 --> 00:28:27,898
companies, which are huge. So this project is not going to disappear.

447
00:28:28,074 --> 00:28:31,422
I don't need to mention or say anything about these companies.

448
00:28:31,476 --> 00:28:35,010
You recognize them. Some notable users,

449
00:28:36,150 --> 00:28:40,066
Wikipedia. When you read something on Wikipedia you are reading information

450
00:28:40,168 --> 00:28:43,970
stored on mariadb. Samsung. If you have devices

451
00:28:45,290 --> 00:28:48,834
that are Samsung and you log into their networks,

452
00:28:48,962 --> 00:28:52,546
you are using Mariadb. Nocare, Red Hat,

453
00:28:52,578 --> 00:28:55,926
Google DBS. DBS is a huge bank in

454
00:28:55,948 --> 00:28:59,250
Asia. They migrated from Oracle to MariaDb and they are

455
00:28:59,260 --> 00:29:02,854
very happy because they are saving a lot of money and they gain

456
00:29:02,902 --> 00:29:06,454
some functionality as well. These are some notable

457
00:29:06,502 --> 00:29:10,890
users, but actually 75% of the Fortune 500

458
00:29:10,960 --> 00:29:14,570
companies use MariaDB. So most of them use MariaDB.

459
00:29:14,730 --> 00:29:18,666
Now it's not only big companies because MariaDB has more than 1 billion downloads

460
00:29:18,698 --> 00:29:21,946
on Docker hub. That's quite a lot. Now in conclusion,

461
00:29:21,978 --> 00:29:26,322
we saw the MariaDB evolutions in the 60s when you store data on

462
00:29:26,376 --> 00:29:30,738
tape. This kind of stuff up to today where

463
00:29:30,904 --> 00:29:34,706
you maybe even with a few clicks have the database running in

464
00:29:34,728 --> 00:29:38,114
the cloud, fully managed sometimes or on your

465
00:29:38,152 --> 00:29:42,040
raspberry Pis, I don't know. I wouldn't recommend going

466
00:29:42,650 --> 00:29:46,022
production with raspberry PI, although I bet it has been done. It might work

467
00:29:46,076 --> 00:29:50,026
even. I don't know. I don't know for databases though. But it

468
00:29:50,048 --> 00:29:53,194
is fun to do it for experimentation. Anyway,

469
00:29:53,312 --> 00:29:57,382
we saw this. I want to leave you with this message. Nobody says Ubuntu

470
00:29:57,446 --> 00:30:01,498
is a fork of Debian or Microsoft SQL Server is a

471
00:30:01,504 --> 00:30:05,466
fork of database unless they are making a historical remark in

472
00:30:05,488 --> 00:30:09,022
the same way. Mariadb is much more than a fork of MySQL and I

473
00:30:09,076 --> 00:30:12,686
hope you saw why this is true and learned something about

474
00:30:12,708 --> 00:30:16,078
Mariadb or database try it out.

475
00:30:16,244 --> 00:30:19,914
It's a lot of fun. These are my coordinates.

476
00:30:19,962 --> 00:30:23,662
Feel free to reach out. I'll be happy to hear from you. Thank you

477
00:30:23,716 --> 00:30:25,490
and enjoy the rest of the conference.

