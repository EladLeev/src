1
00:01:54,270 --> 00:01:57,490
Hello. Good morning. Good afternoon. Good evening. Thank you for

2
00:01:57,560 --> 00:02:01,042
joining today's talk on containing security when working

3
00:02:01,096 --> 00:02:04,158
with containers. My name is Adrian Gonzalez and I'm

4
00:02:04,174 --> 00:02:07,570
a principal software engineering lead here at Microsoft.

5
00:02:08,950 --> 00:02:12,386
As part of my role, I am accountable for ensuring that security is

6
00:02:12,408 --> 00:02:16,514
part of my team's engineering fundamentals and incorporate as

7
00:02:16,552 --> 00:02:19,770
part of all out puts. Whether it's working with a customer or working

8
00:02:19,840 --> 00:02:23,558
on a product outside of work, I enjoy experiencing new cuisines,

9
00:02:23,654 --> 00:02:27,414
going on wine tastings, traveling the world, most outdoor

10
00:02:27,462 --> 00:02:31,254
activities, and playing and watching baseball throughout

11
00:02:31,302 --> 00:02:34,618
the presentation. Today we're going to cover the four phases that I've

12
00:02:34,714 --> 00:02:38,110
experienced when working with security around containers.

13
00:02:38,530 --> 00:02:41,678
First, we're going to explore the top quadrant here,

14
00:02:41,764 --> 00:02:45,586
which is around creating updating container images. In this

15
00:02:45,608 --> 00:02:49,214
section we're going to cover four topics and outline some examples,

16
00:02:49,262 --> 00:02:52,626
as well as additional details around what are some

17
00:02:52,648 --> 00:02:56,174
of these best practices when creating and updating container images?

18
00:02:56,302 --> 00:02:59,640
The first practice I want to talk about is ink, making sure that

19
00:03:00,650 --> 00:03:03,894
you're running the latest versions or most

20
00:03:04,092 --> 00:03:07,618
relatively recent versions of the OS,

21
00:03:07,714 --> 00:03:11,110
and as well as the container environment.

22
00:03:11,270 --> 00:03:14,826
In this image and in the future slides, I'm going to be using Docker as

23
00:03:14,848 --> 00:03:18,298
an example. Typically, the steps to perform this

24
00:03:18,384 --> 00:03:21,674
will vary. The syntax will vary based on your operating

25
00:03:21,722 --> 00:03:26,074
system and tool of choice, but typical steps include things like uninstalling

26
00:03:26,122 --> 00:03:30,234
old versions, updating any packages that are required

27
00:03:30,282 --> 00:03:33,342
to perform the commands on the CLI,

28
00:03:33,486 --> 00:03:36,882
adding GPG keys to ensure security when

29
00:03:36,936 --> 00:03:40,786
downloading dependencies, setting up repositories to be able

30
00:03:40,808 --> 00:03:44,114
to store where the downloads will take place,

31
00:03:44,312 --> 00:03:48,374
and then ultimately determining what version of either the

32
00:03:48,412 --> 00:03:51,558
OS or the container framework you're using.

33
00:03:51,724 --> 00:03:55,714
So in this case it would be a particular version of Docker,

34
00:03:55,762 --> 00:03:59,794
engine container and Docker compose. And in this images

35
00:03:59,842 --> 00:04:03,866
here you see how I outline the command that I use to determine what

36
00:04:03,888 --> 00:04:07,322
are the recent versions of Docker as well as what

37
00:04:07,376 --> 00:04:11,290
version I want to use for my dependencies.

38
00:04:11,630 --> 00:04:15,482
The next best practice is ensuring to use non root

39
00:04:15,546 --> 00:04:18,906
users, and in this particular case you'll

40
00:04:18,938 --> 00:04:22,558
see examples both in the top left and top right images where

41
00:04:22,644 --> 00:04:26,334
I define a particular username, I give it a user

42
00:04:26,382 --> 00:04:29,858
id, and I create a particular

43
00:04:29,944 --> 00:04:32,546
group for that user to be associated with.

44
00:04:32,648 --> 00:04:36,194
And you'll see a command highlighted there where I just

45
00:04:36,232 --> 00:04:39,826
want to share that. In my experience, it's okay to have certain non root

46
00:04:39,858 --> 00:04:43,286
users be able to perform pseudo operations, but you do want to

47
00:04:43,308 --> 00:04:47,438
limit how many users and also definitely segment the users,

48
00:04:47,474 --> 00:04:51,020
potentially as separate groups as well. The last

49
00:04:51,630 --> 00:04:56,650
line in the top left image is that effective use

50
00:04:56,720 --> 00:05:01,082
of ensuring that when the container runs, it's using that username

51
00:05:01,146 --> 00:05:05,034
and not a root user. The bottom right image is effectively

52
00:05:05,082 --> 00:05:09,006
the same structure, but using a real example of where I

53
00:05:09,108 --> 00:05:13,162
needed to download a Golang base image from docker

54
00:05:13,226 --> 00:05:16,866
containers, and then I had to actually go back and use the

55
00:05:16,888 --> 00:05:20,094
root user to install some dependencies.

56
00:05:20,142 --> 00:05:23,806
In this case, I removed most of those dependencies and just showed

57
00:05:23,918 --> 00:05:27,286
the run command where I would update dependencies. And then

58
00:05:27,308 --> 00:05:30,886
once I finished that custom tailoring of

59
00:05:30,988 --> 00:05:34,546
my image, I completed the docker file

60
00:05:34,578 --> 00:05:37,874
by switching back to that non root user.

61
00:05:38,002 --> 00:05:42,518
Another best practice is making sure to use trusted sources or trusted registries.

62
00:05:42,694 --> 00:05:46,026
Here in this image I show how what

63
00:05:46,048 --> 00:05:49,670
is the relationship between a registry, an image, and a container,

64
00:05:49,750 --> 00:05:53,354
where registries is effectively nothing more than a repository

65
00:05:53,402 --> 00:05:57,722
of images? Images are static representations of running containers,

66
00:05:57,786 --> 00:06:01,178
and then a container is the actual instance that is running, and you'll

67
00:06:01,194 --> 00:06:05,074
see that when working with Docker. It follows that same convention when

68
00:06:05,272 --> 00:06:08,578
you see indications of the from command, where the

69
00:06:08,584 --> 00:06:12,238
first piece of that from command is a registry followed by a slash,

70
00:06:12,334 --> 00:06:16,162
followed by the repository name as well as the image name,

71
00:06:16,296 --> 00:06:19,318
and then followed by a colon and the specific

72
00:06:19,404 --> 00:06:22,674
version of that image. Now when using trusted sources

73
00:06:22,722 --> 00:06:26,742
and registries, know that that can be both on prem as well as public cloud

74
00:06:26,876 --> 00:06:30,342
through other providers, whether that be azure,

75
00:06:30,406 --> 00:06:34,966
AWs, Google, some other cloud, or JFrog artifactory.

76
00:06:35,158 --> 00:06:38,634
Another best practice is making sure that when defining images that

77
00:06:38,672 --> 00:06:42,462
they are as lean as possible. That typically translates to only

78
00:06:42,516 --> 00:06:46,190
install the dependencies that that container requires to perform its

79
00:06:46,260 --> 00:06:50,026
function. But it also includes

80
00:06:50,058 --> 00:06:53,290
another mindset that I outline in the top left image,

81
00:06:53,370 --> 00:06:57,010
which is separating build versus runtime dependencies.

82
00:06:57,350 --> 00:07:00,766
In this image we're installing what looks to be some kind of a node

83
00:07:00,798 --> 00:07:04,562
application, or we want to create some kind of a node application that

84
00:07:04,616 --> 00:07:08,230
is a web app. And so the first

85
00:07:08,380 --> 00:07:12,390
part that I highlight here is all the steps required to build that

86
00:07:12,460 --> 00:07:15,926
solution, and that's performed by running that

87
00:07:16,028 --> 00:07:19,606
run yarn run build command. And of course I

88
00:07:19,628 --> 00:07:23,674
had to install yarn to do that. As you can see, yarn install

89
00:07:23,792 --> 00:07:27,594
or, sorry, install all the node NPM packages to do that.

90
00:07:27,712 --> 00:07:31,226
And depending on the solution those can get quite hefty and include

91
00:07:31,258 --> 00:07:35,082
a lot of dependencies. Now the second piece that I highlight

92
00:07:35,146 --> 00:07:38,590
is a totally different docker base

93
00:07:38,660 --> 00:07:42,334
image called Nginx Alpine. And here I'm copying only

94
00:07:42,372 --> 00:07:45,690
the outputs of the run build command in the

95
00:07:45,700 --> 00:07:49,934
previous step and storing them in this new base image.

96
00:07:50,062 --> 00:07:53,778
And now I no longer have to worry about all the other NPM packages that

97
00:07:53,784 --> 00:07:57,474
were required to actually build a solution. And my image is now leaner,

98
00:07:57,602 --> 00:08:01,714
has less dependencies, and is therefore less prone

99
00:08:01,762 --> 00:08:05,382
for vulnerabilities. Also in the bottom right

100
00:08:05,436 --> 00:08:09,066
example is another extension of how I was

101
00:08:09,088 --> 00:08:12,810
able to extend a Golang image and a python based

102
00:08:12,880 --> 00:08:16,966
image. And again, I removed all the custom dependencies

103
00:08:16,998 --> 00:08:21,434
I had to install for keeping this brief. But you

104
00:08:21,472 --> 00:08:24,698
see how I start using in line ten the Golang image,

105
00:08:24,714 --> 00:08:28,250
I download it, and then in line twelve I download the Python image.

106
00:08:28,330 --> 00:08:31,518
I would perform my custom dependencies and install them there.

107
00:08:31,604 --> 00:08:35,122
And then in line 18, all I do is copy everything from the Golang base

108
00:08:35,176 --> 00:08:38,418
image into my current working image, and that is what I

109
00:08:38,424 --> 00:08:42,014
would ultimately produce. The next phase in our cycle

110
00:08:42,062 --> 00:08:45,506
here is storing that container registry I

111
00:08:45,528 --> 00:08:48,930
want to talk about a few concepts as outlined in this slide.

112
00:08:49,090 --> 00:08:53,062
First up is around using, considering what is using

113
00:08:53,116 --> 00:08:56,710
and what is a private registry. Well, really a private registry is

114
00:08:56,780 --> 00:09:00,186
nothing more than just a regular public registry, but it

115
00:09:00,208 --> 00:09:04,454
is segmented by having stronger

116
00:09:04,502 --> 00:09:08,042
network security policies in place. Now these can be things like

117
00:09:08,096 --> 00:09:11,818
firewalls, source IP range policies, or poor policies.

118
00:09:11,994 --> 00:09:15,902
The importance here is security by not

119
00:09:15,956 --> 00:09:19,594
even knowing that a registry exists and only granting

120
00:09:19,642 --> 00:09:23,114
individuals, or in this case networks, the ability

121
00:09:23,162 --> 00:09:26,610
to connect to your registry on a need to know basis.

122
00:09:26,950 --> 00:09:30,334
Another important concept when working with registries and securing

123
00:09:30,382 --> 00:09:34,066
a registry is affiliating a concept called digital signatures to

124
00:09:34,088 --> 00:09:37,286
that registry. I provide a couple of definitions on

125
00:09:37,308 --> 00:09:40,946
what that is here to keep it brief. A digital

126
00:09:40,978 --> 00:09:44,726
signature really is nothing more than what it sounds like. It's a

127
00:09:44,748 --> 00:09:48,406
digital signature that creates trust and a chain

128
00:09:48,438 --> 00:09:52,106
of custody of any image or any version of an

129
00:09:52,128 --> 00:09:55,206
image that is available for you to consume.

130
00:09:55,318 --> 00:09:58,502
It gives you that additional sense of confidence

131
00:09:58,566 --> 00:10:01,882
that that image is produced by

132
00:10:02,016 --> 00:10:05,406
whoever said produced it, and gives you that

133
00:10:05,428 --> 00:10:08,846
sense of accountability that you know who to hold and reach out to. If there

134
00:10:08,868 --> 00:10:12,766
were any issues with that image and the

135
00:10:12,868 --> 00:10:16,962
three images I have here, I show how I use Docker to first

136
00:10:17,096 --> 00:10:21,138
create a digital signature key docker trust

137
00:10:21,224 --> 00:10:24,980
key generate. I'm not Jeff, but I would replace that with my name.

138
00:10:25,530 --> 00:10:29,446
The second image, I add that key that was

139
00:10:29,468 --> 00:10:33,142
just generated. And it's important to note that

140
00:10:33,276 --> 00:10:37,282
prior to generating the key, I do have to provide that password

141
00:10:37,426 --> 00:10:40,714
to be able to generate the private key. But once I set

142
00:10:40,752 --> 00:10:45,034
my password and I have a private key, I would affiliate that

143
00:10:45,232 --> 00:10:48,934
key to the registry. That's what the middle image command

144
00:10:48,982 --> 00:10:52,446
is performing, and you can see it's saying that it's adding Jeff to

145
00:10:52,468 --> 00:10:56,238
the registry and it is prompting for that password so that it can

146
00:10:56,324 --> 00:10:59,662
successfully do so in the bottom

147
00:10:59,716 --> 00:11:02,866
image. We're effectively running the

148
00:11:02,888 --> 00:11:06,546
command to publish that image to that registry and you

149
00:11:06,568 --> 00:11:10,994
can see the command docker trust sign the

150
00:11:11,032 --> 00:11:14,866
name of the registry. The repository is called admin and

151
00:11:14,888 --> 00:11:18,886
the image name is called demo and it's version one. And again,

152
00:11:19,068 --> 00:11:23,346
I'm going to be asked for my password. Once I enter my password, that published

153
00:11:23,378 --> 00:11:27,160
Docker image in that registry will now be digitally signed by myself

154
00:11:27,850 --> 00:11:31,258
and any consumer can get that information that I was the

155
00:11:31,264 --> 00:11:34,826
one that signed it at a particular point in time. Another best practice is

156
00:11:34,848 --> 00:11:39,302
around identity access management, item and role based access management.

157
00:11:39,446 --> 00:11:43,374
To start, let's define two important terms here. A role is

158
00:11:43,412 --> 00:11:47,134
nothing more than a set of a unique id set

159
00:11:47,172 --> 00:11:50,202
of permissions and what asset or assets

160
00:11:50,346 --> 00:11:53,250
those permissions are being granted to for that role.

161
00:11:53,670 --> 00:11:57,522
An account is a set of id

162
00:11:57,656 --> 00:12:00,942
and roles, and that account I'm visually

163
00:12:01,006 --> 00:12:04,798
representing as keys in this image.

164
00:12:04,974 --> 00:12:08,454
In the bottom left image you can see how the service

165
00:12:08,572 --> 00:12:12,690
Azure container registry, which is Azure's registry

166
00:12:12,850 --> 00:12:16,402
solution, has a total of six or seven different roles,

167
00:12:16,466 --> 00:12:20,250
and each role has different sets of permissions.

168
00:12:20,750 --> 00:12:24,300
Now one best practice to consider here is always consider

169
00:12:24,830 --> 00:12:29,178
minimizing highly privileged accounts and only

170
00:12:29,264 --> 00:12:34,074
grant permissions that are required per each account minimal privileges.

171
00:12:34,202 --> 00:12:37,998
And so in this example, the least privileged would be

172
00:12:38,084 --> 00:12:41,418
a key to my image that may only contain,

173
00:12:41,514 --> 00:12:45,314
say the ability to download that image. So that would be the

174
00:12:45,352 --> 00:12:46,850
ACR pool command.

175
00:12:48,150 --> 00:12:51,298
Another more highly elevated privileged key would be the

176
00:12:51,304 --> 00:12:55,006
one on the far right, which is assigned to the Myelm

177
00:12:55,038 --> 00:12:58,486
chart and the base node repository. And that one,

178
00:12:58,508 --> 00:13:02,290
let's say for a sake of argument, is given the ability, the role

179
00:13:02,370 --> 00:13:06,102
contributor, so that whoever has that key can then perform

180
00:13:06,236 --> 00:13:10,438
all of these permissions and operations that are outlined in the left image.

181
00:13:10,614 --> 00:13:13,914
And the most highly privileged key is the one

182
00:13:13,952 --> 00:13:17,862
that is affiliated at the registry level. Even if it's the ability

183
00:13:17,926 --> 00:13:22,030
to just do, say pool of images for all repositories

184
00:13:23,090 --> 00:13:26,910
within that repository, I still consider that a highly privileged account

185
00:13:26,980 --> 00:13:30,666
and should be highly secured and restricted

186
00:13:30,698 --> 00:13:33,954
in terms of who can use it. The next phase is

187
00:13:34,072 --> 00:13:37,570
around container devsecops operations.

188
00:13:37,990 --> 00:13:41,614
And again, we're going to cover a few topics here from ensuring

189
00:13:41,662 --> 00:13:45,474
that the CI agent scans have access to the registry to what is

190
00:13:45,512 --> 00:13:48,230
container scanning and the various CI stages.

191
00:13:49,050 --> 00:13:52,694
So first, when working with CI pipelines and

192
00:13:52,732 --> 00:13:56,802
container registries, it's important to first make sure that your CI solution,

193
00:13:56,866 --> 00:14:00,682
and in this case in the image I use Azure DevOps has the ability to

194
00:14:00,736 --> 00:14:04,662
connect via the network to that container registry.

195
00:14:04,806 --> 00:14:08,422
That may involve making some security network changes on the firewall

196
00:14:08,486 --> 00:14:12,334
or security policies. Second is

197
00:14:12,372 --> 00:14:15,966
to consider creating as many account

198
00:14:16,068 --> 00:14:19,966
keys for different teams or individuals that will

199
00:14:19,988 --> 00:14:23,310
be using the CI pipeline platform solution.

200
00:14:23,650 --> 00:14:27,218
And the same mindset that we did before applies where we want to

201
00:14:27,224 --> 00:14:31,074
be as granular as possible. The most common account key I

202
00:14:31,112 --> 00:14:34,500
create in my experience is CI agent number three.

203
00:14:35,530 --> 00:14:39,190
So for each account only have maybe

204
00:14:39,260 --> 00:14:43,014
one or the minimal number of repositories and only granting that

205
00:14:43,052 --> 00:14:46,406
account ACR pool permissions, a little

206
00:14:46,428 --> 00:14:50,266
more elevated permission might be the CI agent number two key,

207
00:14:50,448 --> 00:14:55,066
which has in this case visually two repositories that

208
00:14:55,168 --> 00:14:59,014
grant that keyholder contributor and ACR

209
00:14:59,062 --> 00:15:02,446
image signer permissions. This is great for a pipeline that will be

210
00:15:02,468 --> 00:15:05,834
doing pushes to those repositories. That way the pipeline

211
00:15:05,882 --> 00:15:09,614
can digitally sign those images and consumers know which

212
00:15:09,652 --> 00:15:13,838
pipelines or which team that uses that pipeline produced said images.

213
00:15:14,014 --> 00:15:18,002
And again, the most highly privileged key is CI agent number

214
00:15:18,056 --> 00:15:21,582
one. This would be very limited,

215
00:15:21,646 --> 00:15:25,074
especially on a CI level. So definitely very

216
00:15:25,112 --> 00:15:29,826
cautious to have a CI have this account key performed

217
00:15:29,858 --> 00:15:33,986
because as owner it has complete control over that entire registry

218
00:15:34,018 --> 00:15:38,534
and all its underlying repositories. But it may be useful for a Devsecops

219
00:15:38,582 --> 00:15:41,782
team to perform to fully automate the provisioning

220
00:15:41,846 --> 00:15:44,810
and main management of future repositories.

221
00:15:45,310 --> 00:15:49,126
Next is talking about the CI stages involving containers

222
00:15:49,158 --> 00:15:52,830
and devsecops. We're going to go through each step here shortly. But just

223
00:15:52,900 --> 00:15:56,702
like all CI pipelines, everything is based on a container code change

224
00:15:56,756 --> 00:16:00,720
or code commit, specifically those that maybe pertain to the

225
00:16:01,170 --> 00:16:04,754
container definition, like the image or docker file in this

226
00:16:04,792 --> 00:16:08,066
case, step one build. Don't worry about the

227
00:16:08,088 --> 00:16:11,700
syntax from here on out. This is Azure DevOps and

228
00:16:12,070 --> 00:16:15,778
what I want to make sure is that we focus more on the actual

229
00:16:15,864 --> 00:16:19,666
docker commands or the tools that I'm using that

230
00:16:19,688 --> 00:16:22,994
I'm working that I'm going to be showing you all. So in this case

231
00:16:23,032 --> 00:16:26,674
the build this step is relatively very simple. It's just running docker build

232
00:16:26,792 --> 00:16:30,250
with a particular tag using the image name

233
00:16:30,320 --> 00:16:33,766
variable that would be passed in as part of CI pipeline.

234
00:16:33,958 --> 00:16:37,034
It would be putting in all build arguments that we'd be putting in

235
00:16:37,072 --> 00:16:40,266
as part of the docker build process and then a

236
00:16:40,288 --> 00:16:44,058
parameter called docker file name that tells what the docker

237
00:16:44,074 --> 00:16:47,690
file name is for docker to look and build a container image

238
00:16:47,770 --> 00:16:51,166
from. Step two is running tests. Think of this

239
00:16:51,188 --> 00:16:54,998
as unit tests for your container. The first thing I highlight

240
00:16:55,034 --> 00:16:59,198
here is a CLI command that you may not be familiar with called talks,

241
00:16:59,374 --> 00:17:02,958
and then the rest of that command e test infra

242
00:17:03,054 --> 00:17:06,538
make target environment. That's basically just a way to distinguish

243
00:17:06,654 --> 00:17:09,878
whether the container is suited for dev

244
00:17:09,964 --> 00:17:13,894
or all the way up to production, and then the parameter for

245
00:17:13,932 --> 00:17:17,430
image name as before. Before we get into what talk this,

246
00:17:17,500 --> 00:17:20,678
I also want to talk about the second task in this image,

247
00:17:20,774 --> 00:17:25,222
which is only triggered when the previous task succeeds.

248
00:17:25,366 --> 00:17:28,886
And if it does succeed, you can see that what we do is we effectively

249
00:17:28,918 --> 00:17:32,758
echo. In this particular case, what we're really doing is we're just

250
00:17:32,784 --> 00:17:36,350
setting a variable called test to pass and giving it the value

251
00:17:36,420 --> 00:17:40,346
of true that we will be using in further steps of the CI

252
00:17:40,378 --> 00:17:43,566
pipeline. So what is tox talks is a virtual

253
00:17:43,598 --> 00:17:47,342
environment management and test CLI that relies

254
00:17:47,406 --> 00:17:51,410
on Pytest, which is a Python package, to effectively

255
00:17:51,750 --> 00:17:55,380
run Python code that is comprised of

256
00:17:55,770 --> 00:17:59,990
methods that are test cases. And each test case has assertions.

257
00:18:00,330 --> 00:18:03,254
Let's show an example of what one of those looks like.

258
00:18:03,372 --> 00:18:07,414
Here is one very rudimentary example of what

259
00:18:07,452 --> 00:18:11,238
a file will look like. And you can see, like I described, each method starts

260
00:18:11,254 --> 00:18:14,634
with the def syntax and then we pass

261
00:18:14,672 --> 00:18:17,594
in variables like host like file content,

262
00:18:17,792 --> 00:18:21,658
and then inside of the method we perform the actual assertions.

263
00:18:21,834 --> 00:18:25,370
So the first method tests to see that certain files

264
00:18:25,450 --> 00:18:28,666
exist in the container, the running container

265
00:18:28,698 --> 00:18:32,378
instance. The second test test container running checks

266
00:18:32,394 --> 00:18:36,046
to see if the user that has an active

267
00:18:36,078 --> 00:18:39,474
session in that container is root. Note we just talked

268
00:18:39,512 --> 00:18:43,038
that we don't want to run that we want to run containers as non root.

269
00:18:43,134 --> 00:18:46,694
So I would argue that this assertion should be changed to say process

270
00:18:46,812 --> 00:18:50,182
user is not equal to root. So we give

271
00:18:50,236 --> 00:18:53,714
more freedom in our test case assertions that other users

272
00:18:53,762 --> 00:18:57,394
are allowed but root is not. And then other assertions

273
00:18:57,442 --> 00:19:01,500
include things like testing certain properties on what the host system is,

274
00:19:01,950 --> 00:19:05,082
checking to see, environment variables that are set,

275
00:19:05,216 --> 00:19:08,986
ports that are exposed, or sockets that the container may

276
00:19:09,008 --> 00:19:12,814
be listening on. Again, this is just a place to get

277
00:19:12,852 --> 00:19:16,922
started. Definitely encourage folks to look into additional

278
00:19:16,986 --> 00:19:20,366
assertions that make sense to test to ensure that the

279
00:19:20,388 --> 00:19:23,466
container is properly configured and defined. Next step

280
00:19:23,508 --> 00:19:26,926
is around scanning for vulnerabilities at the container

281
00:19:26,958 --> 00:19:30,734
level. In this example I use a software solution

282
00:19:30,782 --> 00:19:34,306
called trivia and you can see first step is

283
00:19:34,328 --> 00:19:37,766
for me to download and install trivia and all I'm doing here is making an

284
00:19:37,788 --> 00:19:41,170
HTTP request to install the DBM package

285
00:19:41,250 --> 00:19:45,330
and ensure that trivia got successfully installed.

286
00:19:45,490 --> 00:19:49,110
The second task is where things get interesting. I'm running

287
00:19:49,180 --> 00:19:52,938
two scans using trivia. The first scan in the

288
00:19:53,104 --> 00:19:56,886
first portion of the line there in the script is effectively telling trivia

289
00:19:56,918 --> 00:20:00,602
to pass the pipelines even if it finds vulnerabilities with severity

290
00:20:00,666 --> 00:20:04,938
low and medium when targeting a particular image repository

291
00:20:05,034 --> 00:20:08,030
and a particular image tag version.

292
00:20:08,450 --> 00:20:11,950
The second scan, however, will fail a pipeline

293
00:20:12,450 --> 00:20:15,746
if the severity if it detects any severities at

294
00:20:15,768 --> 00:20:19,662
the high or critical level. Again, this is subject

295
00:20:19,726 --> 00:20:23,266
to risk tolerance based on the industry and the team and

296
00:20:23,288 --> 00:20:27,074
the particular solution on our development. But I definitely would encourage

297
00:20:27,122 --> 00:20:30,706
individuals to side on the air of caution and ensure

298
00:20:30,738 --> 00:20:34,706
that there are no high nor critical vulnerabilities in the container

299
00:20:34,738 --> 00:20:39,222
dependencies here's an example of what a test

300
00:20:39,356 --> 00:20:43,082
vulnerability report from preview looks like. I've highlighted the key things

301
00:20:43,136 --> 00:20:46,426
just to keep an eye on. You'll see the total number of vulnerabilities and their

302
00:20:46,448 --> 00:20:49,526
classifications, and then at the bottom you see a table

303
00:20:49,638 --> 00:20:53,770
with really rich information around what's the dependency or library

304
00:20:53,930 --> 00:20:57,562
specific vulnerability id, its severity, the installed

305
00:20:57,626 --> 00:21:01,502
version that it was found, and then trivia actually goes

306
00:21:01,556 --> 00:21:05,058
and searches its data, sets its database to see

307
00:21:05,144 --> 00:21:08,546
what is the fixed version where that vulnerability is no longer in

308
00:21:08,568 --> 00:21:12,462
place, further exposing you and the team to decide

309
00:21:12,606 --> 00:21:15,910
how to fix the vulnerabilities. Here are more

310
00:21:15,980 --> 00:21:19,414
example scanning tools that I encourage you to look into.

311
00:21:19,532 --> 00:21:23,190
That includes Aqua sonar, cube, white source.

312
00:21:23,610 --> 00:21:27,458
The next step is around versioning and publishing the image. Now I'm

313
00:21:27,474 --> 00:21:31,100
going to break this down by first saying there's two parts to this.

314
00:21:31,630 --> 00:21:35,034
In my experience, it's worthwhile to publish even the images that

315
00:21:35,072 --> 00:21:38,982
failed previous tests. And the reason for that is it makes it easier

316
00:21:39,046 --> 00:21:42,970
for a subset of consumers to download those failed images

317
00:21:43,050 --> 00:21:46,382
and troubleshoot them, patch them, fix them,

318
00:21:46,436 --> 00:21:50,266
and then publish the code changes to fix it to the true repository.

319
00:21:50,458 --> 00:21:54,494
Now the caveat here is just like how we talked about many different keys.

320
00:21:54,622 --> 00:21:58,446
That needs to be a different key that grants a unique

321
00:21:58,558 --> 00:22:02,530
repository in that registry called effectively failed,

322
00:22:03,430 --> 00:22:06,230
with some form of like a failed syntax or indicator.

323
00:22:06,570 --> 00:22:10,338
That's what we're doing in the first highlighted section of this image.

324
00:22:10,514 --> 00:22:14,034
We're effectively on a test passed,

325
00:22:14,082 --> 00:22:17,942
variable value being set to false, which would happen if the

326
00:22:17,996 --> 00:22:21,754
vulnerabilities can, or if the talks test

327
00:22:21,872 --> 00:22:25,194
failed, we would set that to false. Now we will run

328
00:22:25,232 --> 00:22:28,860
a script to create a tag for that image and

329
00:22:29,230 --> 00:22:32,958
append at the very end of it the failed value

330
00:22:33,044 --> 00:22:36,426
as seen near the top of the images. After we've

331
00:22:36,458 --> 00:22:39,882
tagged that image appropriately, the failed images, we now publish

332
00:22:39,946 --> 00:22:43,590
that image. And again, the condition here in Asto. That syntax is effectively

333
00:22:43,610 --> 00:22:47,298
the same as before and all we're doing here is pushing it

334
00:22:47,384 --> 00:22:51,890
to the proper repository with a proper suffix.

335
00:22:52,550 --> 00:22:56,630
Now what's key here is just I wanted to call out for you the

336
00:22:56,780 --> 00:23:00,354
CI credentials that's being used to authenticate the CI pipeline

337
00:23:00,402 --> 00:23:03,394
with the registry is in Azure DevOps,

338
00:23:03,442 --> 00:23:06,658
found using this parameter called service connection.

339
00:23:06,834 --> 00:23:09,926
Just want to mention that it's specific to Azure DevOps, but just want

340
00:23:09,948 --> 00:23:13,462
to make sure that we are still doing this securely for all these examples.

341
00:23:13,606 --> 00:23:17,354
The continuation is now to also publish the happy path if

342
00:23:17,392 --> 00:23:20,726
an image passed all the way through, we want to make sure that we tag

343
00:23:20,758 --> 00:23:24,526
that image appropriately and you can see that that's taken place in

344
00:23:24,548 --> 00:23:28,142
the first task at the top and we're using a value called

345
00:23:28,196 --> 00:23:32,190
latest to give it a name called latest for that version.

346
00:23:32,550 --> 00:23:37,182
The middle task is effectively pushing

347
00:23:37,246 --> 00:23:40,686
the docker image, but using a parameter image

348
00:23:40,718 --> 00:23:44,354
tag instead of the value latest. Here you can

349
00:23:44,392 --> 00:23:47,638
decide to use the conventions such as major

350
00:23:47,804 --> 00:23:51,782
minor minor minor, or use a convention that

351
00:23:51,836 --> 00:23:55,782
maps the CI build guid or job

352
00:23:55,836 --> 00:23:59,754
id to that image as well. I've seen both options work

353
00:23:59,792 --> 00:24:03,178
pretty well in my experience. The bottom

354
00:24:03,264 --> 00:24:07,098
task publishes the same image, but now publish it

355
00:24:07,264 --> 00:24:10,826
using the latest tag or the latest version

356
00:24:10,938 --> 00:24:14,334
label. Now I caution to use

357
00:24:14,372 --> 00:24:18,266
this just because it is prone to more convenience, but it's

358
00:24:18,298 --> 00:24:22,590
also prone to having less control covers. How large

359
00:24:22,660 --> 00:24:26,254
the impact is if that docker image did in fact contain

360
00:24:26,302 --> 00:24:31,026
a vulnerability that just sneaked through that was missed because

361
00:24:31,128 --> 00:24:35,140
if latest is available, consumers will typically opt to do

362
00:24:35,990 --> 00:24:40,070
convenience and use latest, and you may find that you have a lot wider

363
00:24:40,570 --> 00:24:44,006
number of users that may be impacted if you were

364
00:24:44,028 --> 00:24:47,474
to push a vulnerability to latest versus pushing it to a very

365
00:24:47,532 --> 00:24:51,654
specific version as is done in the middle task.

366
00:24:51,782 --> 00:24:55,466
The next phase and last phase in our cycle is around

367
00:24:55,568 --> 00:24:59,494
best practices when securing the production environment that uses

368
00:24:59,542 --> 00:25:03,038
containers. The first best practice I want to

369
00:25:03,044 --> 00:25:05,470
share is the concept around network segmentation,

370
00:25:05,970 --> 00:25:09,534
specifically in your own time. I encourage to read up on

371
00:25:09,572 --> 00:25:13,046
a concept called nanosegmentation when working with containers.

372
00:25:13,098 --> 00:25:16,962
Just like with any other infrastructure, it can be pretty

373
00:25:17,016 --> 00:25:20,178
segmented and locked down to have security

374
00:25:20,264 --> 00:25:23,762
policies that limit who can connect to it as well as

375
00:25:23,816 --> 00:25:27,414
limit what other infrastructure that component can connect

376
00:25:27,452 --> 00:25:30,822
to. So with containers we're going to do the same thing.

377
00:25:30,956 --> 00:25:34,486
We want to wrap containers around a subnet or even

378
00:25:34,668 --> 00:25:38,022
be more nano about it, and wrap individual containers

379
00:25:38,086 --> 00:25:41,546
within multiple subnets so that

380
00:25:41,568 --> 00:25:45,114
it's further segmented and have pretty strict policies in place

381
00:25:45,152 --> 00:25:48,874
to limit what can connect to it and what

382
00:25:48,912 --> 00:25:52,366
the container subnets can connect to. Again, this is

383
00:25:52,388 --> 00:25:55,934
great to minimize the potential impact radius if

384
00:25:55,972 --> 00:25:59,610
there was in fact a vulnerability that was exploited

385
00:25:59,690 --> 00:26:03,282
with that infrastructure or that container. Next up is

386
00:26:03,336 --> 00:26:07,218
a great preventative measure to prevent denial of service or

387
00:26:07,304 --> 00:26:11,298
a depletion of container resources, and that is

388
00:26:11,384 --> 00:26:14,802
setting resource quotas. By default, containers have

389
00:26:14,856 --> 00:26:18,326
no resource contain. So if a running container was

390
00:26:18,348 --> 00:26:21,926
hijacked and for some reason it started really consuming all

391
00:26:21,948 --> 00:26:25,110
the cpu, memory or other infrastructure resource,

392
00:26:26,650 --> 00:26:30,202
it could deplete all of it. So the example I show here is

393
00:26:30,256 --> 00:26:33,866
how we can use kubernetes. The same can

394
00:26:33,888 --> 00:26:37,082
be done with Docker as well. But in my example here I show

395
00:26:37,136 --> 00:26:40,862
how I do it with kubernetes to limit at each

396
00:26:40,916 --> 00:26:44,240
either namespace or at the container level,

397
00:26:44,610 --> 00:26:48,254
what is the default number of cpu and

398
00:26:48,292 --> 00:26:52,122
memory allocated to each container, and what is the maximum

399
00:26:52,186 --> 00:26:55,694
that can be granted to that container. Another best practice

400
00:26:55,742 --> 00:26:59,406
is around continuous container monitoring.

401
00:26:59,518 --> 00:27:03,614
There's three pieces to that environment, hardening, vulnerability assessment,

402
00:27:03,662 --> 00:27:08,098
and runtime threat protection for nodes and cluster environment hardening

403
00:27:08,194 --> 00:27:12,306
is effectively any solution that performs container monitoring,

404
00:27:12,418 --> 00:27:15,974
such as Azure. Microsoft defender for container should

405
00:27:16,012 --> 00:27:19,738
provide these three solutions environment hardening checks to

406
00:27:19,744 --> 00:27:22,906
see if there's any misconfigurations or configurations that

407
00:27:22,928 --> 00:27:26,186
are not secure. For example,

408
00:27:26,288 --> 00:27:29,386
if there are no resource quotas, Microsoft Defender would

409
00:27:29,408 --> 00:27:32,670
flag that as a vulnerability in its continuous monitoring.

410
00:27:33,410 --> 00:27:36,766
Vulnerability assessments performs the same thing we did earlier in our

411
00:27:36,788 --> 00:27:40,922
CI pipeline and just scans for vulnerabilities in container image

412
00:27:40,986 --> 00:27:45,226
dependencies. But why do we will need to do that again and continuously?

413
00:27:45,338 --> 00:27:48,706
Well, the reason for that is vulnerabilities can come up at any point in

414
00:27:48,728 --> 00:27:51,794
time in the future. Not all vulnerabilities are known from the get

415
00:27:51,832 --> 00:27:55,442
go. So as you have images that pass vulnerability

416
00:27:55,506 --> 00:27:59,558
scans and now they're in the registry and they have running

417
00:27:59,644 --> 00:28:02,994
instances or solutions from those images.

418
00:28:03,122 --> 00:28:06,566
You want the ability for a platform to be

419
00:28:06,588 --> 00:28:10,378
able to continuously run vulnerability scans and map any

420
00:28:10,544 --> 00:28:14,486
vulnerabilities to actively running containers

421
00:28:14,598 --> 00:28:18,870
so that you as a team can determine how to best mitigate

422
00:28:18,950 --> 00:28:23,566
and minimize the chances of security issues.

423
00:28:23,748 --> 00:28:26,298
And then the last piece is runtime threat protection,

424
00:28:26,394 --> 00:28:29,774
which ultimately will scan the behavior of each

425
00:28:29,812 --> 00:28:32,742
running container and just raise any anomalies,

426
00:28:32,906 --> 00:28:36,754
whether it's the container doing a highly privileged operation like

427
00:28:36,792 --> 00:28:40,514
user management at the cloud level or

428
00:28:40,552 --> 00:28:45,026
at the active directory level, or whether it's the

429
00:28:45,048 --> 00:28:48,806
container performing a highly privileged operation against some

430
00:28:48,828 --> 00:28:52,594
other core piece of infrastructure that it supposedly typically

431
00:28:52,642 --> 00:28:55,686
has not done before. So any deviations in behavior would also be

432
00:28:55,708 --> 00:28:59,402
flagged in this slide, I encourage you to look up what

433
00:28:59,456 --> 00:29:03,770
Azure's container protector tool offers and

434
00:29:03,920 --> 00:29:07,626
what it checks against, and the particular link that you'll be able to look in

435
00:29:07,648 --> 00:29:10,614
your own time is center for threat informed defense.

436
00:29:10,662 --> 00:29:14,400
Teaming up with Microsoft to really build the notion of

437
00:29:15,330 --> 00:29:19,434
the attack container matrix that outlines all of these different checks

438
00:29:19,482 --> 00:29:23,854
that are performed by these tools as part of runtime threat detection.

439
00:29:23,982 --> 00:29:27,886
Here I wanted to provide a sample vulnerability assessment provided

440
00:29:27,918 --> 00:29:31,278
by the Azure container Defender solution,

441
00:29:31,374 --> 00:29:35,606
and you'll see, as I highlighted here, it does surface certain

442
00:29:35,788 --> 00:29:39,190
infrastructure misconfigurations. It surfaces

443
00:29:39,690 --> 00:29:43,846
things like active container image with running instances that

444
00:29:43,868 --> 00:29:47,794
have vulnerabilities installed and then also checks for kubernetes

445
00:29:47,842 --> 00:29:51,554
to see that it has certain azure policies enabled for further

446
00:29:51,602 --> 00:29:55,210
protection. Couple resources I also want to share here

447
00:29:55,360 --> 00:29:58,934
the top right or top left QR is Microsoft's commercial software

448
00:29:58,982 --> 00:30:02,554
engineering playbook. As it states in the slide,

449
00:30:02,602 --> 00:30:06,730
this is a collection of fundamentals, frameworks, just general best practices

450
00:30:06,810 --> 00:30:10,542
and examples that both myself and many other

451
00:30:10,596 --> 00:30:14,302
individuals have contributed to over the years. It's open sourced,

452
00:30:14,366 --> 00:30:17,634
so we continue updating this as

453
00:30:17,832 --> 00:30:21,374
better practices or new best practices are surfaced

454
00:30:21,502 --> 00:30:25,054
and in the bottom left or bottom right QR code is our open

455
00:30:25,112 --> 00:30:28,454
source for dev containers. I really like to share

456
00:30:28,492 --> 00:30:32,374
this out because it offers a great storing place on what

457
00:30:32,572 --> 00:30:36,002
good practice well defined docker images

458
00:30:36,066 --> 00:30:39,834
look like. Dev containers are a little more specific in nature as that

459
00:30:39,872 --> 00:30:43,926
allows vs code to run within a containerized environment,

460
00:30:44,038 --> 00:30:47,100
but that's another story for another day.

461
00:30:47,630 --> 00:30:51,206
Great resource just to look at best practices on Docker container

462
00:30:51,238 --> 00:30:55,930
or container image definitions and that wraps up our entire lifecycle.

463
00:30:56,290 --> 00:31:00,346
If anything, I really want to share five key takeaways.

464
00:31:00,538 --> 00:31:03,806
One is make sure that the entire team has awareness on

465
00:31:03,828 --> 00:31:07,154
container developers practices. It's going to make them feel

466
00:31:07,192 --> 00:31:10,846
more bought in, more informed and educated versus making it seem

467
00:31:10,878 --> 00:31:14,226
like it's just a lot more requirements and work that is being brought down to

468
00:31:14,248 --> 00:31:18,258
the team. Second, enforce RBAC policies

469
00:31:18,434 --> 00:31:21,926
to prevent individuals from disabling control gates at

470
00:31:21,948 --> 00:31:25,266
the CI pipeline level. This tends

471
00:31:25,298 --> 00:31:27,926
to be something that's overlooked in my experience,

472
00:31:28,108 --> 00:31:31,894
and it is a vulnerability where if a developer

473
00:31:31,942 --> 00:31:35,306
or a team is really in a rush mode, they might

474
00:31:35,328 --> 00:31:38,586
want to disable contain control gates that are there for a good reason.

475
00:31:38,688 --> 00:31:42,574
So really limit who can manage those

476
00:31:42,612 --> 00:31:46,266
control gates and limit individuals

477
00:31:46,298 --> 00:31:50,014
that can perform those operations. Third, hold all members

478
00:31:50,052 --> 00:31:53,522
of the team accountable for adhering to secure container management and

479
00:31:53,576 --> 00:31:57,138
make sure that they know that they can hold each other accountable as well.

480
00:31:57,304 --> 00:32:01,140
After all, security is a team effort and everyone

481
00:32:03,430 --> 00:32:07,010
is responsible for raising

482
00:32:07,090 --> 00:32:11,286
issues and or covers. Fourth is depending on the

483
00:32:11,308 --> 00:32:15,666
level of maturity around developers that you are experienced

484
00:32:15,698 --> 00:32:19,670
with or working in, there may be need to influence

485
00:32:19,750 --> 00:32:23,494
change. And like all things that require

486
00:32:23,542 --> 00:32:27,242
influencing, it's most effective when done as a community and

487
00:32:27,296 --> 00:32:30,640
when individuals connect business,

488
00:32:31,010 --> 00:32:34,046
the business mission and the business success criteria to

489
00:32:34,148 --> 00:32:37,806
these principles of security as well. And last but not least is probably

490
00:32:37,828 --> 00:32:39,150
one of my favorites.

491
00:32:41,250 --> 00:32:44,866
Decisions are all about ratios between convenience and

492
00:32:44,888 --> 00:32:48,110
security and there is no servo bullet.

493
00:32:48,270 --> 00:32:51,422
Everything needs to be custom tailored based on industry,

494
00:32:51,486 --> 00:32:54,786
based on solution, based on who the containers are.

495
00:32:54,888 --> 00:32:58,534
But one of the key thing that I've learned in my experience is

496
00:32:58,652 --> 00:33:02,578
especially when starting off at the beginning, weigh security heavier

497
00:33:02,754 --> 00:33:06,002
and covers time, you'll find that it's less costly

498
00:33:06,066 --> 00:33:09,794
and easier to shift the balances to find the right ratio

499
00:33:09,842 --> 00:33:13,282
between convenience and security. And the reason it's less costly

500
00:33:13,346 --> 00:33:16,562
is because if we were to shift that and weigh convenience

501
00:33:16,626 --> 00:33:20,142
heavier over security at the beginning, that is set

502
00:33:20,236 --> 00:33:23,998
up a potential for a vulnerability to be exploited and for there to

503
00:33:24,004 --> 00:33:27,246
be a data breach or some other type of attack.

504
00:33:27,428 --> 00:33:30,778
And with that, I'd like to conclude by thanking you all for attending

505
00:33:30,874 --> 00:33:34,622
and wish everyone continue having a safe rest

506
00:33:34,676 --> 00:33:37,998
of the calendar year. And in case we don't get to touch base

507
00:33:38,084 --> 00:33:42,254
later, wish everyone a happy new year in 2023.

508
00:33:42,372 --> 00:33:42,780
Thank you.

