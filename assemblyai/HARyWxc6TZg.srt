1
00:00:25,730 --> 00:00:28,790
Hello everyone and welcome to this session.

2
00:00:29,530 --> 00:00:33,074
My name is Luis Cardoza Bird. I'm a mobile

3
00:00:33,122 --> 00:00:37,426
developer and go developer. And also I'm the co founder

4
00:00:37,618 --> 00:00:41,586
of this software technology company named Devotion.

5
00:00:41,778 --> 00:00:45,526
In this meeting, we're going to be talking about building blockchains on

6
00:00:45,548 --> 00:00:48,786
the go using GrPC.

7
00:00:48,978 --> 00:00:51,280
Okay, so before everything,

8
00:00:51,650 --> 00:00:55,838
before everything else, we need to do some

9
00:00:56,004 --> 00:00:59,086
clarification related to why we are going

10
00:00:59,108 --> 00:01:03,470
to use go and also why we are going to be using GrPC.

11
00:01:03,830 --> 00:01:07,860
But first, I'm using to do a little presentation about myself.

12
00:01:09,750 --> 00:01:12,850
As I say previously, my name is Carlos Albert.

13
00:01:13,590 --> 00:01:18,598
This is my email. If you have any doubt of want

14
00:01:18,604 --> 00:01:22,182
to ask me something, please feel free

15
00:01:22,236 --> 00:01:25,974
to contact me in any

16
00:01:26,012 --> 00:01:31,194
way possible. So with

17
00:01:31,232 --> 00:01:34,140
that fulfilled, we can continue.

18
00:01:34,910 --> 00:01:39,034
Okay, so before we start, we need to

19
00:01:39,232 --> 00:01:42,622
think on some steps just

20
00:01:42,676 --> 00:01:46,400
to clarify everything. The first thing is,

21
00:01:46,770 --> 00:01:48,270
what is blockchain?

22
00:01:49,970 --> 00:01:53,458
Then we come to the second step. And that is,

23
00:01:53,624 --> 00:01:56,850
why are we choosing go from all

24
00:01:56,920 --> 00:02:00,370
the other programming language like node, JS,

25
00:02:00,790 --> 00:02:03,780
Rust, Ruby, C,

26
00:02:04,310 --> 00:02:08,402
C sharp, Python? Why are we choosing

27
00:02:08,466 --> 00:02:11,846
go as our main language to develop a

28
00:02:11,868 --> 00:02:15,480
blockchain distribution? The third step,

29
00:02:16,970 --> 00:02:18,470
what is GrPC?

30
00:02:20,350 --> 00:02:24,620
And finally, we definitely

31
00:02:25,310 --> 00:02:27,770
aren't going to be doing a code session.

32
00:02:29,950 --> 00:02:32,640
We aren't going to be doing an example.

33
00:02:33,330 --> 00:02:37,694
I'm just joking. We're going to do a little example about

34
00:02:37,732 --> 00:02:41,966
how to create our own

35
00:02:42,068 --> 00:02:46,286
blockchain distribution using microservice with GrPC.

36
00:02:46,478 --> 00:02:50,500
Okay, so with this

37
00:02:51,510 --> 00:02:55,860
we go to the first thing, how blockchain works.

38
00:02:56,870 --> 00:02:59,342
As many of you can imagine,

39
00:02:59,486 --> 00:03:03,350
blockchains you can imagine as a little cube.

40
00:03:03,690 --> 00:03:07,302
However, blockchain is living

41
00:03:07,356 --> 00:03:12,954
aside all that complex theory that most

42
00:03:12,992 --> 00:03:17,274
of the blogs or web or website or

43
00:03:17,312 --> 00:03:21,390
even videos talk about. We can simplify

44
00:03:23,010 --> 00:03:26,014
everything related to blockchain into this.

45
00:03:26,212 --> 00:03:29,738
Just imagine a simple block. This block.

46
00:03:29,914 --> 00:03:34,050
It has three layers. We have the data layer that

47
00:03:34,120 --> 00:03:37,490
is going to be storing

48
00:03:38,710 --> 00:03:42,702
any kind of information. We have another layer named

49
00:03:42,766 --> 00:03:46,982
the hash layer. And also we have

50
00:03:47,116 --> 00:03:50,546
another layer named the previous hash.

51
00:03:50,738 --> 00:03:54,680
These three components are needed to

52
00:03:55,290 --> 00:03:58,250
build a single block,

53
00:03:58,990 --> 00:04:02,822
just a block, not a blockchain. The term blockchain,

54
00:04:02,886 --> 00:04:06,854
as it say, by itself, is just multiple

55
00:04:06,902 --> 00:04:12,222
blocks that are nested one

56
00:04:12,276 --> 00:04:15,710
with another. So, continuing we have

57
00:04:15,780 --> 00:04:19,760
this example. We have our cube, its name,

58
00:04:20,290 --> 00:04:23,938
the Genesis block. Why Genesis block? Because it's going

59
00:04:23,944 --> 00:04:27,380
to be the root, the origin,

60
00:04:28,470 --> 00:04:32,420
the alpha, the beginning, the beginning of everything.

61
00:04:33,030 --> 00:04:36,546
So in this case, we have our Genesis

62
00:04:36,578 --> 00:04:38,680
block and it say, okay,

63
00:04:39,850 --> 00:04:43,000
we have data and is 1000.

64
00:04:43,450 --> 00:04:46,678
So the data on the genesis is going

65
00:04:46,684 --> 00:04:49,622
to be 1000. The hash,

66
00:04:49,766 --> 00:04:53,066
in this case, the previous hash, it doesn't have

67
00:04:53,168 --> 00:04:56,442
any hash. So in this case we can

68
00:04:56,496 --> 00:05:03,382
set up a hard code hash name and

69
00:05:03,456 --> 00:05:07,294
at the end the whole block we applies any

70
00:05:07,332 --> 00:05:10,110
kind of encryption. RSA,

71
00:05:10,530 --> 00:05:13,726
PBKDF, argon, two,

72
00:05:13,908 --> 00:05:17,278
any kind of encryption. It can work.

73
00:05:17,444 --> 00:05:20,718
So the third step, name encrypted,

74
00:05:20,814 --> 00:05:24,530
is just any type of encryption technique

75
00:05:24,970 --> 00:05:28,854
that you like the most. Okay, so with our

76
00:05:28,892 --> 00:05:32,770
Genesis block, we can build a second block.

77
00:05:32,930 --> 00:05:36,534
This second block, it has the

78
00:05:36,572 --> 00:05:40,118
same characteristic as the Genesis block.

79
00:05:40,294 --> 00:05:44,166
We have the data. In this case, we are storing blockchains

80
00:05:44,198 --> 00:05:48,010
of just integer numbers. In this case we have

81
00:05:48,080 --> 00:05:52,462
block 1001. This 1001

82
00:05:52,516 --> 00:05:55,822
is the data. We have the previous data.

83
00:05:55,956 --> 00:05:59,182
That is, the previous hash in this case is

84
00:05:59,316 --> 00:06:02,710
1000. Obviously, the previous

85
00:06:02,810 --> 00:06:06,146
value that we're going to be presenting in this case is going

86
00:06:06,168 --> 00:06:10,434
to be the encrypted value. But just

87
00:06:10,472 --> 00:06:13,060
for demonstrate how it works,

88
00:06:13,590 --> 00:06:17,474
I'm just displaying you the information unencrypted.

89
00:06:17,602 --> 00:06:21,254
And finally, the final layer is the

90
00:06:21,292 --> 00:06:25,062
hash layer. That in this case is just the

91
00:06:25,116 --> 00:06:29,398
encryption. Or if we can say it better, is the combination

92
00:06:29,494 --> 00:06:34,090
of the information on the data layer plus

93
00:06:34,240 --> 00:06:38,534
the information of the previous layer and also added

94
00:06:38,582 --> 00:06:42,458
the information of the encryption

95
00:06:42,634 --> 00:06:45,200
of the whole block. And with that,

96
00:06:46,050 --> 00:06:49,678
we already are building a blockchain and

97
00:06:49,844 --> 00:06:53,386
the same process apply for all the other blocks

98
00:06:53,418 --> 00:06:56,514
that are going to be building. So in this case,

99
00:06:56,552 --> 00:06:59,522
for example, block 1001, block 1002,

100
00:06:59,576 --> 00:07:03,666
if you can see the process, is the same. It's an

101
00:07:03,688 --> 00:07:07,366
iterative process, it isn't going to change. However,

102
00:07:07,468 --> 00:07:11,270
there is a special case. If you can see here

103
00:07:11,420 --> 00:07:13,080
block 1000,

104
00:07:14,970 --> 00:07:19,002
the data is needed to build the second

105
00:07:19,056 --> 00:07:21,354
block. This is the block 1001.

106
00:07:21,392 --> 00:07:24,794
And the block 1001 is

107
00:07:24,832 --> 00:07:28,010
also needed to build the next block.

108
00:07:28,670 --> 00:07:31,360
That is the block 1002.

109
00:07:32,690 --> 00:07:35,840
But there is a special case.

110
00:07:36,690 --> 00:07:40,062
What is that? For example, if we decide to move,

111
00:07:40,196 --> 00:07:43,538
or for example, if we for any reason

112
00:07:43,704 --> 00:07:47,186
move one block from the third position to

113
00:07:47,208 --> 00:07:50,834
the second one, the blockchain by

114
00:07:50,872 --> 00:07:53,620
itself isn't going to be matching the data.

115
00:07:53,990 --> 00:07:57,654
And that's the special thing about blockchains, the security

116
00:07:57,772 --> 00:08:01,206
that brings by itself. Because when a

117
00:08:01,228 --> 00:08:04,920
hacker try to access to the information,

118
00:08:05,530 --> 00:08:09,690
the hacker needs to decrypt all

119
00:08:09,840 --> 00:08:12,700
the blocks that the system has.

120
00:08:13,550 --> 00:08:16,634
But in this case, he will never going to be.

121
00:08:16,672 --> 00:08:20,174
Or, well, if don't say better. It's going to be

122
00:08:20,212 --> 00:08:23,774
really difficult if we

123
00:08:23,812 --> 00:08:27,486
say it may be impossible to retrieve all

124
00:08:27,588 --> 00:08:30,734
those blocks and also to retrieve the

125
00:08:30,772 --> 00:08:33,938
Genesis block. That this block is a special

126
00:08:34,024 --> 00:08:38,194
block because it has

127
00:08:38,312 --> 00:08:41,474
all the necessary information to

128
00:08:41,512 --> 00:08:45,378
start building the next generation of blocks. So as you

129
00:08:45,384 --> 00:08:48,454
can see, if for some

130
00:08:48,492 --> 00:08:51,670
reason we have block 1002. Yes,

131
00:08:51,740 --> 00:08:55,442
it matched with the previous data. However, with the next block

132
00:08:55,586 --> 00:08:59,830
it say, hey, wait a minute, this is bad because

133
00:08:59,900 --> 00:09:03,500
this block, the term one block 1002

134
00:09:04,270 --> 00:09:08,070
can do any kind of matching with the previous

135
00:09:08,150 --> 00:09:11,278
block. So the block 1002

136
00:09:11,444 --> 00:09:13,840
is bad, it's wrong.

137
00:09:14,290 --> 00:09:19,694
So that is the main reason why blockchain is

138
00:09:19,732 --> 00:09:24,100
currently being adopted by more companies, by more

139
00:09:24,790 --> 00:09:28,546
software projects, because all those benefits

140
00:09:28,648 --> 00:09:32,498
that come by itself. However, there's just

141
00:09:32,664 --> 00:09:35,640
one little thing that we need to make clear.

142
00:09:36,250 --> 00:09:39,526
Blockchain, by itself it counts as a

143
00:09:39,548 --> 00:09:44,130
database. So if you like to implement blockchains

144
00:09:44,210 --> 00:09:47,898
with a database, it's kind of difficult

145
00:09:47,984 --> 00:09:51,594
because the structure of blockchain is just

146
00:09:51,632 --> 00:09:55,654
to store information. And obviously a database stores

147
00:09:55,702 --> 00:09:59,258
information, but in a more complex way. However,

148
00:09:59,344 --> 00:10:03,054
blockchain, it can be used to more simplified data,

149
00:10:03,172 --> 00:10:07,280
for example, user credentials or

150
00:10:07,650 --> 00:10:10,766
user information, those kind of things.

151
00:10:10,948 --> 00:10:14,802
And that's the main benefit. Okay, moving on.

152
00:10:14,856 --> 00:10:17,810
We have the compiler about, well,

153
00:10:17,880 --> 00:10:21,742
Golan in this case. Why are we choosing

154
00:10:21,806 --> 00:10:24,958
Golan? The first thing is because Golan,

155
00:10:25,054 --> 00:10:28,920
the learning curve is really, really low,

156
00:10:29,290 --> 00:10:33,560
is a language that is easy to learn,

157
00:10:34,970 --> 00:10:38,154
if I can say the easiest language that

158
00:10:38,192 --> 00:10:41,754
we can learn. And also it has the

159
00:10:41,872 --> 00:10:45,110
big benefits of the compiler. This compiler,

160
00:10:45,190 --> 00:10:48,570
it works like you code once and it's going to run

161
00:10:48,640 --> 00:10:51,950
everywhere on every platform and

162
00:10:52,020 --> 00:10:55,914
every architecture, Windows 32 bits, 64 bits,

163
00:10:55,962 --> 00:10:58,080
Linux 32, 64,

164
00:10:58,450 --> 00:11:03,234
macOS, any kind of

165
00:11:03,272 --> 00:11:04,420
creating system.

166
00:11:07,430 --> 00:11:10,914
The final thing is, and also Golang is

167
00:11:10,952 --> 00:11:13,810
a static and strongly typed language.

168
00:11:16,490 --> 00:11:19,800
There isn't going to be more than one solution. However,

169
00:11:20,330 --> 00:11:24,326
the most used solution is going to be always the

170
00:11:24,348 --> 00:11:27,906
correct one. So go by itself, it brings

171
00:11:27,938 --> 00:11:30,170
you a lot of benefits. The compiler,

172
00:11:31,070 --> 00:11:36,202
the easy code, and also the

173
00:11:36,336 --> 00:11:40,070
static and strongly type language. And also,

174
00:11:40,160 --> 00:11:43,934
finally, we have the best thing of go,

175
00:11:44,052 --> 00:11:48,010
and that is the go routines that is basically using native

176
00:11:48,090 --> 00:11:52,560
threads. However can be combined with

177
00:11:52,930 --> 00:11:56,870
any kind of other threads, native trap

178
00:11:57,050 --> 00:12:02,674
and well, it can notify by itself to

179
00:12:02,712 --> 00:12:06,610
any kind of truth brothers or even the main threat.

180
00:12:06,970 --> 00:12:10,918
So these are some of

181
00:12:11,084 --> 00:12:14,662
all the benefits that go give you by itself.

182
00:12:14,796 --> 00:12:17,814
The next thing is GrPC. First of all,

183
00:12:17,852 --> 00:12:21,062
GrPC is a framework. We can resume

184
00:12:21,126 --> 00:12:24,458
everything on four things. Those are going

185
00:12:24,464 --> 00:12:27,930
to be the first thing is it has a high quality

186
00:12:28,000 --> 00:12:31,598
HTTP connection. But what I say about high quality

187
00:12:31,684 --> 00:12:36,010
HTTP is most of HTTP connection.

188
00:12:36,170 --> 00:12:39,822
As you know, maybe on some of your

189
00:12:39,876 --> 00:12:44,002
projects, personal project, or on

190
00:12:44,056 --> 00:12:47,506
some business software development. For any

191
00:12:47,528 --> 00:12:51,346
of you that have developed APIs, you know that

192
00:12:51,448 --> 00:12:54,866
by itself, the API, all the connection that has been done

193
00:12:54,968 --> 00:12:58,410
is using HTTP one. However, your pc,

194
00:12:58,590 --> 00:13:03,302
inject a little upgrade into that

195
00:13:03,356 --> 00:13:07,302
connection method and upgrade it to the HTTP two,

196
00:13:07,436 --> 00:13:12,258
that it brings you a better performance and also whole

197
00:13:12,364 --> 00:13:16,266
more clear results from end to end.

198
00:13:16,448 --> 00:13:19,654
The second one is framework,

199
00:13:19,782 --> 00:13:22,960
really easy to understand. We are going to see it on the example.

200
00:13:23,410 --> 00:13:26,782
The third one, the change that we are going to be doing

201
00:13:26,836 --> 00:13:30,554
on GrPC are easy to change because GrPC

202
00:13:30,602 --> 00:13:34,020
by itself is going to be segmentating everything

203
00:13:34,550 --> 00:13:38,082
on minimally service and

204
00:13:38,136 --> 00:13:41,246
those services can be rearranged,

205
00:13:41,358 --> 00:13:44,986
restructured without us to be changing

206
00:13:45,118 --> 00:13:48,454
or without us to be doing a lot of change on

207
00:13:48,492 --> 00:13:51,522
the server or on the client apps.

208
00:13:51,666 --> 00:13:55,394
And finally we have the assist that GrPC

209
00:13:55,442 --> 00:13:58,470
brings us that is most of testing,

210
00:13:58,550 --> 00:14:01,930
inspection and modification thanks to the

211
00:14:02,000 --> 00:14:05,242
protocol buffer that is being used

212
00:14:05,296 --> 00:14:08,682
by default on your pc. This is the

213
00:14:08,736 --> 00:14:12,794
kind of thing that maybe you are used to. For example rest API

214
00:14:12,842 --> 00:14:15,962
as I said previously, is based on HTTP,

215
00:14:16,026 --> 00:14:19,930
one that is added with reserves

216
00:14:20,010 --> 00:14:23,742
and that services. We are going to be using JSOn to

217
00:14:23,876 --> 00:14:27,614
fetch and send information. However your

218
00:14:27,652 --> 00:14:31,906
pc, most of the

219
00:14:32,008 --> 00:14:34,926
developers think that it's related to Google,

220
00:14:35,048 --> 00:14:38,758
but no it isn't. Well, the g change

221
00:14:38,924 --> 00:14:42,214
on each upgrade, sometimes it's good,

222
00:14:42,412 --> 00:14:46,102
great, genius, but never

223
00:14:46,156 --> 00:14:49,634
Google. And the GrPC is based on a remote

224
00:14:49,682 --> 00:14:53,830
procedural call. The GrPC is a combination

225
00:14:53,910 --> 00:14:57,546
between HTTP two remote procedural call

226
00:14:57,648 --> 00:15:01,614
and also protocol buffer. Actually is kind of

227
00:15:01,652 --> 00:15:04,814
easy. So with this

228
00:15:04,852 --> 00:15:07,758
presentation done, we can do a little code example.

229
00:15:07,924 --> 00:15:11,166
In this case we're going to be using go

230
00:15:11,268 --> 00:15:14,982
and the mission is going to be develop a blockchain distributor

231
00:15:15,066 --> 00:15:18,226
using GRTC and go. Okay,

232
00:15:18,328 --> 00:15:23,730
so now that we are on our favorite.

233
00:15:27,130 --> 00:15:31,462
Well in this case I'm going to be using Golan just

234
00:15:31,516 --> 00:15:35,254
because I really like how it

235
00:15:35,292 --> 00:15:38,666
handles all the go issues.

236
00:15:38,848 --> 00:15:42,682
But you can use any other

237
00:15:42,736 --> 00:15:46,650
text editor vs. Code or atom

238
00:15:46,990 --> 00:15:50,060
or, well, anything else.

239
00:15:51,410 --> 00:15:54,880
So now that we are using go,

240
00:15:56,370 --> 00:15:59,918
now that we already create our project, we're going

241
00:15:59,924 --> 00:16:04,258
to be doing some setups. First thing we

242
00:16:04,264 --> 00:16:07,870
are going to create directory

243
00:16:08,030 --> 00:16:11,662
name Proto. This proto

244
00:16:11,726 --> 00:16:15,778
is going to be used to handle

245
00:16:15,954 --> 00:16:19,480
our protocol buffer file. This case

246
00:16:20,330 --> 00:16:23,106
the skeleton for our blockchain.

247
00:16:23,298 --> 00:16:27,674
So we're going to type what

248
00:16:27,712 --> 00:16:31,386
name can we keep it? Okay, let's go

249
00:16:31,408 --> 00:16:35,530
with blockchain proto.

250
00:16:36,750 --> 00:16:40,654
Okay, that's cool. So now

251
00:16:40,692 --> 00:16:44,800
that we have our blockchain proto, we can do

252
00:16:45,250 --> 00:16:49,230
some setup. This case we're going to type syntax

253
00:16:50,690 --> 00:16:53,570
equals proto tree.

254
00:16:54,790 --> 00:16:58,002
Then we need to specify the package. In this case

255
00:16:58,056 --> 00:17:00,850
the package is going to be proto.

256
00:17:02,950 --> 00:17:06,150
Don't forget to put the dot and the comma,

257
00:17:06,890 --> 00:17:10,214
the semicolon. Then we're going to type the

258
00:17:10,252 --> 00:17:14,822
message. This message is basically your

259
00:17:14,876 --> 00:17:18,042
model class. If you come from Java or

260
00:17:18,096 --> 00:17:22,540
C sharp or any other language is our model.

261
00:17:22,910 --> 00:17:26,422
So the model that we're going to be using is a block

262
00:17:26,486 --> 00:17:31,390
model. This case we're going to type message block.

263
00:17:33,010 --> 00:17:36,366
We're going to open and we're going to

264
00:17:36,388 --> 00:17:40,074
type string. We need the previous

265
00:17:40,122 --> 00:17:43,554
hash. This preview hash is going to be

266
00:17:43,592 --> 00:17:47,602
the first data type. Then we need the

267
00:17:47,656 --> 00:17:51,682
data that we are going to be storing. This data is the

268
00:17:51,816 --> 00:17:55,398
information. So in this case

269
00:17:55,484 --> 00:18:00,246
it can be a string, it can be a number

270
00:18:00,428 --> 00:18:04,182
or it can be a boolean or even

271
00:18:04,236 --> 00:18:08,582
so it can be another object. But that depends

272
00:18:08,646 --> 00:18:11,660
on the need that you require at that moment.

273
00:18:12,590 --> 00:18:16,940
But this can be

274
00:18:17,310 --> 00:18:21,242
anything. Do you want to use a json?

275
00:18:21,386 --> 00:18:24,606
Just put a json. You want to

276
00:18:24,628 --> 00:18:28,906
use integer, a string

277
00:18:29,098 --> 00:18:31,760
or an object, go ahead,

278
00:18:32,130 --> 00:18:35,620
replace it. You don't have to do

279
00:18:36,710 --> 00:18:40,706
nothing more. Okay, so continuing we

280
00:18:40,728 --> 00:18:43,906
are going to add the final value that is going to

281
00:18:43,928 --> 00:18:47,666
be string hash.

282
00:18:47,858 --> 00:18:51,286
This hash is going to be the encrypted value of the

283
00:18:51,308 --> 00:18:55,414
block. So we

284
00:18:55,452 --> 00:18:59,210
have our block. The next using is

285
00:18:59,360 --> 00:19:03,210
we're going to be adding a block request.

286
00:19:03,950 --> 00:19:08,090
So we're going to add message block

287
00:19:09,150 --> 00:19:13,118
request. And in this case just

288
00:19:13,284 --> 00:19:15,600
string data equals one.

289
00:19:16,610 --> 00:19:20,970
Next message we have a request,

290
00:19:21,130 --> 00:19:24,834
we're going to send a response. Well, this request is just

291
00:19:24,872 --> 00:19:28,820
for the client. Basically the client send

292
00:19:32,150 --> 00:19:36,734
string as JSON

293
00:19:36,782 --> 00:19:37,540
for example,

294
00:19:40,230 --> 00:19:42,600
type API as example.

295
00:19:44,250 --> 00:19:47,554
And the value that we're going to be returning,

296
00:19:47,682 --> 00:19:51,320
or if I can say it another way,

297
00:19:51,930 --> 00:19:55,706
or your pc server is going to be returning is just

298
00:19:55,808 --> 00:19:59,578
a simple string and that is going to be the

299
00:19:59,664 --> 00:20:05,310
blockchain unencrypted. So block

300
00:20:06,290 --> 00:20:10,330
response, string hash equals

301
00:20:10,410 --> 00:20:11,040
one.

302
00:20:13,250 --> 00:20:17,282
But we are going to be doing something

303
00:20:17,336 --> 00:20:21,214
a little bit more complex. We're going to return a creating

304
00:20:21,262 --> 00:20:24,798
of blocks. It's going to be constantly fetching the data and it's

305
00:20:24,814 --> 00:20:28,966
going to be constantly sending the new information to

306
00:20:28,988 --> 00:20:32,360
the client. Going to type message

307
00:20:33,130 --> 00:20:36,710
chain string response.

308
00:20:37,610 --> 00:20:40,906
And this chain string response is going

309
00:20:40,928 --> 00:20:44,378
to be returning an object. What is going

310
00:20:44,384 --> 00:20:47,594
to be this object? Well, it's going to return the

311
00:20:47,632 --> 00:20:51,370
block object. So block

312
00:20:53,310 --> 00:20:56,746
is going to be inside the

313
00:20:56,768 --> 00:21:00,302
variable block and it's going to be the first type

314
00:21:00,436 --> 00:21:03,310
inside our model change turn response.

315
00:21:04,150 --> 00:21:08,510
Then we're going to type empty

316
00:21:08,590 --> 00:21:11,986
model. And that empty model is just using

317
00:21:12,008 --> 00:21:15,134
to be used when the user requests this.

318
00:21:15,192 --> 00:21:19,206
For example, a get that. As you know, the get it

319
00:21:19,228 --> 00:21:23,174
doesn't need JSON body to

320
00:21:23,292 --> 00:21:27,046
fulfill the message. So GRPC, in this case we're going to be

321
00:21:27,068 --> 00:21:30,918
using an empty message just to simulate

322
00:21:31,014 --> 00:21:32,650
that get petition.

323
00:21:34,430 --> 00:21:38,250
So we're going to type chain request.

324
00:21:38,990 --> 00:21:41,020
We're going to open and close.

325
00:21:42,770 --> 00:21:47,150
Then we're going to add message chain

326
00:21:47,810 --> 00:21:53,318
response and we're

327
00:21:53,354 --> 00:21:56,610
going to send a repeated block.

328
00:21:58,310 --> 00:22:01,554
Type block equals one.

329
00:22:01,752 --> 00:22:05,542
No, I'm using to type blocks just

330
00:22:05,596 --> 00:22:09,154
to be more sadly

331
00:22:09,202 --> 00:22:10,120
on the information.

332
00:22:11,770 --> 00:22:14,886
So what do we have

333
00:22:14,908 --> 00:22:18,518
at the moment? We have a message named block that is going to

334
00:22:18,524 --> 00:22:22,094
contain the information of our new block

335
00:22:22,242 --> 00:22:25,466
that we are going to be creating and also the

336
00:22:25,488 --> 00:22:28,682
other blocks that are going to be chained to the previous one.

337
00:22:28,816 --> 00:22:32,602
We have a block request. This is just for a singular block,

338
00:22:32,746 --> 00:22:35,946
a block response for another singular block,

339
00:22:36,138 --> 00:22:41,040
a chain string response that is going to be basically

340
00:22:43,830 --> 00:22:48,210
nested link list of blocks,

341
00:22:48,630 --> 00:22:52,706
chain request and chain response. This repeated is basically

342
00:22:52,888 --> 00:22:54,980
just a while.

343
00:22:56,230 --> 00:22:58,070
It's an infinite loop.

344
00:23:00,090 --> 00:23:04,710
Finally, we're going to add service blockchain.

345
00:23:05,930 --> 00:23:09,402
And in this service blockchain this is

346
00:23:09,456 --> 00:23:13,178
just going to be the functions as you know,

347
00:23:13,264 --> 00:23:16,794
on your controller. On your controller you can just

348
00:23:16,832 --> 00:23:18,380
type this, for example,

349
00:23:21,410 --> 00:23:24,640
get data and then return

350
00:23:25,170 --> 00:23:27,680
JSON. Just an example.

351
00:23:29,170 --> 00:23:32,538
This scenario is going to be replicated,

352
00:23:32,714 --> 00:23:35,614
but inside our protocol buffer.

353
00:23:35,742 --> 00:23:37,540
How are we going to be doing this?

354
00:23:38,070 --> 00:23:41,794
Well, in this case, the only thing that we need

355
00:23:41,832 --> 00:23:45,570
is just to add an RPC, a remote procedural callback,

356
00:23:45,910 --> 00:23:49,110
and it's going to be named add block.

357
00:23:50,890 --> 00:23:54,134
What is going to be receiving? Well, it's going to be receiving a

358
00:23:54,172 --> 00:23:56,390
block request.

359
00:23:57,710 --> 00:24:00,890
Then this block request is going to return a

360
00:24:00,960 --> 00:24:03,530
block response.

361
00:24:04,190 --> 00:24:07,654
That's it. We're going to copy

362
00:24:07,702 --> 00:24:11,338
this, paste it and

363
00:24:11,504 --> 00:24:17,922
stream get blockchain

364
00:24:18,006 --> 00:24:22,270
request. And here we're going to return a stream

365
00:24:22,870 --> 00:24:26,690
chain stream response

366
00:24:27,190 --> 00:24:30,660
and finally get

367
00:24:31,430 --> 00:24:35,602
chain same as before, chain request

368
00:24:35,666 --> 00:24:40,470
and it's going to be returning chain response.

369
00:24:41,450 --> 00:24:46,614
So this

370
00:24:46,652 --> 00:24:49,100
second RTC and the third one,

371
00:24:50,510 --> 00:24:53,766
they're the same. In one we're going to be returning

372
00:24:53,798 --> 00:24:57,350
a streaming, and on the second one we're going to be returning

373
00:24:57,510 --> 00:25:01,678
a repeated object, but this repeated object,

374
00:25:01,844 --> 00:25:05,920
it can be treated as an internal streaming service.

375
00:25:06,690 --> 00:25:10,880
So this one and this one are

376
00:25:12,310 --> 00:25:15,140
almost the same, maybe on a 90%.

377
00:25:16,950 --> 00:25:20,606
So now that we have our RPC,

378
00:25:20,718 --> 00:25:24,498
we need to generate that information. How are we going

379
00:25:24,504 --> 00:25:27,830
to be generating the information or the skeleton?

380
00:25:29,130 --> 00:25:33,814
Well, in my case I prefer to use a

381
00:25:33,852 --> 00:25:37,602
bash. So I'm going to create one.

382
00:25:37,676 --> 00:25:47,046
It's going to be named generate Sham.

383
00:25:47,078 --> 00:25:51,330
Remember mbash? And this is the comma

384
00:25:51,430 --> 00:25:55,374
to generate the skeleton we need to type

385
00:25:55,492 --> 00:25:58,910
proto blockchain,

386
00:25:59,810 --> 00:26:03,666
proto go out

387
00:26:03,848 --> 00:26:07,780
because we are going to be returning go

388
00:26:08,150 --> 00:26:12,062
code and plugins

389
00:26:12,206 --> 00:26:16,550
equals GrPC and

390
00:26:16,620 --> 00:26:20,774
a little dot. And with that can

391
00:26:20,812 --> 00:26:23,350
just run this command, CD,

392
00:26:24,330 --> 00:26:26,630
auto, sage,

393
00:26:27,130 --> 00:26:28,760
generate sh.

394
00:26:30,190 --> 00:26:33,740
Okay. And as you can see,

395
00:26:35,390 --> 00:26:38,940
GrPC add

396
00:26:39,630 --> 00:26:42,854
to the code, project a new file

397
00:26:42,902 --> 00:26:46,286
named blockchain. PB, go. Well,

398
00:26:46,388 --> 00:26:49,722
protocol buffer, go. This protocol buffer

399
00:26:49,786 --> 00:26:52,502
is auto is a code generated.

400
00:26:52,666 --> 00:26:56,466
So please be careful and

401
00:26:56,648 --> 00:26:59,954
please be advised that if

402
00:26:59,992 --> 00:27:06,422
you do any kind of change inside this

403
00:27:06,476 --> 00:27:10,134
file when you rerun the

404
00:27:10,172 --> 00:27:14,066
generate sh, it's going to delete everything and it's

405
00:27:14,098 --> 00:27:16,342
going to add the new information.

406
00:27:16,476 --> 00:27:20,234
So in this

407
00:27:20,272 --> 00:27:24,906
file you

408
00:27:24,928 --> 00:27:28,554
don't need to modify it. It's good

409
00:27:28,672 --> 00:27:31,920
as it is. Okay,

410
00:27:32,450 --> 00:27:36,330
so now that we have our blockchain pv,

411
00:27:36,490 --> 00:27:38,880
we can start coding. Finally,

412
00:27:40,610 --> 00:27:45,906
what do we need? We need the

413
00:27:45,928 --> 00:27:49,506
model. In this case, the model. I'm going to

414
00:27:49,608 --> 00:27:53,410
create a new directory named chainer. In this chainer

415
00:27:54,710 --> 00:27:57,894
we're going to be adding a new go

416
00:27:57,932 --> 00:28:01,574
file. It's going to be

417
00:28:01,612 --> 00:28:03,750
naming chainer.

418
00:28:05,210 --> 00:28:08,762
Okay. And we are going to add

419
00:28:08,896 --> 00:28:12,058
type. This type is going

420
00:28:12,064 --> 00:28:15,930
to be a block. But this block,

421
00:28:17,470 --> 00:28:22,454
if we can check, this is our

422
00:28:22,512 --> 00:28:26,010
model. We have three strings,

423
00:28:26,170 --> 00:28:28,670
name, previous hash, data and hash.

424
00:28:30,210 --> 00:28:33,890
And with that we can add previous hash.

425
00:28:34,390 --> 00:28:38,834
There is going to be a string add data

426
00:28:39,032 --> 00:28:42,770
also a string. And also hash

427
00:28:43,270 --> 00:28:44,530
is a string.

428
00:28:47,690 --> 00:28:51,270
And of course we need to be returning a list

429
00:28:51,340 --> 00:28:54,694
of blockchains because as the name say by

430
00:28:54,732 --> 00:28:58,922
itself, it's a nested list

431
00:28:59,056 --> 00:29:01,290
of blocks, objects.

432
00:29:03,070 --> 00:29:06,890
And with that we can just add a new

433
00:29:06,960 --> 00:29:09,020
structure name,

434
00:29:10,050 --> 00:29:12,430
blockchain.

435
00:29:13,890 --> 00:29:18,270
And in this blockchain we can just add block

436
00:29:19,810 --> 00:29:26,670
that is going to be an array lock.

437
00:29:27,670 --> 00:29:32,530
And we're done. Sorry, blocks and

438
00:29:32,600 --> 00:29:36,150
we are done. We have our block structure.

439
00:29:36,650 --> 00:29:39,686
As I said previously, this data and

440
00:29:39,708 --> 00:29:43,058
this data type. In this case is a string.

441
00:29:43,154 --> 00:29:50,502
It can be replaced by any kind of data

442
00:29:50,556 --> 00:29:53,580
type that you desire. And string a number,

443
00:29:54,510 --> 00:29:55,530
Boolean,

444
00:29:58,270 --> 00:30:03,034
Json, a list, an object depends

445
00:30:03,082 --> 00:30:06,400
of what you need at the moment. Okay.

446
00:30:08,530 --> 00:30:12,320
With all that we can

447
00:30:12,790 --> 00:30:16,466
start doing some more changes. What do we

448
00:30:16,488 --> 00:30:19,538
need? We need to create a new function.

449
00:30:19,704 --> 00:30:23,490
In this case we need to create a new blockchain.

450
00:30:23,910 --> 00:30:27,142
But how are we going to be doing

451
00:30:27,196 --> 00:30:30,470
that? Okay, let's create

452
00:30:30,540 --> 00:30:32,790
a function name make block.

453
00:30:33,690 --> 00:30:37,458
This make block. What do we need? We need

454
00:30:37,644 --> 00:30:40,250
the previous hash.

455
00:30:40,910 --> 00:30:44,586
We need the data.

456
00:30:44,768 --> 00:30:48,410
And both are going to be a string.

457
00:30:49,890 --> 00:30:54,074
And finally this is going to be returning an already existing

458
00:30:54,122 --> 00:30:55,790
object of type block.

459
00:30:58,130 --> 00:31:01,706
Finally, we are just going to be adding the block.

460
00:31:01,818 --> 00:31:05,806
Block is going to be an already existing

461
00:31:05,838 --> 00:31:06,530
block.

462
00:31:09,110 --> 00:31:12,610
And I don't why the autocomplete.

463
00:31:14,710 --> 00:31:18,646
Okay, there we go. Okay, so previous hash is

464
00:31:18,668 --> 00:31:22,840
going to be previous hash data. It's going to be data

465
00:31:23,210 --> 00:31:26,950
hash. We don't have the hash.

466
00:31:28,190 --> 00:31:32,140
Instead we need to decipher the hash and then add it.

467
00:31:33,950 --> 00:31:37,500
Well, with that case, we need to add a new function.

468
00:31:38,510 --> 00:31:42,620
We can call it get hash. Get hash because

469
00:31:43,550 --> 00:31:46,954
what is the value? This is going to be the

470
00:31:46,992 --> 00:31:50,574
previous hash on the data that

471
00:31:50,612 --> 00:31:54,334
we need to encrypt. Also, both are going to be string

472
00:31:54,382 --> 00:31:56,290
and it's going to return a string.

473
00:31:57,590 --> 00:32:00,580
Well, hash is going to be.

474
00:32:01,910 --> 00:32:04,974
We're going to do some encryption.

475
00:32:05,022 --> 00:32:08,742
In this case, I'm going to be using the sha two five

476
00:32:08,796 --> 00:32:12,802
six. Feel free to use whatever encryption

477
00:32:12,866 --> 00:32:16,294
method you like the most. In this

478
00:32:16,332 --> 00:32:22,662
case, I'm going to be using Sha two

479
00:32:22,716 --> 00:32:27,590
five six dot

480
00:32:28,970 --> 00:32:31,040
sum 56.

481
00:32:31,730 --> 00:32:35,738
And we're going to be adding an array

482
00:32:35,914 --> 00:32:39,338
of byte. And that array

483
00:32:39,354 --> 00:32:42,990
of byte is going to be composed of the previous hash

484
00:32:43,510 --> 00:32:45,620
plus the new data.

485
00:32:47,590 --> 00:32:51,570
And at the end we are just going to be returning

486
00:32:54,890 --> 00:32:58,150
the encoded value of hash.

487
00:32:58,890 --> 00:33:02,360
However, it's going to be linked or it's going to

488
00:33:05,850 --> 00:33:09,382
be differences with

489
00:33:09,436 --> 00:33:10,950
this little symbol.

490
00:33:12,490 --> 00:33:13,800
So in this case,

491
00:33:14,650 --> 00:33:17,910
encode two string.

492
00:33:18,570 --> 00:33:22,400
And with that we have our hash function.

493
00:33:23,650 --> 00:33:26,846
So we can just add get hash. And what is going to be

494
00:33:26,868 --> 00:33:30,960
the data? Well, it's going to be previous hash plus

495
00:33:31,570 --> 00:33:35,540
data and return

496
00:33:36,310 --> 00:33:39,906
block. And we are done.

497
00:33:40,008 --> 00:33:43,970
We have our block. We have our

498
00:33:44,040 --> 00:33:47,894
make block. But still I feel

499
00:33:48,012 --> 00:33:51,718
that there is something that is missing and that is

500
00:33:51,884 --> 00:33:54,390
we need origins cube.

501
00:33:56,570 --> 00:34:01,500
Okay, let's create it. Funk make

502
00:34:02,110 --> 00:34:05,814
blockchain. It's going to be returning

503
00:34:05,862 --> 00:34:08,170
an Albert existing blockchain.

504
00:34:10,450 --> 00:34:14,074
And we are going to create a new variable named Genesis

505
00:34:14,122 --> 00:34:17,760
block. And this Genesis block is going to be

506
00:34:18,130 --> 00:34:22,042
make block. As I said previously. Remember Genesis

507
00:34:22,106 --> 00:34:25,634
block. It can

508
00:34:25,672 --> 00:34:29,170
be any kind of information. It's just dummy day.

509
00:34:29,320 --> 00:34:32,562
Well, it's not dummy data in this case it's going to be.

510
00:34:32,616 --> 00:34:36,200
But you can type with any kind of

511
00:34:36,970 --> 00:34:40,630
special key, special characters that you desire.

512
00:34:42,170 --> 00:34:46,354
So in this case I'm using to type Genesis

513
00:34:46,402 --> 00:34:49,850
hash for the data

514
00:34:50,000 --> 00:34:52,890
also Genesis hash.

515
00:34:55,070 --> 00:34:59,146
And finally, with that we

516
00:34:59,168 --> 00:35:04,734
can just do this chain equals an

517
00:35:04,772 --> 00:35:08,030
array of type block.

518
00:35:09,890 --> 00:35:14,654
And this type block is using to be related

519
00:35:14,702 --> 00:35:17,460
to Genesis block. Finally,

520
00:35:18,230 --> 00:35:22,210
we are going to return a new

521
00:35:22,280 --> 00:35:26,150
blockchain. We're going to return a blockchain

522
00:35:27,290 --> 00:35:31,634
and this blockchain is just going to be nested

523
00:35:31,682 --> 00:35:34,678
with the chain. And there we go.

524
00:35:34,764 --> 00:35:37,880
We already have all the information that we need.

525
00:35:38,270 --> 00:35:41,930
So we have make block, get hash

526
00:35:42,750 --> 00:35:46,634
and also the creation of

527
00:35:46,672 --> 00:35:50,540
the whole cube. We are good to go.

528
00:35:51,010 --> 00:35:55,070
But still there's something that is missing.

529
00:35:58,530 --> 00:36:02,334
I believe that more than one found the issue and that is

530
00:36:02,372 --> 00:36:06,714
that we already have the creation of the block and the Genesis

531
00:36:06,762 --> 00:36:09,986
queue. Well, the Genesis block, but we don't have

532
00:36:10,008 --> 00:36:14,370
a function to link

533
00:36:14,520 --> 00:36:19,222
those blocks rather

534
00:36:19,276 --> 00:36:21,320
quickly. In fact,

535
00:36:23,930 --> 00:36:28,106
once we finish this project, you can basically

536
00:36:28,208 --> 00:36:31,706
copy chainer and paste it whatever you

537
00:36:31,728 --> 00:36:35,130
desire on a new project and just

538
00:36:35,200 --> 00:36:38,966
do some little changes just to be matching

539
00:36:38,998 --> 00:36:43,360
with your new code base and you're good to go.

540
00:36:44,930 --> 00:36:48,490
Well, we're going to be creating

541
00:36:48,650 --> 00:36:52,750
a function name apent

542
00:36:54,390 --> 00:36:58,050
block. This apen block

543
00:36:58,390 --> 00:37:02,370
is going to be needed inside our blockchain.

544
00:37:02,710 --> 00:37:06,674
So we're going to be adding a

545
00:37:06,712 --> 00:37:10,450
superpondition and also we're going to be requesting

546
00:37:10,610 --> 00:37:14,520
the data. There is going to be an string data type

547
00:37:14,890 --> 00:37:18,170
and of course we're going to be returning a block.

548
00:37:19,310 --> 00:37:23,914
Okay, so previous block is

549
00:37:23,952 --> 00:37:27,370
a variable, it's going to be chain blocks.

550
00:37:28,030 --> 00:37:32,878
And we're just going to be getting the

551
00:37:33,044 --> 00:37:37,866
whole size of the array, but we're

552
00:37:37,898 --> 00:37:40,080
going to be reducing that size by one.

553
00:37:41,570 --> 00:37:45,650
So length of chain

554
00:37:46,150 --> 00:37:50,660
blocks minus one.

555
00:37:52,790 --> 00:37:55,570
Then with that we can create the new block.

556
00:37:56,010 --> 00:37:59,880
New block. It's going to be

557
00:38:00,490 --> 00:38:04,642
make block. This make block is going to contain

558
00:38:04,706 --> 00:38:08,778
the previous block hash and

559
00:38:08,864 --> 00:38:12,250
the data, the new data that we are going to be creating.

560
00:38:13,150 --> 00:38:16,490
And finally we're going to be adding that result

561
00:38:16,640 --> 00:38:19,730
to our currently existing blockchain.

562
00:38:19,910 --> 00:38:24,570
So chain block equals

563
00:38:24,730 --> 00:38:27,760
apen just to add that new value.

564
00:38:28,130 --> 00:38:34,078
Chain block is the

565
00:38:34,164 --> 00:38:37,854
original array. We're going to be adding the

566
00:38:37,892 --> 00:38:38,830
new block.

567
00:38:42,610 --> 00:38:47,670
Sorry, my bad. I almost forgot to turn new

568
00:38:47,740 --> 00:38:50,534
block. And that's it.

569
00:38:50,732 --> 00:38:53,814
Okay, now we have everything done on

570
00:38:53,852 --> 00:38:57,626
our chainer. Now we need

571
00:38:57,648 --> 00:39:01,610
to be creating our server for the server.

572
00:39:02,590 --> 00:39:06,506
It's going to be rather quickly because the

573
00:39:06,528 --> 00:39:10,294
main logic of the blockchain resides on this file

574
00:39:10,342 --> 00:39:12,160
name Chainer Go.

575
00:39:13,170 --> 00:39:18,030
Well, we're going to create a new directory name services

576
00:39:19,170 --> 00:39:22,510
and in this server we are just going to be adding a new

577
00:39:22,580 --> 00:39:25,840
go file named server go.

578
00:39:29,250 --> 00:39:32,654
Okay, I'm just going to replace server with

579
00:39:32,692 --> 00:39:36,342
main just to be able to be capable of run

580
00:39:36,396 --> 00:39:39,974
this project. And we're going to be

581
00:39:40,092 --> 00:39:44,530
creating some needed structure

582
00:39:44,610 --> 00:39:47,960
just for the GRPC service to start running.

583
00:39:48,750 --> 00:39:52,746
We're going to create our funk main. And in

584
00:39:52,768 --> 00:39:56,506
the function main we're going to be adding a variable that

585
00:39:56,528 --> 00:40:00,800
is a listener. And this listener is going to be net

586
00:40:02,850 --> 00:40:06,666
listen. I'm going to be requesting

587
00:40:06,698 --> 00:40:08,190
a TCP connection.

588
00:40:10,370 --> 00:40:15,140
What is going to be the address? Let's just say 8004.

589
00:40:16,710 --> 00:40:20,526
However, this is giving us an error and it's

590
00:40:20,558 --> 00:40:24,500
because net listen throws more

591
00:40:25,050 --> 00:40:29,014
than one value also throws an error and

592
00:40:29,052 --> 00:40:33,190
with that we can just add another value name error.

593
00:40:34,250 --> 00:40:37,938
Finally, let's just going to check if error

594
00:40:38,114 --> 00:40:42,950
is different from nil love fatal.

595
00:40:45,710 --> 00:40:47,420
What can we type here?

596
00:40:49,470 --> 00:40:52,922
Let's just type unable to listen on

597
00:40:52,976 --> 00:40:57,698
port variable.

598
00:40:57,814 --> 00:41:01,280
It's going to be error perfect.

599
00:41:02,050 --> 00:41:06,530
Then we're going to create server. It's going to be a GRPC

600
00:41:09,430 --> 00:41:14,820
new server and

601
00:41:16,170 --> 00:41:19,974
server is going to be a

602
00:41:20,012 --> 00:41:23,654
new, sorry, server is

603
00:41:23,692 --> 00:41:28,250
going to be a new server.

604
00:41:29,790 --> 00:41:34,186
However, this server is going to be linked with

605
00:41:34,208 --> 00:41:37,434
the chainer. This chainer is

606
00:41:37,632 --> 00:41:41,550
just to start with our genesis cube.

607
00:41:42,530 --> 00:41:46,510
So it's going to be chainer make

608
00:41:46,580 --> 00:41:50,122
blockchain. This is giving us an error

609
00:41:50,186 --> 00:41:54,500
but it is because we haven't import all

610
00:41:56,630 --> 00:41:58,930
the required elements.

611
00:42:00,230 --> 00:42:06,066
Let's just add it using

612
00:42:06,088 --> 00:42:09,626
to be blockchain,

613
00:42:09,758 --> 00:42:13,670
the Gopher chainer.

614
00:42:14,570 --> 00:42:19,274
Let's just copy this paste and

615
00:42:19,392 --> 00:42:24,460
it's going to be proto perfect.

616
00:42:27,070 --> 00:42:28,780
Okay, that's good.

617
00:42:30,050 --> 00:42:33,182
Okay, now what is the issue

618
00:42:33,236 --> 00:42:36,378
that we have here with server services?

619
00:42:36,474 --> 00:42:40,000
We need to create a new structure. This is because

620
00:42:40,610 --> 00:42:44,580
we need to handle this

621
00:42:44,950 --> 00:42:49,134
request inside on a custom structure.

622
00:42:49,182 --> 00:42:52,980
In this case it's going to be type

623
00:42:54,550 --> 00:42:57,926
server and this type server is

624
00:42:57,948 --> 00:43:01,042
going to be chainer.

625
00:43:01,186 --> 00:43:04,546
Blockchain and we're

626
00:43:04,578 --> 00:43:05,160
good.

627
00:43:07,450 --> 00:43:11,414
Finally we're just using to register

628
00:43:11,542 --> 00:43:15,418
our new server or new service

629
00:43:15,584 --> 00:43:20,278
on the protocol buffer. So proto register

630
00:43:20,374 --> 00:43:23,566
blockchain server and this register is

631
00:43:23,588 --> 00:43:25,070
going to be chainer.

632
00:43:28,610 --> 00:43:30,720
Sorry, my bad.

633
00:43:32,130 --> 00:43:36,100
It's going to be our server and

634
00:43:37,430 --> 00:43:39,810
the new value server.

635
00:43:41,190 --> 00:43:44,690
But still we have a little

636
00:43:44,760 --> 00:43:48,134
issue. Say cannot use server as type

637
00:43:48,172 --> 00:43:50,630
blockchain server type does not implement.

638
00:43:51,370 --> 00:43:55,762
Okay. Just because there are missing

639
00:43:55,906 --> 00:43:59,194
methods to be implemented. Okay, let's just add

640
00:43:59,232 --> 00:44:04,570
it. And finally server

641
00:44:05,550 --> 00:44:09,690
serf listener

642
00:44:10,450 --> 00:44:12,160
on our desired port.

643
00:44:14,210 --> 00:44:18,830
Let's just going to add those imports context

644
00:44:20,210 --> 00:44:21,550
generate request.

645
00:44:25,090 --> 00:44:25,840
Okay.

646
00:44:30,540 --> 00:44:33,690
Okay, we're good.

647
00:44:34,780 --> 00:44:38,304
Now I'm, what is the, what is the other thing

648
00:44:38,342 --> 00:44:42,432
that we are missing at the moment? We have our

649
00:44:42,486 --> 00:44:47,500
server. We have a block stream block getchain

650
00:44:47,660 --> 00:44:51,540
but we

651
00:44:51,610 --> 00:44:53,350
haven't implemented that.

652
00:44:56,920 --> 00:45:00,324
Okay well if for some

653
00:45:00,362 --> 00:45:04,020
reason you are receiving this kind of error

654
00:45:04,100 --> 00:45:06,330
that say unresolved type.

655
00:45:07,740 --> 00:45:11,416
Well to solve that issue it's just needed to

656
00:45:11,438 --> 00:45:15,630
add proto and

657
00:45:16,080 --> 00:45:19,704
automatically detect the changes. So you're just going to copy

658
00:45:19,752 --> 00:45:21,852
this paste it,

659
00:45:21,986 --> 00:45:24,940
paste, paste,

660
00:45:26,660 --> 00:45:30,572
paste and paste

661
00:45:30,716 --> 00:45:34,176
and all the changes are applied as it should be.

662
00:45:34,358 --> 00:45:37,520
Okay, so add block.

663
00:45:38,680 --> 00:45:42,388
What are we using to be doing on this function? Add block is using to

664
00:45:42,394 --> 00:45:48,500
be basically block s

665
00:45:48,650 --> 00:45:51,780
chain because we're going to be appending a new block,

666
00:45:51,940 --> 00:45:56,216
append block and we're going to just send the new information

667
00:45:56,398 --> 00:45:59,784
that is going to be stored and with that

668
00:45:59,822 --> 00:46:03,000
we can just return a new proto

669
00:46:03,980 --> 00:46:08,380
and this proto is going to be block response

670
00:46:09,040 --> 00:46:12,600
and the hash is going to be block

671
00:46:12,760 --> 00:46:16,190
hash. And finally

672
00:46:17,140 --> 00:46:20,476
we just return also we just link anil

673
00:46:20,588 --> 00:46:23,856
because there isn't any kind of error. So we're good to

674
00:46:23,878 --> 00:46:27,820
go. Second one stream

675
00:46:27,900 --> 00:46:31,910
get block. How are we going to be doing this?

676
00:46:32,680 --> 00:46:36,644
Well, basically the stream get block is

677
00:46:36,682 --> 00:46:40,548
just going to be sending all the information that is on the list of

678
00:46:40,634 --> 00:46:44,216
blockchain. So with that we can just

679
00:46:44,318 --> 00:46:49,016
do this for anything in

680
00:46:49,038 --> 00:46:52,612
the range of s chain

681
00:46:52,756 --> 00:46:53,720
blocks.

682
00:46:56,480 --> 00:47:00,668
We are just going to be adding the current object

683
00:47:00,834 --> 00:47:03,070
into a new variable named result.

684
00:47:04,720 --> 00:47:09,672
It's going to be a new proto chain

685
00:47:09,816 --> 00:47:13,188
string response. And this changett

686
00:47:13,224 --> 00:47:16,624
response is using to have a block. This block is

687
00:47:16,662 --> 00:47:19,940
going to be of type proto

688
00:47:20,840 --> 00:47:24,436
block and we're just

689
00:47:24,458 --> 00:47:26,310
going to be adding this information,

690
00:47:27,960 --> 00:47:31,800
previous hash going to be block, previous hash

691
00:47:32,140 --> 00:47:36,372
data block data hash

692
00:47:36,516 --> 00:47:40,216
block. Well we can add

693
00:47:40,238 --> 00:47:44,190
the same data so we're good to go.

694
00:47:45,680 --> 00:47:47,310
And with that,

695
00:47:51,760 --> 00:47:55,276
and with that we can just say the

696
00:47:55,298 --> 00:47:59,280
services is going to be sending the result but

697
00:47:59,350 --> 00:48:03,376
we're going to be sending this result each second. So we're going to have a

698
00:48:03,398 --> 00:48:07,010
time sleep just

699
00:48:07,380 --> 00:48:12,070
to reflect the changes on,

700
00:48:14,040 --> 00:48:17,780
on a better, on a better perspective.

701
00:48:19,320 --> 00:48:22,656
And in the end when everything is done it's just going to be returning

702
00:48:22,688 --> 00:48:25,096
a neil. Okay,

703
00:48:25,278 --> 00:48:28,632
cool. And we

704
00:48:28,686 --> 00:48:30,600
have our server implemented.

705
00:48:32,060 --> 00:48:34,270
If we run it,

706
00:48:34,960 --> 00:48:39,608
let's say go run server

707
00:48:39,704 --> 00:48:43,580
server go. It isn't going to be doing anything but

708
00:48:43,650 --> 00:48:46,270
the server is already listening for changes.

709
00:48:47,220 --> 00:48:53,552
In this case we're just going to be adding some

710
00:48:53,606 --> 00:48:57,484
client just to be fetching information and sending

711
00:48:57,532 --> 00:48:58,370
the new information.

712
00:49:00,280 --> 00:49:03,508
Well, let's do it. Just going

713
00:49:03,514 --> 00:49:06,580
to add client.

714
00:49:08,360 --> 00:49:12,852
It's going to be a new go file name client package

715
00:49:12,916 --> 00:49:15,770
name because we need to be running this.

716
00:49:16,620 --> 00:49:19,944
And on the client, first thing

717
00:49:19,982 --> 00:49:23,416
we need to declare a variable named client that is going to

718
00:49:23,438 --> 00:49:30,220
be of type proto blockchain.

719
00:49:32,800 --> 00:49:36,280
Okay, so with the proto you can just do this.

720
00:49:36,450 --> 00:49:38,290
Just going to be copying this,

721
00:49:40,660 --> 00:49:44,864
paste it because we're going to be using a lot of information

722
00:49:44,982 --> 00:49:48,496
that we really have and we

723
00:49:48,518 --> 00:49:52,164
can start function main is

724
00:49:52,202 --> 00:49:55,140
going to function main. Okay,

725
00:49:55,290 --> 00:49:59,940
so for this scenario we're going to declare two

726
00:50:00,010 --> 00:50:03,368
arguments, name start and stream. Start is just going to

727
00:50:03,374 --> 00:50:06,824
be adding new block to the

728
00:50:06,862 --> 00:50:09,850
chain and stream is going to be receiving the,

729
00:50:10,860 --> 00:50:13,320
receiving the existing block.

730
00:50:16,160 --> 00:50:21,848
So start equals flag

731
00:50:22,024 --> 00:50:27,980
boolean name start false

732
00:50:29,120 --> 00:50:32,160
start receiving.

733
00:50:34,180 --> 00:50:40,320
Sorry, my bad. Start sending sending

734
00:50:41,320 --> 00:50:45,860
concurrent block to the server.

735
00:50:47,080 --> 00:50:51,872
Cool. Second one is going to be name string.

736
00:50:52,016 --> 00:50:56,840
It's going to be flat o stream,

737
00:50:57,340 --> 00:51:03,092
false receive streaming

738
00:51:03,236 --> 00:51:05,320
of blockchain.

739
00:51:06,700 --> 00:51:10,436
Perfect. And finally flag

740
00:51:10,628 --> 00:51:13,710
parse just to get the information.

741
00:51:14,720 --> 00:51:17,856
Okay, so what is going to be the first thing that we

742
00:51:17,878 --> 00:51:20,972
need to do? We need to create a connection,

743
00:51:21,116 --> 00:51:24,832
a live connection. We're just going to create a

744
00:51:24,886 --> 00:51:28,112
variable name connection. There is going to be a new

745
00:51:28,166 --> 00:51:31,876
GrPC dial and

746
00:51:31,898 --> 00:51:35,188
this dial is going to request the target. The target in this case is going

747
00:51:35,194 --> 00:51:39,110
to be all address.

748
00:51:39,560 --> 00:51:43,416
In this case was a four going

749
00:51:43,438 --> 00:51:46,330
to copy this and paste it.

750
00:51:47,180 --> 00:51:50,500
And finally we need to specify

751
00:51:50,580 --> 00:51:53,848
how it's going to be taking the connection procedure. So it's

752
00:51:53,864 --> 00:51:58,632
going to be insecure

753
00:51:58,696 --> 00:52:02,264
connection. However, it's giving us an error

754
00:52:02,312 --> 00:52:05,564
and in this case as before it's because we are

755
00:52:05,602 --> 00:52:09,312
assigning the response but we are receiving the

756
00:52:09,366 --> 00:52:12,876
error. We're just going to be adding

757
00:52:12,908 --> 00:52:18,560
the error. And then if error is

758
00:52:18,630 --> 00:52:22,832
not nil then we're just going to let fail

759
00:52:22,976 --> 00:52:26,496
f cannot dial

760
00:52:26,688 --> 00:52:30,356
server and we're just going to

761
00:52:30,378 --> 00:52:31,460
send the error.

762
00:52:34,060 --> 00:52:37,880
Then client is going to be proto

763
00:52:39,660 --> 00:52:42,904
new blockchain client and we're just going to be

764
00:52:42,942 --> 00:52:44,700
sending the connection.

765
00:52:47,120 --> 00:52:50,750
Okay, finally if

766
00:52:52,160 --> 00:52:55,756
star is true, then we're just going

767
00:52:55,778 --> 00:52:59,244
to create a new function. It's going to be named

768
00:52:59,292 --> 00:53:04,560
start block blockchain.

769
00:53:07,380 --> 00:53:10,390
If stream is true,

770
00:53:10,760 --> 00:53:15,024
then start stream

771
00:53:15,152 --> 00:53:16,020
streaming.

772
00:53:18,120 --> 00:53:21,816
Okay, finally we need

773
00:53:21,838 --> 00:53:25,160
to create those two functions. Start blockchain.

774
00:53:25,660 --> 00:53:28,280
Sorry, my bad. Start blockchain.

775
00:53:29,500 --> 00:53:32,884
And we're just using to create an infinite loop.

776
00:53:32,932 --> 00:53:35,550
In this case we're just going to do an infinite four,

777
00:53:37,280 --> 00:53:40,860
in which case the information is going to be block.

778
00:53:41,760 --> 00:53:44,892
It's going to be client add

779
00:53:44,946 --> 00:53:49,068
block. We need to send the context,

780
00:53:49,244 --> 00:53:52,560
context background. And also

781
00:53:52,630 --> 00:53:56,288
we are just going to be adding the

782
00:53:56,374 --> 00:53:59,828
request. It's going to be

783
00:53:59,914 --> 00:54:04,372
proto block request this

784
00:54:04,426 --> 00:54:08,116
block request. We are just

785
00:54:08,138 --> 00:54:11,672
going to be adding the data. In this case the data is going to be

786
00:54:11,806 --> 00:54:17,640
the current time, so time now string.

787
00:54:19,500 --> 00:54:21,640
However, we are receiving an error.

788
00:54:22,140 --> 00:54:25,692
So same as before,

789
00:54:25,826 --> 00:54:29,436
we need to add another variable, but in this case going

790
00:54:29,458 --> 00:54:31,740
to be address error.

791
00:54:37,140 --> 00:54:40,960
Finally, if address error

792
00:54:41,780 --> 00:54:45,328
equals new sorry, it's not new,

793
00:54:45,494 --> 00:54:49,270
then we're just going to copy this

794
00:54:49,800 --> 00:54:53,030
using to paste it and we're just going to say

795
00:55:01,180 --> 00:55:05,688
unable to add block address

796
00:55:05,774 --> 00:55:08,650
error. Cool.

797
00:55:12,540 --> 00:55:18,012
And then if

798
00:55:18,066 --> 00:55:21,756
we don't have any kind of error then we can just print a

799
00:55:21,778 --> 00:55:25,580
new message name new block hash.

800
00:55:26,260 --> 00:55:38,204
It's using to be kick

801
00:55:38,252 --> 00:55:40,550
assigns the string so we can do this instead.

802
00:55:44,360 --> 00:55:47,332
Block hash. Okay,

803
00:55:47,386 --> 00:55:51,844
cool. And finally time

804
00:55:51,962 --> 00:55:55,530
flip because we're going to be adding a new block each second

805
00:55:57,820 --> 00:56:00,330
time second.

806
00:56:01,500 --> 00:56:03,290
Okay, cool, perfect.

807
00:56:04,800 --> 00:56:09,420
This case we're going to start running our client.

808
00:56:10,160 --> 00:56:13,550
Oh my bad, I forgot to

809
00:56:14,640 --> 00:56:17,952
do the change on the client this

810
00:56:18,006 --> 00:56:24,080
case and use variable client client.

811
00:56:28,260 --> 00:56:31,764
I'm just going to remove this and start

812
00:56:31,882 --> 00:56:34,720
the services. Go run client,

813
00:56:34,800 --> 00:56:36,070
client, go.

814
00:56:39,640 --> 00:56:45,616
Where was the argument? Start string.

815
00:56:45,648 --> 00:56:46,660
The purpose.

816
00:56:52,380 --> 00:56:55,976
So as you, as you can see, this server is already sending the

817
00:56:55,998 --> 00:56:59,816
information and it's returning the

818
00:56:59,918 --> 00:57:03,832
new encrypted hash. So it's working.

819
00:57:03,966 --> 00:57:08,480
We're going to let this blockchain

820
00:57:08,820 --> 00:57:12,348
run and we're going to finish the streaming.

821
00:57:12,524 --> 00:57:15,868
So I'm

822
00:57:15,884 --> 00:57:20,096
just going to redo all this and we're

823
00:57:20,128 --> 00:57:24,612
just going to be adding the final function, name function start

824
00:57:24,666 --> 00:57:28,020
streaming. Okay,

825
00:57:28,090 --> 00:57:32,228
so with the start streaming it's the same

826
00:57:32,314 --> 00:57:36,070
as the start block. Well, it's almost

827
00:57:37,020 --> 00:57:40,664
basically a copy and paste. So we can

828
00:57:40,702 --> 00:57:44,428
just do request equals a new

829
00:57:44,594 --> 00:57:48,488
proto chain

830
00:57:48,664 --> 00:57:52,460
request chain request.

831
00:57:54,080 --> 00:57:58,348
Good. Then response string

832
00:57:58,524 --> 00:58:00,610
because we're going to be fetching information.

833
00:58:02,100 --> 00:58:05,836
It's going to be client string,

834
00:58:05,868 --> 00:58:09,680
get blocks context background

835
00:58:10,180 --> 00:58:13,600
and we just be fetching a new request.

836
00:58:14,840 --> 00:58:20,576
For any scenario we have an error, then we're

837
00:58:20,608 --> 00:58:25,848
just going to be type a

838
00:58:25,854 --> 00:58:29,544
new fatal exception error while

839
00:58:29,662 --> 00:58:34,860
calling stream

840
00:58:36,000 --> 00:58:39,804
and then we are just going to be iterating over that

841
00:58:39,842 --> 00:58:43,928
response. So for block stream we're

842
00:58:43,944 --> 00:58:47,088
going to create a new variable that is going

843
00:58:47,094 --> 00:58:50,576
to be receiving the value of the

844
00:58:50,598 --> 00:58:55,170
string. So resource string equals sorry,

845
00:58:56,340 --> 00:59:00,884
recover value. And if

846
00:59:00,922 --> 00:59:05,204
for some reason the error equals to end

847
00:59:05,242 --> 00:59:09,204
of file, it means that we

848
00:59:09,402 --> 00:59:12,560
finish fetching all the information, all the blocks,

849
00:59:12,720 --> 00:59:16,056
so we can say log. No, we're just

850
00:59:16,078 --> 00:59:19,930
going to do a break here and we are going to just type,

851
00:59:21,100 --> 00:59:24,748
we have reached the end of

852
00:59:24,834 --> 00:59:26,060
this string.

853
00:59:28,720 --> 00:59:32,780
Finally we're just going to be checking if

854
00:59:32,850 --> 00:59:36,136
for some scenario we have an error that

855
00:59:36,178 --> 00:59:39,616
is different from Neil, then we

856
00:59:39,638 --> 00:59:44,080
can just lag fatal f, say error

857
00:59:46,660 --> 00:59:49,460
while reading stream.

858
00:59:51,080 --> 00:59:54,630
And after all this we can just

859
00:59:55,800 --> 00:59:59,904
create a new variable that is going to be fetching

860
00:59:59,952 --> 01:00:02,260
the result block stream,

861
01:00:02,600 --> 01:00:06,810
sorry, block stream with n, not with n,

862
01:00:08,060 --> 01:00:12,120
blockstream block

863
01:00:13,020 --> 01:00:16,140
and then block print format,

864
01:00:16,960 --> 01:00:21,272
in which case we can just type previous

865
01:00:21,336 --> 01:00:24,540
hash. It's going to be a string,

866
01:00:26,800 --> 01:00:30,240
then data, it's going to be a string,

867
01:00:32,100 --> 01:00:34,400
then the hash,

868
01:00:36,180 --> 01:00:40,668
which also is going to be a string and

869
01:00:40,854 --> 01:00:43,920
just using to be adding block produce hash,

870
01:00:44,080 --> 01:00:48,310
block hash and

871
01:00:48,760 --> 01:00:52,330
block data.

872
01:00:52,700 --> 01:00:57,256
Sorry, my bad. Block data and

873
01:00:57,438 --> 01:01:01,160
block hash.

874
01:01:02,780 --> 01:01:06,908
And that's it. We have

875
01:01:07,074 --> 01:01:10,568
the implementation to fetch all the blockchain.

876
01:01:10,664 --> 01:01:13,484
So let's just run it. Go,

877
01:01:13,522 --> 01:01:18,030
run client, client, go and

878
01:01:18,560 --> 01:01:22,272
stream through. And as you can see

879
01:01:22,326 --> 01:01:25,744
the information is

880
01:01:25,782 --> 01:01:29,536
being fetched by the client API,

881
01:01:29,648 --> 01:01:33,152
and as you can see, the information is being updated,

882
01:01:33,216 --> 01:01:37,312
the hash is being retrieved. However, the previous

883
01:01:37,376 --> 01:01:41,336
data that was encrypted is already been displayed on

884
01:01:41,358 --> 01:01:44,170
the console. And as you can see,

885
01:01:44,620 --> 01:01:50,232
we have an implementation of a custom

886
01:01:50,286 --> 01:01:54,348
blockchain distribution using GRPC and implemented a

887
01:01:54,354 --> 01:01:58,412
custom streaming service to fetch the data and also to send

888
01:01:58,466 --> 01:02:02,428
the data from client to server and receive the data from

889
01:02:02,514 --> 01:02:06,924
server to client. And with that we

890
01:02:06,962 --> 01:02:10,770
conclude with this

891
01:02:12,980 --> 01:02:18,028
speaker. I hope that it's

892
01:02:18,044 --> 01:02:21,040
going to be useful for you.

893
01:02:21,110 --> 01:02:24,592
And again I say thank

894
01:02:24,646 --> 01:02:28,850
you for being

895
01:02:29,460 --> 01:02:31,930
on this creating it means a lot.

896
01:02:33,500 --> 01:02:36,996
Don't forget, keep coding, keep practicing,

897
01:02:37,108 --> 01:02:40,730
and always go for the best.

898
01:02:41,260 --> 01:02:41,510
See.

