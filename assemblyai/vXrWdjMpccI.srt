1
00:00:27,010 --> 00:00:30,470
Hi, welcome to Comp 42 devsec Ops days.

2
00:00:30,620 --> 00:00:33,394
I'm really excited that we get to talk about container scanning.

3
00:00:33,442 --> 00:00:36,886
Today we're going to dig into adding container scanning to

4
00:00:36,908 --> 00:00:40,214
a DevOps pipeline. Here's the part where I tell you I am definitely

5
00:00:40,252 --> 00:00:43,414
going to post the slides on my site tonight. I've been that

6
00:00:43,452 --> 00:00:47,126
person chasing the speaker. It's royal pain, which is

7
00:00:47,148 --> 00:00:50,654
why you can go to robrich.org and end click

8
00:00:50,692 --> 00:00:54,474
on presentations here up the top and here's container scanning

9
00:00:54,522 --> 00:00:58,382
runs fast and stay safe. The slides are online right

10
00:00:58,436 --> 00:01:02,142
now. While you're here on robrich.org, let's click on about

11
00:01:02,196 --> 00:01:05,558
me and learn about some of the things that I've done recently. I'm a cyral

12
00:01:05,594 --> 00:01:08,462
developer advocate. If you're struggled with your data mesh,

13
00:01:08,526 --> 00:01:11,934
I would love to learn from you. I'm also a Microsoft MVP,

14
00:01:11,982 --> 00:01:15,506
a Docker captain and a friend of Redgate. AZ Givecamp is really

15
00:01:15,528 --> 00:01:19,622
fun AZ Givecamp brings volunteer developers together with charities to build

16
00:01:19,676 --> 00:01:22,918
free software. We start building software Friday after work.

17
00:01:23,004 --> 00:01:25,970
Sunday afternoon we deliver the completed software to the charities.

18
00:01:26,050 --> 00:01:29,686
Sleep is optional, caffeine provided if you're in Phoenix, come join us

19
00:01:29,708 --> 00:01:33,066
for the next AZ give camp. Or if you'd like a give camp in your

20
00:01:33,088 --> 00:01:36,474
neighborhood, hit me up on email or twitter and let's get a gift camp

21
00:01:36,512 --> 00:01:40,074
near you too. Some of the other things that I've done I

22
00:01:40,112 --> 00:01:44,074
do a lot with container and Docker and Kubernetes training and

23
00:01:44,112 --> 00:01:46,718
consulting. If you have that need, hit me up.

24
00:01:46,884 --> 00:01:50,346
And one of the things I'm particularly proud of, I replied to a Net Rocks

25
00:01:50,378 --> 00:01:53,390
podcast episode. They read my comment on the air and they sent me a mug.

26
00:01:53,470 --> 00:01:56,834
Woohoo. So there's my claim to fame, my coveted net

27
00:01:56,952 --> 00:02:00,126
rocks mug. So let's dig into container

28
00:02:00,158 --> 00:02:03,380
scanning now. We talked about this guy.

29
00:02:03,830 --> 00:02:07,060
Doesn't kubernetes just do this for me?

30
00:02:07,670 --> 00:02:10,930
Well, kind of. Let's take a look at what is Kubernetes.

31
00:02:11,090 --> 00:02:14,598
Oftentimes when we're greeted with Kubernetes, we have a diagram kind

32
00:02:14,604 --> 00:02:18,358
of like this. It shows the control plane here in green. It shows the

33
00:02:18,364 --> 00:02:22,742
worker nodes were in blue. And we can see the various components, the microservices

34
00:02:22,806 --> 00:02:26,426
within kubernetes. Now there's lots of microservices here that

35
00:02:26,448 --> 00:02:30,058
do a lot to keep kubernetes running, but they focus on

36
00:02:30,224 --> 00:02:33,966
keeping kubernetes running. They do nothing for our process in our

37
00:02:33,988 --> 00:02:37,614
container. Now, maybe when the user comes

38
00:02:37,652 --> 00:02:40,894
in, if they don't have the right port or a hostname they won't get

39
00:02:40,932 --> 00:02:44,510
past these load balancer. But once they're inside the pod,

40
00:02:44,590 --> 00:02:48,110
once they're inside the container, if they can compromise that container,

41
00:02:48,190 --> 00:02:51,854
they can easily pivot to any other pod within kubernetes.

42
00:02:51,982 --> 00:02:55,618
Kubernetes does nothing for protecting the security

43
00:02:55,784 --> 00:02:59,426
of these process running inside the container.

44
00:02:59,618 --> 00:03:03,362
Okay, so we don't have anything in kubernetes. Let's flip over to Docker.

45
00:03:03,506 --> 00:03:07,062
Now here in Docker we can compare Docker on the right to

46
00:03:07,116 --> 00:03:10,714
virtual machines. On the left with Docker we still have a

47
00:03:10,752 --> 00:03:14,106
hypervisor, we still have the same sandbox that

48
00:03:14,128 --> 00:03:17,734
we have with virtual machines. So the processes can't communicate

49
00:03:17,782 --> 00:03:21,586
with each other with shared network, with shared memory

50
00:03:21,638 --> 00:03:25,294
space, but they can communicate with each other like

51
00:03:25,332 --> 00:03:29,066
virtual machines do across the network. So if we're running Docker

52
00:03:29,098 --> 00:03:32,250
swarm or even if we're running containers inside of kubernetes,

53
00:03:32,410 --> 00:03:35,986
this container can reach out to this container and this container can reach out

54
00:03:36,008 --> 00:03:39,198
to this container. There's nothing inside Docker

55
00:03:39,294 --> 00:03:43,070
that keeps us secure. From a process perspective.

56
00:03:43,150 --> 00:03:45,620
We still need to manage the process here.

57
00:03:46,010 --> 00:03:50,018
So both from kubernetes and from Docker's perspective,

58
00:03:50,194 --> 00:03:53,362
they are responsible for keeping track of their pieces.

59
00:03:53,506 --> 00:03:56,530
We're responsible for the content in our container.

60
00:03:56,610 --> 00:04:00,590
We could think of kubernetes much like a firewall in front of the container.

61
00:04:00,690 --> 00:04:04,170
Now Kubernetes will do a lot for keeping track of our process.

62
00:04:04,240 --> 00:04:08,522
And if it crashes it'll restart. But it doesn't do a whole lot for

63
00:04:08,656 --> 00:04:12,746
making sure our containers don't get popped and making sure content doesn't

64
00:04:12,778 --> 00:04:15,754
leak. Now kubernetes does have namespaces,

65
00:04:15,882 --> 00:04:19,306
but namespaces are not a security boundary, they're an organizational

66
00:04:19,338 --> 00:04:22,806
boundary. Once we schedule content within kubernetes,

67
00:04:22,938 --> 00:04:26,930
every container is available to every other container over the network.

68
00:04:28,150 --> 00:04:31,778
Kubernetes focuses on keeping Kubernetes running.

69
00:04:31,944 --> 00:04:35,358
It's our task to secure the process in the container.

70
00:04:35,534 --> 00:04:38,838
So what is a container? Well, a container has a file system,

71
00:04:38,924 --> 00:04:42,150
it has users, it has a process, it has ports.

72
00:04:42,570 --> 00:04:46,162
This looks a lot like a Linux machine.

73
00:04:46,306 --> 00:04:49,706
And we know how to secure a Linux machine. That's easy. We can

74
00:04:49,728 --> 00:04:53,846
do processes like making sure we're not running as ute root,

75
00:04:53,958 --> 00:04:57,270
removing excess users, removing unused software,

76
00:04:57,350 --> 00:05:00,894
keeping software up to date, pretty standard stuff,

77
00:05:00,932 --> 00:05:04,640
were preventing unauthorized access into our system.

78
00:05:05,330 --> 00:05:09,038
Well it's a Linux machine except the way that

79
00:05:09,044 --> 00:05:12,746
we accomplish that is a little bit different. These are ephemeral,

80
00:05:12,778 --> 00:05:16,334
isomorphic and deterministic hardware. They're short lived,

81
00:05:16,382 --> 00:05:19,970
unchanging and the same every time. Now that's really cool.

82
00:05:20,040 --> 00:05:23,790
That means that we don't run patch Tuesday inside of a container.

83
00:05:23,870 --> 00:05:27,714
Rather we build a new container and replace these existing container with that new

84
00:05:27,752 --> 00:05:30,738
content. Now if we're going to replace the container,

85
00:05:30,834 --> 00:05:34,726
that works out really well. We just build a new container. And we know

86
00:05:34,748 --> 00:05:38,038
that the content in that new container now has the patches that

87
00:05:38,044 --> 00:05:41,418
we need. That also means that we don't really need to

88
00:05:41,424 --> 00:05:45,274
keep track of what's running inside the container. Because at the point were we

89
00:05:45,312 --> 00:05:49,242
created that container, that's when we establish that. Now if

90
00:05:49,296 --> 00:05:53,246
a container does get popped, that's easy enough. We just evict that container and

91
00:05:53,268 --> 00:05:56,394
spin up a new one. We may need to compensate for damage

92
00:05:56,442 --> 00:06:00,526
that it pivoted to, but we don't need to, for example, scrub the

93
00:06:00,548 --> 00:06:04,270
system. So securing container

94
00:06:04,350 --> 00:06:08,158
by default, every container can communicate with every other container,

95
00:06:08,254 --> 00:06:11,794
both inside docker and inside kubernetes. Now that

96
00:06:11,832 --> 00:06:15,834
makes sense, kind of. It makes our processes, our microservices

97
00:06:15,902 --> 00:06:19,474
really discoverable. But if we're going to want to limit

98
00:06:19,522 --> 00:06:22,646
traffic across our docker switch or around our

99
00:06:22,668 --> 00:06:26,280
Kubernetes cluster, we'll need to use a service mesh to do that.

100
00:06:27,530 --> 00:06:31,434
By default, if we pop any container in the cluster, we can now

101
00:06:31,472 --> 00:06:33,930
pivot to any other container in the cluster.

102
00:06:35,310 --> 00:06:38,774
Now all of our internal methods now have IP addresses.

103
00:06:38,822 --> 00:06:42,126
That's why we have all of our microservices. So if you're able to pop any

104
00:06:42,148 --> 00:06:45,550
of our containers, all of our containers are now at risk.

105
00:06:47,650 --> 00:06:50,910
As we look at threat vectors, we can look at threat vectors coming

106
00:06:50,980 --> 00:06:54,386
from outside. Maybe we have CVE and

107
00:06:54,408 --> 00:06:57,714
installed software. Maybe our app has a vulnerability that gets

108
00:06:57,752 --> 00:07:01,074
exploited by incoming requests. Or maybe

109
00:07:01,112 --> 00:07:04,434
we've exposed secrets inside of the content that we

110
00:07:04,472 --> 00:07:08,002
distribute to machines. Maybe the app didn't render

111
00:07:08,066 --> 00:07:11,542
that. But maybe we included more data

112
00:07:11,596 --> 00:07:15,366
than we should have. And these secrets could come from outside, but they

113
00:07:15,388 --> 00:07:19,274
could also come from underneath. Maybe our container is

114
00:07:19,312 --> 00:07:23,146
running with excessive permissions. Or maybe our software has

115
00:07:23,248 --> 00:07:26,810
a vulnerability that makes it wake up and do unexpected things.

116
00:07:26,960 --> 00:07:30,766
We can kind of group these into the

117
00:07:30,868 --> 00:07:34,490
threats coming from outside, the threats coming from underneath.

118
00:07:34,570 --> 00:07:38,254
And then once we're compromised, what can they pivot to?

119
00:07:38,452 --> 00:07:40,830
Wow, this sounds a lot like Linux.

120
00:07:42,850 --> 00:07:46,698
So the good news, because these are ephemeral, isomorphic and

121
00:07:46,724 --> 00:07:50,174
deterministic hardware. If any of our machines get compromised,

122
00:07:50,222 --> 00:07:53,502
if any of our containers get compromised, we don't have to do a big scrub,

123
00:07:53,566 --> 00:07:57,154
we just shut them down and create new ones. Now that's really

124
00:07:57,192 --> 00:08:00,710
nice. We do need to keep track of what did they pivot to and probably

125
00:08:00,780 --> 00:08:04,326
restart those containers as well. But for the

126
00:08:04,348 --> 00:08:07,798
most part, the damage is done and we've removed it.

127
00:08:07,884 --> 00:08:11,530
We don't need to uninstall things. We don't need to scrub stuff out

128
00:08:11,600 --> 00:08:14,774
things. Deterministic hardware ensures that we're

129
00:08:14,822 --> 00:08:18,154
the same every time. That's actually

130
00:08:18,192 --> 00:08:21,514
really good for container scanning as well, because once we know the

131
00:08:21,552 --> 00:08:25,594
contents inside of a container, we know the contents. We've established

132
00:08:25,642 --> 00:08:29,162
what's running inside that container, and we can take that list of software

133
00:08:29,226 --> 00:08:32,666
and compare it against a CVE database to know if our container

134
00:08:32,698 --> 00:08:35,890
is compromised or what software we might need to upgrade.

135
00:08:37,110 --> 00:08:39,934
Now, as we start talking about a DevOps pipeline,

136
00:08:39,982 --> 00:08:43,726
we'll start running tests against our system. We might have unit

137
00:08:43,758 --> 00:08:47,154
and integration tests. We might have static analysis of our source

138
00:08:47,202 --> 00:08:50,882
code. We might have open source license compliance.

139
00:08:51,026 --> 00:08:54,946
We might take inventory of our machine for known vulnerabilities.

140
00:08:55,138 --> 00:08:58,666
And then finally, we'll take all of these results and we'll compare it

141
00:08:58,688 --> 00:09:02,170
to our corporate level of tolerance.

142
00:09:02,990 --> 00:09:06,634
Now, it's really easy to say, if any

143
00:09:06,672 --> 00:09:10,346
of these tests fail, we're not going to deploy. But what

144
00:09:10,368 --> 00:09:13,530
if there's a vulnerability that is not patched?

145
00:09:13,690 --> 00:09:16,926
What if we don't have a vaccine for this

146
00:09:16,948 --> 00:09:20,558
threat? Should we shut down our business until there's a

147
00:09:20,564 --> 00:09:24,178
vaccine present? Should we hobble along? Should we

148
00:09:24,264 --> 00:09:27,602
deploy it anyway and see how we can manage that

149
00:09:27,656 --> 00:09:31,346
risk? It's possible that we may choose to say

150
00:09:31,448 --> 00:09:35,346
yes. If there's a vulnerability in our things, it's still

151
00:09:35,448 --> 00:09:39,506
good to push it. It might be better than the content that we

152
00:09:39,528 --> 00:09:42,520
have running in production because we've been able to patch other things.

153
00:09:42,890 --> 00:09:46,134
So let's take a look at each of these types of tests as we look

154
00:09:46,172 --> 00:09:49,562
at unit and integration tests. There's nothing new

155
00:09:49,616 --> 00:09:52,940
that I can add here. You need to do it.

156
00:09:53,310 --> 00:09:57,046
Running unit and integration tests helps us validate our software,

157
00:09:57,158 --> 00:10:01,242
and even so much more as we start running our build

158
00:10:01,306 --> 00:10:04,538
more frequently and deploying this content into production.

159
00:10:04,634 --> 00:10:08,490
A good suite of unit and integration tests helps us validate

160
00:10:08,570 --> 00:10:12,350
that updated libraries don't cause harm to our software.

161
00:10:13,250 --> 00:10:16,382
In short, unit and integration tests,

162
00:10:16,446 --> 00:10:19,906
you should do this. Next up, let's take

163
00:10:19,928 --> 00:10:23,694
a look at static code analysis. Now, there's lots of different tools

164
00:10:23,742 --> 00:10:27,186
that we can use for static code analysis. Things is where we start to

165
00:10:27,208 --> 00:10:31,202
look at our source code and see if we can find problems or vulnerabilities

166
00:10:31,266 --> 00:10:34,466
inherent in the way we've built our software. Now, I'm not here to pitch

167
00:10:34,498 --> 00:10:38,002
a software product. But as you grab these slides from robrich.org,

168
00:10:38,066 --> 00:10:41,186
you can click on each of these blue links to be able to get more

169
00:10:41,228 --> 00:10:44,506
information about these products. Hopefully that will help you to get

170
00:10:44,528 --> 00:10:47,754
past the blank page and discover the product that is the best fit

171
00:10:47,792 --> 00:10:52,330
for you. Static code analysis can help us avoid vulnerabilities

172
00:10:52,410 --> 00:10:55,898
within our system. Now as we avoid these vulnerabilities,

173
00:10:55,994 --> 00:10:58,830
then we can build more robust systems.

174
00:10:59,490 --> 00:11:03,774
Next up, license analysis. Now here's some more software products.

175
00:11:03,972 --> 00:11:07,630
Grab these slides from robrich.org and click through each of these blue links

176
00:11:07,710 --> 00:11:11,982
to be able to take a look at ways that we can validate our licenses.

177
00:11:12,126 --> 00:11:15,998
Now, what if we include a GPL library? Does that mean that

178
00:11:16,024 --> 00:11:19,618
our entire system needs to be open source? If that's a concern,

179
00:11:19,714 --> 00:11:23,762
validating these dependency these and the license requirements

180
00:11:23,826 --> 00:11:27,110
associated with that may be really important to the organization.

181
00:11:27,630 --> 00:11:31,094
Take a look at these software products and pivot to the software

182
00:11:31,142 --> 00:11:33,770
product that works great for your environment.

183
00:11:34,750 --> 00:11:39,210
Now let's take a look at policy validation.

184
00:11:39,870 --> 00:11:43,246
Now we have the results of our static analysis. We have the results of our

185
00:11:43,268 --> 00:11:46,670
unit and integration tests. We have the results of our license

186
00:11:47,970 --> 00:11:51,502
and now were given the choice to go

187
00:11:51,556 --> 00:11:55,022
or no go. If we have any failing unit tests,

188
00:11:55,086 --> 00:11:58,050
should we not deploy this new version of these software?

189
00:11:58,470 --> 00:12:02,126
If we have any license validation adjustments,

190
00:12:02,238 --> 00:12:06,338
should we fail the build. Now these are great checks to make.

191
00:12:06,424 --> 00:12:09,558
We may need to take a more pragmatic approach though, to say,

192
00:12:09,644 --> 00:12:13,206
well, it's better than it was, or we need

193
00:12:13,228 --> 00:12:17,250
to get this patch out right now because we're losing a whole lot of business.

194
00:12:17,420 --> 00:12:20,794
And the fact that there's a failing test really

195
00:12:20,832 --> 00:12:24,470
doesn't help us to solve this really urgent concern.

196
00:12:24,550 --> 00:12:27,610
Where were bleeding money out of our organization.

197
00:12:28,350 --> 00:12:31,674
So we may choose to have a different risk

198
00:12:31,722 --> 00:12:34,990
policy associated with the urgency of the deployment.

199
00:12:38,210 --> 00:12:41,454
So where's the serverless in all of things? Were been talking for

200
00:12:41,492 --> 00:12:45,934
some time about adding, testing and validating

201
00:12:45,982 --> 00:12:49,902
our software within our DevOps pipeline. Where's the serverless

202
00:12:49,966 --> 00:12:53,314
part? Where's the container part? Yeah,

203
00:12:53,512 --> 00:12:57,218
all of this so far is principles that work in DevOps pipelines.

204
00:12:57,314 --> 00:13:00,614
Whether you're focusing on container or whether you're focusing on

205
00:13:00,652 --> 00:13:03,730
any other type of software, you'll have unit tests,

206
00:13:03,810 --> 00:13:07,186
integration tests, static analysis,

207
00:13:07,298 --> 00:13:11,610
license validation, and let's add in the container space.

208
00:13:11,760 --> 00:13:15,750
Container scanning when we take a look at container scanning,

209
00:13:15,830 --> 00:13:19,370
our task is twofold. The first is to discover the content

210
00:13:19,440 --> 00:13:22,766
that we have running in our container. Now we need to look at

211
00:13:22,868 --> 00:13:26,382
the libraries that our application depends on. We need to look

212
00:13:26,436 --> 00:13:29,534
at the content that we have installed in the operating system

213
00:13:29,652 --> 00:13:33,194
and depending on our programming environment, we might have multiple

214
00:13:33,242 --> 00:13:36,918
sets of libraries. Maybe our website has our back end libraries,

215
00:13:36,954 --> 00:13:41,058
but it also has some node libraries to be able to construct our front end.

216
00:13:41,224 --> 00:13:44,626
In this case, we need to inventory all of this software. We need

217
00:13:44,648 --> 00:13:48,006
the package name and the version number. Now the

218
00:13:48,028 --> 00:13:52,230
great thing, once we have this inventory of software, we can compare this against

219
00:13:52,300 --> 00:13:55,970
a list of known vulnerabilities. Is any of our packages

220
00:13:56,050 --> 00:13:59,938
vulnerable or what severity is the vulnerability?

221
00:14:00,114 --> 00:14:03,946
Are any of these packages patched and should we upgrade? Now this is

222
00:14:03,968 --> 00:14:07,622
great. That's the purpose of container scanning. We inventory our software

223
00:14:07,686 --> 00:14:11,846
and we compare it to a list of vulnerabilities to take a look at what

224
00:14:11,888 --> 00:14:15,134
software might be vulnerable. Now the great thing here is once

225
00:14:15,172 --> 00:14:18,702
we've inventoried our software, our container, we know

226
00:14:18,756 --> 00:14:22,334
at that container hash all of the packages that are

227
00:14:22,372 --> 00:14:25,550
installed in our system. So periodically we can

228
00:14:25,620 --> 00:14:29,358
recompar that software list to our vulnerability database

229
00:14:29,454 --> 00:14:33,246
and understand if our container is newly vulnerable

230
00:14:33,358 --> 00:14:37,346
based on newly discovered vulnerabilities in some of the software installed

231
00:14:37,378 --> 00:14:40,630
in our system. We don't need to rescan the system.

232
00:14:40,780 --> 00:14:44,066
It's can ephemeral, isomorphic and deterministic

233
00:14:44,098 --> 00:14:47,526
system. If there's any problem we can evict that container and start

234
00:14:47,548 --> 00:14:50,906
up a new one. But we know exactly the content that's in

235
00:14:50,928 --> 00:14:54,790
that container. We just need to continuously compare it to our vulnerability

236
00:14:54,870 --> 00:14:59,046
database. So when should we scan?

237
00:14:59,158 --> 00:15:02,618
Now here's where we add some creativity to this process. There's lots

238
00:15:02,634 --> 00:15:06,446
of points where we can scan our container and based on

239
00:15:06,468 --> 00:15:10,350
that comparison, validate if our container is vulnerable.

240
00:15:11,010 --> 00:15:14,142
Now the container scanning process does take a while.

241
00:15:14,276 --> 00:15:18,050
So if your goal is to have a ten minute build

242
00:15:18,200 --> 00:15:21,794
and container scanning takes 10 minutes, then you won't be able to

243
00:15:21,832 --> 00:15:25,842
complete the container scanning within the build allotment. So maybe

244
00:15:25,896 --> 00:15:29,634
we schedule the scanning but we validate the results

245
00:15:29,682 --> 00:15:32,742
downstream or depending on our policy,

246
00:15:32,876 --> 00:15:36,182
our risk assessment. Maybe we just accept that our build

247
00:15:36,236 --> 00:15:39,690
is now going to take 20 minutes instead of ten. Yeah,

248
00:15:39,840 --> 00:15:43,718
these process of discovering the software within our container

249
00:15:43,814 --> 00:15:46,460
is pretty involved and it takes a while.

250
00:15:47,630 --> 00:15:51,182
So when can we scan? Well, we can start off by putting

251
00:15:51,236 --> 00:15:54,634
a process inside of our DevOps pipeline. The beauty

252
00:15:54,682 --> 00:15:58,926
here is that as our software gets built

253
00:15:59,028 --> 00:16:02,698
we can go build up this image. And once the image

254
00:16:02,714 --> 00:16:06,146
is built, but before we push it to the registry, we can kick off the

255
00:16:06,168 --> 00:16:09,006
process that will inventory this image.

256
00:16:09,198 --> 00:16:13,106
And then perhaps we compare that to our vulnerability database and

257
00:16:13,128 --> 00:16:16,766
identify if there are any severe threats within our container.

258
00:16:16,958 --> 00:16:19,858
Now this is all before we've pushed it to our registry.

259
00:16:19,954 --> 00:16:24,022
And if we can wait that long, then we know exactly when this

260
00:16:24,076 --> 00:16:27,746
software is vulnerable and we can block that thing from even getting into

261
00:16:27,788 --> 00:16:30,970
our registry if it's too vulnerable for our taste.

262
00:16:32,110 --> 00:16:35,242
Now next up, we might choose to include this

263
00:16:35,296 --> 00:16:38,922
scan in our container registry. What if we have some

264
00:16:38,976 --> 00:16:42,430
content that is pulled straight from Docker hub or another

265
00:16:42,500 --> 00:16:45,722
registry and isn't built through our DevOps pipeline?

266
00:16:45,866 --> 00:16:49,662
We may need to scan our container registry periodically to

267
00:16:49,716 --> 00:16:53,422
understand if there are any new containers that might be vulnerable and

268
00:16:53,476 --> 00:16:56,878
added to our registry. Now in the case where we pull a

269
00:16:56,884 --> 00:17:00,654
container and push it into our registry to be able to use it directly,

270
00:17:00,702 --> 00:17:03,762
then this is a great place to catch it. We could also just

271
00:17:03,816 --> 00:17:07,634
enumerate all of the containers. We know that if we've inventoried

272
00:17:07,682 --> 00:17:10,966
our system with this particular container hash, that we

273
00:17:10,988 --> 00:17:14,662
already know the content that's in there. So we can just

274
00:17:14,796 --> 00:17:18,994
quickly scan through our registry, validate that we've inventoried

275
00:17:19,042 --> 00:17:22,614
each of the containers there, and then continue matching

276
00:17:22,662 --> 00:17:26,170
that inventory list to our vulnerability database.

277
00:17:27,230 --> 00:17:30,666
Now next up, we could scan the content in

278
00:17:30,688 --> 00:17:34,718
our cluster. Now arguably it's too late, our content

279
00:17:34,804 --> 00:17:38,318
is already running. But if ever there's content that

280
00:17:38,324 --> 00:17:41,418
we pull directly from Docker hub to start in our cluster,

281
00:17:41,514 --> 00:17:44,718
then this is kind of the only place that we can catch it.

282
00:17:44,884 --> 00:17:48,194
Now arguably you should probably pull the content and push it into

283
00:17:48,232 --> 00:17:51,794
your own registry so that you can validate it first. But if ever we have

284
00:17:51,832 --> 00:17:55,518
a pod that directly references external systems,

285
00:17:55,614 --> 00:17:59,446
then we'll probably need to scan our cluster as

286
00:17:59,468 --> 00:18:03,270
well. Now the assumption of each of these is that

287
00:18:03,340 --> 00:18:07,206
that's the process where all things flow through. So if

288
00:18:07,228 --> 00:18:10,634
we're going to pull content from another registry, then we

289
00:18:10,672 --> 00:18:13,370
can't just can in the DevOps pipeline.

290
00:18:13,710 --> 00:18:17,306
If we're going to pull content from Docker hub and not set

291
00:18:17,328 --> 00:18:20,794
it into our own registry, then we can't just scan our

292
00:18:20,832 --> 00:18:24,606
registry. We need to take a look at the content running in our cluster as

293
00:18:24,628 --> 00:18:29,050
well. And there's one more spot. Kubernetes webhooks.

294
00:18:29,210 --> 00:18:33,230
Kubernetes webhooks are a great place to be able to catch the content because

295
00:18:33,300 --> 00:18:36,494
that's the pipeline that starts pods within our system.

296
00:18:36,612 --> 00:18:40,146
Let's double click into that and take a look how it works. Now here as

297
00:18:40,168 --> 00:18:44,046
we take a look at the Kubernetes webhook story, we have a mechanism

298
00:18:44,158 --> 00:18:47,094
that has two spots where we can tie into it.

299
00:18:47,212 --> 00:18:50,018
The first is the mutating webhooks.

300
00:18:50,194 --> 00:18:54,546
Now in series, each webhook

301
00:18:54,578 --> 00:18:57,922
gets called and it gets to change the yaml associated

302
00:18:57,986 --> 00:19:01,702
with this request. Here's a spot where we might inject

303
00:19:01,766 --> 00:19:05,210
sidecar containers for authentication or other resources.

304
00:19:05,630 --> 00:19:08,966
Next up, we have a validating webhook. Now, it calls

305
00:19:08,998 --> 00:19:12,826
each of them in parallel and each one gets to say yes or no.

306
00:19:13,008 --> 00:19:16,574
Now perhaps at this point we say, hey, that container is running as

307
00:19:16,612 --> 00:19:20,240
root, we're not going to let it through. We could also at this point

308
00:19:20,850 --> 00:19:24,026
go quickly, inventory the system and validate

309
00:19:24,058 --> 00:19:27,650
that there are no severe vulnerabilities within our containers.

310
00:19:28,390 --> 00:19:31,598
Now if this is the first time that we've seen this container image,

311
00:19:31,694 --> 00:19:34,766
we may not have enough time to complete that full container

312
00:19:34,798 --> 00:19:38,694
scan. But if we have seen this layer hash before,

313
00:19:38,812 --> 00:19:42,326
then we can probably just go look at the vulnerability database and

314
00:19:42,348 --> 00:19:46,006
validate that this system isn't too vulnerable to be able to get started in

315
00:19:46,028 --> 00:19:49,482
our cluster. So Kubernetes webhooks is a great

316
00:19:49,616 --> 00:19:53,354
place to be able to give

317
00:19:53,392 --> 00:19:56,634
that go or no go signal into our

318
00:19:56,752 --> 00:20:00,262
cluster because if we say no, taken that pod,

319
00:20:00,326 --> 00:20:03,402
that container won't even get started in our cluster.

320
00:20:03,546 --> 00:20:07,006
That's great. Everything that starts in our cluster is

321
00:20:07,028 --> 00:20:10,990
going to go through this process. So that validating webhook is a break place

322
00:20:11,060 --> 00:20:14,218
to be able to dig in and do some final container

323
00:20:14,234 --> 00:20:17,906
scanning. Now, hopefully we've already seen that image before,

324
00:20:18,008 --> 00:20:21,166
so we're just validating the results. If this is the first time we've

325
00:20:21,198 --> 00:20:25,054
seen the image and it takes 10 minutes to inventory the software,

326
00:20:25,182 --> 00:20:29,586
then were not replying in time, and that validating webhook

327
00:20:29,618 --> 00:20:33,670
is probably going to fail straight away. So maybe we fail it and

328
00:20:33,740 --> 00:20:37,186
in 10 minutes, once we have the results, we try again to schedule

329
00:20:37,298 --> 00:20:40,526
that pod. So these are the various

330
00:20:40,578 --> 00:20:44,458
places where we can take a look at our content and each one has value

331
00:20:44,544 --> 00:20:48,234
depending on where we have these content. If we're going to

332
00:20:48,272 --> 00:20:51,990
always rebuild every image, including these images

333
00:20:52,070 --> 00:20:55,726
from other sources, then putting in our DevOps pipeline might

334
00:20:55,748 --> 00:20:59,226
be sufficient. But if there are any containers that aren't

335
00:20:59,258 --> 00:21:02,814
built in our DevOps pipeline, we'll need to also add content into our

336
00:21:02,852 --> 00:21:06,414
registry. Now if there are any images

337
00:21:06,462 --> 00:21:09,778
that aren't pulled directly from our private registry, but are pulled from a

338
00:21:09,784 --> 00:21:13,774
public registry, then we'll also need to add either a Kubernetes validating

339
00:21:13,822 --> 00:21:16,994
webhook or a periodic scan through our cluster.

340
00:21:17,122 --> 00:21:20,566
And the Kubernetes validating webhook is a great place to do that

341
00:21:20,588 --> 00:21:23,826
double check. Nothing will start inside of our cluster

342
00:21:23,938 --> 00:21:27,990
if we've stopped it at the validating webhook.

343
00:21:30,670 --> 00:21:33,690
Now, what should we use for container scanning software?

344
00:21:34,190 --> 00:21:38,058
I'm definitely not here to pitch container scanning software and

345
00:21:38,144 --> 00:21:40,826
there are many more choices than this,

346
00:21:41,008 --> 00:21:44,566
but this might help you get past a blank page as you grab these slides

347
00:21:44,598 --> 00:21:48,126
from robrich.org. Click through each of these links to be able

348
00:21:48,148 --> 00:21:51,390
to take a look at that software and choose the one that best

349
00:21:51,460 --> 00:21:55,406
resonates with you and your organization. Now your choices

350
00:21:55,438 --> 00:21:58,766
may be different than mine, but for the purpose of demos,

351
00:21:58,878 --> 00:22:02,798
I do need to pick one. So I will reluctantly pick anchor,

352
00:22:02,894 --> 00:22:06,694
maybe alphabetically, but anchor is

353
00:22:06,732 --> 00:22:10,214
free and open source, so it's not a bad choice. It is

354
00:22:10,252 --> 00:22:13,720
definitely not fast, but it does a good job.

355
00:22:15,450 --> 00:22:19,066
Anchor, it's free and open source. It runs as a set

356
00:22:19,088 --> 00:22:22,746
of microservices and it will do the inventory both

357
00:22:22,768 --> 00:22:25,850
of operating system packages and of app packages.

358
00:22:26,270 --> 00:22:29,126
It's great for container scanning for cves,

359
00:22:29,318 --> 00:22:33,114
but it is not fast. The docs are also

360
00:22:33,152 --> 00:22:37,226
not great. Let's take a look though at how we might include anchor

361
00:22:37,258 --> 00:22:40,510
scanning and when you choose the particular software that you're going to use,

362
00:22:40,580 --> 00:22:44,382
then you can use the same methodology to run your build. Our first

363
00:22:44,436 --> 00:22:47,998
stop in anchor is to download the Docker compose file.

364
00:22:48,094 --> 00:22:52,222
Now this allows us to be able to start up the anchor microservices.

365
00:22:52,366 --> 00:22:56,086
What I find interesting about this is that it is a suite of

366
00:22:56,108 --> 00:23:00,102
microservices, but this docker compose file just starts the same

367
00:23:00,156 --> 00:23:03,846
image a bunch of times, passing in different arguments. So is

368
00:23:03,868 --> 00:23:07,106
it microservices or is it a distributed

369
00:23:07,138 --> 00:23:10,954
monolith? That's an argument for another day. Once we've got

370
00:23:10,992 --> 00:23:14,566
anchor started, then we can docker compose exec

371
00:23:14,678 --> 00:23:19,526
or Pip install anchor CLi to be able pardon

372
00:23:19,558 --> 00:23:23,014
me. Once we've got Docker compose up,

373
00:23:23,072 --> 00:23:27,038
we can do a docker compose exec or a pip install

374
00:23:27,124 --> 00:23:30,766
to be able to get at these anchor CLI. That anchor CLI will

375
00:23:30,788 --> 00:23:34,462
allow us to run the commands necessary to be able to get

376
00:23:34,516 --> 00:23:38,026
at the container scanning content. So whether we've

377
00:23:38,058 --> 00:23:41,774
exec in or PIP installed, we now have the anchor CLI

378
00:23:41,822 --> 00:23:45,682
and we can begin the process first status first step

379
00:23:45,736 --> 00:23:49,094
is to do an anchor CLI system status that will tell

380
00:23:49,132 --> 00:23:52,406
us about the content that we have running now.

381
00:23:52,428 --> 00:23:56,326
That's perfect. We have all of our microservices up. We know that the

382
00:23:56,348 --> 00:23:59,962
anchor system is ready and the next one we do is an anchor CLI system

383
00:24:00,016 --> 00:24:03,386
feeds list. Now as part of listing the feeds, it will

384
00:24:03,408 --> 00:24:06,854
kick off the process of syncing the virus

385
00:24:06,902 --> 00:24:10,338
definitions, not virus, these vulnerability definitions.

386
00:24:10,454 --> 00:24:14,554
Now they have vulnerability definitions for each of these package

387
00:24:14,602 --> 00:24:18,622
managers, NuGet, NPM, Maven and

388
00:24:18,676 --> 00:24:21,854
they also have vulnerability lists for each

389
00:24:21,892 --> 00:24:26,202
version of Linux. So we have red hat and Ubuntu and Alpine

390
00:24:26,266 --> 00:24:29,682
and each of the versions of these so that we can take

391
00:24:29,736 --> 00:24:32,882
a container and we can inventory it in all the ways.

392
00:24:33,016 --> 00:24:36,326
Now the docs say that it takes about 10 minutes to populate all

393
00:24:36,348 --> 00:24:39,974
the can data but let's take a look at the one that I did.

394
00:24:40,092 --> 00:24:44,326
Here's my where

395
00:24:44,348 --> 00:24:48,082
is it feeds update. We can see that I started

396
00:24:48,156 --> 00:24:51,100
on the 20th and I finished on the 23rd.

397
00:24:51,870 --> 00:24:54,620
Yeah, that was a little bit more than 10 minutes.

398
00:24:57,150 --> 00:25:00,458
Okay, so we've taken a look at how we get the

399
00:25:00,544 --> 00:25:03,822
anchor system updated. Now once we have

400
00:25:03,876 --> 00:25:07,722
that list of feeds. Actually let's take another look at the list of feeds

401
00:25:07,786 --> 00:25:11,018
and take a look at these things. So we have gem,

402
00:25:11,114 --> 00:25:14,434
Java, NPM, Nuget, Python and that's really

403
00:25:14,472 --> 00:25:18,382
great because we have the vulnerabilities for each one of the package managers.

404
00:25:18,526 --> 00:25:22,398
We also then have vulnerabilities in each version of alpine

405
00:25:22,494 --> 00:25:26,050
including the Amazon, two Centos, Debian,

406
00:25:27,050 --> 00:25:30,390
Rel, Ubuntu. And so if you have

407
00:25:30,540 --> 00:25:34,610
an operating system listed here you'll be able to get at the vulnerabilities

408
00:25:34,690 --> 00:25:37,914
in the packages that might be installed in that operating system

409
00:25:38,032 --> 00:25:41,514
together with these packages that you may have installed as

410
00:25:41,552 --> 00:25:42,620
part of your application.

411
00:25:46,110 --> 00:25:49,114
So that's the next step is grabbing the

412
00:25:49,152 --> 00:25:53,994
content and using that to be able to check our container

413
00:25:54,042 --> 00:25:57,370
to see if our container is vulnerable. Let's take a look at the commands.

414
00:25:57,450 --> 00:26:00,746
Our first step is an anchor cli image add and we'll

415
00:26:00,778 --> 00:26:04,334
give it that container or rather we'll give it that image

416
00:26:04,382 --> 00:26:07,938
and version. Now this will queue the process.

417
00:26:08,024 --> 00:26:11,666
It won't actually execute synchronously. Now if we choose we

418
00:26:11,688 --> 00:26:15,682
can do an anchor cli image wait and that wait will wait

419
00:26:15,736 --> 00:26:18,902
until that task is done. So now we've got the

420
00:26:19,036 --> 00:26:22,422
build spinning for maybe 10 minutes now. That's fine.

421
00:26:22,556 --> 00:26:26,374
We're taking a look at things image and we're waiting for it to be done.

422
00:26:26,572 --> 00:26:29,898
And once it's done then we can take a look at the

423
00:26:29,904 --> 00:26:33,558
results. Anchor Cli image get will get the results

424
00:26:33,654 --> 00:26:37,420
and we can further filter those results based on

425
00:26:37,790 --> 00:26:42,294
the inventory list or the vulnerability results.

426
00:26:42,422 --> 00:26:46,222
As we take a look at these vulnerability results we can choose the

427
00:26:46,276 --> 00:26:49,786
particular type of results that we'd like. Now in this case I'm

428
00:26:49,818 --> 00:26:53,246
looking for all, but we could also look for those specific to a

429
00:26:53,268 --> 00:26:56,802
type of package manager or the operating system and that will

430
00:26:56,856 --> 00:27:00,530
export that list of results in JSON.

431
00:27:01,030 --> 00:27:04,418
We can also take a look at the list of installed packages. So I'm going

432
00:27:04,424 --> 00:27:06,578
to take a look at the content and in this case I'm going to take

433
00:27:06,584 --> 00:27:10,550
a look at the content across all the systems. Now we can save that

434
00:27:10,620 --> 00:27:13,986
list of content off and later we can recompare

435
00:27:14,018 --> 00:27:16,950
that list of contents against our vulnerability database.

436
00:27:17,290 --> 00:27:21,558
Did a new vulnerability get discovered? We can quickly identify

437
00:27:21,654 --> 00:27:24,954
the active container that we have that have that

438
00:27:24,992 --> 00:27:28,694
particular version installed. So now we know immediately

439
00:27:28,742 --> 00:27:32,526
which builds we should restart to be able to secure that software from

440
00:27:32,548 --> 00:27:33,630
that vulnerability.

441
00:27:35,890 --> 00:27:39,838
So let's take a look at how we might integrate this build. I have here

442
00:27:39,924 --> 00:27:42,974
a regular build that just does the normal

443
00:27:43,022 --> 00:27:45,934
things. Docker build, Docker push,

444
00:27:46,062 --> 00:27:49,202
kubernetes apply. Now that's perfect.

445
00:27:49,336 --> 00:27:55,438
This DevOps pipeline, maybe I'm kicking it off from Teamcity

446
00:27:55,534 --> 00:27:58,806
or Jenkins and it's just running things script to be able

447
00:27:58,828 --> 00:28:02,450
to run the content. Now how would I add container scanning?

448
00:28:02,610 --> 00:28:06,434
Let's come in and we'll add all of those anchor commands. So after I've

449
00:28:06,482 --> 00:28:10,038
built my content, before I push my content, I'm going

450
00:28:10,044 --> 00:28:13,962
to go run these anchor commands. Now in this case I'm going to pass

451
00:28:14,016 --> 00:28:17,786
in not only my image name but also my docker file. So anchor can

452
00:28:17,808 --> 00:28:21,066
do some additional checks and I'm going to choose to wait.

453
00:28:21,168 --> 00:28:24,606
So yeah, this may take a long time, but I really want to

454
00:28:24,628 --> 00:28:28,414
make sure that my container is good before I push it into my

455
00:28:28,452 --> 00:28:31,742
container registry. So once it's done I'm going to go

456
00:28:31,796 --> 00:28:35,714
grab the results in JSON format and I'll export those

457
00:28:35,752 --> 00:28:38,978
to vuln JSON now next I'm going

458
00:28:38,984 --> 00:28:42,354
to take a look inside that vulnerability JSON and look

459
00:28:42,392 --> 00:28:46,170
for anything that is vulnerable. If there's anything that's

460
00:28:46,190 --> 00:28:50,422
vulnerable, I'm going to fail the build. Now we talked

461
00:28:50,476 --> 00:28:54,198
previously about how that might be a little bit aggressive. What if there's a

462
00:28:54,204 --> 00:28:57,270
vulnerability that doesn't have a cure?

463
00:28:57,610 --> 00:29:01,066
Should we block the push or might we want

464
00:29:01,088 --> 00:29:04,906
to just push it anyway and take extra care with that build?

465
00:29:05,088 --> 00:29:08,678
Now there's probably patched software in other places,

466
00:29:08,774 --> 00:29:12,282
so just saying that there is any vulnerability at all

467
00:29:12,416 --> 00:29:15,978
might not be pragmatic enough for our organization. Now depending

468
00:29:15,994 --> 00:29:19,438
on your needs, that might be exactly what you need. Let's take a look at

469
00:29:19,444 --> 00:29:23,426
that vulnerability JSON. Here's that list of vulnerabilities and

470
00:29:23,448 --> 00:29:27,250
we can see the CVE, we can take a look at the content and

471
00:29:27,320 --> 00:29:30,754
we get severity in this case

472
00:29:30,792 --> 00:29:34,526
it's medium and we know whether this CVE

473
00:29:34,638 --> 00:29:38,342
is patched. So in this case there is no

474
00:29:38,396 --> 00:29:41,890
fix. A medium vulnerability

475
00:29:41,970 --> 00:29:45,798
with no fix. Should we block pushing? Should we let it

476
00:29:45,804 --> 00:29:49,194
go? Maybe a pragmatic approach might

477
00:29:49,232 --> 00:29:53,878
be no high vulnerabilities and no unpatched vulnerabilities.

478
00:29:54,054 --> 00:29:56,300
That might be a good pragmatic guess.

479
00:29:56,910 --> 00:30:00,314
Okay, so once we've identified the things and we've talked about

480
00:30:00,352 --> 00:30:03,614
how this is likely, not all of that practical, we can

481
00:30:03,652 --> 00:30:07,098
next take a look at the content that we've got. So let's

482
00:30:07,114 --> 00:30:10,526
take a look at these content. And yeah, that's a wall of

483
00:30:10,548 --> 00:30:14,110
packages. This JSON wasn't formatted very well. So instead

484
00:30:14,180 --> 00:30:18,354
let's take a look specifically at the content, just for my operating system.

485
00:30:18,472 --> 00:30:21,906
Here's all the packages and their versions. So I

486
00:30:21,928 --> 00:30:26,274
can now take a look at the content and compare this periodically

487
00:30:26,322 --> 00:30:29,654
to my vulnerability database to know if my software has

488
00:30:29,692 --> 00:30:33,830
become newly vulnerable based on recently discovered vulnerabilities.

489
00:30:34,570 --> 00:30:38,258
I'll save both the vulnerability list and the content

490
00:30:38,364 --> 00:30:41,654
off to a safe spot where I tag

491
00:30:41,702 --> 00:30:45,434
that together with the image hash. And now

492
00:30:45,472 --> 00:30:48,506
I can recheck that container periodically to

493
00:30:48,528 --> 00:30:51,050
know if that image has been newly compromised.

494
00:30:52,030 --> 00:30:55,854
Now once I've validated this image, and I know it's good enough,

495
00:30:55,972 --> 00:30:59,694
now I'll push that to my registry. Now I know that only things

496
00:30:59,732 --> 00:31:02,746
that have been validated are in my registry.

497
00:31:02,938 --> 00:31:06,302
Well, what if a software package becomes newly vulnerable,

498
00:31:06,366 --> 00:31:09,970
but is currently in the registry? Should we purge it out of the registry?

499
00:31:10,630 --> 00:31:14,434
Well, maybe if it's the image that

500
00:31:14,472 --> 00:31:17,894
is currently running in production. What if a pod needs

501
00:31:17,932 --> 00:31:21,286
to restart now? Maybe there's no image that it

502
00:31:21,308 --> 00:31:22,550
can use to restart.

503
00:31:24,570 --> 00:31:28,950
It might take a more pragmatic rather than a more absolute methodology

504
00:31:29,030 --> 00:31:32,138
here to say, well, let's purge old containers out of

505
00:31:32,144 --> 00:31:35,290
our registry that are vulnerable, that aren't also

506
00:31:35,360 --> 00:31:38,634
in use. Okay,

507
00:31:38,672 --> 00:31:41,766
so we've modified our build to include container scanning.

508
00:31:41,798 --> 00:31:45,118
And this was really helpful in being able to get this anchor build,

509
00:31:45,204 --> 00:31:48,718
to be able to validate that our software is not vulnerable in the

510
00:31:48,724 --> 00:31:52,286
way that is tolerable for our build. Now that

511
00:31:52,308 --> 00:31:55,854
was great. We can do that for an on prem build. Let's also

512
00:31:55,892 --> 00:31:59,186
take a look at how we might do this with GitHub actions. Now the

513
00:31:59,208 --> 00:32:02,642
cool part about doing it with GitHub actions as opposed to doing it on

514
00:32:02,696 --> 00:32:06,562
Prem, is that GitHub actions will keep the database up to date.

515
00:32:06,696 --> 00:32:10,054
So we don't need to sync the feeds list, we don't need to

516
00:32:10,092 --> 00:32:13,218
start anchor all of that is handled by GitHub actions.

517
00:32:13,314 --> 00:32:17,014
That's perfect. Now here's one GitHub actions that

518
00:32:17,052 --> 00:32:20,234
will allow us to do all of those steps in one place.

519
00:32:20,432 --> 00:32:24,266
We'll pass in the image, we'll pass in the docker file. We're also going

520
00:32:24,288 --> 00:32:28,822
to look through app packages, so it'll look for NPM and Nuget

521
00:32:28,886 --> 00:32:32,186
and Python packages as well. And then here's a fail

522
00:32:32,218 --> 00:32:35,680
on build command, which I haven't been able to get to work.

523
00:32:36,130 --> 00:32:39,742
In theory it's supposed to fail if there are

524
00:32:39,796 --> 00:32:42,670
too many vulnerabilities, but it doesn't.

525
00:32:43,250 --> 00:32:46,626
Now they also recommend in their docs to go grab that

526
00:32:46,648 --> 00:32:50,258
anchor reports folder that this task outputs and echo it

527
00:32:50,264 --> 00:32:54,158
to the screen, or even better, push it as a build asset.

528
00:32:54,254 --> 00:32:58,114
Now I can put it inside my dashboard alongside the test results,

529
00:32:58,242 --> 00:33:01,990
and I'm specifically running this if always, if the build

530
00:33:02,060 --> 00:33:05,510
fails for any reason, I still want the reports.

531
00:33:06,250 --> 00:33:09,542
So let's take a look at this GitHub build. Now,

532
00:33:09,596 --> 00:33:13,286
I have two versions of the software in this case, here's the container

533
00:33:13,318 --> 00:33:16,982
scanning pass version, and here's these container scanning fail version.

534
00:33:17,046 --> 00:33:20,986
And I've just committed different versions of software in each place.

535
00:33:21,168 --> 00:33:24,334
Now you can see that with the failing one it

536
00:33:24,372 --> 00:33:27,706
fails, and with the passing one it passes.

537
00:33:27,898 --> 00:33:31,390
But I did some experiments here. Could I get it to pass

538
00:33:31,460 --> 00:33:35,394
or fail based on doing different flags? Now here's where I was trying

539
00:33:35,432 --> 00:33:38,798
to use the build fail flag,

540
00:33:38,974 --> 00:33:42,494
but I also tried committing a JavaScript file

541
00:33:42,542 --> 00:33:46,322
straight into my public folder, and it didn't

542
00:33:46,386 --> 00:33:49,734
use static analysis of the files. Rather it

543
00:33:49,772 --> 00:33:53,174
only looked at my package manifest. So it looked at my

544
00:33:53,212 --> 00:33:56,662
package JSon and my packages config and

545
00:33:56,716 --> 00:34:00,050
used that to be able to infer the software that was installed.

546
00:34:00,130 --> 00:34:03,820
So if you just grab one Javascript file and you set it in place,

547
00:34:04,350 --> 00:34:07,846
yeah, unfortunately anchor is going to miss this. So let's

548
00:34:07,878 --> 00:34:11,466
take a look at the build that produced this. And this build is identical in

549
00:34:11,488 --> 00:34:14,910
both sides. It's just the content that it's using

550
00:34:14,980 --> 00:34:17,946
to be able to validate if it succeeds or fails.

551
00:34:18,138 --> 00:34:21,726
So we'll start off by checking out our software standard here.

552
00:34:21,828 --> 00:34:25,086
We'll do a docker build, and in this case I'm tagging

553
00:34:25,118 --> 00:34:28,514
it as container scanning and giving it a GitHub shaw as

554
00:34:28,552 --> 00:34:32,030
my version. Now that definitely isn't semantic versioning,

555
00:34:32,110 --> 00:34:35,470
but it does mean that if ever we're using this image,

556
00:34:35,550 --> 00:34:38,502
we'll know exactly the version of the software that built it,

557
00:34:38,556 --> 00:34:41,958
which might help us reproduce that build. Next,

558
00:34:42,044 --> 00:34:45,782
let's kick off the anchor scan. We talked about how I can't get fail build

559
00:34:45,836 --> 00:34:49,254
to work, so maybe setting it to false or leaving it off

560
00:34:49,292 --> 00:34:52,586
might be a good move. But in this case I've passed in my

561
00:34:52,608 --> 00:34:55,830
docker file as well and I want to include app packages.

562
00:34:55,990 --> 00:34:59,850
Next I'm going to output this build results to

563
00:34:59,920 --> 00:35:03,034
these console. Now that's helpful if we want to use

564
00:35:03,072 --> 00:35:06,842
our build output. But even better, I'm going to take those reports

565
00:35:06,906 --> 00:35:10,286
and I'm going to upload those as build assets together with

566
00:35:10,308 --> 00:35:13,474
my unit test results. Now I can include these as the

567
00:35:13,512 --> 00:35:17,106
portions resulting from this build. Periodically I might cant to

568
00:35:17,128 --> 00:35:21,090
recheck my containers to see if they're vulnerable and having both

569
00:35:21,160 --> 00:35:24,606
the container results, the content results

570
00:35:24,638 --> 00:35:27,894
and the vulnerability list might be really helpful for that.

571
00:35:28,012 --> 00:35:31,254
I'm specifically doing this if always so that if it

572
00:35:31,292 --> 00:35:34,706
failed previously, I'm still going to get these results.

573
00:35:34,898 --> 00:35:38,326
Now let's go check to see if it's vulnerable. In this

574
00:35:38,348 --> 00:35:41,706
case I'm looking for any vulnerability and if I find any then I

575
00:35:41,728 --> 00:35:46,646
will fail the build. Now what if there's a vulnerability that isn't patched?

576
00:35:46,838 --> 00:35:49,942
Should we not allow that in our

577
00:35:50,016 --> 00:35:54,254
cluster? Or should we allow content at

578
00:35:54,292 --> 00:35:57,738
a particular level? Maybe block no severe

579
00:35:57,834 --> 00:36:02,058
vulnerabilities and maybe block patched

580
00:36:02,154 --> 00:36:05,746
vulnerabilities. This is definitely a thing that

581
00:36:05,768 --> 00:36:09,794
you need to discuss with your team and find your corporate level of

582
00:36:09,832 --> 00:36:13,490
comfort with how much vulnerabilities can be in place.

583
00:36:13,640 --> 00:36:17,430
Now we've learned in this industry that just saying

584
00:36:17,500 --> 00:36:21,350
that there's a problem without a cure

585
00:36:22,570 --> 00:36:26,374
may not be the best reason to be able to block out the

586
00:36:26,412 --> 00:36:27,000
everything.

587
00:36:29,450 --> 00:36:32,714
So we took a look at a GitHub actions run and how

588
00:36:32,752 --> 00:36:36,294
we can use GitHub actions to avoid needing to sync

589
00:36:36,342 --> 00:36:40,006
our content. And now we have this cloud based build that is excellent

590
00:36:40,038 --> 00:36:43,598
at being able to validate our containers and get this content

591
00:36:43,684 --> 00:36:47,262
into place. We took a look

592
00:36:47,316 --> 00:36:51,194
at both the failing and passing GitHub action

593
00:36:51,242 --> 00:36:54,946
scenario that was really cool. And so you might choose to clone this

594
00:36:54,968 --> 00:36:58,082
repository and use that as an example,

595
00:36:58,216 --> 00:37:01,540
or take this methodology and use it with a different tool.

596
00:37:03,430 --> 00:37:07,186
Kubernetes. Kubernetes is a great mechanism for keeping

597
00:37:07,218 --> 00:37:10,918
our containers running, but it doesn't protect the process.

598
00:37:11,084 --> 00:37:15,378
The process of protecting the process running in our container is our responsibility.

599
00:37:15,554 --> 00:37:19,670
Kubernetes only protects itself. We need to secure the container.

600
00:37:21,050 --> 00:37:24,326
This has been a lot of fun getting to show you container scanning here at

601
00:37:24,348 --> 00:37:27,734
comp 42. I'll be at that spot where the conference has

602
00:37:27,772 --> 00:37:31,086
designated for a live q and A. Or if you're watching this later, hit me

603
00:37:31,108 --> 00:37:35,034
up on Twitter at rob underscore rich. And you can grab these slides

604
00:37:35,082 --> 00:37:38,910
and these code right now@robrich.org. Click on presentations.

605
00:37:39,250 --> 00:37:42,638
Thanks for joining us and getting to talk about container scanning. I'll see you in

606
00:37:42,644 --> 00:37:43,130
the next session.

