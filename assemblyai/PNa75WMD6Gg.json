{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/52abaaab-d84b-4b85-a4b6-1f7a49efa57f", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["argocd", "best", "brief", "can", "challenges", "cloud", "cluster", "conf fourty two", "configuration", "devops engineer", "gitin", "gitops", "happens", "kubernetes", "matrica labs", "modified", "practices", "stored", "these", "truth", "utibeabasi umanah", "words"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "id": "5c28f9f9-2f79-4460-92a1-844b2634c63c", "status": "completed", "error": null, "text": "Everyone, thanks for genius. My name is UTube and I'll be talking on Githubs in Kubernetes with Algo CD. So without further ado, let's get into it. So what is GitHubs? Well, GitHubs is a continuous delivery strategy. These, our infrastructure and application configuration are defined as code and stored in a vision control system like Git. So basically it uses it as a single source of truth. And what this means is that whatever is defined in the Git repository is exactly what is deployed in these cloud environment. So GitHub allows us to automate cloud infrastructure using infrastructure as code and software development best practices such as git code review and CI CD. There are a few advantages of well, there are a lot of advantages of using GitHubs, but we will just outline a few. First off, it allows us to have faster and safer deployments, it gives us ease of performing rollbacks, it allows for traceability and it makes it easy to eliminate configuration drifts. There are a lot of Gitops tools out these, but for the purpose of these talk we will only be focusing on Algo CD. So Algo CD is a declarative GitHub's continuous derivative tool for kubernetes. It is open source and basically it uses GitHub's principles to deploy applications into kubernetes clusters. Before we take a look at exactly how Algo CD works, let's take a moment to talk about push versus pull deployments. So in a push deployment strategy, basically you would have a CI CD pipeline that builds your application and then updates your Kubernetes cluster or redeploys or deploys the application into the cluster. For example, you would have a Jenkins server as your CI CD build tool. And then whenever Jenkins builds your application, you need to give Jenkins access to the cluster in order for you to perform some Kubectl commands in order to update your application. But this isn't entirely safe because let's say your Jenkins server gets hacked, the hacker would have access to your cluster. So in order to solve this, that's where the pool deployment strategy comes in. So basically you would have a software deployed in your cluster which will pull the git repository for changes, and if there's a change it will redeploy the application. So how does ArgoCD works? ArgoCD is implemented as a Kubernetes controller and it continuously monitors the applications running in your cluster and compares it to what is defined in git repository. So basically it watches a particular repository for changes, let's say you update the version of a particular docker deployment image, so Algo CD will detect that change and implement the change in the cluster without you having to do that manually. So any modifications made to the desired target states in a Gitin repo can be automatically applied and reflected in these specified target environment. Let's take a look at some of the features of ArgoCd. So first off, we have support for multiple config and templating tools such as customize helm jsonnets and plain Yaml. So however your application configuration is defined, be it a helm chart or plain communities, Yamu manifests, Ago CD is able to generate the correct manifest from that and deploy that into a cluster. So with ArgoCd we are able to manage and deploy to multiple clusters. So you would only need to deploy ArgoCD into a single cluster, and ago CD handles the deployment into any other cluster you specify. We also have SSO integration with GitHub, GitLab, Microsoft, LinkedIn, et cetera. So by default, ArgoCD comes with basic authentication using username and password, but you have the ability to activate single sign on as well. So in keeping to Gitops practices, Ago CD allows us to roll back or roll anywhere to any application configuration committed in Git repository. So basically you would have the ability to roll back to previous states, let's say maybe previous commits, that defines a particular state of your applications. So ago city comes with a web interface that allows us to visualize the health status of the resources deployed in your cluster. So let's actually take a look at what this web interface looks like. So here we have the ArgocD web UI, and you can see I have three applications deployed, the CLI app, the declarative app, and these helm demo. So ago CD detects that one of these applications is out of sync, which means that what is deployed in the cluster doesn't match what is specified in the git repository. And it gives me the option to sync this manually. But I can also configure ago CD to do this automatically, and it detects that the declarative app and the helm demo are all healthy. So here in the ago city web UI I can do pretty much anything. I can create new applications, new deployments, I can roll back the deployment, I can sync application, et cetera. So ago city also comes with a command line tool, the Ago CD CLI. And using this we can also create applications. We can roll back a particular deployment we can sync after as well. Yeah, okay, so ago CD also gives us. Automate enables us to detect configuration drifts like we said before. So if a particular state of deprecations deployed in these cluster doesn't match what's in the Giz repository, ArgoCD detects us as well. So ago CD. We also have webhook integration with GitHub basebuckets and GitLab. And Ago CD allows us to override certain parameters. Let's say you deployed a helm charts with algo CD. You would be able to override these helm values using Algo CD. Yeah, so that's been my talk. Thanks for listening and I hope you learned a lot.", "words": [], "utterances": null, "confidence": 0.896361154639176, "audio_duration": 440.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Algo CD is a GitHub's continuous derivative tool for kubernetes. It uses GitHub's principles to deploy applications into kbernetes clusters. It allows us to have faster and safer deployments. Also allows for traceability and it makes it easy to eliminate configuration drifts.", "auto_highlights_result": {"status": "success", "results": [{"count": 7, "rank": 0.08, "text": "Algo CD", "timestamps": [{"start": 30892, "end": 31970}, {"start": 103732, "end": 104750}, {"start": 105732, "end": 106394}, {"start": 125432, "end": 126242}, {"start": 220376, "end": 221006}, {"start": 426636, "end": 427746}, {"start": 433276, "end": 434310}]}, {"count": 1, "rank": 0.07, "text": "new applications", "timestamps": [{"start": 370296, "end": 371054}]}, {"count": 3, "rank": 0.07, "text": "CI CD", "timestamps": [{"start": 74024, "end": 75090}, {"start": 135788, "end": 136306}, {"start": 150532, "end": 151386}]}, {"count": 1, "rank": 0.07, "text": "multiple clusters", "timestamps": [{"start": 269368, "end": 270558}]}, {"count": 1, "rank": 0.07, "text": "kubernetes clusters", "timestamps": [{"start": 119816, "end": 121330}]}, {"count": 1, "rank": 0.06, "text": "pull deployments", "timestamps": [{"start": 129890, "end": 131110}]}, {"count": 1, "rank": 0.06, "text": "new deployments", "timestamps": [{"start": 371102, "end": 371790}]}, {"count": 5, "rank": 0.06, "text": "Git repository", "timestamps": [{"start": 56788, "end": 57690}, {"start": 187228, "end": 187974}, {"start": 207812, "end": 209230}, {"start": 305988, "end": 307162}, {"start": 350544, "end": 351846}]}, {"count": 1, "rank": 0.06, "text": "customize helm jsonnets", "timestamps": [{"start": 247312, "end": 249334}]}, {"count": 3, "rank": 0.06, "text": "tool", "timestamps": [{"start": 109818, "end": 110062}, {"start": 151876, "end": 152526}, {"start": 380236, "end": 380790}]}, {"count": 1, "rank": 0.05, "text": "GitHub basebuckets", "timestamps": [{"start": 417396, "end": 418746}]}, {"count": 2, "rank": 0.05, "text": "configuration drifts", "timestamps": [{"start": 95462, "end": 96934}, {"start": 398422, "end": 399606}]}, {"count": 1, "rank": 0.05, "text": "Jenkins access", "timestamps": [{"start": 158100, "end": 158990}]}, {"count": 1, "rank": 0.05, "text": "previous states", "timestamps": [{"start": 310932, "end": 311920}]}, {"count": 3, "rank": 0.05, "text": "application configuration", "timestamps": [{"start": 41676, "end": 43378}, {"start": 251652, "end": 253310}, {"start": 304132, "end": 305274}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}