{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/2ef5284b-6de7-4ecd-8d86-2649322742e9", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["amenitiz", "antonkalik", "combination", "conffourtytwo", "crafting", "creating", "js", "meets", "nodejs", "openai", "personalized", "plans", "seniorsoftwareengineer", "suggests", "tailored", "weve"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "id": "d85cba98-3205-4f73-993e-2afa095a5232", "status": "completed", "error": null, "text": "Hi and welcome to my session about crafting sport activity series using Nodejs together with OpenAI. Today we are diving to the journey through the sport activity suggestion service using OpenAI. All generation will be based on our indicators. Let's jump into the lineup and we'll see what's there. First of all, we're going to jump into the small introduction, we're going to talk a little bit about OpenAI. We're going to set up our NodeJs application. We will check how to connect and how to do this connection, how to do prompting, messaging, what's the difference in the role. We will check the options, the body, how to look like this connection and how we actually can get those suggestions from OpenAI. And then we will crafting up everything together and finally we do some conclusions and we will discuss about the possibilities. So as I said, we are going to build an application which will be able to send to us daily sports activities based on our indicators. So let's take a look on the schema and in order to better understand how it's going to work. So the service is designed to provide users activity based on the indicators and last activity, it's like a circle of the data. You accomplished activity, next time asking for a new one AI analyze it. Your data and service sends to client the results with new sport activity with plan how to do that? Okay, so there is a variation of sport activities. To refine the AI suggestions for users, we will compile an extensive list of variation of sport activities. This list will be provided to OpenAI API in message. The AI will leverage this information and will take from the list the activity what feeds based on indicators and last activity. So literally you get the last activity, you have your indicators and you get the suggestion based on that information. So as I said, we're going to use an OpenAI. By utilizing OpenAI technology we can access powerful analytics tool that examine user input such as a lifestyle, height, weight to generate custom tailored activity plans specifically for the user. The benefit of using OpenAI in our case lies in the sophisticated algorithms which can be trained. As we want to start to building our service, we should first define the scope of activities and use data point that are relevant to our application. So we going to use, as I say before, nodejs. We have to accomplish that connection. So that's what we plan to do. To employ Nodejs in conjunction with Expressgs which will weve as a web application framework to manage routing controllers, modeling and communication database. We're going to use nextgs. So before to jump into the code to check it out. How we going to deal with all of the stuff? We have to set up our OpenAI account. For that you have to go to OpenAI.com, create your organization in order to obtain the API key. So there is going to be an API account where you can set up all of this stuff and then finally you're going to get your open API key, right. So in this case weve going to dive into the setup node JS service itself and for that in my case I'm just using the create node JS application and I'm going to use the framework Express. This will generate for me necessary files to build my node JS service. So let's take a look on the schema. How exactly going to look like our application. Well so our source of data going to be on postgres. We're going to set the user indicators and activities. Activities is like a history of the list of activities of user. Also indicators have to belongs to the user in order to get this request to bouncegres we're going to use the next JS but in front of all of this we're going to use the exprs JS which is going to as I say before handle our routing responses and to generation of data. We're going to use OpenAI to handle session of the user. We're going to use redis. We're not going to focus so much for that because this is not topic about this. We're going just a little bit touch that part. But first of all before we generate in order to install everything, let's take a look. What's the stack of dependency we're going to have in our package JSon. There's going to be as I say next postgres Regis what we're going to use in my case I'm using a validator, just validate login user and sign up. But this is the COVID of the authentication part but which is very important. We are going to use the OpenAI package nodejs. You have to just install it and we can start using it. Right. So you can see this over here. This is version four for now. And now we have to create an Env file and this is the stack of my variables. And as you can see here that I'm using open API key over here. And that open API key will be provided to the combination of open AI package. Well now how the structure of this application has to look like we have a user which has as I said indicators and activities based on those indicators which is weight, height, lifestyle and last activities. What been accomplished last activity. It can be running on a distance and stuff like that. Based on this information. We have to provide this information to OpenAI. OpenAI will generate that information to us and that's how we're going to get a new sport activity for today. It's actually not specifically for today because route will allow us to generate the data. Depends when we want it. It depends of the client. Like I want this daily or I can just get this by weeks or by month. But anyway we're always going to look on the indicators and activities. But how are we going to do this? The whole flow on the request, right. So request for the sport activity of course will go through the identification plus Regis, Regis will help to us with cache. Then we're going to get user from where we can get the last activity together with indicators. Then we will build based on this data information a prompt. That prompt will go to the request to open API. OpenAI API. And then that's how we're going to get the response with result of sport activity before to dive into this stuff, how we're going to generate our prompt. Let's briefly take a look on the next setup how I built it. So this is the connection to database with different environments. So that's how we can get our data from Db and here by migrations files. From next we can see how structured our tables. In our case we're going just to have very simple user which going to have first name, last name with a username and email. We just need this for sign up. So because that's service application going to have that users and that user going to have each of them going to have indicators. It's just one row in the table for belongs to the user. Where we're going to store our age, weight, height, lifestyle. And based on this information we're going to do those generations. So here also weve going to store as I say as a history of the activities of the user. Here you can see how was the data we're going to use. That's going to be activity type. The activity type is actually list of activities. This is the constant of the list of activities and duration which has to be duration of how long that activity have been accomplished during which time in order to start build our service we going to use some base abstract model which going to deal for us in order to request data from database. So this is the base model and based it on a base model. We're going to build our nodejs for indicators for user and for activities. So user model, extending the base model and we have to assign the table name which is users. And from against that table we're going to be able to create user find by email or find by username. So that part we will simplify in order just to reuse those models across our controllers. So the same approach with indicator model when we able to find all indicators by user id or updating by user id. So all of this methods is actually leveraging these indicators through this model. And we can deal like that with database. So activity model, absolutely the same. We just have to find the activity by using this method. Now slowly we can arrive to the initial point where our application is starting. So very easy one, we just going to start our application, we identify the router and we do this connection to radius. And literally that's it. So let's briefly take a look on the radius. It's just a plain setup. We have to create a client. We do this connection to radius using our env variables and I'm just reuse that and I create the class for radius in order just to simplify the communications request to radius in order for example to set session or get session or delete session. Right. And middleware actually looks also pretty straightforward. There is nothing specific ones like we have jot tokens and we have a secret and that's how we deal with middleware. So that means like when we using for example postman we have to provide the first of all we have to sign up. Then we're going to get the token, we have to use bearer token and then we can start using our endpoints in order to get our suggests from AI. Here are the list of routes. So as I said, we deal with authentication router and we're using the out middle bar where we have all of these checks in order to provide to us the data about user. Of course we can have an access to the session in order to get all of data regarding the user. And you can see in the end that we able to get the suggestions by the suggests and by the slash indicator. We have to be able to update our indicators, depends on the user. Okay, so now let's try to understand what's the expectations we have from the application. Here we have a get request to the API with a suggests. And that suggests will have to send to us a JSon which with this JSon we have to be able to deal on our other client side application. Let's say we can assume that this is going to be some react native application or even on iwatch you can get this application and we can deal with this JSon right. So in this case as you can see we have an activity type which cycling the duration have to be 45 minutes. This number in minutes. So weve expecting something like that. We have to have a description how exactly it has to happen. Then we have to check how much we have to consume our water during this activity. And here you can see also an explanation why we need to do this. Okay. And as you can see the cycling is great activity choose for you as a provides both and so on and so on. So this explanation actually based it on the last activity. So maybe explanation can be depends of like you did nothing previously and this is going to be like explain like hey you did nothing last time. And let's start from running for example. And we have an array of plan like how we have to start this exercise, how we have to deal with this exercise during the way and how we have to finish that. So here's a bit different activity type by just showing like these responses from postman. This is another activity skiing. In the same way we have to deal with the skiing 16 minutes duration is after duration we deal with the subscription. How much water consume has to be in milliliters. And explanation like you can see here for example based it on your previous activity of crossfeed. That means that guy previously has a crossfeed and now he's creating the scheme. Some of you may be thinking like hey what's the region or what's the weather that user having right now? Maybe it's a summer but AI generating to us key. Of course you can customize as you want. Your suggests depends of prompting and this is the part that's going to be next one. But let's dive into this communication between back and the client and how it can work on the application itself with this timers. For example as I said we have a get request with a suggestion and bumps. Json just does responds with this sport activity to the client. So timer actually invoke this API call and then that's how we can get back to this sport activity. And the same way in the indicator. Hey I need just to update my indicator because my weight is changed and the lifestyle actually a little bit changed depends of this activities what we accomplishing. And now we have to start configure our OpenAI in node Js and everything is super simple. We just have to provide the open API key to the class OpenAI and we able to reuse this OpenAI instance and in the controller, as you can see, literally all magic happens right over here. So get suggestion controller having this indicator, we asking from indicator model by the user id and we asking for the last activity by the user id. And that's how by the indicator and last activity we got result and result actually has to be set that we have to set that result also for the activity using activity model we have to just insert what the activity has been accomplished. Of course this is not ideal. I'm just showing the barrett just a base model how we can deal with this. Of course we have to insert the activity of the real accomplished. And we can check it actually with a communication with a client to get some statistic from iwatch in such way only after that we can save insert something to the activity. But now it's just like very simple, bare enough information how we have to deal with this, right? Because we are generating our activity, based it on the last activity and we're just sending this result for now. So pretty simple. And the most important thing, how we have to do this communication against open AI API. First of all, we have to build our system prompt. There is two things. What we have to understand that when we send a message to the completion, we dealing with the different roles. I will explain you a little bit later, what's the difference between those roles. But previously we have to generate set up our prompts. Okay, so in my case, I provided the detailed explanation in my prompt for the system prompt, what exactly we are expecting from response from AI, what kind of response has to be, as you can see that I'm telling that I'm expecting to get a JSOn and I'm listing all of those items in JSon, like how it has to look like, okay. And as you can see that activity type is actually, this is the list of, it's just an array of activities. I'm just sorting them and just provide here to this file. And this is how we can set up system prompt and tell to AI what exactly weve expecting from AI as a response. And here you can see the last activity message, which means that if last activity exists at all, we have to provide this as a parameter, as a user prompt. User has his own indicators, actually activity also has a part of indicator and that's how we're dealing with AI. Weve telling like hey, system has to return me adjacent with that kind of structure. Base it on indicators. Base it on something. What we want to tell like hey, base it on these indicators. Please tell me what I have to do and all of these parts we have to provide to the completions as a messages. And you can see here role system, we provide that content system prompt, which is that message where we are telling how we have to, what we're expecting from AI, and a content for as a user prompt where we are providing our indicators. So let's a little bit take a look on the setup of this completion. Okay, so what is this? Messages. Messages is the context of conversation with the eye. Messages are like the back and forth text between you and the AI. So each message has a role to tell the eye who is speaking. Okay, so as I said, if the role is user, it's like the message is coming from a person using the eye, asking a question or making a statement. If the role is system, it's a special kind of message that gives the eye instructions or information about how to behave, but it's not part of the conversation itself. Right. If the role is assistant, there can be another role is assistant. It's the AI own message or responses. Okay, so what you can see here, the temperature, 0.9. Okay, so I will explain a bit that part as well. So temperature is a way of controlling how creative or surprising the AI responses are. If the temperature is low, the AI replies will be more predictable and safer. If the temperature is higher, the AI is more likely to give you unique and more unexpected responses. Okay, and the model itself, the model actually is the version of the AI you are talking to. Just like your phone has different models with a variation of features, AI has different models that can do different things, right? So some are smarter or more creative. In my case, GPT 3.5 turboids are more cheaper and more stable model, which we can use now, I could say like it's more cheaper even. But anyway, we already can deal with this model and get a good result. Okay, and also I would like to mention another key which is going, it could be as a combination max tokens. It's not over here, but you can set up Max tokens, which means the maximum numbers of pieces of text in the AI is allowed to generate in its response. Okay, so you can think of a token as a single word or punctuation mark. Okay, so Max token sets a limit on how long the AI response can be. Well, suggestion controller has to be, as I said, construct a little bit different. It's just a presentation of how we're going to get this result each time. When I get the result, I'm creating immediately from result activity type, as the last one was, there but it doesn't mean that it's really accomplished. Of course it has to be in a different way, but in terms of presentation it's in such way and indicators have to be updated from result from the client actually. So we have to update hi to say like hey I'm doing a bit different, my lifestyle has changed and I have to update my indicators. I have, I think different weight and those indicators will affect for the next activity what you're going to accomplish next time. So we sense from client the indicators, updating indicators, then they're getting the activity. And then based on this information we got back the sport activity. And for update indicator we have another controller where we have to just as usual deal with indicator model. We have to update by user id and set those indicators updates right away. And from database perspective I'm using postgres. You can see the list of activities here. You can see the activity type has been accomplished with the specific duration, there is a user id and there is a history of when it's been accomplished. Now it's like finally this session was about the open AI integration, how we can deal with these prompt messages and so on. You can find this project and to check and play around by yourself. From my personal GitHub account you can just get the pull up AI server and run it by yourself and play around. And of course previously you have to set up your OpenAI account and get the API key. So thank you so much for the attention and see you.", "words": [], "utterances": null, "confidence": 0.932034087447105, "audio_duration": 1839.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Today we are diving to the journey through the sport activity suggestion service using OpenAI. Service is designed to provide users activity based on the indicators and last activity. All generation will be based on our indicators.\n- So all of this methods is actually leveraging these indicators through this model. So activity model, absolutely the same. We just have to find the activity by using this method. Now slowly we can arrive to the initial point where our application is starting.\n- Communication between back and the client and how it can work on the application itself with this timers. When we send a message to the completion, we dealing with the different roles. Messages is the context of conversation with the eye. If the temperature is higher, the AI is more likely to give unique responses.", "auto_highlights_result": {"status": "success", "results": [{"count": 1, "rank": 0.1, "text": "users activity", "timestamps": [{"start": 118344, "end": 119838}]}, {"count": 2, "rank": 0.09, "text": "activity model", "timestamps": [{"start": 759988, "end": 760910}, {"start": 1240316, "end": 1241026}]}, {"count": 2, "rank": 0.09, "text": "sport activities", "timestamps": [{"start": 145872, "end": 146982}, {"start": 154788, "end": 156042}]}, {"count": 11, "rank": 0.09, "text": "last activity", "timestamps": [{"start": 122680, "end": 123694}, {"start": 172984, "end": 174062}, {"start": 177816, "end": 178938}, {"start": 482018, "end": 482834}, {"start": 546496, "end": 547610}, {"start": 1022184, "end": 1023150}, {"start": 1219576, "end": 1220850}, {"start": 1227672, "end": 1228430}, {"start": 1295696, "end": 1296890}, {"start": 1405988, "end": 1406922}, {"start": 1410740, "end": 1411562}]}, {"count": 2, "rank": 0.09, "text": "new sport activity", "timestamps": [{"start": 137676, "end": 139122}, {"start": 500608, "end": 501830}]}, {"count": 1, "rank": 0.09, "text": "sport activity series", "timestamps": [{"start": 25818, "end": 27114}]}, {"count": 1, "rank": 0.09, "text": "daily sports activities", "timestamps": [{"start": 103970, "end": 105914}]}, {"count": 7, "rank": 0.09, "text": "activity type", "timestamps": [{"start": 647152, "end": 648170}, {"start": 648672, "end": 649354}, {"start": 976792, "end": 977698}, {"start": 1056190, "end": 1057162}, {"start": 1381308, "end": 1382438}, {"start": 1698384, "end": 1699194}, {"start": 1783308, "end": 1784102}]}, {"count": 1, "rank": 0.09, "text": "result activity type", "timestamps": [{"start": 1697936, "end": 1699194}]}, {"count": 1, "rank": 0.08, "text": "great activity", "timestamps": [{"start": 1011236, "end": 1012218}]}, {"count": 1, "rank": 0.08, "text": "custom tailored activity plans", "timestamps": [{"start": 203238, "end": 204978}]}, {"count": 3, "rank": 0.07, "text": "indicator model", "timestamps": [{"start": 734652, "end": 735958}, {"start": 1213284, "end": 1214560}, {"start": 1762916, "end": 1763790}]}, {"count": 1, "rank": 0.07, "text": "open AI API", "timestamps": [{"start": 1309188, "end": 1312510}]}, {"count": 26, "rank": 0.07, "text": "indicators", "timestamps": [{"start": 42400, "end": 43530}, {"start": 107604, "end": 108714}, {"start": 121032, "end": 122094}, {"start": 171656, "end": 172430}, {"start": 179980, "end": 180994}, {"start": 329906, "end": 330674}, {"start": 338604, "end": 339458}, {"start": 465700, "end": 466618}, {"start": 469640, "end": 470686}, {"start": 523928, "end": 524526}, {"start": 548752, "end": 549638}, {"start": 616312, "end": 616926}, {"start": 698688, "end": 699638}, {"start": 739930, "end": 741270}, {"start": 751228, "end": 752498}, {"start": 916790, "end": 917694}, {"start": 1418680, "end": 1419726}, {"start": 1436972, "end": 1437666}, {"start": 1442272, "end": 1443142}, {"start": 1477832, "end": 1478794}, {"start": 1714868, "end": 1715878}, {"start": 1730492, "end": 1731570}, {"start": 1736140, "end": 1736882}, {"start": 1745232, "end": 1746250}, {"start": 1747142, "end": 1747766}, {"start": 1767960, "end": 1768734}]}, {"count": 1, "rank": 0.06, "text": "open AI package", "timestamps": [{"start": 453330, "end": 455310}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}