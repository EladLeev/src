1
00:01:44,910 --> 00:01:48,494
All right, let's take a look at what Gitops is with Argocd,

2
00:01:48,542 --> 00:01:52,126
and then we'll spend some time understanding vault and the injector

3
00:01:52,158 --> 00:01:55,540
in kubernetes. Then we're going to follow that up with a demo.

4
00:01:58,870 --> 00:02:03,746
So, intro to Gitops with Argocd if

5
00:02:03,768 --> 00:02:08,394
you're not familiar with Gitops, it's the process of having your

6
00:02:08,592 --> 00:02:11,978
application code and your infrastructure code all

7
00:02:12,064 --> 00:02:16,134
stored in git. And basically git becomes

8
00:02:16,182 --> 00:02:19,850
your source of truth and you deploy straight from git.

9
00:02:20,210 --> 00:02:24,586
In this case, Argocd is a tool that implements Gitops

10
00:02:24,618 --> 00:02:28,602
principles and it's implemented as a Kubernetes controller

11
00:02:28,666 --> 00:02:32,942
which continuously monitors running applications

12
00:02:33,006 --> 00:02:36,322
in your environment. It compares the current

13
00:02:36,456 --> 00:02:40,338
live state against the desired target state

14
00:02:40,504 --> 00:02:43,730
as specified inside of your Git repo.

15
00:02:44,570 --> 00:02:48,306
A deployed application whose live state starts

16
00:02:48,338 --> 00:02:52,290
to deviate from the target state is considered out of sync.

17
00:02:52,450 --> 00:02:56,754
You have the option to have auto sync enabled, so revert

18
00:02:56,802 --> 00:03:00,054
back to what you want your desired state

19
00:03:00,092 --> 00:03:03,974
to be, which is in your Git repository. And again, that's a source of truth

20
00:03:04,102 --> 00:03:07,734
that is available, or you can leave it at the default of manual

21
00:03:07,862 --> 00:03:11,550
and then you can alert on a deviation if you wish.

22
00:03:12,210 --> 00:03:15,818
So ArgoCD reports and visualizes the differences

23
00:03:15,914 --> 00:03:19,854
while providing facilities to automatically or

24
00:03:19,892 --> 00:03:23,538
manually sync the live state back to desired target state, as I mentioned.

25
00:03:23,704 --> 00:03:27,102
And then any modifications made to the desired

26
00:03:27,246 --> 00:03:31,326
target state in the Git repo will automatically get applied

27
00:03:31,358 --> 00:03:34,638
and reflected in your target environment. So it's

28
00:03:34,654 --> 00:03:38,310
an amazing technology, and many organizations are moving

29
00:03:38,460 --> 00:03:42,550
to Gitops. Now let's take a look at the app,

30
00:03:42,620 --> 00:03:46,520
the demo app that we're going to use today. I call it the school app.

31
00:03:47,070 --> 00:03:50,970
And as you might know, I offer

32
00:03:51,120 --> 00:03:55,178
an academy, a teaching academy for DevOps and platform

33
00:03:55,264 --> 00:03:59,526
engineering. And as such I use this school app

34
00:03:59,648 --> 00:04:03,486
as a demo application in my

35
00:04:03,508 --> 00:04:06,974
tech and aid academy. So here what we're going to do, we're going to have

36
00:04:07,012 --> 00:04:10,858
this application that allows users

37
00:04:10,874 --> 00:04:14,386
to enroll in courses. And you can

38
00:04:14,408 --> 00:04:17,682
see the back end here, the course

39
00:04:17,736 --> 00:04:21,986
that was created and what users or what students

40
00:04:22,088 --> 00:04:25,966
have been enrolled into that course. And the components

41
00:04:25,998 --> 00:04:29,214
of this application is basically it's written

42
00:04:29,262 --> 00:04:33,730
in view JS. That's the front end JavaScript

43
00:04:33,810 --> 00:04:37,306
framework that is used for the user to interact with

44
00:04:37,328 --> 00:04:40,486
the front end. The backend API is written

45
00:04:40,518 --> 00:04:44,662
in fast API, which is a great python API

46
00:04:44,726 --> 00:04:48,202
framework. So as the user interacts with

47
00:04:48,336 --> 00:04:51,518
the front end, the front end talks to the

48
00:04:51,524 --> 00:04:56,282
backend app, and then our data layer is using MongoDB,

49
00:04:56,346 --> 00:05:00,010
that's our database, and then our API

50
00:05:00,090 --> 00:05:03,614
talks to the database and of course the database

51
00:05:03,662 --> 00:05:06,722
responds back and then the data is

52
00:05:06,856 --> 00:05:10,334
rendered back to the user in their browser.

53
00:05:10,462 --> 00:05:14,530
Now, in the very beginning of our demo, we're going to hard code the

54
00:05:14,680 --> 00:05:17,950
connection to MongoDB inside of our app.

55
00:05:18,030 --> 00:05:21,506
So the credentials, the username and password, they're going to be hard coded

56
00:05:21,538 --> 00:05:24,866
in here, which is definitely not the way to go in production.

57
00:05:24,978 --> 00:05:28,762
You need to have some sort of a method to

58
00:05:28,896 --> 00:05:32,298
automatically rotate secrets and store those secrets outside

59
00:05:32,384 --> 00:05:35,626
the application. In a secrets management store such as

60
00:05:35,648 --> 00:05:39,274
Hashicorp Vault, the application

61
00:05:39,392 --> 00:05:43,862
output in Kubernetes will look something like this. When you run Kubectl

62
00:05:43,926 --> 00:05:47,374
getall, you're going to see that we have three pods. We've got

63
00:05:47,412 --> 00:05:51,114
an API pod, a front end pod and the MongoDB

64
00:05:51,162 --> 00:05:54,754
pod. They're all deployed as deployments. And of

65
00:05:54,792 --> 00:05:58,066
course we have services for each one of those

66
00:05:58,248 --> 00:06:02,194
pods and they're using cluster IP for

67
00:06:02,232 --> 00:06:06,022
their service type. All right, let's now add

68
00:06:06,076 --> 00:06:09,318
vault to the mix and see how things will work for our school

69
00:06:09,404 --> 00:06:10,680
app application.

70
00:06:13,370 --> 00:06:17,074
So once again, we have the same workflow. We got our user

71
00:06:17,122 --> 00:06:21,062
talking to the front end and we've got our fast app API

72
00:06:21,206 --> 00:06:24,118
and we got the front end talking to the API.

73
00:06:24,294 --> 00:06:28,042
And then MongoDB needs to be accessed. But this time

74
00:06:28,096 --> 00:06:31,374
we're going to rely on vault to supply us with the

75
00:06:31,412 --> 00:06:34,954
necessary credentials. So the API will reach out to vault,

76
00:06:35,002 --> 00:06:38,814
it needs to authenticate into vault and then reach

77
00:06:38,852 --> 00:06:42,494
out to get the database credentials so that the API can

78
00:06:42,532 --> 00:06:46,366
now talk to the database. And of course the database talks

79
00:06:46,398 --> 00:06:48,580
back to the API and the front end,

80
00:06:49,830 --> 00:06:53,666
the application is rendered in the front end. So to get

81
00:06:53,688 --> 00:06:57,394
to that step, we need to understand first, the first step of accessing

82
00:06:57,442 --> 00:07:01,414
vault and in our unique case here is going to be using

83
00:07:01,532 --> 00:07:04,806
Kubernetes authentication method. So the

84
00:07:04,828 --> 00:07:08,714
Kubernetes authentication method is one of many authentication methods that

85
00:07:08,752 --> 00:07:12,746
vault allows. And in this case it

86
00:07:12,768 --> 00:07:16,154
is a method to solve the secret zero problem.

87
00:07:16,352 --> 00:07:19,946
Basically what the secret zero problem is, how do you access the

88
00:07:19,968 --> 00:07:23,434
first secret, how do you get secrets out of vault?

89
00:07:23,482 --> 00:07:26,814
But first you need to authenticate into vault. So how do we authenticate into

90
00:07:26,852 --> 00:07:30,222
vault securely? So that's where we have

91
00:07:30,276 --> 00:07:34,394
a vault agent sidecar that can sit beside your

92
00:07:34,452 --> 00:07:36,930
application container in the same pod.

93
00:07:37,750 --> 00:07:40,946
This pod is going to have a service account or

94
00:07:40,968 --> 00:07:44,050
youll application is going to have a namespace and a service account.

95
00:07:44,200 --> 00:07:48,134
And what will happen is the application pod will

96
00:07:48,172 --> 00:07:51,894
get, or the vault agent will get a jot token from the

97
00:07:51,932 --> 00:07:55,638
kubelet inside the node where the application is running

98
00:07:55,804 --> 00:07:59,894
and that jot token is going to get passed over as the vault

99
00:07:59,942 --> 00:08:03,434
agent authenticates into vault. And there is

100
00:08:03,472 --> 00:08:07,318
a connection between the vault server

101
00:08:07,494 --> 00:08:11,966
and the Kubernetes API that we'll set up. And that way

102
00:08:12,148 --> 00:08:15,406
the vault server can pass that

103
00:08:15,428 --> 00:08:19,614
jot token over to the API and basically ask the question does

104
00:08:19,652 --> 00:08:23,262
the pod or did the pod that I just used the jot token for,

105
00:08:23,316 --> 00:08:27,086
was that initiated under your management, Mr. Kubernetes?

106
00:08:27,198 --> 00:08:31,454
Kubernetes will come back and say yes, I know about it, it's under my management

107
00:08:31,582 --> 00:08:35,234
and that is the authentication piece. Then what will happen is

108
00:08:35,272 --> 00:08:38,886
vault will come back, deliver a token and a token has a

109
00:08:38,908 --> 00:08:42,594
policy attached to it to authorize the application or the vault

110
00:08:42,642 --> 00:08:46,310
agent to retrieve secrets at specific paths.

111
00:08:46,890 --> 00:08:50,086
So that's kind of the Kubernetes authentication method

112
00:08:50,118 --> 00:08:54,026
in a nutshell. And from here we want to talk a little bit about the

113
00:08:54,048 --> 00:08:56,890
vault agent sidecar injector.

114
00:08:57,310 --> 00:09:01,502
So the vault agent workflow in Kubernetes looks

115
00:09:01,556 --> 00:09:05,066
like this. You have an application Kubernetes pod

116
00:09:05,178 --> 00:09:08,474
with a mounted volume inside of this pod.

117
00:09:08,522 --> 00:09:11,886
We've got our application. So our app lives here.

118
00:09:12,068 --> 00:09:16,722
We also have the vault agent sidecar that I just mentioned and

119
00:09:16,776 --> 00:09:19,954
we have our vault server. So what happens

120
00:09:19,992 --> 00:09:23,630
is the vault agent will go ahead and authenticate with the vault server.

121
00:09:23,790 --> 00:09:27,190
The vault server will respond back with an application token.

122
00:09:27,610 --> 00:09:31,558
The vault agent will store this app token inside of a

123
00:09:31,564 --> 00:09:35,126
sync file in the mounted volume so the application can

124
00:09:35,148 --> 00:09:38,390
actually access this token. And if the application is

125
00:09:38,460 --> 00:09:42,154
vault aware we can stop here and the application can grab this

126
00:09:42,192 --> 00:09:45,766
token, talk directly to the vault server and retrieve the secrets

127
00:09:45,798 --> 00:09:49,354
directly. But that of course means that youll application code

128
00:09:49,472 --> 00:09:53,510
needs to have a way to talk to the vault API and retrieve secrets.

129
00:09:53,590 --> 00:09:56,878
So you're going to have to make changes to the code.

130
00:09:57,044 --> 00:10:00,286
But we can take this a step further and we can actually say, you know

131
00:10:00,308 --> 00:10:04,206
what, let's have the vault agent retrieve secrets on behalf

132
00:10:04,238 --> 00:10:07,954
of the application and that way it makes the application

133
00:10:08,072 --> 00:10:12,020
vault unaware and you don't have to make any changes to the application.

134
00:10:12,710 --> 00:10:16,706
Of course vault needs to check against the policy that's associated

135
00:10:16,738 --> 00:10:20,870
with that token to make sure that the vault agent can retrieve secrets from

136
00:10:20,940 --> 00:10:24,600
the server at the particular path that it requested it at.

137
00:10:25,450 --> 00:10:30,486
And from there there's

138
00:10:30,518 --> 00:10:35,862
something called the vault agent template where we can actually templatize

139
00:10:36,006 --> 00:10:39,420
how we want to render those secrets for our application.

140
00:10:40,030 --> 00:10:43,726
So what happens is now the vault agent is going to

141
00:10:43,748 --> 00:10:47,774
use this template to grab the secrets and render them in a particular

142
00:10:47,892 --> 00:10:51,210
format to allow the application to retrieve

143
00:10:51,290 --> 00:10:54,930
my username and password for my MongoDB. And once

144
00:10:55,000 --> 00:10:58,338
the application can read this out of the file that's again in the

145
00:10:58,344 --> 00:11:02,530
mounted volume here, it can now connect to the MongoDB

146
00:11:03,110 --> 00:11:06,886
database and the application continues to

147
00:11:06,908 --> 00:11:10,566
run as before. So let's talk a little

148
00:11:10,588 --> 00:11:13,510
bit about the Vault agent sidecar injector.

149
00:11:13,930 --> 00:11:18,006
What it is it really alters the pod specifications

150
00:11:18,118 --> 00:11:22,070
to include the vault agent containers that render vault secrets

151
00:11:22,150 --> 00:11:25,850
to a shared memory volume. Using vault agent templates.

152
00:11:26,270 --> 00:11:29,554
The app containers within this pod can consume vault

153
00:11:29,622 --> 00:11:33,054
secrets from the shared volume without being vault aware. As we saw

154
00:11:33,092 --> 00:11:36,254
in the workflow, the injector uses or

155
00:11:36,292 --> 00:11:40,030
is a Kubernetes mutation webhook controller

156
00:11:40,770 --> 00:11:43,810
and it works by intercepting pod create

157
00:11:43,880 --> 00:11:47,934
and update events in Kubernetes and then the controller parses

158
00:11:47,982 --> 00:11:50,990
the event and looks for the metadata annotation.

159
00:11:51,150 --> 00:11:54,660
Hashicorp.com agent inject is true

160
00:11:55,210 --> 00:11:59,010
and if found, the controller will alter the pod specification

161
00:11:59,090 --> 00:12:03,862
based on other annotations that are present so

162
00:12:03,916 --> 00:12:07,746
mutation effects. Every container in the pod will be configured

163
00:12:07,778 --> 00:12:11,254
to mount a shared memory volume. This volume

164
00:12:11,302 --> 00:12:14,822
is mounted to the path vault secrets by default.

165
00:12:14,886 --> 00:12:18,602
Of course that's configurable and will be used by the vault agent

166
00:12:18,656 --> 00:12:22,330
containers for sharing secrets with the other containers

167
00:12:22,410 --> 00:12:26,478
in the pod. There are two types of vault agent

168
00:12:26,564 --> 00:12:30,042
containers we can inject. There's the init

169
00:12:30,106 --> 00:12:33,978
and the sidecar, and the init container will pre populate

170
00:12:34,074 --> 00:12:37,934
the shared memory volume with the requested secrets prior to

171
00:12:37,972 --> 00:12:41,282
the containers starting. And these are very good

172
00:12:41,336 --> 00:12:44,482
for cron jobs. So if ever I'm running a backup job,

173
00:12:44,536 --> 00:12:48,674
for example using cron, I will use the init container

174
00:12:48,722 --> 00:12:52,562
for that. And then the second one is the sidecar container

175
00:12:52,626 --> 00:12:55,926
which will continue to authenticate and render secrets to the

176
00:12:55,948 --> 00:12:59,434
same location as the pod runs. And this one's really good for long

177
00:12:59,472 --> 00:13:02,890
lived containers. And if you use

178
00:13:02,960 --> 00:13:06,282
dynamic secrets later, which I highly recommend you do,

179
00:13:06,416 --> 00:13:10,990
as those secrets change over time, the sidecar

180
00:13:11,570 --> 00:13:16,190
container can render those secrets for the application dynamically

181
00:13:17,170 --> 00:13:20,894
and then using annotations. Init and sidecar containers can also

182
00:13:20,932 --> 00:13:25,086
be disabled so vault

183
00:13:25,118 --> 00:13:28,402
agent configs to render the secret there are two methods of

184
00:13:28,456 --> 00:13:31,982
configuring the vault agent containers to render secrets.

185
00:13:32,126 --> 00:13:35,742
The first one is using annotation agent inject

186
00:13:35,806 --> 00:13:39,790
secret annotation the second method is to use a configuration map

187
00:13:39,870 --> 00:13:43,554
so config map that allows that contains the vault agent config

188
00:13:43,602 --> 00:13:47,118
files and only one of these two methods

189
00:13:47,234 --> 00:13:50,566
may be used at any time. The config

190
00:13:50,598 --> 00:13:54,714
map can provide more details for configuration beyond the

191
00:13:54,752 --> 00:13:58,166
annotations. So what's

192
00:13:58,198 --> 00:14:02,462
an example look like? This is what we're going to do in our demo.

193
00:14:02,596 --> 00:14:06,670
Here's our annotations and you can see here that agent

194
00:14:06,740 --> 00:14:10,394
inject is true. Agent inject token is true configures

195
00:14:10,442 --> 00:14:14,590
vault agent to share the vault token with other containers in the pod.

196
00:14:14,750 --> 00:14:18,446
This is helpful for Vault aware apps that need to communicate directly

197
00:14:18,478 --> 00:14:21,934
with vault but require auto authentication provided by vault

198
00:14:21,982 --> 00:14:25,410
agent. So if you're just going to use the token

199
00:14:25,490 --> 00:14:28,040
for a vault aware app, you need to have this.

200
00:14:29,690 --> 00:14:33,238
The update blocks further mutations by adding the value

201
00:14:33,324 --> 00:14:36,310
injected to the pod after successful mutation.

202
00:14:36,970 --> 00:14:40,874
And here's where we render the vault token in this particular

203
00:14:40,992 --> 00:14:44,390
path. App secrets and under the file called Token

204
00:14:44,470 --> 00:14:47,882
and we'll see it in the demo. And the role we're using here is called

205
00:14:47,936 --> 00:14:48,940
school app.

206
00:14:51,790 --> 00:14:55,562
If you want a full list of annotations, you can go to this particular URL

207
00:14:55,626 --> 00:14:58,640
to see all the available options for you.

208
00:14:59,970 --> 00:15:02,350
Let's take a look at the vault agent template.

209
00:15:03,270 --> 00:15:07,230
Quick review here. Vault agent uses

210
00:15:07,310 --> 00:15:10,398
the console template project to render secrets.

211
00:15:10,574 --> 00:15:14,766
So the console template is a project that was actually used with Hashicorp

212
00:15:14,798 --> 00:15:18,210
console that got extended over to the vault agent

213
00:15:18,280 --> 00:15:21,974
to be able to render these secrets as a template. And then this is

214
00:15:22,012 --> 00:15:25,750
useful for vault unaware apps. As we mentioned before, the app's file system

215
00:15:25,820 --> 00:15:29,346
has the secrets dropped in by vault. The app doesn't talk

216
00:15:29,388 --> 00:15:32,874
to vault directly and all it needs to know is

217
00:15:32,912 --> 00:15:36,140
what files to find those secrets from and how to read them.

218
00:15:36,750 --> 00:15:40,618
And just again, a quick overview or quick review

219
00:15:40,704 --> 00:15:44,634
I should say, of this workflow. Once again we have the mounted

220
00:15:44,682 --> 00:15:48,542
volume where application lives. The vault agent lives here in the same

221
00:15:48,596 --> 00:15:52,090
pod. It talks to the vault server by first authenticating

222
00:15:52,170 --> 00:15:55,946
using the Kubernetes authentication method. The vault server

223
00:15:55,978 --> 00:15:59,618
responds with a token. That token gets stored in the sync file and we

224
00:15:59,624 --> 00:16:02,974
can stop here. As I mentioned before, if the application is vault aware,

225
00:16:03,022 --> 00:16:06,082
can retrieve the token from here and talk to vault directly.

226
00:16:06,226 --> 00:16:09,794
Or we can take this a step further and get the vault

227
00:16:09,842 --> 00:16:13,126
agent to retrieve secrets on behalf of the application

228
00:16:13,308 --> 00:16:16,502
and store these secrets in a particular

229
00:16:16,636 --> 00:16:19,914
file that is based on

230
00:16:19,952 --> 00:16:23,386
a template so we can get the particular format that we want for

231
00:16:23,408 --> 00:16:27,066
our application to talk to whatever it needs

232
00:16:27,088 --> 00:16:30,586
to talk to, in this case the MongoDB database.

233
00:16:30,698 --> 00:16:34,814
And now we're good to connect. What does this

234
00:16:34,852 --> 00:16:38,894
look like in terms of more annotations? So now

235
00:16:39,012 --> 00:16:43,058
we stopped here last time at this line here, but now we want to

236
00:16:43,144 --> 00:16:47,154
take it to the next level and add the templating for

237
00:16:47,192 --> 00:16:50,754
our application. So as youll can see here, we are

238
00:16:50,952 --> 00:16:54,882
adding this annotation agent inject secret school

239
00:16:54,936 --> 00:16:58,354
app MongoDB username and this is the path

240
00:16:58,402 --> 00:17:02,166
inside of vault at this MongoDB path inside of

241
00:17:02,188 --> 00:17:05,986
internal data school app. And then we also have the password file.

242
00:17:06,018 --> 00:17:09,786
So these two will effectively tie into two

243
00:17:09,888 --> 00:17:13,066
files that you'll see down here. Down here you

244
00:17:13,088 --> 00:17:17,130
see another annotation for our template and

245
00:17:17,200 --> 00:17:20,718
this is what the template looks like. So all we're going to do is just

246
00:17:20,804 --> 00:17:24,202
render the school app DB

247
00:17:24,266 --> 00:17:28,062
username right here in between here.

248
00:17:28,116 --> 00:17:32,570
And this is using Golang's templating language. So we're grabbing

249
00:17:32,650 --> 00:17:35,842
the MongoDB username from this

250
00:17:35,896 --> 00:17:39,986
path inside of vault and also doing the same thing for the

251
00:17:40,008 --> 00:17:43,586
password in a separate file. So we'll see this inside the

252
00:17:43,608 --> 00:17:47,106
demo, inside our container. You'll see that we have two files

253
00:17:47,138 --> 00:17:50,626
that will get rendered app secrets school app MongoDB

254
00:17:50,658 --> 00:17:54,230
username and school app is going to be

255
00:17:54,300 --> 00:17:58,434
the username and then app secrets school app MongoDB

256
00:17:58,482 --> 00:18:01,818
password. The password is going to be Mongo root pass that's going to

257
00:18:01,824 --> 00:18:05,834
get rendered in here and that's pretty much it.

258
00:18:05,952 --> 00:18:09,274
From a slides perspective what we're going to do,

259
00:18:09,392 --> 00:18:12,320
let's now dive into a demo together.

260
00:18:13,970 --> 00:18:16,400
All right, let's now have some fun with our demo.

261
00:18:16,770 --> 00:18:20,650
So I've got this all set up for you in GitHub

262
00:18:20,730 --> 00:18:24,642
and you can use code spaces to get this all set up without

263
00:18:24,696 --> 00:18:28,146
having to do anything on your local machine. So if

264
00:18:28,168 --> 00:18:31,698
you go to our repository here,

265
00:18:31,784 --> 00:18:35,540
the GitHub repository, first thing you want to do is fork it into your own

266
00:18:35,910 --> 00:18:39,686
environment. So make sure you go ahead and fork it. And then

267
00:18:39,708 --> 00:18:43,286
once you fork it, you can run a code space on main like

268
00:18:43,308 --> 00:18:47,642
this. And I already set up the

269
00:18:47,696 --> 00:18:51,642
necessary dev containers that will set up a

270
00:18:51,696 --> 00:18:56,842
mini cube Kubernetes cluster. It will set up really

271
00:18:56,896 --> 00:19:00,814
everything that's needed in our environment. So the one thing

272
00:19:00,852 --> 00:19:04,446
I will note though is for this to work, you're going to

273
00:19:04,468 --> 00:19:08,782
need to have this run in your own

274
00:19:08,836 --> 00:19:12,330
visual studio code on your desktop.

275
00:19:12,410 --> 00:19:15,602
And I'll tell you why in just a minute. So go down to the bottom

276
00:19:15,656 --> 00:19:20,850
here where it says code space at the bottom here and select

277
00:19:20,920 --> 00:19:24,274
open in vs code desktop. What this will do is

278
00:19:24,312 --> 00:19:28,182
it will open this particular code

279
00:19:28,236 --> 00:19:31,750
space remotely inside of your visual studio code

280
00:19:31,820 --> 00:19:35,320
installation on youll machine. So I'm running this in Windows here.

281
00:19:36,970 --> 00:19:40,300
It doesn't matter what operating system you're running it in,

282
00:19:40,990 --> 00:19:44,054
it's going to get started. And you can see at the bottom it says opening

283
00:19:44,102 --> 00:19:47,258
remote. So it really is talking to code space,

284
00:19:47,344 --> 00:19:51,102
which is GitHub's own cloud, where you can have

285
00:19:51,156 --> 00:19:54,846
development environments in there. And I use it quite extensively in my

286
00:19:54,868 --> 00:19:58,302
courses, makes things much easier for my

287
00:19:58,356 --> 00:20:02,462
students, so they don't have to worry about binaries and

288
00:20:02,596 --> 00:20:05,666
dependencies and things breaking. If it

289
00:20:05,688 --> 00:20:09,458
works in my code space, it will work in your code space, that kind

290
00:20:09,464 --> 00:20:13,314
of thing. All right, now the reason why I'm asking you to run

291
00:20:13,352 --> 00:20:17,522
this in your own visual studio

292
00:20:17,666 --> 00:20:20,934
desktop is because when it comes to

293
00:20:20,972 --> 00:20:24,406
the communication between the front end, the back end,

294
00:20:24,428 --> 00:20:27,880
the database, we're running all on

295
00:20:28,570 --> 00:20:33,562
local host. If you were to try to run this in

296
00:20:33,616 --> 00:20:37,114
codespace, Codespace gives a

297
00:20:37,232 --> 00:20:44,038
port. If you go to ports here, it'll give a port for each

298
00:20:44,064 --> 00:20:47,322
one of the exposed ports. It will have a particular host theme,

299
00:20:47,386 --> 00:20:50,954
and my front end won't know how to reach the API,

300
00:20:51,002 --> 00:20:54,814
and the API won't know how to reach the database and so on. So because

301
00:20:54,852 --> 00:20:58,226
this is a demo, I want everything to run on local host. So you'll need

302
00:20:58,248 --> 00:21:02,782
to do this in your visual studio code desktop.

303
00:21:02,926 --> 00:21:07,206
So while I was chatting here, our minicube cluster should

304
00:21:07,228 --> 00:21:10,770
be running right now. I have a bunch of aliases,

305
00:21:10,850 --> 00:21:15,240
if you notice, in here. In my startup script for this code space,

306
00:21:15,690 --> 00:21:19,538
I use a bunch of aliases for kubernetes commands to make my life easier.

307
00:21:19,634 --> 00:21:24,454
The most famous one is KGA, which Kubectl get, all kdell

308
00:21:24,502 --> 00:21:27,834
for kubectl delete and a bunch of others kg for

309
00:21:27,872 --> 00:21:31,818
Kubectl get. So I kind of render this here to make my life easier.

310
00:21:31,914 --> 00:21:35,774
I also have k nine s installed here as

311
00:21:35,812 --> 00:21:39,182
well, if you like that. And I also

312
00:21:39,236 --> 00:21:42,846
have KubectX and Kubernetes installed,

313
00:21:42,878 --> 00:21:46,226
which is really good for me when I

314
00:21:46,248 --> 00:21:51,950
want to work with namespaces.

315
00:21:52,110 --> 00:21:55,814
So let's render this on the left here so we can see a bit

316
00:21:55,852 --> 00:21:59,286
better. And I'll go ahead and

317
00:21:59,388 --> 00:22:02,840
pull up my readme file, which I have all my notes here,

318
00:22:06,730 --> 00:22:09,914
and we start to look at the demo

319
00:22:10,032 --> 00:22:12,860
steps one by one over here.

320
00:22:17,130 --> 00:22:21,320
So let's look at KubectX. We'll see that we have only one

321
00:22:21,770 --> 00:22:24,758
context minicube. If youll run Kubernetes,

322
00:22:24,854 --> 00:22:29,126
that will show us we've got four namespaces, just the default mini

323
00:22:29,158 --> 00:22:32,554
cube cluster. So first things first, let's install the

324
00:22:32,592 --> 00:22:35,614
school app, and I'm going to run a bunch of commands here to

325
00:22:35,652 --> 00:22:38,846
get this going? I'll explain this of

326
00:22:38,868 --> 00:22:42,480
course we're creating a new namespace called School app.

327
00:22:42,930 --> 00:22:46,958
We're creating a helm repo well adding a helm repo

328
00:22:47,054 --> 00:22:51,454
for Bitnami, we're creating the MongoDB Helm

329
00:22:51,502 --> 00:22:55,250
chart and then I'm going to create my

330
00:22:55,320 --> 00:22:57,966
application here I've got my helm chart.

331
00:22:57,998 --> 00:23:01,130
I've exposed my application or packaged

332
00:23:01,150 --> 00:23:03,590
my application as a helm chart,

333
00:23:04,090 --> 00:23:07,750
called it school app. And from here we can

334
00:23:07,820 --> 00:23:11,990
quickly take a look at the new namespace

335
00:23:12,070 --> 00:23:16,646
called School app Run KGA. And I see that MongoDB

336
00:23:16,758 --> 00:23:20,518
is installed here. Now I'm

337
00:23:20,534 --> 00:23:24,230
going to install my front end

338
00:23:24,320 --> 00:23:27,774
and use helm install front end to install my front end.

339
00:23:27,892 --> 00:23:31,422
I'm going to use helm install my API to install

340
00:23:31,476 --> 00:23:35,754
my API. And now if I run kubectl

341
00:23:35,802 --> 00:23:41,026
get all I see that I am running

342
00:23:41,208 --> 00:23:44,594
my containers here. They're not quite up yet, so we can

343
00:23:44,632 --> 00:23:47,950
do a watch kubectl

344
00:23:48,110 --> 00:23:51,878
get pods and just wait until my

345
00:23:52,044 --> 00:23:55,186
containers are up and running. And they are. I can see API

346
00:23:55,218 --> 00:23:57,910
front end and school app mongo.

347
00:23:58,570 --> 00:24:02,202
So as I showed you in the slides, here is my school

348
00:24:02,256 --> 00:24:05,658
app ready to go up and running. Just out of

349
00:24:05,664 --> 00:24:08,330
curiosity, if you want to see what this looks like,

350
00:24:08,480 --> 00:24:12,362
let's expose our

351
00:24:12,416 --> 00:24:15,694
front end and our back end. So that's the

352
00:24:15,732 --> 00:24:19,054
front end on port 8001, the back end on port

353
00:24:19,092 --> 00:24:22,778
5000. I can open these in a browser window.

354
00:24:22,954 --> 00:24:26,286
And here's our fast API running. If I

355
00:24:26,308 --> 00:24:30,050
go to the docs URL I can see all my endpoints

356
00:24:31,190 --> 00:24:35,442
and if I'm interested now of course to see my front end,

357
00:24:35,496 --> 00:24:38,834
I go to 8001. That will bring

358
00:24:38,872 --> 00:24:42,198
me to my front end of the application. I can

359
00:24:42,284 --> 00:24:45,766
go to the admin side of things. I can create a course or

360
00:24:45,788 --> 00:24:49,494
add a course. Here's my vault 201 course

361
00:24:49,612 --> 00:24:53,306
which a plugin here. All what I'm showing you

362
00:24:53,328 --> 00:24:57,062
today is from this course vault for applications in Kubernetes.

363
00:24:57,206 --> 00:25:00,682
If you're interested in that, of course you can check that out on

364
00:25:00,736 --> 00:25:04,526
my technate academy site. Now we

365
00:25:04,548 --> 00:25:08,094
can also see the

366
00:25:08,132 --> 00:25:11,610
front here, front end for the application for the users,

367
00:25:11,690 --> 00:25:14,894
they can enroll into a course, enroll here. And now

368
00:25:14,932 --> 00:25:18,126
this user is enrolled. If I go back to my admin I can see this

369
00:25:18,148 --> 00:25:21,550
user is enrolled here and I can delete

370
00:25:21,710 --> 00:25:25,294
as well. So just showing you how I'm interacting with my database

371
00:25:25,342 --> 00:25:28,650
and storing things in the database, deleting things from the database,

372
00:25:28,750 --> 00:25:32,598
everything is running very well. And however though

373
00:25:32,764 --> 00:25:36,434
everything is running with credentials that are hard coded

374
00:25:36,482 --> 00:25:40,120
into the application. Meaning that if I go in

375
00:25:41,230 --> 00:25:45,434
and let's see here. If I create

376
00:25:45,472 --> 00:25:47,500
a new tab and I open my,

377
00:25:50,510 --> 00:25:52,890
let's see my API logs.

378
00:25:55,710 --> 00:25:59,290
If I run this command, it will show me the API logs

379
00:25:59,370 --> 00:26:02,926
that we are looking for here that we were running. And if I get

380
00:26:02,948 --> 00:26:06,666
this correct, here we go. You can see that MongoDB credentials

381
00:26:06,698 --> 00:26:10,034
using hard coded values that appear in GitLab, which is not a good

382
00:26:10,072 --> 00:26:13,346
thing. Basically these are hard coded into the

383
00:26:13,368 --> 00:26:16,190
application, they're pushed into git,

384
00:26:16,270 --> 00:26:20,390
and they're visible for anybody who has access to the git repository.

385
00:26:20,970 --> 00:26:23,798
This is a big no no. We don't want to do that. So we're using

386
00:26:23,804 --> 00:26:26,440
to introduce vault next.

387
00:26:27,210 --> 00:26:31,158
Okay, so let's get out of here and

388
00:26:31,244 --> 00:26:36,710
let's see where we're at. We are going to now install

389
00:26:36,860 --> 00:26:39,994
Argocd. Okay, so what we'll do

390
00:26:40,032 --> 00:26:43,194
is we're going to install the ArgoCd server. So let's create

391
00:26:43,232 --> 00:26:45,790
a new namespace, call it Argocd.

392
00:26:49,490 --> 00:26:53,242
All right, and we're going to use this Kubectl

393
00:26:53,306 --> 00:26:57,874
apply command to install Argocd for us in that particular

394
00:26:58,072 --> 00:27:02,594
namespace. Let's change our

395
00:27:02,632 --> 00:27:06,850
namespace to Argocd.

396
00:27:07,270 --> 00:27:11,590
And let's watch our pods to make sure that argocd is

397
00:27:11,660 --> 00:27:15,094
up and running. So we can see here a bunch of pods that are

398
00:27:15,132 --> 00:27:19,702
still in the process of coming

399
00:27:19,756 --> 00:27:20,360
up.

400
00:27:23,550 --> 00:27:26,858
Almost there. We just have a couple more that

401
00:27:26,944 --> 00:27:30,106
need to be ready before we go and we're done. Perfect.

402
00:27:30,288 --> 00:27:34,326
That was quick. All right, now let's expose the ArgoCD

403
00:27:34,438 --> 00:27:37,914
API server so we can actually see

404
00:27:37,952 --> 00:27:41,358
the UI so that

405
00:27:41,444 --> 00:27:44,734
we are exposing now port 8002. Let's open

406
00:27:44,772 --> 00:27:48,210
that in our browser. And from here

407
00:27:48,280 --> 00:27:51,426
we should be able to access Argocd. We just need

408
00:27:51,448 --> 00:27:54,980
our username and password. So let's go ahead and grab that.

409
00:27:56,230 --> 00:27:59,590
By default, ArgocD puts the password

410
00:28:00,330 --> 00:28:03,686
in here in this secret. So let's grab it. And there

411
00:28:03,708 --> 00:28:08,070
it is. Let's copy that and log in with admin

412
00:28:09,450 --> 00:28:11,240
and sign in this way.

413
00:28:12,430 --> 00:28:16,166
All right, we have a freshly installed Argo CD

414
00:28:16,278 --> 00:28:20,074
server. No applications ready or no applications deployed just

415
00:28:20,112 --> 00:28:23,934
yet. All right, so let's go ahead and deploy our

416
00:28:23,972 --> 00:28:28,074
application. But first let's

417
00:28:28,122 --> 00:28:32,970
go into our school app and delete

418
00:28:33,050 --> 00:28:37,118
this namespace altogether because remember we now want to use Gitops

419
00:28:37,214 --> 00:28:40,580
as our approach to deploying this

420
00:28:40,950 --> 00:28:45,250
application. So let's run Kubectl

421
00:28:47,030 --> 00:28:50,978
or kubectl delete or kdelete namespace

422
00:28:51,074 --> 00:28:54,146
cool app to delete this namespace.

423
00:28:54,178 --> 00:28:57,942
And we'll just double check, make sure everything is gone before

424
00:28:57,996 --> 00:29:01,286
we proceed because obviously again we

425
00:29:01,308 --> 00:29:04,730
want to use ArgocD as the tool, our Gitops tool,

426
00:29:04,880 --> 00:29:08,454
to spin up our application so it can monitor

427
00:29:08,502 --> 00:29:11,670
this application and make sure there's no drift.

428
00:29:11,830 --> 00:29:15,978
All right, let's run Kubectl, get namespace.

429
00:29:16,074 --> 00:29:19,854
Our school app namespace is gone. And now what we're going to do is

430
00:29:19,892 --> 00:29:23,886
we're going to run Kubectl apply and

431
00:29:23,988 --> 00:29:28,420
use this ArgocD school app manifest to

432
00:29:28,950 --> 00:29:33,106
render our application. If you want to see what this manifest looks like,

433
00:29:33,288 --> 00:29:37,620
it's pretty straightforward. It's an application for

434
00:29:38,310 --> 00:29:41,490
Argocd. It's going to be in the namespace

435
00:29:41,570 --> 00:29:45,654
Argocd. The name is school app. The destination namespace is

436
00:29:45,692 --> 00:29:48,882
school app. The server is our Kubernetes server.

437
00:29:48,946 --> 00:29:52,150
The path is school app subchart,

438
00:29:52,310 --> 00:29:56,602
which is right here. This is what we're rendering and

439
00:29:56,736 --> 00:30:00,406
we are grabbing the repo, which is our repo

440
00:30:00,438 --> 00:30:03,878
that we're in right now, the ArgoCD vault repo.

441
00:30:03,974 --> 00:30:07,246
And we are creating a namespace as well. So if I were to

442
00:30:07,268 --> 00:30:09,310
run Kubectl gate namespace,

443
00:30:11,090 --> 00:30:14,686
I don't see anything yet. It should show up. So let's take

444
00:30:14,708 --> 00:30:18,578
a look and see what happened in the UI. There it is. So all

445
00:30:18,584 --> 00:30:20,370
I need to do is just click sync.

446
00:30:25,780 --> 00:30:29,164
And now our application is progressing,

447
00:30:29,212 --> 00:30:40,664
it's syncing. As you can see here we have all

448
00:30:40,702 --> 00:30:45,048
the different pieces are running and

449
00:30:45,134 --> 00:30:49,064
there is an issue here with our API pod.

450
00:30:49,112 --> 00:30:53,484
And the reason for that is before recording I forgot to

451
00:30:53,602 --> 00:30:56,972
change my values for my

452
00:30:57,026 --> 00:31:02,464
application here to I

453
00:31:02,502 --> 00:31:06,124
need to disable these two fields

454
00:31:06,172 --> 00:31:09,568
and then we'll come back and fix it later. So let's go

455
00:31:09,574 --> 00:31:11,010
ahead and disable this.

456
00:31:17,240 --> 00:31:20,884
All right, so true to Gitops, I'm making a change in

457
00:31:20,922 --> 00:31:24,944
here. Okay. And now what I'm going to do is I'm going

458
00:31:25,002 --> 00:31:28,276
to push this back to my git

459
00:31:28,308 --> 00:31:31,544
repo and argocd is going to notice the change and

460
00:31:31,582 --> 00:31:33,130
go apply the change.

461
00:31:37,280 --> 00:31:40,456
Okay, so we've got status disabled, kind is disabled.

462
00:31:40,568 --> 00:31:43,756
Let's go ahead and commit this. Let's just

463
00:31:43,778 --> 00:31:48,204
call it start fresh commit and

464
00:31:48,242 --> 00:31:51,920
let's sync our changes. And now

465
00:31:52,070 --> 00:31:55,810
that is synced, let's go ahead and go back into our

466
00:31:57,620 --> 00:32:01,436
ArgoCD dashboard. I'm going to click refresh

467
00:32:01,628 --> 00:32:05,076
just to get this to move faster. Otherwise we'd have to

468
00:32:05,098 --> 00:32:08,240
wait I think two minutes or five minutes by default.

469
00:32:08,400 --> 00:32:11,524
So we click refresh. You see out of sync already.

470
00:32:11,722 --> 00:32:15,124
And why is this out of sync? You can

471
00:32:15,242 --> 00:32:18,872
click apptif and it will show you what the difference is.

472
00:32:19,006 --> 00:32:22,744
You can see the annotations are going to get removed, for example,

473
00:32:22,942 --> 00:32:26,264
and our vault status here,

474
00:32:26,302 --> 00:32:29,732
this is going to be disabled, meaning that we're removing vault from the equation.

475
00:32:29,796 --> 00:32:33,544
And this is what we should have started with. But it's actually a good exercise

476
00:32:33,592 --> 00:32:37,368
to show you Gitops in action. So now we can go ahead and click sync

477
00:32:37,464 --> 00:32:39,310
and we're going to synchronize everything.

478
00:32:43,180 --> 00:32:46,644
And this should fix our API

479
00:32:46,692 --> 00:32:49,720
deployment and it should be healthy after

480
00:32:49,790 --> 00:32:53,768
this works. So let's see here. So the replica set

481
00:32:53,854 --> 00:32:57,356
deleted our pod and see if it will create a

482
00:32:57,378 --> 00:33:01,464
new API pod for us. Just give it a few seconds

483
00:33:01,512 --> 00:33:02,110
here,

484
00:33:06,930 --> 00:33:09,950
maybe even a quick refresh, because I'm impatient.

485
00:33:10,950 --> 00:33:14,734
And there we go. Yeah. So here we go. We've got our API pod

486
00:33:14,782 --> 00:33:18,766
running. If I go back in visual

487
00:33:18,798 --> 00:33:22,174
studio code and run get namespace,

488
00:33:22,222 --> 00:33:26,294
I see my school app here. So cuben school

489
00:33:26,412 --> 00:33:30,294
app and run qCtl, get everything.

490
00:33:30,412 --> 00:33:33,720
My API front end, school app, everything is running.

491
00:33:34,090 --> 00:33:37,798
If I go back and just stop the connection and secrets

492
00:33:37,814 --> 00:33:41,562
the connection to my front end and my back

493
00:33:41,616 --> 00:33:45,226
end, I should be good to see my application

494
00:33:45,328 --> 00:33:48,718
once again. So if I refresh that,

495
00:33:48,884 --> 00:33:51,930
I see my application once again, I can add courses,

496
00:33:52,090 --> 00:33:56,074
I can remove courses, I can interact

497
00:33:56,122 --> 00:33:58,400
with my database, no problem.

498
00:33:59,830 --> 00:34:03,266
Okay, now remember, we're still in the

499
00:34:03,288 --> 00:34:06,462
phase where we haven't introduced vault

500
00:34:06,526 --> 00:34:10,782
yet. All we've done is we've introduced

501
00:34:10,846 --> 00:34:15,510
Gitops through Argocd. So with Argocd,

502
00:34:15,930 --> 00:34:19,234
we can monitor the desired state in our git repo

503
00:34:19,362 --> 00:34:23,286
versus the active state, which is what we see here. All is

504
00:34:23,308 --> 00:34:26,870
good, everything is healthy. Next step is to introduce vault,

505
00:34:26,950 --> 00:34:30,874
which is our final step for our demo today.

506
00:34:31,072 --> 00:34:34,874
All right, so let's go ahead and go back

507
00:34:34,912 --> 00:34:37,900
to my guide to see where we left off.

508
00:34:39,310 --> 00:34:42,400
All right, so we've deployed the app with Argocd now,

509
00:34:43,890 --> 00:34:47,200
and we saw that it's using hard code secrets from before.

510
00:34:50,310 --> 00:34:53,518
Okay, now we're

511
00:34:53,534 --> 00:34:57,886
using to install the vault server in our environment

512
00:34:57,998 --> 00:35:01,694
using our helm chart. So let's

513
00:35:01,742 --> 00:35:04,630
create a new namespace, call it vault.

514
00:35:05,450 --> 00:35:09,590
Let's introduce or add our repo, our helm

515
00:35:10,890 --> 00:35:14,722
release here, or our helm repository. And then

516
00:35:14,876 --> 00:35:18,742
we're going to install our vault server

517
00:35:18,886 --> 00:35:22,746
inside of the

518
00:35:22,768 --> 00:35:26,394
namespace vault. And let's see

519
00:35:26,432 --> 00:35:29,678
what we have here. We've got containers that are starting.

520
00:35:29,764 --> 00:35:33,034
I can see the vault container.

521
00:35:33,082 --> 00:35:36,526
I can see the vault agent injector, which is what is the

522
00:35:36,548 --> 00:35:40,622
mutation webhook that looks for annotations and goes ahead and

523
00:35:40,756 --> 00:35:44,420
creates an agent sidecar for us.

524
00:35:45,270 --> 00:35:48,914
So let's watch this until everything is

525
00:35:48,952 --> 00:35:52,866
ready. Okay, we're running. Notice that the

526
00:35:52,888 --> 00:35:56,498
vault node or the vault server

527
00:35:56,594 --> 00:35:59,798
is not using to go into the ready state. It's running, but it's not going

528
00:35:59,804 --> 00:36:03,714
to go into the ready state because we need to initialize an unseal

529
00:36:03,762 --> 00:36:06,826
vault. So to do that, first of all, we need

530
00:36:06,848 --> 00:36:10,300
to exec into our container. So let's do that.

531
00:36:11,790 --> 00:36:15,654
So now we're inside the vault container and we need to run a few commands

532
00:36:15,702 --> 00:36:19,354
here. First off, we need to initialize

533
00:36:19,402 --> 00:36:23,726
vault using the vault operator command. And just

534
00:36:23,828 --> 00:36:26,842
notice that this is a demo environment.

535
00:36:26,906 --> 00:36:30,686
Please don't do this in a production environment. Production environment. You'll need

536
00:36:30,708 --> 00:36:33,410
to do a whole lot of things when you initializing vault.

537
00:36:33,830 --> 00:36:37,762
And by the way, vault doesn't need to live inside

538
00:36:37,816 --> 00:36:41,474
of a Kubernetes cluster. Your vault server can live somewhere else.

539
00:36:41,592 --> 00:36:44,806
But you will need the injector inside of the

540
00:36:44,828 --> 00:36:48,706
cluster so it can listen to annotations or see annotations

541
00:36:48,818 --> 00:36:51,560
and then inject the agent.

542
00:36:52,250 --> 00:36:55,522
All right, so this is important. The unseal key and the root token.

543
00:36:55,586 --> 00:36:59,130
We need those. So we will save these in a notepad file.

544
00:37:00,750 --> 00:37:04,598
So I save them here in this notepad file. I'll make it bigger.

545
00:37:04,774 --> 00:37:07,930
All right, we're going to come back and use these very shortly.

546
00:37:08,770 --> 00:37:14,586
Actually right now. Vault operator unseal

547
00:37:14,698 --> 00:37:17,886
and we need that unseal key. So this

548
00:37:17,908 --> 00:37:21,330
is what allows us to unseal our vault cluster.

549
00:37:22,550 --> 00:37:26,034
And now our sealed status is

550
00:37:26,072 --> 00:37:29,378
false means that we are unsealed, which is great.

551
00:37:29,544 --> 00:37:33,270
Now let's go ahead and exit this container.

552
00:37:37,770 --> 00:37:41,206
Okay. Actually one thing we

553
00:37:41,228 --> 00:37:45,466
want to do is I

554
00:37:45,488 --> 00:37:50,470
want to make sure that I add my authentication,

555
00:37:50,550 --> 00:37:53,930
kubernetes authentication into vault.

556
00:37:54,910 --> 00:37:58,250
So we actually need to stay inside the vault container

557
00:37:59,150 --> 00:38:01,520
to do that. So let's go ahead and go back.

558
00:38:04,050 --> 00:38:06,958
All right, so we're back in the vault container and we're going to do a

559
00:38:06,964 --> 00:38:13,746
couple of things. You need to export the address, the vault address to

560
00:38:13,768 --> 00:38:18,078
port 8200. And we need to log in. So vault login.

561
00:38:18,254 --> 00:38:21,330
And you need that root token that we just saved.

562
00:38:22,330 --> 00:38:25,494
And if you have

563
00:38:25,532 --> 00:38:29,426
spent more than 5 seconds with me on any of the vault tutorials

564
00:38:29,458 --> 00:38:33,014
I present, you'll quickly hear me say

565
00:38:33,052 --> 00:38:36,934
that the root token is only for creating authentication methods and

566
00:38:36,972 --> 00:38:40,266
it is to be revoked in production environments. Of course,

567
00:38:40,288 --> 00:38:43,254
this is a demo, so we're going to play with the root token. We won't

568
00:38:43,302 --> 00:38:47,210
bother doing anything else. Now here we have

569
00:38:47,280 --> 00:38:49,820
our first secret that we want to create.

570
00:38:50,610 --> 00:38:53,680
First of all, we got to create a secrets engine.

571
00:38:54,770 --> 00:38:58,430
This is the KV version two secrets engine. We first enable it

572
00:38:58,500 --> 00:39:02,558
and then we're going to put our secrets in here. Remember our MongoDB username

573
00:39:02,574 --> 00:39:06,702
and password? So here's our username and here's our password.

574
00:39:06,846 --> 00:39:10,286
And if you want to retrieve that you can run this command

575
00:39:10,478 --> 00:39:14,114
and it will come back retrieve your username and password right

576
00:39:14,152 --> 00:39:18,118
here. Now we need to create a school

577
00:39:18,204 --> 00:39:21,526
application policy. If you recall when I talked about the token and the

578
00:39:21,548 --> 00:39:25,342
policy, you need to have a policy in place that allows

579
00:39:25,506 --> 00:39:29,270
the holder of the token to access particular locations.

580
00:39:29,430 --> 00:39:33,702
So you see here the path internal data school app MongoDB

581
00:39:33,846 --> 00:39:37,450
is the same path that we wrote the secret into.

582
00:39:37,520 --> 00:39:40,842
So we need to have this policy in place so that the vault

583
00:39:40,906 --> 00:39:44,334
agent will have this policy as part of its

584
00:39:44,372 --> 00:39:47,950
token when it goes out to authenticate against vault.

585
00:39:48,610 --> 00:39:52,302
So now let's set up the Kubernetes authentication method in vault.

586
00:39:52,446 --> 00:39:56,802
This allows our vault agent to talk

587
00:39:56,856 --> 00:40:00,258
to vault. So this is just a

588
00:40:00,264 --> 00:40:04,086
bunch of config that you'll have to create

589
00:40:04,268 --> 00:40:07,474
really quickly off Kubernetes config the issuer,

590
00:40:07,522 --> 00:40:10,870
the token reviewer the Kubernetes host the Kubernetes Ca

591
00:40:10,940 --> 00:40:14,678
Cert we're writing or binding to

592
00:40:14,764 --> 00:40:18,582
this service account and this namespace called School app.

593
00:40:18,636 --> 00:40:22,570
Very important policies is app which we wrote up here.

594
00:40:22,640 --> 00:40:26,038
So this policy is attached to this role

595
00:40:26,134 --> 00:40:29,854
that we're creating, the role called school app and we're giving it

596
00:40:29,892 --> 00:40:33,098
time to live 5 seconds and maximum ttl of 20 seconds.

597
00:40:33,194 --> 00:40:37,630
But basically this is our way of getting

598
00:40:37,780 --> 00:40:41,214
kubernetes or vault set up with kubernetes so vault

599
00:40:41,262 --> 00:40:44,546
can authenticate against Kubernetes and figure out if any

600
00:40:44,568 --> 00:40:47,822
of the resources or pods that Kubernetes spins up belong

601
00:40:47,886 --> 00:40:51,202
to the Kubernetes API and that

602
00:40:51,256 --> 00:40:55,510
allows vault to authenticate applications into Kubernetes.

603
00:40:58,570 --> 00:41:01,638
All right, let's now exit the container. I think

604
00:41:01,644 --> 00:41:05,106
we're done with all the configuration for vault.

605
00:41:05,298 --> 00:41:08,806
And now let's test the school app with the vault injector. And how

606
00:41:08,828 --> 00:41:12,342
are we going to do that? I have this all set up with templates,

607
00:41:12,406 --> 00:41:15,786
helm templates and so on. So all we need to do is go into the

608
00:41:15,808 --> 00:41:19,614
values Yaml file here as

609
00:41:19,652 --> 00:41:26,254
part of the subchart. And I need to just make changes here to

610
00:41:26,292 --> 00:41:29,946
do this. Instead of vault being disabled here I want

611
00:41:29,988 --> 00:41:32,894
vault to have status of KV, static injector,

612
00:41:32,942 --> 00:41:36,338
template file and kind injector. And that

613
00:41:36,424 --> 00:41:40,734
basically will allow us to use vault to render secrets.

614
00:41:40,862 --> 00:41:44,886
Now I'm going to say use vault for secrets. I'm going to

615
00:41:44,908 --> 00:41:48,614
commit this and I'm going to push that.

616
00:41:48,732 --> 00:41:52,450
And again, in a production environment, you won't just have the ability

617
00:41:52,530 --> 00:41:56,206
to commit and push straight to the main branch,

618
00:41:56,258 --> 00:41:59,654
of course. You create a pull request or merge request,

619
00:41:59,702 --> 00:42:03,706
you have a peer review and then that gets merged into

620
00:42:03,888 --> 00:42:07,740
your main branch if that's the strategy you're taking.

621
00:42:08,450 --> 00:42:11,886
All right, so that gets pushed through again, I'm going to hit a

622
00:42:11,908 --> 00:42:18,990
quick refresh inside of argo CD and

623
00:42:19,060 --> 00:42:22,826
we can see now that we're out of sync, right, so we

624
00:42:22,868 --> 00:42:26,900
need to sync this. But before we sync, let's again look at the diff.

625
00:42:27,430 --> 00:42:31,586
And as you notice here now we have a bunch of annotations. And if

626
00:42:31,608 --> 00:42:35,874
you recall I told you that you need these annotations for the mutation

627
00:42:35,922 --> 00:42:39,218
webhook, which is the agent injector, the vault agent injector.

628
00:42:39,314 --> 00:42:42,450
Once it sees these annotations it's going to mutate

629
00:42:42,530 --> 00:42:45,798
the pod specification and that's how we're going to see

630
00:42:45,964 --> 00:42:49,866
an agent, a vault agent injector or,

631
00:42:49,888 --> 00:42:53,702
sorry, a vault agent show up inside of our pod.

632
00:42:53,846 --> 00:42:58,158
So here's the annotation. If I make this a bit bigger, maybe to see better,

633
00:42:58,324 --> 00:43:01,518
you can see the agent inject is true

634
00:43:01,604 --> 00:43:04,960
what we saw in the slides, basically the different

635
00:43:05,330 --> 00:43:09,120
agent injector annotations that we expect.

636
00:43:09,570 --> 00:43:13,806
And here's the template where we're going to render the password, render the username

637
00:43:13,918 --> 00:43:17,538
and it's going to be at this particular pass app secrets that

638
00:43:17,544 --> 00:43:20,930
we'll see inside the container. All right, what else?

639
00:43:21,000 --> 00:43:25,282
Vault status from disabled to kv static injector template file

640
00:43:25,426 --> 00:43:29,240
and that should be good to go. We can go ahead and sync that

641
00:43:29,930 --> 00:43:35,758
synchronize and from here we'll

642
00:43:35,794 --> 00:43:39,482
wait till the API gets recreated and if we

643
00:43:39,536 --> 00:43:43,786
go into the logs of the API, which we'll do in

644
00:43:43,808 --> 00:43:47,366
just a minute and this is complete, we'll see that.

645
00:43:47,408 --> 00:43:51,054
Now we're using the agent injector. So let's go ahead back in

646
00:43:51,092 --> 00:43:57,290
here and let's

647
00:43:57,370 --> 00:44:00,962
make sure we are in the

648
00:44:01,016 --> 00:44:03,650
school app namespace.

649
00:44:04,230 --> 00:44:08,942
And if I run Kubectl, get all I can see. Now there are two containers

650
00:44:09,006 --> 00:44:12,382
running inside of my API pod. One is for

651
00:44:12,456 --> 00:44:16,102
the agent, the vault agent, and the other one

652
00:44:16,156 --> 00:44:19,014
is for my actual API application.

653
00:44:19,212 --> 00:44:24,520
All right, and now what we'll do is

654
00:44:25,150 --> 00:44:29,626
take a look at the

655
00:44:29,648 --> 00:44:33,242
logs for my API and you can see here credentials using

656
00:44:33,296 --> 00:44:36,966
Vault KV with injector and templates for vault unaware apps.

657
00:44:37,078 --> 00:44:41,226
You can see my username and password. This is grabbed or taken directly

658
00:44:41,258 --> 00:44:45,440
from vault and it's not hard coded anymore anywhere in my

659
00:44:45,890 --> 00:44:50,026
application code, which is amazing. So with

660
00:44:50,068 --> 00:44:53,474
that I can go back of course to show you that the application still

661
00:44:53,512 --> 00:44:57,474
runs. I'm going to re expose my ports for my

662
00:44:57,512 --> 00:45:00,706
application and

663
00:45:00,728 --> 00:45:03,720
then go back, refresh this.

664
00:45:04,330 --> 00:45:06,920
I can now once again add the course,

665
00:45:07,850 --> 00:45:11,606
I can delete a course and my application

666
00:45:11,708 --> 00:45:15,230
is running smoothly talking to my mongo database,

667
00:45:15,330 --> 00:45:18,906
no problem. So next I just want to

668
00:45:18,928 --> 00:45:23,002
show you what happens inside of

669
00:45:23,056 --> 00:45:26,762
my API pod. So if I go back here and

670
00:45:26,896 --> 00:45:31,022
I go into my pod, so let's clear and run

671
00:45:31,076 --> 00:45:34,926
kubectl exec and

672
00:45:34,948 --> 00:45:38,314
I'm going to exec into my pod to show you inside my pod.

673
00:45:38,442 --> 00:45:41,854
So inside my pod I have my main py

674
00:45:41,902 --> 00:45:45,090
file, of course my python file, but if I go up

675
00:45:45,160 --> 00:45:48,494
one directory and ls you see secrets,

676
00:45:48,622 --> 00:45:52,194
if I go into secrets now the path is

677
00:45:52,232 --> 00:45:55,494
app secrets and if you recall app secrets is through the

678
00:45:55,532 --> 00:45:59,042
annotations is where I'm storing my vault

679
00:45:59,106 --> 00:46:03,110
token and I'm storing my username and password files.

680
00:46:03,610 --> 00:46:07,430
So if I run cat token, this is the vault token

681
00:46:07,510 --> 00:46:11,194
that a vault aware app can just grab and talk

682
00:46:11,232 --> 00:46:13,718
to vault directly. Authenticating to vault directly.

683
00:46:13,894 --> 00:46:17,174
The school Mongo username

684
00:46:17,222 --> 00:46:20,958
is my username that gets dropped in here school app as you

685
00:46:20,964 --> 00:46:24,938
can see as part of the agent template.

686
00:46:25,034 --> 00:46:28,302
And then finally my school

687
00:46:28,356 --> 00:46:31,406
app Mongo password allows

688
00:46:31,438 --> 00:46:35,534
me to see my Mongo root

689
00:46:35,662 --> 00:46:39,262
pass is the password to access MongodB.

690
00:46:39,406 --> 00:46:42,526
And if I'm using in this case I'm using static secrets

691
00:46:42,558 --> 00:46:46,406
because I'm talking to the static KV secrets engine in

692
00:46:46,428 --> 00:46:50,802
vault. But you can always go to a dynamic secret

693
00:46:50,866 --> 00:46:54,434
engine and I highly recommend doing that. MongodB Vault

694
00:46:54,482 --> 00:46:58,154
has one for MongoDB and what will happen is every

695
00:46:58,192 --> 00:47:01,094
time the application needs to access Mongo,

696
00:47:01,142 --> 00:47:04,570
it can create on demand just in time

697
00:47:04,640 --> 00:47:08,042
credentials from vault to use to connect to

698
00:47:08,096 --> 00:47:11,242
Mongo. And there's a time to live for those credentials.

699
00:47:11,386 --> 00:47:15,054
Once the TTL expires, then the application needs to go

700
00:47:15,092 --> 00:47:18,766
and recreate a new set of credentials and in

701
00:47:18,788 --> 00:47:22,494
that case we no longer have any long lived static credentials

702
00:47:22,542 --> 00:47:26,146
in the environment. All of

703
00:47:26,168 --> 00:47:30,162
this I talk about in a lot of my courses in the tech

704
00:47:30,216 --> 00:47:33,618
and aid academy. So feel free to check out some of

705
00:47:33,624 --> 00:47:37,410
those courses. I have extensive coverage on Hashicorp vault.

706
00:47:37,750 --> 00:47:41,582
Once again, you can check out the vault 201 Kubernetes

707
00:47:41,726 --> 00:47:45,846
applications with vault. If that is something that that interests

708
00:47:45,878 --> 00:47:49,562
you, please take a look at that and that is the end

709
00:47:49,616 --> 00:47:53,466
of this talk. I hope you enjoyed it and I hope you enjoy the

710
00:47:53,488 --> 00:47:57,622
rest of the talks at Conf 42, dev stock ops,

711
00:47:57,766 --> 00:47:59,960
and I will see you in other videos.

