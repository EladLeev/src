1
00:00:25,410 --> 00:00:29,126
You. Hello everyone and welcome to this

2
00:00:29,148 --> 00:00:32,546
session on building applications with r two DBC,

3
00:00:32,658 --> 00:00:36,854
a new fullyreactive database connectivity specification used

4
00:00:36,892 --> 00:00:40,146
to connect with relational databases in a fully reactive manner.

5
00:00:40,258 --> 00:00:44,022
My name is Rob Hedgpeth and a little bit about myself. I actually work for

6
00:00:44,076 --> 00:00:47,366
MariaDB as part of the developer Relations group and essentially what

7
00:00:47,388 --> 00:00:51,674
that means is that I do anything and everything I can it to help improve

8
00:00:51,802 --> 00:00:55,354
or just better the developer experience using MariaDB

9
00:00:55,402 --> 00:00:59,498
products. Right? And so if you're not aware MariaDB is a relational database,

10
00:00:59,594 --> 00:01:03,930
that's about was much time as I'll probably spend really talking about MariaDB specifically.

11
00:01:04,010 --> 00:01:07,166
Some of the examples that I use, of course will use it. But what you

12
00:01:07,188 --> 00:01:10,034
want to take away from this is that I'm going to be taking a look

13
00:01:10,072 --> 00:01:13,746
at the r two DBC specification as a whole, how it can

14
00:01:13,768 --> 00:01:17,250
be used not only really with MariaDB, but a variety of different

15
00:01:17,320 --> 00:01:21,446
relational databases solutions. But mainly we're going to be looking at r two DBC as

16
00:01:21,468 --> 00:01:24,646
it is at the end of this. As you go throughout the rest of the

17
00:01:24,668 --> 00:01:28,246
conference and even after the conference, if you happen to have any questions or maybe

18
00:01:28,268 --> 00:01:31,626
just some input on the session itself, please feel free to reach out to me

19
00:01:31,648 --> 00:01:35,258
at rob or robh@mariadb.com you can

20
00:01:35,264 --> 00:01:39,034
reach me on Twitter at probably realrob or you can go ahead and follow me

21
00:01:39,072 --> 00:01:42,330
on GitHub. I put a lot of samples not only with

22
00:01:42,400 --> 00:01:46,046
r two DBC, but a lot of things dealing with relational databases. So feel

23
00:01:46,068 --> 00:01:49,646
free to go out and follow me on GitHub as well. Now let's dive into

24
00:01:49,748 --> 00:01:52,810
reactive programming with relational databases,

25
00:01:52,890 --> 00:01:56,238
specifically relational databases. But what we want to key into first,

26
00:01:56,324 --> 00:01:59,426
just so we can get everybody kind of running at the same pace or really

27
00:01:59,448 --> 00:02:02,814
on the same page, is this idea of reactive

28
00:02:02,862 --> 00:02:06,034
programming. Well, what does that mean? And so we're going to dive a little bit

29
00:02:06,072 --> 00:02:09,102
into that just to really serve as a refresher for some.

30
00:02:09,176 --> 00:02:12,710
And maybe you aren't familiar with reactive programming in general.

31
00:02:12,780 --> 00:02:16,086
Not a problem. We're going to get everybody again, like I said, on the

32
00:02:16,108 --> 00:02:19,158
same page. So for some of you, this may be a refresher, but let's go

33
00:02:19,164 --> 00:02:22,666
ahead and take a look at something that is a pretty relatable example. I think

34
00:02:22,688 --> 00:02:26,330
for most of us out there in a simple application

35
00:02:26,480 --> 00:02:30,342
or a simple solution design where we've got a client communicating

36
00:02:30,406 --> 00:02:34,226
with a server and more specifically communicating with a server thread,

37
00:02:34,278 --> 00:02:37,918
right? So some thread on the server that's actually doing the work process,

38
00:02:38,004 --> 00:02:41,614
something that the client is sending in maybe as a request or something like that.

39
00:02:41,652 --> 00:02:45,102
And so in this instance, we can imagine that the client, like I said,

40
00:02:45,156 --> 00:02:48,418
sends in a request and the server thread picks that up. And so when the

41
00:02:48,424 --> 00:02:52,194
server thread does that, the request is in this case indicating to do

42
00:02:52,232 --> 00:02:55,170
something with the database, which of course makes sense if we're going to talk about

43
00:02:55,240 --> 00:02:58,826
reactive programming with relational databases. But in the normal scenario,

44
00:02:58,878 --> 00:03:02,102
right, it's going to take that request, maybe it's got some

45
00:03:02,236 --> 00:03:05,554
instructions that basically indicate I need to execute some query.

46
00:03:05,602 --> 00:03:09,622
In this case, we're going to execute some SQL, some structured query language against

47
00:03:09,676 --> 00:03:13,174
a relational database. And while that's happening, that server thread is essentially

48
00:03:13,222 --> 00:03:17,194
just waiting for the process to execute, right? So whatever

49
00:03:17,312 --> 00:03:20,954
maybe query or queries that you're sending in, just waiting for those to

50
00:03:21,072 --> 00:03:24,478
finish and during that time is essentially just waiting there, right? So once it

51
00:03:24,484 --> 00:03:27,514
gets it, then it can go ahead and handle that response. Now you're probably knowing

52
00:03:27,562 --> 00:03:31,182
where I'm getting with this, but if that server thread basically

53
00:03:31,236 --> 00:03:35,274
is stuck waiting for the database to go ahead and continue processing

54
00:03:35,322 --> 00:03:38,546
or doing whatever it's doing on that side, it's not really important to

55
00:03:38,568 --> 00:03:41,954
us. Then if another request comes in from the client, one of the things

56
00:03:41,992 --> 00:03:44,958
that we know off the bat is that we can't do anything with server thread

57
00:03:44,974 --> 00:03:48,626
one because it's at the moment really waiting for some work to get

58
00:03:48,648 --> 00:03:52,166
done from the database. And so for this situation, we go ahead and we

59
00:03:52,188 --> 00:03:55,526
decide, and something that we've been doing for a while now is just make this

60
00:03:55,548 --> 00:03:58,902
multithreaded, right? Just spin up another thread. We'll handle this

61
00:03:58,956 --> 00:04:02,566
asynchronously, and we'll handle whatever requested information is coming

62
00:04:02,588 --> 00:04:05,706
in from the client that standpoint. And again, it's going to follow that

63
00:04:05,728 --> 00:04:09,126
same trend where maybe it works with the database, maybe it works with the file

64
00:04:09,158 --> 00:04:12,554
system. Doesn't really matter, right. Is that essentially it kind of all works

65
00:04:12,592 --> 00:04:15,566
the same. It's dealing with something that is making it wait. And so when the

66
00:04:15,588 --> 00:04:19,454
third request or the fourth or 100th request comes in, we're dealing with this

67
00:04:19,492 --> 00:04:23,102
with more and more thread context. Now that's great, right?

68
00:04:23,236 --> 00:04:26,526
But the problem with that is that as we add more

69
00:04:26,548 --> 00:04:30,094
and more threads, we're certainly making that more complex from a development

70
00:04:30,142 --> 00:04:33,982
standpoint, but we're also making that more complex from a computational

71
00:04:34,046 --> 00:04:37,586
standpoint in the sense that it could take more memory to basically

72
00:04:37,688 --> 00:04:41,138
manage all of this thread context. So the concepts of all these threads

73
00:04:41,154 --> 00:04:44,054
have just general thread management now. We're not going to dive in the minutiae of

74
00:04:44,092 --> 00:04:47,430
why that is. But essentially one of the side effects of that is

75
00:04:47,500 --> 00:04:50,934
that as you increase memory usage, you can have

76
00:04:50,972 --> 00:04:54,522
other side effects like decreasing throughput. All things that you really don't want,

77
00:04:54,576 --> 00:04:58,474
right? Increased memory released throughput. These are things that you don't want in your application.

78
00:04:58,592 --> 00:05:02,046
And so it causes more problems. And this is really where, if we're getting

79
00:05:02,148 --> 00:05:06,202
to the meat of it is where reactive programming methodologies

80
00:05:06,266 --> 00:05:09,818
or thinking reactively has really stepped in to help alleviate

81
00:05:09,834 --> 00:05:14,074
some of these problems. In a reactive solution, we've got a very similar setup

82
00:05:14,122 --> 00:05:17,534
here where the client is then communicating with that server thread,

83
00:05:17,582 --> 00:05:21,362
right, just the same, but instead of the server thread, you know, executing or

84
00:05:21,416 --> 00:05:25,090
communicating with the database and then waiting on that process to finish

85
00:05:25,160 --> 00:05:28,786
or complete for doing something else, it's really just throwing it over to fence to

86
00:05:28,808 --> 00:05:32,198
the database to say, hey, go ahead and do this. I'm going to go continue

87
00:05:32,284 --> 00:05:35,654
to process other things. Like for instance, we've got a second request in here,

88
00:05:35,692 --> 00:05:39,698
or third or fourth or fifth request. When you're done database

89
00:05:39,794 --> 00:05:43,354
and you want to give me back some results, then let me know, I will

90
00:05:43,392 --> 00:05:47,162
handle those. And then of course subsequently send that downstream into

91
00:05:47,216 --> 00:05:50,874
the client. This is a very simple explanation, but was you can see

92
00:05:50,912 --> 00:05:54,302
here, rather than being blocked, which we'll get into, we're completely

93
00:05:54,356 --> 00:05:57,630
unblocked to handle other requests like request two,

94
00:05:57,700 --> 00:06:01,246
until eventually the database sends us something back that we need to

95
00:06:01,268 --> 00:06:04,626
handle. And this is pretty age old

96
00:06:04,728 --> 00:06:08,414
solution that we're probably used to, right? You've probably heard of things like the observer

97
00:06:08,462 --> 00:06:11,774
pattern or pub sub. It's nothing necessarily

98
00:06:11,902 --> 00:06:15,522
new, right, or revolutionary, but this is a way

99
00:06:15,576 --> 00:06:19,266
of being able to handle things in a more efficient manner. So you're not necessarily

100
00:06:19,378 --> 00:06:22,818
which you can, but you're not necessarily looking to improve performance,

101
00:06:22,914 --> 00:06:26,674
but you are looking to become much more efficient in using the resources,

102
00:06:26,722 --> 00:06:30,682
for instance, like on the server that you have. And this is a large part

103
00:06:30,736 --> 00:06:35,014
of being able to think reactively. Well, as I've very broadly

104
00:06:35,062 --> 00:06:38,378
and very abstractly really explained this, you're probably

105
00:06:38,464 --> 00:06:42,410
wondering how exactly is this getting done? And there's a variety of ways

106
00:06:42,480 --> 00:06:45,998
that this can be done and I'm going to examine a particular

107
00:06:46,084 --> 00:06:49,646
way that this is done. And then particularly how that plays into r two

108
00:06:49,668 --> 00:06:52,970
DBC. As we talk about reactive development and reactive

109
00:06:53,050 --> 00:06:56,686
solutions with relational data sources. First we

110
00:06:56,708 --> 00:06:59,554
need to take a look at the definition. A lot of times I like to

111
00:06:59,592 --> 00:07:03,250
start with the simplest spot that we can build off of. And really that is

112
00:07:03,320 --> 00:07:07,042
this definition of fullyreactive programming, right? And it's chock full

113
00:07:07,096 --> 00:07:10,630
of computer sciency words. So we're going to kind of piece this apart

114
00:07:11,130 --> 00:07:14,386
as I read this out. But we've got a declarative programming

115
00:07:14,418 --> 00:07:17,778
paradigm concerned with data streams in the propagation

116
00:07:17,874 --> 00:07:21,794
of change. Now, like I said, that's chock full of computer sciency language.

117
00:07:21,842 --> 00:07:24,746
But essentially what that means is that if we look at it first, we're looking

118
00:07:24,768 --> 00:07:28,186
at a declarative programming paradigm. Those of you may be familiar, may not

119
00:07:28,208 --> 00:07:31,926
be familiar, but you can really think of declarative programming paradigms as

120
00:07:31,968 --> 00:07:35,630
you're not necessarily concerned about the minutiae or

121
00:07:35,700 --> 00:07:39,166
the step by step process of what's happening in some

122
00:07:39,188 --> 00:07:42,494
kind of, let's say, a command or execution. You're really just interested

123
00:07:42,612 --> 00:07:46,094
in performing something and then retrieving back a result of some

124
00:07:46,132 --> 00:07:49,426
sort. So it's a little bit different than, say, something like imperative programming where

125
00:07:49,448 --> 00:07:52,898
you're really controlling the workflow, right? Is a step by step process.

126
00:07:52,984 --> 00:07:56,414
So there's that side where it's declarative. And then this idea of dealing

127
00:07:56,462 --> 00:07:59,942
with data streams and ultimately the propagation of change.

128
00:07:59,996 --> 00:08:03,062
Now we're going to dive a lot more into data streams, but propagation of change,

129
00:08:03,116 --> 00:08:06,690
of course, you can just think of as this dissemination or spread

130
00:08:06,770 --> 00:08:10,354
changes in data, for instance, and that's really largely

131
00:08:10,402 --> 00:08:13,866
handled by data streams. So if we get nothing out of this definition, really what

132
00:08:13,888 --> 00:08:17,114
we're keying into is how we can use data streams combined with

133
00:08:17,152 --> 00:08:20,794
declarative programming to really help with the propagation or the

134
00:08:20,832 --> 00:08:24,298
spread of change. Now, if we were to ask

135
00:08:24,384 --> 00:08:27,454
probably a lot of you out there, well, what is a data stream? I mean,

136
00:08:27,492 --> 00:08:31,054
the definition that really comes first and foremost to us is probably this

137
00:08:31,092 --> 00:08:34,174
idea. Now we don't have to use publisher and subscriber, but you can think

138
00:08:34,212 --> 00:08:38,014
of point a and point b where you're just quite literally

139
00:08:38,142 --> 00:08:41,586
streaming data, right? And in fact you could say, hey,

140
00:08:41,688 --> 00:08:45,042
send it all over, just send all of the data over. But of course,

141
00:08:45,096 --> 00:08:49,126
most of us know that if this happens from one point to another, or in

142
00:08:49,148 --> 00:08:52,834
this case, what we're using is the publisher and subscriber, this subscriber

143
00:08:52,882 --> 00:08:56,406
can become overwhelmed, right? And so if that happens and

144
00:08:56,428 --> 00:09:00,530
it's not able to handle the data that comes in either at volume

145
00:09:00,610 --> 00:09:04,050
or even the velocity of which it's receiving it, then it's going

146
00:09:04,060 --> 00:09:06,826
to have to put it someplace to handle it later. And in this case,

147
00:09:06,848 --> 00:09:09,866
we can think of, this was a backlog, right? It's really creating this backlog of,

148
00:09:09,888 --> 00:09:13,514
hey, I've got this operation to do, but I will handle this

149
00:09:13,552 --> 00:09:16,814
later. But the problem with that is that can really start to mount up,

150
00:09:16,852 --> 00:09:20,394
right? So as we're sending more and more data, maybe we're not decreasing the velocity

151
00:09:20,442 --> 00:09:24,142
or we're increasing the volume. It doesn't really help the subscriber at that point.

152
00:09:24,196 --> 00:09:28,322
And so it starts to build this backlog up even more. Right. And that really

153
00:09:28,376 --> 00:09:32,194
has us dive into, okay, well, what is a data stream, right. It was pretty

154
00:09:32,232 --> 00:09:35,346
simple on that last slide. You're just streaming data. But we

155
00:09:35,368 --> 00:09:39,542
need to take a step deeper into what's available to us within

156
00:09:39,596 --> 00:09:42,854
the anatomy of a data stream that we can use to make

157
00:09:42,892 --> 00:09:46,054
that process more efficient. Because ultimately, as we talk about

158
00:09:46,092 --> 00:09:50,226
fullyreactive programming, and then as we dive into R two DBC, we're really honing

159
00:09:50,258 --> 00:09:53,642
in on this idea of efficiency and really improving that. And so

160
00:09:53,696 --> 00:09:57,594
from an anatomical perspective of a data stream, of course, we know

161
00:09:57,632 --> 00:10:01,130
that it has to start at some point. And logically, we hope,

162
00:10:01,200 --> 00:10:04,458
right, it's not some infinite process, and it's going to complete,

163
00:10:04,544 --> 00:10:07,994
right. And we hope at the end of that, that all data has been processed

164
00:10:08,042 --> 00:10:11,694
in some manner. And this all happens over the course of time, right? You start

165
00:10:11,732 --> 00:10:15,278
it, and then, of course, whether it's nanoseconds or it's hours,

166
00:10:15,364 --> 00:10:18,658
days, weeks, whatever it is, this happens over the course of time. It's going to

167
00:10:18,664 --> 00:10:22,146
start and it's going to complete. But what becomes more interesting, of course, is what

168
00:10:22,168 --> 00:10:25,634
we're sending. Now, this is all relatively straightforward, but we're going to be

169
00:10:25,672 --> 00:10:29,654
sending, in this case, calling them variables. But these are really that propagation or

170
00:10:29,692 --> 00:10:33,702
just the changes in data that I was speaking about before, right. Was things

171
00:10:33,756 --> 00:10:37,202
get sent along this stream. Data gets sent along this stream,

172
00:10:37,266 --> 00:10:40,166
and ultimately, it can run one of two paths,

173
00:10:40,198 --> 00:10:43,814
right? It can either successfully be processed and completed,

174
00:10:43,862 --> 00:10:47,334
or it can unsuccessfully, right. Causing some error or some exception.

175
00:10:47,382 --> 00:10:50,922
And while this anatomy is pretty straightforward and pretty easy

176
00:10:50,976 --> 00:10:54,586
to wrap our minds around with, it's actually very powerful, because as we dive

177
00:10:54,618 --> 00:10:57,866
into the next couple of slides and I start to extrapolate

178
00:10:57,978 --> 00:11:01,882
from this or start to really build on top of this anatomical

179
00:11:01,946 --> 00:11:05,294
setup for a data stream, we'll see that we can use all of these

180
00:11:05,332 --> 00:11:08,686
parts in order to create some standards and some specifications

181
00:11:08,798 --> 00:11:12,386
that really help us with reactive development. But the first thing that we want to

182
00:11:12,408 --> 00:11:15,666
start on is this idea of back pressure, right? So one

183
00:11:15,688 --> 00:11:19,750
of the things that the anatomy of a data stream really helps us key into

184
00:11:19,820 --> 00:11:23,574
and the original problem that we had, right, was that we're taking maybe too

185
00:11:23,612 --> 00:11:27,314
much information, either from a velocity perspective, a volume perspective,

186
00:11:27,362 --> 00:11:30,566
or both, like in this image to the face, maybe right

187
00:11:30,588 --> 00:11:34,346
when we've got this fire hose, and ultimately we can't handle drinking out of this

188
00:11:34,368 --> 00:11:37,466
fire hose. And so back pressure comes in was a way to be able

189
00:11:37,488 --> 00:11:41,162
to control that flow. Right. You can imagine that back pressure is

190
00:11:41,216 --> 00:11:44,670
basically controlled with this guy's hand so he doesn't just get

191
00:11:44,740 --> 00:11:48,586
annihilated in the face with some water. This really starts to introduce

192
00:11:48,618 --> 00:11:52,238
us to the idea of back pressure. Now, if I bring up the diagram that

193
00:11:52,244 --> 00:11:55,526
I had before, where we've got that simple relationship between a publisher

194
00:11:55,578 --> 00:11:59,122
and a subscriber, what this means is that you give control

195
00:11:59,256 --> 00:12:02,866
to the subscriber to communicate with the publisher to

196
00:12:02,888 --> 00:12:06,546
be able to say, hey, I only want this much information. This is essentially how

197
00:12:06,568 --> 00:12:10,166
much I can handle. And then at some given time, whenever that may

198
00:12:10,188 --> 00:12:13,798
be, it could be instantly, it could be seconds, could be hours.

199
00:12:13,884 --> 00:12:17,366
However, it is at some amount of time when the publisher is ready to

200
00:12:17,388 --> 00:12:20,790
do what the subscriber has asked for it do, it can send that information.

201
00:12:20,940 --> 00:12:24,802
And this really creates this idea of non blocking back pressure

202
00:12:24,866 --> 00:12:28,242
where the subscriber is going to say, hey, this is what I can handle.

203
00:12:28,306 --> 00:12:31,946
Send this to me when you can, and an undetermined amount of time, the publisher

204
00:12:31,978 --> 00:12:34,286
is going to say, hey, I'm going to go ahead and send this. And it

205
00:12:34,308 --> 00:12:38,254
creates a very non blacking scenario here where we can receive that information that

206
00:12:38,292 --> 00:12:41,566
the subscriber is set up to handle. And of course, if we put this in

207
00:12:41,588 --> 00:12:45,258
a scenario of operating on a couple of things, this means that if the subscriber

208
00:12:45,354 --> 00:12:49,026
request will say a single element or a single piece of data, then of

209
00:12:49,048 --> 00:12:52,802
course the publisher is going to send that single piece of information.

210
00:12:52,936 --> 00:12:56,606
If the subscriber says, hey, I can receive more, then the publisher

211
00:12:56,638 --> 00:13:00,422
can go ahead and send the subscriber two more pieces of information and so on

212
00:13:00,476 --> 00:13:03,942
and so forth. But this is very simple, right? And that's good.

213
00:13:03,996 --> 00:13:07,254
But the problem with that is that there's any number of ways that this

214
00:13:07,292 --> 00:13:11,154
can be implemented. And we all know that working at different shops and

215
00:13:11,212 --> 00:13:14,954
throughout the years, there's a lot of times where we may reinvent the

216
00:13:14,992 --> 00:13:18,346
wheel or we'll go grab some random package and there's no

217
00:13:18,368 --> 00:13:21,978
real consensus on how some of this stuff is done. And that can create a

218
00:13:21,984 --> 00:13:25,710
problem, right, for the longevity of a project or maintenance of a project,

219
00:13:25,860 --> 00:13:29,198
even onboarding people, and I've never seen this, what the heck how

220
00:13:29,204 --> 00:13:32,938
are you doing this? And having to basically spend cycles bringing

221
00:13:32,954 --> 00:13:36,654
everybody up to speed on exactly how you implemented non blocking back pressure.

222
00:13:36,702 --> 00:13:39,854
So back in 2013, a group of individuals

223
00:13:39,902 --> 00:13:43,266
from places like Netflix and Pivotal and Lightbend got together

224
00:13:43,368 --> 00:13:46,754
and they created a specification. And this specification is called

225
00:13:46,792 --> 00:13:50,562
reactive streams. And essentially it's a way to be able to take advantage

226
00:13:50,626 --> 00:13:54,326
of the anatomy, right? So the pieces of the data stream in

227
00:13:54,348 --> 00:13:57,734
such a way that you could create a very efficient design and a very

228
00:13:57,772 --> 00:14:01,754
reusable, almost standard, right, is in the specification to be able to

229
00:14:01,792 --> 00:14:05,942
use across a variety of different libraries or solutions

230
00:14:06,006 --> 00:14:09,834
in a reusable manner that's broadly disseminated and broadly used.

231
00:14:09,952 --> 00:14:13,478
And this again contains pieces like I'd shown before, like the

232
00:14:13,504 --> 00:14:16,954
publisher and the subscriber, but using some of the anatomical

233
00:14:17,002 --> 00:14:20,366
features of some of the things available within a data stream to be able

234
00:14:20,388 --> 00:14:24,154
to take advantage of sending variables and understanding

235
00:14:24,202 --> 00:14:27,774
whether or not things were done in error or cause an exception, and then

236
00:14:27,812 --> 00:14:30,802
whether or not things completed, we can actually piece this puzzle together,

237
00:14:30,856 --> 00:14:34,302
right, as we see here in this diagram, where through the use of a subscription,

238
00:14:34,366 --> 00:14:38,086
we can set up a relationship between a publisher, a subscriber, and we can do

239
00:14:38,108 --> 00:14:41,746
certain things, right, we can request certain information, we can cancel the stream

240
00:14:41,778 --> 00:14:45,670
altogether, and then the publisher is essentially going to notify

241
00:14:46,090 --> 00:14:49,718
the subscriber key into events, sorry, methods that exist on

242
00:14:49,724 --> 00:14:53,114
the subscriber to say, hey, here's your next item. This actually had

243
00:14:53,152 --> 00:14:57,098
an error, or I'm completely done. But again, this is very general.

244
00:14:57,184 --> 00:15:00,554
So what this means to you, as the developers out there is you can really

245
00:15:00,592 --> 00:15:04,586
take this and think of it very simply as a collection of interfaces.

246
00:15:04,698 --> 00:15:07,966
Fullyreactive streams API is really a specification. And what

247
00:15:07,988 --> 00:15:12,126
that means is that they're not really defining how exactly from a step by

248
00:15:12,148 --> 00:15:16,302
step process. You should really do this. That's up to whatever implementing libraries,

249
00:15:16,366 --> 00:15:20,322
which I'll get into a little bit later, decide to do that stuff instead.

250
00:15:20,456 --> 00:15:24,158
These collection of interfaces are basically just defining the structure

251
00:15:24,254 --> 00:15:28,094
and essentially the flow of how these things can work to create reactive

252
00:15:28,142 --> 00:15:32,006
solutions using the fullyreactive streams API. Okay, but why

253
00:15:32,108 --> 00:15:35,506
is this important? I know you're like, Rob, you started this session at the beginning

254
00:15:35,538 --> 00:15:38,634
of it talking about reactive programming and how you can use that with

255
00:15:38,672 --> 00:15:42,742
relational databases. And we haven't really gotten into databases

256
00:15:42,806 --> 00:15:46,618
at all relational otherwise. So why is this important? Well,

257
00:15:46,704 --> 00:15:50,074
fullyreactive database interactions, in order for that to

258
00:15:50,112 --> 00:15:54,094
happen, they need to be top to bottom. So in order to

259
00:15:54,292 --> 00:15:57,886
get the benefits of a reactive solution in general, is that the

260
00:15:57,908 --> 00:16:01,182
whole thing needs to be reactive, right? Otherwise, if you've got maybe

261
00:16:01,236 --> 00:16:05,034
a portion of it, say the server back end part of it is all reactive,

262
00:16:05,082 --> 00:16:08,142
but then your communication with the database is not, it's blocked.

263
00:16:08,206 --> 00:16:11,694
And if one part of an application or a solution is blocked,

264
00:16:11,742 --> 00:16:15,006
then if you think about it, it's all really blocked, right? Because it's not fully

265
00:16:15,038 --> 00:16:18,914
reactive in the sense that everything is communicating in this kind of publisher

266
00:16:18,962 --> 00:16:22,594
subscriber, what you think of as event driven programming,

267
00:16:22,642 --> 00:16:26,246
asynchronous data streams through event driven programming. And so if

268
00:16:26,268 --> 00:16:29,362
it's not top to bottom, then it's really not reactive.

269
00:16:29,426 --> 00:16:32,594
And so for reactive database interactions,

270
00:16:32,722 --> 00:16:35,866
they really need to be fundamentally non blocking and they need to

271
00:16:35,888 --> 00:16:39,686
use these things or this concept of back pressure, which is why I've described

272
00:16:39,718 --> 00:16:42,846
it. And the reason why I put this up first is because there's a lot

273
00:16:42,868 --> 00:16:46,734
of libraries like RX Java, project reactor that already

274
00:16:46,772 --> 00:16:50,270
use reactive streams, right? They already have implementations of

275
00:16:50,340 --> 00:16:53,978
that specification or that API was an implemented library.

276
00:16:54,074 --> 00:16:57,166
So they've gone in to find the actual bits and processes

277
00:16:57,198 --> 00:17:00,926
that need to happen to kind of fill out fullyreactive streams as an actual library

278
00:17:00,958 --> 00:17:04,466
or an actual solution. And because again, it's supposed to be like

279
00:17:04,488 --> 00:17:08,082
the standard specification, it's something that kind of plays well

280
00:17:08,136 --> 00:17:12,098
with how you would communicate with a database. But unfortunately,

281
00:17:12,194 --> 00:17:15,206
if we're talking about Java based or

282
00:17:15,228 --> 00:17:19,014
really JVM ecosystem based solutions, we're very used

283
00:17:19,052 --> 00:17:23,030
to using something like the Java database connectivity specification,

284
00:17:23,110 --> 00:17:26,426
which is JDBC, right? So you're probably very familiar with that. Now, as I

285
00:17:26,448 --> 00:17:30,730
described in the scenario before, you can create a fullyreactive application using maybe

286
00:17:30,880 --> 00:17:33,966
RX Java or using Project reactor. But when

287
00:17:33,988 --> 00:17:37,386
you hit the JDBC API, well, it was created

288
00:17:37,418 --> 00:17:41,294
back in 1997, and it wasn't really made in

289
00:17:41,412 --> 00:17:45,114
keeping in mind some of these more reactive types of interactions.

290
00:17:45,162 --> 00:17:48,546
In fact, those weren't really mainstream for applications in general because we

291
00:17:48,568 --> 00:17:52,542
weren't having to deal with things like taking advantage most efficiently

292
00:17:52,606 --> 00:17:56,318
of the hardware. Underneath, we were really mostly concerned about things like

293
00:17:56,344 --> 00:18:00,214
performance. And so that's really where a lot of the threading conversation comes

294
00:18:00,252 --> 00:18:03,010
in, or handling context, or handling concurrency.

295
00:18:03,090 --> 00:18:06,806
So by design, JDBC was actually designed as

296
00:18:06,828 --> 00:18:10,878
a blocking driver, right? So it communicates using some kind of wire protocol

297
00:18:10,914 --> 00:18:14,486
to the underlying database, and you have to wait for whatever it's

298
00:18:14,518 --> 00:18:17,674
done. And solutions otherwise essentially are just done through

299
00:18:17,712 --> 00:18:21,334
an asynchronous manner where you're kind of spinning up threads or threaded

300
00:18:21,382 --> 00:18:24,606
communication in order to be able to do that. But while that may be

301
00:18:24,628 --> 00:18:28,554
good for a lot of applications out there, if you're looking to maintain

302
00:18:28,602 --> 00:18:31,998
or kind of improve as much as you can the efficiency of the

303
00:18:32,004 --> 00:18:35,534
hardware and of the horsepower underlying for your database

304
00:18:35,582 --> 00:18:39,086
and your applications, then you're going to need to have another solution.

305
00:18:39,198 --> 00:18:42,894
And that's where finally, R two DBC enters

306
00:18:42,942 --> 00:18:46,274
the chat or enters the conversation. Right, but what is R

307
00:18:46,312 --> 00:18:50,166
two DBC? Well, as you remember, JDBC is an acronym that I went

308
00:18:50,188 --> 00:18:53,734
into, and I've probably said all of the words enough and you've probably

309
00:18:53,852 --> 00:18:57,234
guessed at this point if you didn't already know. But R two DBC

310
00:18:57,282 --> 00:19:00,342
stands for reactive relational databases,

311
00:19:00,406 --> 00:19:04,694
connectivity and like JDBC and like reactive streams,

312
00:19:04,822 --> 00:19:08,442
it is a specification. Now, the goals and design

313
00:19:08,496 --> 00:19:12,266
principles really of this specification are pretty simple and straightforward.

314
00:19:12,378 --> 00:19:15,774
One, we live in a day and age where everything really needs to be open.

315
00:19:15,812 --> 00:19:19,182
And coming from MariaDB and even

316
00:19:19,236 --> 00:19:23,022
before that, really Marie DB, coming from MySQL, we're really

317
00:19:23,076 --> 00:19:26,874
ingrained and really have our ears to the ground from the open source community,

318
00:19:26,932 --> 00:19:30,994
because we understand that the open source community, a whole, can really come

319
00:19:31,032 --> 00:19:34,190
together and solve a lot of problems. And so it was one of the goals

320
00:19:34,270 --> 00:19:37,746
for the specification of RDBC to be completely open.

321
00:19:37,848 --> 00:19:41,122
And that's because the group of people that originally started didn't

322
00:19:41,266 --> 00:19:44,662
set out thinking, oh well, we have all of the solutions for all the problems

323
00:19:44,716 --> 00:19:48,418
that may come up with communicating with relational data sources underneath.

324
00:19:48,514 --> 00:19:51,530
In fact, quite the opposite, right? They want to open that up so that community

325
00:19:51,600 --> 00:19:55,034
members, and I encourage you after this, if you want to go and

326
00:19:55,152 --> 00:19:58,906
contribute to RTDBC, please do that. They come

327
00:19:58,928 --> 00:20:02,554
from all walks and backgrounds and different types of solutions. And so

328
00:20:02,592 --> 00:20:06,046
they can come with different types of solutions for the problems that exist out there.

329
00:20:06,148 --> 00:20:09,342
And then beyond that, a lot of the principles have really gone into,

330
00:20:09,396 --> 00:20:13,946
as we've talked about, reactive development in general, such as being completely nonblocking.

331
00:20:13,978 --> 00:20:17,106
Right. It's important that in fact, it's crucial that the

332
00:20:17,128 --> 00:20:20,446
database interaction for a reactive solution be completely non

333
00:20:20,478 --> 00:20:23,406
blocking, because if you're going to create a fullyreactive solution, it needs to be fully

334
00:20:23,438 --> 00:20:27,282
reactive. And of course, I dove into fullyreactive streams

335
00:20:27,346 --> 00:20:31,122
because that really sets a standard, this universal specification

336
00:20:31,186 --> 00:20:34,690
that can be used within your backend,

337
00:20:34,770 --> 00:20:37,906
maybe API solution or whatever the solution may be, that communicates

338
00:20:37,938 --> 00:20:41,222
with the database, which may already be using reactive streams.

339
00:20:41,286 --> 00:20:45,734
We want to use that same specification within a database connectivity driver,

340
00:20:45,782 --> 00:20:49,466
ultimately. And along with that, we need to have a very small

341
00:20:49,568 --> 00:20:52,634
footprint, right? So a very lightweight specification that

342
00:20:52,672 --> 00:20:56,126
doesn't set out to make too many assumptions or have too

343
00:20:56,148 --> 00:20:58,874
many opinions. And so for RTDBC,

344
00:20:59,002 --> 00:21:02,206
one of the largest goals was to keep it small, to keep it

345
00:21:02,228 --> 00:21:05,746
simple, because while a lot of relational databases are very similar

346
00:21:05,848 --> 00:21:09,182
in the way that they may connect, they may execute

347
00:21:09,246 --> 00:21:12,674
queries, there are a lot of differences between them, right.

348
00:21:12,712 --> 00:21:16,590
There's a lot of vendor differences between, say, MySQL, Marie DB,

349
00:21:16,750 --> 00:21:20,098
Microsoft SQL Server, Oracle Postgres. Right. There's a lot of

350
00:21:20,104 --> 00:21:23,442
things that you can take advantage of, each ones that really set them apart.

351
00:21:23,506 --> 00:21:26,886
And so R two DBC, as a specification wanted to keep

352
00:21:26,908 --> 00:21:30,838
this in mind so that at the driver level, things could be added

353
00:21:30,934 --> 00:21:34,822
into it without having to absorb or kind of handle opinionated

354
00:21:34,886 --> 00:21:38,678
or assumptions that were created within the R two JDBC specification.

355
00:21:38,774 --> 00:21:43,222
And then ultimately other clients and libraries can also be created in combination

356
00:21:43,286 --> 00:21:47,086
or used in tandem with the drivers, which I'll get into a little

357
00:21:47,108 --> 00:21:50,718
bit later. And this really harkens back to the diagram that

358
00:21:50,724 --> 00:21:53,982
I showed a few slides ago where rather than having a green

359
00:21:54,036 --> 00:21:57,786
checkmark for the reactive app or the actual back end

360
00:21:57,828 --> 00:22:01,522
application that you may be creating that communicates the database, now we've got two green

361
00:22:01,576 --> 00:22:05,326
check marks because the whole application is completely reactive or fully

362
00:22:05,358 --> 00:22:08,678
reactive. But diving a little bit deeper into that, we need to take a

363
00:22:08,684 --> 00:22:12,374
look at the specification itself. Right. And how you can

364
00:22:12,412 --> 00:22:15,922
use something called the service provider interface,

365
00:22:15,986 --> 00:22:19,158
the SPI for R two DBC, to actually create

366
00:22:19,244 --> 00:22:22,666
a reactive driver. And that reactive driver is then something the

367
00:22:22,688 --> 00:22:26,438
implementation that then you can use within your applications. So first we're

368
00:22:26,454 --> 00:22:29,862
going to take a look at the R two DBC SPI,

369
00:22:29,926 --> 00:22:33,226
take a look at how that's constructed, what the principles

370
00:22:33,258 --> 00:22:36,638
of design were really brought together for,

371
00:22:36,724 --> 00:22:40,538
and how that then ultimately can be used within a vendor's

372
00:22:40,634 --> 00:22:44,014
reactive driver, R two DBC driver, in order

373
00:22:44,052 --> 00:22:46,638
to create something that you can use against a database.

374
00:22:46,814 --> 00:22:50,366
Well, why this service provider interface?

375
00:22:50,398 --> 00:22:53,570
Right. So before I get into what it is,

376
00:22:53,640 --> 00:22:56,994
and really when, as we look at what it is, we're going to see that

377
00:22:57,112 --> 00:23:00,982
it's pretty simple, but it's really important before we do that to understand

378
00:23:01,116 --> 00:23:04,146
why. And a little bit of this I touched on just a couple of seconds

379
00:23:04,178 --> 00:23:07,414
ago is this idea of being able to

380
00:23:07,452 --> 00:23:10,602
create a very kind of unappenated or

381
00:23:10,656 --> 00:23:13,866
unbiased approach, not making too many assumptions of

382
00:23:13,888 --> 00:23:17,270
things that need to be done, essentially keeping the specification

383
00:23:17,350 --> 00:23:21,414
as light as possible. And that's really done from a hindsight

384
00:23:21,462 --> 00:23:24,762
perspective, where we look back at things like JDBC

385
00:23:24,826 --> 00:23:28,286
and not to pick too much on JDBC because it was stood the test of

386
00:23:28,308 --> 00:23:32,298
time. Obviously you can really use JDBC for a multitude

387
00:23:32,314 --> 00:23:35,678
of solutions. But one of the things that I'd point out is that if you've

388
00:23:35,694 --> 00:23:39,538
ever dealt with JDBC, either from an API perspective or

389
00:23:39,624 --> 00:23:42,786
creating a driver from it, is that it can be

390
00:23:42,808 --> 00:23:46,386
very opinionated, right. And it has done some things that has

391
00:23:46,408 --> 00:23:50,086
made it ultimately very difficult, either from an API side or a

392
00:23:50,108 --> 00:23:53,718
driver side, to have to add some extra code to

393
00:23:53,724 --> 00:23:57,590
handle things specific to keywords like question mark binding,

394
00:23:58,090 --> 00:24:01,546
to basically have to parse through URLs on

395
00:24:01,568 --> 00:24:05,238
the driver side, which we all know URLs are fairly

396
00:24:05,334 --> 00:24:09,158
universal at this point, so there's really no need to have to reinvent

397
00:24:09,174 --> 00:24:12,746
the wheel for every driver empty that's constructed and so on

398
00:24:12,768 --> 00:24:16,174
and so forth. These problems have kind of sprouted up. But the idea really

399
00:24:16,212 --> 00:24:19,726
was to take the advantage of hindsight within RDBC and kind of

400
00:24:19,748 --> 00:24:23,054
strip down or simplify things as possible while still being

401
00:24:23,092 --> 00:24:26,974
broadly available or broadly be able to be used by implementing drivers.

402
00:24:27,022 --> 00:24:30,450
And as I mentioned, URL parsing is one of the first things on that list,

403
00:24:30,520 --> 00:24:33,774
because we know that URLs are pretty straightforward,

404
00:24:33,822 --> 00:24:37,346
right? And for database connectivity, over the course of years,

405
00:24:37,448 --> 00:24:40,854
through usage of things like JDBC, they've established a pretty set

406
00:24:40,892 --> 00:24:43,858
URL to be able to do this, right, where you're defining things like the scheme

407
00:24:43,874 --> 00:24:46,882
in this case of determining that it's R two DBC,

408
00:24:47,026 --> 00:24:50,830
specifying a driver, whether that be MySQL or SQL server,

409
00:24:50,930 --> 00:24:54,374
being able to identify the database through a host

410
00:24:54,422 --> 00:24:58,026
or a port number, maybe you've got a default database, and then being able

411
00:24:58,048 --> 00:25:01,962
to set on query parameters that maybe add things like security or

412
00:25:02,016 --> 00:25:05,754
encryption to be able to add to that overall profile

413
00:25:05,802 --> 00:25:09,198
of how you want to communicate with the targeted database, right? That's what

414
00:25:09,204 --> 00:25:12,526
the URL is for. And so within RTDBC, they're handling all the

415
00:25:12,548 --> 00:25:15,966
URL parsing for you. So the implementing driver doesn't have to worry

416
00:25:15,998 --> 00:25:20,270
about those things. There's a set standard beyond that, the R two DBC driver

417
00:25:20,350 --> 00:25:24,162
or the R two DBC SPI comes with really two levels of

418
00:25:24,216 --> 00:25:28,006
compliance. So there are things or interfaces really if

419
00:25:28,028 --> 00:25:31,506
we look at the API interfaces that have to be fully

420
00:25:31,538 --> 00:25:35,186
supported, right? So they have to have an implementation and a full implementation.

421
00:25:35,298 --> 00:25:39,126
And there's interfaces that exist within the SPI that have

422
00:25:39,148 --> 00:25:42,714
to be partially supported. And part of that is because it allows that

423
00:25:42,752 --> 00:25:46,474
flexibility within the drivers to key into vendor level

424
00:25:46,592 --> 00:25:49,994
functionality or vendor specific functionality. But a lot of this should look

425
00:25:50,032 --> 00:25:53,214
very familiar. Right. As we take a look at it, we're looking at things like

426
00:25:53,252 --> 00:25:56,974
connection factory, which of course basically

427
00:25:57,092 --> 00:26:00,606
a factory. It's producing some kind of product and in

428
00:26:00,628 --> 00:26:03,934
this case the product is a connection. And so we're going to take a look

429
00:26:03,972 --> 00:26:07,778
at kind of this kind of top down approach where we

430
00:26:07,784 --> 00:26:11,534
can think about a very normal or very standard sequence

431
00:26:11,582 --> 00:26:14,626
of events that may need to happen in order to be able to communicate with

432
00:26:14,648 --> 00:26:18,270
the database, execute a query and return, and then parse some results.

433
00:26:18,350 --> 00:26:21,606
And that involves in this case taking a look at a

434
00:26:21,628 --> 00:26:24,806
couple of interfaces that exist within the SPI. One of course that

435
00:26:24,828 --> 00:26:28,322
I mentioned was connectivity factory, how they can create connectivity,

436
00:26:28,466 --> 00:26:31,818
then from those connections that have been established, how statements can then

437
00:26:31,824 --> 00:26:35,386
be executed and then using results, object in a

438
00:26:35,408 --> 00:26:38,746
row object, how those can be parsed. So let's go ahead and first take

439
00:26:38,768 --> 00:26:42,186
a look at the connection factory within the SPI. It's pretty simple. This is the

440
00:26:42,208 --> 00:26:45,822
entire interface that exists for connection factory. Now a lot of this seems

441
00:26:45,876 --> 00:26:49,774
probably pretty straightforward, and I actually pretty much described exactly what

442
00:26:49,812 --> 00:26:53,694
it does, which is that it creates connections. But one of the things to look

443
00:26:53,732 --> 00:26:57,074
at, and this really takes us to the beginning of the session where

444
00:26:57,112 --> 00:27:00,894
I talked about how reactive streams is an integral

445
00:27:00,942 --> 00:27:04,798
part in R two DBC. And that's because fullyreactive streams

446
00:27:04,894 --> 00:27:08,662
is used directly, right? So the specification is

447
00:27:08,716 --> 00:27:12,226
used throughout the R two DBC specification.

448
00:27:12,338 --> 00:27:15,554
Now again, like fullyreactive streams, R two DBC

449
00:27:15,602 --> 00:27:19,154
is really just a collection of mostly interfaces. There are some classes

450
00:27:19,202 --> 00:27:22,586
and there's some abstract classes in there, but it's mostly interfaces that have to be

451
00:27:22,608 --> 00:27:26,054
implemented from a driver. Right? So from MySQL was a vendor,

452
00:27:26,102 --> 00:27:29,414
they've got their driver, Marie DP or postgres,

453
00:27:29,542 --> 00:27:33,386
Microsoft SQL Server. Right. A bunch of different drivers out there. But what

454
00:27:33,408 --> 00:27:36,766
we want to key in on is this usage of reactive streams, because as we

455
00:27:36,788 --> 00:27:40,746
take a look, we know that we're using reactive streams. Specifically we're

456
00:27:40,778 --> 00:27:44,286
importing the publisher. And the reason why we're doing that is because

457
00:27:44,308 --> 00:27:47,678
if we remember back to the relationship really between a publisher

458
00:27:47,694 --> 00:27:50,994
and a subscriber, we understood that, that in that first very simple one

459
00:27:51,032 --> 00:27:54,274
where we're talking about, hey, I want to request some information. The publisher says,

460
00:27:54,312 --> 00:27:58,258
okay, whatever amount of time I need to prep this or prepare this,

461
00:27:58,344 --> 00:28:01,222
I'm going to send this back over to you. This is what's happening here,

462
00:28:01,276 --> 00:28:05,046
right? Is that rather than just getting a connection, right. So we're using

463
00:28:05,148 --> 00:28:08,838
the create method to just get a connection back. We're actually

464
00:28:08,924 --> 00:28:12,522
getting back a publisher. So when we execute the create

465
00:28:12,576 --> 00:28:15,946
method, we're actually just receiving then this publisher that we

466
00:28:15,968 --> 00:28:19,398
can then subscribe to, which is going to say, hey, at a given time I'm

467
00:28:19,414 --> 00:28:22,938
going to give you this connection when I'm ready. And that could happen instantaneously,

468
00:28:22,954 --> 00:28:27,338
it could happen nanoseconds, milliseconds down the road. But we're

469
00:28:27,434 --> 00:28:31,514
tapping directly into the reactive streams and more importantly reactive

470
00:28:31,562 --> 00:28:35,658
programming to make this more of an asynchronous process of receiving

471
00:28:35,754 --> 00:28:39,218
this connection or ultimately this event that tells us that we

472
00:28:39,224 --> 00:28:43,010
can have that connection. And this is a theme that plays throughout all of

473
00:28:43,080 --> 00:28:46,018
the interfaces, right? And I say all of them, I mean, of course not all

474
00:28:46,024 --> 00:28:49,558
of them have necessarily interactions with reactive streams as we get into some

475
00:28:49,564 --> 00:28:52,998
of the enumerations and stuff like that. But as we get into

476
00:28:53,084 --> 00:28:56,246
interacting with the database itself, it all is really

477
00:28:56,348 --> 00:28:59,926
rooted or kind of built its foundation on reactive streams and

478
00:28:59,948 --> 00:29:03,770
of course reactive programming. And so receiving things

479
00:29:03,920 --> 00:29:07,626
or beginning things like a transaction, right? Being able to begin a transaction is

480
00:29:07,648 --> 00:29:11,546
a process that we can subscribe to or being able to close a

481
00:29:11,568 --> 00:29:15,178
connectivity, being able to commit transactions. These are all things that we're

482
00:29:15,194 --> 00:29:18,830
taking advantage of in a reactive manner. Even the

483
00:29:18,900 --> 00:29:22,826
idea of being able to execute a structured query language

484
00:29:22,938 --> 00:29:26,802
statement or an SQL or SQL statement is being done

485
00:29:26,856 --> 00:29:30,526
using reactive streams where we're essentially returning

486
00:29:30,558 --> 00:29:33,714
back. So we're executing whatever our statement may be.

487
00:29:33,752 --> 00:29:37,326
But when this was been executed, we're subscribing to a publisher to receive

488
00:29:37,358 --> 00:29:41,362
that result. And so when that statement has been executed and the publisher

489
00:29:41,426 --> 00:29:44,870
sends that to the subscriber, that's when we'll receive that result

490
00:29:44,940 --> 00:29:48,934
object. And of course, nothing really new here is that as we

491
00:29:49,052 --> 00:29:52,646
start to dive into the result object, which you could think of as a collection

492
00:29:52,678 --> 00:29:55,962
of rows or a collection of pieces of data

493
00:29:56,016 --> 00:29:59,446
that have come from whatever query statement we have executed.

494
00:29:59,558 --> 00:30:03,054
We can also take advantage of being able to look at things like how many

495
00:30:03,092 --> 00:30:06,254
rows to being able to parse through that

496
00:30:06,292 --> 00:30:10,618
information in a reactive format or a reactive methodology

497
00:30:10,794 --> 00:30:14,026
all the way down into a row, which is quite literally a row

498
00:30:14,058 --> 00:30:17,206
of information. Now that of course doesn't have to be tied to a specific table

499
00:30:17,258 --> 00:30:20,914
that could be just depending on your query. But ultimately we're trying

500
00:30:20,952 --> 00:30:24,094
to get to this row. So as you can see, and if you're familiar

501
00:30:24,142 --> 00:30:28,042
with it, doesn't even really have to exist within the Java or JVM ecosystem,

502
00:30:28,126 --> 00:30:31,510
any real connection driver or connectivity driver out there.

503
00:30:31,580 --> 00:30:34,902
Ultimately, if you're dealing with a relational database, you're trying to

504
00:30:34,956 --> 00:30:38,694
take advantage of being able to use that tabular information and however you

505
00:30:38,732 --> 00:30:42,266
constructed your query and be able to get after that. The difference here of

506
00:30:42,288 --> 00:30:45,590
course is that we're doing that in a very reactive manner

507
00:30:45,670 --> 00:30:49,386
on top of the reactive streams specification. But of

508
00:30:49,408 --> 00:30:53,294
course, as I've described before throughout this, is that we really

509
00:30:53,332 --> 00:30:57,274
want to dive into the how I can use it. How can I specifically

510
00:30:57,322 --> 00:31:01,386
dive in and started to take advantage of R two DBC

511
00:31:01,498 --> 00:31:05,490
for the relational databases that I'm using? Well, there are a variety of different

512
00:31:05,560 --> 00:31:09,966
R two DBC drivers, or some places call them connectors.

513
00:31:10,158 --> 00:31:13,586
Simply think of them as implementations of the R

514
00:31:13,608 --> 00:31:17,614
two DBC specification that's specific to whatever database

515
00:31:17,662 --> 00:31:21,554
or whatever vendor of relational storage happens to be communicated

516
00:31:21,602 --> 00:31:24,806
with. And there's a variety of them out there and there's even more in the

517
00:31:24,828 --> 00:31:29,270
works. But you can imagine distributed databases like cloud

518
00:31:29,340 --> 00:31:32,354
Spanner to using H two MySQL,

519
00:31:32,402 --> 00:31:35,414
Mariadb, Microsoft SQL Server and postgres.

520
00:31:35,462 --> 00:31:39,466
Right? The idea of this R two DBC specification is to provide a

521
00:31:39,488 --> 00:31:42,750
very broad standardized approach for running or

522
00:31:42,900 --> 00:31:46,586
managing reactive interactions with the underlying database.

523
00:31:46,698 --> 00:31:50,798
And I'm specifically going to take a look at how we can actually use

524
00:31:50,884 --> 00:31:54,318
the implementation from MariaDB. Now of course I mentioned that

525
00:31:54,324 --> 00:31:57,054
I am from Marie DB, but a lot of these drivers,

526
00:31:57,102 --> 00:32:00,498
especially at the highest level, are very similar, right. And that's the

527
00:32:00,504 --> 00:32:03,938
entire point of the R two DB specification, is to really tie together

528
00:32:04,024 --> 00:32:07,538
a lot of the things that relational databases all do. And the first thing that

529
00:32:07,544 --> 00:32:10,674
we can think about is this idea of being able to connect to the database.

530
00:32:10,722 --> 00:32:14,166
Of course we understand that it's going to take information like

531
00:32:14,188 --> 00:32:17,782
a location, right. The combination of a host address and a port number,

532
00:32:17,836 --> 00:32:21,590
right. So we can specify exactly where that database is. And then at

533
00:32:21,740 --> 00:32:25,286
the simplest level, then providing things like credentials. But of course there's

534
00:32:25,318 --> 00:32:28,426
other things that you can be able to add onto this, such as security and

535
00:32:28,448 --> 00:32:31,638
then limitation features as far as limiting timeouts

536
00:32:31,654 --> 00:32:34,494
and stuff like that. There's all kinds of things that we could add onto this

537
00:32:34,532 --> 00:32:37,966
and some of which may be vendor specific. But at the simplest case we

538
00:32:37,988 --> 00:32:41,130
can use this connection configuration implementation

539
00:32:41,210 --> 00:32:44,270
to be able to do that. Now as you can see here,

540
00:32:44,340 --> 00:32:47,922
it's proceeded with MariaDB and that really just tells you

541
00:32:47,976 --> 00:32:51,534
that the connection configuration which exists as can interface

542
00:32:51,582 --> 00:32:54,802
within r two DBC, we have an implementing class which is

543
00:32:54,856 --> 00:32:58,542
preceded by the name of the vendor. And that's pretty common for MariaDb,

544
00:32:58,606 --> 00:33:02,406
for Microsoft SQL Server, for MySQL these naming patterns are

545
00:33:02,428 --> 00:33:05,478
going to be pretty similar. And that's even more evident as we take

546
00:33:05,484 --> 00:33:08,486
a look at how we can take advantage of that configuration object which

547
00:33:08,508 --> 00:33:12,154
I created in the last slide to then be able to create an instance of

548
00:33:12,192 --> 00:33:16,246
the MariaDB connection factory object. And that connection

549
00:33:16,278 --> 00:33:19,866
factory implementation is really that just an implementation of

550
00:33:19,888 --> 00:33:23,326
the connection factory interface within RDBC can use that

551
00:33:23,348 --> 00:33:26,862
connection factory then to create or to get a hold of

552
00:33:26,916 --> 00:33:30,462
a connection. Now as I mentioned before, we would do this

553
00:33:30,516 --> 00:33:34,110
using reactive streams and this idea of first

554
00:33:34,180 --> 00:33:37,506
receiving back a publisher, which then at some undetermined amount

555
00:33:37,528 --> 00:33:41,346
of time is going to publish or send a connection object to us

556
00:33:41,368 --> 00:33:44,866
that we can then use. But in the case of some things such as a

557
00:33:44,888 --> 00:33:49,014
connection, when you create it or when you request it, you're most likely going to

558
00:33:49,052 --> 00:33:52,562
want to use that immediately. And so in some cases,

559
00:33:52,626 --> 00:33:55,814
very small cases, you actually do want to block and with

560
00:33:55,852 --> 00:33:58,834
the reactive streams specification implementation.

561
00:33:58,882 --> 00:34:02,390
So whatever that may be, in this case we're actually using project reactor.

562
00:34:02,470 --> 00:34:05,958
They come with different mechanisms that allow you to wait or to block

563
00:34:06,054 --> 00:34:09,750
that communication so we can actually wait for that connection object to be delivered.

564
00:34:09,830 --> 00:34:13,142
In this case we're using block and now we've got this co n in

565
00:34:13,216 --> 00:34:16,718
connection object and what that allows us to do

566
00:34:16,884 --> 00:34:20,590
once we have this. Now I understand I'm starting to

567
00:34:20,660 --> 00:34:24,574
incrementally add more code into each slide and that's really

568
00:34:24,612 --> 00:34:27,886
for a purpose which I'll get into a little bit later. But don't worry,

569
00:34:27,918 --> 00:34:31,442
we're not going to dive into the details of all of this. Just know that

570
00:34:31,496 --> 00:34:35,314
starting from the top, we're taking advantage of the connection object and then

571
00:34:35,352 --> 00:34:39,222
we're using the method of create statements to

572
00:34:39,356 --> 00:34:42,678
specify the SQL statement that we want to execute. And what that's going to

573
00:34:42,684 --> 00:34:46,162
do is it's going to return back a Mariadb statement

574
00:34:46,226 --> 00:34:49,814
implemented, right? So the statement class, Mariadb statement

575
00:34:49,862 --> 00:34:53,974
is a class and it's an implementation of the statement interface

576
00:34:54,022 --> 00:34:57,546
which exists in r two DBC. From there, that's where

577
00:34:57,568 --> 00:35:00,826
we can actually use that select statement object and be

578
00:35:00,848 --> 00:35:04,826
able to take advantage of the execute method. And that execute method

579
00:35:04,858 --> 00:35:08,174
is just returning us the publisher like I had said before.

580
00:35:08,292 --> 00:35:11,806
And of course from there, ultimately we need to subscribe to

581
00:35:11,828 --> 00:35:15,134
that. So at the very bottom you see that, okay, we're going to subscribe to

582
00:35:15,172 --> 00:35:18,446
this and it's going to give us whatever we've mapped,

583
00:35:18,478 --> 00:35:21,854
right. So in the middle there, there's some things that we've mapped and we've

584
00:35:21,902 --> 00:35:25,682
kind of parsed through some of the things like result and row object

585
00:35:25,736 --> 00:35:28,870
that I had sent before. But what's important about this is that

586
00:35:28,940 --> 00:35:32,002
we're using a reactive streams implementation,

587
00:35:32,066 --> 00:35:36,038
in this case that I mentioned before, project reactor, which basically

588
00:35:36,124 --> 00:35:41,102
will take our interface, our publisher interface of type Maredbresult,

589
00:35:41,186 --> 00:35:44,506
and it's going to kind of fill that out with flux. And Flux is an

590
00:35:44,528 --> 00:35:47,622
implementation of the publisher interface.

591
00:35:47,766 --> 00:35:51,178
And with that then we're able to do some things like map, right? We're going

592
00:35:51,184 --> 00:35:54,682
to take the data that exists in the database, we're going to do that fanciness

593
00:35:54,746 --> 00:35:58,234
to go ahead and map it to the Java data types

594
00:35:58,282 --> 00:36:02,174
and a Java object. In this case we have task and

595
00:36:02,292 --> 00:36:05,898
then whenever that's ready, the publisher is going to send that we've of course subscribed

596
00:36:05,914 --> 00:36:09,666
to it, and then we're going to do something with that task. Right the

597
00:36:09,688 --> 00:36:14,270
very bottom here. But got to say, that was a pretty simple implementation

598
00:36:14,350 --> 00:36:18,214
as we talk through the steps. But you and I, we all know that

599
00:36:18,332 --> 00:36:21,234
coming up with a new data access layer,

600
00:36:21,362 --> 00:36:25,206
having to persist or maintain objects and

601
00:36:25,228 --> 00:36:28,310
all of the steps in between that can be large.

602
00:36:28,380 --> 00:36:31,954
Which is why over the course of time, clients, right,

603
00:36:32,012 --> 00:36:35,274
libraries that have helped really abstract away a lot of

604
00:36:35,312 --> 00:36:39,114
those details have come into existence. And I hit on it a little bit

605
00:36:39,152 --> 00:36:42,330
earlier, but R two DBC was really designed with this in mind,

606
00:36:42,400 --> 00:36:45,726
right? It was kept really lightweight, not only for the vendor level,

607
00:36:45,828 --> 00:36:49,278
but so that the vendors could keep that as lightweight as they possibly can,

608
00:36:49,364 --> 00:36:53,146
but then still adhere to this specification that could then be used on a client

609
00:36:53,178 --> 00:36:56,574
level. And the client level is to create more humane

610
00:36:56,622 --> 00:37:00,274
or more opinionated APIs and ultimately create this

611
00:37:00,312 --> 00:37:03,682
level of abstraction or this layer of interactions that's going to handle things like

612
00:37:03,736 --> 00:37:07,634
creating the data access, right? So handling connection factories, handling the

613
00:37:07,672 --> 00:37:10,854
connections so that ultimately you can do what you need to do,

614
00:37:10,892 --> 00:37:14,130
which is that I want to execute query or several queries,

615
00:37:14,210 --> 00:37:17,638
and I want to put that into an object on my application side.

616
00:37:17,724 --> 00:37:20,278
I don't want to have to worry about a lot of the steps that kind

617
00:37:20,284 --> 00:37:23,526
of come in between that, such as the mapping and stuff that I showed before.

618
00:37:23,628 --> 00:37:26,566
And there's a lot of clients that already exist and there's a lot more in

619
00:37:26,588 --> 00:37:30,238
flight that have been validated as official RDBC clients. And the one that we're going

620
00:37:30,244 --> 00:37:33,514
to look at today is spring data R two DBC.

621
00:37:33,562 --> 00:37:36,366
So I'm going to jump into, right after this, I'm going to jump into a

622
00:37:36,388 --> 00:37:39,594
live demonstration where I'm going to show how we can take advantage

623
00:37:39,642 --> 00:37:42,974
of an R two DBC driver that's being used by the

624
00:37:43,012 --> 00:37:46,878
spring data R two DBC client. So you can just think of spring data if

625
00:37:46,884 --> 00:37:50,286
you haven't really used it, you can just think of it as, again, that abstraction

626
00:37:50,318 --> 00:37:53,474
that's going to help us create the data access layer and the data

627
00:37:53,512 --> 00:37:56,878
access and really persistence layer persisted objects that we can use

628
00:37:56,904 --> 00:38:00,374
within our application. And ultimately we're just going to communicate with

629
00:38:00,412 --> 00:38:03,218
that, with an application all the way to the database.

630
00:38:03,314 --> 00:38:06,342
So let's go ahead and get started.

631
00:38:06,476 --> 00:38:10,790
Within our demonstration, I am going to jump

632
00:38:10,870 --> 00:38:14,534
directly into an integrated development environment known

633
00:38:14,582 --> 00:38:18,330
as visual Studio code. It's a free,

634
00:38:18,480 --> 00:38:21,930
essentially code editor, right. And you can use it for things like compilation,

635
00:38:22,270 --> 00:38:25,386
but there's a variety of them out there, and a lot

636
00:38:25,408 --> 00:38:28,126
of them will work with the type of project that I'm going to show you.

637
00:38:28,148 --> 00:38:31,998
It's not necessarily important, but just so you know, I'm using visual studio code.

638
00:38:32,084 --> 00:38:35,890
And on the left hand side here you can see what is my solution explorer,

639
00:38:36,230 --> 00:38:40,130
which is going to show everything within my solution. And in this case I have

640
00:38:40,200 --> 00:38:43,780
a maven based project. So maven is

641
00:38:44,310 --> 00:38:47,846
a build management system essentially, right? So being able

642
00:38:47,868 --> 00:38:51,554
to specify things that you want to be able to build within what we're

643
00:38:51,602 --> 00:38:55,254
using as a Java application. Now, I've started by

644
00:38:55,292 --> 00:38:59,586
going to start spring IO to go ahead and generate

645
00:38:59,698 --> 00:39:03,358
this project. And really why I've done that is because I'm using spring,

646
00:39:03,474 --> 00:39:06,774
the spring framework. There's a lot of dependencies

647
00:39:06,822 --> 00:39:10,166
that come into play, and I don't want to go through the steps

648
00:39:10,198 --> 00:39:14,182
involved and kind of pinning all that together and individually bringing those dependencies

649
00:39:14,246 --> 00:39:17,626
in. And so I used a generator at start spring IO

650
00:39:17,738 --> 00:39:21,246
to create a spring boot project. Now, spring boot is something that you would

651
00:39:21,268 --> 00:39:24,238
traditionally use for something like an API. We're not going to do that. We're going

652
00:39:24,244 --> 00:39:27,266
to keep it much simpler than that. But really I wanted to be able to

653
00:39:27,288 --> 00:39:30,974
just very easily set up all the dependencies

654
00:39:31,022 --> 00:39:34,290
so I can take advantage of spring data r two DbC,

655
00:39:34,950 --> 00:39:38,520
which is the client, and then ultimately be able to take a look at

656
00:39:39,450 --> 00:39:42,306
the Mariadb R two DbC connector.

657
00:39:42,498 --> 00:39:46,006
And that really starts in a Maven project, right?

658
00:39:46,028 --> 00:39:49,770
A maven based project, looking at the project

659
00:39:49,920 --> 00:39:53,146
object model, which is this palm file and essentially the

660
00:39:53,168 --> 00:39:56,298
palm file, it basically just will indicate a bunch

661
00:39:56,304 --> 00:40:00,314
of things about your project as far as versioning, as far

662
00:40:00,352 --> 00:40:04,122
as different types of properties and different versioning numbers

663
00:40:04,176 --> 00:40:06,526
and stuff like that, that it'll use. Right. You can name the project, things like

664
00:40:06,548 --> 00:40:09,950
that. But what we want to key into really is this

665
00:40:10,020 --> 00:40:14,534
dependencies property. Inside of there we're defining the dependencies

666
00:40:14,602 --> 00:40:18,242
or essentially these binaries that we're pulling from something

667
00:40:18,296 --> 00:40:21,746
called the Maven central repository. Not really important other than

668
00:40:21,768 --> 00:40:24,962
the fact that we're taking these libraries, we're pulling them down,

669
00:40:25,096 --> 00:40:27,942
we're setting up all the dependencies that we need so that we can go write

670
00:40:27,996 --> 00:40:31,990
code. But what I want to point out is that inside of the project you

671
00:40:32,060 --> 00:40:35,730
obviously are going to pull down the spring

672
00:40:35,810 --> 00:40:39,574
data r two DbC binaries and then you simply need to

673
00:40:39,612 --> 00:40:43,218
pull down the Mariadb r two DBC connector.

674
00:40:43,314 --> 00:40:45,686
And then a couple of other things that I have in here. I mentioned spring

675
00:40:45,718 --> 00:40:48,394
boot, which we won't really be using, but it kind of helps set up this

676
00:40:48,432 --> 00:40:52,542
project. But then project Lombok, which basically just

677
00:40:52,596 --> 00:40:56,766
means that I'm lazy and I'm having Project Lombok kind

678
00:40:56,788 --> 00:41:00,014
of generate or handle some boilerplate code

679
00:41:00,052 --> 00:41:03,534
for me, some getters and setters and some classes which we'll see in here.

680
00:41:03,732 --> 00:41:07,522
Now let's go ahead and actually dive into the code

681
00:41:07,576 --> 00:41:11,378
of how we can use r two Dbc within a reactive application.

682
00:41:11,544 --> 00:41:14,900
Now of course, I've already created this application to kind of save some time.

683
00:41:15,350 --> 00:41:18,946
And this application is going to be run inside of a single file. And the

684
00:41:18,968 --> 00:41:21,986
way that we're going to do this is we're going to communicate with a database,

685
00:41:22,018 --> 00:41:25,346
which I've already set up using a docker container, which is the easiest

686
00:41:25,378 --> 00:41:27,826
way to really get started with a lot of these databases.

687
00:41:28,018 --> 00:41:31,622
And it just sits on my local host. So I'm just going to communicate using

688
00:41:31,676 --> 00:41:34,554
one hundred and twenty seven zero, zero, one. And I'm going to say,

689
00:41:34,592 --> 00:41:37,626
hey, I'm going to mess with a single table or I'm going to communicate with

690
00:41:37,648 --> 00:41:40,826
a single table. And I want to do this in a reactive fashion using r

691
00:41:40,848 --> 00:41:44,406
two DBC. And within this class I'm

692
00:41:44,438 --> 00:41:47,006
going to set up a couple of things to let me do that right.

693
00:41:47,028 --> 00:41:50,718
So within about 70 lines of code, we're going

694
00:41:50,724 --> 00:41:54,850
to go ahead and be able to set up everything that we need to show

695
00:41:55,000 --> 00:41:58,626
several different types of interactions with the database using r

696
00:41:58,648 --> 00:42:02,674
two DBC. Now as we dive into this application,

697
00:42:02,792 --> 00:42:06,210
something that I want to point out is that I have a main method here

698
00:42:06,280 --> 00:42:09,942
and I've done some things so that I can take advantage of the running application

699
00:42:10,076 --> 00:42:13,894
itself. And really ultimately why I've done this is

700
00:42:13,932 --> 00:42:17,206
so that at the bottom here. So when you run an application, it's going to

701
00:42:17,228 --> 00:42:21,654
run and then it's going to be done. But because we're using asynchronous

702
00:42:21,782 --> 00:42:25,370
data streams, these activities from publishers and subscribers,

703
00:42:25,790 --> 00:42:28,966
the application may finish before we're actually done processing

704
00:42:28,998 --> 00:42:31,386
the information. And so we might not be able to see anything in the output.

705
00:42:31,418 --> 00:42:37,066
So at the end of this I'm basically just preventing

706
00:42:37,098 --> 00:42:41,050
the application from exiting so that we can within the console output,

707
00:42:41,130 --> 00:42:45,294
see exactly what's happening. And I think that's the easiest way to really get our

708
00:42:45,332 --> 00:42:48,802
feelers or kind of get a sense of what R two DBC is doing

709
00:42:48,856 --> 00:42:52,126
and how we can use it. And then of course we can expand well beyond

710
00:42:52,158 --> 00:42:55,850
that. And of course you wouldn't just keep your application open indefinitely,

711
00:42:56,030 --> 00:42:59,862
but this will give us a good starting point. So first

712
00:42:59,916 --> 00:43:03,186
and foremost, when we come into an application, especially a spring

713
00:43:03,218 --> 00:43:07,602
application, we want to dive into application properties.

714
00:43:07,666 --> 00:43:10,986
Now this application properties file is going to

715
00:43:11,008 --> 00:43:14,906
allow us to take advantage of some of the configuration that

716
00:43:14,928 --> 00:43:18,634
exists in spring, specifically in spring r two DBc that allow

717
00:43:18,672 --> 00:43:22,550
us to specify things like the URL, the username

718
00:43:22,630 --> 00:43:25,600
and the password. Now in the instance of time,

719
00:43:26,050 --> 00:43:29,614
I'm going to go ahead and paste some of these things in here because

720
00:43:29,652 --> 00:43:32,894
it's going to be a lot faster than me kind of fat fingering the code

721
00:43:33,092 --> 00:43:36,386
and then probably not having anything that can compile at the

722
00:43:36,408 --> 00:43:39,634
end. But I will explain everything as I go through it.

723
00:43:39,672 --> 00:43:43,940
Now what I'm going to do first is I'm going to paste in

724
00:43:45,590 --> 00:43:49,394
the information that allows us to connect to our underlying database.

725
00:43:49,442 --> 00:43:53,014
Now was I kind of dove into before? The first

726
00:43:53,052 --> 00:43:56,758
part of that is really establishing an R two DBC URL or the

727
00:43:56,764 --> 00:43:59,770
URL that's parsed within the R two DBC specification.

728
00:44:00,350 --> 00:44:03,674
Of course that starts with your scheme. Then you can specify the

729
00:44:03,712 --> 00:44:07,434
driver. In this case I'm using Mariadb. I'm going to

730
00:44:07,472 --> 00:44:10,990
indicate that I am using localhost on port 33

731
00:44:11,060 --> 00:44:14,830
six, and my default database is just called to do right

732
00:44:14,900 --> 00:44:18,398
inside of our database, which I'll bring up here in a

733
00:44:18,404 --> 00:44:21,982
console application. Very simply here

734
00:44:22,116 --> 00:44:25,742
I have one table that exists inside

735
00:44:25,796 --> 00:44:29,150
of this to do database. The table is just called task

736
00:44:29,230 --> 00:44:32,238
and it contains, as you'd imagine, a list of tasks.

737
00:44:32,334 --> 00:44:35,106
Now of course this is very simple, but it's meant to be that way so

738
00:44:35,128 --> 00:44:38,510
that we can establish a very clear example here. And it's already been

739
00:44:38,600 --> 00:44:42,210
preloaded with a couple of pieces of information which will help us in the demonstration

740
00:44:42,290 --> 00:44:45,702
to come. But know that this table exists within a local

741
00:44:45,756 --> 00:44:49,494
database on my machine. Now to get to or

742
00:44:49,532 --> 00:44:53,014
to gain access to this. Then I provide the username and the password

743
00:44:53,062 --> 00:44:56,730
all within this application properties file. That's that.

744
00:44:56,800 --> 00:45:00,330
So we've saved and we're going to go back to our demo application

745
00:45:00,480 --> 00:45:03,878
because now it's time for us to start writing the code that we can

746
00:45:03,904 --> 00:45:07,050
use to actually integrate and communicate with the database.

747
00:45:07,210 --> 00:45:10,206
So again, I'm going to paste some things in here, but I will explain these

748
00:45:10,228 --> 00:45:13,914
along the way. Now, if we want to think about communicating

749
00:45:13,962 --> 00:45:17,266
with a database, and I mentioned it before, we want to think about how we

750
00:45:17,288 --> 00:45:20,658
can persist those things on the application side. And the first thing that

751
00:45:20,664 --> 00:45:24,594
we're going to do then is create a class that mimics or

752
00:45:24,632 --> 00:45:28,322
that matches the task table that exists inside

753
00:45:28,376 --> 00:45:31,046
of our database. Now you don't have to do this and it can be much

754
00:45:31,068 --> 00:45:34,166
more complex, but this is a very simple application and as

755
00:45:34,188 --> 00:45:38,022
I saw before, I have an id field, I have a

756
00:45:38,076 --> 00:45:41,414
description and I have completed those all match to the table that exists

757
00:45:41,462 --> 00:45:45,594
inside of my database. But there's a couple of annotations here which

758
00:45:45,712 --> 00:45:49,450
are useful to know. One is this idea of data,

759
00:45:49,520 --> 00:45:53,418
and this is coming from that project Lombok that I mentioned before, which is allowing

760
00:45:53,434 --> 00:45:57,134
me to go ahead and basically have

761
00:45:57,172 --> 00:45:59,998
it build out the things like the getters and setters so I don't have to

762
00:46:00,004 --> 00:46:03,578
do those things. I've got some argument requirements

763
00:46:03,674 --> 00:46:07,346
as far as being able to require arguments within the constructor whenever I

764
00:46:07,368 --> 00:46:10,946
create a new object. And then most importantly here we

765
00:46:10,968 --> 00:46:14,706
have this annotation of a table which is then setting up

766
00:46:14,808 --> 00:46:18,614
the relationship really between this class of task to

767
00:46:18,652 --> 00:46:22,290
the task table which exists inside of my MariadB

768
00:46:22,370 --> 00:46:26,482
database or to do database. And then I've got some annotations

769
00:46:26,546 --> 00:46:30,154
which basically describe a primary key and the fact that a

770
00:46:30,192 --> 00:46:33,482
particular property cannot be null, right.

771
00:46:33,536 --> 00:46:37,242
Things that are important for this so that I don't accidentally enter

772
00:46:37,296 --> 00:46:41,018
a null object and we get an error. Now that is,

773
00:46:41,184 --> 00:46:44,814
we've appropriately mapped, or we're setting up the persistence of

774
00:46:44,852 --> 00:46:48,266
being able to take information from the to do or the task

775
00:46:48,298 --> 00:46:51,566
table and put it into this task object. Next,

776
00:46:51,748 --> 00:46:55,166
when we're using r two DBC or spring

777
00:46:55,198 --> 00:46:58,770
data, r two DBC, we really want to take advantage of

778
00:46:58,920 --> 00:47:02,926
this idea of repository. And a repository allows

779
00:47:02,958 --> 00:47:06,766
us then to be able to communicate in a very simple way

780
00:47:06,888 --> 00:47:10,886
to a repository of information underneath which

781
00:47:10,908 --> 00:47:14,930
in this case is actually going to be tied directly to our task table.

782
00:47:15,090 --> 00:47:18,822
And I'm doing this by using something that's already provided within spring data

783
00:47:18,876 --> 00:47:23,318
RDBC which is called the reactive crud repository interface.

784
00:47:23,414 --> 00:47:26,646
And this interface is just allowing basic

785
00:47:26,678 --> 00:47:30,714
crud or it facilitates basic crud operations, right? So everything from

786
00:47:30,752 --> 00:47:34,046
being able to insert, create, or so create,

787
00:47:34,228 --> 00:47:37,386
read, update and delete, right? Just the crud

788
00:47:37,418 --> 00:47:40,574
acronym, if you will. And all I have to do really

789
00:47:40,612 --> 00:47:44,478
is specify that I am going to be using a task object which

790
00:47:44,484 --> 00:47:48,402
I had previously mapped right through that annotation of table, and that

791
00:47:48,456 --> 00:47:51,842
the primary key is an integer, right. For that id.

792
00:47:51,976 --> 00:47:55,298
Now that's all I need to do. Now I've actually set up

793
00:47:55,304 --> 00:47:59,240
the communication directly between my application and

794
00:48:00,250 --> 00:48:03,798
the table that exists inside of my database. And I've done all of this through

795
00:48:03,884 --> 00:48:07,142
the application property settings that I just added in. And then now

796
00:48:07,196 --> 00:48:10,482
through the task repository, which uses the fullyreactive crudpository

797
00:48:10,626 --> 00:48:14,090
and the task class. Go ahead and save

798
00:48:14,160 --> 00:48:18,074
here. Now I want to add in a couple of bits here. Now a couple

799
00:48:18,112 --> 00:48:22,250
of things that I'm going to add in are going to be, for instance,

800
00:48:22,590 --> 00:48:25,994
I want to go ahead and do something called auto wiring,

801
00:48:26,122 --> 00:48:29,738
and this is using something called inversion of control and dependency injection,

802
00:48:29,834 --> 00:48:33,102
which allow me then to just create an instance of

803
00:48:33,156 --> 00:48:37,394
my task repository that I can then use to

804
00:48:37,432 --> 00:48:41,518
be able to execute those crud or those simple methods

805
00:48:41,694 --> 00:48:44,834
to be able to do things like read and write information to the

806
00:48:44,872 --> 00:48:48,574
underlying task table. I'm kind of obfuscating

807
00:48:48,622 --> 00:48:52,518
away some of the details there, but certainly look that up if

808
00:48:52,524 --> 00:48:55,718
you're not as familiar. But ultimately we just want to be able to get information

809
00:48:55,804 --> 00:48:59,450
from our database. Now after I've auto wired up that

810
00:48:59,600 --> 00:49:03,034
repository, next I want to add in a couple of

811
00:49:03,152 --> 00:49:06,954
methods that I've really built that I can take advantage of

812
00:49:06,992 --> 00:49:10,954
within side of this demo application, right, the ability to

813
00:49:11,072 --> 00:49:14,854
save a task and the ability to get a collection of tasks.

814
00:49:14,902 --> 00:49:17,166
So, right, I want to create a new task and then I want to be

815
00:49:17,188 --> 00:49:21,098
able to display or retrieve those and then display those in the output.

816
00:49:21,274 --> 00:49:25,220
And as you can see, I'm actually taking advantage of the

817
00:49:25,590 --> 00:49:29,330
task repository instance that I previously established,

818
00:49:29,750 --> 00:49:33,486
and it's returning monotask and flux

819
00:49:33,518 --> 00:49:37,310
tasks. Now I already mentioned Flux, which is an implementation

820
00:49:37,390 --> 00:49:40,662
of a publisher that specifically exists within

821
00:49:40,716 --> 00:49:42,950
side of the project reactor library.

822
00:49:43,610 --> 00:49:47,414
Flux returns zero to many objects, mono returns zero

823
00:49:47,452 --> 00:49:50,394
to one. That's really all you need to know at this point. But those are

824
00:49:50,432 --> 00:49:53,926
essentially implemented publishers from reactive

825
00:49:53,958 --> 00:49:57,082
streams. Now I'm going to very

826
00:49:57,136 --> 00:50:01,434
quickly show how I can take

827
00:50:01,472 --> 00:50:05,502
advantage of both of those methods, right, so as I mentioned before,

828
00:50:05,556 --> 00:50:08,714
I have four previously existing tasks. It's kind of like a magic trick.

829
00:50:08,762 --> 00:50:12,126
Here we go. I've got four tasks inside of my table. What I'm going

830
00:50:12,148 --> 00:50:15,410
to do now is I'm going to create a new task using the task object

831
00:50:15,480 --> 00:50:19,058
that I created on the bottom of the screen, the task class. And I want

832
00:50:19,064 --> 00:50:23,006
to implemented the only non

833
00:50:23,038 --> 00:50:26,574
null property that I described within the constructor, which is description.

834
00:50:26,622 --> 00:50:29,606
And I want to give it a new description of task five. I then want

835
00:50:29,628 --> 00:50:33,526
to execute using demo application or the instance of demo application to

836
00:50:33,548 --> 00:50:36,150
save the task. I'm going to subscribe to it,

837
00:50:36,220 --> 00:50:39,574
right? And then it's going to output the result. Then I

838
00:50:39,612 --> 00:50:43,098
want to output the results of all of the tasks. So I just want to

839
00:50:43,104 --> 00:50:46,154
be able to read very simple things that you'd be able to do really in

840
00:50:46,192 --> 00:50:50,066
any driver, any connector not necessarily specific to r two DBC.

841
00:50:50,198 --> 00:51:01,820
So let's go ahead and execute save

842
00:51:01,890 --> 00:51:02,510
here.

843
00:51:05,520 --> 00:51:06,590
Let's see.

844
00:51:07,840 --> 00:51:11,632
Okay, well, let's clear this

845
00:51:11,686 --> 00:51:15,244
really quick and let's just go ahead and rerun

846
00:51:15,292 --> 00:51:18,720
this. I might have had a previously running implementation.

847
00:51:19,940 --> 00:51:23,504
Well, I've obviously missed something, but it looks like I got about

848
00:51:23,542 --> 00:51:27,668
three minutes left. So I'm just going to pull over my other

849
00:51:27,754 --> 00:51:31,220
application. I promise this has worked in the past, but again,

850
00:51:31,290 --> 00:51:35,224
I always tend to find a way to do this. But what

851
00:51:35,262 --> 00:51:39,476
I want to do here and what is actually executed, then I'll

852
00:51:39,508 --> 00:51:43,384
see here inside of the output is

853
00:51:43,422 --> 00:51:47,772
that I have been able then to create

854
00:51:47,906 --> 00:51:51,592
a task five. So that first insert

855
00:51:51,656 --> 00:51:55,292
right, it's going to return through the publisher right here

856
00:51:55,346 --> 00:51:58,852
or through the subscription of that original save publisher,

857
00:51:59,016 --> 00:52:01,090
the ability to return task five.

858
00:52:02,260 --> 00:52:06,128
Then I just simply want to be able to read everything

859
00:52:06,214 --> 00:52:08,240
that exists within that table.

860
00:52:09,540 --> 00:52:13,088
After that, the plan was to go ahead

861
00:52:13,174 --> 00:52:17,056
and jump into how you can use back pressure

862
00:52:17,168 --> 00:52:21,184
to be able to actually modify the way that the subscriber communicates

863
00:52:21,232 --> 00:52:23,908
with the publisher was far as how it's requesting information.

864
00:52:24,074 --> 00:52:27,064
So I've kind of ruined the surprise here, but I want to show you how

865
00:52:27,102 --> 00:52:30,920
easily that's done. Simply using the demo

866
00:52:30,990 --> 00:52:34,516
application instance that I had created before, and again using git task,

867
00:52:34,548 --> 00:52:38,492
which is the method that I had previously created, I basically just

868
00:52:38,546 --> 00:52:41,788
want to create a custom subscriber. And within sight of

869
00:52:41,794 --> 00:52:45,384
that, if we remember back to the subscriber interface

870
00:52:45,432 --> 00:52:49,330
that exists inside of reactive streams, we can remember that

871
00:52:49,860 --> 00:52:53,244
we had a variety of different things that we could do to take advantage

872
00:52:53,292 --> 00:52:56,896
of the data streams. Anatomical features such

873
00:52:56,918 --> 00:53:01,436
as being able to listen to on subscribe methods

874
00:53:01,468 --> 00:53:05,284
that are all overridden here. Being able to understand when the next element or

875
00:53:05,322 --> 00:53:09,380
the next task in this case was actually sent over from the publisher,

876
00:53:09,880 --> 00:53:13,284
being able to determine if an error or an exception had happened and being

877
00:53:13,322 --> 00:53:16,996
able to see if it's complete. Now, primarily what we want to look

878
00:53:17,018 --> 00:53:20,824
at here is the ability that on next we want to control through back

879
00:53:20,862 --> 00:53:23,976
pressure the amount of information that's sent. And the

880
00:53:23,998 --> 00:53:28,168
way that I've done this is very simple, where I've essentially just determined

881
00:53:28,344 --> 00:53:31,580
through an integer, a variable here within

882
00:53:31,650 --> 00:53:35,470
side of this class to say, okay, I want to receive two at a time,

883
00:53:35,840 --> 00:53:39,900
and then using modular division on two, I basically

884
00:53:39,970 --> 00:53:43,676
just saying that every time I just want to request two pieces

885
00:53:43,708 --> 00:53:47,516
of information, and when I've done that and I've incremented that I've received

886
00:53:47,548 --> 00:53:51,168
two, then and only then am I going to request again.

887
00:53:51,254 --> 00:53:55,136
Right? So every two times I'm going to request that and I've

888
00:53:55,168 --> 00:53:58,260
added some print statements in order to be able to eliminate that.

889
00:53:58,410 --> 00:54:01,956
Now, inside of our application we

890
00:54:01,978 --> 00:54:05,544
can see that if we start here, we can see that

891
00:54:05,662 --> 00:54:09,812
when I were to run this, I'm actually then receiving

892
00:54:09,956 --> 00:54:13,176
two pieces of information or two tasks that

893
00:54:13,198 --> 00:54:16,344
I can print out, and then I'm printing those then

894
00:54:16,382 --> 00:54:20,220
and only then I request two more pieces of information or two more elements

895
00:54:20,880 --> 00:54:24,556
until the publisher can send everything that it has. So in

896
00:54:24,578 --> 00:54:28,028
this instance we have five records that exist within that

897
00:54:28,114 --> 00:54:32,204
task table. And so at the end I've requested two, but the publisher

898
00:54:32,252 --> 00:54:35,490
can really only provide one and the process is complete.

899
00:54:35,860 --> 00:54:40,240
And that concludes the demonstration on reactive

900
00:54:40,980 --> 00:54:44,740
streams. I'm going to go ahead and put this last bit

901
00:54:44,810 --> 00:54:48,452
up here because I just want to point out that if you happen to have

902
00:54:48,586 --> 00:54:52,352
an interest in contributing to the r two DBC specification,

903
00:54:52,496 --> 00:54:55,876
please go and visit RDBC IO. It is

904
00:54:55,898 --> 00:54:59,492
now a part of the reactive foundation, so it's getting quite a bit of momentum

905
00:54:59,556 --> 00:55:03,128
and it's expected to be completely GA or version one

906
00:55:03,214 --> 00:55:07,332
this year, so 2021. If you'd like to see more implementation examples,

907
00:55:07,476 --> 00:55:10,888
please go and check out mariadb.com developers. There's a bunch

908
00:55:10,904 --> 00:55:14,840
of open source free examples for getting started with R two DBC

909
00:55:14,920 --> 00:55:18,428
using completely free instances of a database. So you can

910
00:55:18,434 --> 00:55:22,044
jump in there. If you'd like to check out the driver code for mariadb R

911
00:55:22,082 --> 00:55:25,740
two DBC, you can check that out on GitHub as well. I am actually

912
00:55:25,810 --> 00:55:29,036
writing, or I've written a book and it's due to be published in April on

913
00:55:29,058 --> 00:55:32,544
R two DBC. It's the first book on RT DBC called R two DBC

914
00:55:32,592 --> 00:55:36,516
revealed. So if you're really interested in it and really want to dive into how

915
00:55:36,538 --> 00:55:40,032
R two DBC has come together and how you can use it within your applications,

916
00:55:40,096 --> 00:55:43,476
please check out that book that's coming out in April. And again, please feel free

917
00:55:43,498 --> 00:55:47,184
to reach out to me at robh@mariadb.com at probably real Rob

918
00:55:47,232 --> 00:55:50,436
and rhetchpath on GitHub. Thank you very much and I hope you enjoy the rest

919
00:55:50,458 --> 00:55:51,650
of the conference. Have a great day.

