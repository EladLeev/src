1
00:00:41,170 --> 00:00:44,582
Hey folks, welcome. Let's talk about container security. But before

2
00:00:44,636 --> 00:00:47,714
going into that, we need to talk about containers.

3
00:00:47,842 --> 00:00:51,406
What is a container? If you look at the real world, your day to

4
00:00:51,428 --> 00:00:55,406
day life, a container is something that holds something else. It holds a receptible or

5
00:00:55,428 --> 00:00:58,858
a good, like your soda can or the airtight container

6
00:00:58,874 --> 00:01:02,330
to put your food in. And basically what you're trying to do is making sure

7
00:01:02,420 --> 00:01:06,222
that the outside world cannot influence the containment

8
00:01:06,286 --> 00:01:10,238
that's inside. One thing is you need to pick your container correctly.

9
00:01:10,334 --> 00:01:14,206
However, if you translate that concept into software,

10
00:01:14,318 --> 00:01:18,054
people think in many cases that if you put an application into

11
00:01:18,092 --> 00:01:22,418
a container, that by default it is safe from outside vulnerabilities,

12
00:01:22,514 --> 00:01:25,894
the threats from in the outside world. Unfortunately, this is not

13
00:01:25,932 --> 00:01:29,430
true. And that's why we are going to, or I am going to show you

14
00:01:29,500 --> 00:01:32,826
what you can do to build safe containers. One thing you

15
00:01:32,848 --> 00:01:36,326
have to keep in mind is that if you look at a container

16
00:01:36,358 --> 00:01:39,722
in real life, it's a protective barrier around

17
00:01:39,776 --> 00:01:43,298
the good, to protect the goods from the outside influence.

18
00:01:43,414 --> 00:01:47,182
However, if you look at software, it's more or less we need two way

19
00:01:47,236 --> 00:01:51,246
traffic. We need to get outside of the container, for instance, having a

20
00:01:51,268 --> 00:01:54,814
UI towards any user, or you need to connect to

21
00:01:54,852 --> 00:01:58,258
it with a database connection or a request or something like that.

22
00:01:58,344 --> 00:02:01,234
So it is different and we need to cope with that.

23
00:02:01,352 --> 00:02:04,702
But first, my name is Brian Vermeer. I'm a developer advocate for sneak.

24
00:02:04,766 --> 00:02:08,322
I am a Java developer by trade. Currently I'm a Java champion.

25
00:02:08,386 --> 00:02:11,702
I do a lot of stuff in the community and I love

26
00:02:11,756 --> 00:02:15,554
that. But today we are going to talk about securing containers

27
00:02:15,602 --> 00:02:19,654
and specifically Docker containers. Because Docker is the most

28
00:02:19,772 --> 00:02:22,966
used, well known way to create containers.

29
00:02:23,078 --> 00:02:26,394
It is not the only way, I know that. But there are a lot of

30
00:02:26,512 --> 00:02:30,122
downloads of docker containers from Docker hub and people create

31
00:02:30,176 --> 00:02:34,666
their containers based on that. So today we

32
00:02:34,688 --> 00:02:37,822
can more or less say this is a best practice session on Docker image security.

33
00:02:37,956 --> 00:02:41,614
Let's get into first, the first addition to the first tip I can

34
00:02:41,652 --> 00:02:45,506
give you that is prefer a minimal base image. If you

35
00:02:45,528 --> 00:02:49,026
look at how we build docker images, we build

36
00:02:49,048 --> 00:02:52,930
that in a file, a Docker file. And normally you start with from

37
00:02:53,000 --> 00:02:56,862
something. And that from something is say from Ubuntu

38
00:02:56,926 --> 00:03:00,558
or from Debian or from node. You build

39
00:03:00,664 --> 00:03:03,906
your application on top of an existing image that you probably download

40
00:03:03,938 --> 00:03:07,222
from Docker Hub. Last year we did a research, oh well,

41
00:03:07,356 --> 00:03:10,986
late 2019, we did a research on the top ten

42
00:03:11,168 --> 00:03:14,486
free docker images that you could use, that you could download from Docker

43
00:03:14,518 --> 00:03:17,978
Hub and we tested them for known vulnerabilities inside

44
00:03:18,064 --> 00:03:22,134
the images and this was the result. All ten images had

45
00:03:22,192 --> 00:03:25,614
vulnerabilities by default, although most of them are well

46
00:03:25,652 --> 00:03:29,290
known images, well maintained images, images that might be certified

47
00:03:29,370 --> 00:03:33,102
in some way or recognized by Docker or whatever you might call it.

48
00:03:33,236 --> 00:03:36,802
Looking at each and every one of these images and well

49
00:03:36,856 --> 00:03:40,562
take specifically a node images, a lot of vulnerabilities come in your

50
00:03:40,616 --> 00:03:44,530
application if you just use this image. What we did in this research was

51
00:03:44,600 --> 00:03:48,238
we took these images without any specific tag.

52
00:03:48,334 --> 00:03:52,018
So basically that means at that point in time we took the latest image.

53
00:03:52,114 --> 00:03:55,526
A lot of people do that and build their image that way. That means that

54
00:03:55,548 --> 00:03:59,106
if I do this today there will probably be a slightly different scale.

55
00:03:59,218 --> 00:04:02,826
Moreover, the importance is that the latest image might not be

56
00:04:02,848 --> 00:04:06,058
the best image. For instance, if you took the node image and you look at

57
00:04:06,064 --> 00:04:09,770
the node image closely, that node image is node JS built

58
00:04:09,840 --> 00:04:13,950
on top of something else, on top of a full blown operating system

59
00:04:14,020 --> 00:04:16,766
called Debian Jesse at that point in time.

60
00:04:16,868 --> 00:04:20,810
So that means everything that comes from that layer of abstraction,

61
00:04:20,890 --> 00:04:24,314
the full blown debian operating system plus the node

62
00:04:24,362 --> 00:04:28,382
image and then your stuff comes on top of that. So it's layered

63
00:04:28,446 --> 00:04:32,290
and then you have to think about that and think of yourself. Do I actually

64
00:04:32,360 --> 00:04:35,938
need a full blown operating system to

65
00:04:36,104 --> 00:04:39,350
build my tiny little rest servers on? Probably not.

66
00:04:39,500 --> 00:04:43,062
If we take this any further and we look at a full operating system because

67
00:04:43,116 --> 00:04:47,094
most images are built on top of can operating system layer, we see

68
00:04:47,132 --> 00:04:50,666
that there are a lot of differences between different operating systems. If you

69
00:04:50,688 --> 00:04:54,598
take Debian, for instance, you might use Debian fully,

70
00:04:54,694 --> 00:04:58,074
but probably not. If you convert to a Debian slim image instead

71
00:04:58,112 --> 00:05:01,926
of the normal debian image, you already well remediated

72
00:05:01,958 --> 00:05:06,000
a bunch of vulnerabilities. You have less stuff in your image so

73
00:05:06,370 --> 00:05:09,950
that will not harm you. If you go any further to the right on

74
00:05:10,020 --> 00:05:13,786
this image, you see that things like Ubuntu or fedora

75
00:05:13,818 --> 00:05:17,886
or even alpine may help you remediate a lot of threats. So choosing

76
00:05:17,918 --> 00:05:21,314
your image correctly, your base image, your foundation of

77
00:05:21,352 --> 00:05:24,914
your docker container is crucial. Think about it.

78
00:05:24,952 --> 00:05:28,902
Do I need every single binary and every single library that

79
00:05:28,956 --> 00:05:32,326
comes with a full blown operating system? Do I need that for

80
00:05:32,348 --> 00:05:35,986
my application? Probably not. And in many cases things like fedora

81
00:05:36,018 --> 00:05:39,906
or alpine even might be suitable enough. If I translate

82
00:05:39,938 --> 00:05:44,038
it to for instance Java image like here and I'm using OpenJDk eleven.

83
00:05:44,134 --> 00:05:47,962
If I do the latest image, the latest image is bound to the

84
00:05:48,016 --> 00:05:51,674
Ubuntu version of this image. And that had at the point where

85
00:05:51,712 --> 00:05:55,226
I tested it, and that's a couple of months ago, was 25 known

86
00:05:55,258 --> 00:05:59,086
vulnerabilities in Ubuntu, not so much in OpenJDK. If I choose

87
00:05:59,108 --> 00:06:02,814
a Debian version, which I can, which is a far far bigger one, it gives

88
00:06:02,852 --> 00:06:07,022
me a lot of more vulnerabilities but also a lot of more unused binaries

89
00:06:07,086 --> 00:06:11,154
in my case. Therefore, in some cases it would be wise to use Alpine to

90
00:06:11,192 --> 00:06:14,382
look at this from can architectural perspective from the beginning.

91
00:06:14,526 --> 00:06:18,598
Which choice do I make for my base image is a valid one because

92
00:06:18,684 --> 00:06:22,646
Linux operating system vulnerabilities, they steadily increase. If you

93
00:06:22,668 --> 00:06:26,066
see over time how this increases between the different sorts

94
00:06:26,098 --> 00:06:29,474
of operating systems. You see that debian for instance,

95
00:06:29,522 --> 00:06:32,842
in this case is the winner. But that doesn't mean

96
00:06:32,976 --> 00:06:36,294
you need to use it. Maybe you do, maybe you don't. But make a conscious

97
00:06:36,342 --> 00:06:39,994
choice. Make sure that you only use the stuff that you need,

98
00:06:40,112 --> 00:06:43,686
because what you do not have in your container cannot

99
00:06:43,718 --> 00:06:47,214
harm you. Let's go to the second option. And the second thing that

100
00:06:47,252 --> 00:06:50,906
I want to show you is the least privileged principle and the least privileged user

101
00:06:50,938 --> 00:06:54,862
in this case because think about it, the least privileged principle basically says

102
00:06:54,916 --> 00:06:58,034
that you can only do what needs to be done,

103
00:06:58,152 --> 00:07:01,326
nothing more, nothing less. For instance, if I come to the doctor,

104
00:07:01,438 --> 00:07:04,850
I want to make sure that my doctor knows what my medical history is.

105
00:07:04,920 --> 00:07:08,014
That doesn't mean that every doctor in the hospital and every nurse in the hospital

106
00:07:08,062 --> 00:07:11,346
needs to know what my medical history is. Moreover, if he wants to operate

107
00:07:11,378 --> 00:07:14,706
on my nose, he doesn't need to know what my shoe size is because that's

108
00:07:14,738 --> 00:07:18,630
irrelevant. Make sure that you act the same way with

109
00:07:18,700 --> 00:07:22,134
users and applications. If you run a docker

110
00:07:22,182 --> 00:07:25,706
image straight away, or you write a docker file and you just

111
00:07:25,728 --> 00:07:29,114
run the application within your docker image straight away, you run

112
00:07:29,152 --> 00:07:32,582
it by default as root. Is that necessary?

113
00:07:32,726 --> 00:07:36,142
Probably not. So the best thing you can do is create

114
00:07:36,196 --> 00:07:39,822
a specific user for that. Create a specific user with only

115
00:07:39,876 --> 00:07:43,294
the provides it needs and we can do it something like this.

116
00:07:43,412 --> 00:07:46,494
I'm creating an image based on Ubuntu. Run my stuff

117
00:07:46,532 --> 00:07:50,194
on that and oh, let me just outline the stuff that is important because these

118
00:07:50,232 --> 00:07:53,954
three lines are important. In this case I create a specific

119
00:07:54,152 --> 00:07:58,130
user and a specific user group for it. It's a system user

120
00:07:58,210 --> 00:08:01,446
without a password, without the home directory, without shell access,

121
00:08:01,548 --> 00:08:05,474
and I couple it to the group I created in the second yellow

122
00:08:05,522 --> 00:08:09,206
line line I give it the ownership of

123
00:08:09,228 --> 00:08:12,522
my application folder because that's what I need. I only need

124
00:08:12,576 --> 00:08:15,946
the privileges on that folder. In the third line that

125
00:08:15,968 --> 00:08:19,482
I marked over here, you see that I call the user because I can create

126
00:08:19,536 --> 00:08:22,646
a user and I can give it privileges. But if I now call the user

127
00:08:22,678 --> 00:08:25,966
and use that user I created, it will not do anything and it will still

128
00:08:25,988 --> 00:08:29,774
run as root. If I do it like this, then every command afterwards will

129
00:08:29,812 --> 00:08:33,454
be executed by the user I created it. So now you see

130
00:08:33,492 --> 00:08:37,086
that by doing a few more lines you add a new user

131
00:08:37,118 --> 00:08:41,026
with limited privileges. And that might make

132
00:08:41,048 --> 00:08:44,994
sure that your scope is smaller than it was. Because think about security

133
00:08:45,112 --> 00:08:48,978
like this. Security is always a chain of attacks. If something happens

134
00:08:49,144 --> 00:08:53,078
and that thing like you can enter an application or a

135
00:08:53,084 --> 00:08:56,614
container. In this case, if there's something wrong inside your

136
00:08:56,652 --> 00:09:00,166
application or container, we can connect from one step to another step to

137
00:09:00,188 --> 00:09:02,678
another step. And you can make it worse and worse and worse and worse.

138
00:09:02,774 --> 00:09:06,106
So make sure that in every level or every stage that you

139
00:09:06,128 --> 00:09:10,278
can apply secure practices. You should do that to prevent

140
00:09:10,374 --> 00:09:14,362
if something is happening that it gets blown up in your face.

141
00:09:14,496 --> 00:09:18,058
Also think about the image you're using. I'm now using an Ubuntu image,

142
00:09:18,074 --> 00:09:20,606
but if I use for instance a node image, and this is can example from

143
00:09:20,628 --> 00:09:24,880
node ten, the node images come with a specific user already

144
00:09:25,330 --> 00:09:29,218
the node user. If I'm not aware of that and not

145
00:09:29,304 --> 00:09:32,974
doing this like the underlined line over here, I'm just using the root

146
00:09:33,022 --> 00:09:36,274
user. But if I call that node user because it's already there

147
00:09:36,312 --> 00:09:39,730
and has limited privileges, I can use it. But you need to call it

148
00:09:39,800 --> 00:09:42,758
before you execute the command that you want to come out. What do you want

149
00:09:42,764 --> 00:09:46,118
to do? So be aware of that and find out if your base image or

150
00:09:46,124 --> 00:09:49,594
the image that you're using already contains a user that you can use for this

151
00:09:49,632 --> 00:09:53,114
instead of creating it. If not, you can recreate it yourself.

152
00:09:53,312 --> 00:09:56,790
Next one, finding, fixing and monitoring open source vulnerabilities

153
00:09:56,870 --> 00:10:00,614
in your operating system. Because I told you things like operating

154
00:10:00,662 --> 00:10:04,618
systems already. We talked about that in the beginning of picking your base image.

155
00:10:04,714 --> 00:10:07,886
But even if you look at build packs like this, you see there

156
00:10:07,908 --> 00:10:11,422
is a large difference between where the build packs are used

157
00:10:11,476 --> 00:10:14,878
from. So this again is somewhat older research, but just to give you some

158
00:10:14,884 --> 00:10:18,606
numbers, it depends on if a build pack is built on debian or on Ubuntu

159
00:10:18,638 --> 00:10:22,482
for instance, but also it depends over time. So if you

160
00:10:22,616 --> 00:10:26,098
test your image from at the beginning when you created it,

161
00:10:26,104 --> 00:10:29,518
one that's a very good, that's already very 100 points, but make sure that

162
00:10:29,544 --> 00:10:32,886
over time you do that again and again and again because vulnerabilities will be

163
00:10:32,908 --> 00:10:36,086
found and will be fixed over time. There was a question we

164
00:10:36,108 --> 00:10:39,560
asked in our open source security report.

165
00:10:40,330 --> 00:10:43,526
Well, a year and a half ago, when do you scan your docker images

166
00:10:43,558 --> 00:10:47,798
for operating system vulnerabilities? And a lot of people unfortunately

167
00:10:47,894 --> 00:10:51,286
do not, they do not know. They don't take care of that layer

168
00:10:51,318 --> 00:10:55,006
of abstraction. We probably take care of our application, we probably take care

169
00:10:55,028 --> 00:10:58,430
of our firewalls and that kind of stuff. But your operating system,

170
00:10:58,580 --> 00:11:01,758
if you deliver a complete container, if you deliver a

171
00:11:01,764 --> 00:11:05,306
complete image, then you are responsible for that operating system layer

172
00:11:05,338 --> 00:11:08,770
as well. So don't input it blindly. Make sure that you scan that and

173
00:11:08,840 --> 00:11:12,734
you are aware of what is happening. And one thing you can use are applicable

174
00:11:12,782 --> 00:11:16,098
tools you can use is for instance the tooling that sneak delivers. And this

175
00:11:16,104 --> 00:11:19,780
is an example if you install the Snyk Cli so

176
00:11:20,170 --> 00:11:23,490
you can find that on the website. I won't go into that. Say for instance,

177
00:11:23,570 --> 00:11:27,026
I'm fetching the image over here with docker pool. I'm Docker pooling

178
00:11:27,138 --> 00:11:30,678
the note ten container. I can do something like sneak container test

179
00:11:30,764 --> 00:11:34,538
and call that container I have on my local machine, scan it right away and

180
00:11:34,544 --> 00:11:38,426
it will give you a number of vulnerabilities that are in there and even

181
00:11:38,528 --> 00:11:41,686
give you, for instance, how you can fix them. In some cases

182
00:11:41,798 --> 00:11:45,498
if you create a container yourself and you add your docker file

183
00:11:45,514 --> 00:11:48,606
to it. So with a file and you add it to

184
00:11:48,708 --> 00:11:52,522
the docker file that is used to create that container, we can give you remediation

185
00:11:52,586 --> 00:11:56,366
advice on the base image. For instance like use another base image

186
00:11:56,398 --> 00:12:00,194
to remediate already x amount of vulnerabilities because,

187
00:12:00,312 --> 00:12:04,034
well, we know the info. The other thing you can do is testing is good.

188
00:12:04,072 --> 00:12:07,758
Testing is good. Like when you're building, when you're creating, but also when you're in

189
00:12:07,784 --> 00:12:11,494
production, you need to be aware of that. So one thing you can do

190
00:12:11,532 --> 00:12:15,266
is doing a sneak container monitor and monitor that image.

191
00:12:15,298 --> 00:12:19,318
What that does is it creates a snapshot of that point in time,

192
00:12:19,404 --> 00:12:22,806
sends it over to the sneak UI and helps

193
00:12:22,838 --> 00:12:26,246
you can it on a daily basis. It will scan it on a daily basis

194
00:12:26,278 --> 00:12:30,166
and if there are new problems or new remediation

195
00:12:30,198 --> 00:12:33,706
advice, it will ping you actively, which is helpful for

196
00:12:33,728 --> 00:12:37,054
a development team, not only pointing out hey, something is wrong but

197
00:12:37,092 --> 00:12:40,286
also we have a fix and it looks something like this. I did it for

198
00:12:40,308 --> 00:12:43,598
the note ten image. I did that today. And you see that over here?

199
00:12:43,684 --> 00:12:47,614
That we have the amount of vulnerabilities over here. If something has changed,

200
00:12:47,662 --> 00:12:51,362
I will get pinged. In this case, my preference is by email, in my email

201
00:12:51,416 --> 00:12:55,522
box. And that is interesting because did you know that 44%

202
00:12:55,576 --> 00:12:59,570
of the Docker images vulnerabilities can be fixed with newer base images?

203
00:12:59,730 --> 00:13:03,382
Like if I just switch out the base image and not doing anything

204
00:13:03,436 --> 00:13:07,522
on the application or other key binaries that I might manually

205
00:13:07,586 --> 00:13:10,946
put in, but just switching out the base image can already remediate

206
00:13:10,978 --> 00:13:14,298
a lot of problems by getting to a smaller base image, by getting to

207
00:13:14,304 --> 00:13:17,594
another version of a base image. So if we ask people,

208
00:13:17,632 --> 00:13:20,938
how do you find out about new vulnerabilities in your deployed container in

209
00:13:20,944 --> 00:13:24,574
production? A lot of people unfortunately don't, because once

210
00:13:24,612 --> 00:13:28,174
it's in production, it's basically out of sight, and we're looking at new features that

211
00:13:28,212 --> 00:13:32,174
holds for applications, but also for containers. And know that

212
00:13:32,212 --> 00:13:35,694
20% of Docker image vulnerabilities can be fixed just by building

213
00:13:35,742 --> 00:13:39,426
them. And that is interesting because in a lot of cases, if you look

214
00:13:39,448 --> 00:13:42,706
at Docker images or docker files, they look like this,

215
00:13:42,808 --> 00:13:46,142
like from Ubuntu latest. And you know that the latest

216
00:13:46,206 --> 00:13:49,490
now might be different from the latest in two weeks

217
00:13:49,560 --> 00:13:53,158
or three weeks, because once a problem is found, it will be fixed and a

218
00:13:53,164 --> 00:13:55,846
new version will be out, and that will be the latest, and so forth and

219
00:13:55,868 --> 00:13:59,542
so forth. So doing this and the same holds for

220
00:13:59,676 --> 00:14:03,366
things like I'm doing an app, get over here on Python. The Python

221
00:14:03,398 --> 00:14:07,066
version now might be different from the Python version in two weeks or two months.

222
00:14:07,168 --> 00:14:10,766
This means that if you're having an application, even if the application

223
00:14:10,868 --> 00:14:14,846
doesn't change the shell around it, the container where it

224
00:14:14,868 --> 00:14:18,602
lives in can change by just updating or rebuilding

225
00:14:18,666 --> 00:14:21,786
that image, reuse that Docker file,

226
00:14:21,818 --> 00:14:25,074
not doing anything, and rebuild it, because every time you build it,

227
00:14:25,112 --> 00:14:28,494
it potentially can have updates. So best practice

228
00:14:28,542 --> 00:14:32,274
in this one is just rebuild it over time, once a week, once a month,

229
00:14:32,312 --> 00:14:35,758
whatever is feasible for your application, just redo

230
00:14:35,774 --> 00:14:39,154
that, even if your application did not change the single character.

231
00:14:39,282 --> 00:14:43,142
However, if you do this, a best practice would be to use the

232
00:14:43,276 --> 00:14:46,626
no cache to make sure that it doesn't hit the cache.

233
00:14:46,658 --> 00:14:50,086
Normally it shouldn't be doing this, but now I force not to not

234
00:14:50,108 --> 00:14:53,654
to hit the cache anyway, and I force it to download

235
00:14:53,702 --> 00:14:56,938
the latest version. So rebuilding it can already solve a lot

236
00:14:56,944 --> 00:15:00,278
of things, especially if that container is in production for ages

237
00:15:00,374 --> 00:15:03,790
or for months or weeks. But you get me. So,

238
00:15:03,940 --> 00:15:06,990
okay, story is enough, but what could possibly go wrong?

239
00:15:07,140 --> 00:15:10,906
Interesting question, because when you create a container

240
00:15:10,938 --> 00:15:13,486
or you use a container and build on top of that, all the binaries are

241
00:15:13,508 --> 00:15:17,026
there. And I'm going to show you an application in just

242
00:15:17,048 --> 00:15:20,530
a second that is using one of the binaries that

243
00:15:20,600 --> 00:15:24,338
is in that container or on your operating system. And that binary is

244
00:15:24,424 --> 00:15:28,882
imagemagic. And the version of imagemagic I'm using has an improper

245
00:15:28,946 --> 00:15:32,354
input validation. And that sounds okay ish.

246
00:15:32,482 --> 00:15:36,610
But with this improper input validation I can do code execution

247
00:15:36,690 --> 00:15:40,298
and then it becomes kind of tragic. That's why this

248
00:15:40,384 --> 00:15:43,590
vulnerability is called image tragic. I think it's funny.

249
00:15:43,670 --> 00:15:46,714
However, I'm going to show you an application in a second,

250
00:15:46,752 --> 00:15:50,038
and that application uses image magic. Let me get right

251
00:15:50,064 --> 00:15:53,914
to that. All right, I'm running a container,

252
00:15:54,042 --> 00:15:58,506
it runs on localhost and it's

253
00:15:58,538 --> 00:16:02,094
here on my machine and it runs on port 30 112.

254
00:16:02,292 --> 00:16:05,670
So let's get to here. And you see, let me reload

255
00:16:05,690 --> 00:16:10,366
it. This is an application, it's a very simple node application that uses imagemagic

256
00:16:10,398 --> 00:16:14,466
to where I can upload a picture and it resizes the picture to can

257
00:16:14,568 --> 00:16:18,534
ideal format for Twitter. So what I can do, I can choose a

258
00:16:18,572 --> 00:16:22,246
file and let's choose a file on my machine. Let's choose a

259
00:16:22,268 --> 00:16:25,800
picture of myself that is large.

260
00:16:26,330 --> 00:16:29,886
So I upload it and I say resize, and it resize

261
00:16:29,938 --> 00:16:33,846
the picture to the actual size. That is very convenient

262
00:16:34,038 --> 00:16:37,162
for Twitter. Okay, cool. So that works. My unit tests around it.

263
00:16:37,216 --> 00:16:40,486
Fine, fine. But I know this is using image magic

264
00:16:40,518 --> 00:16:43,598
on the dahut. What if my image was something different,

265
00:16:43,684 --> 00:16:47,406
not just a regular image on my machine, but something like this. Let me

266
00:16:47,428 --> 00:16:48,960
go over here.

267
00:16:51,010 --> 00:16:54,610
Yes, it's here. Rce one jpeg.

268
00:16:57,350 --> 00:17:00,466
Rce one jpeg. And this is my

269
00:17:00,488 --> 00:17:04,718
jpg. Cool, right? Because this is possible with images

270
00:17:04,734 --> 00:17:08,070
magic or this is valid. The problem is,

271
00:17:08,220 --> 00:17:11,926
normally I'm allowed to call the URL in

272
00:17:11,948 --> 00:17:15,666
this file. However, with this pipe, I break out of this URL

273
00:17:15,778 --> 00:17:19,398
and basically execute touch Rce

274
00:17:19,494 --> 00:17:22,906
one. So instead of actually downloading the

275
00:17:23,008 --> 00:17:26,986
jpeg, wherever it is, I am securing a

276
00:17:27,088 --> 00:17:31,178
command. And if I can execute this command, I obviously can execute,

277
00:17:31,354 --> 00:17:35,486
maybe can execute other commands. So if I look

278
00:17:35,588 --> 00:17:39,006
in the image, the image is already here and say something like

279
00:17:39,028 --> 00:17:42,160
there, there is no rce one file yet.

280
00:17:42,770 --> 00:17:45,986
But uploading this image, like I said, let's do

281
00:17:46,008 --> 00:17:49,426
this again and let's choose that rce one file I

282
00:17:49,448 --> 00:17:52,834
just showed you. So rce one jpeg, it breaks out

283
00:17:52,872 --> 00:17:57,078
of that URL and it does the touch rce one. So open it,

284
00:17:57,244 --> 00:18:01,974
resizes and nothing comes back because there is no image and

285
00:18:02,012 --> 00:18:06,994
look at what's

286
00:18:07,042 --> 00:18:10,474
there. There is an empty file called rce one. So I can do a

287
00:18:10,512 --> 00:18:14,102
code execution and that is interesting because if I can do a code execution

288
00:18:14,166 --> 00:18:17,766
like this, I can probably do other codes, create scripts

289
00:18:17,798 --> 00:18:20,960
for instance, or run scripts. Got me?

290
00:18:21,330 --> 00:18:24,894
Cool. Second one, I've got something interesting as well.

291
00:18:24,932 --> 00:18:28,490
So instead of just doing rce one, I have an rce

292
00:18:28,570 --> 00:18:30,640
two, you already guessed it.

293
00:18:31,170 --> 00:18:34,766
So if

294
00:18:34,788 --> 00:18:38,050
I'm looking at rce two, it does something similar.

295
00:18:38,200 --> 00:18:41,746
But what that thing does is it tries to go

296
00:18:41,768 --> 00:18:45,186
to a URL but it breaks out of it again by this

297
00:18:45,288 --> 00:18:49,046
quote because this quote is something it basically says like

298
00:18:49,148 --> 00:18:52,658
evaluate this first. And what it evaluates is I'm

299
00:18:52,674 --> 00:18:56,146
going to an address host docker internal which basically refers

300
00:18:56,178 --> 00:18:59,782
back to the host machine where this docker image works on. I'm looking

301
00:18:59,836 --> 00:19:03,482
for a file, I'm getting the content of that file and print it out in

302
00:19:03,536 --> 00:19:07,386
that same file on my docker machine. So I recreate that file and I

303
00:19:07,408 --> 00:19:10,666
basically run it. So what's in this r sh?

304
00:19:10,848 --> 00:19:14,198
Well r

305
00:19:14,304 --> 00:19:17,934
sh is a script and that script gets again

306
00:19:17,972 --> 00:19:21,162
to my localhost and gets a tarball,

307
00:19:21,306 --> 00:19:24,558
Netcat. And Netcat is an application for networks,

308
00:19:24,654 --> 00:19:28,046
not really important, but it unzips or untars the tarball

309
00:19:28,078 --> 00:19:31,566
and it basically installs Netcat on that machine.

310
00:19:31,678 --> 00:19:34,930
So by doing this, if this works,

311
00:19:35,080 --> 00:19:38,002
I can execute scripts. Cool,

312
00:19:38,056 --> 00:19:41,766
right. So first of all, what I need to do, I need

313
00:19:41,788 --> 00:19:45,158
to make sure that my localhost serves this normally I

314
00:19:45,164 --> 00:19:49,190
can do something on the outside. So let's serve this application because Netcat

315
00:19:49,350 --> 00:19:52,954
is in this folder if I'm not mistaken. Yes. So the

316
00:19:52,992 --> 00:19:58,730
r sh and the Netcat tarball is over here. So let's serve

317
00:19:59,550 --> 00:20:04,126
this file on port 5000.

318
00:20:04,228 --> 00:20:07,200
That's what I need. Address already in use.

319
00:20:19,990 --> 00:20:23,314
Right, let me

320
00:20:23,352 --> 00:20:26,994
check. Oh, I did it already in another thing

321
00:20:27,032 --> 00:20:30,854
so I can redo the, terminate this one. Cool, I'm back

322
00:20:30,892 --> 00:20:34,262
here. It's already used. It said says now it's not.

323
00:20:34,316 --> 00:20:37,666
So it's now listening on port 5000 and it's now securing

324
00:20:37,698 --> 00:20:40,538
as a web server just a small tool I can use. What I'm going to

325
00:20:40,544 --> 00:20:44,106
do is I'm going to upload that rce two. So going back to

326
00:20:44,128 --> 00:20:47,802
the first page, uploading rce two and

327
00:20:47,856 --> 00:20:51,446
resize it and it does all sorts of things. You see it's

328
00:20:51,478 --> 00:20:55,246
running but it doesn't do anything. I do need to do something on

329
00:20:55,268 --> 00:20:58,654
my local machine. So Netcat is running but

330
00:20:58,692 --> 00:21:03,282
on my local machine over here. Let's do it over here. I can do

331
00:21:03,336 --> 00:21:07,394
Netcat in listening mode like lnv on 31

332
00:21:07,432 --> 00:21:10,514
31. Just wait a few seconds and let's see what

333
00:21:10,552 --> 00:21:13,938
happens. This is on my

334
00:21:13,944 --> 00:21:18,120
local machine and because Netcat is running this doesn't do anything yet.

335
00:21:19,770 --> 00:21:20,920
Nothing yet.

336
00:21:25,930 --> 00:21:27,110
Let's retry.

337
00:21:35,230 --> 00:21:38,598
All right, I should put it in listening mode first. So let's redo

338
00:21:38,614 --> 00:21:39,180
this.

339
00:21:45,210 --> 00:21:49,254
First thing I need to do is start up natcat over here in my

340
00:21:49,292 --> 00:21:52,950
local machine and minus lnv

341
00:21:53,370 --> 00:21:57,362
31 31. And I'm putting it in listening mode.

342
00:21:57,426 --> 00:22:00,810
Interesting. Now I'm uploading that file I just showed you.

343
00:22:00,880 --> 00:22:04,986
So I'm uploading that rce two file. I open it and

344
00:22:05,008 --> 00:22:09,046
I resize it. And you see it's running, it's downloading the tarball,

345
00:22:09,078 --> 00:22:12,218
it's unzipping, et cetera, et cetera, et cetera. So by doing this,

346
00:22:12,304 --> 00:22:16,526
I'm executing stuff and I'm downloading other stuff because hey, it's possible.

347
00:22:16,708 --> 00:22:20,414
So with this listening mode, I basically try to make a connection from my local

348
00:22:20,452 --> 00:22:24,234
machine to my docker host. And you see by doing can ls,

349
00:22:24,282 --> 00:22:27,794
I already have all the files in my root over here. So I now have

350
00:22:27,832 --> 00:22:31,026
access, basically some sort of shell access to my local machine. And I can do

351
00:22:31,048 --> 00:22:34,506
all sorts of things. But because I can download a tarball,

352
00:22:34,558 --> 00:22:37,714
I can execute it by using this construct.

353
00:22:37,842 --> 00:22:41,270
I am executing code or scripts on

354
00:22:41,340 --> 00:22:45,254
a docker machine that wasn't designed for that. And that's because

355
00:22:45,372 --> 00:22:49,286
we're using image magic that is outdated. That has problem. So the

356
00:22:49,308 --> 00:22:52,918
problem is not so much in my application, but in a binary that is served

357
00:22:52,934 --> 00:22:56,250
to me together with my docker images. So interesting

358
00:22:56,320 --> 00:22:59,500
part. Take care of that. That's what can go wrong.

359
00:22:59,870 --> 00:23:02,538
All right, getting back to my presentation,

360
00:23:02,634 --> 00:23:06,222
next thing, use a linter. And we all know linters from

361
00:23:06,276 --> 00:23:09,854
coding. If you are can application developer, you probably use a

362
00:23:09,892 --> 00:23:13,678
linter or a source code analysis to write better code

363
00:23:13,764 --> 00:23:16,834
to find bugs, maybe to find security issues as well.

364
00:23:16,872 --> 00:23:20,382
And there are also security linters that you can use for docker files.

365
00:23:20,446 --> 00:23:23,778
One of these things, Oz is huddlent or

366
00:23:23,864 --> 00:23:27,218
hadolint. I'm not really sure how to pronounce it. However,

367
00:23:27,304 --> 00:23:31,158
it can help you scan your docker file and see if there are problems

368
00:23:31,244 --> 00:23:34,374
or not. If you created a file, you just pull

369
00:23:34,412 --> 00:23:37,686
it to this one just like you do with your application that you use a

370
00:23:37,708 --> 00:23:41,434
linter or a scanner for that scans your code to prevent bugs or

371
00:23:41,472 --> 00:23:44,966
issues. You can do this with Hadolind as well. And Hadolind

372
00:23:44,998 --> 00:23:48,682
can for instance, tell you like please use copy instead of add for

373
00:23:48,736 --> 00:23:52,254
files and folders because that's better practice. So this is an easy

374
00:23:52,292 --> 00:23:56,062
tool again that you can use when breaking docker files yourself

375
00:23:56,196 --> 00:23:59,454
to prevent certain silly mistakes. Write that

376
00:23:59,492 --> 00:24:03,266
down. Okay, next one. It's not only about your

377
00:24:03,288 --> 00:24:06,802
container, because your container is a shell, is a

378
00:24:06,936 --> 00:24:09,730
wrapper, and inside your container there's an application.

379
00:24:09,880 --> 00:24:13,326
But both cases like your container is output facing,

380
00:24:13,358 --> 00:24:16,994
but your application probably as well. So think about that. Your application should also

381
00:24:17,032 --> 00:24:20,306
be secure. It's not only your application or only your container,

382
00:24:20,338 --> 00:24:24,034
it's both. And looking at your application, say this is the binary

383
00:24:24,082 --> 00:24:28,166
that you put into that application or into that container. How much

384
00:24:28,268 --> 00:24:32,154
of that binary of your application is actually the code that you

385
00:24:32,192 --> 00:24:35,562
wrote, that you wrote yourself or your team members wrote? Probably something

386
00:24:35,616 --> 00:24:39,414
like this. The rest of it, like the rest of the yellow part,

387
00:24:39,552 --> 00:24:43,258
probably frameworks, libraries, other libraries.

388
00:24:43,354 --> 00:24:46,590
And we know that libraries import libraries import libraries, right?

389
00:24:46,660 --> 00:24:50,398
So we depend a lot on, well, dependencies that

390
00:24:50,404 --> 00:24:54,362
you put into your manifest file, like your package JSon or your palm

391
00:24:54,426 --> 00:24:57,694
XMl. That's a good choice because we do not want to do the heavy lifting.

392
00:24:57,742 --> 00:25:00,974
We do not want to create plumbing like yet another rest endpoint

393
00:25:01,022 --> 00:25:04,146
or something like that. We want to create value and that's the code that we

394
00:25:04,168 --> 00:25:08,134
wrote. However, do you know what's in that big yellow ball? What's happening in these

395
00:25:08,172 --> 00:25:11,554
dependencies? Because we're responsible for everything, the code you wrote,

396
00:25:11,602 --> 00:25:15,126
the dependencies, but, and the container. So make sure that if you pull in

397
00:25:15,148 --> 00:25:18,886
dependencies, that these dependencies are good, that they are not harmful and

398
00:25:18,908 --> 00:25:22,506
that they are up to date, maybe because if you look at vulnerabilities that

399
00:25:22,528 --> 00:25:26,374
are found each year by ecosystem, it is growing, unfortunately.

400
00:25:26,502 --> 00:25:30,106
And the point is, it's not so much the dependency that you pull in

401
00:25:30,128 --> 00:25:33,414
yourself, but because that dependency that you pull in might depend

402
00:25:33,472 --> 00:25:36,570
on something else. On something else, on something else several layers deep.

403
00:25:36,650 --> 00:25:39,886
Most of the problems are in the indirect dependencies, so we

404
00:25:39,908 --> 00:25:43,062
should take care of that as well by for instance,

405
00:25:43,146 --> 00:25:46,782
scanning your application. And it again sounds like very theoretical.

406
00:25:46,846 --> 00:25:50,146
And what can go wrong with that? Right? Well, let me show

407
00:25:50,168 --> 00:25:54,206
you. I'm showing you a very small spring

408
00:25:54,238 --> 00:25:58,146
application. And let me get this down, let me get

409
00:25:58,168 --> 00:26:01,654
into the application. This application is quite small. This application is

410
00:26:01,692 --> 00:26:05,158
a grocery list. As you can see, when I start this application up, it will

411
00:26:05,164 --> 00:26:08,902
fill my grocery list with beans for fifty cents and milk for $1.09.

412
00:26:08,956 --> 00:26:12,474
It's Java code. It's not really interesting to be honest. It's spring boot application.

413
00:26:12,672 --> 00:26:15,878
This is the item I'm using the item. This is my domain.

414
00:26:15,974 --> 00:26:19,274
It's not interesting at all because these three fields are the most

415
00:26:19,312 --> 00:26:22,486
important one, the id that it's automatically generated,

416
00:26:22,598 --> 00:26:26,426
a name and a cost. The rest of the functions are getters and better

417
00:26:26,458 --> 00:26:30,206
to interact with name and cost. The interesting part comes into the

418
00:26:30,228 --> 00:26:34,734
item repository and the item repository, as you see over here, I am using spring

419
00:26:34,782 --> 00:26:38,402
data and spring data best. With spring data I can just create

420
00:26:38,456 --> 00:26:42,798
an interface. So not even an implementation, an interface extending crud repository.

421
00:26:42,894 --> 00:26:46,334
And by naming conventions I can create basic

422
00:26:46,382 --> 00:26:50,246
functions like find by name, give it a parameter name and

423
00:26:50,348 --> 00:26:53,874
spring data will take care of the rest. It will automatically generate

424
00:26:54,002 --> 00:26:57,798
the implementation for me based on all other things like what is

425
00:26:57,804 --> 00:27:01,538
my driver, et cetera. So by doing this I do not have to implement my

426
00:27:01,564 --> 00:27:05,226
SQL query myself by naming convention. It does it for me, it generates it

427
00:27:05,248 --> 00:27:08,810
for me, which is pretty neat because now I can focus on the business value.

428
00:27:08,960 --> 00:27:12,174
Cool. With spring data rest that I implement or

429
00:27:12,212 --> 00:27:15,486
I import over here, I just put an annotation over

430
00:27:15,508 --> 00:27:18,922
here. And what I do is from that crud repository

431
00:27:18,986 --> 00:27:22,522
that connects with my database, I instantly

432
00:27:22,586 --> 00:27:26,194
create rest endpoints. So my crud repository are available as

433
00:27:26,232 --> 00:27:29,394
rest endpoints, which is even greater because now I

434
00:27:29,432 --> 00:27:32,894
have the basic functions available and I can work on integration

435
00:27:32,942 --> 00:27:36,854
with other things. Right? Cool. Very easy prototyping typing, you would

436
00:27:36,892 --> 00:27:40,422
say. So let's run this application and let's hope it works

437
00:27:40,476 --> 00:27:44,406
because it's always praying to demo gods that these things work.

438
00:27:44,588 --> 00:27:48,386
And it works. It's up and running. Let's go back to my browser

439
00:27:48,498 --> 00:27:52,006
and let's go to localhost 80

440
00:27:52,038 --> 00:27:55,306
80. It refers me to my hell browser. And the hell browser is just to

441
00:27:55,328 --> 00:27:58,970
show you how a few things work. Like I can call the

442
00:27:59,120 --> 00:28:02,990
items one, which gives me the first item in my grocery list,

443
00:28:03,060 --> 00:28:06,702
which is beans for $0.50. If I do number two,

444
00:28:06,836 --> 00:28:10,446
you will get milk for $1.09. Cool. But it can

445
00:28:10,468 --> 00:28:13,966
also do things like search find by

446
00:28:13,988 --> 00:28:17,906
name, which was my crud repository, and the thing that changed into an endpoint by

447
00:28:17,928 --> 00:28:21,634
giving it a query parameter beer, I can

448
00:28:21,672 --> 00:28:24,994
actually search for it. So now I have beer for 599.

449
00:28:25,112 --> 00:28:28,806
Pretty cool. So we're done, let's go. But there's a problem in the

450
00:28:28,828 --> 00:28:32,454
plumbing. In the spring data rest, this particular version is

451
00:28:32,492 --> 00:28:35,654
vulnerable and the vulnerability is kind of not so obvious.

452
00:28:35,772 --> 00:28:39,562
So let's go into that I am in the

453
00:28:39,616 --> 00:28:40,860
right thing.

454
00:28:42,990 --> 00:28:46,330
Let's go to that application and let's go to the exploits.

455
00:28:48,830 --> 00:28:52,554
I will show you what you can do by showing you the

456
00:28:52,752 --> 00:28:56,430
JSON body that I can give a certain curl request.

457
00:28:58,130 --> 00:29:01,806
It's this buddy, let me just enlarge it for

458
00:29:01,828 --> 00:29:05,214
you. Let me see what's going on. It is a piece of JSON.

459
00:29:05,342 --> 00:29:09,486
And if I put this piece of JSON as part of a curl patch request,

460
00:29:09,598 --> 00:29:13,566
for some reason I am allowed to utilize SPL

461
00:29:13,598 --> 00:29:17,394
securing expression language. With an expression language I am allowed to

462
00:29:17,512 --> 00:29:20,866
call variables, call objects, create new objects,

463
00:29:20,898 --> 00:29:24,342
that kind of stuff. And what I do over here is I get the current

464
00:29:24,396 --> 00:29:28,038
runtime and I execute a command. I get it as an input stream, redirect it

465
00:29:28,044 --> 00:29:31,754
to an output stream and I can show it to you. So if command is

466
00:29:31,792 --> 00:29:35,046
something different, not the word command but an actual command

467
00:29:35,078 --> 00:29:38,394
like env or delete or make deer or whatever,

468
00:29:38,512 --> 00:29:42,106
and this works, I can basically do anything

469
00:29:42,208 --> 00:29:45,598
within the application or break out of the application and do anything on

470
00:29:45,604 --> 00:29:49,486
the machine, in this case your docker image. So this

471
00:29:49,508 --> 00:29:52,420
is cool, but let's just actually hack it.

472
00:29:57,350 --> 00:30:00,914
Let's go for the passwd file. So if

473
00:30:00,952 --> 00:30:04,270
we look over here we see that is curl patch request,

474
00:30:04,430 --> 00:30:08,054
right? And that curl patch request has a content type and

475
00:30:08,172 --> 00:30:12,322
we see the actual thing over here, like the runtime getting the runtime execute.

476
00:30:12,466 --> 00:30:15,960
In this case I'm creating a string that says

477
00:30:16,670 --> 00:30:20,474
etc passwd and I

478
00:30:20,512 --> 00:30:24,966
call this request with this body on the endpointitem

479
00:30:25,078 --> 00:30:28,726
one, which was there normally as just a get endpoint

480
00:30:28,758 --> 00:30:32,558
to get my first item in my grocery list. But unfortunately I can do

481
00:30:32,564 --> 00:30:35,694
a patch request this way as well. And by doing this, this is of course

482
00:30:35,732 --> 00:30:39,230
my local machine. By running this I will have

483
00:30:39,380 --> 00:30:43,558
access to my passwd file. And now my passwd

484
00:30:43,594 --> 00:30:47,074
file doesn't contain a lot of information, luckily not anymore these

485
00:30:47,112 --> 00:30:50,926
days. But if I can read this and your docker

486
00:30:50,958 --> 00:30:54,706
container doesn't container the right privileges for the user, but for

487
00:30:54,728 --> 00:30:58,294
instance the root user, we can read and write a lot of stuff

488
00:30:58,332 --> 00:31:01,526
in your container without you knowing it. Cool. So take

489
00:31:01,548 --> 00:31:04,966
care of your application as well. So I showed you what

490
00:31:04,988 --> 00:31:09,046
can go wrong with can application. Next thing I want to tell

491
00:31:09,068 --> 00:31:12,726
you is things about multistage builds. A multistage builds

492
00:31:12,758 --> 00:31:16,406
is a marvelous thing in Docker because what you can do is you can split

493
00:31:16,438 --> 00:31:20,298
builds in different steps and what you can do with that for instance is

494
00:31:20,384 --> 00:31:23,994
you can divide your build image from your production image.

495
00:31:24,122 --> 00:31:28,314
If you look on how to's on the Internet, on stack overflow,

496
00:31:28,362 --> 00:31:31,758
or when you google things, you find very small

497
00:31:31,844 --> 00:31:35,774
images or spare very small docker files, how you can build an image,

498
00:31:35,902 --> 00:31:39,022
but in many cases, at build time or at creation,

499
00:31:39,086 --> 00:31:43,054
you need some more information, and you do not want to leak

500
00:31:43,102 --> 00:31:46,626
that into the image that goes to production. With a

501
00:31:46,648 --> 00:31:50,290
multistage build, you can split these things. And for instance, that's interesting. With Java.

502
00:31:50,370 --> 00:31:53,746
I'm using a Java image over here. I'm using the OpenJDK

503
00:31:53,858 --> 00:31:57,206
maven three image, and that means it containers the

504
00:31:57,228 --> 00:32:01,078
JDK, which is the Java development kit, roughly says it's

505
00:32:01,094 --> 00:32:04,682
the JVM plus the Java runtime environment and the building

506
00:32:04,736 --> 00:32:08,150
stuff. So what we can do with that is it contains Maven,

507
00:32:08,230 --> 00:32:11,594
the complete JDK, and I copy my full source code in it

508
00:32:11,632 --> 00:32:14,718
and I run it. But for a Java application, that's not what I need.

509
00:32:14,804 --> 00:32:18,958
I can use Maven, I can use a JDK to build my

510
00:32:19,044 --> 00:32:22,666
artifact. And I only need the build result because it's a compiled

511
00:32:22,698 --> 00:32:26,126
language. So I do not need Maven and the whole JDK,

512
00:32:26,158 --> 00:32:30,050
I just need a runtime environment to run this jar war,

513
00:32:30,120 --> 00:32:33,586
whatever it is in it. You see that because all this tooling is in there.

514
00:32:33,688 --> 00:32:37,646
Basically, you do not just want the car, you want the whole factory

515
00:32:37,678 --> 00:32:41,558
to build the car. That's what you're doing here. It's over 600 megabytes. If I

516
00:32:41,564 --> 00:32:45,174
do it like this, I still use that same thing as the

517
00:32:45,212 --> 00:32:48,742
top part of my build images. So that is the build image as

518
00:32:48,796 --> 00:32:52,634
building. And in the second part I refer to that.

519
00:32:52,752 --> 00:32:56,054
So what I do with the second part is I create a production image,

520
00:32:56,102 --> 00:32:59,942
and that only holds the Java runtime environment based on alpine.

521
00:33:00,006 --> 00:33:03,566
And that is a very small distribution. That is what goes

522
00:33:03,588 --> 00:33:06,702
into the actual product that I'm putting on my

523
00:33:06,756 --> 00:33:10,462
server. I copy the jar file and I run it so

524
00:33:10,516 --> 00:33:14,014
that final product will just be over 100 megabytes big,

525
00:33:14,132 --> 00:33:17,746
and that's like a lot less. Also, if you,

526
00:33:17,768 --> 00:33:20,946
for instance, building node images, like here, and I have an example on

527
00:33:20,968 --> 00:33:25,470
node twelve, a node twelve image where I need to provide credentials

528
00:33:25,550 --> 00:33:29,122
to get to a certain registry. And you do not want these registries,

529
00:33:29,186 --> 00:33:32,326
you do not want this token, which is secret, you do

530
00:33:32,348 --> 00:33:35,526
not want to leak it into your production image, because if it

531
00:33:35,548 --> 00:33:38,658
is there, you can probably find that back, it's somewhere

532
00:33:38,674 --> 00:33:42,426
in the cache. And by doing, for instance, history or something, you can retrieve these

533
00:33:42,448 --> 00:33:45,866
kind of things. If we do a multistage build, everything that is

534
00:33:45,888 --> 00:33:49,242
in the building image stays in the building image, and I only copy the stuff

535
00:33:49,296 --> 00:33:52,862
over that I need so things like secrets or

536
00:33:52,916 --> 00:33:56,542
extra binaries that you need during creation to check to whatever

537
00:33:56,596 --> 00:33:59,838
you want to want to do or to do quality

538
00:33:59,924 --> 00:34:03,630
assurance, I don't care. Do that in your build part and you only need

539
00:34:03,700 --> 00:34:07,694
the product of it, right? So in this case the production image

540
00:34:07,742 --> 00:34:11,726
is based on again note twelve, but a slim version which is a smaller

541
00:34:11,758 --> 00:34:15,874
version of it. Separating these two is a very good practice and something you

542
00:34:15,912 --> 00:34:19,622
should be doing. So you're using open source. Me too.

543
00:34:19,676 --> 00:34:22,710
I'm an open source contributor as well, and open source is great,

544
00:34:22,780 --> 00:34:26,374
but you have to make sure that you keep a thing in mind. If a

545
00:34:26,412 --> 00:34:30,490
large open source package or container that is widely used is

546
00:34:30,560 --> 00:34:33,430
vulnerable and compromised, there are a lot of victims.

547
00:34:33,510 --> 00:34:36,746
So as a developer, you're responsible for the application and

548
00:34:36,768 --> 00:34:40,326
the container around it to ship it to production. Make sure you are aware

549
00:34:40,358 --> 00:34:44,046
what's in it. If there are already known vulnerabilities and how to

550
00:34:44,068 --> 00:34:47,758
remediate them, because you do not want to be eventually secure. You want to be

551
00:34:47,844 --> 00:34:52,138
secure as soon as possible, as soon as these vulnerabilities

552
00:34:52,234 --> 00:34:55,982
are known. Little recap choose the right base image.

553
00:34:56,046 --> 00:34:59,666
Make sure that the base image does not contain stuff you don't need. Make sure

554
00:34:59,688 --> 00:35:03,554
that it's small, because every binary that ships with a

555
00:35:03,592 --> 00:35:06,402
full blown operating system,

556
00:35:06,536 --> 00:35:10,246
you might not need every single one of them. So make

557
00:35:10,268 --> 00:35:13,782
it small. Make it concise. What you don't have cannot harm you.

558
00:35:13,916 --> 00:35:17,958
Rebuild your image often, even if your application doesn't change,

559
00:35:18,044 --> 00:35:21,994
building your image based on a certain base image or other

560
00:35:22,032 --> 00:35:25,654
binaries that you pull in, they might change and they might have fixes

561
00:35:25,702 --> 00:35:29,226
as well. Can your images during development, but also when

562
00:35:29,248 --> 00:35:32,358
you go to production by taking a snapshot and monitor it. Same holds

563
00:35:32,374 --> 00:35:36,046
for your applications of course, but be aware of that, that scanning is

564
00:35:36,068 --> 00:35:39,390
one of the things that you need to constantly do in every single

565
00:35:39,540 --> 00:35:43,178
part of your software development lifecycle. The multistage builds I

566
00:35:43,204 --> 00:35:46,814
showed you is a good practice to make a separation

567
00:35:46,862 --> 00:35:50,900
between your build image that might need stuff like tokens or

568
00:35:51,270 --> 00:35:55,154
might need extra binaries to do the building stuff. Separate that

569
00:35:55,192 --> 00:35:58,766
from the production image that is small and based on, for instance,

570
00:35:58,798 --> 00:36:03,074
an alpine images or something like that. Use a security linter. A thing like Hadolint

571
00:36:03,122 --> 00:36:06,566
that I showed you is a very nice small tool that you can add to

572
00:36:06,588 --> 00:36:10,146
your toolset to can your docker file and prevent

573
00:36:10,178 --> 00:36:14,134
silly mistakes. And last but not least, make sure that you do not

574
00:36:14,252 --> 00:36:17,958
run your docker container as a root by default. This is the

575
00:36:17,964 --> 00:36:22,126
case, so create a user or make sure that if the

576
00:36:22,148 --> 00:36:25,278
container you base your image on, if it already has

577
00:36:25,364 --> 00:36:29,306
a specific user, that you actually call it, but don't run it as root.

578
00:36:29,418 --> 00:36:32,702
All right, that's about it for me. Thank you for listening. Thank you for watching

579
00:36:32,756 --> 00:36:36,206
all the tooling I showed you you can use for free. And see you later.

580
00:36:36,308 --> 00:36:36,570
Cheers.

