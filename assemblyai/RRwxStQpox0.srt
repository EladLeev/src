1
00:00:26,130 --> 00:00:29,446
Hello everyone, my name is Gajendra Deshpande. Today I will

2
00:00:29,468 --> 00:00:33,206
be presenting a talk on build your first cyber forensics application

3
00:00:33,308 --> 00:00:37,334
using Python. So in today's talk, we are going to

4
00:00:37,372 --> 00:00:41,074
discuss about introduction to digital crimes, digital forensics,

5
00:00:41,122 --> 00:00:44,866
the process of investigation and the collection of evidence, then setting

6
00:00:44,898 --> 00:00:48,246
up Python for forensic application development, built in

7
00:00:48,268 --> 00:00:51,626
functions and modules for forensic tasks, forensic indexing

8
00:00:51,658 --> 00:00:55,322
and searching has functions for forensics, forensic evidence extraction,

9
00:00:55,386 --> 00:00:59,262
metadata forensics, then using natural language tools in forensics. And finally,

10
00:00:59,316 --> 00:01:03,018
this summary, let us first look at some cybercrime statistics.

11
00:01:03,114 --> 00:01:06,958
So, the Internet Crimes report for 2019 released by USA's

12
00:01:06,974 --> 00:01:10,478
Internet Crime Compliance center of Federal Bureau

13
00:01:10,494 --> 00:01:14,606
of Investigation has revealed top four countries that are victims of Internet crimes.

14
00:01:14,718 --> 00:01:17,838
You can see here USA has more than four lakh reports.

15
00:01:17,934 --> 00:01:21,894
Then UK has more than 93,000, Canada has more than 33,000

16
00:01:21,932 --> 00:01:25,874
and India has more than 27,000. Of course, these numbers are only reported

17
00:01:25,922 --> 00:01:29,762
numbers, so unreported numbers are much, much higher. So you can consider

18
00:01:29,916 --> 00:01:33,466
at least three times higher. So according to RSA report of

19
00:01:33,488 --> 00:01:37,318
2015, mobile transactions are rapidly growing and cybercrimes

20
00:01:37,414 --> 00:01:41,082
are migrating to less protected soft channels. So less protected soft

21
00:01:41,136 --> 00:01:44,366
channels are mostly our mobile devices. And most

22
00:01:44,388 --> 00:01:48,398
of times what happens is mobile devices are operated by those who are not

23
00:01:48,484 --> 00:01:52,026
well educated and who are not well versed with the mobile

24
00:01:52,058 --> 00:01:56,062
device and different settings. So according to report by Norton

25
00:01:56,206 --> 00:02:00,242
2015, an estimated 103,000,000 Indians lost about

26
00:02:00,376 --> 00:02:03,822
rupees 16,000 on an average to cybercrime.

27
00:02:03,886 --> 00:02:07,966
So that amounts to us dollar of around 200

28
00:02:08,008 --> 00:02:11,506
plus. According to an article published in Indian Express

29
00:02:11,538 --> 00:02:15,094
on 19 number 216, over 55% millions in

30
00:02:15,132 --> 00:02:19,494
India are hit by this cybercrime. So a recent study by Checkpoint Research has

31
00:02:19,532 --> 00:02:23,446
recorded over one like 50,000 cyberattacks every week during Covid-19

32
00:02:23,478 --> 00:02:27,638
pandemic. So there has been an increase of 30% in cyberattacks

33
00:02:27,654 --> 00:02:31,910
compared to previous weeks. So that's because many people have lost jobs

34
00:02:32,070 --> 00:02:36,046
and many people are suffering. And maybe there are many insider attacks who

35
00:02:36,068 --> 00:02:39,902
are taking advantage of the situation. Now let us look at the definition of

36
00:02:39,956 --> 00:02:43,902
digital forensics. So, forensics science is the use of scientific

37
00:02:43,966 --> 00:02:47,474
methods or expertise to investigate crimes or

38
00:02:47,512 --> 00:02:51,742
examine evidence that might be presented in the court of law. So cyber forensics

39
00:02:51,806 --> 00:02:55,842
is investigation of various crimes happening in the cyberspace.

40
00:02:55,986 --> 00:02:59,638
Examples of attacks include phishing, ransomware, fake news,

41
00:02:59,724 --> 00:03:02,962
fake medicine, extortion and insider frauds.

42
00:03:03,026 --> 00:03:07,090
So according to DFRWs, that is digital forensics research workshop,

43
00:03:07,170 --> 00:03:11,334
digital forensics can be defined as the use of scientifically derived

44
00:03:11,382 --> 00:03:14,822
and proven method toward the preservation, collection, validation,

45
00:03:14,886 --> 00:03:18,714
identification, analysis, interpretation, documentation and

46
00:03:18,752 --> 00:03:22,154
presentation of the digital evidence derived from digital

47
00:03:22,202 --> 00:03:25,806
sources for the purpose of facilitating or furthering the

48
00:03:25,828 --> 00:03:29,194
reconstruction of events found to be criminal, or helping

49
00:03:29,242 --> 00:03:33,310
to anticipate unauthorized functions shown to be disruptive

50
00:03:33,390 --> 00:03:37,134
to planned operations. So the digital forensic investigation

51
00:03:37,182 --> 00:03:40,466
process has the following steps. It starts with

52
00:03:40,488 --> 00:03:43,646
identification, then collection, validation, examination,

53
00:03:43,758 --> 00:03:46,902
preservation and presentation. So in identification steps,

54
00:03:46,956 --> 00:03:50,482
what happens is whenever a cybercrimes investigating officer,

55
00:03:50,546 --> 00:03:54,130
or basically an investigating officer, usually he's the police officer.

56
00:03:54,210 --> 00:03:58,230
When he visits the place, his job is to first identify

57
00:03:58,390 --> 00:04:02,294
all the objects so that he can seize those objects,

58
00:04:02,422 --> 00:04:06,138
which helps in the investigation of the case. So basically

59
00:04:06,224 --> 00:04:10,130
this identification of objects helps in collecting the evidence.

60
00:04:10,230 --> 00:04:14,106
So basically he has to collect all the electronic

61
00:04:14,138 --> 00:04:16,986
gadgets, including smartphones,

62
00:04:17,178 --> 00:04:20,298
laptops, then storage devices,

63
00:04:20,474 --> 00:04:24,194
et cetera. So one important thing he should note here that

64
00:04:24,232 --> 00:04:27,954
there may be some devices, okay, say for examples,

65
00:04:28,152 --> 00:04:31,774
toy USB. So these are very difficult to identify.

66
00:04:31,902 --> 00:04:35,854
Even he has to identify such objects and take into his custody.

67
00:04:35,982 --> 00:04:39,334
Then once the objects are identifying, then the next

68
00:04:39,372 --> 00:04:42,754
step comes is the collection. So in collection of evidence,

69
00:04:42,882 --> 00:04:46,326
the investigating officer has to note down the state of

70
00:04:46,348 --> 00:04:49,926
the system. If it is on, then he has to perform live forensics. If it

71
00:04:49,948 --> 00:04:53,274
is off, he should not turn on the system. So the present state of the

72
00:04:53,312 --> 00:04:56,780
system has to be maintained and the photograph needs to be taken.

73
00:04:57,150 --> 00:05:00,630
Now if in some cases, so generally that situation is rare,

74
00:05:00,710 --> 00:05:04,586
the police officer is not in a position to perform live forensics,

75
00:05:04,698 --> 00:05:08,110
then he just needs to pull the plug so that the present

76
00:05:08,180 --> 00:05:12,094
state of the system can be maintained. So if he turn

77
00:05:12,132 --> 00:05:15,954
on the system or turn off the system, then it will definitely change the state

78
00:05:15,992 --> 00:05:19,362
of the system and it will alter the evidence. And one more important thing,

79
00:05:19,416 --> 00:05:22,978
whenever investigating officer is collecting the evidence is that

80
00:05:23,064 --> 00:05:26,422
they collect the most volatile evidence first and the least

81
00:05:26,476 --> 00:05:30,246
volatile evidence last. So there's a particular order is mentioned,

82
00:05:30,348 --> 00:05:33,282
so that states the volatility.

83
00:05:33,426 --> 00:05:37,026
As per the volatility order, the investigating officer needs to collect

84
00:05:37,058 --> 00:05:40,474
the evidence. Then once it is done, then the next

85
00:05:40,512 --> 00:05:43,994
step is to validate the evidence. Now note here

86
00:05:44,032 --> 00:05:47,542
that the investigating officers usually takes the snapshot

87
00:05:47,606 --> 00:05:50,998
or the image of the system, and this image needs to be validated.

88
00:05:51,094 --> 00:05:54,890
So one algorithm which can be used for validation is the hashing algorithm.

89
00:05:54,970 --> 00:05:58,554
So I will demonstrate how it is done in later slides.

90
00:05:58,682 --> 00:06:02,110
The next is examination. Once the system

91
00:06:02,180 --> 00:06:05,354
image has been captured, the investigating officer

92
00:06:05,402 --> 00:06:08,962
needs to examine it. Now note here that this data will be huge. So without

93
00:06:09,016 --> 00:06:12,210
computer, it will be very difficult to examine the data and get the

94
00:06:12,280 --> 00:06:16,158
useful insights. Now, the next step is preservation.

95
00:06:16,254 --> 00:06:20,134
Now, note here that investigating officers are collecting different objects, such as hard

96
00:06:20,172 --> 00:06:23,782
disk and several other evidences. They needs to be stored in

97
00:06:23,916 --> 00:06:26,918
proper room temperature, in a proper security,

98
00:06:27,084 --> 00:06:31,306
in a proper lockers, and they also need to be stored in special

99
00:06:31,408 --> 00:06:35,222
bags, such as antistatic bags or faraday bags.

100
00:06:35,286 --> 00:06:39,226
This is very important, because if the procedure is not followed, then the evidence may

101
00:06:39,248 --> 00:06:42,606
be altered. If the evidence is altered by any means, then it will not be

102
00:06:42,628 --> 00:06:45,754
presented in the court of law. The next is presentation.

103
00:06:45,882 --> 00:06:49,758
The whole idea behind all these steps is

104
00:06:49,844 --> 00:06:53,278
to extract the evidence and present it in the court of law,

105
00:06:53,364 --> 00:06:57,218
right? So if these steps are not performed, then court will not accept it.

106
00:06:57,304 --> 00:07:01,010
So every step needs to be performed carefully, and finally,

107
00:07:01,160 --> 00:07:04,514
it has to be presented in the court of law. Now,

108
00:07:04,552 --> 00:07:08,662
there is one important standard known as Dobert Standard.

109
00:07:08,796 --> 00:07:12,562
So, let us discuss how Dobert standard is useful

110
00:07:12,626 --> 00:07:16,646
and how Python adheres to Dobert standard. So, in United

111
00:07:16,748 --> 00:07:20,998
States federal law, the Dobert standard is a rule of evidence regarding

112
00:07:21,014 --> 00:07:24,554
the admissibility of expert witness testimony. So a party may

113
00:07:24,592 --> 00:07:28,134
raise a Dobert motion, a special motion in limina raised

114
00:07:28,182 --> 00:07:32,202
before or during trial to exclude the presentation

115
00:07:32,266 --> 00:07:36,314
of unqualified evidence to the jury. So there are some illustrative

116
00:07:36,362 --> 00:07:40,046
factors. So, the court defined scientific methodology as the

117
00:07:40,068 --> 00:07:44,114
process of formulating hypothesis, and then conducting experiments to

118
00:07:44,152 --> 00:07:47,794
prove or falsify the hypothesis, and provided a set

119
00:07:47,832 --> 00:07:51,634
of illustrative factors. So, pursuant to rule 10

120
00:07:51,672 --> 00:07:55,538
four a, in Dobert, the US Supreme Court suggested that

121
00:07:55,624 --> 00:07:59,174
the following factors be considered. So, has the technique been

122
00:07:59,212 --> 00:08:02,886
tested in actual field conditions and not just in

123
00:08:02,908 --> 00:08:06,246
a laboratory? Has the technique been subject to peer review and

124
00:08:06,268 --> 00:08:09,594
publication? What is the known or potential rate

125
00:08:09,632 --> 00:08:13,606
of error? Do standards exist for control of technique's operation?

126
00:08:13,718 --> 00:08:17,062
Has the technique been generally accepted within the relevant

127
00:08:17,126 --> 00:08:20,662
scientific community? Now let's see how Python implements

128
00:08:20,726 --> 00:08:24,922
it. So, in 2003, brain carrier published a paper that examined

129
00:08:24,986 --> 00:08:28,234
rules of evidence standards, including Dobert,

130
00:08:28,282 --> 00:08:31,706
and compared and contrasted the open source and closed source

131
00:08:31,738 --> 00:08:35,486
forensic tools. One of his key conclusion was using the guidelines

132
00:08:35,518 --> 00:08:39,458
of Dobert tests. We have shown that open source tools may

133
00:08:39,544 --> 00:08:43,566
more clearly and comprehensively meet the guideline requirements than closed

134
00:08:43,598 --> 00:08:47,338
source tools. So this statement clearly states that Python

135
00:08:47,374 --> 00:08:50,786
has advantage because Python is open source and free software.

136
00:08:50,978 --> 00:08:55,474
So we can say that Python adheres to the Dobert standard and the investigation

137
00:08:55,602 --> 00:08:59,174
process, or the code written using Python language for

138
00:08:59,212 --> 00:09:02,682
cybercrimes application that can be presented in the court of law.

139
00:09:02,736 --> 00:09:06,298
The results are not automatic, of course, just because the source is open.

140
00:09:06,384 --> 00:09:10,694
Rather, specific steps must be followed regarding design, development and validation.

141
00:09:10,822 --> 00:09:14,074
Can the program or algorithm be explained? This explanation

142
00:09:14,122 --> 00:09:17,966
should be explained in words, not only in code. Has enough information

143
00:09:18,068 --> 00:09:21,514
been provided such that thorough tests can be developed

144
00:09:21,562 --> 00:09:24,754
to test the program? Have error rates been

145
00:09:24,792 --> 00:09:28,462
calculated and validated independently? Has the program been studied

146
00:09:28,526 --> 00:09:31,854
and peer reviewed? Has the program been generally accepted

147
00:09:31,902 --> 00:09:35,298
by the community? Now you can see these five points correlate to

148
00:09:35,304 --> 00:09:39,014
the Dobert standard. Illustrative factors. So that's why we can

149
00:09:39,052 --> 00:09:42,854
say that since Python is open source and you can do

150
00:09:42,892 --> 00:09:46,514
all these points which are mentioned on this slide using Python.

151
00:09:46,642 --> 00:09:50,326
So it adds to the Daubert standard and hence the evidence

152
00:09:50,358 --> 00:09:53,562
can be presented in the court of law. It is very very important.

153
00:09:53,696 --> 00:09:56,986
Whenever you are using tool, you should ensure that it

154
00:09:57,088 --> 00:09:59,180
adheres to the Dobert standard.

155
00:09:59,790 --> 00:10:03,854
The next setting up Python for forensics application development now

156
00:10:03,892 --> 00:10:07,358
there are some factors which actually need to be considered whenever you

157
00:10:07,364 --> 00:10:10,798
are setting the environment. The first one is your background and the

158
00:10:10,804 --> 00:10:15,170
organization support. So what is your qualification, how much skill

159
00:10:15,590 --> 00:10:19,074
you are having in Python and what is the organization support?

160
00:10:19,112 --> 00:10:23,150
Say for example, is your organization funds the development of new software

161
00:10:23,230 --> 00:10:26,426
or is it capable of purchasing new software

162
00:10:26,558 --> 00:10:30,274
or is it interested to invest in open source

163
00:10:30,322 --> 00:10:34,146
tools? The next is choosing the third party libraries. So choosing

164
00:10:34,178 --> 00:10:37,734
third party libraries is also very very important because there is

165
00:10:37,772 --> 00:10:41,594
a dependency issue and you may have to sometimes write

166
00:10:41,632 --> 00:10:44,986
wrappers in order to just get the functions. The next is

167
00:10:45,008 --> 00:10:48,406
the ides and their features, that is integrated development environments.

168
00:10:48,518 --> 00:10:51,886
So what do you prefer? Are you just okay to write the

169
00:10:51,908 --> 00:10:55,406
command line programs or you need sophisticated ides so

170
00:10:55,428 --> 00:10:58,506
that it can help you code faster using the features

171
00:10:58,538 --> 00:11:01,594
such as intellisense and debugging.

172
00:11:01,722 --> 00:11:04,834
The next is installation. So where you want to install it?

173
00:11:04,872 --> 00:11:08,386
On which operating system are you interested in installing on

174
00:11:08,408 --> 00:11:12,254
Windows, Linux or Macintosh? Of course, if the evidence

175
00:11:12,302 --> 00:11:15,790
is just the analysis then it depends.

176
00:11:15,950 --> 00:11:18,982
So it is just a simple analysis then you can use any operating system.

177
00:11:19,036 --> 00:11:22,166
But if you are performing some system specific

178
00:11:22,348 --> 00:11:26,198
analysis, say for example Windows forensics or

179
00:11:26,204 --> 00:11:29,554
Linux forensics or Macintosh forensics, then you need to install Python

180
00:11:29,602 --> 00:11:32,902
on those specific operating systems, then write version of Python.

181
00:11:32,966 --> 00:11:36,934
So this is also very very important. You can't use the recent version of Python

182
00:11:36,982 --> 00:11:40,330
just because it is recent. Okay. Some libraries may support it. May not support

183
00:11:40,400 --> 00:11:43,982
it, okay. So the getting tasks done is very very important.

184
00:11:44,116 --> 00:11:47,534
So you need to use the appropriate version of Python then

185
00:11:47,572 --> 00:11:51,150
next, how you want to execute your programs. Are you

186
00:11:51,220 --> 00:11:54,562
interested in using graphical tools or just these shell commands? Okay,

187
00:11:54,616 --> 00:11:57,986
many times shell commands will do the job and you can get the

188
00:11:58,008 --> 00:12:01,330
job done very quickly. And many times it is very important

189
00:12:01,480 --> 00:12:05,060
to use graphical tools also.

190
00:12:05,930 --> 00:12:09,394
Now let's see how Python supports the development

191
00:12:09,442 --> 00:12:12,966
of cyber forensics applications now. Built in

192
00:12:13,068 --> 00:12:17,094
functions and modules now note here that Python has got many

193
00:12:17,212 --> 00:12:20,582
built in functions and modules. You can list all of them using

194
00:12:20,636 --> 00:12:23,946
the Dir builtin function and

195
00:12:23,968 --> 00:12:27,334
you can see here that there are several built in modules

196
00:12:27,382 --> 00:12:30,922
and functions listed. So if you are a Python developer, you are already

197
00:12:30,976 --> 00:12:35,086
aware of these functions. The only thing we need to see is how we

198
00:12:35,108 --> 00:12:38,954
are going to use them differently when we are developing the cyber cyber

199
00:12:39,002 --> 00:12:42,954
forensic application. This is a simple code which demonstrates

200
00:12:43,002 --> 00:12:46,914
the use of range function. So you might have used range function along

201
00:12:46,952 --> 00:12:50,446
with loops. So whenever you wanted to generate some list of numbers, or whenever

202
00:12:50,478 --> 00:12:54,082
you wanted to work with lists or

203
00:12:54,216 --> 00:12:57,394
basically array kind of data structures. So here you can see

204
00:12:57,432 --> 00:13:00,806
here that the base address has been defined and basically here we are

205
00:13:00,828 --> 00:13:04,114
generating ten local IP addresses. So similarly

206
00:13:04,162 --> 00:13:07,854
you can generate any number of IP addresses, any kind of IP addresses.

207
00:13:07,922 --> 00:13:11,382
You can even generate IPV six addresses.

208
00:13:11,446 --> 00:13:14,954
So similarly you can use this range function to generate any

209
00:13:14,992 --> 00:13:19,050
kind of information. The next application is

210
00:13:19,200 --> 00:13:22,526
to list the files from the directory. So in this

211
00:13:22,548 --> 00:13:25,818
case we are using the OS module. Again, it's inbuilt.

212
00:13:25,914 --> 00:13:29,178
So here we are getting the current working directory.

213
00:13:29,274 --> 00:13:32,494
Then we are using current working directory to print the

214
00:13:32,612 --> 00:13:35,966
files and folders in the present working directory. So note

215
00:13:35,998 --> 00:13:40,210
here that in this case also we have not used any additional library.

216
00:13:40,630 --> 00:13:44,430
The next concept is forensic indexing and searching.

217
00:13:44,510 --> 00:13:48,214
So in case of indexing and searching, so you already are aware of

218
00:13:48,252 --> 00:13:51,878
these concepts. Indexing and searching. So whenever you have worked with

219
00:13:51,964 --> 00:13:55,762
list data structures or arrays or matrices, two dimensional arrays

220
00:13:55,826 --> 00:13:59,366
or multi dimensional arrays, you might have dealt with index

221
00:13:59,478 --> 00:14:02,826
concept. Then similarly in case of Google, you might

222
00:14:02,848 --> 00:14:07,014
have also dealt with page ranking. So algorithm,

223
00:14:07,062 --> 00:14:10,678
so you may be aware of it. The next is searching. Searching is just a

224
00:14:10,704 --> 00:14:14,238
simple operation which is used to find the relevant information.

225
00:14:14,404 --> 00:14:17,902
So you can develop or you can write your own search

226
00:14:17,956 --> 00:14:21,390
functionality, or you can use the search function

227
00:14:21,460 --> 00:14:25,190
available in the Python core library.

228
00:14:25,370 --> 00:14:29,262
So these two are very simple methods.

229
00:14:29,326 --> 00:14:32,786
Now note here that many times what happens is our evidence may be present in

230
00:14:32,808 --> 00:14:36,974
files. So in that case we need to search for particular keywords.

231
00:14:37,022 --> 00:14:40,534
So these keywords are nothing but the clues for the evidence. You need

232
00:14:40,572 --> 00:14:44,566
to search for those keywords. You need to search for particular information and

233
00:14:44,588 --> 00:14:48,054
you can do it using a very simple code. So you just need

234
00:14:48,092 --> 00:14:51,350
to use files data structure. So open the file,

235
00:14:51,430 --> 00:14:55,082
then read the information line by line, then process the information,

236
00:14:55,216 --> 00:14:58,746
then check for the keywords. So if those keywords are found you can

237
00:14:58,768 --> 00:15:01,866
just print those are found. If they are not found you can just print they

238
00:15:01,888 --> 00:15:04,618
are not found. So if they are found means you have found some clues.

239
00:15:04,714 --> 00:15:08,442
So then you can use some additional tools to index

240
00:15:08,506 --> 00:15:11,822
them, right? So even you can perform simple indexing using

241
00:15:11,876 --> 00:15:15,426
dictionary or you can just put it in a list. So when you put it

242
00:15:15,448 --> 00:15:19,090
in a list you will be indexing them by default.

243
00:15:19,430 --> 00:15:23,502
Now there is a library called as Hoosh. So it is advanced

244
00:15:23,646 --> 00:15:27,506
library and it can be used for forensics indexing

245
00:15:27,538 --> 00:15:30,710
and searching. So Hoosh was created and is maintained by

246
00:15:30,780 --> 00:15:34,502
Matt. It was originally created for use

247
00:15:34,556 --> 00:15:38,402
in online help system of side effects software,

248
00:15:38,466 --> 00:15:42,262
3d animation software, Houdini. Since 2016

249
00:15:42,406 --> 00:15:46,154
it is not being maintained but we are not seeing any updates. But still

250
00:15:46,192 --> 00:15:50,170
it works with the present version of Python. You don't face any problem

251
00:15:50,240 --> 00:15:53,854
with the present version, it's still compatible and it works fine without any

252
00:15:53,892 --> 00:15:58,046
problem. It's a pure Python library and

253
00:15:58,148 --> 00:16:02,358
it supports fielded indexing and search. It supports fast indexing and retrieval.

254
00:16:02,474 --> 00:16:05,166
It supports pluggable scoring algorithm,

255
00:16:05,278 --> 00:16:08,254
text analysis, storage and various posting formats,

256
00:16:08,302 --> 00:16:11,986
et cetera. And you can also query it. So it

257
00:16:12,008 --> 00:16:15,918
supports powerful query language and pure Python

258
00:16:16,014 --> 00:16:20,062
spell checker. Now this is the code actually written

259
00:16:20,126 --> 00:16:23,190
using Hoosh. So what we are doing here

260
00:16:23,260 --> 00:16:27,046
is first we are importing the required modules such

261
00:16:27,068 --> 00:16:30,586
as create in, right? Then we are defining a

262
00:16:30,608 --> 00:16:33,866
schema with title path and the content.

263
00:16:34,048 --> 00:16:37,402
Then we are creating a directory index dir with

264
00:16:37,456 --> 00:16:40,714
the schema. Then we are writing the files and the content

265
00:16:40,832 --> 00:16:43,966
to index Dir. Now note here that once the content has been

266
00:16:43,988 --> 00:16:47,514
written, you also need to write the query parser. So this query

267
00:16:47,562 --> 00:16:51,262
parser will help you to extract the information from

268
00:16:51,316 --> 00:16:55,170
this library. So Hoosh can also be used to create

269
00:16:55,240 --> 00:16:58,914
your own custom search engine. So it supports both indexing and

270
00:16:58,952 --> 00:17:03,438
searching features. Now has functions for forensics. So hash functions

271
00:17:03,534 --> 00:17:07,534
are very very important. They are used for basically validation purpose.

272
00:17:07,582 --> 00:17:10,530
So whenever you take the snapshot of the image,

273
00:17:10,610 --> 00:17:13,910
whenever you tasks the record the entire

274
00:17:13,980 --> 00:17:17,062
image of the system. So when I say image of the system, we are using

275
00:17:17,196 --> 00:17:20,886
tools like Northern Ghost and we are making the image

276
00:17:20,918 --> 00:17:24,154
of the entire system. Once your image is ready,

277
00:17:24,272 --> 00:17:28,614
you can start analyzing it. But note here that you cannot perform forensics

278
00:17:28,662 --> 00:17:32,058
analysis on the original data. You need to perform forensic analysis on

279
00:17:32,064 --> 00:17:35,486
the copy of the data. Now when you perform forensic analysis on the copy of

280
00:17:35,508 --> 00:17:38,650
the data, after performing the analysis, you need to check the has

281
00:17:38,730 --> 00:17:42,186
you need to check the has of original image and the copied

282
00:17:42,218 --> 00:17:45,178
image, so it should be the same. If there's a difference,

283
00:17:45,284 --> 00:17:48,702
then that means that something has been altered in the copied image.

284
00:17:48,766 --> 00:17:52,686
So that's why you can see here that using a simple application I'm

285
00:17:52,718 --> 00:17:56,430
demonstrating here, we are importing a hashlib library.

286
00:17:56,590 --> 00:18:00,386
Then we are using SHa 256 hash

287
00:18:00,418 --> 00:18:04,770
module. So of course it also supports other algorithms such as MD Phi.

288
00:18:04,930 --> 00:18:08,150
Then note here that there are two messages have been

289
00:18:08,220 --> 00:18:11,594
written. One is Python is, and second one is a great programming language. They have

290
00:18:11,632 --> 00:18:15,094
been combined and stored in a string called as Yum.

291
00:18:15,222 --> 00:18:18,454
Then we are calculating the digest on Yum.

292
00:18:18,582 --> 00:18:21,338
Then we are defining another variable, x.

293
00:18:21,504 --> 00:18:24,806
Now again here also say we are using same method,

294
00:18:24,838 --> 00:18:28,314
that is Sha 256, and in this case we are using a single sentence.

295
00:18:28,362 --> 00:18:31,566
Python is a great programming language. Now at the end we

296
00:18:31,588 --> 00:18:35,406
are just comparing using a statement print x digest is

297
00:18:35,428 --> 00:18:39,314
equal to m digest. So that means we are checking whether the digest of

298
00:18:39,352 --> 00:18:43,406
x and Yum are same. So in this case, you can see here the output

299
00:18:43,438 --> 00:18:46,450
is same. And also it says that the digest is true.

300
00:18:46,520 --> 00:18:50,070
So that means the hash is same, the information is

301
00:18:50,140 --> 00:18:53,926
not being altered. Now there's the same example. So what

302
00:18:53,948 --> 00:18:57,334
I have done is I have just added one white space at the

303
00:18:57,372 --> 00:19:01,126
end of x message, right after the dot. So in

304
00:19:01,148 --> 00:19:05,094
this case, again the digest has been calculated. Hash has been calculated.

305
00:19:05,142 --> 00:19:08,874
Now in this case it is showing false. So that means the hashes are not

306
00:19:08,912 --> 00:19:12,826
same. So that means that the information has been altered. So has functions

307
00:19:12,858 --> 00:19:16,254
are very, very important. Okay. And note here that the

308
00:19:16,292 --> 00:19:19,706
use of hash algorithms is recognized in the court

309
00:19:19,738 --> 00:19:22,554
of law. Especially I'm not aware of other countries,

310
00:19:22,602 --> 00:19:26,178
but at least in India, it has been recorded by Information

311
00:19:26,264 --> 00:19:29,634
Technology Act 2000. Now next up is

312
00:19:29,672 --> 00:19:33,106
forensics evidence extraction. So for this we can use the

313
00:19:33,128 --> 00:19:37,218
library called as pillow. Pillow is the friendly PIL fork

314
00:19:37,234 --> 00:19:40,434
by Alex Clark and contributors. So PIL is the Python

315
00:19:40,482 --> 00:19:44,210
imaging library by Frederick Lund and contributors.

316
00:19:44,290 --> 00:19:47,938
Basically, it is used for image processing tasks. The Python image

317
00:19:47,954 --> 00:19:50,998
library adds image processing capabilities to your Python interpreter.

318
00:19:51,094 --> 00:19:55,094
So this library provides extensive file format support and efficient

319
00:19:55,142 --> 00:19:59,046
internal representation, and fairly powerful image processing capabilities. The core

320
00:19:59,078 --> 00:20:02,986
image library is designed for fast access to data stored in a few basic

321
00:20:03,018 --> 00:20:06,542
pixel format, so it should provide a solid foundation for general

322
00:20:06,596 --> 00:20:10,474
image processing tool. Now for forensic evidence

323
00:20:10,522 --> 00:20:14,126
extraction, we are using again the PIL library. Now note here that we

324
00:20:14,148 --> 00:20:18,050
can extract the XiF tasks. We can extract the GPS information

325
00:20:18,120 --> 00:20:21,746
using GPS tags. Now we can use both.

326
00:20:21,848 --> 00:20:24,974
Now let's assume that there's a picture which is taken from your mobile

327
00:20:25,022 --> 00:20:28,378
phone and it is stored in your mobile phone. Now the investigating

328
00:20:28,414 --> 00:20:32,018
officer will take that photo and he will write the third script,

329
00:20:32,114 --> 00:20:35,446
that is the script written at the bottom and he will extract the

330
00:20:35,468 --> 00:20:38,818
GPS information about that photo, okay? And he will

331
00:20:38,844 --> 00:20:42,602
also extract the other properties of the image such as size,

332
00:20:42,736 --> 00:20:45,926
image description. Then GPS tax include the longitude,

333
00:20:46,038 --> 00:20:49,466
latitude. So basically the location information so where that

334
00:20:49,488 --> 00:20:52,874
photo has been taken. So all this information can be extracted

335
00:20:52,922 --> 00:20:56,430
using simple PL library and the

336
00:20:56,500 --> 00:21:00,682
modules such as tags and GPS tasks. Of course this library supports

337
00:21:00,746 --> 00:21:04,770
various other modules also which are useful in

338
00:21:04,920 --> 00:21:09,054
extracting the evidence. The next is the PI screenshot

339
00:21:09,102 --> 00:21:12,926
module. So it tries to allow to take Pyscreenshot without installing third party

340
00:21:12,958 --> 00:21:16,850
libraries. Again, note here that it has been written

341
00:21:17,190 --> 00:21:21,286
as a wrapper to pillow, but PIL Pyscreenshot also supports other

342
00:21:21,308 --> 00:21:24,786
libraries. Now note here that performance is not the target

343
00:21:24,818 --> 00:21:28,598
for this library or in any case of cyber forensics activities,

344
00:21:28,694 --> 00:21:32,026
performance is not the target. The importance is given to

345
00:21:32,048 --> 00:21:35,254
the evidence and its protection.

346
00:21:35,382 --> 00:21:38,746
So basically it has to ensure that the information has not

347
00:21:38,768 --> 00:21:41,994
been altered. So this is simple code which

348
00:21:42,032 --> 00:21:45,120
actually tasks the screenshot of entire screen.

349
00:21:45,490 --> 00:21:48,746
So that can be done by using importing by screenshot module

350
00:21:48,778 --> 00:21:52,254
and using a grab method. So once you grab it, you just need to save

351
00:21:52,292 --> 00:21:55,874
the image using save method. So this particular code takes

352
00:21:55,912 --> 00:21:59,618
the screenshot of entire screen. Similarly you can take the screenshot of

353
00:21:59,704 --> 00:22:03,214
part of a screen by specifying the coordinates

354
00:22:03,262 --> 00:22:06,910
to BB box parameter in grab method. Now you

355
00:22:06,920 --> 00:22:10,594
can also check the performance of PI screenshot module if you are real, if you're

356
00:22:10,642 --> 00:22:14,534
interested. So you can see here there are different modules such as

357
00:22:14,572 --> 00:22:17,926
Pil, MSS, right, Piqt and et cetera. And n

358
00:22:17,948 --> 00:22:21,462
equal to ten means this is the time taken to take ten

359
00:22:21,516 --> 00:22:25,130
screenshots. So you can choose the one which is taking the less time.

360
00:22:25,280 --> 00:22:28,426
Okay, so you can force the back end. So if you force the back end

361
00:22:28,448 --> 00:22:31,542
to scratch and if you force the back end to MSS,

362
00:22:31,686 --> 00:22:35,102
and if you set child process to false, then of course

363
00:22:35,156 --> 00:22:38,606
it will help you to improve the performance significantly. But as

364
00:22:38,628 --> 00:22:42,446
I have said, performance is not the target here. Extracting the evidence is

365
00:22:42,468 --> 00:22:46,470
the target. The next is metadata forensics. Now note here that metadata

366
00:22:46,490 --> 00:22:49,938
is associated with every kind of a file. So now mutagen is

367
00:22:49,944 --> 00:22:53,474
the Python module to handle audio metadata. Now you can see here

368
00:22:53,512 --> 00:22:57,074
that many times you may get audio evidence or video evidence. So in that case

369
00:22:57,112 --> 00:23:00,950
you may have to extract the metadata of audio file or sometimes

370
00:23:01,020 --> 00:23:04,726
in even video file. So in that case, mutagen will help you.

371
00:23:04,828 --> 00:23:08,326
So again, mutagen is pure Python library. That means no additional modules

372
00:23:08,358 --> 00:23:11,466
are required, so they don't have any standard

373
00:23:11,568 --> 00:23:14,938
or any additional dependency. So you

374
00:23:14,944 --> 00:23:19,126
can install mutagen using Python three minus mPIP. Install mutagen.

375
00:23:19,238 --> 00:23:23,174
Now what this mutagen does is it takes any audio file and

376
00:23:23,232 --> 00:23:26,986
tries to guess its type and returns the file type instance or none.

377
00:23:27,018 --> 00:23:30,606
Many times it happens that people may change the extension, but even though

378
00:23:30,708 --> 00:23:34,278
you change the extension, the internal algorithm internal

379
00:23:34,314 --> 00:23:37,842
architecture will remain same. So in that case it becomes important to

380
00:23:37,976 --> 00:23:41,186
guess the or get the type of the

381
00:23:41,288 --> 00:23:44,754
file original type of the file. So you can see

382
00:23:44,792 --> 00:23:49,078
here the same mutagen library is able to get the information

383
00:23:49,164 --> 00:23:52,614
about a flac file and also the mp3 file, so it can get

384
00:23:52,652 --> 00:23:55,794
the bitrate and the length of an audio

385
00:23:55,842 --> 00:23:59,654
file. Then similarly, as I have said, since you are dealing with

386
00:23:59,692 --> 00:24:03,226
files, metadata is associated with every kind of file. So there is a library called

387
00:24:03,248 --> 00:24:06,906
as PyPdf. So using this you can extract metadata information

388
00:24:07,008 --> 00:24:10,630
of Pdf file. So again it is a pure Python library

389
00:24:10,710 --> 00:24:14,366
and it is capable of extracting the document information, splitting the documents page

390
00:24:14,388 --> 00:24:18,266
by page, merging documents page by page, cropping pages, merging multiple

391
00:24:18,298 --> 00:24:21,338
pages, encrypting and decrypting Pdf files,

392
00:24:21,434 --> 00:24:24,974
and so on. The next is PE file. So PE

393
00:24:25,012 --> 00:24:28,274
file is a multiplatform Python module to argparse and work

394
00:24:28,312 --> 00:24:31,586
with the portable executable files. So usually PE files are found on

395
00:24:31,608 --> 00:24:35,406
Windows operating system. So most of the information contained in PE file header

396
00:24:35,438 --> 00:24:38,278
is accessible as well as sections, data and the data.

397
00:24:38,364 --> 00:24:42,642
So the structures defined in Windows header files will be accessible as attributes.

398
00:24:42,786 --> 00:24:45,894
In PE instance, the naming of fields or attributes will

399
00:24:45,932 --> 00:24:49,826
try to add to the naming scheme in those headers, so only shortcuts

400
00:24:49,858 --> 00:24:53,034
added for convenience will depart from that convention. So PE

401
00:24:53,072 --> 00:24:57,062
file required some basic understanding of the layout of a PE file.

402
00:24:57,126 --> 00:25:00,494
So with it it's possible to explore nearly every single feature of PE

403
00:25:00,532 --> 00:25:04,030
file format. Some of the tasks which are possible

404
00:25:04,100 --> 00:25:07,214
with PE file are instructing headers, analyzing the functions data,

405
00:25:07,252 --> 00:25:10,698
retrieving embedded data, reading strings from resources,

406
00:25:10,794 --> 00:25:13,982
then warning of suspicious and malformed values,

407
00:25:14,046 --> 00:25:18,398
overwriting fields, then Packer detection with PID signatures,

408
00:25:18,494 --> 00:25:22,510
PID signature detection, signature generation, et cetera.

409
00:25:22,590 --> 00:25:25,966
The next one more important concept is using natural

410
00:25:25,998 --> 00:25:29,498
language tools or NLP packages in Python. Now note here that whenever

411
00:25:29,534 --> 00:25:33,494
you extract the information you are actually taking the image of the entire computer.

412
00:25:33,612 --> 00:25:36,774
So there may be lot of textual information present in it,

413
00:25:36,812 --> 00:25:40,490
there may be lot of system files present in it so it is not possible

414
00:25:40,560 --> 00:25:44,186
to examine each and every file manually. So in that case, to extract the

415
00:25:44,208 --> 00:25:46,742
useful information, to extract the keywords,

416
00:25:46,886 --> 00:25:51,246
NLP packages can be used. We know that NLP packages support

417
00:25:51,428 --> 00:25:54,970
features such as tokenization, lamatization, word frequency,

418
00:25:55,050 --> 00:25:58,666
NGram analysis, and so on. So finally, you can also generate

419
00:25:58,698 --> 00:26:02,654
the summary. You can also generate the frequency of co occurring words

420
00:26:02,692 --> 00:26:06,814
using Ngram analysis. Also they support grammatical

421
00:26:06,942 --> 00:26:10,606
tools such as part of speech tagging and also the named entity recognition.

422
00:26:10,638 --> 00:26:14,594
So several features are supported. And all these features are really important

423
00:26:14,792 --> 00:26:18,242
in forensics analysis. So you can get the required

424
00:26:18,306 --> 00:26:22,114
information, or you can try to get the required information or some insights

425
00:26:22,162 --> 00:26:25,426
using NLP packages. Now, these NLP

426
00:26:25,458 --> 00:26:29,042
packages can be classified into three categories. One is single

427
00:26:29,116 --> 00:26:32,534
language libraries. So most of the times NLTK space and texture,

428
00:26:32,582 --> 00:26:36,650
they work with English, but some of them also support some other languages.

429
00:26:36,990 --> 00:26:40,854
Then we have specific libraries for multiple human languages

430
00:26:40,902 --> 00:26:44,086
such as stanza and polyglot. They support stanza

431
00:26:44,118 --> 00:26:48,190
support at least 60 plus languages. Polygraph support at least 150 or 140

432
00:26:48,340 --> 00:26:52,074
languages. Then there are some libraries such as NLTK

433
00:26:52,122 --> 00:26:55,714
or Indic NLP. These are for indian languages which have

434
00:26:55,752 --> 00:26:59,186
got different structure altogether. Of course, stanza supports and also

435
00:26:59,208 --> 00:27:02,926
polyglot supports some of the indian languages. But in LTC

436
00:27:02,958 --> 00:27:06,366
and Indic, NLP are much more advanced. In today's

437
00:27:06,398 --> 00:27:10,978
talk, we have seen how we can create small cyber forensic applications.

438
00:27:11,074 --> 00:27:14,786
So we had not done, say any extensive application. We had not created

439
00:27:14,818 --> 00:27:17,942
any extensive application. But you can see here that we have created very

440
00:27:17,996 --> 00:27:21,158
small applications using the concepts known to us.

441
00:27:21,244 --> 00:27:23,810
Of course we had seen some advanced libraries.

442
00:27:23,970 --> 00:27:27,846
So in cyber forensic application creation, it is very

443
00:27:27,868 --> 00:27:31,306
important to follow the standard procedure, the law enforcement agencies

444
00:27:31,338 --> 00:27:34,894
during the investigation process. Otherwise it will not be admissible in the

445
00:27:34,932 --> 00:27:38,174
court of law. Then there are many open source as well as commercial tools for

446
00:27:38,212 --> 00:27:42,122
digital forensics. Learning to develop your own tool is always advantageous

447
00:27:42,186 --> 00:27:45,466
because it can save time, it can help you to save money. Then many tools

448
00:27:45,498 --> 00:27:48,954
written in Python are pure python implementations. And most importantly,

449
00:27:49,002 --> 00:27:52,480
Python and open source tools comply with Dobert Standard.

450
00:27:53,010 --> 00:27:53,660
Thank you everyone.

