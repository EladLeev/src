1
00:00:20,330 --> 00:00:23,626
Hello and welcome to my talk. My name is Michael Birch. I'm a senior Rust

2
00:00:23,658 --> 00:00:27,890
engineer working at Aurora Labs. I've been working with Rust since 2018,

3
00:00:27,970 --> 00:00:31,334
but before that I was doing functional programming in Scala. I love

4
00:00:31,372 --> 00:00:34,806
how Rust is an imperative programming language, but takes inspiration from some

5
00:00:34,828 --> 00:00:38,840
of the best features of functional programming, some of which we'll talk about today.

6
00:00:39,450 --> 00:00:42,906
My goal with this talk is to show how patterns in functional programming can be

7
00:00:42,928 --> 00:00:45,962
used in rust to write code that is easier to test,

8
00:00:46,096 --> 00:00:49,926
maintain, and reused in multiple applications. In your tech stack.

9
00:00:50,038 --> 00:00:53,886
In particular, I'm focusing on how we applied these ideas at Aurora to

10
00:00:53,908 --> 00:00:57,422
do what it says in the title, turn our main smart contract into

11
00:00:57,476 --> 00:01:01,194
an indexer. I hope this talk will be both accessible

12
00:01:01,242 --> 00:01:05,486
and interesting to blockchain developers, rust experts, and functional programming

13
00:01:05,518 --> 00:01:09,026
enthusiasts. Though each group may find different parts of the talk more

14
00:01:09,048 --> 00:01:12,980
or less informative in terms of an outline, I'll begin

15
00:01:13,510 --> 00:01:16,814
by getting everyone up to speed on the basics of blockchain

16
00:01:16,862 --> 00:01:20,374
technology. Only what you need to understand what I mean when I'm talking

17
00:01:20,412 --> 00:01:23,960
about smart contracts, indexers, and how they relate to one another.

18
00:01:24,330 --> 00:01:27,970
Next, I'll talk about the key features of the rest programming language

19
00:01:28,050 --> 00:01:32,278
that enable us to do this smart contracts into indexers trick.

20
00:01:32,454 --> 00:01:35,942
And finally, we'll do a deep dive into some real code that showcases

21
00:01:36,006 --> 00:01:38,970
how these ideas were applied at Aurora.

22
00:01:39,470 --> 00:01:42,986
So, to get started, let's talk about blockchain basics. What is

23
00:01:43,008 --> 00:01:46,698
a blockchain? A blockchain is an appendonly data structure

24
00:01:46,794 --> 00:01:50,222
with immutable history. What I mean by this is

25
00:01:50,356 --> 00:01:53,854
the data structure can only have additional data added to

26
00:01:53,892 --> 00:01:57,406
it, and once something has been added to the blockchain, it cannot

27
00:01:57,438 --> 00:02:01,134
be changed. Up on the slide, we have sort of the classic

28
00:02:01,182 --> 00:02:04,654
depiction of a blockchain. The squares in the diagram

29
00:02:04,702 --> 00:02:08,226
are the so called blocks which represent the individual chunks

30
00:02:08,258 --> 00:02:11,606
of data in the data structure, and the arrows show how the

31
00:02:11,628 --> 00:02:15,110
blocks are connected to one another. Hence blockchain.

32
00:02:15,530 --> 00:02:19,306
This data structure you can imagine extending infinitely to the

33
00:02:19,328 --> 00:02:23,798
right by adding a new block with can arrow pointing to the previous block.

34
00:02:23,974 --> 00:02:27,638
As I mentioned, the history is immutable because the connections

35
00:02:27,734 --> 00:02:30,874
actually depend on what data came before it.

36
00:02:30,912 --> 00:02:34,782
So you cannot change that earlier data and still maintain that

37
00:02:34,836 --> 00:02:38,314
connection. This is cryptographically secured, but the details

38
00:02:38,362 --> 00:02:42,366
are not important for what we're talking about today. So you

39
00:02:42,388 --> 00:02:45,954
might ask, what goes into these blocks? And the answer is

40
00:02:46,072 --> 00:02:50,014
transactions. For typical blockchain applications,

41
00:02:50,142 --> 00:02:53,266
you have transactions that are interpreted in some kind

42
00:02:53,288 --> 00:02:57,300
of virtual machine, which causes some kind of global state to change.

43
00:02:58,150 --> 00:03:01,254
For example, in the case of Ethereum, which is a relatively large

44
00:03:01,292 --> 00:03:05,046
blockchain platform you may have heard of before, the state consists of all

45
00:03:05,068 --> 00:03:08,506
of the accounts and contracts that exist on the platform,

46
00:03:08,688 --> 00:03:12,890
and the virtual machine is the ethereum virtual machine. The EVM

47
00:03:13,310 --> 00:03:17,338
transactions can be things like send three ETh to some address

48
00:03:17,504 --> 00:03:21,002
or call some method on a contract

49
00:03:21,066 --> 00:03:24,826
that was previously deployed. And speaking of smart

50
00:03:24,858 --> 00:03:28,090
contracts, let's talk about those. A smart contract

51
00:03:28,170 --> 00:03:31,706
is a program that can run in the virtual

52
00:03:31,738 --> 00:03:35,058
machine of whatever blockchain you're talking about. Up on

53
00:03:35,064 --> 00:03:39,074
the slide. I've got sort of a simple example where

54
00:03:39,272 --> 00:03:43,486
in the first transaction you deploy some contract,

55
00:03:43,678 --> 00:03:47,090
it gets included into the state, and then in a later

56
00:03:47,160 --> 00:03:50,418
block you have a new transaction that is calling a method,

57
00:03:50,514 --> 00:03:53,670
in this case, the method foo on that contract.

58
00:03:54,250 --> 00:03:57,526
Smart contracts can do all kinds of things. They're limited only by the

59
00:03:57,548 --> 00:04:00,890
power of the virtual machine that they operate in. For example,

60
00:04:00,960 --> 00:04:04,118
smart contracts can represent tokens, maybe even tokens

61
00:04:04,134 --> 00:04:07,690
that are tied to some real world currency, so called stablecoins.

62
00:04:08,110 --> 00:04:11,578
Smart contracts can be marketplaces where you can trade

63
00:04:11,674 --> 00:04:15,706
between those different tokens, or they can be escrow lockers

64
00:04:15,738 --> 00:04:18,960
to facilitate some kind of exchange. Maybe even in the real world,

65
00:04:19,330 --> 00:04:23,194
smart contracts can be validated storages

66
00:04:23,322 --> 00:04:26,178
where you can prove that off can events happened,

67
00:04:26,344 --> 00:04:30,370
say for example in the leaderboard for blockchain enabled games.

68
00:04:30,870 --> 00:04:34,674
Or even a smart contract could be the

69
00:04:34,712 --> 00:04:38,038
entire virtual machine of some other blockchain platform.

70
00:04:38,204 --> 00:04:41,622
And this might sound crazy, but it's an important part of this story

71
00:04:41,676 --> 00:04:45,474
that we'll come back to later. For now, let's keep being with our blockchain

72
00:04:45,522 --> 00:04:49,510
basics. All of this is just about a single copy

73
00:04:49,590 --> 00:04:52,934
of the blockchain and how it evolves. But in a real blockchain

74
00:04:52,982 --> 00:04:56,666
platform, the blockchain is distributed and

75
00:04:56,768 --> 00:05:00,478
continuously built by multiple participants that are

76
00:05:00,484 --> 00:05:03,550
decentralized, the so called nodes of the network,

77
00:05:04,050 --> 00:05:07,710
and the transactions are submitted by users.

78
00:05:08,130 --> 00:05:11,466
The nodes eventually agree on the blockchain that they're all collectively

79
00:05:11,498 --> 00:05:15,118
building up to some point using a consensus algorithm.

80
00:05:15,294 --> 00:05:18,354
Again, the details are not very important for what we're talking about here,

81
00:05:18,472 --> 00:05:21,874
but suffice it to say the blockchain is

82
00:05:21,912 --> 00:05:25,442
only eventually consistent, and getting data about

83
00:05:25,496 --> 00:05:29,430
the blockchain off of the network is slow because of the decentralized nature.

84
00:05:29,930 --> 00:05:33,766
So how do users actually get the data off of the

85
00:05:33,788 --> 00:05:37,510
blockchain? They interact with some kind of RPC.

86
00:05:37,930 --> 00:05:41,926
Usually that RPC is run by a third party service, but users

87
00:05:41,958 --> 00:05:44,954
can choose to run their own code that are a part of the network and

88
00:05:44,992 --> 00:05:48,634
still expose an RPC interface to themselves. The key point

89
00:05:48,672 --> 00:05:51,926
here is that getting data off of the blockchain is slow because

90
00:05:51,968 --> 00:05:55,342
it requires multiple network calls, and even still

91
00:05:55,396 --> 00:05:59,162
because of the decentralized nature, it's only eventually consistent.

92
00:05:59,226 --> 00:06:03,166
So something that happens in one node may take a long time to propagate and

93
00:06:03,188 --> 00:06:06,690
be visible by any given RPC for a particular user.

94
00:06:07,430 --> 00:06:11,918
So to help address that problem, we have this idea of an indexer.

95
00:06:12,094 --> 00:06:15,818
Given the wide range of functionality of smart contracts,

96
00:06:16,014 --> 00:06:19,410
it's not always efficient to query a blockchain platform directly

97
00:06:19,490 --> 00:06:23,298
against its RPC. There's just no way for a single RPC

98
00:06:23,394 --> 00:06:27,350
to capture all of the different possible variations on

99
00:06:27,420 --> 00:06:30,806
the states that different smart contracts could hold. And indexers

100
00:06:30,838 --> 00:06:34,794
help address this by having a specialized view of the blockchain state which

101
00:06:34,832 --> 00:06:37,370
is optimized for particular queries.

102
00:06:38,030 --> 00:06:42,220
For example, a block Explorer like Etherscan, which is

103
00:06:42,670 --> 00:06:45,790
the biggest block explorer for the Ethereum blockchain.

104
00:06:46,290 --> 00:06:49,694
It'll show you all of the tokens that are held by

105
00:06:49,732 --> 00:06:52,926
each user. Up on the slide, I've taken a screenshot of ether scan where

106
00:06:52,948 --> 00:06:56,642
I've selected some random account and you can see it holds 23

107
00:06:56,696 --> 00:07:00,386
different kinds of tokens. This kind

108
00:07:00,408 --> 00:07:04,334
of query would be very difficult or maybe even impossible

109
00:07:04,382 --> 00:07:07,666
to do with just the RPC because the mapping

110
00:07:07,698 --> 00:07:12,034
is actually reversed on chain. Each token knows

111
00:07:12,082 --> 00:07:15,446
the list of balance holders, but there is no

112
00:07:15,628 --> 00:07:18,986
index for all of the tokens held by each of the

113
00:07:19,008 --> 00:07:22,954
addresses. So to solve that problem, Etherscan has

114
00:07:22,992 --> 00:07:26,522
an indexer which maintains that reverse lookup and makes

115
00:07:26,576 --> 00:07:30,300
the queries efficient when a user visits their website.

116
00:07:32,450 --> 00:07:36,526
So the way to think about how indexers fit into the

117
00:07:36,548 --> 00:07:39,726
story here is you have some user talking to some

118
00:07:39,828 --> 00:07:43,130
application UI which is talking to an indexer,

119
00:07:43,210 --> 00:07:46,846
and the indexer is fed data from an RPC and the indexer

120
00:07:46,878 --> 00:07:50,820
is maintaining its own internal specialized view of the state.

121
00:07:51,350 --> 00:07:55,186
Indexers, like I've been saying, help create low latency experience for

122
00:07:55,208 --> 00:07:59,170
users or web, two experiences in the sort of blockchain

123
00:07:59,250 --> 00:08:02,726
jargon. Since the indexer needs to populate the

124
00:08:02,748 --> 00:08:06,422
database from blockchain data, it needs to understand what state

125
00:08:06,476 --> 00:08:09,446
of the smart contract is important. Therefore,

126
00:08:09,558 --> 00:08:12,746
smart contracts and their indexers are always related to

127
00:08:12,768 --> 00:08:17,194
one another. So can idea we might have is

128
00:08:17,312 --> 00:08:20,618
to have a single source code, single code base

129
00:08:20,784 --> 00:08:24,254
that contributes both to our smart contract and our

130
00:08:24,292 --> 00:08:27,454
indexers. Again, because they're so closely related to one another,

131
00:08:27,652 --> 00:08:30,794
this would be great since it would mean less maintenance.

132
00:08:30,842 --> 00:08:34,702
There's just less code overall to maintain. And even better

133
00:08:34,756 --> 00:08:38,654
still, it would make our indexer more powerful than your average indexer,

134
00:08:38,702 --> 00:08:41,758
because it would have access to all of the smart contract's logic,

135
00:08:41,854 --> 00:08:45,422
and it would be able to do things like simulate an entire transaction

136
00:08:45,566 --> 00:08:48,802
off chain, and that gives you free low latency

137
00:08:48,866 --> 00:08:52,742
feedback to users about potential errors. So this is

138
00:08:52,796 --> 00:08:56,034
what we're aiming for. This is our idea. How are we going to accomplish

139
00:08:56,082 --> 00:08:59,866
that using rust? So there's a few key concepts that

140
00:08:59,888 --> 00:09:03,494
we want to take a look at. First of all is different compilation

141
00:09:03,542 --> 00:09:07,974
targets. So up on the slide I've got links

142
00:09:08,022 --> 00:09:11,466
to the official rust documentation if you want to sort of take

143
00:09:11,488 --> 00:09:15,070
a deep dive and read more about this yourself. But at a high level

144
00:09:15,220 --> 00:09:18,318
you have the rest compiler giving you some kind of

145
00:09:18,404 --> 00:09:22,000
output from your code, some kind of executable output from your code.

146
00:09:22,610 --> 00:09:26,210
In the typical case, it's an executable for whatever

147
00:09:26,280 --> 00:09:29,534
operating system you're running on Linux, Windows, Mac,

148
00:09:29,662 --> 00:09:33,214
and maybe even specialized to the specific hardware of your machine,

149
00:09:33,262 --> 00:09:37,206
say it's an arm or x 86. But there are

150
00:09:37,228 --> 00:09:41,414
more executable targets than just these. In particular,

151
00:09:41,532 --> 00:09:45,142
webassembly is an important one for this story, because the

152
00:09:45,196 --> 00:09:48,630
blockchain platform that Aurora uses has webassembly

153
00:09:48,710 --> 00:09:52,374
as its virtual machine. So on the slide

154
00:09:52,422 --> 00:09:56,202
I include the commands that you would use in rust to

155
00:09:56,336 --> 00:09:59,654
install the webassembly target compilation

156
00:09:59,702 --> 00:10:04,126
target, and then how you would select that targets to build

157
00:10:04,228 --> 00:10:05,200
your project.

158
00:10:07,490 --> 00:10:10,942
Now, given that you can have these different

159
00:10:10,996 --> 00:10:15,490
targets, it's useful to be able to write code that selects

160
00:10:16,550 --> 00:10:20,542
or is specialized to a particular compilation target.

161
00:10:20,686 --> 00:10:24,018
Conditional compilation allows us to do this.

162
00:10:24,184 --> 00:10:28,030
Again, I've got a link up on the slide which you

163
00:10:28,040 --> 00:10:31,414
can do some further reading on if you're interested. But long

164
00:10:31,452 --> 00:10:34,646
story short, the syntax looks like the example I've got

165
00:10:34,668 --> 00:10:38,214
up there. So we have some function Foo, and the implementation

166
00:10:38,262 --> 00:10:42,060
of Foo depends on if we're compiling to wasm or not.

167
00:10:42,750 --> 00:10:47,350
Again, this is useful because it lets us make specific choices

168
00:10:47,510 --> 00:10:51,174
that only work on that architecture. So in the case of webassembly,

169
00:10:51,222 --> 00:10:55,166
you have this notion of host functions, which we'll talk a lot about later.

170
00:10:55,348 --> 00:10:59,438
But host functions are functions that the host, that is the computer

171
00:10:59,524 --> 00:11:03,310
running your webassembly virtual machine exposes for

172
00:11:03,460 --> 00:11:07,300
the WASM module to use, whereas in a normal application

173
00:11:07,750 --> 00:11:11,490
those don't exist. But in a normal application you do have

174
00:11:11,560 --> 00:11:15,810
access to disk, for example, so you could use that to access storage.

175
00:11:16,550 --> 00:11:20,338
Now, the drawback of conditional compilation is that it's

176
00:11:20,354 --> 00:11:24,134
a little verbose, and it makes the implementation a little hard to

177
00:11:24,172 --> 00:11:27,494
read, right. You can see, the function foo maybe looks

178
00:11:27,532 --> 00:11:30,650
a little awkward because there are these two totally separate branches.

179
00:11:31,150 --> 00:11:34,426
Additionally, because you have these separate branches, it's a little tedious to

180
00:11:34,448 --> 00:11:38,010
use inside of an IDE. Your iDe will usually

181
00:11:38,080 --> 00:11:41,530
only show you one branch of the conditional compilation at a time,

182
00:11:41,680 --> 00:11:44,782
so you have to sort of switch back and forth between them when you're trying

183
00:11:44,836 --> 00:11:48,394
to write code for it. But fortunately,

184
00:11:48,442 --> 00:11:52,994
we can minimize the amount of conditional compilation that we're doing by

185
00:11:53,112 --> 00:11:56,994
abstracting most of our code over the

186
00:11:57,112 --> 00:11:59,090
platform specific effects.

187
00:12:00,790 --> 00:12:05,246
And to do that, we have this idea in rust called type generics.

188
00:12:05,438 --> 00:12:09,030
So the whole point of a type generic is you

189
00:12:09,100 --> 00:12:11,910
write a function, in this case get balance,

190
00:12:12,570 --> 00:12:16,502
which takes in some type, but we don't care what it is,

191
00:12:16,556 --> 00:12:20,598
we only care that it has a particular interface,

192
00:12:20,774 --> 00:12:24,118
and that interface is defined using a trait,

193
00:12:24,214 --> 00:12:28,022
and indicated in the syntax they are using a so called trait bound.

194
00:12:28,086 --> 00:12:31,862
So we have in the brackets

195
00:12:31,926 --> 00:12:35,094
between there the angle brackets I O

196
00:12:35,152 --> 00:12:38,426
says that whatever this type I is, it must implement

197
00:12:38,458 --> 00:12:41,930
the IO interface defined by the IO trait.

198
00:12:42,090 --> 00:12:46,270
In this example, I'm keeping it pretty simple with just the read and write methods,

199
00:12:46,770 --> 00:12:50,466
and the type signatures are maybe a little suspect. You can imagine maybe that there

200
00:12:50,488 --> 00:12:54,386
should be some kind of option or result involved in the read, but for

201
00:12:54,408 --> 00:12:58,034
the sake of example, let's suppose this is what it looks like. The point

202
00:12:58,072 --> 00:13:01,366
is that when you have this type generic, you don't care what the specifics of

203
00:13:01,388 --> 00:13:05,046
the implementation are, you can still make use of those methods in the

204
00:13:05,068 --> 00:13:09,346
implementation of your function. So in the case of get balance, we're imagining reading

205
00:13:09,378 --> 00:13:13,066
some bytes out of the state and interpreting them as a

206
00:13:13,088 --> 00:13:16,886
U 128 value. So this get balance

207
00:13:16,918 --> 00:13:20,042
function is now totally generic over anything

208
00:13:20,096 --> 00:13:23,834
that implements I o. And in particular we can imagine implementing

209
00:13:23,882 --> 00:13:28,042
this for webassembly as well as native

210
00:13:28,106 --> 00:13:31,680
code. And these would look a little bit different because of the different

211
00:13:32,530 --> 00:13:35,970
implementations that are possible in those targets.

212
00:13:37,590 --> 00:13:41,486
So for example, on the indexer side maybe our implementation would be reading

213
00:13:41,518 --> 00:13:45,070
to a database on the disk, while on the webassembly side it

214
00:13:45,080 --> 00:13:49,446
would be calling to a host function like I mentioned before. But either way,

215
00:13:49,548 --> 00:13:53,558
after we've done those implementations, the getbalance function

216
00:13:53,644 --> 00:13:57,302
is now available and identical in

217
00:13:57,356 --> 00:14:01,162
both situations. So this code is generic and

218
00:14:01,216 --> 00:14:04,666
reusable in both cases. Now,

219
00:14:04,688 --> 00:14:08,234
of course, this particular example is a little bit silly, because get

220
00:14:08,272 --> 00:14:11,594
balance is just a one liner function, so you

221
00:14:11,712 --> 00:14:15,146
probably would imagine it wouldn't be that big of a deal to duplicate that logic

222
00:14:15,178 --> 00:14:18,254
in the two places instead of jumping through all of these type

223
00:14:18,292 --> 00:14:21,486
generic hoops. But this idea

224
00:14:21,668 --> 00:14:25,314
scales, right? It doesn't matter how complicated the get balance function is,

225
00:14:25,352 --> 00:14:28,654
and at some point it's complicated enough that you don't want to have to duplicate

226
00:14:28,702 --> 00:14:30,850
it into both places.

227
00:14:32,630 --> 00:14:35,906
So this is the whole point of the

228
00:14:36,008 --> 00:14:39,446
functional programming patterns. Let's take a step back and just

229
00:14:39,468 --> 00:14:43,410
talk about the big ideas here, because this really isn't about just rust

230
00:14:43,490 --> 00:14:47,240
or just blockchain. This is programming style in general.

231
00:14:47,870 --> 00:14:52,620
The code concept is when you're writing code

232
00:14:53,070 --> 00:14:56,700
for environment specific effects like reading and writing from state,

233
00:14:57,070 --> 00:15:00,554
you can abstract over them in your core

234
00:15:00,602 --> 00:15:03,934
business logic to make it pure. That is to

235
00:15:03,972 --> 00:15:07,886
say, it doesn't depend on the particular environment, it doesn't depend on

236
00:15:07,908 --> 00:15:11,226
any compilation target specific effects,

237
00:15:11,418 --> 00:15:15,006
and by factoring those things out, pushing them into

238
00:15:15,028 --> 00:15:19,646
a trait, and only having those trait implementations has the boundaries of your applications.

239
00:15:19,838 --> 00:15:23,234
The result is most of your code is easier to

240
00:15:23,272 --> 00:15:27,494
test and easier to maintain because it can

241
00:15:27,532 --> 00:15:31,314
be tested using in memory

242
00:15:31,442 --> 00:15:35,698
structures, right? Just different implementations of those traits

243
00:15:35,794 --> 00:15:39,130
that don't even actually do the effects.

244
00:15:40,110 --> 00:15:43,658
So in the case of storage, right, you could have

245
00:15:43,744 --> 00:15:47,158
just a simple hash map in memory that you're reading

246
00:15:47,174 --> 00:15:50,794
and writing for your

247
00:15:50,832 --> 00:15:54,270
tests, but still be able to test all of your business logic code,

248
00:15:54,340 --> 00:15:58,030
because again, it is agnostic to the details of that implementation,

249
00:15:58,450 --> 00:16:01,902
while in the production implementation you're actually using

250
00:16:01,956 --> 00:16:05,586
a real database. And again, all of the code

251
00:16:05,688 --> 00:16:09,122
that is being used with that database has still already

252
00:16:09,176 --> 00:16:13,886
been tested in this in memory environment.

253
00:16:14,078 --> 00:16:17,926
The other nice thing about all of this is

254
00:16:18,108 --> 00:16:21,202
this code is easier to reason about. You don't have to worry

255
00:16:21,266 --> 00:16:25,330
about are there going to be random side effects

256
00:16:25,410 --> 00:16:29,210
in particular parts of the code because they're all

257
00:16:29,360 --> 00:16:33,290
explicitly given in the type signatures. You can't

258
00:16:33,710 --> 00:16:37,350
do I O without having the I O trait

259
00:16:37,430 --> 00:16:41,014
present. If you're writing code that is generic,

260
00:16:41,062 --> 00:16:44,266
overall possible compilation target. So whenever

261
00:16:44,298 --> 00:16:47,854
you see a piece of code that doesn't have the I O

262
00:16:47,892 --> 00:16:51,054
trait on it, you know it's not doing any I O.

263
00:16:51,252 --> 00:16:54,846
And conversely, when you do see a function that has the I

264
00:16:54,868 --> 00:16:58,740
O trait, you know that some state is being used by that function.

265
00:16:59,350 --> 00:17:03,026
This is something that you might have heard before, has the principle of

266
00:17:03,048 --> 00:17:06,894
least authority, where the idea is that code should only have access

267
00:17:07,032 --> 00:17:10,342
to the minimum amount of capabilities that it actually

268
00:17:10,396 --> 00:17:13,654
needs to function. So code that doesn't need I O doesn't have

269
00:17:13,692 --> 00:17:17,350
I O, and similarly for other effects. Finally,

270
00:17:17,420 --> 00:17:20,538
this code is easier to reuse, and that is kind of

271
00:17:20,544 --> 00:17:23,786
the whole point of this talk. Once your code is

272
00:17:23,808 --> 00:17:27,674
written in this abstract way, you can use the same code

273
00:17:27,792 --> 00:17:31,546
for any different application that

274
00:17:31,568 --> 00:17:35,294
you need. So in the case that we're talking about, it's a smart contract and

275
00:17:35,332 --> 00:17:38,878
an indexer, but you can imagine that the same kind of thing would work.

276
00:17:38,964 --> 00:17:42,394
Say, if you had a web application and a mobile

277
00:17:42,442 --> 00:17:45,554
application, you could have the same rust code base at its

278
00:17:45,592 --> 00:17:48,994
core and compile it to webassembly. That gets used

279
00:17:49,032 --> 00:17:52,900
as part of a web app or down into

280
00:17:53,830 --> 00:17:57,334
a mobile code and used in your mobile app as well.

281
00:17:57,372 --> 00:18:00,886
And again, it would be the same idea where if you're abstracting over

282
00:18:01,068 --> 00:18:05,190
the FX, you don't need to worry about whether you're talking

283
00:18:05,260 --> 00:18:09,466
to a javascript wrapper in the browser or an

284
00:18:09,488 --> 00:18:13,306
Android operating system, for example. But all

285
00:18:13,328 --> 00:18:16,586
of that aside, let's get back to our

286
00:18:16,608 --> 00:18:19,994
main topic here. So at Aurora, we made

287
00:18:20,112 --> 00:18:23,966
use of these ideas, like I've been saying, to make an

288
00:18:23,988 --> 00:18:27,482
indexer out of a smart contract. So what is Aurora?

289
00:18:27,546 --> 00:18:31,322
Aurora is an ethereum scaling solution built on top of the near blockchain

290
00:18:31,386 --> 00:18:34,930
platform. I've got a couple links up on the slide if you want to

291
00:18:35,080 --> 00:18:38,414
read more about that and dig deeper.

292
00:18:38,542 --> 00:18:42,370
That's available. But for today's story,

293
00:18:42,520 --> 00:18:46,710
the part that is most important is Aurora's

294
00:18:47,690 --> 00:18:51,622
core product is this EVM, the Ethereum virtual machine we talked about before.

295
00:18:51,756 --> 00:18:56,082
But it's deployed as a smart contract on top of near uses

296
00:18:56,146 --> 00:18:59,042
webassembly as its blockchain VM,

297
00:18:59,186 --> 00:19:02,346
which means it's super powerful. Rust compiles to it,

298
00:19:02,368 --> 00:19:06,326
no problem, like we saw earlier. And you can write an implementation

299
00:19:06,358 --> 00:19:09,738
of the EVM in Rust, compile it to Webassembly. Now you have

300
00:19:09,744 --> 00:19:13,338
it as a smart contract on Nier, and that enables

301
00:19:13,354 --> 00:19:17,486
this whole scaling solution where now you're using Nier to run

302
00:19:17,588 --> 00:19:21,006
the EVM transactions instead of Ethereum itself.

303
00:19:21,108 --> 00:19:24,962
So you're benefiting from near's better

304
00:19:25,016 --> 00:19:28,370
scaling, the sharding and consensus and all this stuff.

305
00:19:28,440 --> 00:19:31,060
But again, out of scope for today,

306
00:19:32,870 --> 00:19:36,850
the most important detail to continue our story is Aurora

307
00:19:36,930 --> 00:19:40,950
claims to be compatible with Ethereum tooling,

308
00:19:41,370 --> 00:19:45,062
including the metamask wallet, the hard

309
00:19:45,116 --> 00:19:48,694
hat developer tool. And if these

310
00:19:48,812 --> 00:19:52,154
are not familiar to you, don't worry about it. Suffice it to say, these are

311
00:19:52,192 --> 00:19:56,566
tools that are very common in the Ethereum ecosystem,

312
00:19:56,678 --> 00:20:00,346
and they rely on a particular RPC, right? They rely on the

313
00:20:00,368 --> 00:20:03,758
RPC that Ethereum nodes would expose. So for Aurora to

314
00:20:03,764 --> 00:20:08,270
be compatible with them, it must also expose that same RPC interface.

315
00:20:08,930 --> 00:20:12,350
So there's sort of an obvious implementation on how to do this.

316
00:20:12,500 --> 00:20:15,806
We know that this thing is deployed on Nier, and Nier has its own RPC.

317
00:20:15,918 --> 00:20:20,318
So you can imagine a proxy which translates Ethereum

318
00:20:20,414 --> 00:20:24,194
RPC requests into the

319
00:20:24,232 --> 00:20:28,130
corresponding near RPC request that's talking to the Aurora contract,

320
00:20:28,290 --> 00:20:32,440
and then translates the response back. But as we've mentioned,

321
00:20:32,810 --> 00:20:36,550
this is quite slow. It involves multiple network hops,

322
00:20:37,290 --> 00:20:40,854
and so you may end up with lower latency with a higher latency

323
00:20:40,902 --> 00:20:44,662
than you want. The other issue is some of the RPC

324
00:20:44,726 --> 00:20:48,038
requests on Ethereum are fairly beefy.

325
00:20:48,134 --> 00:20:51,806
You can ask an Ethereum RPC node to simulate entire

326
00:20:51,908 --> 00:20:55,214
transactions, and if you're trying to do that on

327
00:20:55,332 --> 00:20:57,870
a network node inside of webassembly,

328
00:20:58,290 --> 00:21:01,920
it can be additional latency on top of the

329
00:21:02,550 --> 00:21:04,530
just simple network latency.

330
00:21:05,030 --> 00:21:08,180
So getting to the main point here,

331
00:21:08,790 --> 00:21:12,370
the way we can solve this is by writing an indexer

332
00:21:13,030 --> 00:21:16,834
that is actually able to function has this ethereum

333
00:21:16,882 --> 00:21:20,246
RPC. So again, because it needs to do

334
00:21:20,268 --> 00:21:23,750
this whole transaction simulation, needs to have

335
00:21:23,900 --> 00:21:27,334
all of the functionality of the aurora contract baked into

336
00:21:27,372 --> 00:21:30,890
it, and we're going to use the

337
00:21:30,960 --> 00:21:34,300
exact methods that we've just been talking about to make this possible.

338
00:21:35,470 --> 00:21:38,938
So all of this code is available on GitHub, it's all

339
00:21:38,944 --> 00:21:41,930
open source. I've got a link up on the slide if you ever want to

340
00:21:42,000 --> 00:21:44,878
go and take a look at it yourself. But we'll take a look at a

341
00:21:44,884 --> 00:21:48,126
few snippets and get a sense of what's going on here. So the

342
00:21:48,148 --> 00:21:51,662
code that's up on the screen right now is the

343
00:21:51,716 --> 00:21:55,506
real code out of the actual Aurora engine. So here's the

344
00:21:55,528 --> 00:21:58,766
actual implementation of get balance that I sort of gave a toy

345
00:21:58,798 --> 00:22:02,098
example of earlier. It's pretty similar to the toy example,

346
00:22:02,264 --> 00:22:05,780
with a few extra error handling things going on.

347
00:22:06,230 --> 00:22:09,090
And similarly for the setbalance,

348
00:22:10,390 --> 00:22:13,682
again, notice the IO type generic,

349
00:22:13,826 --> 00:22:18,422
right. We are using a read and a write on type

350
00:22:18,476 --> 00:22:22,070
that we don't actually know its concrete value, we only know its interface,

351
00:22:22,230 --> 00:22:25,446
and we can compose these together into more complicated functionality.

352
00:22:25,478 --> 00:22:28,970
So the add balance function uses both get and set together

353
00:22:29,120 --> 00:22:32,446
to add an amount to a balance. But again, you can see the

354
00:22:32,468 --> 00:22:36,174
I o trait is present so that it can be passed along to

355
00:22:36,292 --> 00:22:38,350
the other smaller functions.

356
00:22:40,610 --> 00:22:44,654
So let's look at what the implementation of this I o trait actually looks

357
00:22:44,692 --> 00:22:48,322
like. So this is for the webassembly side. Notice that

358
00:22:48,376 --> 00:22:52,114
the main struct we're interested in is just a singleton struct. It's just called

359
00:22:52,152 --> 00:22:55,634
runtime, as in the near runtime, as in it is running inside

360
00:22:55,672 --> 00:22:58,786
of wasm, and it's a singleton because it doesn't

361
00:22:58,818 --> 00:23:02,882
actually have any fields or state that are important. The implementation

362
00:23:02,946 --> 00:23:06,306
comes from the host functions that the near runtime

363
00:23:06,338 --> 00:23:10,362
exposes to us. So you can see in this implementation we're calling this storage read

364
00:23:10,416 --> 00:23:14,086
function. It's all fairly low level and the details

365
00:23:14,118 --> 00:23:17,882
aren't super important. The point is that we know that this host function

366
00:23:17,936 --> 00:23:21,658
exists and we can call it, and that gives us access to

367
00:23:21,744 --> 00:23:25,118
the storage. And the same thing, on the

368
00:23:25,124 --> 00:23:29,370
right side, there's a host function we can call it. We're passing in some pointers

369
00:23:29,450 --> 00:23:33,166
because it has to do with the host, reading out values from

370
00:23:33,188 --> 00:23:37,250
the WASM memory and writing the value

371
00:23:37,320 --> 00:23:40,980
into the actual underlying storage that the near node has.

372
00:23:41,590 --> 00:23:45,578
But again, details aside, it is implemented

373
00:23:45,614 --> 00:23:49,186
using these host functions and it satisfies the interface that we've

374
00:23:49,218 --> 00:23:53,078
defined. Now on the other side,

375
00:23:53,164 --> 00:23:56,726
the indexer side, this is native code, and it's a little more

376
00:23:56,748 --> 00:24:00,626
complicated. We have the last field, there is a database

377
00:24:00,658 --> 00:24:04,454
handle to a RocksDB database, because that's where the storage

378
00:24:04,502 --> 00:24:07,466
is actually going to be located in the case of the indexers. And I see

379
00:24:07,488 --> 00:24:13,062
a few other fields as well, because we want there to be conditional features

380
00:24:13,126 --> 00:24:16,474
that the RPC implementation has as

381
00:24:16,512 --> 00:24:20,142
compared to just smart contract. So for example,

382
00:24:20,196 --> 00:24:23,358
we needed to have access to the whole history of the state,

383
00:24:23,524 --> 00:24:27,650
not just the state, at any given moment in time. The reason is because

384
00:24:27,800 --> 00:24:31,058
when a user is accessing the Ethereum RPC, they can

385
00:24:31,064 --> 00:24:34,820
actually specify previous blocks to simulate their transaction against.

386
00:24:36,010 --> 00:24:39,638
And similarly, because we are interested in the

387
00:24:39,644 --> 00:24:43,382
potential of simulating transactions without actually committing them to the state,

388
00:24:43,516 --> 00:24:47,442
we need all of the changes to happen in memory instead

389
00:24:47,516 --> 00:24:50,874
of being eagerly written to the database. So that's what the

390
00:24:50,912 --> 00:24:55,020
transaction diff and output parts of the structure for.

391
00:24:55,630 --> 00:24:59,962
So this is what the read storage implementation looks

392
00:25:00,016 --> 00:25:03,440
like. Again, the details are not super important.

393
00:25:04,450 --> 00:25:08,186
What matters is that this is satisfying. Exactly the same interface,

394
00:25:08,298 --> 00:25:12,382
but the implementation details are different. So in this case we are taking

395
00:25:12,436 --> 00:25:15,614
a look at the in memory changes first.

396
00:25:15,732 --> 00:25:19,314
Again, because they weren't committed to the database, and if it's not

397
00:25:19,352 --> 00:25:22,786
present in there, that is, the key hasn't been written before in

398
00:25:22,808 --> 00:25:26,678
this transaction. Then we have to go back and look at the database. And the

399
00:25:26,684 --> 00:25:30,098
database has an iterator in it, because we are going backwards

400
00:25:30,194 --> 00:25:33,858
through the history to find the key value pair that's

401
00:25:33,874 --> 00:25:37,480
relevant. Similarly, on the right storage side,

402
00:25:38,510 --> 00:25:41,882
same kind of same point,

403
00:25:41,936 --> 00:25:45,754
right. It implements the interface that we've defined, but in

404
00:25:45,792 --> 00:25:49,338
this case it's writing to this in memory diff instead of writing to the

405
00:25:49,344 --> 00:25:53,374
database, or in the case of the webassembly calling

406
00:25:53,412 --> 00:25:56,814
a host function. But what's very

407
00:25:56,852 --> 00:26:00,320
cool about this, and you might be

408
00:26:00,770 --> 00:26:04,670
know Michael, there are webassembly

409
00:26:05,590 --> 00:26:09,678
standards that tell you what interfaces should look like for interacting

410
00:26:09,694 --> 00:26:12,914
with storage. You don't necessarily have to jump through all these hoops. But the point

411
00:26:12,952 --> 00:26:16,434
is that this isn't just about storage,

412
00:26:16,482 --> 00:26:19,762
it's about any kind of environment

413
00:26:19,826 --> 00:26:23,574
specific effect. Storage is one that we commonly think

414
00:26:23,612 --> 00:26:26,946
about. But in the blockchain world there are other effects

415
00:26:26,978 --> 00:26:31,162
that we care about as well, and they have analogies in other

416
00:26:31,296 --> 00:26:35,238
contexts too. So for example, the environment variables

417
00:26:35,414 --> 00:26:38,726
are things like what block height are we executing in, who signed

418
00:26:38,758 --> 00:26:43,006
this transaction, what time is it? All this kind of stuff is all set in

419
00:26:43,028 --> 00:26:47,054
the environment of the transaction's execution and is

420
00:26:47,092 --> 00:26:50,190
available in the webassembly contracts from host functions.

421
00:26:50,770 --> 00:26:54,074
But we still need to be able to access that stuff when we're simulating

422
00:26:54,122 --> 00:26:57,458
the transaction locally. So we have a trait that exposes all

423
00:26:57,464 --> 00:27:00,914
of the things that a user could potentially ask for,

424
00:27:01,112 --> 00:27:04,254
and we have a separate implementation for the indexer.

425
00:27:04,302 --> 00:27:08,134
In that implementation, the information comes out of

426
00:27:08,252 --> 00:27:11,400
the actual block that we're consuming. Or in the case of

427
00:27:12,170 --> 00:27:15,874
a user submitted simulated transaction, we just fill in default

428
00:27:15,922 --> 00:27:19,146
values for these. But you could also imagine an

429
00:27:19,168 --> 00:27:23,530
implementation where these were literally environment variables, as in system

430
00:27:23,600 --> 00:27:27,542
environment variables, right. Say we were writing some kind of CLI

431
00:27:27,606 --> 00:27:31,110
application to interact with this instead of making it as an RPC.

432
00:27:31,270 --> 00:27:34,494
Then you could read environment variables as part of that

433
00:27:34,532 --> 00:27:37,886
command line call to fill in this as well. Right.

434
00:27:37,908 --> 00:27:41,518
And that would be another implementation, which again our sort

435
00:27:41,524 --> 00:27:45,138
of core business logic is agnostic to, but opens up the opportunity

436
00:27:45,224 --> 00:27:48,766
for making these other applications. Similarly,

437
00:27:48,878 --> 00:27:52,690
there's this idea of promises, which is actually a near

438
00:27:52,760 --> 00:27:56,034
specific concept on

439
00:27:56,072 --> 00:27:59,030
most blockchains. Well, specifically on Ethereum,

440
00:27:59,450 --> 00:28:02,678
calls to other contracts are synchronous. They happen all in

441
00:28:02,684 --> 00:28:06,402
the same transaction and all at the same time in the same block.

442
00:28:06,546 --> 00:28:10,134
But on Nier, calls to other contracts are asynchronous.

443
00:28:10,182 --> 00:28:13,498
This has to do with the sharding model. Again, the details aren't super important,

444
00:28:13,664 --> 00:28:17,386
but suffice to say, this is another kind of effect that

445
00:28:17,488 --> 00:28:21,322
exists in the webassembly smart contract context,

446
00:28:21,466 --> 00:28:25,754
but doesn't exist in the case that we're running an indexer,

447
00:28:25,802 --> 00:28:29,440
right? Because the indexer only looks at the

448
00:28:30,210 --> 00:28:33,634
Aurora smart contract itself, it doesn't index the whole

449
00:28:33,672 --> 00:28:37,618
near environment. So it's actually not able to simulate these

450
00:28:37,784 --> 00:28:41,506
cross contract calls, but we can still factor them

451
00:28:41,528 --> 00:28:45,070
out as a trait and put in no op implementations

452
00:28:45,150 --> 00:28:48,854
for the case of the indexer. And this also works fine because

453
00:28:49,052 --> 00:28:52,754
most transactions on Aurora are contained within the EVM.

454
00:28:52,802 --> 00:28:56,738
Like I mentioned, the EVM tends to be this synchronous

455
00:28:56,914 --> 00:29:00,166
all in one block type transaction. So most of the time we

456
00:29:00,188 --> 00:29:03,402
don't actually need these, but sometimes we do,

457
00:29:03,456 --> 00:29:06,906
and therefore we need the code to handle it and we're still

458
00:29:06,928 --> 00:29:10,858
able to factor it out and do it sort of for real in quotation marks

459
00:29:10,874 --> 00:29:14,346
and webassembly and just no ops in the indexer,

460
00:29:14,378 --> 00:29:16,880
and have it also work totally fine.

461
00:29:19,090 --> 00:29:22,718
And all of this sort of builds up to huge

462
00:29:22,884 --> 00:29:27,070
complicated functions, right? So this is just the interface

463
00:29:27,150 --> 00:29:30,610
of the submit function. This is sort of the main entry point

464
00:29:30,680 --> 00:29:34,366
for users when they send an EVM transaction

465
00:29:34,398 --> 00:29:37,974
to Aurora. And so you can see we've composed together all these

466
00:29:38,012 --> 00:29:41,766
different kinds of effects. We've got the I O for storage access,

467
00:29:41,868 --> 00:29:45,778
the environment variables that are present, and the possibility

468
00:29:45,874 --> 00:29:48,726
of calling other near contracts.

469
00:29:48,918 --> 00:29:52,234
Now if I left the implementation off, because again

470
00:29:52,272 --> 00:29:55,546
the details aren't really what's important here, but the

471
00:29:55,568 --> 00:29:57,978
point is that this is a relatively large,

472
00:29:58,064 --> 00:30:02,030
relatively complicated function with multiple lines of code, and having

473
00:30:02,100 --> 00:30:05,914
to duplicate it between both the indexer

474
00:30:06,042 --> 00:30:09,646
and the smart contract would have been too big of

475
00:30:09,668 --> 00:30:13,362
a maintenance burden and wouldn't have made sense. But because

476
00:30:13,416 --> 00:30:16,642
we can write this abstract code that is reusable for both,

477
00:30:16,776 --> 00:30:20,738
it enables us to have this indexer as

478
00:30:20,904 --> 00:30:24,290
RPC. So as a final

479
00:30:24,360 --> 00:30:28,082
point here, this is what the actual RPC

480
00:30:28,146 --> 00:30:30,914
code looks like, or part of it anyways.

481
00:30:31,042 --> 00:30:34,934
So there's a particular RPC method for Ethereum RPCs called

482
00:30:34,972 --> 00:30:38,318
ETh underscore estimate gas. This is one of those transaction

483
00:30:38,434 --> 00:30:41,580
simulation RPC methods that I've been referring to.

484
00:30:42,110 --> 00:30:45,834
And this is sort of, it's only

485
00:30:45,872 --> 00:30:50,494
a snippet, it's not the full implementation, but this is sort of the main points

486
00:30:50,612 --> 00:30:54,160
of what's going on. We have to set up the

487
00:30:54,530 --> 00:30:58,414
structs that implement the traits that we've set out,

488
00:30:58,452 --> 00:31:01,866
right. So this is the environment

489
00:31:01,978 --> 00:31:06,334
variables. You can see we're setting default values because it's

490
00:31:06,462 --> 00:31:10,386
just fixed. In this case it's just a simulation. And then

491
00:31:10,408 --> 00:31:14,302
we also have the engine access struct

492
00:31:14,366 --> 00:31:17,990
that we saw on an earlier slide, and we're accessing it at a particular

493
00:31:18,060 --> 00:31:21,842
block height and transaction position because again the user can specify

494
00:31:21,906 --> 00:31:26,034
those things in their request. And the actual implementation

495
00:31:26,082 --> 00:31:29,266
of this, which I've left off the slide because again the details

496
00:31:29,298 --> 00:31:33,062
aren't important is a closure

497
00:31:33,126 --> 00:31:36,714
that accepts this I O object. So now it's got access to the MV object

498
00:31:36,752 --> 00:31:40,702
and the I O object, and it can call methods like submit. And again,

499
00:31:40,756 --> 00:31:44,366
the point is that it's not duplicating any

500
00:31:44,388 --> 00:31:47,614
of that complicated logic that exists in

501
00:31:47,732 --> 00:31:51,258
sort of our functional programming generic core.

502
00:31:51,354 --> 00:31:54,980
It just calls the method submit and then does something with the result.

503
00:31:57,030 --> 00:31:59,250
So in conclusion,

504
00:32:00,390 --> 00:32:03,746
at the highest level, the thing that

505
00:32:03,768 --> 00:32:06,566
I want you to take away from this talk is that you can write your

506
00:32:06,588 --> 00:32:10,466
business logic in a way that uses pure

507
00:32:10,578 --> 00:32:14,070
reusable code by abstracting away platform specific

508
00:32:14,140 --> 00:32:17,366
effects. And as a nice side effect, this code is

509
00:32:17,388 --> 00:32:19,930
actually easier to test and to maintain.

510
00:32:20,670 --> 00:32:24,246
In this particular talk, we were using Rust as our programming

511
00:32:24,278 --> 00:32:27,958
language of choice, and Rust can accomplish this using traits

512
00:32:28,054 --> 00:32:31,950
and type generics along with a little bit of conditional compilation.

513
00:32:32,450 --> 00:32:36,430
And for the specific example of this that we talked about today,

514
00:32:36,500 --> 00:32:40,158
it was in the blockchain context where Aurora has

515
00:32:40,244 --> 00:32:43,554
the EVM smart contracts that is able to also be

516
00:32:43,592 --> 00:32:47,006
an indexer and share a code base, and this enables

517
00:32:47,038 --> 00:32:50,334
their low latency RPC

518
00:32:50,382 --> 00:32:54,226
for Ethereum compatibility. But as I mentioned before,

519
00:32:54,328 --> 00:32:57,714
there are other possible applications for this. For example, using the same

520
00:32:57,752 --> 00:33:01,574
code in web and mobile applications, I'm sure you can come up with

521
00:33:01,612 --> 00:33:04,918
other examples based on your own fields of interest.

522
00:33:05,004 --> 00:33:08,650
Maybe you're working in embedded devices and you want to share a code base between

523
00:33:08,800 --> 00:33:11,990
the embedded version and say, the simulated

524
00:33:12,070 --> 00:33:14,810
version of your hardware, et cetera.

525
00:33:15,390 --> 00:33:19,430
Again, the main point is functional programming patterns

526
00:33:19,510 --> 00:33:22,766
enable you to reuse code in a way you may not be able

527
00:33:22,788 --> 00:33:26,286
to otherwise. Thank you all

528
00:33:26,308 --> 00:33:29,806
for your attention. Got some links up on the slide here. If you

529
00:33:29,828 --> 00:33:33,582
want to read more about near or Aurora. If you want to learn more about

530
00:33:33,636 --> 00:33:37,658
me, you can get in touch with me directly on Telegram at BirchMD.

531
00:33:37,834 --> 00:33:40,766
Or if you want to take a look at other code that I've worked on,

532
00:33:40,788 --> 00:33:44,462
you can check out my GitHub under that same username. And I also have

533
00:33:44,516 --> 00:33:47,990
a blog that I occasionally write to on my website,

534
00:33:48,060 --> 00:33:51,446
Typedriven CA, and I write about mostly rust and

535
00:33:51,468 --> 00:33:54,120
mirror, but some other stuff occasionally as well.

536
00:33:54,490 --> 00:33:56,500
Thank you for your time. See you later.

