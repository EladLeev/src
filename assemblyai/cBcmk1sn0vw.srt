1
00:00:30,850 --> 00:00:34,822
Hi everyone, and welcome to this talk about building automated quality yet into

2
00:00:34,876 --> 00:00:38,406
your CI pipelines. And I'm glad that you've decided to come and

3
00:00:38,428 --> 00:00:42,246
attend this talk because in my opinion, when it comes to building CI pipelines or

4
00:00:42,268 --> 00:00:45,606
anything DevOps related, we tend to often focus on all

5
00:00:45,628 --> 00:00:48,786
the technical natures around how to build the pipelines, the different sort of codes,

6
00:00:48,818 --> 00:00:51,662
what sort of coding principle do we have, what sort of tools are we using

7
00:00:51,716 --> 00:00:55,246
to be able to better design our CI pipelines? But we

8
00:00:55,268 --> 00:00:58,366
often forget about the quality aspect of it. And I'm not just talking about the

9
00:00:58,388 --> 00:01:01,502
software testing part, but sometimes the deeper sort of quality.

10
00:01:01,556 --> 00:01:05,342
Gates, how do we ensure and maintain quality? We often

11
00:01:05,396 --> 00:01:09,234
have these QA divisions or these software testers, and we've kind of

12
00:01:09,272 --> 00:01:12,994
separated the individual part of it as opposed to what we can actually

13
00:01:13,032 --> 00:01:17,378
build and automate through our pipelines and use our pipelines as well to help control

14
00:01:17,544 --> 00:01:20,966
our software quality. So that's what I want to talk about today, and I hope

15
00:01:20,988 --> 00:01:25,062
that you really enjoy this conversation because it's something that I believe is

16
00:01:25,116 --> 00:01:28,834
really important and really useful in the software testing and software

17
00:01:28,882 --> 00:01:32,310
development world. But before I go any further,

18
00:01:32,470 --> 00:01:36,294
I want to just firstly, briefly introduce myself. My name is Craig

19
00:01:36,342 --> 00:01:40,150
Reezy. I work for a company called RepL, which is part of Accenture,

20
00:01:40,230 --> 00:01:44,014
where I work as a software architect focused primarily around

21
00:01:44,052 --> 00:01:46,670
test, automated and software testing.

22
00:01:47,010 --> 00:01:50,526
I also do board games as well. So I also have my

23
00:01:50,548 --> 00:01:54,318
own board game company called Risky Games, where you can go and download some of

24
00:01:54,324 --> 00:01:58,162
my board games and then also have a book out called quality by design

25
00:01:58,296 --> 00:02:01,954
where I write a lot about software testing, but then also how do we

26
00:02:01,992 --> 00:02:05,666
design and build software to be of a better quality? So if

27
00:02:05,688 --> 00:02:08,374
that's something that's interested in you, where you want to learn more about how to

28
00:02:08,412 --> 00:02:11,926
design software from the ground up to be of high quality, it's something which

29
00:02:11,948 --> 00:02:15,734
I'd recommend you going to read, but yeah,

30
00:02:15,852 --> 00:02:19,686
let's go back to my topic. But if you're wondering where

31
00:02:19,708 --> 00:02:22,886
my accent comes from as well, I'd like to just say that I am

32
00:02:22,908 --> 00:02:26,534
from Cape Town, South Africa. So I thought I'd just share a few pictures

33
00:02:26,582 --> 00:02:29,578
with you from my beautiful city and my beautiful country, which I'm really proud to

34
00:02:29,584 --> 00:02:32,746
be a part of and really would encourage you to visit this

35
00:02:32,768 --> 00:02:36,878
part of the world if you really want to see something that's incredibly beautiful and

36
00:02:36,964 --> 00:02:40,398
something different, really something which I'd encourage you to do. And all

37
00:02:40,404 --> 00:02:43,786
of these pictures are from the city alone.

38
00:02:43,818 --> 00:02:46,254
So this is not even something where I need to travel outside of my city

39
00:02:46,292 --> 00:02:48,754
to be able to get to see all these things. So really grateful and really

40
00:02:48,792 --> 00:02:52,820
thankful to be able to be a part of such a beautiful city.

41
00:02:53,670 --> 00:02:57,186
But let's get back to the idea of quality gates. So what

42
00:02:57,208 --> 00:03:00,038
is a quality gate? And I would really like to think of it as kind

43
00:03:00,044 --> 00:03:03,574
of more of like a check control. So we think in QA we often

44
00:03:03,612 --> 00:03:07,254
think of checkboxes and things that we need to take off or some form

45
00:03:07,292 --> 00:03:10,562
of entry and exit criteria that we need to meet to be able to ensure

46
00:03:10,706 --> 00:03:14,278
that this stage of quality, this stage of the software development

47
00:03:14,374 --> 00:03:17,482
we're happy with and we're ready to take it on. And now we want to

48
00:03:17,536 --> 00:03:21,260
move it forward. And it's a really important aspect of

49
00:03:21,950 --> 00:03:25,758
software development from a quality perspective is having sort of checks and

50
00:03:25,764 --> 00:03:29,486
balances in place to make sure that we've covered certain angles that

51
00:03:29,508 --> 00:03:33,438
we've tested enough here before we can move it on. And I really

52
00:03:33,604 --> 00:03:36,546
like to think about it more as like passing on a ball. So I think

53
00:03:36,568 --> 00:03:39,838
we're all familiar with the typical SDLC, whether it be waterfall,

54
00:03:39,854 --> 00:03:43,266
whether it be agile. Most often it's quite iterative, which is why

55
00:03:43,288 --> 00:03:46,866
in this particular picture I've shown a loop. But in everything, we kind of

56
00:03:46,888 --> 00:03:49,942
have to say, okay, well, we've now analyzed the story. We're now going to start

57
00:03:49,996 --> 00:03:53,640
planning design in everything. We're kind of passing the ball on

58
00:03:54,010 --> 00:03:57,094
to the next sort of phase. And yes, there are things where you can do

59
00:03:57,132 --> 00:04:00,386
certain things at the same time. You can do aspects of your development and testing.

60
00:04:00,418 --> 00:04:04,742
At the same time you can often do aspects of your deployment along

61
00:04:04,796 --> 00:04:07,986
with some of your maintenance and your evaluation. And some of these things can bleed

62
00:04:08,018 --> 00:04:11,438
into each other. But the point is that all move along and they might be

63
00:04:11,444 --> 00:04:14,814
iterative, but you got to be able to say, at what point in time am

64
00:04:14,852 --> 00:04:17,982
I finished with this analysis so that we're ready to start planning this function?

65
00:04:18,036 --> 00:04:21,438
And at what point in time can we say that our design is done so

66
00:04:21,444 --> 00:04:24,046
that we're happy to hand this over to our development team so that they can

67
00:04:24,068 --> 00:04:26,866
start working with it? And we've got to pass this ball on.

68
00:04:26,968 --> 00:04:31,106
And at each of these stages there is really a level of quality

69
00:04:31,288 --> 00:04:35,154
that we want to be able to say is done, or we can call

70
00:04:35,192 --> 00:04:39,380
it a definition of done in the agile world where we're like, now this particular

71
00:04:39,830 --> 00:04:43,298
task has been done and I'm ready to pass it on to the next phase.

72
00:04:43,394 --> 00:04:46,486
And that's really what we're trying to do with quality gates. It's really being able

73
00:04:46,508 --> 00:04:50,246
to say that we've now checked that we're happy with the quality of

74
00:04:50,268 --> 00:04:53,626
this work that's been delivered and we're ready to pass it on to

75
00:04:53,648 --> 00:04:57,002
the next phase. The difference though, is that this is not something

76
00:04:57,056 --> 00:05:00,122
where again, we want to have a manual checkpoint. What I want to talk about

77
00:05:00,176 --> 00:05:03,374
now is really something that can actually be driven by

78
00:05:03,412 --> 00:05:06,298
your CI CD pipelines.

79
00:05:06,394 --> 00:05:09,774
Because we want software to work quickly. And typically, when we think of

80
00:05:09,812 --> 00:05:13,406
all these different change controls, these different sort

81
00:05:13,428 --> 00:05:16,190
of quality gates, these checkboxes,

82
00:05:16,530 --> 00:05:20,178
we can often think this is over regulated. There is too much

83
00:05:20,344 --> 00:05:23,362
process going on here and that's a bad thing. And we try and stay away

84
00:05:23,416 --> 00:05:26,580
and move away from process because it slows us down.

85
00:05:27,350 --> 00:05:30,630
But those processes and those sort of measures that we need are good things.

86
00:05:30,700 --> 00:05:34,786
We need quality control. We need to have a measure

87
00:05:34,818 --> 00:05:38,914
of being able to say that this really meets our quality expectations versus

88
00:05:38,962 --> 00:05:42,394
it doesn't. But what I really want to talk about in today's talk is

89
00:05:42,432 --> 00:05:46,166
how we can actually automate that so we don't have to think about it slowing

90
00:05:46,198 --> 00:05:50,374
us down, but rather something where using our CI CD pipelines correctly,

91
00:05:50,422 --> 00:05:53,886
we can build in the right controls that can help speed us up and

92
00:05:53,908 --> 00:05:57,738
it can actually move us to actually moving faster because our testing

93
00:05:57,754 --> 00:06:01,534
and quality control is no longer slowing us down, but it's actually an important

94
00:06:01,652 --> 00:06:05,330
part of what it is that we do, an important aspect of how we're moving

95
00:06:05,400 --> 00:06:07,490
forward with our software.

96
00:06:10,150 --> 00:06:12,978
And that's really the why. So when I think about why quality gates, I think

97
00:06:12,984 --> 00:06:15,678
it's really about how do we get things moving quicker.

98
00:06:15,694 --> 00:06:19,054
So it's about how do we automatically measure acceptance criteria.

99
00:06:19,102 --> 00:06:22,422
So we have the acceptance criteria, but how do we

100
00:06:22,476 --> 00:06:25,270
create a way of being able to automate it so that we remove that human

101
00:06:25,340 --> 00:06:29,234
checkpoints that can sometimes slow us down. It's about driving

102
00:06:29,282 --> 00:06:32,506
a whole sort of shift left mindset. I think many

103
00:06:32,528 --> 00:06:35,946
of us are familiar with the idea of shifting left, which is really how

104
00:06:35,968 --> 00:06:40,406
do we start testing sooner? How do we get testing

105
00:06:40,438 --> 00:06:43,754
sooner and sooner in the process? And by having quality gates and actually

106
00:06:43,792 --> 00:06:47,786
automating those quality gates, you can drive that process because you can put measures

107
00:06:47,818 --> 00:06:51,502
in place that kind of help the team and ensure that the team has actually

108
00:06:51,556 --> 00:06:55,022
done these things. They have actually thought about certain quality measures before

109
00:06:55,076 --> 00:06:58,734
you move it forward. And a really good way of being able to start driving

110
00:06:58,782 --> 00:07:02,366
and moving tests into that shift left mindset is to actually utilize your CI CD

111
00:07:02,398 --> 00:07:06,402
pipeline so that even developers, when they're now needing to building things in their code,

112
00:07:06,456 --> 00:07:09,574
they've now got to hit certain standards before it can move on. So it really

113
00:07:09,612 --> 00:07:13,122
encourages a team to adopt that proper shift lift mindset.

114
00:07:13,266 --> 00:07:17,174
It's definitely going to safeguard your quality and

115
00:07:17,212 --> 00:07:20,626
prevent things further down the line. If you speak to any tester

116
00:07:20,658 --> 00:07:23,766
and you ask them what's the most frustrating part of part of software development,

117
00:07:23,798 --> 00:07:27,034
they'll often tell you the crunch when it gets to the end.

118
00:07:27,232 --> 00:07:30,506
They've maybe estimated and planned so much work that needs to get done with any

119
00:07:30,528 --> 00:07:34,510
given sprint within any sort of deliverable or project. But inevitably

120
00:07:35,010 --> 00:07:38,506
that gets taken up with a variety of reasons. Things get delayed,

121
00:07:38,538 --> 00:07:42,206
get delayed, and now testers have kind of got to fit a

122
00:07:42,228 --> 00:07:45,694
whole lot of testing into a lot smaller space. And then they get even more

123
00:07:45,732 --> 00:07:49,090
impacted by the fact that often they're now working with things and they're quickly

124
00:07:49,160 --> 00:07:52,286
finding issues and defects on the software. And that's

125
00:07:52,318 --> 00:07:55,682
just making things even more difficult. When you have

126
00:07:55,736 --> 00:07:58,926
automated quality gates in place, you actually are

127
00:07:58,968 --> 00:08:02,454
safeguarding the quality, you're preventing later defects from

128
00:08:02,492 --> 00:08:05,878
getting introduced, so that when the testers do start taking over, things are in a

129
00:08:05,884 --> 00:08:10,842
much better space. It prevents a lot of that sort of crunch time and

130
00:08:10,896 --> 00:08:15,100
really helps the testing to actually move forward because you can start to

131
00:08:15,550 --> 00:08:19,114
actually align a lot of what's needed from a testing perspective into even their

132
00:08:19,152 --> 00:08:23,146
automation perspective. So you'll find that it's not just that the

133
00:08:23,248 --> 00:08:26,654
quality of the software is getting better, it's that the tests are in a better

134
00:08:26,692 --> 00:08:30,046
space where they're able to automate at the same point in time. And so when

135
00:08:30,068 --> 00:08:33,966
it comes to them doing their work, there's not this huge rush to

136
00:08:33,988 --> 00:08:37,866
try and do both. It's really about being able to then focus on

137
00:08:37,908 --> 00:08:41,278
properly doing quality assurance on the software, because they've already covered

138
00:08:41,294 --> 00:08:43,426
a lot of the automation that needs to get done, a lot of the other

139
00:08:43,448 --> 00:08:46,478
sort of technical work that is needed. And overall,

140
00:08:46,574 --> 00:08:49,970
I think what it does is it really ensures proactive

141
00:08:50,050 --> 00:08:53,362
quality. A lot of times when it comes to software

142
00:08:53,426 --> 00:08:56,694
testing, we can be very reactive. The testers go,

143
00:08:56,732 --> 00:08:59,926
they take the software, they deploy the software, they use

144
00:08:59,948 --> 00:09:02,666
the software, they find issues, you got to go back, fix it. And it's this

145
00:09:02,688 --> 00:09:06,362
iterative sort of cycle. It's often going

146
00:09:06,416 --> 00:09:08,826
back and it's trying to fix things in hindsight and then try and say,

147
00:09:08,848 --> 00:09:12,086
well, what do we do to kind of, why do we make this mistake?

148
00:09:12,118 --> 00:09:15,914
What do we do to try and fix it now, rather than trying to prevent

149
00:09:15,962 --> 00:09:19,930
defects from happening. And when you have proper quality gates

150
00:09:20,010 --> 00:09:23,950
within your software you can almost prevent those defects from happening

151
00:09:24,020 --> 00:09:27,186
because you can build automated measures that can say, well look, last time we

152
00:09:27,208 --> 00:09:31,090
had this issue because of this particular mistake, you can actually go and build

153
00:09:31,240 --> 00:09:34,578
a quality gates that can check for that. So the

154
00:09:34,584 --> 00:09:37,778
next time Azure software is getting deployed or built to be able

155
00:09:37,784 --> 00:09:41,142
to catch that and say, hang on, we can't allow that

156
00:09:41,196 --> 00:09:44,598
because we need to ensure that something is being tested correctly or

157
00:09:44,604 --> 00:09:48,550
that we have the right measures in place and it can really prevent quality issues

158
00:09:48,620 --> 00:09:52,502
coming in. And that really helps you to ensure that you're actually preventing

159
00:09:52,566 --> 00:09:56,634
and you're actually building quality along the way in the process as

160
00:09:56,672 --> 00:09:59,946
opposed to this constant thing of throwing things

161
00:09:59,968 --> 00:10:02,898
to testing. Testing is finding issues, sending it back and back and forth,

162
00:10:02,934 --> 00:10:05,466
back and forth, and that slows teams down a lot. And I would say that's

163
00:10:05,498 --> 00:10:09,450
probably where most software projects

164
00:10:09,610 --> 00:10:14,970
overrun. It's that constant back and forth, whether it's between software

165
00:10:15,050 --> 00:10:18,626
developers and the testers or maybe issues with

166
00:10:18,648 --> 00:10:22,398
requirements, we haven't quite established those things. Those are the things that slow teams

167
00:10:22,414 --> 00:10:25,554
down because there's constant scope, there's constant need to fix

168
00:10:25,592 --> 00:10:28,558
and adjust what you're working on because you got to go back and fix older

169
00:10:28,574 --> 00:10:32,514
mistakes. And by having quality gates in place you can prevent

170
00:10:32,562 --> 00:10:35,734
a lot of those things from happening. So it can actually speed you

171
00:10:35,772 --> 00:10:39,174
up and really make you a more efficient team. So yeah,

172
00:10:39,212 --> 00:10:42,966
there's really important reasons as to why we should be considering quality gates

173
00:10:43,078 --> 00:10:46,330
in our software projects. So what does it need?

174
00:10:46,400 --> 00:10:50,442
So it's one thing saying, okay, this is what quality gates is, this is why

175
00:10:50,496 --> 00:10:54,080
we need them. And before we even get to the point of

176
00:10:54,610 --> 00:10:57,998
what specifically are we trying to build quality around and

177
00:10:58,004 --> 00:11:01,134
what do these gates look like? It's also important to understand that there are

178
00:11:01,172 --> 00:11:04,498
some building blocks to put in place before you even want to

179
00:11:04,504 --> 00:11:08,050
consider quality gates. I think one of those first things that we need to really

180
00:11:08,120 --> 00:11:12,414
work towards well defined and clear completion

181
00:11:12,462 --> 00:11:15,558
criteria. I think when we allow a

182
00:11:15,564 --> 00:11:19,874
lot of ambiguity into our software development

183
00:11:19,922 --> 00:11:23,718
processes, we're opening up our teams to develop

184
00:11:23,804 --> 00:11:27,750
software that doesn't work as expected. We open up our teams to

185
00:11:27,820 --> 00:11:31,462
build software where they're not so sure

186
00:11:31,596 --> 00:11:34,986
all the things that need to be tested because it's not really clear what

187
00:11:35,008 --> 00:11:38,554
this is supposed to do. And so when we don't have that in place,

188
00:11:38,592 --> 00:11:42,214
it's very difficult to build anything that's automated because there's so much flux

189
00:11:42,262 --> 00:11:45,514
that we're still trying to figure things out and we actually

190
00:11:45,632 --> 00:11:49,006
don't know what is good enough quality. We don't even know what to test and

191
00:11:49,028 --> 00:11:51,934
how to test these things because we're still figuring all these things out. And if

192
00:11:51,972 --> 00:11:54,958
you're in a state with your software where that's kind of where you're at with

193
00:11:54,964 --> 00:11:58,318
your team, it might be a little difficult to try and automate your quality gates,

194
00:11:58,414 --> 00:12:01,762
because what you really then want to focus on is rather how do we get

195
00:12:01,816 --> 00:12:04,926
better at defining things like our completion criteria

196
00:12:04,958 --> 00:12:08,406
and saying, look, this is actually what our requirements look like. We've actually defined this

197
00:12:08,428 --> 00:12:12,386
a little bit more clearly. Clearly this is actually what's

198
00:12:12,418 --> 00:12:16,438
needed to be say that this step of the process is properly done

199
00:12:16,524 --> 00:12:19,674
and you really want to be able to have that in place. I think that

200
00:12:19,712 --> 00:12:23,130
the next thing is to have a testable architecture.

201
00:12:25,630 --> 00:12:29,238
We need to build software that can be clearly tested.

202
00:12:29,414 --> 00:12:33,594
There's no point building software that might

203
00:12:33,632 --> 00:12:36,286
work well in terms of being able to get something out the door as fast

204
00:12:36,308 --> 00:12:39,326
as possible, but there's a lot of things where you're like, we're not too sure

205
00:12:39,348 --> 00:12:42,926
how to test this particular part of the application and then you can't really

206
00:12:42,948 --> 00:12:46,146
building a measure to be able to test. Have we

207
00:12:46,168 --> 00:12:47,810
tested this effectively?

208
00:12:49,510 --> 00:12:52,978
Have we written the right amount of automation scripts for it to run within our

209
00:12:52,984 --> 00:12:56,018
pipelines? Because we actually haven't made it testable enough to be

210
00:12:56,024 --> 00:13:00,050
able to do all these things. And if we're not creating software that's testable,

211
00:13:00,210 --> 00:13:03,798
we're really robbing our teams of the ability to

212
00:13:03,804 --> 00:13:08,214
be able to build anything that can be really

213
00:13:08,252 --> 00:13:11,638
effective within the CI CD pipelines anyway. But then we're also robbing the teams

214
00:13:11,654 --> 00:13:15,514
of being able to utilize something like quality gates because we can't really

215
00:13:15,552 --> 00:13:18,826
accurately test our architecture. So it's important to make

216
00:13:18,848 --> 00:13:21,946
sure that when you're designing your software that you consider testing. And how is this

217
00:13:21,968 --> 00:13:25,070
going to be tests. And when I say testing,

218
00:13:25,570 --> 00:13:29,066
yes, there's the unit testing, yes, there's sort of your integration,

219
00:13:29,098 --> 00:13:33,114
your UI testing or your API testing. It's the whole thing, it's all encompassing.

220
00:13:33,162 --> 00:13:36,366
How do you test the thing across every different phase of your

221
00:13:36,388 --> 00:13:40,274
software? Have you considered that? And so that's something to think about.

222
00:13:40,312 --> 00:13:43,474
I'm not going to delve too much deeper into what testable architecture is.

223
00:13:43,592 --> 00:13:47,346
It's really something I'd encourage you to work out and to

224
00:13:47,368 --> 00:13:50,406
research yourself, but it's something that you need to have in place and I think

225
00:13:50,428 --> 00:13:53,942
a good guideline while I'm at this point, if you ever want to know if

226
00:13:53,996 --> 00:13:57,586
your software architecture is testable, it's to try write unit

227
00:13:57,618 --> 00:14:01,154
tests for every single part of your software.

228
00:14:01,202 --> 00:14:04,554
And if you can't write a really good unit test, that can give

229
00:14:04,592 --> 00:14:07,866
you a good 90% to 100% code coverage on a particular part

230
00:14:07,888 --> 00:14:11,178
of your architecture, there's a good chance that it's not testable enough and you've got

231
00:14:11,184 --> 00:14:14,446
to rethink your design. So just something to keep in mind. With that,

232
00:14:14,468 --> 00:14:17,386
obviously comes a strong focus on unit testing.

233
00:14:17,578 --> 00:14:21,086
We can't have this thing where developers are pushing things through

234
00:14:21,108 --> 00:14:25,226
our CI CD pipelines that haven't really been unit

235
00:14:25,258 --> 00:14:28,546
tested properly. We can't think we're going to push this through the pipelines. We've got

236
00:14:28,568 --> 00:14:31,266
quality control for a reason. They're going to go and check the software. They've got

237
00:14:31,288 --> 00:14:34,706
automation scripts that can run and pick things up. That's not

238
00:14:34,728 --> 00:14:39,942
really helpful because a lot of things that work

239
00:14:39,996 --> 00:14:43,698
better from a unit testing perspective. And again, this is not a talk about unit

240
00:14:43,714 --> 00:14:47,174
testing and how to write

241
00:14:47,292 --> 00:14:50,790
better and more detailed unit tests or things to cover in unit tests or not.

242
00:14:50,940 --> 00:14:54,346
But if you're not going to have a strong focus of unit testing, where your

243
00:14:54,368 --> 00:14:57,754
developers are writing a lot of unit tests to ensure that the individual aspects of

244
00:14:57,792 --> 00:15:01,430
code are working correctly, you're going to push

245
00:15:01,510 --> 00:15:05,246
a lot of your test automation requirements down the

246
00:15:05,268 --> 00:15:08,574
line. And if you think about your CI CD pipelines, no one

247
00:15:08,612 --> 00:15:12,206
wants their CI CD pipelines to be running for hours and hours

248
00:15:12,228 --> 00:15:15,290
and hours before they get feedback on was this successful?

249
00:15:15,450 --> 00:15:17,858
And the only way to really do that is to ensure that there is a

250
00:15:17,864 --> 00:15:21,198
lot of unit testing place, because then really, when you're building your software straight

251
00:15:21,214 --> 00:15:25,362
away, the moment you're actually doing that sort of code, commit those

252
00:15:25,416 --> 00:15:28,398
first few minutes where it's actually building the code and running the unit test,

253
00:15:28,504 --> 00:15:31,766
it's really giving you immediate feedback. And if you can cover a lot of

254
00:15:31,788 --> 00:15:36,200
testing in that space, you really reduce the need for the

255
00:15:36,570 --> 00:15:39,986
more complicated integration into an automated tests,

256
00:15:40,018 --> 00:15:43,534
which are very effective and needed, but take a long time to execute.

257
00:15:43,602 --> 00:15:47,146
So you want to again reduce the cycles and reduce how long it takes you

258
00:15:47,168 --> 00:15:50,026
to be able to develop the software, and that's a really good way of being

259
00:15:50,048 --> 00:15:53,078
able to do that. So have a strong focus on unit tests.

260
00:15:53,254 --> 00:15:56,446
Obviously, you're still going to have those automated integration tests. You need

261
00:15:56,468 --> 00:15:59,806
to have automation throughout every aspect of your pipeline. We can't talk

262
00:15:59,828 --> 00:16:03,166
about automating quality gates if we haven't automated our tests. So we need to think

263
00:16:03,188 --> 00:16:06,378
about test automation through every process, but it's

264
00:16:06,394 --> 00:16:09,378
important to be able to have that strong base of unit testing and then on

265
00:16:09,384 --> 00:16:12,820
top of that, start having your other automated tests kick in.

266
00:16:13,590 --> 00:16:17,234
It also works best with small, frequent releases, which is really

267
00:16:17,272 --> 00:16:20,678
what CI CD is designed for. If you're going

268
00:16:20,684 --> 00:16:24,502
to be building software where it's only going to be released once

269
00:16:24,556 --> 00:16:27,638
every year, 18 months, and you're not going to have a lot of iteration in

270
00:16:27,644 --> 00:16:30,582
it, CI CD is really not for you anyway.

271
00:16:30,636 --> 00:16:34,262
And to really make use of this and to make use of your quality gates

272
00:16:34,326 --> 00:16:37,642
effectively, you really want to be able to have something where you have small,

273
00:16:37,696 --> 00:16:41,322
frequent releases. You don't want to work with big software. Now you're trying to turn

274
00:16:41,376 --> 00:16:45,758
over big software and big changes on

275
00:16:45,764 --> 00:16:48,414
a regular basis, and then you're trying to rush the process. It can be very

276
00:16:48,452 --> 00:16:51,866
difficult to automate something that's big, but it's a lot easier

277
00:16:51,898 --> 00:16:55,294
when you're working with smaller, more componentized software where

278
00:16:55,332 --> 00:16:58,622
you can make small iterative changes. It's a lot easier to implement

279
00:16:58,686 --> 00:17:02,098
quality gates, be able to check your quality systems, and to be

280
00:17:02,104 --> 00:17:04,674
able to move forward. And I think that last step is a very important thing

281
00:17:04,712 --> 00:17:08,790
to get into next when it comes to thinking about software development.

282
00:17:09,770 --> 00:17:12,646
And I'm going to diverge a little bit to really speak about the whole way

283
00:17:12,668 --> 00:17:16,150
that I think we approach software development from a testing perspective.

284
00:17:18,410 --> 00:17:21,906
And this is perhaps maybe more aimed at the testers than the developers.

285
00:17:21,938 --> 00:17:24,650
But if you were to speak to most testers and you give them any application

286
00:17:24,720 --> 00:17:27,946
and say, here's an application, test it, typically what they're going to do is

287
00:17:27,968 --> 00:17:31,382
they're going to look at the application in its entirety.

288
00:17:31,446 --> 00:17:35,370
You might have multiple different services running multiple different databases,

289
00:17:35,450 --> 00:17:38,990
all with separate configurations that are storing things, but they're going to take the application

290
00:17:39,060 --> 00:17:42,874
and they're going to run from it end to end, and they're going to devise

291
00:17:42,922 --> 00:17:46,314
a lot of their test permutations

292
00:17:46,362 --> 00:17:49,810
from that. Yes, they might be hitting APIs, but they might be wanting to

293
00:17:49,960 --> 00:17:52,978
hit an API that goes all the way from service one to service five and

294
00:17:52,984 --> 00:17:56,354
take it all the way back and see if everything's working together well.

295
00:17:56,472 --> 00:17:59,926
And then often the mistake that's made is because your testers start off focusing from

296
00:17:59,948 --> 00:18:03,554
that angle, they can tend to then focus their test automation

297
00:18:03,602 --> 00:18:06,854
efforts from that angle. And again, that's big. When you're trying to focus your test

298
00:18:06,892 --> 00:18:10,194
automation at these big overall,

299
00:18:10,242 --> 00:18:12,918
end to end aspects of your software,

300
00:18:13,014 --> 00:18:16,442
you're slowing things down because those tests become really

301
00:18:16,496 --> 00:18:19,722
long to execute. They become really flaky because it's dealing with too many moving

302
00:18:19,776 --> 00:18:22,666
parts and it's not really ideal. Those are not the type of tests you want

303
00:18:22,688 --> 00:18:25,806
to be running in your pipelines. You need tests that are very responsive, giving you

304
00:18:25,828 --> 00:18:29,294
quick feedback. And so you need to be thinking about

305
00:18:29,332 --> 00:18:33,434
your software testing and your design not from this big perspective,

306
00:18:33,562 --> 00:18:37,058
but really from a small perspective. So really thinking about

307
00:18:37,144 --> 00:18:40,834
system. So we have like a system here, system one, where system one

308
00:18:40,952 --> 00:18:44,098
has your service. It's got a database, it's got some

309
00:18:44,104 --> 00:18:48,114
database that it interacts with and then it's got its different

310
00:18:48,152 --> 00:18:51,446
dependencies, whatever that might be. And you'd actually want to have those stubbed. You need

311
00:18:51,468 --> 00:18:54,594
to have a lot of mocking in place. So those of you that are familiar

312
00:18:54,642 --> 00:18:57,798
with your unit testing, this is an important part of unit testing and you'd need

313
00:18:57,804 --> 00:19:00,762
to build that in to your unit test, but not just your unit test.

314
00:19:00,816 --> 00:19:04,602
Also your integration test have a level of mocking where you can test

315
00:19:04,656 --> 00:19:08,074
that system one in its entirety, completely isolated from

316
00:19:08,112 --> 00:19:11,770
those other systems if you want to. Every single time you're building

317
00:19:11,840 --> 00:19:15,086
and making improvements in your software, running through these extensive end to

318
00:19:15,108 --> 00:19:18,714
end tests, again, you're slowing down your pipelines.

319
00:19:18,762 --> 00:19:22,094
It's not what CI CD was designed for. It was designed for

320
00:19:22,132 --> 00:19:25,314
quick, immediate feedback. We need to think about testing from

321
00:19:25,352 --> 00:19:28,434
a much smaller perspective and rather focus on trying

322
00:19:28,472 --> 00:19:32,398
to reduce the scale of your software where you can isolate

323
00:19:32,414 --> 00:19:36,034
things. And from a testing perspective you can just focus on this

324
00:19:36,072 --> 00:19:39,186
one service and everything it needs. And then it's a lot easier to

325
00:19:39,208 --> 00:19:42,038
not just write unit tests for your different aspects of code. But then it's a

326
00:19:42,044 --> 00:19:45,494
lot easier to write tests just for this one service and making sure that

327
00:19:45,532 --> 00:19:48,582
it's working well. And you can then instead of speaking

328
00:19:48,636 --> 00:19:52,278
to the other sort of dependencies, you speak to mocks of those dependencies so

329
00:19:52,284 --> 00:19:57,062
that you can test it and get really good coverage moving

330
00:19:57,116 --> 00:20:00,894
forward across within that entire system. So your automated tests can run and you're just

331
00:20:00,932 --> 00:20:04,238
running a portion of your automation scripts to be able to allow you to

332
00:20:04,244 --> 00:20:08,058
get there. And then that's also useful because it allows

333
00:20:08,074 --> 00:20:10,414
you to scale better because now all of a sudden we're like, okay, we're making

334
00:20:10,452 --> 00:20:12,942
a change to system one and now we're going to make a change to system

335
00:20:12,996 --> 00:20:16,222
two. We don't have to worry about, okay, we're now making change to system

336
00:20:16,276 --> 00:20:19,218
one. Got to run through the entire intuition test cycle and now we're going to

337
00:20:19,224 --> 00:20:21,842
do the same because we're now making a change to system two. You can now

338
00:20:21,896 --> 00:20:25,074
effectively work independently, have a team work on system

339
00:20:25,112 --> 00:20:28,878
one and system two and those letting can be completely isolated.

340
00:20:29,054 --> 00:20:32,438
And from a CI CD perspective, that's what you kind of want. You want sort

341
00:20:32,444 --> 00:20:35,314
of isolation. You want to be able to run this job that can then eventually

342
00:20:35,362 --> 00:20:38,838
merge into the bigger software process. But you want to be able

343
00:20:38,844 --> 00:20:42,314
to work with things independently. So it's important to have that

344
00:20:42,352 --> 00:20:45,814
building block in place as we move forward into actually now looking at quality gates.

345
00:20:45,862 --> 00:20:49,754
More specifically, that it's not just about building quality gates if your

346
00:20:49,792 --> 00:20:51,660
software design is not right.

347
00:20:52,910 --> 00:20:56,814
I'm really passionate about getting software right early and that starts at

348
00:20:56,852 --> 00:21:00,158
a design phase and that's why I'm spending so much time at the start of

349
00:21:00,164 --> 00:21:04,100
this talk talking about that design. Because you're never going to fix

350
00:21:04,630 --> 00:21:08,254
or build high quality software or poorly

351
00:21:08,302 --> 00:21:11,486
designed software. Even the world's greatest testers

352
00:21:11,518 --> 00:21:15,374
and the most fantastic development team with incredible

353
00:21:15,422 --> 00:21:18,420
automated scripts, if your software is not designed right,

354
00:21:18,870 --> 00:21:22,486
you're not going to put good quality software out no matter how effective and good

355
00:21:22,508 --> 00:21:26,358
your teams are. And so it's important to start with this design and

356
00:21:26,364 --> 00:21:30,098
get this right. And if you can really get this design right and you

357
00:21:30,124 --> 00:21:34,038
can really focus on isolating and building software that's modular,

358
00:21:34,214 --> 00:21:37,926
that works in a small way, that's very testable and very independent

359
00:21:37,958 --> 00:21:41,226
from each other. That is what you have for the success to be able to

360
00:21:41,248 --> 00:21:44,906
moving forward. And if you have that layer and that foundation, it's a lot easier

361
00:21:44,938 --> 00:21:48,634
to build your software and then to be able to put quality gates

362
00:21:48,682 --> 00:21:52,366
and put checks and balances in place. But what

363
00:21:52,388 --> 00:21:56,042
I will speak about can apply. So what if you're working with software,

364
00:21:56,106 --> 00:21:59,534
maybe not all of this is in place. Yes, you can still use quality gates.

365
00:21:59,582 --> 00:22:02,366
And as we go through the next few slides where we look at quality gates

366
00:22:02,398 --> 00:22:05,554
in a little bit more detail and what they actually are and maybe

367
00:22:05,592 --> 00:22:07,060
how you can apply them.

368
00:22:08,230 --> 00:22:12,146
Note that you can still do it. It does work with bigger pieces

369
00:22:12,178 --> 00:22:15,878
of software. It does work with bigger sort of applications, even things that haven't quite

370
00:22:16,044 --> 00:22:19,654
been broken down. It's just that it works tests in these type of things.

371
00:22:19,692 --> 00:22:22,794
So I kind of want to give you sort of the sort of best case

372
00:22:22,832 --> 00:22:26,886
of how it should work, how you should be designing your software

373
00:22:26,998 --> 00:22:30,246
for CI CD to be able to get the best quality out of your CI

374
00:22:30,278 --> 00:22:33,558
CD and your software. But if you haven't

375
00:22:33,574 --> 00:22:37,226
quite got that in place and you're working with some legacy applications where you've

376
00:22:37,338 --> 00:22:40,938
been running the software for years and you've got your CI CD systems

377
00:22:41,114 --> 00:22:44,446
already in place, but your software application is maybe a little bit too

378
00:22:44,468 --> 00:22:48,130
big. That's fine, we can still work around that. You can still build automated quality

379
00:22:48,200 --> 00:22:51,522
gates in place. It might just look different.

380
00:22:51,576 --> 00:22:54,386
And so with everything, I think it's important to understand that context, that it might

381
00:22:54,408 --> 00:22:58,006
just look different for your application if you don't have this in

382
00:22:58,028 --> 00:23:01,174
place, but you can still find those measures that work for

383
00:23:01,212 --> 00:23:03,750
you very important to note.

384
00:23:04,970 --> 00:23:08,214
And again, it's important to, when we're looking

385
00:23:08,252 --> 00:23:11,758
at these gates, just to understand this automation test pyramid,

386
00:23:11,794 --> 00:23:15,174
because again, anything quality related, there needs to be some sort of checks and balances

387
00:23:15,222 --> 00:23:18,634
in place. And with any pyramid it's very

388
00:23:18,672 --> 00:23:22,394
important to be able to have that strong foundation. A pyramid works well because

389
00:23:22,432 --> 00:23:26,222
it's got a solid foundation and everything is scaling up to a point

390
00:23:26,276 --> 00:23:29,358
where you can go a lot higher because you've got this firm base and you

391
00:23:29,364 --> 00:23:32,846
can effectively build a pyramid high and strong. It won't fall over, it will

392
00:23:32,868 --> 00:23:36,238
last a long time because it's got that solid base in

393
00:23:36,244 --> 00:23:39,426
place and that's what you need. So again, it's just reiterating that whole thing of

394
00:23:39,448 --> 00:23:42,498
you've got to have a solid base of unit tests and you've got to

395
00:23:42,504 --> 00:23:46,114
have your component tests and then your

396
00:23:46,152 --> 00:23:49,426
functional tests with APIs and sort of aspects of UI before heading

397
00:23:49,458 --> 00:23:53,234
into anything non functional. And you'll still have that manual testing component,

398
00:23:53,282 --> 00:23:56,594
but it can be greatly reduced. And with all of these things, this unit component,

399
00:23:56,642 --> 00:24:00,274
functional, non functional. If you have these automated,

400
00:24:00,402 --> 00:24:04,378
you can build quality gates to check each layer to make sure

401
00:24:04,544 --> 00:24:08,518
before we even move on to executing our component tests, we've got our unit

402
00:24:08,534 --> 00:24:11,754
test in place and we're running our unit testing code. Then we're going into our

403
00:24:11,792 --> 00:24:15,562
components where we're working with those isolated and stubbed microservices

404
00:24:15,626 --> 00:24:19,786
that we've built before. We then going into maybe a little bit more complicated API

405
00:24:19,818 --> 00:24:22,926
and UI tests at a functional level that are testing things. And we can actually

406
00:24:22,948 --> 00:24:26,434
go and make sure that all of these building blocks are in place before we

407
00:24:26,472 --> 00:24:29,300
move up. And that's useful because again,

408
00:24:31,430 --> 00:24:35,122
it's a lot quicker to run everything at the bottom, all of these things

409
00:24:35,256 --> 00:24:38,694
as we go up the permit. It takes longer and longer to do

410
00:24:38,732 --> 00:24:42,646
manual testing is very effective and we needed because

411
00:24:42,668 --> 00:24:46,134
we need to be using our software within our spaces. But it's the

412
00:24:46,172 --> 00:24:49,558
slowest form of quality control and not useful when you want to deploy on

413
00:24:49,564 --> 00:24:52,538
a regular basis and you're running your CI CD pipelines and wanting to be able

414
00:24:52,544 --> 00:24:56,054
to deploy into production on the same day. And to do that effectively

415
00:24:56,102 --> 00:25:00,038
again, you need that base, that whole sort of having a solid base of unit

416
00:25:00,054 --> 00:25:03,278
tests in place. And if you can build quality gates in between those things,

417
00:25:03,364 --> 00:25:05,886
you can control the whole process better.

418
00:25:06,068 --> 00:25:08,160
So very useful to have in place.

419
00:25:09,570 --> 00:25:12,446
But let's get back to quality gates. We've had a look at the foundation and

420
00:25:12,468 --> 00:25:15,662
how it is that you need to building your software, but what is a quality

421
00:25:15,716 --> 00:25:18,786
gate check? So we now have quality gate and we're going to have different sort

422
00:25:18,808 --> 00:25:22,046
of quality gates at our software. What is it really looking at? And there's

423
00:25:22,078 --> 00:25:25,874
a multitude of things that you can look at within a quality gate. And there

424
00:25:25,912 --> 00:25:29,150
are some change controls that you can even put in before we even get

425
00:25:29,160 --> 00:25:32,454
into CI CD pipelines in terms of your requirements and what they need to look

426
00:25:32,492 --> 00:25:36,674
like and how a user story should be defined, how requirements

427
00:25:36,722 --> 00:25:40,286
should be defined, how your acceptance criteria

428
00:25:40,338 --> 00:25:43,100
should be defined before you even begin to work on it.

429
00:25:44,430 --> 00:25:47,962
Those are all important quality gates and checks that you need to have in place.

430
00:25:48,096 --> 00:25:52,134
But from an automated CRCD quality gate perspective,

431
00:25:52,182 --> 00:25:55,166
these are the things that you'd probably want to look at. And these are not

432
00:25:55,188 --> 00:25:57,374
the only things you can look at. There are other things that you can build

433
00:25:57,412 --> 00:26:01,182
quality gates around. But essentially if you can understand

434
00:26:01,316 --> 00:26:05,482
all these different things, you can start to build automated quality gates

435
00:26:05,626 --> 00:26:08,530
around these different measures. I think the first thing is bold health. When you're building

436
00:26:08,600 --> 00:26:11,666
your software, and I think this is an easy one to do,

437
00:26:11,768 --> 00:26:15,218
it needs to bold correctly. So you want to be able to check that the

438
00:26:15,224 --> 00:26:18,406
health of your bold, maybe not necessarily always the code that

439
00:26:18,428 --> 00:26:21,926
you've submitted, but anything else that you

440
00:26:21,948 --> 00:26:25,206
might need to be dependent on needs to also be checked as

441
00:26:25,228 --> 00:26:28,834
well. So something around other pieces of software,

442
00:26:28,962 --> 00:26:33,186
are they healthy? You might, for instance, be releasing

443
00:26:33,218 --> 00:26:36,266
some code and you want to deploy and build your code and test it,

444
00:26:36,288 --> 00:26:39,514
but you know that your code is dependent on something else that's maybe not quite

445
00:26:39,552 --> 00:26:42,314
right and you can go and actually check and say, well, hang on,

446
00:26:42,512 --> 00:26:45,840
this other piece of code, I'm not happy with it. It's not building right.

447
00:26:46,370 --> 00:26:49,742
Let's not go in and push this any further because we're dependent on it.

448
00:26:49,876 --> 00:26:53,674
It's looking at the infrastructure health. So we're deploying our software

449
00:26:53,722 --> 00:26:57,774
onto a container or into some bigger system. What's that like? Is the infrastructure

450
00:26:57,822 --> 00:27:01,346
healthy? Will it give me reliable results? Will it run reliably and

451
00:27:01,368 --> 00:27:05,054
you can actually go and check the health of your infrastructure

452
00:27:05,102 --> 00:27:08,562
to make sure that you're happy with it before you even build code onto it.

453
00:27:08,616 --> 00:27:11,798
And very important, there's the obvious thing, and I think this is the

454
00:27:11,804 --> 00:27:15,506
one that we all mostly will think of as test results.

455
00:27:15,538 --> 00:27:18,450
We're running tests, whether it be unit tests, integration tests,

456
00:27:18,610 --> 00:27:21,946
component tests. What are the results of that? So when you're building your

457
00:27:21,968 --> 00:27:26,346
software, you should be building your software, you should be running your

458
00:27:26,368 --> 00:27:29,802
unit tests. Obviously, you want that to pass, and that should be 100% pass

459
00:27:29,856 --> 00:27:33,034
rate before you even move on to the next level to say,

460
00:27:33,072 --> 00:27:35,834
we've passed all of our unit test, let's move it on. And then your integration

461
00:27:35,882 --> 00:27:39,838
tests or your component tests run and move on and on. So again, you want

462
00:27:39,844 --> 00:27:44,266
to check your test results. Very important, code coverage.

463
00:27:44,458 --> 00:27:47,906
And I've had a lot of debate with people who say that code coverage is

464
00:27:47,928 --> 00:27:51,234
a really poor metric and it's not a good

465
00:27:51,272 --> 00:27:55,060
measure of the software quality. And I would say that

466
00:27:56,390 --> 00:27:59,558
that's not completely accurate. I think code coverage can be a really

467
00:27:59,644 --> 00:28:03,414
good measure of your, your testing effort. I just think it's that we use

468
00:28:03,452 --> 00:28:06,422
it incorrectly. We don't understand code coverage and how it works,

469
00:28:06,476 --> 00:28:09,814
and we should never place emphasis only on code

470
00:28:09,852 --> 00:28:13,690
coverage when it comes to software testing. But if we're not using code coverage

471
00:28:14,030 --> 00:28:17,574
at all, we are really crippling our software development,

472
00:28:17,622 --> 00:28:20,266
because we really need to use code coverage as a way of being able to

473
00:28:20,288 --> 00:28:23,926
effectively determine that we have written tests that are covering

474
00:28:23,958 --> 00:28:27,054
the right amount of code, and particularly if we're aiming really high,

475
00:28:27,092 --> 00:28:30,206
and we pulled in really good sort of stub systems and

476
00:28:30,228 --> 00:28:34,126
mock systems in place, we can really get a high code coverage out of our

477
00:28:34,148 --> 00:28:37,842
unit tests in particular. And so it's a really good measure to have and understand

478
00:28:37,896 --> 00:28:41,294
that by code coverage. When I say code coverage,

479
00:28:41,342 --> 00:28:45,134
yes, there is statement coverage, there is branch coverage, there is decision

480
00:28:45,182 --> 00:28:48,514
coverage. There's a whole bunch of ways of measuring it. I'm saying all of it.

481
00:28:48,632 --> 00:28:52,246
When we're doing code coverage on our software, we shouldn't just be isolating one

482
00:28:52,268 --> 00:28:55,926
of those. We should be taking all of those different code coverage metrics and

483
00:28:55,948 --> 00:28:59,366
saying, do we score high enough across all of them? Have we

484
00:28:59,388 --> 00:29:02,578
really looked at all of our decisions? Have we really looked at all the different

485
00:29:02,604 --> 00:29:05,866
sort of branches that our code is taking? Have we really looked at all of

486
00:29:05,888 --> 00:29:09,354
the executable statements in our code? And is it then giving

487
00:29:09,392 --> 00:29:12,506
us a high enough sort of coverage? And I would say a good thing to

488
00:29:12,528 --> 00:29:16,622
actually aim for from a unit test perspective is 90% or above some

489
00:29:16,676 --> 00:29:19,854
applications that might be a little difficult to achieve, in which

490
00:29:19,892 --> 00:29:23,262
case it's often worthwhile then maybe lowering it or maybe looking to

491
00:29:23,316 --> 00:29:26,398
change that design to improve it. But I would say if you've

492
00:29:26,414 --> 00:29:30,322
designed your software right and modular enough, a 90% code

493
00:29:30,376 --> 00:29:34,114
coverage shouldn't be hard to achieve. I think it's just often we

494
00:29:34,152 --> 00:29:38,242
don't put the effort in to that early unit test phase to

495
00:29:38,296 --> 00:29:41,266
warrant that type of thing, and we say it might be difficult to achieve.

496
00:29:41,298 --> 00:29:44,534
Our software is never able to get to a 90% code

497
00:29:44,572 --> 00:29:48,066
coverage. We're happy with all of our tests passing on the code coverage

498
00:29:48,098 --> 00:29:51,686
being 75%. If we really focus on it enough, we can get

499
00:29:51,708 --> 00:29:55,146
there, and particularly if the software is designed right. But important to

500
00:29:55,168 --> 00:29:58,426
have that metric, you need to have some sort of quality gate in place to

501
00:29:58,448 --> 00:30:01,786
know that you haven't just got all your tests passing, but that your tests have

502
00:30:01,808 --> 00:30:05,006
actually covered the areas that you want them to. So, very important thing to have

503
00:30:05,028 --> 00:30:08,986
in place when you're utilizing both of those, your security scans,

504
00:30:09,018 --> 00:30:12,430
you need to be able to scan your software. Yes, you can run

505
00:30:12,500 --> 00:30:15,726
a variety of security tests and you can automate a lot of your

506
00:30:15,748 --> 00:30:19,074
security tests, but a very quick one is

507
00:30:19,112 --> 00:30:22,466
having scans in place. You should have a scan in place.

508
00:30:22,568 --> 00:30:25,266
There's a variety of tools that can do it, that you can go and just

509
00:30:25,288 --> 00:30:28,850
ensure that your code is of a high quality.

510
00:30:28,920 --> 00:30:32,774
That's something you should build in, and you should prevent your code from moving too

511
00:30:32,812 --> 00:30:36,310
far along in the process with known security

512
00:30:36,380 --> 00:30:39,910
issues. Now, I understand that when we're starting

513
00:30:39,980 --> 00:30:43,258
out with a software project, you might not want to

514
00:30:43,264 --> 00:30:46,166
put this in place because you're still starting out and you're still finding your feet

515
00:30:46,198 --> 00:30:48,470
from a software perspective.

516
00:30:48,630 --> 00:30:52,266
And quite a lot of teams tend to leave their software scanning

517
00:30:52,298 --> 00:30:55,326
for very late in the cycle because they're focused on getting

518
00:30:55,348 --> 00:30:59,680
things done before they bring that in. And I understand that

519
00:31:00,370 --> 00:31:03,582
you really want to have a good foundation of

520
00:31:03,636 --> 00:31:06,990
code and application written before you start introducing scans.

521
00:31:07,150 --> 00:31:10,942
What I just says is, don't leave that too late. I have worked on projects

522
00:31:11,006 --> 00:31:15,506
where they've started to look at the security too late, and that

523
00:31:15,528 --> 00:31:18,786
they were building new applications and they've been building this application for three or four

524
00:31:18,808 --> 00:31:22,086
months. Now they want to get it into production, and now they want to

525
00:31:22,108 --> 00:31:25,218
introduce a level of security scanning to make sure everything's safe.

526
00:31:25,314 --> 00:31:29,046
And now they're starting to get some really big failures. And I worked on

527
00:31:29,068 --> 00:31:32,406
projects where those failures were identified in the code that was written

528
00:31:32,438 --> 00:31:36,426
at the very start of the project where they weren't following proper standards and

529
00:31:36,448 --> 00:31:40,346
protocols. So rather err on the side of bringing that in really early

530
00:31:40,528 --> 00:31:44,474
and having a security scan in place from the very beginning of writing that first

531
00:31:44,512 --> 00:31:47,678
code, if you can. And then there's something you can build into your pipeline so

532
00:31:47,684 --> 00:31:51,226
that if a security scan fails for whatever reasons, and you can benchmark

533
00:31:51,258 --> 00:31:54,846
it based on how severe you need to be on different parts of your

534
00:31:54,868 --> 00:31:58,258
application, but you can bring those security scans in

535
00:31:58,264 --> 00:32:02,398
place and make sure that the software does meet security criteria.

536
00:32:02,574 --> 00:32:05,426
It won't even build and move on to the next phase until you fix that

537
00:32:05,448 --> 00:32:08,866
gap. It might again sound like a lot of work to slow you down,

538
00:32:09,048 --> 00:32:12,214
but you're preventing tech debt from

539
00:32:12,332 --> 00:32:15,238
later in your project and you're getting it right early so that you don't have

540
00:32:15,244 --> 00:32:17,846
to worry about these things later. And it actually helps you to move quicker if

541
00:32:17,868 --> 00:32:21,078
you can do that. Right. Same with performance. Now here I'm

542
00:32:21,094 --> 00:32:24,474
not talking about the software performance and performance testing, I'm talking about the

543
00:32:24,512 --> 00:32:26,940
service performance of, yes,

544
00:32:29,390 --> 00:32:33,030
not of your whole software, but of just that piece of the application.

545
00:32:33,120 --> 00:32:36,382
So when you're actually running your code and you're running your unit test,

546
00:32:36,436 --> 00:32:39,258
how long should certain things take to execute?

547
00:32:39,354 --> 00:32:42,618
How long should a function run? As you're testing

548
00:32:42,634 --> 00:32:46,066
the individual services, it's worthwhile knowing these things and actually then

549
00:32:46,088 --> 00:32:50,066
being able to benchmark how effective your service is

550
00:32:50,088 --> 00:32:53,810
running. And because it's unit test, you can often make these

551
00:32:53,880 --> 00:32:57,006
really tight and you can make them really strict criteria.

552
00:32:57,038 --> 00:33:00,834
But the moment you start introducing code that's not efficient,

553
00:33:00,882 --> 00:33:05,462
all of a sudden you'll notice your unit test goes from maybe executing within

554
00:33:05,516 --> 00:33:08,898
a couple of milliseconds or one or 2 seconds into 1020 seconds because something's

555
00:33:08,914 --> 00:33:11,990
not right with the code and it hasn't quite been optimized correctly.

556
00:33:12,490 --> 00:33:14,886
We should flag that and we should say, hang on, we're not going to deploy

557
00:33:14,918 --> 00:33:18,938
this any further, there's something wrong with the performance. And so if we have started

558
00:33:19,024 --> 00:33:22,414
looking at the performance of our code and how it executes very

559
00:33:22,452 --> 00:33:25,786
early, it's something that we can building into our quality gates

560
00:33:25,818 --> 00:33:30,266
and we can stop the software and poorly

561
00:33:30,298 --> 00:33:33,966
performance software from getting further on because we might think it's just

562
00:33:33,988 --> 00:33:36,922
a small piece of code, it's not running optimally, it's not a big thing,

563
00:33:36,996 --> 00:33:40,546
it doesn't scale well. If you're starting to think that that service

564
00:33:40,728 --> 00:33:44,178
or that piece of code might be called on a regular basis and that might

565
00:33:44,264 --> 00:33:47,614
then be scaled out around the world. If you're in the cloud and you're scaling

566
00:33:47,662 --> 00:33:51,414
globally, you don't want to have any code that's not performant and that's something

567
00:33:51,452 --> 00:33:54,566
that you can consider building in place and it's something

568
00:33:54,588 --> 00:33:57,718
that you want to do and consider. And then the

569
00:33:57,724 --> 00:34:01,514
last thing is incident and issue management. We can build

570
00:34:01,552 --> 00:34:05,478
quality gates even if we might not think of defects

571
00:34:05,494 --> 00:34:08,794
and incidents within our CI pipelines, you can still

572
00:34:08,832 --> 00:34:12,506
build a quality gates that can check your incident or your

573
00:34:12,528 --> 00:34:15,950
issue management systems and say, hang on, we can't deploy this service.

574
00:34:16,020 --> 00:34:18,750
Let's say you need to deploy something into production,

575
00:34:19,250 --> 00:34:22,314
but now you've got traceability in place and you know that there is a bug

576
00:34:22,362 --> 00:34:25,886
being logged against particular piece of code that's in your

577
00:34:25,908 --> 00:34:28,866
release and it can go and actually check and say, well hang on,

578
00:34:28,968 --> 00:34:32,670
this particular piece of functionality, there is actually a major bug that's still being logged,

579
00:34:32,830 --> 00:34:36,158
it can stop you, hang on, we can't deploy. There's a major issue that's

580
00:34:36,174 --> 00:34:39,846
still outstanding that we need to resolve. And again, you can

581
00:34:40,028 --> 00:34:43,714
put those criteria in place on how strict you need to be with certain rules

582
00:34:43,842 --> 00:34:47,234
and whether it warrants it based on the importance for feature.

583
00:34:47,362 --> 00:34:50,890
But again, you can build those measures and you can prevent the human

584
00:34:50,960 --> 00:34:54,326
error part of accidentally

585
00:34:54,358 --> 00:34:58,106
putting something into production when there was actually a major issue and someone forgot about

586
00:34:58,128 --> 00:35:01,526
it, because your quality gate will catch that and say, hang on, our issue management

587
00:35:01,558 --> 00:35:04,870
system is saying that there isn't known issue in place. I'm not going to

588
00:35:04,880 --> 00:35:08,702
let you deploy any further until we fix it. And so again,

589
00:35:08,756 --> 00:35:11,646
we can use quality gates really well. And those are some of the things that

590
00:35:11,668 --> 00:35:15,166
it can check, which are very important types of

591
00:35:15,188 --> 00:35:18,606
quality gates that we can get set up and

592
00:35:18,628 --> 00:35:22,418
check out. So whenever we're setting up environments, we're checking out our code, we can

593
00:35:22,424 --> 00:35:26,034
build a quality gate there and check that out. Again, anytime code

594
00:35:26,072 --> 00:35:29,126
is built there should be a quality gate in terms of how well does it.

595
00:35:29,228 --> 00:35:33,574
Anytime tests are executed, whether it be units, CI tests, whatever it might be,

596
00:35:33,772 --> 00:35:37,634
we need to make sure that that's done and that we can measure those results.

597
00:35:37,762 --> 00:35:40,300
The static analysis, those scans that we're running,

598
00:35:41,150 --> 00:35:45,146
we can build a quality gate around that step. And every time those

599
00:35:45,168 --> 00:35:49,146
scans run, are we happy with the results? If not, send it

600
00:35:49,168 --> 00:35:52,982
back. If we're happy, move it on. An environment readiness

601
00:35:53,046 --> 00:35:57,258
check we're now deploying. If we've gone through this stage of our CI CD

602
00:35:57,274 --> 00:36:00,442
pipeline, we've now got to deploy this into some sort of environment,

603
00:36:00,506 --> 00:36:04,074
whether it be in the cloud, whether it be some sort of containerized

604
00:36:04,122 --> 00:36:06,954
environment. So if you've got somewhere or some sort of bigger test environment,

605
00:36:07,002 --> 00:36:10,446
whatever it is that you're deploying in, is that environment

606
00:36:10,478 --> 00:36:13,586
really for us? Have we actually gone and looked at, can we actually spin up

607
00:36:13,608 --> 00:36:16,900
some containers and say that we're happy with it and hang on,

608
00:36:18,310 --> 00:36:21,686
this environment meets our needs, we're happy with it. Let's go

609
00:36:21,708 --> 00:36:25,574
on to the next thing. Then you can go and deploy your steps in so

610
00:36:25,612 --> 00:36:28,934
you can actually test your deployment. Before and after

611
00:36:28,972 --> 00:36:32,666
your deployment. Just say, okay, we're happy with the deployment. Once you've then deployed your

612
00:36:32,688 --> 00:36:36,186
software, is everything up and running that's supposed to be up and running before you

613
00:36:36,208 --> 00:36:39,574
even start running any further tests? We've actually deployed these systems.

614
00:36:39,622 --> 00:36:43,658
Are these services up? Are we happy that they are operational

615
00:36:43,834 --> 00:36:47,550
to a basic level and basic degree? There's no point even trying to run

616
00:36:47,700 --> 00:36:51,786
any sort of automated test against something if it's

617
00:36:51,818 --> 00:36:54,494
not running properly. If you want to now move to the next phase and maybe

618
00:36:54,532 --> 00:36:58,770
run broader, bigger tests,

619
00:36:59,190 --> 00:37:01,954
we need to be able to ensure that it's deployed correctly and we can build

620
00:37:01,992 --> 00:37:05,266
a quality gates around that. And so again, something very important that you can put

621
00:37:05,288 --> 00:37:09,590
in place from there on, it's something like automated

622
00:37:10,490 --> 00:37:14,326
integration test execution. We can now have bigger tests that

623
00:37:14,348 --> 00:37:17,798
are now executing. And again, we've got that strong foundation of unit tests. So you

624
00:37:17,804 --> 00:37:21,686
might have fewer of them, but you still want to have your integration tests that

625
00:37:21,708 --> 00:37:24,666
are running and they're automated and it's able to run those checks. And you can

626
00:37:24,688 --> 00:37:27,866
have a quality gate around that to ensure that those all pass before you move

627
00:37:27,888 --> 00:37:31,334
on to the next thing. And I've put dynamic code analysis

628
00:37:31,382 --> 00:37:35,246
as opposed to static code analysis. This is something that you can have in

629
00:37:35,268 --> 00:37:38,526
place. Not all systems might need to

630
00:37:38,548 --> 00:37:41,886
have this in place, but it's important to have it there as well. And these

631
00:37:41,908 --> 00:37:45,438
are typically tools that, again, can give you a good feel around

632
00:37:45,524 --> 00:37:49,246
security of

633
00:37:49,268 --> 00:37:52,346
your software. So it's not just about the static analysis, where it's

634
00:37:52,378 --> 00:37:55,958
actually now building your code and making sure that it's happy with

635
00:37:55,964 --> 00:37:59,634
the quality of the code. You can actually run a dynamic sort of code analysis

636
00:37:59,682 --> 00:38:03,718
where it's actually taking code and trying to do certain things with the

637
00:38:03,724 --> 00:38:05,974
code and trying to break it. There are a lot of tools that can help

638
00:38:06,012 --> 00:38:09,686
you to be able to assess the quality of your software at that level,

639
00:38:09,788 --> 00:38:13,226
and you can build a quality gate around that. And then the last sort of

640
00:38:13,248 --> 00:38:16,906
type of quality gate that we get is really around our non functional tests that

641
00:38:16,928 --> 00:38:21,002
we have in place. Your performance tests, you can have a quality gate where last

642
00:38:21,056 --> 00:38:24,374
step of deployment, you actually run a couple of very lightweight performance

643
00:38:24,422 --> 00:38:27,454
tests to make sure that the software is performant and you can stop it there.

644
00:38:27,492 --> 00:38:30,606
If it's not performant. You can do the same with your security or

645
00:38:30,628 --> 00:38:34,494
with any sort of visual. If your software needs

646
00:38:34,532 --> 00:38:37,906
to visually look a certain way, you can use visual scans to quickly now run

647
00:38:37,928 --> 00:38:41,918
through your software and ensure that, well, hang on, this software doesn't

648
00:38:41,934 --> 00:38:45,026
quite visually render itself properly if that's important to us.

649
00:38:45,208 --> 00:38:48,546
And you can flag certain pages to say this page has to

650
00:38:48,568 --> 00:38:52,246
pass or not. From a visual regression perspective, we can now flag that

651
00:38:52,268 --> 00:38:55,878
and say, well hang on, we're not happy with this result, stop it,

652
00:38:56,044 --> 00:38:59,350
stop deployment. There's something that's not quite right. And so this,

653
00:38:59,420 --> 00:39:03,434
again, if you understand these different types of quality gates and how they

654
00:39:03,472 --> 00:39:06,186
fit within a pipeline, you can see that they can really add a lot of

655
00:39:06,208 --> 00:39:09,050
value because it prevents us from making mistakes.

656
00:39:09,710 --> 00:39:13,166
The end result is if you build a quality gate at every single one of

657
00:39:13,188 --> 00:39:16,030
these steps, and again, you can automate this quality gate,

658
00:39:16,530 --> 00:39:19,070
your end result will be good quality software,

659
00:39:19,570 --> 00:39:23,066
unless you've really lowered your standards of your quality gates.

660
00:39:23,098 --> 00:39:26,066
But if you've increased and you've got high standards for your quality gates in terms

661
00:39:26,088 --> 00:39:28,290
of code coverage and test execution results,

662
00:39:29,590 --> 00:39:33,106
you are going to have a really good quality software. And the

663
00:39:33,128 --> 00:39:36,546
best thing is that all of these things are automated and

664
00:39:36,568 --> 00:39:40,166
you can get to the end of your check and know that

665
00:39:40,188 --> 00:39:43,480
you've got good quality software. Some examples of things,

666
00:39:45,290 --> 00:39:48,470
this is not an exhaustive list. This is very lightweight, some things,

667
00:39:48,540 --> 00:39:51,702
but just some simple things that we'll look into. And I'll go through some code

668
00:39:51,756 --> 00:39:55,466
examples towards the end of the talk, things like linting standards to be

669
00:39:55,488 --> 00:39:58,806
met. So when your code is building, are you happy with a linting?

670
00:39:58,838 --> 00:40:01,834
Does the code look right and flow right? And again,

671
00:40:01,872 --> 00:40:05,338
I've had discussions with people who criticize and say, but why are we focusing on

672
00:40:05,344 --> 00:40:08,846
a linting? Shouldn't we just focus on the functionality and execution of the code?

673
00:40:09,028 --> 00:40:12,446
Code needs to be maintained and linting is an important part of that,

674
00:40:12,548 --> 00:40:15,690
making sure that the code looks and meets certain standards.

675
00:40:15,850 --> 00:40:19,138
You can have tools that can actually go and check to make sure do all

676
00:40:19,144 --> 00:40:22,418
the variables meet. Camel case, are we happy with the way that

677
00:40:22,424 --> 00:40:26,526
everything is shaped and looked? You can actually automate all of those checks by utilizing

678
00:40:26,558 --> 00:40:30,034
linting tools in the build process, that can help and you can

679
00:40:30,152 --> 00:40:32,886
make that a quality gates where it actually checks that to say it's got to

680
00:40:32,908 --> 00:40:36,374
pass our linting standards because we need to write code that's maintainable and

681
00:40:36,492 --> 00:40:40,120
tests the standards that we set as an organization, have that there.

682
00:40:40,570 --> 00:40:44,294
Again, the most obvious one, you want to have something like 100% successful

683
00:40:44,342 --> 00:40:46,970
completion of all tests with a 90% code coverage.

684
00:40:47,630 --> 00:40:51,534
Obviously this is primarily focused on unit testing because when

685
00:40:51,572 --> 00:40:55,434
it comes to later sort of tests, you can't do the code coverage

686
00:40:55,562 --> 00:40:58,926
comparison. But again, you want to

687
00:40:58,948 --> 00:41:02,926
make sure that all

688
00:41:02,948 --> 00:41:06,900
your unit tests pass. Why are we releasing code into

689
00:41:07,750 --> 00:41:10,914
later cycles if tests are failing? Why are we doing

690
00:41:10,952 --> 00:41:14,334
that? Obviously there might be times when we know something's going to fail,

691
00:41:14,382 --> 00:41:17,906
and those would be the odd sort of things that might happen from time

692
00:41:17,928 --> 00:41:21,794
to time when software is still very early in development,

693
00:41:21,842 --> 00:41:25,142
where we are aware that some things might not completely pass

694
00:41:25,276 --> 00:41:28,120
because there is something that we haven't quite figured out yet.

695
00:41:28,650 --> 00:41:33,402
But I would argue that that's very seldom the case early

696
00:41:33,456 --> 00:41:36,890
on in your software development phase. It might get there, but as your software matures,

697
00:41:37,550 --> 00:41:41,914
any software that's been around for a couple of months, you should already have 100%

698
00:41:42,112 --> 00:41:45,646
successful unit test completion as a standard, because you should by that point in time,

699
00:41:45,668 --> 00:41:48,926
have built something that you know how to test it effectively. So very important to

700
00:41:48,948 --> 00:41:52,702
have in place. And 90% code coverage I've spoken about before

701
00:41:52,756 --> 00:41:56,542
is a really good target to hit and very doable if you've designed your software

702
00:41:56,606 --> 00:42:01,346
correctly. Obviously you want to make sure your scans all

703
00:42:01,368 --> 00:42:05,202
meet and that you've actually covered all of your code within

704
00:42:05,256 --> 00:42:09,326
your scans. And then something like successful pass of all automated checks,

705
00:42:09,438 --> 00:42:13,094
something that you want to make sure is done. And that's a quality check

706
00:42:13,132 --> 00:42:16,246
that you can have in place when all of your automated tests are run at

707
00:42:16,268 --> 00:42:20,274
every level, component integration, whatever you might have your UI API

708
00:42:20,322 --> 00:42:24,326
tests, that's all passed. And again, we're quite strict on those criteria

709
00:42:24,358 --> 00:42:27,722
that it's got to pass. Something you can build in place,

710
00:42:27,776 --> 00:42:30,922
you don't have to do the 100%, you can do 90%, 80%.

711
00:42:31,056 --> 00:42:34,474
Again, you can tailor this because you know your software product,

712
00:42:34,512 --> 00:42:37,006
but obviously you want to aim as high as possible to be able to get

713
00:42:37,028 --> 00:42:40,814
the right quality code out. So definitely something

714
00:42:40,852 --> 00:42:43,614
you'd want to have in place. And so those are just some examples of things

715
00:42:43,652 --> 00:42:48,514
that you can check. Again, not an exhaustive list, but if you understand the

716
00:42:48,552 --> 00:42:51,998
whats of what needs to be tested, you can probably think of some good examples

717
00:42:52,014 --> 00:42:55,778
of checks that you can put in place to build into each of those

718
00:42:55,864 --> 00:42:59,030
quality gates. And you can put multiple checks into one quality

719
00:42:59,100 --> 00:43:02,710
gate. For instance, you can have, while your code is building,

720
00:43:02,780 --> 00:43:06,962
you can run some scans, do your letting,

721
00:43:07,026 --> 00:43:09,894
and check your test results of your unit tests, and you can build all three

722
00:43:09,932 --> 00:43:13,402
into one quality gate. And each of those checks can fail your quality

723
00:43:13,456 --> 00:43:16,138
gate, or two out of three can fail it, whatever you want your standard to

724
00:43:16,144 --> 00:43:19,814
be. But you can put those checks in place in each quality gate

725
00:43:19,862 --> 00:43:22,910
to make sure that within this quality gate, we're going to measure these three things.

726
00:43:22,980 --> 00:43:26,446
They're automated and it's going to come

727
00:43:26,468 --> 00:43:29,790
in place. So those are some good examples. I've put here

728
00:43:29,860 --> 00:43:33,774
a high level example of a typical CI CD pipeline.

729
00:43:33,822 --> 00:43:36,638
Or when I say typical, it might not be typical to every organization,

730
00:43:36,734 --> 00:43:40,562
but something that shows

731
00:43:40,616 --> 00:43:43,826
the typical process of things. And this

732
00:43:43,848 --> 00:43:47,710
is one that I've used before. This is something where they're using maven

733
00:43:47,870 --> 00:43:51,298
to be able to set up

734
00:43:51,304 --> 00:43:54,134
their software. And so you can see as it does, it sets up and check

735
00:43:54,172 --> 00:43:56,498
out that the code has got to be checked out correctly, that the code sets

736
00:43:56,514 --> 00:43:59,946
up correctly. Before it even goes to building the code, they've got a quality

737
00:44:00,048 --> 00:44:03,242
check in place to make sure that we've checked up the code

738
00:44:03,296 --> 00:44:07,706
correctly. We're happy with the setup of

739
00:44:07,728 --> 00:44:11,274
the system before we move on. You then build your code.

740
00:44:11,312 --> 00:44:14,798
It's got to build correctly while it's building. You're running your unit test, you might

741
00:44:14,804 --> 00:44:18,398
be running some other CI test that you have in place.

742
00:44:18,564 --> 00:44:22,160
You're then going into static code analysis where you're looking at

743
00:44:23,010 --> 00:44:26,426
your security scans. Maybe there's some sort of quality criteria that's picking

744
00:44:26,458 --> 00:44:30,546
up or any sort of dependencies, where it's looking at other dependencies and how those

745
00:44:30,568 --> 00:44:33,874
dependencies are covered within your code. All of that can be achieved through

746
00:44:33,912 --> 00:44:37,358
static analysis code. And again, those are all check marks, things that you

747
00:44:37,384 --> 00:44:41,414
can put an actual automated check against before

748
00:44:41,452 --> 00:44:45,026
you can then deploy into, let's say, some sort of broader QA environment,

749
00:44:45,138 --> 00:44:49,542
some sort of bigger environment where we can now run

750
00:44:49,676 --> 00:44:53,242
a bigger set of tests where we're not just isolating everything into just this code

751
00:44:53,296 --> 00:44:56,794
build, but we're now actually executing into some

752
00:44:56,832 --> 00:45:00,682
broader environment. It doesn't be a fixed environment, it can be another

753
00:45:00,736 --> 00:45:04,158
sort of CI environment. But it's not just that isolated code. It's a

754
00:45:04,164 --> 00:45:08,158
series of containers that are maybe now spinning up and testing the code in a

755
00:45:08,244 --> 00:45:11,566
bigger sort of way. But yeah, we're now deploying into some

756
00:45:11,588 --> 00:45:15,086
sort of test environment where we're now going to do some

757
00:45:15,108 --> 00:45:18,754
post deployment checks. So again, we're not just deploying the code and saying,

758
00:45:18,792 --> 00:45:22,034
okay, let's run our tests. Let's actually go

759
00:45:22,072 --> 00:45:25,586
back and make sure that the software. So whether we have

760
00:45:25,768 --> 00:45:29,158
a smoke test or some sort of lightweight integration test, whether we have some sort

761
00:45:29,164 --> 00:45:32,418
of monitoring in place, whatever it might be, but let's utilize

762
00:45:32,434 --> 00:45:36,578
those smoke tests to say, well, actually, before we do anything further, we've deployed

763
00:45:36,594 --> 00:45:39,962
the software. Is everything up and running? Are we happy

764
00:45:40,016 --> 00:45:43,850
that the services are speaking to each other and that they're communicating effectively?

765
00:45:44,190 --> 00:45:47,180
Can we do one or two lightweight tests with them?

766
00:45:47,790 --> 00:45:51,114
Yes. Okay, great. Now let's run the rest of the test.

767
00:45:51,232 --> 00:45:54,154
If we get a failure there, don't bother running the rest of the test.

768
00:45:54,192 --> 00:45:56,766
Yes, you might think, but we still want to test everything else to see where

769
00:45:56,788 --> 00:45:59,566
other failures are there. That's important sometimes,

770
00:45:59,668 --> 00:46:02,638
but you also want to just stop it there rather,

771
00:46:02,724 --> 00:46:07,486
because a failure here can give you mixed

772
00:46:07,518 --> 00:46:11,154
or often inaccurate test results further down the line anyway, because something's not quite

773
00:46:11,192 --> 00:46:14,274
right. So rather fix it there and put quality checks in place.

774
00:46:14,312 --> 00:46:17,758
And these are things that can be checked and measured. Your functional tests,

775
00:46:17,774 --> 00:46:21,526
obviously testing locally, remote, whatever it might be, those are

776
00:46:21,548 --> 00:46:25,426
things that can be measured. You can have your dynamic code analysis, your quality scan

777
00:46:25,618 --> 00:46:29,178
that can be checked. You can then repeat a deployment to the

778
00:46:29,184 --> 00:46:32,826
next stage and do post deployment checks at

779
00:46:32,848 --> 00:46:36,550
the next level. Integration and smoke.

780
00:46:36,710 --> 00:46:40,762
And again, that can all be checked. Those are checkboxes that can be checked before

781
00:46:40,816 --> 00:46:44,234
getting into your non functional test. And those are really things around

782
00:46:44,352 --> 00:46:47,566
accessibility. There are a lot of tools these days that can

783
00:46:47,588 --> 00:46:51,518
do accessibility, that can check your security from a

784
00:46:51,684 --> 00:46:55,090
dynamic perspective, your load tests and your performance tests.

785
00:46:55,430 --> 00:46:58,974
I wouldn't typically put a load

786
00:46:59,022 --> 00:47:02,866
test in a CI CD pipeline because you generally don't want to

787
00:47:02,888 --> 00:47:06,706
put your system under load. So I've put

788
00:47:06,728 --> 00:47:09,606
it here because I think it's important to understand that that's a quality control that

789
00:47:09,628 --> 00:47:13,286
can be automated and a check. But I would only run

790
00:47:13,308 --> 00:47:16,486
a load test on a very

791
00:47:16,588 --> 00:47:20,114
limited basis. But it's important you can still build it into your pipeline,

792
00:47:20,162 --> 00:47:23,754
but only run when needed. When you're making big changes, then you can maybe run

793
00:47:23,792 --> 00:47:26,214
a bigger sort of load test where you actually put in your system under load

794
00:47:26,262 --> 00:47:30,154
because system underload will stress your system. It may

795
00:47:30,192 --> 00:47:34,230
impact other operations

796
00:47:34,310 --> 00:47:37,198
because the system is under load and other things might not be working correctly if

797
00:47:37,204 --> 00:47:41,200
you've got multiple teams trying to push coding together. So it's not something you'd want

798
00:47:42,290 --> 00:47:46,378
happening all the time, but there might be times when you're

799
00:47:46,394 --> 00:47:49,586
working on a big feature before you push it into production. You can run

800
00:47:49,608 --> 00:47:53,262
a load test and actually see how it loads and that can be automated.

801
00:47:53,326 --> 00:47:56,766
And you can have a checkbox in place where your CI pipeline actually runs

802
00:47:56,798 --> 00:48:00,246
it and then actually checks results and determines whether it's happy with it or not

803
00:48:00,268 --> 00:48:03,046
based on the criteria you've set. And then same with your performance test. You can

804
00:48:03,068 --> 00:48:06,294
measure performance at every aspect. I put performance test at the end

805
00:48:06,332 --> 00:48:10,182
here, but you can even performance test much

806
00:48:10,236 --> 00:48:13,226
earlier if you know how long it takes your unit test to be able to

807
00:48:13,248 --> 00:48:16,986
run. And you've got sort of benchmarks in place for how long code should take

808
00:48:17,008 --> 00:48:20,374
to execute and speak to each other. You can move performance tests even earlier

809
00:48:20,422 --> 00:48:24,074
into the cycle. But important to note that all of these things can be

810
00:48:24,112 --> 00:48:27,566
checked and all of these things can have an automated measure where

811
00:48:27,588 --> 00:48:31,150
it's like, well, we actually know what pass means or what we consider

812
00:48:31,220 --> 00:48:33,934
pass. And again, it doesn't have to be 100% pass. With your performance test,

813
00:48:33,972 --> 00:48:37,566
you got your benchmarks in place. Are we happy that it met all the benchmarks?

814
00:48:37,598 --> 00:48:41,598
And you can even prioritize parts where it's

815
00:48:41,614 --> 00:48:44,654
absolutely essential. It's got to meet the benchmarks and parts where maybe it doesn't,

816
00:48:44,782 --> 00:48:47,502
but you can prioritize that and set that up, but you can build a quality

817
00:48:47,576 --> 00:48:51,254
gates that measures that.

818
00:48:51,372 --> 00:48:54,918
Here's a broader thing, if you want to just understand a little bit more in

819
00:48:54,924 --> 00:48:57,986
terms of specific things that maybe you want to do and then introduce.

820
00:48:58,018 --> 00:49:01,686
So this is again, looking at something a little bit bigger where maybe this

821
00:49:01,708 --> 00:49:05,082
is not your typical sort of CI CD pipeline, but your quality

822
00:49:05,136 --> 00:49:08,490
gates that you have in control, that you have in place across your entire

823
00:49:08,560 --> 00:49:11,946
project to get you thinking about other things in terms of what are the

824
00:49:11,968 --> 00:49:14,606
other sort of measures and things that we can check in and check in.

825
00:49:14,628 --> 00:49:18,254
A quality gator stuff like

826
00:49:18,292 --> 00:49:21,726
analysis might not be things that we typically want automated, but that would be a

827
00:49:21,748 --> 00:49:24,458
quality gates that we would have before we now start going into the code development,

828
00:49:24,474 --> 00:49:28,066
where we now start getting into that whole sort of automation phase before we then

829
00:49:28,088 --> 00:49:31,982
get to get into our operation, where even things like incident management,

830
00:49:32,046 --> 00:49:35,634
problem management, your acceptance testing, those things

831
00:49:35,672 --> 00:49:39,174
can be automated, your user testing, you wouldn't typically automate that,

832
00:49:39,212 --> 00:49:43,202
but it just shows you how quality gates

833
00:49:43,266 --> 00:49:46,838
can work through every little process of the cycle. And they don't have

834
00:49:46,844 --> 00:49:50,678
to necessarily follow the sequential thing, particularly in most sort

835
00:49:50,684 --> 00:49:54,518
of software delivery cycles your testing might be interspersed

836
00:49:54,534 --> 00:49:57,898
with different aspects of your code, but it's important to

837
00:49:57,904 --> 00:50:00,486
have these things in place and know that you can use them. Things like mutation

838
00:50:00,518 --> 00:50:04,454
testing can help. Things like your configuration

839
00:50:04,502 --> 00:50:07,246
testing, all of these things can be automated. So I would say that whole sort

840
00:50:07,268 --> 00:50:11,354
of quality gate two to qualify to quality gates

841
00:50:11,402 --> 00:50:15,230
six is really what you'd run in your pipeline.

842
00:50:15,650 --> 00:50:18,702
And those are the things that you can automate. Some of the stuff in quality

843
00:50:18,756 --> 00:50:22,226
gate seven and eight can be automated as well, but those are things that we

844
00:50:22,248 --> 00:50:24,974
just want to make sure that your software is still going and you can monitor

845
00:50:25,022 --> 00:50:28,658
and building that in place. Those are things that you can still have. But important

846
00:50:28,744 --> 00:50:32,098
to note that they don't necessarily need to be part of your pipeline and don't

847
00:50:32,114 --> 00:50:35,574
necessarily need to be automated. But your quality gates two to six, and again,

848
00:50:35,612 --> 00:50:39,106
it doesn't be those you can expand those to, like I have in the previous

849
00:50:39,138 --> 00:50:42,854
slide, a lot more quality gates. But if you understand the different sort of stages

850
00:50:42,902 --> 00:50:46,666
of typically how it would work, important to understand that those

851
00:50:46,688 --> 00:50:50,486
things are there. And again, these are iterative things. You might have multiple different stages

852
00:50:50,678 --> 00:50:54,266
where you can then iterate those processes and have a quality gates for each sort

853
00:50:54,288 --> 00:50:56,974
of stage in that process, and very important to have.

854
00:50:57,012 --> 00:51:00,558
So hopefully that gives you sort of a newfound respect for

855
00:51:00,564 --> 00:51:02,766
the types of quality gates that you can have and the things that you can

856
00:51:02,788 --> 00:51:06,226
actually check within your software to ensure that it actually meets the criteria of what

857
00:51:06,248 --> 00:51:09,906
we need. Now, when it comes to building these

858
00:51:09,928 --> 00:51:13,426
things. And again, there's multiple ways of being able to build this. This is

859
00:51:13,448 --> 00:51:16,802
an example of how you would typically want to maybe build something

860
00:51:16,856 --> 00:51:19,762
when it comes to ado as your DevOps.

861
00:51:19,906 --> 00:51:23,778
But you can try something similar, whether using GitLab, whether using Jenkins,

862
00:51:23,874 --> 00:51:27,446
any one of the other many sort of CI tooling out there. These are

863
00:51:27,468 --> 00:51:31,226
things that you typically want to do where you'd have your board, you'd have your

864
00:51:31,328 --> 00:51:34,086
developers got to have some code sitting somewhere,

865
00:51:34,278 --> 00:51:39,146
where there's some sort of things where the moment your

866
00:51:39,168 --> 00:51:42,666
repo gets updated and someone pushes code to

867
00:51:42,688 --> 00:51:46,398
your git repo, it triggers something that can then start the CI sort of

868
00:51:46,404 --> 00:51:48,926
build process. And that's sort of how you would do it. And within sort of

869
00:51:48,948 --> 00:51:52,574
every step of that process, you can build

870
00:51:52,612 --> 00:51:55,966
checks in place that can run and check everything.

871
00:51:56,068 --> 00:51:59,154
And so that's typically how you would go about looking to build your

872
00:51:59,192 --> 00:52:01,906
quality gates in the first place, to be able to make sure that it kind

873
00:52:01,928 --> 00:52:05,746
of does it. And that trigger starts at

874
00:52:05,768 --> 00:52:09,158
that pushing code level the moment git has an update and someone's pushed code in

875
00:52:09,164 --> 00:52:12,742
the update, you can start triggering things and how you want them to do.

876
00:52:12,876 --> 00:52:16,246
And then you can run through your

877
00:52:16,268 --> 00:52:19,442
CI before you then start doing your CD

878
00:52:19,506 --> 00:52:22,902
where you're actually taking things through a little bit more automated

879
00:52:22,966 --> 00:52:26,486
checks. Your CI is just building your code correctly, your CD is actually deploying

880
00:52:26,518 --> 00:52:29,738
it and running a better level of tests against it. And you

881
00:52:29,744 --> 00:52:33,246
can do that against multiple different environments. So important to have that in place

882
00:52:33,268 --> 00:52:37,120
and understand that that's kind of the approach that you take to building

883
00:52:37,730 --> 00:52:41,134
your quality gates. But let's go into some examples because

884
00:52:41,172 --> 00:52:43,822
you might be thinking well how do we actually build this in our project?

885
00:52:43,876 --> 00:52:46,466
It's great having these quality gates in place, but we're not so sure what to

886
00:52:46,488 --> 00:52:49,954
always do. Here's an example of some code that

887
00:52:49,992 --> 00:52:54,034
can maybe help. And again, these are just high level examples. You could

888
00:52:54,072 --> 00:52:59,122
have find what works for you, but all of these examples

889
00:52:59,186 --> 00:53:02,466
can actually be written within your code, within your CI

890
00:53:02,498 --> 00:53:05,974
CD system to be able to use

891
00:53:06,012 --> 00:53:09,526
it. This is all done within yaml with

892
00:53:09,548 --> 00:53:12,486
these particular things. And you can have a variety of sort of scripts that need

893
00:53:12,508 --> 00:53:16,266
to be able to run. But yeah, whatever it might be in

894
00:53:16,288 --> 00:53:19,194
place, whatever it is that you need to do, these are just some examples of

895
00:53:19,232 --> 00:53:23,034
things that you can do. So look at it and just

896
00:53:23,072 --> 00:53:26,974
then try and figure out what will work best for you. But a pre

897
00:53:27,012 --> 00:53:30,238
deploy test where you're actually running a

898
00:53:30,244 --> 00:53:32,318
job, you're looking at your server and your database, you want to make sure that

899
00:53:32,324 --> 00:53:35,838
everything checks. And you can run some quick bash scripts to be able to just

900
00:53:35,844 --> 00:53:39,570
check that everything's kind of checked out. And basically

901
00:53:39,640 --> 00:53:43,346
really you can write some shell scripts that can quickly just check that everything's up.

902
00:53:43,448 --> 00:53:46,386
So you're actually just checking that your db is up, that your server is up

903
00:53:46,408 --> 00:53:49,854
before you deploy anything. You can do a pre deploy

904
00:53:49,902 --> 00:53:52,534
test and then you can do a post deploy test where, okay great,

905
00:53:52,572 --> 00:53:56,098
now we've done this and I want to run some smoke tests

906
00:53:56,114 --> 00:53:59,490
to make sure that everything's up. And in this particular example we're using Bash

907
00:53:59,570 --> 00:54:02,346
where we're actually just going to run some shell scripts that can check it for

908
00:54:02,368 --> 00:54:05,802
us. But you can also run some more specific

909
00:54:05,856 --> 00:54:09,206
examples. You don't have to use some shell scripts. You can run some actual tests

910
00:54:09,238 --> 00:54:12,698
that you've scripted and then actually just run those functions and

911
00:54:12,864 --> 00:54:16,314
call those functions. You can put this within your actual yaml

912
00:54:16,362 --> 00:54:19,786
code to instigate this quality gate. And so that's really what you'd

913
00:54:19,818 --> 00:54:23,726
want to use when it comes to building your quality gates is use your

914
00:54:23,748 --> 00:54:27,134
yaml. Create your task within yaml and be

915
00:54:27,172 --> 00:54:30,366
able to define what it is that needs to be run.

916
00:54:30,388 --> 00:54:34,558
And you can then within that task, determine the things that needs to

917
00:54:34,644 --> 00:54:37,846
get done. But that doesn't mean that you need to always just run it.

918
00:54:37,868 --> 00:54:40,454
And then how do you know that it's passed and how do you put certain

919
00:54:40,492 --> 00:54:43,782
criteria in place? And here's an example. And again,

920
00:54:43,836 --> 00:54:46,114
I'm going to share these slides so you can have a look at the slides,

921
00:54:46,162 --> 00:54:50,280
download them if you want to have a look at this code in more detail.

922
00:54:53,290 --> 00:54:56,758
But this is just, again, just a quick sort of snapshot of what the

923
00:54:56,764 --> 00:54:59,000
code would look like within,

924
00:55:00,210 --> 00:55:03,278
within your system. But here we go, for instance, where we now want to go

925
00:55:03,284 --> 00:55:05,866
and we want to be able to check things and we can utilize some tools.

926
00:55:05,898 --> 00:55:09,166
We want to be able to execute some code. So for instance, we're using in

927
00:55:09,188 --> 00:55:12,398
this particular example, Kobatura, for a code coverage tool where

928
00:55:12,404 --> 00:55:15,498
we want to now go and actually measure these things. And we're running a task

929
00:55:15,514 --> 00:55:18,866
to be able to run a whole bunch of different jobs. And we can

930
00:55:18,888 --> 00:55:22,802
set a code coverage target of 90. So there is

931
00:55:22,936 --> 00:55:26,306
something where you can actually set a target where it's got to hit. And so

932
00:55:26,328 --> 00:55:30,038
we know that this code coverage target is an output that comes

933
00:55:30,124 --> 00:55:33,206
from our tooling. And now we're saying, okay, great, well,

934
00:55:33,228 --> 00:55:38,006
that output has got to hit 90. So most tooling will return a

935
00:55:38,028 --> 00:55:41,290
result. Even when you're executing your test, they should be pushing some sort of result

936
00:55:41,360 --> 00:55:44,794
back, and you can set what that

937
00:55:44,832 --> 00:55:48,314
target needs to be. So in this case, we're setting the code coverage target needs

938
00:55:48,352 --> 00:55:52,266
to be 90%. And in

939
00:55:52,288 --> 00:55:55,374
this case, all the tests need to pass, and then the code

940
00:55:55,412 --> 00:55:58,926
coverage need to be 90% of whatever's passed. And so we

941
00:55:58,948 --> 00:56:02,398
can specify code coverage target 90, that the actual pass rate needs to

942
00:56:02,404 --> 00:56:05,514
be completely 100. You just go and create another line in there and you specify

943
00:56:05,642 --> 00:56:09,154
it needs to pass 100%. And that helps you with that.

944
00:56:09,192 --> 00:56:12,626
And then you can pass those results and put those results somewhere and

945
00:56:12,648 --> 00:56:15,794
store them in a location so that we can still find them

946
00:56:15,832 --> 00:56:19,498
later. And all of this within your CI CD type, within your CI

947
00:56:19,534 --> 00:56:22,786
CD tooling, you should be able to then go and view, and that helps

948
00:56:22,818 --> 00:56:26,470
us. And you can go check it there. And then the same with just ensuring

949
00:56:26,970 --> 00:56:30,582
your scans. You can actually go and check scans and see how

950
00:56:30,636 --> 00:56:34,026
successful were your scans. And so this is just another example of

951
00:56:34,048 --> 00:56:37,226
things that we can do. When we're running any sort of scan policy, we can

952
00:56:37,248 --> 00:56:40,422
actually go and have a look at the different sort of critical, high, medium,

953
00:56:40,486 --> 00:56:44,286
low sort of risks that are raised and we can actually set some

954
00:56:44,308 --> 00:56:46,000
standards in place and say, well,

955
00:56:47,730 --> 00:56:51,070
do these scans bring me results that I'm happy with?

956
00:56:51,140 --> 00:56:54,338
And am I happy that it's met the criteria that we want? And you can

957
00:56:54,424 --> 00:56:57,726
use those variables and put in a variable to say that I'm

958
00:56:57,758 --> 00:57:00,802
happy with what's been achieved and I'm happy

959
00:57:00,856 --> 00:57:04,126
that there's no major severities.

960
00:57:04,238 --> 00:57:08,306
And so therefore our code is safe. But if there's any major severities get

961
00:57:08,328 --> 00:57:10,998
picked up, we can stop the bold right there and say, this is not a

962
00:57:11,004 --> 00:57:14,534
safe bold, let's stop. So these are great things that we can do and

963
00:57:14,572 --> 00:57:17,590
put in place. And so this is some code that you can think of.

964
00:57:17,660 --> 00:57:20,714
And again, these are things that you can play with. Have a look and see

965
00:57:20,752 --> 00:57:23,994
how you could utilize it in your own space with your own tooling. It's just

966
00:57:24,032 --> 00:57:29,658
an example of some code that you can write that can start building quality

967
00:57:29,744 --> 00:57:32,906
gates within your CI CD tooling. It's a lot easier to do it

968
00:57:32,928 --> 00:57:35,694
when it comes to test results where you can literally go and make sure that

969
00:57:35,732 --> 00:57:39,726
all the tests need to pass and you can set that to any

970
00:57:39,748 --> 00:57:42,942
sort of thing. The process has to run completely, particularly when you're running

971
00:57:42,996 --> 00:57:46,206
sort of your integration end to end test. You can set it where the whole

972
00:57:46,228 --> 00:57:48,878
thing needs to run and so the single failure will throw it and it won't

973
00:57:48,894 --> 00:57:52,386
deploy it any further. Things that you can put

974
00:57:52,408 --> 00:57:56,430
in place, but if you utilize in some sort of process like Yaml

975
00:57:56,510 --> 00:57:59,470
within your pipelines, it's very easy to write a YAml script that can add in

976
00:57:59,480 --> 00:58:03,094
that step and within that phase, put in that step and then building that quality

977
00:58:03,132 --> 00:58:07,126
gate. So from a coding perspective, it's actually quite easy to do and

978
00:58:07,148 --> 00:58:10,666
to build these quality gates. It's getting the processes and

979
00:58:10,688 --> 00:58:14,218
the actual systems around that correct

980
00:58:14,304 --> 00:58:18,106
and in place to be able to make

981
00:58:18,128 --> 00:58:21,018
use of them correctly and to be able to build in the effective measures where

982
00:58:21,024 --> 00:58:24,210
we can actually test our software more effectively.

983
00:58:24,390 --> 00:58:27,550
But yeah, very important. So this is some code examples for that.

984
00:58:27,700 --> 00:58:30,510
And then the last thing I wanted to just talk about is observability.

985
00:58:31,570 --> 00:58:35,870
Because I think with anything CI CD related, it's not just about it

986
00:58:36,020 --> 00:58:38,514
passing through and moving on to the next step. And the next step it really

987
00:58:38,552 --> 00:58:41,806
becomes around us being able to make use of our software

988
00:58:41,918 --> 00:58:45,630
being observable. And if we don't have observability

989
00:58:45,710 --> 00:58:49,646
in our CI CD pipelines, we are losing out

990
00:58:49,688 --> 00:58:53,446
a lot of what value it can give

991
00:58:53,468 --> 00:58:56,646
us. So it's not just about it running through the process and then we

992
00:58:56,748 --> 00:59:00,498
just trust it. There's a lot of observability and things that need to happen and

993
00:59:00,524 --> 00:59:04,186
things that we can track to then be able to also building around our

994
00:59:04,208 --> 00:59:07,738
CI CD tooling that can give us better quality. Things like

995
00:59:07,824 --> 00:59:11,002
collecting data from multiple sources. And how do we collect that data?

996
00:59:11,056 --> 00:59:15,502
Because your CI CD pipelines typically running

997
00:59:15,556 --> 00:59:19,406
and deploying a system, and then you've got your unit tests that are running and

998
00:59:19,428 --> 00:59:23,380
then it will push that output somewhere. You might typically have

999
00:59:25,910 --> 00:59:29,778
your integration test or your end to end test written by your

1000
00:59:29,784 --> 00:59:33,950
testing team, maybe outputting somewhere else in a different location.

1001
00:59:34,110 --> 00:59:36,926
Then you have your scan results pushing to another location.

1002
00:59:37,118 --> 00:59:40,882
You then have things like performance tests,

1003
00:59:41,026 --> 00:59:44,454
any sort of things where we're actually monitoring what's going on with

1004
00:59:44,492 --> 00:59:47,974
our sort of system, our server, what is

1005
00:59:48,012 --> 00:59:51,474
our server operation like? What's our cpu

1006
00:59:51,522 --> 00:59:54,450
usage while this thing is running? We can check all of that stuff if we

1007
00:59:54,460 --> 00:59:57,386
wanted to. All of that will then store to another sort of thing. And so

1008
00:59:57,408 --> 00:59:59,946
what happens is that there's a whole bunch of data that goes all over the

1009
00:59:59,968 --> 01:00:03,686
place. And I think the biggest problem is we have the CRCD tooling

1010
01:00:03,718 --> 01:00:06,478
in place and then we allow that data to sit all over the place.

1011
01:00:06,644 --> 01:00:10,174
And yes, we can build the quality gates around that will

1012
01:00:10,212 --> 01:00:13,818
stop and prevent it from moving forward. But we're not digging

1013
01:00:13,914 --> 01:00:16,766
deeper into the software and understand how it all works. And so the best thing

1014
01:00:16,788 --> 01:00:19,186
to do is to take all the data, collect it from multiple sources and store

1015
01:00:19,208 --> 01:00:22,578
it into a central location. And you

1016
01:00:22,584 --> 01:00:25,186
can build APIs to go and automate that data gathering where it can go and

1017
01:00:25,208 --> 01:00:28,914
put everything in one location of this is our CI CD

1018
01:00:28,962 --> 01:00:32,658
information that we need and it's all in one location. And the reason why that's

1019
01:00:32,674 --> 01:00:36,066
important is because then we can use logging correctly.

1020
01:00:36,178 --> 01:00:39,560
So there's failures during the process and things are going on.

1021
01:00:40,330 --> 01:00:43,866
But now we have logging and everything centralized and we can

1022
01:00:43,888 --> 01:00:47,626
now monitor this database and it's very

1023
01:00:47,648 --> 01:00:50,026
easy to now go, okay, this is the log, this is the issue. And then

1024
01:00:50,048 --> 01:00:53,562
we can go and actually delve deeper into the issue because our quality

1025
01:00:53,616 --> 01:00:56,366
gates will have failures and we're going to have a lot of failures during our

1026
01:00:56,388 --> 01:00:59,258
process. But what actually went wrong with the software and the application, and if it's

1027
01:00:59,274 --> 01:01:02,960
going to take you ages to figure out what went wrong with your application.

1028
01:01:04,050 --> 01:01:06,910
We're not speeding up the process in any way. So again,

1029
01:01:06,980 --> 01:01:10,466
logging and monitoring becomes important because then you're able to actually go in and see

1030
01:01:10,488 --> 01:01:13,614
what was logged in the software now because you've pulled everything together in a centralized

1031
01:01:13,662 --> 01:01:16,978
way, you can follow, okay, well, this was logged here and this

1032
01:01:16,984 --> 01:01:20,950
is what happened at the next phase. And it failed this quality gate here because,

1033
01:01:21,100 --> 01:01:23,718
and we can see what went on in the code in that level and we

1034
01:01:23,724 --> 01:01:27,158
can pull everything together and we can use login to

1035
01:01:27,164 --> 01:01:30,666
delve deeper, but we can also monitor the health of that. And so you can

1036
01:01:30,768 --> 01:01:35,114
have triggers in place and alerting in place that

1037
01:01:35,152 --> 01:01:38,586
can trigger and alert you when quality gates have failed and

1038
01:01:38,608 --> 01:01:42,118
allow you why. And you can also put dashboards in place that can maybe showcase

1039
01:01:42,214 --> 01:01:45,914
system health wasn't great there, or this test was failing, or this particular scan

1040
01:01:45,962 --> 01:01:49,230
kept on failing. And you can also track the lifecycle over time.

1041
01:01:49,300 --> 01:01:52,414
So your CRCD pipelines ran a thousand times this

1042
01:01:52,452 --> 01:01:55,890
month. And you can start saying, well, this quality

1043
01:01:55,960 --> 01:01:59,250
gate failed more often than any other quality gate. Why?

1044
01:01:59,320 --> 01:02:02,850
And you can also start to use your quality gates to get even better

1045
01:02:02,920 --> 01:02:06,638
where, okay, maybe your quality gate standards are too strict,

1046
01:02:06,734 --> 01:02:10,054
but also maybe we're just not doing something right and we need to change

1047
01:02:10,092 --> 01:02:13,654
the way that we're working and improve the way that we're building our software or

1048
01:02:13,692 --> 01:02:17,154
our processes in place so that we can hit that quality gate

1049
01:02:17,202 --> 01:02:20,760
more often. And so again, if you have all that place,

1050
01:02:21,450 --> 01:02:24,518
all that data in one place and you've got the right sort of visualization,

1051
01:02:24,614 --> 01:02:27,930
you can see those things. And again, it helps you to build better quality

1052
01:02:28,000 --> 01:02:31,178
software as a result of it. You can keep track of,

1053
01:02:31,184 --> 01:02:34,414
obviously, your data retention policies while you're doing this. That's important.

1054
01:02:34,532 --> 01:02:37,818
I sort of put that point in that whenever you're working with data, be aware

1055
01:02:37,834 --> 01:02:42,926
of data retention policies. You don't want to store this information all

1056
01:02:42,948 --> 01:02:45,546
the time. You don't want to have years and years and years worth of CI

1057
01:02:45,578 --> 01:02:49,138
CD information. It's not worth your while. You often want

1058
01:02:49,144 --> 01:02:51,474
to just track certain things. You might want to keep around for a while,

1059
01:02:51,512 --> 01:02:54,894
but typically three to six months for anything CI CD related,

1060
01:02:55,022 --> 01:02:58,066
you can have it and you can start flushing it out. And then you don't

1061
01:02:58,088 --> 01:03:01,206
want to store stuff, particularly if you're moving quite quickly with

1062
01:03:01,228 --> 01:03:04,886
your development. You don't want to store stuff that's been around for a long time

1063
01:03:05,068 --> 01:03:08,178
and then try and track, well, six months ago this happened in our CI

1064
01:03:08,194 --> 01:03:11,446
CD tooling. Why you might not need

1065
01:03:11,468 --> 01:03:14,378
that information, get rid of it. But yeah,

1066
01:03:14,464 --> 01:03:17,866
I think an important part is to then continuously monitor and optimize. So it's not

1067
01:03:17,888 --> 01:03:22,234
just about putting your quality gates in place and leaving them there with

1068
01:03:22,272 --> 01:03:26,554
anything software related. Continuously monitor the effectiveness of your quality gates optimize.

1069
01:03:26,602 --> 01:03:29,230
See how you can do better, see how you can make your CI CD process

1070
01:03:29,300 --> 01:03:32,734
better, see how you can make your quality gates better, see how you can

1071
01:03:32,772 --> 01:03:35,986
design your software and change your software to better meet your quality gates. All of

1072
01:03:36,008 --> 01:03:39,810
that's important and I think that's why I wanted to talk about observability

1073
01:03:40,710 --> 01:03:43,906
before closing out the talk, because if

1074
01:03:43,928 --> 01:03:47,474
we don't have some level of observability, we're not really

1075
01:03:47,512 --> 01:03:51,058
understanding what's going on going on with our software and we can't improve it properly.

1076
01:03:51,154 --> 01:03:54,440
So very important thing to have in place and so

1077
01:03:54,970 --> 01:03:58,278
important to have observability. The thing about observability, whenever it comes to

1078
01:03:58,284 --> 01:04:01,114
your CI CD pipelines and your quality gates, and if you have that in place,

1079
01:04:01,152 --> 01:04:05,082
you can start utilizing your quality gates to be able to build better

1080
01:04:05,136 --> 01:04:09,226
software. So I've covered quite a lot in this talk and

1081
01:04:09,248 --> 01:04:13,094
so I really want to encourage you if you've listened to this talk and you've

1082
01:04:13,142 --> 01:04:16,638
really enjoyed it and learned a lot, but if

1083
01:04:16,644 --> 01:04:20,222
you do have any questions, please feel free to contact me in the Discord channel

1084
01:04:20,276 --> 01:04:23,326
on the conference and we can talk about these ideas a little

1085
01:04:23,348 --> 01:04:26,418
bit better. And I'm really keen to be able to hear your feedback and maybe

1086
01:04:26,504 --> 01:04:29,746
answer some of your questions and maybe some challenges that you're having in your

1087
01:04:29,768 --> 01:04:33,262
space around quality gates or CRCD pipelines,

1088
01:04:33,326 --> 01:04:36,978
or how to change your testing or your software design to be able to better

1089
01:04:37,064 --> 01:04:40,686
achieve this within your software or any sort of other sort of coding

1090
01:04:40,718 --> 01:04:43,286
related questions. If you're not so sure how to build a quality gate, let's talk

1091
01:04:43,308 --> 01:04:46,806
about that. But I look forward to hearing more about it from everyone. And thank

1092
01:04:46,828 --> 01:04:50,102
you so much for listening to this talk. I've really enjoyed being able to present

1093
01:04:50,156 --> 01:04:53,766
this and I really hope that it's going to be helpful to

1094
01:04:53,788 --> 01:04:57,414
many of you to be able to start making changes in your own

1095
01:04:57,612 --> 01:05:01,022
software delivery process by putting quality gates in place

1096
01:05:01,076 --> 01:05:04,334
that can really deliver real results and allow you to be able to

1097
01:05:04,452 --> 01:05:07,854
deliver software that really is of a great

1098
01:05:07,892 --> 01:05:10,030
quality. Thank you so much for listening.

