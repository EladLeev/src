{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/f936c6cb-4332-45cd-9dc1-10d65f286122", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["basic", "be", "beyond", "browser", "can", "case", "circuit", "circuits", "collection", "complex", "composed", "comprises", "computing", "conf fourty two", "core", "created", "editors", "existing", "features", "formats", "gates", "highperformance", "httpsuraniumtransilvaniaquantumorg", "intends", "larger", "nisq", "offline", "opensource", "placed", "productive", "provide", "qubits", "radu marginean", "reused", "simulated", "software developer", "supports", "twoqubit", "understood", "uranium visual platform", "using"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "id": "669ed034-5710-4a18-8b97-c7450e22ca58", "status": "completed", "error": null, "text": "Many of the quantum circuits used in the niscar and beyond can be understood visually as a collection of gates placed in a circuit, according to some better one. Of course, the purpose of any circuit is mainly a specification on how to perform a quantum computation. However, judging by the managed circuits running one algorithm are often reused in more complicated ones. The visual aspect is an important factor for both understanding the inner working of an algorithm and how this can be reused to build more advanced ones. As a concrete example, we show here an implementation of the Grover search algorithm on five qubits. What the algorithm does is that it permits searching an unstructured data set for a particular value. 1 may observe that the circuit is initialized in a default state, which usually is chosen to be the state where all qubits are in the zero state. The six ancillary qubit is initialized in one state. Next, the level of Hadamar gates is applied. The effect of Hadamar gates is to transform the initial state to a superposition of all possible states. You may have heard sometime the statement that the quantum device computes all possible results in parallel. This statement is, of course a bit of a stretch, but it captures the rationale between this step, which is using many other algorithms. Next, we apply a series of gates that implement the algorithm itself. The same circuit can be drawn in a more compact manner like this one. We see that first we apply an oracle subsurface, whose purpose is to mark the state we want to measure by flipping its face, and next we apply the so called Grover diffusion operator, which has the effect of inverting each 32 values stored in the first five qubits around their global mean value. Overall, these two gates have the effect of increasing the probability of measuring the state flagged by oracle as a solution and decreasing the probability of measuring any other state. The combination of oracle and diffusion operator is applied several times in a row, and during each iteration the probability of measuring the state we are searching for increases, while the probability of measuring the other state decreases. The results that we get when we perform the final set of measurements on the top five qubits is not to be found with 100% certainty, but is captured with very high probability. As another example, we show here an implementation of quantum phase estimation, which, like Grober, is not only a significant algorithm by itself, but is often reused as a subcomponent in many other algorithms. Here we also see the familiar construction of using a layer of Hadamar gates in the preparation of the initial state for the top five qubits. What is also important to remark here is that the state of lower three qubits is prepared to be an eigen state of the operator u whose eigenvalue we want to measure. As a consequence of this, whenever we apply a control u operation on a bottom three qubit due to a phenomenon named phase give back, the phase of u is recorded bit by bit on the top control qubits. The case of u can be linked to the eigenvalue of u and can be read out at the end of the experiment by layer of measure gates shown here in red after we applied an inverse quantum free a transform gate because the phase was written in free a bases, while when we make a measurement on a quantum computer we usually measure in the standard Z base. What we have seen so far is that the use case for designing circuits visually using an editor is a very strong one. However, most of the existing circuit editors are rather limited. Uranium is a platform that intends to fill this unoccupied space. It is open source and free to use. At its core it comprises can advanced circuit editor which is easy to work with and powerful, and a high performance simulator, and written eras that can run both in your browser and offline. As a concrete example, here is how one can start using our editor. First of all, you need to pick up gate and drag and drop it into the editor area. Now you may ask, do I need to do that for every gate that I want on my circuit? The answer is not once you have added a gate, you can easily duplicate it. You can generate an array of identical gates of an existing one. You can select a portion of a circuit which you can copy, you can paste or if you wish, you can erase. Circuits can be reused in a sense that smaller circuits can be saved in a project and reused that gates in a larger circuit from the same project. For example like this one. We also provide a very simple python API which one can use to generate circuits programmatically. After doing that, circuits can be imported in your existing projects. Another very useful feature is, especially when working with compostable circuits, is the ability to replicate a gate. This permits you to generate an array of circuits of gates like this, one of the similar kinds that you have seen in quantum case estimation and are very often used in many other algorithms of the same inspiration for editing gate parameters, you can of course interact with the gate pop up. So basically when you add a gate and you can add for those gates that accept parameters, you can add parameters from the gate pop up, you can duplicate the gate and parameters will be copied identically, there are a number of shortcuts between two editors such that you can quickly switch from one gate on another or quickly delete a gates. Measure gates behave a little bit different perhaps I should first explain what is the role of the measure gates in our editor. Because we display probability distribution, we do not make sampling when you add a measure gate, but what it happens. Well, if no measure gates are added to the circuit, the output results for the simulation will display results for the full Hilbert space covered by the circuit. In this case, we have a circuit with four qubits and the simulation results have four states. When we add a measure gate to the circuit, what the editor does is to select a portion or subspace of the Hilbert space in order to display results and ignore the other one which is not covered by measure gates. Whenever you add a measure gate to the circuit, it will assign a classic bit to the measure gates and usually the index of the classic bit is taken to be the same with the index of the target bit. However, for example, when you generate can array of measure gates, this behavior might occasionally be different because the editors tries to think to guess which is the best configuration of measurements that you want to apply. In general, whenever you are uncertain about the state of the circuit at training moment, you can use this tooltip button which will show the parameters for all those gates which have parameters. And basically this is a very handy tool to figure out what is the current state of your circuit at any time. We support a large collection of gates, many of which are not to be found elsewhere. So of course we support the standard polygates xyz gates. We support other created closely related gates like v, which is the square root of x, h which is square root of y and s, which is the square root of z and t, which is square root of f of s. We support of course, arbitrary rotation on the blocks here around the x, y and z axis. We support the Hadamar gates which is used in almost every algorithm, but we support some other gates. For example, what Hadamar gate is is a rotation on the diagonal axis in Zx plane. So besides this standard Hadamar gate, there are two other Hadamar gates which are occasionally useful, and this represent PI rotation around the diagonal axis in the y, z and xy plane. We support standard parametric gates ranging from one to three parameters. We support the sea gate which performs a permutation on the x, y and z axis. We support integral root of x, y and z gates which are used, for example, in quantum free transform circuits for the two qubit gates. We of course support the swap gate and various variants of swap like parametric swap or iswap, and several others. We support the so called icing gates, which are native gates to trap driven ion devices. We support the Magic gate. We support the Givens gate, which is used occasionally in computational chemistry. We support the cross resonance gate, which is a native gate in superconductic base devices. And in general you can add any numbers of controls to a gate. For example, you can add controls in the Z basis like this. Sorry, but you can also add controls in the X basis, or you can add controls in the Y basis. You can add controls either by dragging the control icon from the top left of the UI, or you can add controls from the gate pop up dialog where you can add a little bit faster and larger number of controls. We also support the aggregate gate, which is a method to group several gates together and assign them a common set of controls. For example, here is an implementation of the Steen error correction code in general, where you are unsure what a gate does. You can use our help facility how it works. You select a gate from the gate panel on the left and push the help button. If you unselect the gate, you'll get to a general section that will give you some hints on general hints for using our editor an important detail when we display our simulation result is the choice of ordering for qubits when representing quantum states. Most quantum textbook use the big indian ordering, while many commercial hardware quantum computing platform use the little indian ordering because interpreting gates as binary numbers makes sense. Using the letter collection, we provide support for both. When simulating quantum circuits, you can simulate circuits with up to 27 qubits online. The simulator was written in rust complex webassembly and runs very fast in your browser, surprisingly fast. A 20 qubit circuit with 300 gigs is simulated in less than 1 second. We also support we provide support for simulating circuits with up to 32 qubits offline, an important aspect to be reused. Our platform is not an isolated island in the space of quantum computing software. We provide support for exporting quantum circuits to Kiskit and OpencaSm format. We also provide support for running your circuits directly on IBMQ quantum devices. For this you need to go to one of your projects, select a circuit you want to run on, and then press the ping IBMQ button. This will take a few seconds because this will make an API call towards IBM on the cloud. But eventually you are going to see here a list of quantum devices which you are allowed to use. Unfortunately, I have a basic ABM Q account, and I have only access to real devices, up to seven qubits. You may be able to do more. At any rate, you also have access to some very performance simulators. For example, there is a tensor network simulator which can simulate circuits with up to 100 qubits. At this moment, you can easily create circuits in our editor with up to even 30 qubits or more. It may be a bit more tedious for the very largest one, but it can definitely be done. And in general it can be done fast and easily. To be fair, if you work with 30 qubits, a larger display might help, but you also provide a zoom in zoom out function which allows you to accommodate circuits with up to even 32 qubits on the display of a laptop. In the future, we want to scale our editor to hundreds of, even perhaps thousands of qubits by supporting circuits like this one. What you should note here is the dots, meaning that you could in principle will make circuits with an arbitrary large number of qubits. Another interesting feature that we might try to add support for is running semi classical quantum algorithms like VQE and QA using our simulator. In the end, I would like to invite you to try out our editor and you have any kind of feedback, questions or feature requests, please contact us on Discord. Thank you very much.", "words": [], "utterances": null, "confidence": 0.940324926402948, "audio_duration": 846.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Many of the quantum circuits used in the niscar and beyond can be understood visually as a collection of gates placed in a circuit. Circuits running one algorithm are often reused in more complicated ones. Uranium is a platform that intends to fill this unoccupied space.\n- In the future, we want to scale our editor to hundreds of, even perhaps thousands of qubits. Another interesting feature that we might try to add support for is running semi classical quantum algorithms like VQE and QA using our simulator. If you have any feedback, questions or feature requests, please contact us on Discord.", "auto_highlights_result": {"status": "success", "results": [{"count": 7, "rank": 0.1, "text": "measure gates", "timestamps": [{"start": 193952, "end": 194614}, {"start": 346342, "end": 347094}, {"start": 352628, "end": 353194}, {"start": 365192, "end": 365726}, {"start": 398128, "end": 399210}, {"start": 405844, "end": 406714}, {"start": 416088, "end": 417090}]}, {"count": 5, "rank": 0.1, "text": "Hadamar gates", "timestamps": [{"start": 67384, "end": 68174}, {"start": 69848, "end": 70574}, {"start": 163268, "end": 164074}, {"start": 492688, "end": 493830}, {"start": 510052, "end": 510874}]}, {"count": 1, "rank": 0.1, "text": "gate parameters", "timestamps": [{"start": 319486, "end": 320478}]}, {"count": 1, "rank": 0.09, "text": "several gates", "timestamps": [{"start": 632220, "end": 632914}]}, {"count": 1, "rank": 0.09, "text": "native gates", "timestamps": [{"start": 568872, "end": 569742}]}, {"count": 1, "rank": 0.09, "text": "interpreting gates", "timestamps": [{"start": 678636, "end": 679510}]}, {"count": 1, "rank": 0.09, "text": "identical gates", "timestamps": [{"start": 257556, "end": 258830}]}, {"count": 1, "rank": 0.09, "text": "standard parametric gates", "timestamps": [{"start": 521990, "end": 523890}]}, {"count": 1, "rank": 0.09, "text": "circuit editor", "timestamps": [{"start": 226622, "end": 227498}]}, {"count": 3, "rank": 0.09, "text": "quantum circuits", "timestamps": [{"start": 17988, "end": 18842}, {"start": 690902, "end": 691734}, {"start": 723886, "end": 724798}]}, {"count": 1, "rank": 0.08, "text": "quantum free transform circuits", "timestamps": [{"start": 548190, "end": 550410}]}, {"count": 1, "rank": 0.08, "text": "smaller circuits", "timestamps": [{"start": 274728, "end": 275534}]}, {"count": 1, "rank": 0.07, "text": "compostable circuits", "timestamps": [{"start": 298752, "end": 299954}]}, {"count": 1, "rank": 0.06, "text": "quantum states", "timestamps": [{"start": 669742, "end": 670690}]}, {"count": 1, "rank": 0.06, "text": "two other Hadamar gates", "timestamps": [{"start": 509620, "end": 510874}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}