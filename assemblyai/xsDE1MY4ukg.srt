1
00:00:23,240 --> 00:00:26,600
Everyone, welcome at my talk, typesafe client

2
00:00:26,680 --> 00:00:30,372
for smart contracts. Actually, I told

3
00:00:30,426 --> 00:00:34,036
a little bit different in the intro, but actually that's what

4
00:00:34,058 --> 00:00:37,300
we're going to look at. So we're going to look

5
00:00:37,370 --> 00:00:40,988
at how we can parse smart contracts and generate typescript

6
00:00:41,024 --> 00:00:44,712
definitions for that. Now, first of all,

7
00:00:44,846 --> 00:00:48,836
my name is Albert Rotede. I'm the architect at Kadena

8
00:00:48,868 --> 00:00:51,160
for developers Experience squad.

9
00:00:52,860 --> 00:00:57,608
We work with developers and the core teams to achieve

10
00:00:57,704 --> 00:01:01,100
the most convenient way possible

11
00:01:01,250 --> 00:01:04,830
for our end users. But first,

12
00:01:05,200 --> 00:01:09,016
let's go into what this is. So what we actually built is Kadena

13
00:01:09,048 --> 00:01:13,696
client. Kadena client is a multipurpose tool to

14
00:01:13,798 --> 00:01:17,996
build transactions, sign transactions, and submit

15
00:01:18,028 --> 00:01:21,376
those transactions to the blockchain and listen to any events

16
00:01:21,408 --> 00:01:25,060
that happen after they have been submitted.

17
00:01:25,480 --> 00:01:29,200
But first, something else. Who knows

18
00:01:29,280 --> 00:01:33,110
what this is? Who knows the series? Whats this is?

19
00:01:33,660 --> 00:01:37,784
This is actually a very nice

20
00:01:37,982 --> 00:01:41,780
series that I like. I like the environments

21
00:01:41,940 --> 00:01:45,692
and the way it's portrayed. And actually,

22
00:01:45,826 --> 00:01:49,768
this is, anyone who knows

23
00:01:49,944 --> 00:01:53,916
already know whats it's whats this is. This is

24
00:01:53,938 --> 00:01:58,000
actually the expanse. So let's imagine

25
00:01:58,580 --> 00:02:02,944
that you are a consumer and

26
00:02:03,062 --> 00:02:06,544
you are paying youre bills for what you

27
00:02:06,582 --> 00:02:10,196
consume. In this case, Netflix is the

28
00:02:10,218 --> 00:02:13,940
one that is the receiver

29
00:02:14,440 --> 00:02:18,150
of a certain amount of money from youre.

30
00:02:18,600 --> 00:02:21,828
Now, we can actually do this in a smart contract.

31
00:02:22,004 --> 00:02:26,068
Imagine building a service where you offer subscriptions

32
00:02:26,164 --> 00:02:29,784
to give users access to

33
00:02:29,822 --> 00:02:32,968
all the streams that you have available. And let's imagine that we

34
00:02:32,974 --> 00:02:36,300
do this on the blockchain. So how would youre go about that?

35
00:02:36,450 --> 00:02:40,300
Well, first we would create a function called a subscribe.

36
00:02:40,880 --> 00:02:44,204
So here in the subscribe function, youre can pass two things.

37
00:02:44,322 --> 00:02:47,730
One is the account and the months.

38
00:02:48,260 --> 00:02:52,204
Well, actually, the subscribe function in the smart contract holds

39
00:02:52,252 --> 00:02:55,840
some logic that automates secrets

40
00:02:56,260 --> 00:02:59,844
and enforces some predefined arguments without the

41
00:02:59,882 --> 00:03:03,940
need of an intermediate party or centralized authority.

42
00:03:04,520 --> 00:03:08,832
Except this intermediate party is the blockchain, which is a decentralized

43
00:03:08,896 --> 00:03:12,792
one. In the case of subscription, we have

44
00:03:12,846 --> 00:03:16,808
two arguments. One argument is called accounts and one

45
00:03:16,894 --> 00:03:21,108
month. Each of those represents a part of the agreement

46
00:03:21,284 --> 00:03:24,120
that we make between two parties.

47
00:03:24,720 --> 00:03:27,736
Account and months have to be filed somewhere.

48
00:03:27,928 --> 00:03:31,644
In this case, the months and the

49
00:03:31,682 --> 00:03:35,276
account is being written to a record. We have

50
00:03:35,298 --> 00:03:39,276
a function that's available in the smart tv smart

51
00:03:39,308 --> 00:03:42,556
contract. Netflix's smart contracts. It writes

52
00:03:42,588 --> 00:03:46,770
a record and then retrieves it by the key of the account name.

53
00:03:47,220 --> 00:03:51,076
And this is then stored in a database. And for

54
00:03:51,098 --> 00:03:55,028
the amount of months, we multiply that with a certain amount of money,

55
00:03:55,114 --> 00:03:58,976
which is then paid for. So we think of smart contracts

56
00:03:59,008 --> 00:04:02,964
as sort of digital agreements that automatically

57
00:04:03,012 --> 00:04:07,050
execute themselves when some predefined conditions are met,

58
00:04:07,500 --> 00:04:11,908
and we want to record that payment in the blockchain.

59
00:04:12,084 --> 00:04:15,596
So to do that, we execute inside

60
00:04:15,698 --> 00:04:19,132
the subscribe function body another write

61
00:04:19,186 --> 00:04:23,256
record, which actually is something from a different smart

62
00:04:23,288 --> 00:04:26,828
contract. The smart contract called coin,

63
00:04:27,004 --> 00:04:31,088
where we transfer money. In this case, we transfer money

64
00:04:31,254 --> 00:04:34,688
from the sender, represented by the account of

65
00:04:34,694 --> 00:04:38,080
the user, to the receiver.

66
00:04:38,440 --> 00:04:41,750
In this case, whoever accepts this payment,

67
00:04:42,440 --> 00:04:45,892
and then some amount, which is the amount

68
00:04:46,026 --> 00:04:49,524
that's calculated, times some price under

69
00:04:49,562 --> 00:04:53,784
the hood. When this call happens, it will include the

70
00:04:53,822 --> 00:04:58,184
coin module. The coin module itself has its own schema that

71
00:04:58,222 --> 00:05:01,640
will hold the amount of coins that someone

72
00:05:01,710 --> 00:05:05,276
owns. Whenever the transfer function is

73
00:05:05,298 --> 00:05:09,500
being called, the sender's balance is checked

74
00:05:10,000 --> 00:05:13,596
whether it's sufficient in order to deduce the balance such that it

75
00:05:13,618 --> 00:05:17,104
doesn't go below zero. In this case,

76
00:05:17,142 --> 00:05:20,576
the key of each record is the account name, and the

77
00:05:20,598 --> 00:05:23,120
value in this case is the balance.

78
00:05:23,780 --> 00:05:27,760
So, a smart contract is

79
00:05:27,830 --> 00:05:32,192
a piece of code that is stored on a decentralized

80
00:05:32,256 --> 00:05:35,536
platform. A smart contract contains

81
00:05:35,728 --> 00:05:39,152
a definition of a schema and definitions.

82
00:05:39,296 --> 00:05:42,680
To interact with a schema, a function

83
00:05:42,830 --> 00:05:46,280
can then restrict the operations that you can

84
00:05:46,430 --> 00:05:50,010
do in that schema. In short,

85
00:05:50,460 --> 00:05:54,048
a smart contract is a set of secure,

86
00:05:54,244 --> 00:05:58,140
serverless functions that can interact with a database

87
00:05:58,640 --> 00:06:02,476
on a decentralized platform. So how do we do that?

88
00:06:02,578 --> 00:06:06,084
We do that by using pact. Pact is a turing

89
00:06:06,152 --> 00:06:09,676
incomplete language that provides an interface to the Kadena

90
00:06:09,708 --> 00:06:13,520
blockchain. Now, what does Turing incomplete mean?

91
00:06:13,670 --> 00:06:16,816
Turing incomplete means that there's no way to

92
00:06:16,838 --> 00:06:20,368
do recursion or loops, which actually

93
00:06:20,454 --> 00:06:23,380
makes the language a lot more safe.

94
00:06:23,960 --> 00:06:27,408
It means that you cannot make the mistakes that you can make with other languages.

95
00:06:27,504 --> 00:06:31,488
For example, you cannot get into an infinite loop, and the loop

96
00:06:31,664 --> 00:06:35,208
is limited to the size of whatever you're working with.

97
00:06:35,374 --> 00:06:38,788
So you can only apply a function on a set of items

98
00:06:38,804 --> 00:06:41,896
in, for example, an array or a list. You can

99
00:06:41,918 --> 00:06:45,436
also not get into stack overflow errors when

100
00:06:45,458 --> 00:06:48,892
you are doing a recursion or a while loop that's never

101
00:06:48,946 --> 00:06:51,980
stopping. But because of these limitations,

102
00:06:52,880 --> 00:06:57,360
we can introduce something called model checking.

103
00:06:57,700 --> 00:07:01,360
Model checking is the way we can make

104
00:07:01,430 --> 00:07:05,180
our smart contracts 100% testable,

105
00:07:05,340 --> 00:07:08,480
and this is done by executing former verification.

106
00:07:09,320 --> 00:07:12,164
Let's look at that. To give an example,

107
00:07:12,282 --> 00:07:15,984
the transfer function in this case has a conserve

108
00:07:16,032 --> 00:07:20,150
mass property. The conserve mass property

109
00:07:20,920 --> 00:07:24,120
means that in the table of the smart contract,

110
00:07:24,860 --> 00:07:28,260
all the end results of all the balances accumulated

111
00:07:28,340 --> 00:07:32,040
needs to be zero. I mean, it should conserve mass

112
00:07:32,190 --> 00:07:35,788
youre cannot introduce new money, you cannot deduct new money

113
00:07:35,954 --> 00:07:39,756
from the system as a whole. Now if

114
00:07:39,858 --> 00:07:43,230
a certain function, for example the transfer function in this case

115
00:07:43,760 --> 00:07:47,164
would be able to remove

116
00:07:47,212 --> 00:07:50,450
money from the system or print money into the system,

117
00:07:51,140 --> 00:07:53,920
then this conserve mass model would fail.

118
00:07:54,340 --> 00:07:58,044
So the combination of a language being Turing

119
00:07:58,092 --> 00:08:01,476
incomplete and whats form of verification makes it

120
00:08:01,498 --> 00:08:04,980
a very very smart contract language.

121
00:08:05,480 --> 00:08:08,820
And we actually have a nice overview of

122
00:08:08,890 --> 00:08:12,760
the things that could be saved

123
00:08:13,260 --> 00:08:16,872
by Kadena. When youre would use the

124
00:08:17,006 --> 00:08:21,156
packed smart contract language instead of know competing

125
00:08:21,188 --> 00:08:25,020
blockchain language that is not Turing incomplete,

126
00:08:25,440 --> 00:08:27,950
you would have been able to save a lot of money.

127
00:08:28,480 --> 00:08:32,184
So quick recap onto smart

128
00:08:32,232 --> 00:08:35,864
contracts. A piece of code that is stored on a decentralized

129
00:08:35,912 --> 00:08:39,010
platform. You could say a serverless function

130
00:08:39,700 --> 00:08:44,192
contains a definition of a schema and functions to interact with a schema and

131
00:08:44,326 --> 00:08:48,050
a function can restrict these operations. How do we do that?

132
00:08:48,520 --> 00:08:51,030
Let's go into this one first.

133
00:08:51,400 --> 00:08:54,884
Here we see that we have the

134
00:08:54,922 --> 00:08:58,932
coin schema. So this is a schema definition of

135
00:08:58,986 --> 00:09:02,264
what this particular smart contract will work with.

136
00:09:02,382 --> 00:09:06,664
In this case, the coin smart contract will work with a

137
00:09:06,702 --> 00:09:10,260
key value pair where the value is defined

138
00:09:10,340 --> 00:09:13,976
as balance and guard. And the

139
00:09:13,998 --> 00:09:16,780
key is actually the id that we're working with,

140
00:09:16,930 --> 00:09:20,860
which is the account name. So it looks like this every record

141
00:09:20,930 --> 00:09:24,716
in the table. Whats a key by which it can be looked up.

142
00:09:24,898 --> 00:09:28,124
So when youre retrieve values, you don't search for an account or use a where

143
00:09:28,162 --> 00:09:31,520
statement, but you look it up by key. This makes it really fast

144
00:09:31,590 --> 00:09:35,664
and performant. In this case, the key is the account name.

145
00:09:35,862 --> 00:09:39,620
The account name can be an arbitrary string with some limitations.

146
00:09:40,360 --> 00:09:43,796
Now the value is the rest of the schema and the

147
00:09:43,818 --> 00:09:47,636
balance and the guard. The guard is as

148
00:09:47,658 --> 00:09:51,264
simple as a function that just returns true or false

149
00:09:51,312 --> 00:09:55,160
when a set of conditions are met. In this case, it's a key guard.

150
00:09:55,580 --> 00:09:59,188
We'll go into that detail a little bit later. Now let's

151
00:09:59,204 --> 00:10:02,436
look at the functions that can interact with the schema.

152
00:10:02,628 --> 00:10:05,784
So these functions need to limit the interaction

153
00:10:05,832 --> 00:10:09,230
in a certain way that it's safe to work with it.

154
00:10:09,600 --> 00:10:13,388
Now how do we do that? So let's go over the function first.

155
00:10:13,474 --> 00:10:17,250
So this function is called a diff on,

156
00:10:17,780 --> 00:10:21,152
and the first part is the name of the function

157
00:10:21,206 --> 00:10:24,464
and its return value. The second part is

158
00:10:24,502 --> 00:10:28,096
actually the arguments that we have. Then there

159
00:10:28,118 --> 00:10:32,244
are some guards that will limit how

160
00:10:32,282 --> 00:10:35,696
you can interact with this function. So if the sender

161
00:10:35,728 --> 00:10:39,684
is the same as the receiver, then you cannot be both

162
00:10:39,722 --> 00:10:43,412
the sender and the receiver. For transfer, what it enforces

163
00:10:43,476 --> 00:10:46,856
is not sender and receiver. Then we

164
00:10:46,878 --> 00:10:50,436
validate account. We see if the sender account and the receiver

165
00:10:50,468 --> 00:10:54,520
account exist and if the amount is above zero,

166
00:10:54,670 --> 00:10:58,552
because if you would make a transfer to someone else minus

167
00:10:58,616 --> 00:11:02,332
something, you would receive money, which is of course that's something

168
00:11:02,386 --> 00:11:05,548
that we don't want to do. So this is some business logic that

169
00:11:05,554 --> 00:11:08,720
we work with. Now let's check out how a function

170
00:11:08,790 --> 00:11:12,540
can restrict the operations to the record of that schema.

171
00:11:12,700 --> 00:11:16,828
So how do we do we do that? By introducing a with capability

172
00:11:16,924 --> 00:11:21,396
statement. A with capability statement takes

173
00:11:21,498 --> 00:11:24,932
two arguments. If you look closely, the first

174
00:11:24,986 --> 00:11:28,784
argument is this section, and the second argument

175
00:11:28,832 --> 00:11:32,516
is the rest of the function, which is kind of like a callback

176
00:11:32,548 --> 00:11:36,696
in JavaScript. What does it do? So when the

177
00:11:36,718 --> 00:11:40,184
capability is executed, when its expression is

178
00:11:40,222 --> 00:11:44,364
being interpreted and run, it checks for two things.

179
00:11:44,562 --> 00:11:48,460
Did the signer sign for this capability?

180
00:11:49,040 --> 00:11:53,404
In this case, the sender. Did the sender sign that

181
00:11:53,442 --> 00:11:56,460
this capability can be executed?

182
00:11:56,980 --> 00:12:00,130
If so, execute the code.

183
00:12:00,500 --> 00:12:04,050
Now, the execution of the code is this part.

184
00:12:04,580 --> 00:12:08,256
Here we see that we debit the sender a

185
00:12:08,278 --> 00:12:11,856
certain amount, and then we credit the receiver

186
00:12:11,888 --> 00:12:15,524
a certain amount. First we debit the sender by

187
00:12:15,562 --> 00:12:18,884
the amount of what the user wants to send to the other

188
00:12:18,922 --> 00:12:23,832
user. And then based on some

189
00:12:23,886 --> 00:12:27,972
information that we read from the database, we then credit the receiver

190
00:12:28,116 --> 00:12:31,624
some amount. So this is what it looks like.

191
00:12:31,822 --> 00:12:35,484
The function is being executed and the changes are being

192
00:12:35,522 --> 00:12:38,380
introduced. So this is the function,

193
00:12:38,530 --> 00:12:41,710
coin transfer from Albert to John,

194
00:12:42,160 --> 00:12:45,464
133.7 kda,

195
00:12:45,512 --> 00:12:49,824
for example. It first checks that

196
00:12:50,022 --> 00:12:54,544
the balance is sufficient and

197
00:12:54,582 --> 00:12:57,824
then it will transfer this money. So after this it will be

198
00:12:57,862 --> 00:13:01,396
done and John will be credited with more money than he

199
00:13:01,418 --> 00:13:05,172
had before. Now let's take a look at what the transaction looks like

200
00:13:05,226 --> 00:13:09,364
in the blockchain. So the transaction is actually a

201
00:13:09,402 --> 00:13:13,320
JSON with two parts. In this case.

202
00:13:13,470 --> 00:13:17,176
One part is the code that's being executed, and the

203
00:13:17,198 --> 00:13:21,050
second part is the signers that need to sign for this code.

204
00:13:21,580 --> 00:13:25,660
We see that there is a matching public key. The public key is

205
00:13:25,730 --> 00:13:29,644
part of whoever owns and

206
00:13:29,682 --> 00:13:32,780
wants to sign for this capability.

207
00:13:33,520 --> 00:13:37,250
What we see that needs to be signed is the coin transfer

208
00:13:37,860 --> 00:13:41,344
with its arguments. When this is signed, it will

209
00:13:41,382 --> 00:13:45,884
allow the function to be executed for these specific arguments

210
00:13:46,012 --> 00:13:50,416
to transfer money from Albert to John with

211
00:13:50,438 --> 00:13:54,080
the amount of 133.7 kda.

212
00:13:54,660 --> 00:13:57,956
Now if we take a closer look at the transaction, there needs to be a

213
00:13:57,978 --> 00:14:01,868
signature as well. We sign for the transaction

214
00:14:02,064 --> 00:14:05,892
by seeing which public key matches to which signature.

215
00:14:06,036 --> 00:14:09,370
So whenever we sign something, we will make sure that

216
00:14:10,060 --> 00:14:14,056
Albert Pubkey will be the owner of

217
00:14:14,078 --> 00:14:17,276
whatever is being signed here. So why do we need

218
00:14:17,298 --> 00:14:20,396
a Javascript client? Well, let's go

219
00:14:20,418 --> 00:14:24,956
back a little bit and take a look at how we do this in

220
00:14:25,058 --> 00:14:28,684
the back end world or in the regular web

221
00:14:28,722 --> 00:14:32,156
two world where we have a back end and SQL and a database

222
00:14:32,188 --> 00:14:35,504
table. So let's imagine you have a node JS service where you

223
00:14:35,622 --> 00:14:39,296
have some business logic and you want to write some SQL to update

224
00:14:39,328 --> 00:14:42,836
a database table. Similarly, we have

225
00:14:42,858 --> 00:14:47,284
a front end and we build up our transactions and

226
00:14:47,322 --> 00:14:51,364
use an API to send it to the smart contract and

227
00:14:51,402 --> 00:14:54,648
then it will retain its value in the

228
00:14:54,654 --> 00:14:58,452
blockchain database. Well actually it's a little bit more complex

229
00:14:58,596 --> 00:15:01,480
because when we are working with the wallet,

230
00:15:01,980 --> 00:15:05,496
when we are working with a transaction, we need to sign it as well.

231
00:15:05,678 --> 00:15:09,292
Now in order to make sure that it's signed, we only

232
00:15:09,346 --> 00:15:12,764
then can send it to the blockchain. So what we actually do is we build

233
00:15:12,802 --> 00:15:15,980
a transaction, we sign the transaction,

234
00:15:16,640 --> 00:15:20,400
then we send it to the blockchain and we wait for it to be validated.

235
00:15:20,900 --> 00:15:24,304
So this is a whole bunch of logic that we want to abstract away from

236
00:15:24,342 --> 00:15:27,820
our general user. So first part is writing,

237
00:15:27,900 --> 00:15:31,732
building the transaction. We want to write the code coin transfer

238
00:15:31,866 --> 00:15:35,396
with the correct parameters, we want to add the

239
00:15:35,418 --> 00:15:39,348
relevant authorizations and then we want to set the

240
00:15:39,354 --> 00:15:42,536
correct parameters, for example network id, chain id,

241
00:15:42,638 --> 00:15:45,800
who is going to pay for the transaction cost, et cetera.

242
00:15:46,140 --> 00:15:49,370
Now let's go back to youre backend example.

243
00:15:50,060 --> 00:15:53,080
We have now a Prisma client.

244
00:15:53,660 --> 00:15:57,516
If you know what Prisma is, you know that it takes the information

245
00:15:57,618 --> 00:16:02,232
from the database table and it will convert it to a typesafe client

246
00:16:02,376 --> 00:16:06,304
that can interact with your database based

247
00:16:06,342 --> 00:16:09,616
on SQL. So whenever you generate this code,

248
00:16:09,798 --> 00:16:12,976
you will get a typesafe client that can

249
00:16:13,078 --> 00:16:16,796
interact with your database through SQL

250
00:16:16,908 --> 00:16:20,290
and it will even optimize your queries if you want.

251
00:16:20,660 --> 00:16:24,304
Now that's exactly what we want to do with this Kadena client

252
00:16:24,352 --> 00:16:27,990
as well. We want our front end to be able to work

253
00:16:28,680 --> 00:16:32,136
with the transactions API without the

254
00:16:32,158 --> 00:16:34,600
need to write youre own jSon.

255
00:16:34,940 --> 00:16:38,632
So how do we do that in JavaScript? We have

256
00:16:38,686 --> 00:16:42,344
a packed builder. What we actually want is to

257
00:16:42,382 --> 00:16:45,708
have some intellisense. We want to have

258
00:16:45,794 --> 00:16:49,740
information from the blockchain

259
00:16:50,320 --> 00:16:54,264
to work with the smart contract. So imagine

260
00:16:54,312 --> 00:16:58,000
this to be a rest endpoint or a table in the database.

261
00:16:58,420 --> 00:17:01,856
And then whenever you type this out, youre will see that it

262
00:17:01,878 --> 00:17:05,296
hints for all the functions that you can call from

263
00:17:05,318 --> 00:17:09,172
the coin module and you get also information

264
00:17:09,306 --> 00:17:13,056
on the arguments that you get. And it's

265
00:17:13,088 --> 00:17:16,404
typesafe. Now because of this one,

266
00:17:16,602 --> 00:17:19,220
we also need to add a signer,

267
00:17:19,640 --> 00:17:23,656
and we need to sign for the transaction that we built here. So here

268
00:17:23,678 --> 00:17:26,520
we say, okay, this is the command I want to execute,

269
00:17:27,020 --> 00:17:30,312
and this one, the add signer part, will then

270
00:17:30,366 --> 00:17:34,136
make sure that you have to include this. And this

271
00:17:34,158 --> 00:17:37,820
is also being done type safely, which is really neat.

272
00:17:38,240 --> 00:17:42,140
And then we have some plumbing logic in order to make

273
00:17:42,210 --> 00:17:45,740
sure that we can send this transaction to the blockchain successfully.

274
00:17:46,080 --> 00:17:49,884
So how do we do that? How do we go from a smart contract

275
00:17:49,932 --> 00:17:53,570
on one hand to a typescript definition that can be used

276
00:17:53,940 --> 00:17:57,440
in this library to build an awesome

277
00:17:57,510 --> 00:18:00,388
client? First we need to look,

278
00:18:00,554 --> 00:18:04,400
take the smart contract, put it into the parser,

279
00:18:04,560 --> 00:18:08,196
and this is where we actually go through the wormhole and

280
00:18:08,298 --> 00:18:11,604
check out how a parser works. I want to take a little

281
00:18:11,642 --> 00:18:15,492
bit of a sidestep here and I want to get your attention to

282
00:18:15,546 --> 00:18:19,176
a parser. So what we describe in a parser is

283
00:18:19,198 --> 00:18:22,696
that we say this is the structure of our program.

284
00:18:22,878 --> 00:18:26,924
So in this case the structure of a number is

285
00:18:27,122 --> 00:18:30,316
something whats we see here. But how do we explain

286
00:18:30,418 --> 00:18:33,804
to the machine and to something

287
00:18:33,842 --> 00:18:37,376
that interprets that whats we actually are working with a

288
00:18:37,398 --> 00:18:40,690
number. So we say, okay, number is

289
00:18:42,500 --> 00:18:46,688
a regular expression of zero

290
00:18:46,774 --> 00:18:50,996
to nine with a certain amount

291
00:18:51,178 --> 00:18:54,912
certain times. So let's see, this one is already matching,

292
00:18:55,056 --> 00:18:57,972
as you can see, but we have more numbers.

293
00:18:58,106 --> 00:19:01,716
We can create a number of multiple individual numbers which

294
00:19:01,738 --> 00:19:05,050
is still the same number. So we use star for that.

295
00:19:05,580 --> 00:19:09,640
Now when we want to do some processing, we want to

296
00:19:09,790 --> 00:19:12,856
see that this number is actually something we

297
00:19:12,878 --> 00:19:16,332
can join together. As you saw here, it's still a set

298
00:19:16,386 --> 00:19:19,996
of individual parts, but actually we want to take all

299
00:19:20,018 --> 00:19:23,976
these individual parts and make it one number. So that's

300
00:19:24,008 --> 00:19:28,064
how we do whats. So we add some Javascript logic that then takes the first

301
00:19:28,102 --> 00:19:32,236
argument of the result and uses

302
00:19:32,268 --> 00:19:35,776
it to join them together. Because the first argument of the

303
00:19:35,798 --> 00:19:39,344
result whats actually already an array, we take

304
00:19:39,382 --> 00:19:43,060
this one and we join it together into single

305
00:19:43,210 --> 00:19:46,448
element. So now we have an array of a single element,

306
00:19:46,544 --> 00:19:50,100
but we can even do that like multiple times. Maybe we can

307
00:19:50,170 --> 00:19:53,476
do it like this, but we need to write our grammar for

308
00:19:53,498 --> 00:19:57,144
that. So whats we can say is, okay, we have a white

309
00:19:57,182 --> 00:20:00,010
space here and then another number.

310
00:20:00,460 --> 00:20:03,748
How do we deal with that? We need to add a white space.

311
00:20:03,934 --> 00:20:07,596
So a white space is usually composed of an

312
00:20:07,618 --> 00:20:11,180
underscore. Were we see that now we actually

313
00:20:11,250 --> 00:20:14,796
have it working. But we want, of course,

314
00:20:14,898 --> 00:20:18,076
this part to be flexible. We can have two

315
00:20:18,098 --> 00:20:21,456
numbers and then we can have subsequent numbers. So what we

316
00:20:21,478 --> 00:20:24,592
can do is we can wrap this around and say,

317
00:20:24,646 --> 00:20:28,128
okay, you can have multiples of those. And now,

318
00:20:28,214 --> 00:20:32,180
as you see, we have a set of numbers, the first set,

319
00:20:32,330 --> 00:20:36,180
second set, and the third set. So this is basically

320
00:20:36,330 --> 00:20:39,604
the grammar of a language. And in this

321
00:20:39,642 --> 00:20:43,064
case, the language is a programming language which sums some

322
00:20:43,102 --> 00:20:46,296
things together. Now we want to introduce an

323
00:20:46,318 --> 00:20:50,024
operator. So we want to actually make sure that we can work with a

324
00:20:50,062 --> 00:20:53,752
plus symbol and ideally also with

325
00:20:53,806 --> 00:20:57,724
an underscore. Now, an operator can be something like

326
00:20:57,762 --> 00:21:01,324
a plus. And this is actually how we do that.

327
00:21:01,522 --> 00:21:05,276
So we now have number, operator number. And then also

328
00:21:05,378 --> 00:21:09,344
we can say, okay, in this case, the white

329
00:21:09,382 --> 00:21:12,608
space is optional, so we can make it like this.

330
00:21:12,774 --> 00:21:16,176
And then we also have the double underscore to identify that

331
00:21:16,198 --> 00:21:20,188
it should be mandatory. So here we say, okay, this one

332
00:21:20,214 --> 00:21:24,550
is optional, which means that now we can also write this one.

333
00:21:24,920 --> 00:21:28,676
Now, in order to process the operator in a logical way,

334
00:21:28,778 --> 00:21:32,090
we can add some processing logic where we say, okay,

335
00:21:33,580 --> 00:21:37,912
we have an operator, for example o.

336
00:21:38,046 --> 00:21:41,960
And then we will return a type operator.

337
00:21:42,620 --> 00:21:46,460
And the operator in this case for the plus is called sum.

338
00:21:48,160 --> 00:21:52,616
What we see now is that this element is now converted

339
00:21:52,648 --> 00:21:56,380
to a sum element to an object, whats is a sum.

340
00:21:56,740 --> 00:22:00,690
And of course we want to ignore this object.

341
00:22:01,380 --> 00:22:04,816
So we just strip them out. And now wherever they

342
00:22:04,838 --> 00:22:08,496
are used, we can leave them out so we can add a

343
00:22:08,518 --> 00:22:12,276
filter. And now we have a nice part were we

344
00:22:12,298 --> 00:22:15,396
can work with. But actually we want

345
00:22:15,418 --> 00:22:19,552
to do something more. We want to add another operator,

346
00:22:19,696 --> 00:22:22,600
because operator is not just a plus,

347
00:22:22,750 --> 00:22:25,930
but also a minus, for example,

348
00:22:26,540 --> 00:22:30,170
that we can do this way. And now this one works as well.

349
00:22:30,620 --> 00:22:33,916
And then finally we can

350
00:22:34,018 --> 00:22:37,132
merge all these parts together and have only

351
00:22:37,186 --> 00:22:41,710
one object. Whats says first

352
00:22:42,480 --> 00:22:45,230
operator in last?

353
00:22:45,760 --> 00:22:49,330
This is how we can do that. In this case, we have left,

354
00:22:49,940 --> 00:22:53,424
which is the one that we see here. This is the first

355
00:22:53,462 --> 00:22:56,768
element. We have d two,

356
00:22:56,854 --> 00:22:59,590
which is the third element, one, two, three.

357
00:23:00,200 --> 00:23:04,324
And then we have the operator, the value of

358
00:23:04,362 --> 00:23:08,116
the operator function. Or we can leave it like an object. And then we

359
00:23:08,138 --> 00:23:11,440
have left right operator. And the operator in

360
00:23:11,450 --> 00:23:14,472
this case is a sum. But as we already

361
00:23:14,526 --> 00:23:17,704
have defined the operator here, it's nice to use

362
00:23:17,742 --> 00:23:21,924
the value. All right, let's go back to the wormhole

363
00:23:22,052 --> 00:23:25,020
and into our presentation.

364
00:23:25,520 --> 00:23:29,772
So we saw that there is a smart contract with

365
00:23:29,826 --> 00:23:32,540
a transfer function and a capability,

366
00:23:33,280 --> 00:23:36,796
and we actually want to convert these into the

367
00:23:36,818 --> 00:23:39,984
parts that we actually need. So we

368
00:23:40,022 --> 00:23:43,056
need to define that it's a function. So we

369
00:23:43,078 --> 00:23:46,320
need to find all the functions that are here, like the methods.

370
00:23:46,740 --> 00:23:50,076
Then we need to find the parts that correspond

371
00:23:50,188 --> 00:23:53,190
to the name of the function and its return type.

372
00:23:53,640 --> 00:23:57,156
We need to identify its arguments. So how do we

373
00:23:57,178 --> 00:24:00,276
do that? All right, let's look at the right side.

374
00:24:00,378 --> 00:24:04,090
Here we have a parser. And a parser is actually

375
00:24:04,860 --> 00:24:08,872
a set of rules that we combine in order to find

376
00:24:09,006 --> 00:24:12,392
what the thing is that we are looking at. So how this works

377
00:24:12,446 --> 00:24:16,430
is a method. Whatever we put in were

378
00:24:17,040 --> 00:24:20,760
has to start with a unlock. Now, a block

379
00:24:20,840 --> 00:24:24,204
is matching two parentheses. So each code

380
00:24:24,242 --> 00:24:27,756
unlock impact is a starting and an ending parentheses.

381
00:24:27,948 --> 00:24:32,096
This will work for mostly anything. Then it will see

382
00:24:32,278 --> 00:24:36,108
whether there is a kind. Well, it's not jquery,

383
00:24:36,204 --> 00:24:40,390
but what we actually do here is we use this part to create

384
00:24:41,000 --> 00:24:45,124
the elements that we want to extract from the

385
00:24:45,162 --> 00:24:49,380
code. So here you see the matching properties

386
00:24:50,200 --> 00:24:55,000
that correspond to the matching statements.

387
00:24:55,500 --> 00:24:59,400
So, for example, kind whats a statement

388
00:25:00,060 --> 00:25:03,248
that we match with, et cetera, et cetera.

389
00:25:03,444 --> 00:25:07,052
Now, how this works is it will go through every

390
00:25:07,106 --> 00:25:11,468
parser and see how much of this part

391
00:25:11,634 --> 00:25:15,484
will match to whatever I'm looking at. So when

392
00:25:15,522 --> 00:25:19,584
we have a unlock, then I expect to find a

393
00:25:19,622 --> 00:25:22,960
kind. If I'm working with a function, actually,

394
00:25:23,030 --> 00:25:26,336
I'm expecting to find one of

395
00:25:26,358 --> 00:25:29,956
the types that we have here, in this case, a defin. And if it

396
00:25:29,978 --> 00:25:34,084
matches, then that's good. Then if

397
00:25:34,122 --> 00:25:37,540
we find an atom, it still matches to

398
00:25:37,610 --> 00:25:40,784
what we call a method. If we find an atom,

399
00:25:40,832 --> 00:25:44,696
we want to store it. We store it here in the transfer, in the

400
00:25:44,718 --> 00:25:47,050
name property. Now,

401
00:25:48,300 --> 00:25:51,896
we could potentially have a return type, and a

402
00:25:51,918 --> 00:25:55,596
return type is a type rule because there is a column at the

403
00:25:55,618 --> 00:25:58,350
start and then a value.

404
00:25:58,880 --> 00:26:03,016
So the type rule is actually a combination of atom and the column

405
00:26:03,048 --> 00:26:06,764
in front. A type rule means this is the

406
00:26:06,802 --> 00:26:10,096
definition of a type rule, which is colon and

407
00:26:10,118 --> 00:26:13,584
then atom. And if we have it, we want to store it

408
00:26:13,622 --> 00:26:17,136
as the return type. And now we're actually going a little

409
00:26:17,158 --> 00:26:20,596
bit deep, and we're going to look at if

410
00:26:20,618 --> 00:26:24,068
we get a sequence. So we still say, okay, we have a

411
00:26:24,074 --> 00:26:27,524
block. This part is the block, starting with

412
00:26:27,562 --> 00:26:31,304
apprentices opening and closing parentheses. And then

413
00:26:31,342 --> 00:26:35,432
it should maybe repeat with

414
00:26:35,486 --> 00:26:38,440
a set that has an atom and a type rule.

415
00:26:38,780 --> 00:26:42,148
So an atom and a type rule,

416
00:26:42,244 --> 00:26:45,932
and this can be repeated multiple times, can even

417
00:26:45,986 --> 00:26:48,904
be omitted. The type rule can be omitted,

418
00:26:48,952 --> 00:26:52,412
and that's why we say maybe. But if these

419
00:26:52,546 --> 00:26:56,292
rules are still matching to whatever we see, we are confident

420
00:26:56,376 --> 00:26:59,680
that these are parameters for the method.

421
00:27:00,180 --> 00:27:03,996
So here you see that we see a sender

422
00:27:04,108 --> 00:27:07,296
which matches here receiver that

423
00:27:07,318 --> 00:27:11,910
we are going to store here, and then of course also add a decimal amount.

424
00:27:12,520 --> 00:27:15,844
Now we store this in the parameter section and

425
00:27:15,882 --> 00:27:20,356
then we want to look at how we can add the

426
00:27:20,378 --> 00:27:23,540
information that we need to sign for this transaction.

427
00:27:23,880 --> 00:27:27,444
So let's look at the partial output, and it's a little bit bigger

428
00:27:27,492 --> 00:27:31,556
than we just looked at. So this is actually the parser output.

429
00:27:31,748 --> 00:27:35,100
And on the other side we have a generated typescript definition.

430
00:27:35,520 --> 00:27:38,888
So how do we go from the parser output

431
00:27:38,984 --> 00:27:43,612
that we have defined here that we created from this parser and

432
00:27:43,666 --> 00:27:46,904
go to a typescript definition, because the typescript definition

433
00:27:46,952 --> 00:27:50,576
is then in the end what we need to use, because here you see actually

434
00:27:50,678 --> 00:27:54,480
the matching part of the function call that we had. Well,

435
00:27:54,630 --> 00:27:58,432
we can basically just take that and interpret it and

436
00:27:58,566 --> 00:28:02,528
make a big string concatenation. So we have a

437
00:28:02,534 --> 00:28:06,196
kind which is called a module. So if we find a module, then we

438
00:28:06,218 --> 00:28:09,796
are going to use the coin part, the name of it, and use it

439
00:28:09,898 --> 00:28:13,860
in the interface. This is actually matching

440
00:28:14,020 --> 00:28:17,428
with the pack modules coin part. So this coin

441
00:28:17,524 --> 00:28:20,884
matches to this coin which matches to this coin

442
00:28:20,932 --> 00:28:24,360
which matched to the parsed smart contract.

443
00:28:24,940 --> 00:28:28,236
Inside the smart contract is a set of

444
00:28:28,258 --> 00:28:31,692
functions annotated by an array and then

445
00:28:31,746 --> 00:28:35,132
an object in that array. And here we see that the kind

446
00:28:35,186 --> 00:28:38,960
is a defin because that's how pact defines functions.

447
00:28:39,380 --> 00:28:43,360
So we write it down in our generated typescript definitions

448
00:28:44,020 --> 00:28:47,456
and then it matches to what we can use in the

449
00:28:47,478 --> 00:28:51,204
client code. The same thing we do for

450
00:28:51,242 --> 00:28:54,884
the parameters and we can include type information.

451
00:28:55,082 --> 00:28:58,292
If the type information was omitted, we could write

452
00:28:58,346 --> 00:29:01,524
sender is any for example.

453
00:29:01,722 --> 00:29:05,576
And now because these are matching, we can also create the same

454
00:29:05,678 --> 00:29:09,588
part for the client code. Now actually the parser

455
00:29:09,604 --> 00:29:13,236
output is a little bit bigger because we also have the with capabilities.

456
00:29:13,348 --> 00:29:17,064
And in this case this function introduces the capability

457
00:29:17,192 --> 00:29:21,404
transfer. Now the capability transfer is

458
00:29:21,442 --> 00:29:24,284
the one whats we return from here,

459
00:29:24,402 --> 00:29:28,290
because that's going to be used in the wrapper function,

460
00:29:28,980 --> 00:29:32,256
in the builder, this case. And here

461
00:29:32,278 --> 00:29:35,536
we can see that the capability is this capability with

462
00:29:35,558 --> 00:29:38,964
the coin transfer as a name. And if you are going

463
00:29:39,002 --> 00:29:42,388
to add a coin transfer, you want to sign for

464
00:29:42,474 --> 00:29:46,688
the coin transfer which has to have these arguments.

465
00:29:46,864 --> 00:29:50,870
So we are kind of recreating everything that is possible

466
00:29:51,900 --> 00:29:55,960
in pact, but then from JavaScript,

467
00:29:56,380 --> 00:29:59,364
and this is then the completed transaction builder.

468
00:29:59,492 --> 00:30:04,250
So here you can see that by sending money

469
00:30:04,860 --> 00:30:08,216
using the coin transfer function with a sender receiver

470
00:30:08,248 --> 00:30:11,932
and some amount we can then say okay,

471
00:30:12,066 --> 00:30:15,356
we have a signer and we are going to sign for in

472
00:30:15,378 --> 00:30:18,432
this case the gas which is the transaction fee and

473
00:30:18,566 --> 00:30:22,256
the transfer which is actually the

474
00:30:22,278 --> 00:30:26,252
authorization that we want to give to the blockchain

475
00:30:26,396 --> 00:30:30,484
to deduct some amount from the record where

476
00:30:30,522 --> 00:30:34,372
sender is the key and credit some amount for the record were

477
00:30:34,426 --> 00:30:38,260
receiver is the key. So this is basically

478
00:30:38,410 --> 00:30:42,150
transaction building with javascript type save.

479
00:30:42,540 --> 00:30:46,410
We automatically know what we need to fill in.

480
00:30:46,860 --> 00:30:50,392
Beautiful. So let's make a quick

481
00:30:50,446 --> 00:30:54,620
recap. So the first thing that we built was an expression builder.

482
00:30:55,520 --> 00:30:59,004
Sorry, let me just take a quick sip. So we create

483
00:30:59,042 --> 00:31:02,940
an expression builders to create packed expressions

484
00:31:03,360 --> 00:31:07,600
in a typesafe manner by extracting

485
00:31:08,180 --> 00:31:10,560
the defense from the smart contract.

486
00:31:11,060 --> 00:31:13,680
Then we have a transaction builder.

487
00:31:14,020 --> 00:31:17,596
The transaction builder is the plumbing around the transaction,

488
00:31:17,708 --> 00:31:20,964
around the code. Actually, to make sure that this

489
00:31:21,002 --> 00:31:24,308
code can be executed, a few things that are needed

490
00:31:24,394 --> 00:31:28,176
are adding a signer, for example adding

491
00:31:28,208 --> 00:31:32,020
some metadata, which network you want to use, et cetera.

492
00:31:32,460 --> 00:31:36,100
And then we can sign this transaction.

493
00:31:36,260 --> 00:31:40,184
And for that we have some utilities. For example sign with Chainweaver or

494
00:31:40,222 --> 00:31:42,970
sign with wallet, connect or sign with something else.

495
00:31:43,600 --> 00:31:46,860
Then we want to submit it to the blockchain.

496
00:31:47,600 --> 00:31:51,464
Inside. Kadena client is also a fetch

497
00:31:51,512 --> 00:31:55,820
interface that we can use to communicate with the blockchain.

498
00:31:56,180 --> 00:31:59,520
And finally we have some information to submit it

499
00:31:59,590 --> 00:32:03,024
and also to listen to the

500
00:32:03,062 --> 00:32:06,208
transaction and wait for the transaction to be

501
00:32:06,374 --> 00:32:10,032
verified. And once the transaction is verified we know

502
00:32:10,086 --> 00:32:13,430
that the receiver has received his money.

503
00:32:13,960 --> 00:32:17,396
Now I said we have signed with Chainweaver, but there is also

504
00:32:17,418 --> 00:32:21,316
a bunch of other tools that we can use to sign with.

505
00:32:21,498 --> 00:32:25,476
So thank youre very much. We have built a

506
00:32:25,498 --> 00:32:28,836
blockchain client to read

507
00:32:29,018 --> 00:32:32,388
and write and listen to transactions on

508
00:32:32,394 --> 00:32:35,800
the blockchain. This way front end is closer

509
00:32:35,880 --> 00:32:38,780
to the blockchain than you thought previously.

510
00:32:39,200 --> 00:32:39,930
Thank you very much.

