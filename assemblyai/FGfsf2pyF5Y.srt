1
00:00:41,010 --> 00:00:44,162
Hello and welcome to this talk titled Kubernetes security jumpstart.

2
00:00:44,226 --> 00:00:47,942
Like a real jumpstart. The goal of this talk is to start our

3
00:00:47,996 --> 00:00:51,486
security journey in kubernetes. After this talk, hopefully you

4
00:00:51,508 --> 00:00:55,054
will know all the different aspects of kubernetes that you need to secure and

5
00:00:55,092 --> 00:00:58,334
what security really means in the scope of kubernetes or

6
00:00:58,372 --> 00:01:01,674
in general. This is not an in depth tutorial on how to secure your Kubernetes

7
00:01:01,722 --> 00:01:05,538
cluster. This is collection of bunch of different tools and techniques and ideas you

8
00:01:05,544 --> 00:01:08,590
have to be careful about when you're trying to secure your Kubernetes cluster.

9
00:01:08,670 --> 00:01:12,786
The slides to this talk are in this link at tiny cc k

10
00:01:12,808 --> 00:01:16,146
eight s security. If you need to follow along and if you want to find

11
00:01:16,168 --> 00:01:19,542
these slides, you can find it there. So I'll start with the question,

12
00:01:19,676 --> 00:01:23,094
are computers less secure than real life? By real life

13
00:01:23,132 --> 00:01:26,374
I mean you and I, our daily day to day life, when we think about

14
00:01:26,412 --> 00:01:30,406
computers, we think of a lot of different things. But what I'm trying

15
00:01:30,428 --> 00:01:34,106
to ask here is our computers less secure than real life?

16
00:01:34,208 --> 00:01:38,342
So let's take some example. Is this secure? This door

17
00:01:38,406 --> 00:01:42,074
with the door code on the top and on the handle? You could say

18
00:01:42,112 --> 00:01:45,022
this is secure because you don't know what this door is.

19
00:01:45,156 --> 00:01:48,062
Or how about this? Is this secure things?

20
00:01:48,116 --> 00:01:50,974
Turnstile is trying to stop people from going into this space,

21
00:01:51,092 --> 00:01:53,998
but as you can see, there's a wide gap next to it.

22
00:01:54,084 --> 00:01:57,826
How about this? This is a door that has a push to exit, but that

23
00:01:57,848 --> 00:02:01,474
you can kind of slide your hand through and kind of open the door from

24
00:02:01,512 --> 00:02:04,882
outside. Hidden camera. This camera is trying to monitor things,

25
00:02:04,936 --> 00:02:08,114
but it is blocked by a sign. Well, how about these

26
00:02:08,152 --> 00:02:11,826
locks? These are padlocks, standard issue masters padlock

27
00:02:11,858 --> 00:02:15,394
you can buy from any store and people use that to lock their gym

28
00:02:15,442 --> 00:02:19,146
doors or something, some small locker. So one on the left is a

29
00:02:19,168 --> 00:02:22,362
master lock, it's fairly common. One on the right

30
00:02:22,496 --> 00:02:26,362
is a padlock makes by squire. It's a british company that

31
00:02:26,416 --> 00:02:30,570
makes some of the strongest padlocks in the world. The one here,

32
00:02:30,640 --> 00:02:34,934
it's a one could lock. And when it was created, it was declared

33
00:02:34,982 --> 00:02:38,554
the strongest padlock in the world. So the year after that they decided,

34
00:02:38,602 --> 00:02:41,566
you know what, that wasn't strong enough. We're going to make a stronger version of

35
00:02:41,588 --> 00:02:44,602
that. We're going to make like a two could version of the same lock.

36
00:02:44,666 --> 00:02:47,742
So that year, this lock was the strongest lock of the year.

37
00:02:47,876 --> 00:02:51,054
Well, they thought, you know what, that's not good enough either. We're going to go

38
00:02:51,092 --> 00:02:54,026
higher. We're going to have to make it stronger. So they made a five pound

39
00:02:54,058 --> 00:02:57,286
version of the same lock, and that was, I mean, this is one of

40
00:02:57,308 --> 00:03:01,126
the strongest padlock you can probably buy if you're not custom making it.

41
00:03:01,228 --> 00:03:04,774
So what's the point of all this? What's the point of you showing you real

42
00:03:04,812 --> 00:03:08,246
life scenarios or actual logs or like, security things people use in

43
00:03:08,268 --> 00:03:12,202
day to day life? Security is a spectrum. Security is not a thing that,

44
00:03:12,256 --> 00:03:15,466
oh, it's something is secure or not secure. Things can be

45
00:03:15,488 --> 00:03:19,114
more secure or less secure. Never just secure. You can't have

46
00:03:19,152 --> 00:03:22,454
something that is just secure. Well, in software,

47
00:03:22,502 --> 00:03:26,394
you can probably have security in software that you didn't write. Only secure software

48
00:03:26,442 --> 00:03:29,646
is where you have no code. But the moment you write code, the moment you

49
00:03:29,668 --> 00:03:33,454
have infrastructure involved, you have a spectrum of security. Well, remember this

50
00:03:33,492 --> 00:03:36,970
lock, the five pound lock? That is probably the strongest lock that you

51
00:03:36,980 --> 00:03:40,686
can buy in the hand of lock picking lawyer. It's a YouTube

52
00:03:40,718 --> 00:03:44,318
channel that deals with, like, lock picking. It took him four minutes to dismantle

53
00:03:44,334 --> 00:03:47,778
the entire lock with some tools. So security is hard.

54
00:03:47,864 --> 00:03:51,666
It is a spectrum. It is hard to get right, because attacking

55
00:03:51,698 --> 00:03:55,206
computer is easier. We can attack a computer by hundreds of

56
00:03:55,228 --> 00:03:58,466
other computers at the same time. In real life, we have a lot of assumptions

57
00:03:58,498 --> 00:04:01,938
that you can make right. For example, most, many of us drive

58
00:04:02,044 --> 00:04:05,782
here. How many times when you are driving, you have to worry about this scenario

59
00:04:05,846 --> 00:04:09,306
happening. I'm going to assume and hope it's not. All of

60
00:04:09,328 --> 00:04:13,066
us have to worry about this situation happening day to day. But when you

61
00:04:13,088 --> 00:04:16,254
are a computer, software, everything is an adversary on the Internet. The moment your

62
00:04:16,292 --> 00:04:20,014
application touches the Internet, everything on the Internet is trying to attack it

63
00:04:20,052 --> 00:04:23,646
and exploit it. Trust no one. This is the agenda for the

64
00:04:23,668 --> 00:04:27,318
talk today. We're going to talk about security and us, which we just touched upon

65
00:04:27,354 --> 00:04:30,990
a little bit. We're going to talk about security in Kubernetes context. And finally we're

66
00:04:31,490 --> 00:04:35,042
going to get started with Kubernetes security. Things talk in no way, shape or form

67
00:04:35,096 --> 00:04:38,578
a full, complete tutorial on Kubernetes security. Security, as I

68
00:04:38,584 --> 00:04:42,134
said, is a large spectrum and a lot of things is involved. But hopefully this

69
00:04:42,172 --> 00:04:45,302
talk will give you ideas on things you need to worry about when you're building

70
00:04:45,356 --> 00:04:48,726
your Kubernetes cluster or maintaining your Kubernetes cluster. My name is

71
00:04:48,748 --> 00:04:52,786
Mophi. I'm a software engineer and a developer advocate at IBM. I mostly do container

72
00:04:52,818 --> 00:04:56,026
stuff, write go code and collect stickers. If you need to find me in the

73
00:04:56,048 --> 00:04:59,446
social media you can find me at Mufi codes in any of the social platforms

74
00:04:59,478 --> 00:05:02,286
up above. So let's started talking about Kubernetes security.

75
00:05:02,388 --> 00:05:06,014
Kubernetes security has few different aspects to it. Number one is

76
00:05:06,052 --> 00:05:09,546
application security. The application you run on Kubernetes next is container

77
00:05:09,578 --> 00:05:13,226
security, next image security, next infrastructure,

78
00:05:13,338 --> 00:05:17,106
then network security. And finally we're going to talk about runtime kubernetes security.

79
00:05:17,208 --> 00:05:21,122
Let's talk about application security a little bit. For application security use

80
00:05:21,176 --> 00:05:24,806
best practices for application security. And this may sound a

81
00:05:24,808 --> 00:05:28,398
little counterintuitive because I'm not really giving any proper advice because it

82
00:05:28,424 --> 00:05:31,494
is quite hard to give you advice or information

83
00:05:31,612 --> 00:05:35,266
about application security because it depends on the application you're writing, the runtime you're

84
00:05:35,298 --> 00:05:39,858
using, the language you're using and everything around your runtime.

85
00:05:39,954 --> 00:05:43,926
So just use the best practices for the language runtime

86
00:05:43,958 --> 00:05:47,418
and the environment you're using it for. As Gordon Ramsey could

87
00:05:47,424 --> 00:05:50,858
put it, I can't teach you that because that's common sense, although a

88
00:05:50,864 --> 00:05:54,670
lot of this common sense information are not common at all. But again,

89
00:05:54,740 --> 00:05:57,920
try to use the best practices. So let's talk about container security.

90
00:05:58,290 --> 00:06:01,662
No unknown base image. So between the two

91
00:06:01,716 --> 00:06:05,146
here, pop quiz, which one do you use? We have on one side we have

92
00:06:05,188 --> 00:06:09,522
movie code, Golang Super Secret 116 and

93
00:06:09,576 --> 00:06:13,154
Golang latest. Some of you may answer it's the right one

94
00:06:13,192 --> 00:06:16,402
because the left one is an unknown base image. You are right, but you're also

95
00:06:16,456 --> 00:06:20,146
wrong because none of things why? Because you have to lock

96
00:06:20,178 --> 00:06:23,586
down versions you can't guarantee. Just because the Golang

97
00:06:23,618 --> 00:06:27,714
latest is an official base image, you can't really guarantee this. Golang latest

98
00:06:27,762 --> 00:06:31,378
is the Golang you build your application on top of this latest image

99
00:06:31,394 --> 00:06:34,886
tag is a terrible image tag to use because that latest keeps

100
00:06:34,918 --> 00:06:38,346
changing with every new version that comes around. So if you build your application for

101
00:06:38,368 --> 00:06:41,462
Golang 112 and latest Golang 116,

102
00:06:41,526 --> 00:06:45,518
117, 118, whatever comes out next might have some breaking changes

103
00:06:45,604 --> 00:06:49,274
that now breaks your application. So never use latest.

104
00:06:49,402 --> 00:06:52,638
So let's look at two Golang versions. So one of

105
00:06:52,644 --> 00:06:56,418
them is Golang 116 three Alpine 313 which is

106
00:06:56,424 --> 00:06:59,602
very specific. It's a tag that is pretty good.

107
00:06:59,656 --> 00:07:02,610
It's not necessarily the best, but it's still pretty good.

108
00:07:02,680 --> 00:07:06,222
But the best way to lock down version is by using digest Sha

109
00:07:06,286 --> 00:07:09,702
you have like the image itself and the Shia is built using

110
00:07:09,756 --> 00:07:13,398
the image content. So every time you use this image you

111
00:07:13,404 --> 00:07:16,726
are guaranteeing that you are building things image on the version that

112
00:07:16,748 --> 00:07:20,386
you tested and have verified. Your application works so use digest

113
00:07:20,418 --> 00:07:23,846
Shah when possible. And it's pretty much if you're using any kind of like image

114
00:07:23,878 --> 00:07:27,674
registry, it's almost always possible to use digest Sha. So make sure

115
00:07:27,712 --> 00:07:31,146
you use it. Next update for vulnerability remediation. So if

116
00:07:31,168 --> 00:07:34,470
you're using something like node and NPM packages,

117
00:07:34,550 --> 00:07:38,266
every once in a while you would see that your NPM packages have some vulnerabilities

118
00:07:38,378 --> 00:07:41,406
and you need to update your images. So there are tools we're going to talk

119
00:07:41,428 --> 00:07:44,762
about later that lets you kind of look at your images

120
00:07:44,826 --> 00:07:48,654
and find out if there's any vulnerability in them. Next is limited

121
00:07:48,702 --> 00:07:51,826
attack vector. What does this mean? So this basically means

122
00:07:51,928 --> 00:07:55,106
you should try to use smaller base images. So if you

123
00:07:55,128 --> 00:07:58,898
have a choice between Alpine and Debian, you should probably go with alpine because it

124
00:07:58,904 --> 00:08:02,534
is a smaller image with less things in it. So you have a less chance

125
00:08:02,652 --> 00:08:06,294
of exposing something that you didn't want to expose. And if you

126
00:08:06,332 --> 00:08:09,846
have a compiled language that can take binary, definitely look

127
00:08:09,868 --> 00:08:13,266
into scratch images. So scratch are empty container

128
00:08:13,298 --> 00:08:16,582
based images that only can run compiled binary.

129
00:08:16,646 --> 00:08:20,310
So if you're using languages like Go, C, C Plus plus or rust,

130
00:08:20,390 --> 00:08:23,930
or using Java with GralvM, you could take advantage of

131
00:08:24,000 --> 00:08:27,946
this container base image that has nothing other than the binary. So your attacker doesn't

132
00:08:27,978 --> 00:08:31,470
have anything to attack your container images on. So let's talk about image security

133
00:08:31,540 --> 00:08:35,354
a little bit. So for image security, the best practice here is least

134
00:08:35,412 --> 00:08:38,542
privileged access. If your user doesn't need to be root,

135
00:08:38,606 --> 00:08:42,498
make sure you're never root. Always use some user creation within the

136
00:08:42,504 --> 00:08:46,098
container image so that you're running as user 5000, which a

137
00:08:46,104 --> 00:08:49,338
random user who doesn't have any special permission in the container

138
00:08:49,374 --> 00:08:52,390
image. One thing I always like to say is root is the root of all

139
00:08:52,460 --> 00:08:56,150
evil. If your container image, if you're running as root, if somehow that

140
00:08:56,220 --> 00:08:59,766
image escapes now in the host, that user is now

141
00:08:59,788 --> 00:09:03,846
root as well and can wreak havoc. So you want to make sure your container

142
00:09:03,878 --> 00:09:07,018
image is running as non root users. It's kind of like things situation,

143
00:09:07,104 --> 00:09:10,870
right? Like your container is that small rhino

144
00:09:11,030 --> 00:09:14,346
inside the enclosure, but somehow it kept

145
00:09:14,378 --> 00:09:17,726
in gap. Now this rhino is out in the world, but now this rhino is

146
00:09:17,748 --> 00:09:21,294
also a root user. So outside and out in the world

147
00:09:21,412 --> 00:09:24,398
that this rhino can do anything they want. So you have to make sure the

148
00:09:24,404 --> 00:09:27,778
cage you're building for your container is really secure. Also,

149
00:09:27,944 --> 00:09:31,042
if it by mistake does go out, it doesn't have any permission to do anything

150
00:09:31,096 --> 00:09:34,482
extra. Let's talk a little bit about infrastructure security at this point. So again,

151
00:09:34,536 --> 00:09:37,614
Kubernetes is abstracting away a lot of the infrastructure,

152
00:09:37,662 --> 00:09:41,206
but underneath all of it, it's still, there are bare metals or

153
00:09:41,228 --> 00:09:44,866
vms or what have you. So we have to make sure that our underlying infrastructure

154
00:09:44,898 --> 00:09:48,514
is secure to make sure our application is secure. So don't expose

155
00:09:48,562 --> 00:09:51,786
underlying infrastructure. That kind of seems like common sense,

156
00:09:51,888 --> 00:09:55,702
but like in the last few years there have been a number of these exploits

157
00:09:55,766 --> 00:09:59,446
where hackers have attacked the master node or the worker

158
00:09:59,478 --> 00:10:03,454
node itself. So where Kubernetes security was not broken, but they broke into

159
00:10:03,492 --> 00:10:06,526
the underlying vms and master nodes and got access to it.

160
00:10:06,548 --> 00:10:10,010
Famously we had the cryptojacking of the Tesla Kubernetes servers

161
00:10:10,090 --> 00:10:13,050
where their master node, the Kubernetes dashboard,

162
00:10:13,130 --> 00:10:17,002
was actually insecure without any password. So they found the master node

163
00:10:17,066 --> 00:10:20,706
IP and just like accessed it directly from their computer and

164
00:10:20,728 --> 00:10:23,886
now then had AWS s three secrets exposed.

165
00:10:23,998 --> 00:10:27,842
Metadata is more valuable than you think. So when you're a Kubernetes cluster,

166
00:10:27,906 --> 00:10:31,126
information you get to yourself. You have information

167
00:10:31,228 --> 00:10:34,982
like your master node IP. When you're using Kubectl to connect to it.

168
00:10:35,036 --> 00:10:38,658
This information might not seem like without the secret it might not seem

169
00:10:38,674 --> 00:10:42,066
super valuable, but the moment someone knows your node IP,

170
00:10:42,178 --> 00:10:45,466
then they can started even start doing some DDoS attacks on

171
00:10:45,488 --> 00:10:48,886
the node. So if your node is too busy like just serving random

172
00:10:48,918 --> 00:10:52,918
requests, your Kubernetes cluster might go down because it can't reserve your network traffic

173
00:10:53,014 --> 00:10:56,266
hardened nodes. So you should make sure that your node doesn't

174
00:10:56,298 --> 00:10:59,918
have SSH enabled. That's just like security 101. At this point

175
00:11:00,004 --> 00:11:03,198
you could make sure that there is no other way to access your

176
00:11:03,284 --> 00:11:05,938
nodes. Don't expose the node IPS if you can,

177
00:11:06,024 --> 00:11:09,602
and all of these good practices you can start doing. So. Make sure your

178
00:11:09,656 --> 00:11:13,138
node underlying infrastructure itself is following the best security

179
00:11:13,224 --> 00:11:17,394
policies. Update regularly. So every once in a while under Linux

180
00:11:17,442 --> 00:11:22,050
like Ubuntu or like a red hat Enterprise Linux, whatever underlying node

181
00:11:22,210 --> 00:11:26,034
Linux environment you're using might have some vulnerability that leaks

182
00:11:26,082 --> 00:11:29,746
something or just something is vulnerable. So you have to make sure the underlying

183
00:11:29,778 --> 00:11:33,142
infrastructure is updating as well as update the Kubernetes version

184
00:11:33,206 --> 00:11:36,186
when the new version comes out after some testing. Because if you have a too

185
00:11:36,208 --> 00:11:39,706
old of a version, you might just open yourself up for some

186
00:11:39,808 --> 00:11:43,706
vulnerability that was fixed in a later patch. And just by not fixing

187
00:11:43,738 --> 00:11:47,658
the zero day vulnerabilities you're just opening yourself up for these kind of attacks.

188
00:11:47,754 --> 00:11:52,126
So let's talk a little bit about now. Network security. So Kubernetes is

189
00:11:52,228 --> 00:11:55,530
environments for microservice applications. So you have a lot of network traffic,

190
00:11:55,610 --> 00:11:59,250
both internally from service to service and externally from service

191
00:11:59,320 --> 00:12:02,546
to other applications. You have to be very careful about making sure

192
00:12:02,568 --> 00:12:05,922
your network security is up to date and working to keep

193
00:12:05,976 --> 00:12:10,402
everything secure. So network segmentation. So this is the idea of making sure internally,

194
00:12:10,466 --> 00:12:14,582
within the same Kubernetes cluster, you have segments where your application

195
00:12:14,716 --> 00:12:18,246
is isolated to talk to, only the application they need to talk to,

196
00:12:18,268 --> 00:12:22,130
rather than opening it up to everything in the cluster. So by default,

197
00:12:22,210 --> 00:12:25,978
any pod in any namespace in Kubernetes can talk to any other pod in

198
00:12:25,984 --> 00:12:29,466
any node. But that is not the best system for security. So what you

199
00:12:29,488 --> 00:12:32,998
want to do is make sure that you are locking it up so that

200
00:12:33,024 --> 00:12:35,918
it can only talk to things they have to talk to.

201
00:12:36,004 --> 00:12:39,182
For example, you can use network policy, and here we are

202
00:12:39,236 --> 00:12:42,686
only allowing incoming traffic from front end to go

203
00:12:42,708 --> 00:12:46,658
to back end and nowhere else. So that my back end pod selectors will

204
00:12:46,744 --> 00:12:50,402
only allow traffic to come in from front end. So if someone gets

205
00:12:50,456 --> 00:12:53,682
access to a random pod in your cluster and someone

206
00:12:53,736 --> 00:12:57,326
just hijacks that pod, they won't be able to make network traffic calls

207
00:12:57,358 --> 00:13:00,742
to your back end if this policy is in place.

208
00:13:00,876 --> 00:13:04,230
So some runtime Kubernetes security practices that you can use

209
00:13:04,300 --> 00:13:08,118
is use RBaC. RBAC stands for role based access control.

210
00:13:08,204 --> 00:13:11,730
So RBaC tries to answer this question, can subject

211
00:13:11,810 --> 00:13:15,222
verb object. One of the example this could be can user

212
00:13:15,286 --> 00:13:18,438
list pods. So every time you set up an RBaC rule, this is the rule

213
00:13:18,454 --> 00:13:21,806
you're trying to set. You could also set RBaC rules to

214
00:13:21,828 --> 00:13:25,902
individual namespaces. So then the question becomes, can user list pod in

215
00:13:25,956 --> 00:13:29,822
namespace? So you could have RBaC rules that are either specific

216
00:13:29,876 --> 00:13:33,418
to entire cluster or specific to single namespaces.

217
00:13:33,514 --> 00:13:36,842
So one of the examples, so this right here is example of

218
00:13:36,916 --> 00:13:40,382
a role that is bound to a namespace. So in this case, namespace default,

219
00:13:40,446 --> 00:13:43,714
we're creating a role that allows our user to

220
00:13:43,832 --> 00:13:47,746
list pods. So get watch and list pods. And we're doing

221
00:13:47,768 --> 00:13:51,254
a role binding to connect that role to a subject. So in this case,

222
00:13:51,292 --> 00:13:55,442
our subject is a user username is Jane, and role

223
00:13:55,506 --> 00:13:59,186
is then is going to be a read pod reader role. So things user

224
00:13:59,218 --> 00:14:02,466
Jane now will be able to get watch or list pod.

225
00:14:02,498 --> 00:14:05,574
So the command kubectl get pods will succeed.

226
00:14:05,622 --> 00:14:09,562
But if they try to do something like kubectural delete pod, that would fail because

227
00:14:09,616 --> 00:14:13,818
this user Jane does not have permission to delete pods.

228
00:14:13,994 --> 00:14:17,726
Define quotas. So every resource you create, you can define some sort

229
00:14:17,748 --> 00:14:22,026
of quota. In this example we're creating a resource quota and adding

230
00:14:22,138 --> 00:14:25,918
some sort of limit like how much memory you want to give, how much cpu

231
00:14:25,934 --> 00:14:29,202
you want to give, or in

232
00:14:29,256 --> 00:14:32,786
every single pod you can also create some sort of resource coder by saying we

233
00:14:32,808 --> 00:14:36,882
want to use 00:25 cpu, 128 megs of ram and

234
00:14:36,936 --> 00:14:40,662
also limit that kind of like different limits as well. So why is

235
00:14:40,716 --> 00:14:44,354
using resource code a security mechanism? So the ways resource

236
00:14:44,402 --> 00:14:47,666
coder help is limit attack surface and damage. So let's

237
00:14:47,698 --> 00:14:51,562
say one of your pod gets compromised and someone gets access to

238
00:14:51,616 --> 00:14:54,902
your pod if there is a limit, if the pod

239
00:14:54,966 --> 00:14:58,634
tries to access too much resource, kubernetes API can

240
00:14:58,752 --> 00:15:02,026
then kill that pod if it's asking for too much resource. If you don't have

241
00:15:02,048 --> 00:15:05,230
a resource limit, that pod in theory can just

242
00:15:05,300 --> 00:15:08,478
request too much resource and block out all other application

243
00:15:08,564 --> 00:15:12,462
that's running on your cluster. Also with resource coda. Another side effect

244
00:15:12,516 --> 00:15:15,498
or the main reason you want to use resource coda, that is you can get

245
00:15:15,524 --> 00:15:18,786
better resource utilization. If the scheduler knows upfront how

246
00:15:18,808 --> 00:15:21,986
much resource things applications is asking for, it can schedule it

247
00:15:22,008 --> 00:15:26,066
in a location that has exactly that much resource available and thus you

248
00:15:26,088 --> 00:15:29,522
can reach over like 70% to 80% cluster utilization.

249
00:15:29,586 --> 00:15:33,206
So that's why resource quotas are great. Finally, when you actually put a

250
00:15:33,228 --> 00:15:35,954
resource quota in your applications on your pod and deployment,

251
00:15:36,002 --> 00:15:39,810
Kubernetes actually marks these pods and application with a higher priority.

252
00:15:39,890 --> 00:15:42,982
So if you have limit and requests both set and are equal,

253
00:15:43,046 --> 00:15:46,534
your application is quality of service is rated as guaranteed.

254
00:15:46,582 --> 00:15:50,086
That means this is the last thing Kubernetes will delete

255
00:15:50,118 --> 00:15:53,566
and usually won't delete ever. And if you don't have any limit or

256
00:15:53,588 --> 00:15:57,818
request set, what happens is your quality of service is listed as best effort.

257
00:15:57,914 --> 00:16:01,998
So if something more priority comes along, Kubernetes API might

258
00:16:02,084 --> 00:16:05,726
actually delete this particular application. So putting resource quota is

259
00:16:05,748 --> 00:16:09,810
not only useful for security, it's also useful for your application so the application

260
00:16:09,880 --> 00:16:13,746
doesn't get booted when there is more resource needed. Monitor and log and this

261
00:16:13,768 --> 00:16:17,394
is not necessarily anything specific to Kubernetes. Anytime you have application and

262
00:16:17,432 --> 00:16:21,334
runtime, you want to make sure that you're monitoring and logging those information into some

263
00:16:21,372 --> 00:16:24,706
location, and so that if something does go wrong, you can immediately

264
00:16:24,738 --> 00:16:28,162
find it. And even if you immediately can find it, you can have a location

265
00:16:28,226 --> 00:16:31,766
where you can go find information later. Pods are ephemeral. So if you have

266
00:16:31,788 --> 00:16:35,206
pod logs just printed out on the pod itself, when the pod

267
00:16:35,238 --> 00:16:38,458
dies, something goes wrong. Those logs will be gone as well. So you'll have no

268
00:16:38,464 --> 00:16:41,686
way of knowing why a pod died. So I have some sort of central logging

269
00:16:41,718 --> 00:16:45,354
mechanism, hopefully outside the cluster that is constantly

270
00:16:45,402 --> 00:16:48,634
adding these logs into so that you can go back and trace

271
00:16:48,762 --> 00:16:51,854
why something went down. If some bad actor tried to make

272
00:16:51,892 --> 00:16:55,374
too many requests too quickly, you can then look at it and have

273
00:16:55,412 --> 00:16:58,562
some mechanism, have some way to alert or have some way to

274
00:16:58,616 --> 00:17:02,286
kill that thing. But you can't do that without having a location where you're collecting

275
00:17:02,318 --> 00:17:06,146
and aggregating this information. Admission controllers so admission controllers in

276
00:17:06,168 --> 00:17:09,426
Kubernetes is a way where every time you make a request

277
00:17:09,458 --> 00:17:12,610
or every time you try to create some new resource on Kubernetes,

278
00:17:12,690 --> 00:17:16,386
you can run those resources requests through this admission

279
00:17:16,418 --> 00:17:20,566
controller. So admission controller kind of looks like this. When you make an API request

280
00:17:20,598 --> 00:17:24,246
using Kubectl or directly using the Kubernetes API,

281
00:17:24,358 --> 00:17:27,610
it takes the authentication, all that is done.

282
00:17:27,680 --> 00:17:31,066
Then it goes to mutating admission and this webhook

283
00:17:31,098 --> 00:17:34,794
can mutate your request. And then after the request

284
00:17:34,842 --> 00:17:38,730
has been mutated you can then go through validation and validation

285
00:17:38,810 --> 00:17:42,762
can stop a deployment if it doesn't follow the validation

286
00:17:42,826 --> 00:17:46,014
webhook. And finally it gets persisted to etCD.

287
00:17:46,062 --> 00:17:49,694
And then at some point the reconciler takes that information and make your cluster

288
00:17:49,742 --> 00:17:53,310
state that. So why is admission webhooks useful?

289
00:17:53,390 --> 00:17:56,882
So you can use admission webhooks for pretty much anything. But one of the

290
00:17:56,936 --> 00:18:00,726
key security features they can do is look at some policy that

291
00:18:00,748 --> 00:18:04,354
you have in your company and make sure each of the resource

292
00:18:04,402 --> 00:18:08,342
that you are applying or deploying to your Kubernetes cluster follows those things.

293
00:18:08,396 --> 00:18:12,166
For example, if you want to make sure that you have quotas defined on

294
00:18:12,188 --> 00:18:15,606
all resources, you can put that in a webhook. And every time a new resource

295
00:18:15,638 --> 00:18:19,546
is being created, if it doesn't have a quota specified, either you can have

296
00:18:19,568 --> 00:18:23,126
a mutating webhook that adds a quota automatically, some default

297
00:18:23,158 --> 00:18:27,354
quota, or have a validating webhook. If it doesn't have a quota defined,

298
00:18:27,402 --> 00:18:30,762
it can just reject the application of that particular deployment.

299
00:18:30,826 --> 00:18:33,626
And it could be for a number of things. If you're trying to add privilege

300
00:18:33,658 --> 00:18:37,218
escalation, if you don't have AC Linux profile set and any number of

301
00:18:37,224 --> 00:18:41,330
things in between, you could do that using admission webhooks encrypt at

302
00:18:41,400 --> 00:18:44,894
rest. So by default the HCD database that where Kubernetes

303
00:18:44,942 --> 00:18:48,674
stores all its states is not encrypted. So to secure

304
00:18:48,722 --> 00:18:52,258
your information like secrets and other things, you need to make sure that your ETCD

305
00:18:52,274 --> 00:18:55,826
database is encrypted at rest so that no bad actor

306
00:18:55,858 --> 00:18:58,982
can access that information. Well, as Gandalf would say,

307
00:18:59,036 --> 00:19:02,230
keep it secret, keep it safe. So now let's talk

308
00:19:02,300 --> 00:19:05,686
tools. We talked about all the different things we need to worry about. Now let's

309
00:19:05,718 --> 00:19:09,146
see what are the tools in the ecosystem that we have to our disposal to

310
00:19:09,168 --> 00:19:12,694
make that job easier for us. Always be careful with your tools

311
00:19:12,742 --> 00:19:15,966
because it's very easy to burn ourselves when we are trying to

312
00:19:15,988 --> 00:19:20,190
use a new tool that we don't really take into consideration, what are the

313
00:19:20,260 --> 00:19:23,966
effects that could happen? But with that in mind, I'm going to talk about some

314
00:19:23,988 --> 00:19:27,506
of the different tools that touch upon different aspects of security.

315
00:19:27,688 --> 00:19:31,314
Most of them are open source. There are some paid products. None of them are

316
00:19:31,352 --> 00:19:34,546
endorsement. I have tried some of them out, I have found many of

317
00:19:34,568 --> 00:19:38,082
them in the ecosystem. So none of these listed here

318
00:19:38,136 --> 00:19:41,830
are like, and they are not listed in a particular order. So don't take

319
00:19:41,900 --> 00:19:45,586
this listing as any recommendation or kind of a vote

320
00:19:45,618 --> 00:19:49,286
of confidence. The ones I have tried and the ones I have kind

321
00:19:49,308 --> 00:19:53,254
of played around with, I can say if they are good and decent

322
00:19:53,302 --> 00:19:56,874
at what they do. But again, when you are trying to do that for your

323
00:19:56,912 --> 00:20:00,666
application, your company, please do some more research into them to find.

324
00:20:00,688 --> 00:20:04,282
But if they fit the need that you have. So let's first

325
00:20:04,336 --> 00:20:07,786
talk about image scanning and analysis. So when you are building container

326
00:20:07,818 --> 00:20:11,306
images or you have a container image, you want to make sure that this image

327
00:20:11,338 --> 00:20:15,230
doesn't have any vulnerability. There are a number of image scanning tools

328
00:20:15,310 --> 00:20:18,638
both in open source and paid. Some of them would be encore,

329
00:20:18,734 --> 00:20:22,306
Claire Dockle, Cubexray, sneak, trivi these are

330
00:20:22,328 --> 00:20:25,934
all tools. Some of them are free Apache MIT

331
00:20:25,982 --> 00:20:29,682
licenses and some of them has commercial offering

332
00:20:29,826 --> 00:20:33,074
tied to them. So they are part of a larger commercial offering.

333
00:20:33,122 --> 00:20:36,406
Let's look at a demo of a couple of these tools here in

334
00:20:36,428 --> 00:20:39,814
the list. Dockle good with tech test

335
00:20:39,852 --> 00:20:43,034
image v one. So guru tech is the creator of this

336
00:20:43,072 --> 00:20:46,634
tool dockle and they have a test image that you can run this against.

337
00:20:46,672 --> 00:20:49,850
So you're going to run that against this guru tech and this

338
00:20:49,920 --> 00:20:53,446
will just like download the image and scan the image,

339
00:20:53,478 --> 00:20:57,326
all the contents there and you'll see that we have some fatal things that are

340
00:20:57,348 --> 00:21:01,198
coming out of this. Talking about instead of copy we should use add

341
00:21:01,284 --> 00:21:04,782
do not store credential environments, clear app get

342
00:21:04,836 --> 00:21:07,822
caches. That is to make sure our image size is smaller.

343
00:21:07,886 --> 00:21:11,714
We're using avoid empty's password. There are a bunch of things that are bad and

344
00:21:11,752 --> 00:21:15,026
you can actually put this in between your CI when

345
00:21:15,048 --> 00:21:18,242
you're trying to build your image to make sure your image doesn't have any problems.

346
00:21:18,296 --> 00:21:21,574
So if you see any of the fatal errors you could stop your

347
00:21:21,612 --> 00:21:25,190
CI build and fail the CI build. Another image that does similar thing

348
00:21:25,260 --> 00:21:28,694
is called three v. With three v we can point it to

349
00:21:28,812 --> 00:21:31,858
one of our Golang latest image and it will look at

350
00:21:31,884 --> 00:21:35,594
the image and it will find bunch of things and many of these things

351
00:21:35,632 --> 00:21:39,146
are from the CVE. So these are list of container vulnerability that are

352
00:21:39,168 --> 00:21:42,874
found for Linux and it can list bunch of these things, right? And based

353
00:21:42,912 --> 00:21:46,126
on these issues either we can update our image or we can

354
00:21:46,148 --> 00:21:49,726
fail this build depending on if the error is something that

355
00:21:49,748 --> 00:21:53,146
we need to update. You can use both dockle and trivia in your CI

356
00:21:53,178 --> 00:21:56,814
and in their documentation. They have documentation for how to use them in your

357
00:21:56,852 --> 00:22:01,102
CI pipeline and make sure that you are taking into consideration that your image

358
00:22:01,166 --> 00:22:04,466
scan like whatever value you get from your image scan. So let's move on.

359
00:22:04,488 --> 00:22:07,854
So let's talk about runtime security a little bit. So for runtime

360
00:22:07,902 --> 00:22:11,506
security in Kubernetes what we are talking about is your cluster

361
00:22:11,538 --> 00:22:15,330
is ready, your cluster is running. We want to learn things about that cluster,

362
00:22:15,410 --> 00:22:18,706
whether or not the cluster is set up properly or the things you deploy

363
00:22:18,738 --> 00:22:22,554
to things cluster. So again these

364
00:22:22,592 --> 00:22:25,226
are a little bit more involved to set up. So we're not going to look

365
00:22:25,248 --> 00:22:28,634
at a demo, but there are some really big hitters here.

366
00:22:28,752 --> 00:22:32,682
For example Falco is a sysdig project. They do a lot of these security things

367
00:22:32,736 --> 00:22:36,270
that you inject into your Kubernetes cluster. They monitor the cluster real time

368
00:22:36,340 --> 00:22:39,770
and every time something bad is happening someone is trying to access the cluster

369
00:22:39,850 --> 00:22:43,678
in a way that is not allowed. It can create this

370
00:22:43,764 --> 00:22:46,622
monitoring alerts that you can look at. You can also set up SC,

371
00:22:46,676 --> 00:22:49,906
Linux and Seccomp to make sure that you are limiting the

372
00:22:49,928 --> 00:22:54,114
amount of things a container could do within the cluster. And these

373
00:22:54,152 --> 00:22:57,554
are definitely like each of them demand their

374
00:22:57,592 --> 00:23:01,186
own talk in their own rights. But you could set up these kind of rules

375
00:23:01,218 --> 00:23:04,742
to make sure that your container has the most least

376
00:23:04,796 --> 00:23:08,358
amount of access to do things in your cluster as possible.

377
00:23:08,524 --> 00:23:12,138
So let's look at the network security a little bit. So for network security

378
00:23:12,224 --> 00:23:15,482
there are a bunch of network overlays in Kubernetes and

379
00:23:15,536 --> 00:23:18,986
each of them aside from the network policy that is based on

380
00:23:19,008 --> 00:23:22,314
Kubernetes itself, if you are using any of these other things as your

381
00:23:22,352 --> 00:23:25,898
network overlay, for example in IBM cloud, Kubernetes we use Calico

382
00:23:25,914 --> 00:23:29,566
as a network overlay, and Calico has things you could do as well in

383
00:23:29,588 --> 00:23:32,926
terms of network policy that can go even more fine grained compared to

384
00:23:32,948 --> 00:23:36,530
the general Kubernetes network policy. So if you find out exactly

385
00:23:36,600 --> 00:23:40,002
which network overlay your Kubernetes cluster is using, you can make use

386
00:23:40,056 --> 00:23:43,502
of the particular network policy rules

387
00:23:43,566 --> 00:23:46,642
from your provider to make sure that your cluster network policy

388
00:23:46,696 --> 00:23:49,862
is really secure. Secrets management and this one is a tough one,

389
00:23:49,916 --> 00:23:53,394
because by default kubernetes secrets are not necessarily secret,

390
00:23:53,442 --> 00:23:57,058
they are just base 64 encoded. Although you could encrypt your HTTP

391
00:23:57,074 --> 00:24:00,134
cluster at best, even then your secret anyone who has access

392
00:24:00,172 --> 00:24:03,286
to the cluster can be read by and then converted

393
00:24:03,318 --> 00:24:06,666
base 64 from regular text. So creating secret in

394
00:24:06,688 --> 00:24:10,550
kubernetes is not probably the best idea. So the way you want to create secret

395
00:24:10,630 --> 00:24:14,174
is probably using some sort of secrets management, either using

396
00:24:14,292 --> 00:24:17,710
some kms from your cloud provider where your Kubernetes cluster is,

397
00:24:17,780 --> 00:24:21,706
or using tools like vault where you have either deployed

398
00:24:21,738 --> 00:24:24,782
yourself or managed from Hashicorp. Get vault

399
00:24:24,846 --> 00:24:29,202
that you can store secrets and inject secrets at runtime directly to your application

400
00:24:29,336 --> 00:24:32,754
for image distribution. There are a number of tools. You have

401
00:24:32,792 --> 00:24:36,434
grapheus in Toto Portieris and each of them does something

402
00:24:36,472 --> 00:24:40,002
a little bit different. But all of them has the idea that if your image,

403
00:24:40,066 --> 00:24:43,254
when you're distributing an image, how do you make sure that

404
00:24:43,292 --> 00:24:47,538
image is coming from the right place? Especially portiers

405
00:24:47,634 --> 00:24:51,222
has admission webhook that can look at an image and make sure

406
00:24:51,356 --> 00:24:54,506
this image is coming from a whitelisted source. So each of the

407
00:24:54,528 --> 00:24:58,202
tools, they are open source so you can deploy your own version of it.

408
00:24:58,256 --> 00:25:02,190
They're dealing with the idea how you can distribute an image from

409
00:25:02,340 --> 00:25:05,450
a secure source and securely to your end user.

410
00:25:05,530 --> 00:25:09,498
Security audit so for your kubernetes, there are ways to audit

411
00:25:09,594 --> 00:25:12,606
both the deployment yamls and the cluster itself.

412
00:25:12,708 --> 00:25:15,934
For example, tools like Kubebench or

413
00:25:15,972 --> 00:25:19,810
kubernetes, they're both from Aqua security. You can run it against a running

414
00:25:19,880 --> 00:25:23,538
cluster and that can check against some fixed rules to see if

415
00:25:23,544 --> 00:25:26,834
your cluster is set up properly. Kube audit is pretty

416
00:25:26,872 --> 00:25:30,134
cool. It can look at a YAML file that you have about

417
00:25:30,172 --> 00:25:33,266
to deploy to your cluster and check against the YAML

418
00:25:33,298 --> 00:25:37,762
file to see if the YAML file is following proper Kubernetes

419
00:25:37,826 --> 00:25:41,494
guidelines, and it can also fail your continuous delivery

420
00:25:41,542 --> 00:25:44,714
pipeline. If the YAML file you're about to deploy is not up to

421
00:25:44,752 --> 00:25:48,060
mark, you have Kubesec does something very similar.

422
00:25:48,430 --> 00:25:52,202
It can give you a scoring and it can fail your build. And finally,

423
00:25:52,336 --> 00:25:56,158
open policy agent in this scenario is probably one of the best tool that

424
00:25:56,164 --> 00:25:59,498
is out there for auditing your running Kubernetes cluster deployment

425
00:25:59,594 --> 00:26:03,166
where can define any kind of rule. So all the things we could do

426
00:26:03,188 --> 00:26:06,866
with admission webhook it is quite difficult to write your admission webhook from

427
00:26:06,888 --> 00:26:10,226
scratch with open policy agent you can define all that and more

428
00:26:10,328 --> 00:26:13,506
using very simple rules and logic. And every time

429
00:26:13,528 --> 00:26:17,058
you try to deploy something new it gets validated against the open policy

430
00:26:17,144 --> 00:26:20,754
agent webhook and you can then stop deployment because it doesn't

431
00:26:20,802 --> 00:26:24,614
match the set security rules that you have in your company. Let's look

432
00:26:24,652 --> 00:26:27,958
at a couple more demos that showcases a couple of the

433
00:26:27,964 --> 00:26:30,934
tools. We're not going to talk about open policy agent in this one in terms

434
00:26:30,972 --> 00:26:34,698
of demo because again that's a much more in depth demo and definitely deserves in

435
00:26:34,704 --> 00:26:37,850
its own talk to cover all the different things you could do with open policy

436
00:26:37,920 --> 00:26:41,574
agent. So we are running a Kube audit against the deployment

437
00:26:41,622 --> 00:26:45,166
that I have and this is checking for all the different things

438
00:26:45,188 --> 00:26:48,874
that we have. So if I run this against my deployment Yaml,

439
00:26:48,922 --> 00:26:52,014
you will see that we are getting a lot of errors. So one of them

440
00:26:52,052 --> 00:26:54,718
here is app armor settings is not set up,

441
00:26:54,884 --> 00:26:58,354
automount service account, token true and default service account.

442
00:26:58,472 --> 00:27:01,986
So in this deployment YAmL, we are not using like

443
00:27:02,008 --> 00:27:05,470
a special service account, we are using the default service account for the namespace

444
00:27:05,550 --> 00:27:09,282
which is not best security practices capability or security context

445
00:27:09,346 --> 00:27:12,930
missing. We are not adding any specific security context.

446
00:27:13,010 --> 00:27:16,754
We are not doing run as non root. So run as non root

447
00:27:16,802 --> 00:27:19,974
is not set to true allow privilege escalation neil so

448
00:27:20,012 --> 00:27:23,446
we are not also stopping our container to privilege escalate

449
00:27:23,478 --> 00:27:26,906
to root here either. So all these things we should set but we are not

450
00:27:26,928 --> 00:27:30,234
in this yAml. And so this cube audit tool is

451
00:27:30,272 --> 00:27:34,422
failing this particular YAML file. So if we set it up in our CD

452
00:27:34,486 --> 00:27:37,642
and run cube audit when you are about to deploy our YAML file,

453
00:27:37,706 --> 00:27:41,306
we could fail the build because our deployment YAML

454
00:27:41,338 --> 00:27:45,318
is not up to mark. We can also do something similar with Cubesec.

455
00:27:45,434 --> 00:27:49,058
Cubesec also can scan our YAML file and in this case

456
00:27:49,144 --> 00:27:52,386
we are looking at some, we get a score of

457
00:27:52,408 --> 00:27:55,730
four. So we got a passed because we have a limit set,

458
00:27:55,800 --> 00:27:59,338
we have a memory set, we have cpu set as well as request

459
00:27:59,374 --> 00:28:02,566
memory is also set. Some of that they also give some advice in

460
00:28:02,588 --> 00:28:05,734
terms of not directly errors, but give some advice like set app

461
00:28:05,772 --> 00:28:09,734
armor use service account, seccom root file system non root and run

462
00:28:09,772 --> 00:28:13,574
as user. So all these things, as you can see, both Cubesec and Cube audit

463
00:28:13,622 --> 00:28:16,970
does a very similar thing. So you can choose either of them in your

464
00:28:17,040 --> 00:28:20,534
pipeline to make sure that you are failing builds that doesn't

465
00:28:20,582 --> 00:28:23,978
follow the best security policies. Now finally, let's talk about some of

466
00:28:23,984 --> 00:28:27,566
the end to end commercial security products that are out there. So the ones I

467
00:28:27,588 --> 00:28:30,814
talked about, most of them are open source, but some of them are tied to

468
00:28:30,852 --> 00:28:34,142
some bigger commercial offering. With commercial offering we get

469
00:28:34,196 --> 00:28:37,614
enterprise support as well as probably a nice dashboard

470
00:28:37,662 --> 00:28:41,314
that can constantly be scanning your kubernetes cluster and updating you

471
00:28:41,352 --> 00:28:45,234
with the vulnerability that it found. So there are a number of them obviously,

472
00:28:45,352 --> 00:28:48,610
because again this industry have a lot of choices for almost everything. I list

473
00:28:48,680 --> 00:28:52,518
some of them here. This is in no way shape or form a complete

474
00:28:52,604 --> 00:28:56,530
list. So when you're doing your security you may come across something newer

475
00:28:56,610 --> 00:28:59,126
or something even better than this. But there are some of them I'm going to

476
00:28:59,148 --> 00:29:02,454
talk about. You definitely have aqua security. They put out a lot of open

477
00:29:02,492 --> 00:29:05,158
source tools in the community as well. There are a bunch of them in the

478
00:29:05,164 --> 00:29:08,358
list like sysdig as well, twist lock and a number of them.

479
00:29:08,444 --> 00:29:11,406
And there's like a quick comparison between some of them.

480
00:29:11,508 --> 00:29:15,066
And each of those tools have these different capabilities.

481
00:29:15,178 --> 00:29:18,478
And just because something has more capability, that doesn't necessarily mean

482
00:29:18,564 --> 00:29:22,462
they are better or worse than the other tools. It just means as of

483
00:29:22,516 --> 00:29:26,142
now and they are claiming to have all these different tools. It might be

484
00:29:26,196 --> 00:29:29,458
possible for you to look at these tools when you are

485
00:29:29,464 --> 00:29:32,786
trying to use one of them, that you may not need all kind of

486
00:29:32,808 --> 00:29:36,354
all of these capabilities. So for your application you might look

487
00:29:36,392 --> 00:29:40,246
at one of these tools and see that the capability they offer is all

488
00:29:40,268 --> 00:29:43,526
we actually need. So definitely keep this list in mind.

489
00:29:43,628 --> 00:29:47,494
Look at this and look at all the features each of them provide. But also

490
00:29:47,532 --> 00:29:50,886
keep in mind that just because having a huge list of

491
00:29:50,988 --> 00:29:54,694
different things some of these tools has to offer doesn't necessarily

492
00:29:54,742 --> 00:29:58,234
mean how good each of those tools are. So again, I would implore you to

493
00:29:58,272 --> 00:30:01,466
kind of do your own exploration, try them out,

494
00:30:01,568 --> 00:30:04,974
use the trial and see which application here fits your

495
00:30:05,012 --> 00:30:07,930
need the most. Finally, let's talk but service meshes.

496
00:30:08,010 --> 00:30:11,886
Service mesh, there are quite many of them now. The notable ones would be

497
00:30:11,908 --> 00:30:15,550
istio Linkerd one and two kuma mesh. So service

498
00:30:15,620 --> 00:30:18,898
mesh are a collection of best in class solutions that

499
00:30:18,984 --> 00:30:22,274
brings in bunch of things that right now is quite

500
00:30:22,312 --> 00:30:25,506
difficult to do just in kubernetes. And you have to do a lot of these

501
00:30:25,528 --> 00:30:29,238
things yourself to do them well. So service meshes control and

502
00:30:29,244 --> 00:30:32,614
monitor service traffic. They are invisible to dev team,

503
00:30:32,652 --> 00:30:36,246
which is a great thing. Your development teams won't have to worry about where your

504
00:30:36,268 --> 00:30:39,958
application runs to build really cool applications. And finally,

505
00:30:40,044 --> 00:30:43,254
they can enable mtls between service to service traffic.

506
00:30:43,302 --> 00:30:46,906
So when you have mutual TLS enabled between service, what you

507
00:30:46,928 --> 00:30:50,406
can achieve from it is if by any chance one of your pods

508
00:30:50,438 --> 00:30:54,454
gets compromised without the proper TLS certificate, that pod

509
00:30:54,502 --> 00:30:57,406
won't be able to talk to some other pod it is not allowed to talk

510
00:30:57,428 --> 00:31:00,766
to in the first place. So you can really limit the amount of things a

511
00:31:00,788 --> 00:31:03,854
bad actor can do. Even if they get access to your application?

512
00:31:03,972 --> 00:31:08,126
Even if they get access to the application pod. It also lets transparent

513
00:31:08,158 --> 00:31:11,726
monitoring of network traffic. So you'll automatically collect these metrics

514
00:31:11,758 --> 00:31:15,490
from the network traffic as they're passing through. Can kind of look at what exactly

515
00:31:15,560 --> 00:31:18,986
is happening in your cluster if one of their pod all of a sudden

516
00:31:19,038 --> 00:31:23,046
starts to make too many requests. You can monitor that, set up some alerts and

517
00:31:23,148 --> 00:31:26,534
take action based on that to make sure that your cluster is

518
00:31:26,572 --> 00:31:29,670
not going crazy. So let me ask this question again,

519
00:31:29,740 --> 00:31:33,626
right? We talked about a lot of these things and after talking about

520
00:31:33,728 --> 00:31:37,754
this for about the last 2025 minutes, are computers less secure than real

521
00:31:37,792 --> 00:31:41,114
life? Right? Like we have a lot of problems in computer security.

522
00:31:41,232 --> 00:31:44,574
At the same time, we have a lot more tools too to make sure that

523
00:31:44,612 --> 00:31:48,446
this security vulnerability doesn't affect us directly. As I said,

524
00:31:48,548 --> 00:31:51,690
and I'm going to say it over and over again, security is a spectrum.

525
00:31:51,770 --> 00:31:55,274
Nothing is like secure. It could be more secure or less secure.

526
00:31:55,322 --> 00:31:59,394
Never just secure. When I think of kubernetes security or security in general,

527
00:31:59,512 --> 00:32:03,346
this picture comes to my mind. Let's say our bike is the application and

528
00:32:03,368 --> 00:32:06,898
we want to make sure this application is secure. So all we are trying to

529
00:32:06,904 --> 00:32:10,258
do is put more and more and more locks on things bike,

530
00:32:10,354 --> 00:32:14,038
so that at the end of the day it's not worth for the thief to

531
00:32:14,124 --> 00:32:17,286
try to get rid of all these locks to steal our bike in

532
00:32:17,308 --> 00:32:21,530
terms our data and application. So when we try to secure our application,

533
00:32:21,680 --> 00:32:25,066
all we are trying to do is to make sure that sealing the

534
00:32:25,088 --> 00:32:28,778
data, stealing the information, breaking into this application

535
00:32:28,944 --> 00:32:32,474
is not worth the time. With that, go out there

536
00:32:32,512 --> 00:32:35,870
and secure your kubernetes and your applications in general.

537
00:32:36,020 --> 00:32:39,806
Hopefully I have managed to show you what are the

538
00:32:39,828 --> 00:32:43,082
different things you need to worry about when you're trying to secure your kubernetes cluster.

539
00:32:43,146 --> 00:32:46,330
And I'm trying to free your mind, but I can only show you the door.

540
00:32:46,410 --> 00:32:50,266
You are the one that has to walk through it. Great. DevOps Admin Morpheus

541
00:32:50,298 --> 00:32:53,710
said that to Neo once and I'm saying that to you now. With that.

542
00:32:53,780 --> 00:32:56,790
That is the end of the talk. Thank you so much for spending the last

543
00:32:56,860 --> 00:33:00,098
30 odd minutes with me and listening to me about kubernetes

544
00:33:00,194 --> 00:33:04,070
security. I'd love to hear your stories, comments, questions and

545
00:33:04,140 --> 00:33:07,698
any cool security stories that you have. You can find me at movie

546
00:33:07,714 --> 00:33:11,174
codes and if you have any questions, feel free to drop by and ask me

547
00:33:11,212 --> 00:33:12,260
on Twitter. Thank you.

