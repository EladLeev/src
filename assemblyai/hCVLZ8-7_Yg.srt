1
00:00:25,490 --> 00:00:29,474
Hey everyone, this is Smokitz from Edgeless. I'm hoping you're enjoying the conference.

2
00:00:29,522 --> 00:00:33,142
So far, this talk is going to be about how to build

3
00:00:33,276 --> 00:00:37,080
cloud native confidential computing apps with go

4
00:00:37,450 --> 00:00:41,206
so we're edgeless. We're a startup from the

5
00:00:41,308 --> 00:00:45,154
city of Bohom in Germany. It's a city probably less famous

6
00:00:45,202 --> 00:00:48,358
for returning to the premier division in soccer this year,

7
00:00:48,444 --> 00:00:52,218
and more famous for rapidly growing vibrant

8
00:00:52,314 --> 00:00:56,046
startup computer secrets startup scene. And we're part of

9
00:00:56,068 --> 00:01:00,266
it. We're building confidential computing applications

10
00:01:00,378 --> 00:01:04,142
with a focus on open source cloud native

11
00:01:04,206 --> 00:01:07,858
tooling. We're roughly ten engineers and

12
00:01:07,944 --> 00:01:11,410
were founded two years back in 2019.

13
00:01:11,830 --> 00:01:15,498
So before I go into the details of building confidential computing

14
00:01:15,534 --> 00:01:18,934
applications, I'd like to go one step back and

15
00:01:19,052 --> 00:01:22,402
give you a brief introduction on what is confidential

16
00:01:22,466 --> 00:01:25,682
computing, what problem does it solve?

17
00:01:25,826 --> 00:01:29,194
And more importantly, why this is exciting and why

18
00:01:29,232 --> 00:01:30,700
I'm giving this talk today.

19
00:01:31,710 --> 00:01:35,462
So you might have seen this graphic

20
00:01:35,526 --> 00:01:38,874
or sticker from the Free Software foundation on

21
00:01:38,912 --> 00:01:42,606
some tech conference, on some t shirt or something that says there

22
00:01:42,628 --> 00:01:45,770
is no cloud, there's just other people's computers.

23
00:01:45,930 --> 00:01:48,746
And of course this is a very provocative statement,

24
00:01:48,938 --> 00:01:53,230
but since a couple of years, everybody is moving

25
00:01:53,380 --> 00:01:56,960
their data, their workloads to the cloud.

26
00:01:57,570 --> 00:02:01,700
It's just private people like you and me storing their data

27
00:02:02,790 --> 00:02:05,890
min some cloud service. But it's also

28
00:02:06,040 --> 00:02:09,638
startups like us that are heavily using

29
00:02:09,724 --> 00:02:13,302
the cloud. And it's great because we don't need to build and buy

30
00:02:13,356 --> 00:02:17,046
our own infrastructure. We immediately have all the computing power we

31
00:02:17,068 --> 00:02:20,390
need at hand, very flexible, scalable,

32
00:02:20,550 --> 00:02:23,850
and the same goes for larger enterprises.

33
00:02:24,270 --> 00:02:27,478
They don't want to maintain their own infrastructure anymore,

34
00:02:27,574 --> 00:02:31,926
it's less efficient. So they start moving their workloads

35
00:02:32,038 --> 00:02:35,854
to those cloud. Well, we have to remember that the cloud is not just some

36
00:02:35,972 --> 00:02:39,774
magic place where milk and honey flow, it's some real

37
00:02:39,812 --> 00:02:43,682
hardware in a real data center somewhere that is

38
00:02:43,816 --> 00:02:47,054
maintained by real people. There's a software stack

39
00:02:47,102 --> 00:02:50,894
running on this hardware with real hypervisors operating systems,

40
00:02:51,022 --> 00:02:54,562
also maintained by some people. And then

41
00:02:54,696 --> 00:02:59,078
there's other customers code running alongside your code that

42
00:02:59,164 --> 00:03:02,166
potentially is isolated from your code,

43
00:03:02,268 --> 00:03:06,066
built just through regular isolation primitives. So you can't

44
00:03:06,098 --> 00:03:09,782
be certain that they might interfere with your computing,

45
00:03:09,926 --> 00:03:13,334
they might be malicious and try to steal

46
00:03:13,382 --> 00:03:17,034
your data through site channels or other means.

47
00:03:17,232 --> 00:03:20,860
So on one hand, for private people,

48
00:03:21,230 --> 00:03:24,846
this is the fear of breaches. Data breaches, losing your data,

49
00:03:24,948 --> 00:03:29,066
using your photos and what you care about. But for enterprises,

50
00:03:29,258 --> 00:03:32,878
that's even more than just. I mean it's bad enough, but it's

51
00:03:32,894 --> 00:03:36,290
even worse, because they might miss out on

52
00:03:36,360 --> 00:03:40,354
business value here where they can, because of

53
00:03:40,392 --> 00:03:44,194
regulations or other reasons, share their data or move

54
00:03:44,232 --> 00:03:47,702
their data to the cloud, potentially share

55
00:03:47,756 --> 00:03:52,214
it with other enterprises and then do a

56
00:03:52,252 --> 00:03:56,134
collaborative computation on data, profit from each

57
00:03:56,172 --> 00:04:00,330
other, create new business value, create new insights from

58
00:04:00,480 --> 00:04:02,860
merging their respective data.

59
00:04:03,230 --> 00:04:06,538
And this is really problem today,

60
00:04:06,624 --> 00:04:10,410
right? You could do so much more with those data you already have.

61
00:04:10,560 --> 00:04:13,978
If you could share the data without sharing,

62
00:04:14,074 --> 00:04:17,566
because you don't want to trust these other parties, these other companies,

63
00:04:17,748 --> 00:04:22,342
you would need some kind of primitive so you can agree on beforehand

64
00:04:22,506 --> 00:04:26,226
and then be sure that this is the way the data is

65
00:04:26,248 --> 00:04:30,098
handled afterwards. And hardware providers saw this problem a couple

66
00:04:30,104 --> 00:04:34,466
of years back and decided we

67
00:04:34,488 --> 00:04:38,566
need some hardware base that we can build on to create

68
00:04:38,668 --> 00:04:42,322
some secure computation space on the upper layers

69
00:04:42,466 --> 00:04:45,686
that people can use to process their data in this

70
00:04:45,708 --> 00:04:49,466
secure space. And this is typically called an enclave. So a

71
00:04:49,488 --> 00:04:52,986
secure space that you can move your data, your code

72
00:04:53,168 --> 00:04:56,154
and computers it there. And last year,

73
00:04:56,272 --> 00:05:00,022
Forbes acknowledged that this is a

74
00:05:00,096 --> 00:05:03,840
very fundamental change in how we see the cloud.

75
00:05:04,210 --> 00:05:07,870
And they added the confidential computing as

76
00:05:07,940 --> 00:05:11,374
one of their digital transformation trends for 21.

77
00:05:11,572 --> 00:05:15,010
So this was of course very reassuring.

78
00:05:15,350 --> 00:05:19,326
But it's not just this promise that this is going to be a digital transformation

79
00:05:19,358 --> 00:05:23,490
trend. It's already happening. So you see the big cases

80
00:05:23,990 --> 00:05:27,234
already having right now today offerings

81
00:05:27,282 --> 00:05:30,242
for confidential computing, and they are growing rapidly.

82
00:05:30,386 --> 00:05:33,974
It's really starting to gain traction now. People understand this

83
00:05:34,012 --> 00:05:37,714
technology more, they understand what confidential computing gets them and

84
00:05:37,772 --> 00:05:41,718
asking for these offerings. So of course CSP delivered,

85
00:05:41,814 --> 00:05:45,350
you can have confidential computing vms clusters

86
00:05:45,430 --> 00:05:48,794
on the cloud today. And it's not just an

87
00:05:48,832 --> 00:05:52,426
additional product that gives you

88
00:05:52,448 --> 00:05:55,914
more security, additional features. There are people even

89
00:05:55,952 --> 00:05:59,994
going as far saying this is a real breakthrough technology that's

90
00:06:00,042 --> 00:06:03,878
transforming the future of the cloud. It will be one of the building blocks

91
00:06:03,994 --> 00:06:08,034
for the future of those cloud. So in approximately five years,

92
00:06:08,152 --> 00:06:11,778
the cloud will be fully confidential. So all

93
00:06:11,784 --> 00:06:15,634
the computing power there, all the workloads will be done inside confidential

94
00:06:15,682 --> 00:06:19,286
computing. So this is why we're excited about this,

95
00:06:19,388 --> 00:06:23,174
and more and more people are jumping on the train and

96
00:06:23,212 --> 00:06:27,046
use this technology. So very high level

97
00:06:27,148 --> 00:06:30,318
technical overview of what I mean. With secure arcways,

98
00:06:30,434 --> 00:06:33,894
we have this stack beforehand. Every layer in the stack

99
00:06:33,942 --> 00:06:37,242
could access or potentially access your code,

100
00:06:37,296 --> 00:06:40,846
your data, including people that have access to

101
00:06:41,028 --> 00:06:45,006
the operating system, for example. So now we introduce a

102
00:06:45,028 --> 00:06:48,986
new part in the hardware that bootstraps

103
00:06:49,098 --> 00:06:52,766
this secure enclave. You move the code and data inside,

104
00:06:52,948 --> 00:06:56,642
and then nothing else in the stack has access to it.

105
00:06:56,776 --> 00:07:00,674
And we typically define such secure enclaves with four

106
00:07:00,712 --> 00:07:04,626
properties, so they are isolated from everything else. They are

107
00:07:04,648 --> 00:07:08,246
on their own there. Their memory is protected at runtime. So even if you have

108
00:07:08,268 --> 00:07:13,026
direct memory access to the hardware memory, you wouldn't be able to obtain

109
00:07:13,138 --> 00:07:16,914
the plain text there. Then they have some kind of mechanism to seal

110
00:07:16,962 --> 00:07:21,446
their state, meaning to persist their state on some storage,

111
00:07:21,638 --> 00:07:25,222
of course, encrypted and only accessible

112
00:07:25,286 --> 00:07:29,098
to them later on. And then they have some kind of

113
00:07:29,184 --> 00:07:32,538
means of proving the identity to the

114
00:07:32,544 --> 00:07:37,246
outside, proving they have integrated the

115
00:07:37,268 --> 00:07:40,686
code and data that's expected there, and proving this to

116
00:07:40,708 --> 00:07:44,670
a third party, to the user. And that's typically called attestation,

117
00:07:44,830 --> 00:07:48,146
remote attestation. So those four properties is what

118
00:07:48,168 --> 00:07:52,190
we expect from secure enclaves, from confidential computing.

119
00:07:52,350 --> 00:07:55,380
I'd like to give you some real, I mean,

120
00:07:55,910 --> 00:07:58,630
you can let your imagination go there,

121
00:07:58,700 --> 00:08:02,118
but to give you really hands on,

122
00:08:02,284 --> 00:08:05,654
maybe a little bit out of the box, examples of where confidential computing is

123
00:08:05,692 --> 00:08:09,850
used. First of all, thing that's very interesting for a lot of people is

124
00:08:10,000 --> 00:08:13,126
wallets, cryptocurrency wallets. Currently there's

125
00:08:13,158 --> 00:08:16,794
a lot of special hardware used, but with

126
00:08:16,832 --> 00:08:20,214
this technology, you could actually use commodity cloud

127
00:08:20,352 --> 00:08:24,634
cpus, cloud machines to build secure

128
00:08:24,682 --> 00:08:28,158
wallets that are even privacy preserving. And there's a company

129
00:08:28,244 --> 00:08:31,854
doing this already called bitcoin. The other

130
00:08:31,892 --> 00:08:35,422
thing, e health. So in Germany we have the electronic

131
00:08:35,486 --> 00:08:39,954
health records and those e, which is

132
00:08:39,992 --> 00:08:43,234
basically electronic prescription that

133
00:08:43,272 --> 00:08:46,566
is going to be rolled out. And it's built with confidential computing. So you

134
00:08:46,588 --> 00:08:50,466
have all your patients data, their diagnosis,

135
00:08:50,658 --> 00:08:55,154
their medical history, stored, processed and accessible

136
00:08:55,282 --> 00:08:59,014
in the cloud, built, protected via confidential computing.

137
00:08:59,142 --> 00:09:02,374
That's one very popular messenger called signal.

138
00:09:02,502 --> 00:09:05,926
They do what most messengers do, they do contact discovery.

139
00:09:06,038 --> 00:09:09,898
So they go through your contacts on your phone and match

140
00:09:09,984 --> 00:09:13,642
them with other registered users of this messenger.

141
00:09:13,786 --> 00:09:17,754
And of course, this is often a problem of whether people criticize

142
00:09:17,802 --> 00:09:21,486
about these messengers. They basically push your whole contact list to the

143
00:09:21,508 --> 00:09:25,618
cloud and signal build confidential computing application

144
00:09:25,784 --> 00:09:28,894
that handles things inside an enclave. So nobody,

145
00:09:29,022 --> 00:09:32,434
not signal, not anybody else actually ever gets

146
00:09:32,472 --> 00:09:35,974
access to your contacts, and they stay with you and you still can

147
00:09:36,012 --> 00:09:39,014
have your contact discovery service. Very cool,

148
00:09:39,052 --> 00:09:42,262
those. Okay, so hope

149
00:09:42,316 --> 00:09:45,526
I got you hooked on confidential computing and what

150
00:09:45,548 --> 00:09:49,306
you can do with it. So now let's take a look at how we

151
00:09:49,328 --> 00:09:53,162
can build confidential computing application with go cloud

152
00:09:53,216 --> 00:09:57,354
native. And that's what we want to do. So first question,

153
00:09:57,552 --> 00:10:01,338
why go? Why is this? Where's the match here for us?

154
00:10:01,424 --> 00:10:04,974
And I think for most people, confidential computing is a cloud technology.

155
00:10:05,172 --> 00:10:09,150
Cloud in most cases means cloud native software means

156
00:10:09,220 --> 00:10:12,846
microservices, means scaling. And I

157
00:10:12,868 --> 00:10:16,290
think you could say that's most likely going to be some go service

158
00:10:16,360 --> 00:10:20,706
running there. Most software there is written in Go. It's quite a good match

159
00:10:20,888 --> 00:10:24,626
without going into details of the language here. But when

160
00:10:24,648 --> 00:10:28,466
we started there was no go support for secure enclaves.

161
00:10:28,578 --> 00:10:31,814
So we decided if we think about how we want to build

162
00:10:31,852 --> 00:10:34,790
software for confidential computing applications,

163
00:10:36,010 --> 00:10:38,166
we want to build them with Go, we want to build them cloud native.

164
00:10:38,198 --> 00:10:41,802
So we need the support and let's get this cool

165
00:10:41,856 --> 00:10:45,370
go experience into the world of confidential computing.

166
00:10:45,950 --> 00:10:48,662
So essentially we build eg.

167
00:10:48,806 --> 00:10:52,206
It's a modified go compiler that compiles your go code that

168
00:10:52,308 --> 00:10:55,758
is able to run inside an enclave. We have some

169
00:10:55,924 --> 00:10:59,546
SGX specific tooling, so you might be familiar

170
00:10:59,578 --> 00:11:03,438
with the go way of building software. Go build, go run. You want

171
00:11:03,444 --> 00:11:07,566
to have the same experience with ego. So you see

172
00:11:07,668 --> 00:11:10,962
on the bottom there you can install it from the snap store.

173
00:11:11,016 --> 00:11:14,066
We have a DAP package, you can install it, build it from source, and then

174
00:11:14,088 --> 00:11:17,246
we have more or less the same experience of ego.

175
00:11:17,278 --> 00:11:20,822
Go build. And then we have an additional step we will see

176
00:11:20,876 --> 00:11:23,974
later on to sign your application and ego run.

177
00:11:24,012 --> 00:11:27,586
So it feels very go like. And then of course we

178
00:11:27,628 --> 00:11:31,894
have some libraries to give you the specific features

179
00:11:32,022 --> 00:11:35,660
inside and outside of the enclave that are very specific

180
00:11:36,110 --> 00:11:39,706
in enclave code. So before I showed you

181
00:11:39,808 --> 00:11:43,134
the ceiling and remote editation and this kind of stuff,

182
00:11:43,252 --> 00:11:46,880
and we will see things in the hands on shortly after things.

183
00:11:48,930 --> 00:11:52,390
And it's not only us that like to build software with ego.

184
00:11:52,490 --> 00:11:55,966
We heard that the folks at Microsoft like it as well and they included

185
00:11:55,998 --> 00:11:59,762
it in their documentation for building

186
00:11:59,816 --> 00:12:02,834
confidential application for the Azure cloud.

187
00:12:03,032 --> 00:12:06,898
And yeah, of course eg works with your favorite

188
00:12:06,994 --> 00:12:10,854
tooling to write your software. We mostly use vs code,

189
00:12:10,972 --> 00:12:14,470
but of course you can use whatever you like.

190
00:12:14,620 --> 00:12:18,166
So this is the high level overview of

191
00:12:18,188 --> 00:12:21,466
eg. It's very short because it's not much you have to

192
00:12:21,488 --> 00:12:25,338
adapt. If you write go code, there's not much you need to change. You install

193
00:12:25,424 --> 00:12:29,340
it and then you're good to go. And now I'd like to

194
00:12:29,790 --> 00:12:33,406
do a little demo, give you a bit of a, more of a practical experience

195
00:12:33,508 --> 00:12:37,706
of what ego feels like. And to that end let me introduce

196
00:12:37,818 --> 00:12:41,470
a little demo application. So we want to build

197
00:12:41,620 --> 00:12:45,378
a cloud service that's running there with ego in the

198
00:12:45,384 --> 00:12:49,540
cloud. And it's basically a key value store. You can pass in

199
00:12:50,230 --> 00:12:53,586
a key and a value secret and

200
00:12:53,688 --> 00:12:56,998
the server stores it. And whenever you pass in

201
00:12:57,084 --> 00:13:00,774
the same key again, you will retrieve those same

202
00:13:00,812 --> 00:13:04,674
value. So your secret again. So passing in a secret

203
00:13:04,802 --> 00:13:09,354
and getting it back. Let me switch into

204
00:13:09,552 --> 00:13:13,066
the vs code screen. Okay, so this is

205
00:13:13,088 --> 00:13:16,614
our demo application. It's a simple server client

206
00:13:16,662 --> 00:13:20,114
application. The server is an HTTP server handling

207
00:13:20,182 --> 00:13:25,290
one endpoint called secret. Expect three parameters depending

208
00:13:25,370 --> 00:13:29,246
on the first one, the command, it either gets or gets a

209
00:13:29,268 --> 00:13:32,586
value. The value is stored inside a

210
00:13:32,628 --> 00:13:35,700
map, simple key value store here.

211
00:13:37,910 --> 00:13:41,202
And when you retrieve a value,

212
00:13:41,256 --> 00:13:44,546
it checks for this key in the map, and if it exists it returns it

213
00:13:44,568 --> 00:13:48,614
to you. And the map is essentially the state

214
00:13:48,652 --> 00:13:52,118
of this application. And whenever a new value is set,

215
00:13:52,204 --> 00:13:55,542
the state is stored or

216
00:13:55,596 --> 00:13:59,034
saved and when it initially boots up it

217
00:13:59,072 --> 00:14:02,378
loads a state. So this is implemented using

218
00:14:02,464 --> 00:14:06,250
files on the local file system. So saving

219
00:14:06,320 --> 00:14:09,786
is writing it to a file and loading is reading it from

220
00:14:09,808 --> 00:14:12,302
this file. So when it boots up it checks if there are already a state

221
00:14:12,356 --> 00:14:16,926
and loads it. So it has some very simple

222
00:14:17,028 --> 00:14:19,760
primitive way of persisting state.

223
00:14:20,130 --> 00:14:23,940
And in typical go I could now build this application

224
00:14:24,550 --> 00:14:27,630
with go build server

225
00:14:27,710 --> 00:14:31,282
go and

226
00:14:31,336 --> 00:14:34,946
I could run it binary, or I can do go

227
00:14:34,968 --> 00:14:38,486
run server go and then

228
00:14:38,508 --> 00:14:41,238
it's listening and I can connect with my favorite tool,

229
00:14:41,324 --> 00:14:45,526
curl, whatever, it's just an HTTP endpoint. Essentially I

230
00:14:45,548 --> 00:14:49,530
wrote, for the simplicity of this demo, I wrote a client that

231
00:14:49,600 --> 00:14:53,738
expects a command key value and then

232
00:14:53,904 --> 00:14:57,126
builds up the HTTP request,

233
00:14:57,238 --> 00:15:01,374
connects to the server and then executes the

234
00:15:01,412 --> 00:15:05,166
HTTP get and

235
00:15:05,268 --> 00:15:08,960
does the set and get commands. Very simple,

236
00:15:10,690 --> 00:15:14,194
nothing magic going on here. So again, I could

237
00:15:14,232 --> 00:15:18,834
build my client, or I can run it directly and

238
00:15:18,872 --> 00:15:22,340
of course it expects command and

239
00:15:23,590 --> 00:15:26,180
value and a key. So let's say test test,

240
00:15:27,510 --> 00:15:31,222
it says okay, so now let's try to gets this

241
00:15:31,356 --> 00:15:34,886
value and there

242
00:15:34,908 --> 00:15:38,374
it is, so secret test retrieved. Okay, now let's

243
00:15:38,422 --> 00:15:41,642
say we want to put the server inside

244
00:15:41,696 --> 00:15:45,754
a secure enclave so I can deploy it to the cloud and nobody can

245
00:15:45,792 --> 00:15:49,478
steal those secrets at runtime.

246
00:15:49,574 --> 00:15:51,470
So it's protected.

247
00:15:53,010 --> 00:15:56,734
And all I have to do for this with

248
00:15:56,772 --> 00:16:00,414
ego, so let's stop. The server is

249
00:16:00,452 --> 00:16:04,046
just, instead of say go build, I say eg

250
00:16:04,078 --> 00:16:08,318
go build server

251
00:16:08,414 --> 00:16:12,610
go, same as

252
00:16:12,680 --> 00:16:16,418
before. And as I mentioned, I have one additional step.

253
00:16:16,584 --> 00:16:20,006
I built this binary now with our modified go compiler so

254
00:16:20,028 --> 00:16:23,670
it can be run inside an enclave. And now I can create an enclaves

255
00:16:24,250 --> 00:16:28,154
by saying eg sign. All enclaves have

256
00:16:28,192 --> 00:16:31,862
to be signed. So I need this one additional

257
00:16:31,926 --> 00:16:38,874
step. And when

258
00:16:38,912 --> 00:16:42,654
we do this, we get three new files, a public private key

259
00:16:42,692 --> 00:16:46,030
pair that was used for signing, and a configuration.

260
00:16:46,850 --> 00:16:51,146
This configuration contains

261
00:16:51,178 --> 00:16:55,250
some SGX specific parameters. It contains

262
00:16:56,790 --> 00:16:59,906
the application that this is for it contains the

263
00:16:59,928 --> 00:17:03,266
key and of course I

264
00:17:03,288 --> 00:17:06,406
can modify those values if I already have a

265
00:17:06,428 --> 00:17:09,910
signing key. I can use this here for signing,

266
00:17:10,570 --> 00:17:14,854
but with the default configuration now we

267
00:17:14,892 --> 00:17:19,562
can now just do ego run of

268
00:17:19,616 --> 00:17:23,494
server. And instead of booting up my go binary,

269
00:17:23,542 --> 00:17:27,130
it now boots up an enclave and starts my go binary inside.

270
00:17:27,280 --> 00:17:30,734
And everything else is just working as

271
00:17:30,772 --> 00:17:34,414
before. In fact I should still oh no,

272
00:17:34,452 --> 00:17:40,062
this doesn't work. I will get to that back later, but I can set

273
00:17:40,116 --> 00:17:43,700
this value again and of course retrieve it.

274
00:17:44,550 --> 00:17:48,210
So very simple this configuration.

275
00:17:49,270 --> 00:17:52,260
We will see it in the next iteration of this demo.

276
00:17:53,510 --> 00:17:57,574
But you can go to our documentation, you will find

277
00:17:57,692 --> 00:18:02,230
those, it's on ego devdocs.

278
00:18:03,050 --> 00:18:06,950
And then you find of course those commands I just showed you. But you also

279
00:18:07,020 --> 00:18:11,222
find a reference for this configuration file

280
00:18:11,366 --> 00:18:15,066
that is explaining all those parameters, what they mean and what you

281
00:18:15,088 --> 00:18:18,618
need to set there for your own application. This is

282
00:18:18,704 --> 00:18:22,350
how simple it is to create a go enclave from a simple

283
00:18:22,420 --> 00:18:25,774
go application. Same thing works if you have a more

284
00:18:25,892 --> 00:18:29,854
complex application. For example, typical thing

285
00:18:29,892 --> 00:18:33,678
we show is those hashicorp vault secret store

286
00:18:33,764 --> 00:18:37,678
that also runs inside a go enclave or an ego enclave.

287
00:18:37,774 --> 00:18:40,846
The next thing I want to show you is remote adaptation.

288
00:18:40,958 --> 00:18:44,702
So we just have seen how simple it is to create can enclave.

289
00:18:44,846 --> 00:18:47,570
Now it's running inside the cloud, it's protected.

290
00:18:47,650 --> 00:18:50,886
But how does the user that wants to

291
00:18:50,908 --> 00:18:54,502
trust this application and wants to send over the secrets know

292
00:18:54,556 --> 00:18:58,246
that this actually the service we just written there, and it's

293
00:18:58,278 --> 00:19:02,006
not this guy, that's some malicious user

294
00:19:02,038 --> 00:19:06,326
deployed that's waiting for user secrets and then runs

295
00:19:06,358 --> 00:19:10,054
with them. So how does it work? And it works with remote

296
00:19:10,102 --> 00:19:14,320
agitation. When a user does a request there, the service

297
00:19:14,690 --> 00:19:18,586
creates something like an identity report. In the world of confidential

298
00:19:18,618 --> 00:19:22,126
computing, in the world of SGX, typically called quote. So the

299
00:19:22,148 --> 00:19:26,238
service sends over this quote to the user, first user

300
00:19:26,254 --> 00:19:29,038
verifies the identity, verifies the integrity,

301
00:19:29,214 --> 00:19:33,314
and when successful sends over the

302
00:19:33,352 --> 00:19:37,394
secrets. Let's see how with Eg we can very

303
00:19:37,432 --> 00:19:41,730
simplest have this remote adaptation, so open

304
00:19:41,880 --> 00:19:45,218
things code again, go into our server.

305
00:19:45,394 --> 00:19:49,594
What we want to do now, we want to, instead of creating an

306
00:19:49,632 --> 00:19:53,318
HTTP server,

307
00:19:53,334 --> 00:19:56,470
we want to create an HTTPs server so the connection is protected.

308
00:19:56,630 --> 00:20:00,394
And with the TLS handshake

309
00:20:00,442 --> 00:20:05,102
we also want to verify the identity of the service going

310
00:20:05,156 --> 00:20:08,526
into our documentation. It has a link to the

311
00:20:08,548 --> 00:20:12,474
go library that ego comes

312
00:20:12,532 --> 00:20:14,100
with. So let's see,

313
00:20:17,590 --> 00:20:23,454
we have different modules

314
00:20:23,502 --> 00:20:27,446
depending on what part of the

315
00:20:27,468 --> 00:20:31,634
enclave process you're in. So for the client side, for the enclave

316
00:20:31,682 --> 00:20:35,640
side, and some specifics so let's see,

317
00:20:36,410 --> 00:20:43,774
the enclave has

318
00:20:43,812 --> 00:20:48,494
some explanation on how to use remote editation and

319
00:20:48,532 --> 00:20:52,302
what we want to have here. We want to use the very simplest function

320
00:20:52,356 --> 00:20:55,902
we can have that's called create editation server TLS

321
00:20:55,966 --> 00:20:59,262
config. So it basically creates a go TLS

322
00:20:59,326 --> 00:21:02,914
configuration that embeds the

323
00:21:02,952 --> 00:21:07,106
identity proof I just showed you in the TLS certificate and returns

324
00:21:07,138 --> 00:21:10,566
your TLS config. So this function is what we

325
00:21:10,588 --> 00:21:11,480
want to use.

326
00:21:14,250 --> 00:21:18,234
So going into vs code we

327
00:21:18,272 --> 00:21:22,602
say tls config and

328
00:21:22,656 --> 00:21:26,394
some error that we're going to probably ignore right now should be

329
00:21:26,432 --> 00:21:30,830
this Mr. C and

330
00:21:30,980 --> 00:21:36,346
it was in the enclave package.

331
00:21:36,458 --> 00:21:42,994
So this function here and

332
00:21:43,032 --> 00:21:45,140
let's ignore the error for now.

333
00:21:47,910 --> 00:21:51,394
And now we can use this TLS config when

334
00:21:51,432 --> 00:21:54,290
we create the server.

335
00:21:54,710 --> 00:21:58,806
So we

336
00:21:58,828 --> 00:22:02,054
say TLS config is this guy.

337
00:22:02,252 --> 00:22:05,782
And instead of sharing listen and serve, we say listen

338
00:22:05,836 --> 00:22:08,070
and serve tls.

339
00:22:08,830 --> 00:22:12,278
And because we already configured a TLS config here we don't

340
00:22:12,294 --> 00:22:21,454
need to set any more values. So now instead

341
00:22:21,572 --> 00:22:25,294
of just doing

342
00:22:25,332 --> 00:22:26,910
a normal TLS handshake,

343
00:22:28,130 --> 00:22:31,866
this TLS server also includes the proof

344
00:22:31,898 --> 00:22:35,700
of identity. And when I run this again

345
00:22:36,710 --> 00:22:40,594
sorry, I have to build it first of course need

346
00:22:40,632 --> 00:22:44,306
to sign it and then I

347
00:22:44,328 --> 00:22:52,290
can run it's.

348
00:22:52,810 --> 00:22:56,726
And on the client side let me give you a

349
00:22:56,748 --> 00:22:59,820
bit of show you what this looks like.

350
00:23:00,830 --> 00:23:04,714
I'm using OpenSSL here basically showing you

351
00:23:04,752 --> 00:23:08,938
what the TLS certificates that are returned from those

352
00:23:09,104 --> 00:23:10,960
server look like.

353
00:23:13,810 --> 00:23:17,274
So this is the certificate chain that OpenSSL

354
00:23:17,322 --> 00:23:21,054
parsed, basically giving you some

355
00:23:21,092 --> 00:23:24,750
information about certificates. And then there's an extension

356
00:23:24,830 --> 00:23:28,366
and this extension is just binary blob

357
00:23:28,398 --> 00:23:31,634
garbage here, but it

358
00:23:31,672 --> 00:23:34,050
contents the identity proof,

359
00:23:34,870 --> 00:23:38,486
the so called quote of things service. And this can

360
00:23:38,508 --> 00:23:42,630
be verified on the client side to verify the identity of the server.

361
00:23:42,970 --> 00:23:46,294
And of course ego also contains a library for the

362
00:23:46,332 --> 00:23:50,426
client. So on the client side we

363
00:23:50,448 --> 00:23:53,802
now want to, instead of connecting to HTTP server we want to connect

364
00:23:53,856 --> 00:23:57,366
to an steps server. So we set those scheme

365
00:23:57,398 --> 00:24:02,560
to HTTPs and

366
00:24:05,330 --> 00:24:09,034
where we do the connection that's currently the HTTP

367
00:24:09,082 --> 00:24:11,710
get here let's get a client.

368
00:24:20,550 --> 00:24:24,500
And instead of saying HTTP get we say client get.

369
00:24:27,530 --> 00:24:31,842
And now we need some configuration

370
00:24:31,906 --> 00:24:37,350
again and let's go to our documentation

371
00:24:38,510 --> 00:24:42,330
instead of those enclave now we go to the client

372
00:24:44,670 --> 00:24:48,778
and it says create adaptation client. This is those

373
00:24:48,864 --> 00:24:52,026
other side of this API that creates

374
00:24:52,058 --> 00:24:55,534
a TLS config for the client and it

375
00:24:55,572 --> 00:24:59,182
expects a verification function. And this verification function

376
00:24:59,236 --> 00:25:03,094
is there to essentially verify the identity

377
00:25:03,242 --> 00:25:09,602
of the service. So the example is

378
00:25:09,656 --> 00:25:15,862
right here. So let's copy this part going

379
00:25:15,916 --> 00:25:17,320
back into vs code.

380
00:25:20,970 --> 00:25:23,320
I'll just do this here now.

381
00:25:24,410 --> 00:25:28,038
So this was a lot of code, but it's

382
00:25:28,054 --> 00:25:31,926
very simple. So we say we want to create those client

383
00:25:31,958 --> 00:25:35,414
TLS config. We need the eclient module

384
00:25:35,462 --> 00:25:39,260
for this and then

385
00:25:40,770 --> 00:25:44,270
we don't need this anymore. We can just say

386
00:25:44,340 --> 00:25:47,840
client get. So what does those verify report function?

387
00:25:48,290 --> 00:25:51,742
It obtains the attestation report that is

388
00:25:51,796 --> 00:25:55,522
passed during the TLS handshake and now it should verify it.

389
00:25:55,576 --> 00:25:58,994
So you can say what

390
00:25:59,032 --> 00:26:03,314
values do you want to verify from

391
00:26:03,352 --> 00:26:07,170
the server? So how do you want to verify the enclave?

392
00:26:07,250 --> 00:26:11,062
And typically you would basically

393
00:26:11,196 --> 00:26:14,294
say okay, what security version should be smaller than

394
00:26:14,332 --> 00:26:17,878
two, protect id should be

395
00:26:18,044 --> 00:26:21,930
1234. And then we want to have some signer Id.

396
00:26:22,080 --> 00:26:25,146
And signer id is set here and it says you

397
00:26:25,168 --> 00:26:29,114
can obtain a signer Id from an enclave using ego signer id.

398
00:26:29,312 --> 00:26:32,666
So let's go into our enclave json, this is the configuration

399
00:26:32,698 --> 00:26:36,462
of the server enclave. It said product id

400
00:26:36,516 --> 00:26:40,606
should be 1234, security version should

401
00:26:40,628 --> 00:26:44,306
be bigger than two. So let's set it to three. And then we

402
00:26:44,328 --> 00:26:47,810
need the signer id of this enclaves.

403
00:26:48,710 --> 00:26:52,290
So for a second let's stop the server

404
00:26:52,870 --> 00:26:57,802
and say ego

405
00:26:57,966 --> 00:27:01,638
signer id of

406
00:27:01,804 --> 00:27:05,160
server. And here we go.

407
00:27:07,550 --> 00:27:11,306
So we can add things here. So you say

408
00:27:11,408 --> 00:27:17,130
signer Id is hex code

409
00:27:22,430 --> 00:27:43,584
and probably some error string.

410
00:27:43,632 --> 00:27:46,996
Sorry. Okay, and then we can

411
00:27:47,018 --> 00:27:50,776
use the signer Id later on. And of

412
00:27:50,798 --> 00:27:53,450
course we need to verify the error or ignore it.

413
00:27:53,820 --> 00:27:55,210
Ignoring it now.

414
00:27:57,580 --> 00:28:01,288
And this should be it. So we basically say this arcade

415
00:28:01,304 --> 00:28:05,372
should be signed, should contain those values and

416
00:28:05,426 --> 00:28:07,950
that's it. So boot up the server again.

417
00:28:09,920 --> 00:28:14,656
We need to sign it because we changed those values in

418
00:28:14,678 --> 00:28:17,330
the configuration, then we can run it.

419
00:28:18,020 --> 00:28:21,200
And here we can do eg, run client

420
00:28:22,260 --> 00:28:25,472
not sorry, it's just go

421
00:28:25,526 --> 00:28:29,412
run client. And let's say we want to set

422
00:28:29,466 --> 00:28:34,020
a value that worked. So it was verified successfully

423
00:28:35,560 --> 00:28:39,816
and let's get this value and

424
00:28:39,838 --> 00:28:43,528
that's it. So the client verified the identity of

425
00:28:43,534 --> 00:28:47,320
the server, established a secure TLS connection and everything

426
00:28:47,390 --> 00:28:50,724
was end to end. Secure end to end, encrypted. Very cool,

427
00:28:50,862 --> 00:28:54,590
very easy. You find the details as I did

428
00:28:55,280 --> 00:28:58,700
in our docs and in our go package description.

429
00:28:59,360 --> 00:29:02,988
Okay, so this was remote adaptation was

430
00:29:03,154 --> 00:29:06,328
very straightforward. One thing I admins didn't

431
00:29:06,344 --> 00:29:10,016
go into detail yet was bring our map to disk. I had

432
00:29:10,038 --> 00:29:14,080
this in original example. I didn't change anything in

433
00:29:14,230 --> 00:29:18,196
our enclave version. But we have to be a little bit more careful here

434
00:29:18,298 --> 00:29:22,084
because essentially we're storing this in plain text.

435
00:29:22,282 --> 00:29:26,224
And if we do so we of course leak

436
00:29:26,272 --> 00:29:29,784
our state, leak our secrets. So we need some kind of way of

437
00:29:29,902 --> 00:29:33,636
sharing this secrets to persistent

438
00:29:33,668 --> 00:29:36,984
storage. And this in terms of confidential computing is

439
00:29:37,022 --> 00:29:40,612
typically called seedling. So a client sends,

440
00:29:40,676 --> 00:29:44,156
we do the identity proof first, client sends over

441
00:29:44,258 --> 00:29:47,884
the secrets, we now want to encrypted them and

442
00:29:47,922 --> 00:29:52,030
then store them to disk. And encrypting them

443
00:29:52,720 --> 00:29:56,156
is more or less straightforward. The question is if

444
00:29:56,178 --> 00:29:59,808
you want to unencrypt them, unseal them later on. We need to

445
00:29:59,814 --> 00:30:03,564
make sure things is only possible from inside the enclave and only from the enclave

446
00:30:03,612 --> 00:30:07,424
that initially sealed this data or an equivalent

447
00:30:07,472 --> 00:30:11,844
enclave depending on. Basically we need to decide on what identity we

448
00:30:11,962 --> 00:30:14,228
build this sealed data to.

449
00:30:14,394 --> 00:30:17,844
And eagle also handles this for you.

450
00:30:17,962 --> 00:30:21,384
So let's go back into vs code again, see how

451
00:30:21,422 --> 00:30:24,884
this works. Currently we're just storing

452
00:30:24,932 --> 00:30:28,804
them, we just store the data to plain

453
00:30:28,852 --> 00:30:32,072
text to persistent to this file.

454
00:30:32,216 --> 00:30:36,344
So let me go into our documentation of ego APIs.

455
00:30:36,472 --> 00:30:40,540
This time we need the crypto module

456
00:30:40,880 --> 00:30:44,204
and it has two functions, seal with product key, seal with

457
00:30:44,242 --> 00:30:48,176
unique key, basically saying do you want to bind those identity of

458
00:30:48,198 --> 00:30:52,288
your sealed data to this product to this service

459
00:30:52,374 --> 00:30:55,970
in general or do you want to bind it to the one specific

460
00:30:56,280 --> 00:31:00,230
instance of the service? In our case, let's use the product

461
00:31:01,160 --> 00:31:04,896
basically expects the plain text encrypted

462
00:31:04,928 --> 00:31:07,510
with your key and returns the encrypted data.

463
00:31:08,120 --> 00:31:11,828
So going into vs code saving

464
00:31:11,914 --> 00:31:15,220
state here,

465
00:31:15,290 --> 00:31:20,980
this is our plaintext data. So let's say crypto

466
00:31:32,210 --> 00:31:42,930
data with product keyboard.

467
00:31:44,710 --> 00:31:45,860
There we go.

468
00:31:47,770 --> 00:31:54,402
And again this returns out our encrypted

469
00:31:54,466 --> 00:31:58,066
state and some arrow

470
00:31:58,098 --> 00:31:59,560
I'm going to ignore for now.

471
00:32:03,070 --> 00:32:06,746
And then we can store instead of

472
00:32:06,848 --> 00:32:10,060
the bytes directly we store the encrypted state.

473
00:32:11,710 --> 00:32:15,198
And same goes for loading the state.

474
00:32:15,364 --> 00:32:20,394
Again, this is a function unseal that's ccspecific.

475
00:32:20,442 --> 00:32:24,590
So this works for either of those two sharing functions.

476
00:32:25,430 --> 00:32:29,858
So when I load the state before

477
00:32:29,944 --> 00:32:31,300
decoding it,

478
00:32:36,070 --> 00:32:40,386
I need to decrypt it. So decrypt

479
00:32:40,498 --> 00:32:41,160
state.

480
00:32:44,010 --> 00:32:48,310
So let's call it the encrypted state equals

481
00:32:48,890 --> 00:32:51,462
the ecrypto package module.

482
00:32:51,526 --> 00:32:55,894
Need unseal with our binary

483
00:32:55,942 --> 00:32:59,574
blob and this probably returns an error

484
00:32:59,622 --> 00:33:02,140
as well. We want to ignore it for now.

485
00:33:03,730 --> 00:33:06,960
And now instead of the blob I use this decrypted state.

486
00:33:07,730 --> 00:33:11,134
Very cool. One thing I need to mention here

487
00:33:11,172 --> 00:33:14,650
is ego doesn't mount your host

488
00:33:14,730 --> 00:33:17,906
file system by default so that you

489
00:33:17,928 --> 00:33:22,354
don't accidentally leak any data. So when we store this here into

490
00:33:22,392 --> 00:33:26,382
some random file, it will end up in memory and not on a disk.

491
00:33:26,526 --> 00:33:30,230
We can specify mount points in our configuration.

492
00:33:30,810 --> 00:33:33,670
Of course you can see this in our documentation.

493
00:33:34,010 --> 00:33:37,986
So for a configuration file it explains

494
00:33:38,018 --> 00:33:41,562
those mount points. So let's copy this

495
00:33:41,616 --> 00:33:45,254
example here. Mounting a path

496
00:33:45,302 --> 00:33:46,700
in the host file system.

497
00:33:48,590 --> 00:33:53,094
So I'm saying okay I need some mounts and

498
00:33:53,152 --> 00:33:54,430
I want to mount,

499
00:33:58,610 --> 00:34:02,190
I don't know, the server thing, I want to mount it into data,

500
00:34:02,260 --> 00:34:05,258
it should be host of s and it should not be read only,

501
00:34:05,444 --> 00:34:09,442
very simple mount point. And now I can say okay store

502
00:34:09,496 --> 00:34:13,250
this into Datasecretstore.

503
00:34:16,870 --> 00:34:20,866
I probably need to remove the current secret store because it's unencrypted

504
00:34:20,898 --> 00:34:23,080
and it won't decrypt well,

505
00:34:27,130 --> 00:34:31,534
but that's it, right? So we encrypt, we seal

506
00:34:31,602 --> 00:34:35,114
our state before storing it and unseal it here

507
00:34:35,232 --> 00:34:42,346
before loading it again. And I

508
00:34:42,368 --> 00:34:50,582
need to build it again and

509
00:34:50,656 --> 00:34:54,106
sign it with the new mount

510
00:34:54,138 --> 00:34:58,900
points. And now I can do eg run,

511
00:35:03,110 --> 00:35:05,330
let me make this a little bit bigger.

512
00:35:08,010 --> 00:35:11,974
So in the client I can just do the

513
00:35:12,012 --> 00:35:15,526
same thing, I can set a value and we

514
00:35:15,548 --> 00:35:20,546
will see secret store pops up here. So it's

515
00:35:20,578 --> 00:35:25,030
binary data, you have to trust me for now. That's actually encrypted.

516
00:35:25,190 --> 00:35:26,890
I can show you directly.

517
00:35:28,830 --> 00:35:32,154
So let's see if I retrieve it now. It should

518
00:35:32,192 --> 00:35:36,074
return, just go

519
00:35:36,112 --> 00:35:39,726
run. Client gets test those. This was

520
00:35:39,748 --> 00:35:43,114
the wrong one. It retrieves the cv.

521
00:35:43,162 --> 00:35:49,714
Let's restart the server and

522
00:35:49,752 --> 00:35:53,282
then do the same thing and

523
00:35:53,336 --> 00:35:56,526
return. So the state work was persisted,

524
00:35:56,718 --> 00:36:00,290
it's stored in an encrypted file on

525
00:36:00,360 --> 00:36:03,922
the those file system now. So this is how

526
00:36:03,976 --> 00:36:08,386
simple ceiling is with the EG libraries.

527
00:36:08,498 --> 00:36:12,026
So this is all for ego. I hope you had a good hands on experience

528
00:36:12,128 --> 00:36:15,654
to give you a quite good impression

529
00:36:15,702 --> 00:36:19,354
on how eg works. I just want to give you

530
00:36:19,392 --> 00:36:22,886
a very brief, very short vision

531
00:36:22,998 --> 00:36:26,782
of how we can now deploy for example

532
00:36:26,836 --> 00:36:30,202
the server application we just built in cloud in a Kubernetes

533
00:36:30,266 --> 00:36:33,726
cluster and deal with all those ccspecific

534
00:36:33,828 --> 00:36:37,154
tasks that you have there. So think

535
00:36:37,192 --> 00:36:40,258
of our server now as one

536
00:36:40,424 --> 00:36:43,618
service, one instance of a service, one pod in

537
00:36:43,624 --> 00:36:47,054
the language of Kubernetes. And now you want to scale

538
00:36:47,102 --> 00:36:49,766
things up because a lot of clients want to store their key in your key

539
00:36:49,788 --> 00:36:53,254
value store. So you have those in the scheme here you have four

540
00:36:53,292 --> 00:36:57,158
instances. Now we need to basically

541
00:36:57,244 --> 00:37:01,394
sync our state between each other and all those different instances.

542
00:37:01,442 --> 00:37:05,258
They need to attest each other because they don't trust each other from

543
00:37:05,424 --> 00:37:09,130
nothing, right. They need to do a attestation between themselves and

544
00:37:09,200 --> 00:37:12,666
then from the outside you just want to see this as one instance. So you

545
00:37:12,688 --> 00:37:15,974
have a lot of those CC specific tasks.

546
00:37:16,102 --> 00:37:20,334
And we build another tool called marble run. That is,

547
00:37:20,452 --> 00:37:24,158
we call it the control plane of confidential computing. That basically

548
00:37:24,244 --> 00:37:28,066
takes those concepts we just saw from single enclaves to

549
00:37:28,168 --> 00:37:31,922
the context of the whole cluster. So you can have

550
00:37:32,056 --> 00:37:35,746
end to end confidentiality, integrity, verifiability, not only

551
00:37:35,768 --> 00:37:39,170
in a single enclaves, but your whole deployment in the cluster.

552
00:37:39,330 --> 00:37:42,694
And everything is updatable, everything is cloud native. So very

553
00:37:42,732 --> 00:37:47,000
easy. And we don't reinvent the wheel here. Maran works

554
00:37:47,450 --> 00:37:51,794
with the most common service mesh. It's designed to work with kubernetes.

555
00:37:51,842 --> 00:37:55,606
It can also work standalone, but together they form what we imagine

556
00:37:55,638 --> 00:37:58,822
to be the way of dealing with devop tasks

557
00:37:58,886 --> 00:38:02,380
with deployments of confidential microservices in the cloud.

558
00:38:02,930 --> 00:38:06,222
Okay, so conclusions? I hope I got you excited about

559
00:38:06,276 --> 00:38:10,030
confidential computing and how easy it is to build

560
00:38:10,100 --> 00:38:13,578
confidential microservices with ego.

561
00:38:13,754 --> 00:38:17,054
I encourage you to try it out yourself. Go to

562
00:38:17,092 --> 00:38:20,398
ego Dev, check out our docs, we have some samples you can

563
00:38:20,404 --> 00:38:24,400
try out. Same goes for Malvern, on Malvern sh,

564
00:38:24,770 --> 00:38:28,198
they're both open source, you can find them on GitHub if you

565
00:38:28,204 --> 00:38:30,710
like. Leave a star, we would really appreciate it.

566
00:38:30,860 --> 00:38:34,438
And yeah, that's it from my side.

567
00:38:34,524 --> 00:38:38,294
Hope you enjoyed the talk. Thank you very much for joining in and

568
00:38:38,412 --> 00:38:40,740
enjoy the rest of the conference. Thank you.

