1
00:00:23,260 --> 00:00:26,464
Hi everyone. Conf 42

2
00:00:26,662 --> 00:00:29,976
excellent. Ah, what we're going to

3
00:00:29,998 --> 00:00:33,320
talk about today are basically microservices

4
00:00:33,820 --> 00:00:36,890
refactoring the patterns. This is like a very fancy name.

5
00:00:37,260 --> 00:00:41,544
What we are going to do is talk about how to take

6
00:00:41,742 --> 00:00:45,892
ugly prepared, very ugly API

7
00:00:45,956 --> 00:00:49,348
code and refactor it to patterns.

8
00:00:49,364 --> 00:00:52,792
We're going to talk about the patterns themselves also. But why

9
00:00:52,846 --> 00:00:56,656
we're doing that it because we want

10
00:00:56,758 --> 00:01:00,530
cleaner code and easy to maintain. But we'll get to that.

11
00:01:02,100 --> 00:01:05,730
My name is Gil Zilberfeld and

12
00:01:06,360 --> 00:01:10,880
I'm a trainer and a consultant on everything development,

13
00:01:10,960 --> 00:01:14,544
testing, product agile,

14
00:01:14,592 --> 00:01:18,052
whatever needs you have in order to

15
00:01:18,106 --> 00:01:21,796
make software better. I'm the author of two books, everyday unit testing, everyday spring testing.

16
00:01:21,828 --> 00:01:25,336
That's from the Java world. And you can

17
00:01:25,358 --> 00:01:29,290
contact me on these things, Twitter as well.

18
00:01:30,300 --> 00:01:33,996
The backside has all the things that you need to contact me

19
00:01:34,018 --> 00:01:37,740
if you have any questions. I want to start with the goal,

20
00:01:38,160 --> 00:01:42,092
and the goal is always

21
00:01:42,226 --> 00:01:45,184
code that works over and over again. Code that works. Yeah,

22
00:01:45,222 --> 00:01:49,264
we know that we probably want to have code that

23
00:01:49,302 --> 00:01:53,296
works and we

24
00:01:53,318 --> 00:01:56,404
want it to work over and over again, meaning that we're going to go into

25
00:01:56,442 --> 00:01:59,636
that code. And when we go into that code and to

26
00:01:59,658 --> 00:02:02,980
add features, fixed bugs, whatever, we want to continue having

27
00:02:03,050 --> 00:02:07,444
this experience of having

28
00:02:07,562 --> 00:02:11,880
code that works now and after every iteration.

29
00:02:12,540 --> 00:02:16,136
Now what you see is basically the feeling when you

30
00:02:16,158 --> 00:02:19,576
need to go into most code, not just microservice code.

31
00:02:19,758 --> 00:02:23,532
The reason I picked this one is because it's more focused on things

32
00:02:23,586 --> 00:02:27,752
that microservices do. And everybody's writing microservices

33
00:02:27,816 --> 00:02:31,308
these days and we may not

34
00:02:31,394 --> 00:02:34,944
be able to focus on the

35
00:02:34,982 --> 00:02:38,816
time while we're building them, on what we actually want

36
00:02:38,998 --> 00:02:42,530
the code to not just do, but look like.

37
00:02:43,060 --> 00:02:47,364
So as we write more code and add

38
00:02:47,402 --> 00:02:51,632
more features and so on, basically if we don't refactor,

39
00:02:51,776 --> 00:02:55,184
what happens is that we don't want to refactor

40
00:02:55,232 --> 00:02:58,640
again and again and again code gets messy

41
00:02:58,720 --> 00:03:02,330
and basically it becomes like a trap for the next developer that comes in.

42
00:03:03,740 --> 00:03:07,370
That's going to be his or hers problem. So we don't want that.

43
00:03:08,220 --> 00:03:12,696
We want a couple of things that care going to go the

44
00:03:12,718 --> 00:03:14,830
principles that we are interested in.

45
00:03:15,520 --> 00:03:18,972
And the first one, the code,

46
00:03:19,106 --> 00:03:22,156
we want it to be easy to change again. If you are not going to

47
00:03:22,178 --> 00:03:25,010
go into that code again, it doesn't really matter.

48
00:03:25,700 --> 00:03:28,544
But if we care, easy,

49
00:03:28,742 --> 00:03:33,408
less risky. We want the code to basically

50
00:03:33,494 --> 00:03:37,056
go in there, make the changes and go out. So in order to do that,

51
00:03:37,078 --> 00:03:40,528
there are a couple of principles that we're going to talk about and coding

52
00:03:40,544 --> 00:03:43,376
guide us today. One is cohesion.

53
00:03:43,488 --> 00:03:47,124
Cohesion is about having code that

54
00:03:47,162 --> 00:03:50,692
deals with the same things being in the same place, files,

55
00:03:50,756 --> 00:03:54,232
modules, whatever. And second is

56
00:03:54,286 --> 00:03:57,748
the complement of that separation of concerns.

57
00:03:57,844 --> 00:04:01,000
Code that deals with different things need to be separated.

58
00:04:02,780 --> 00:04:06,124
It makes sense to us, but also it makes sense

59
00:04:06,162 --> 00:04:09,340
in terms of maintainability. And that is when we're going to fix something

60
00:04:09,410 --> 00:04:12,796
or touch something, we'd rather focus on that thing

61
00:04:12,818 --> 00:04:15,232
and not all the other things that go with it.

62
00:04:15,366 --> 00:04:18,912
Dependencies, I don't know if you change here,

63
00:04:18,966 --> 00:04:22,284
need to change there, so it makes it easier

64
00:04:22,332 --> 00:04:26,640
to change if there are no dependencies or things are separated.

65
00:04:27,460 --> 00:04:31,220
Second thing, we want it easy to test. We're not going to talk about

66
00:04:31,370 --> 00:04:34,676
much about testing today, but it is kind of a thing that we

67
00:04:34,698 --> 00:04:37,908
want, because if you think about APIs, we're thinking about

68
00:04:37,994 --> 00:04:42,548
raising up servers and we're going to see databases

69
00:04:42,724 --> 00:04:46,516
and Kafka queues. The more setup

70
00:04:46,548 --> 00:04:50,708
that we need to have, the more dependencies that we have in our tests,

71
00:04:50,884 --> 00:04:53,310
that is less likely that we say,

72
00:04:54,960 --> 00:04:57,836
I don't want to do it, I don't want to test. It takes too much

73
00:04:57,858 --> 00:05:02,776
time, too risky. So the more the code doesn't

74
00:05:02,808 --> 00:05:06,480
have too many dependencies, fewer dependencies there are,

75
00:05:06,550 --> 00:05:10,268
it is easier to test. If it's easier to test, chances are we're

76
00:05:10,284 --> 00:05:13,392
going to test it. The second thing is about

77
00:05:13,446 --> 00:05:16,210
loosely coupled interfaces and events. Now,

78
00:05:16,600 --> 00:05:19,796
Javascript typescript, we're going

79
00:05:19,818 --> 00:05:23,764
to show examples today. Events, we know about this,

80
00:05:23,962 --> 00:05:27,520
right? Events basically decouple

81
00:05:27,600 --> 00:05:31,176
the sender of the event. It doesn't care about who gets the event and

82
00:05:31,198 --> 00:05:34,424
what it does with it. And all

83
00:05:34,462 --> 00:05:38,570
the event handler needs to know where it came from. That's it.

84
00:05:39,180 --> 00:05:43,048
So this is like a separation of concerns as well, but it's

85
00:05:43,064 --> 00:05:46,684
also loosely coupled. That means that we can change one without changing the other.

86
00:05:46,722 --> 00:05:50,620
As long as we are keeping the contract.

87
00:05:51,040 --> 00:05:54,408
Interfaces are the same. Basically it's a structure

88
00:05:54,584 --> 00:05:58,496
of the data that we're sending. It's a

89
00:05:58,518 --> 00:06:01,648
contract. As long as we keep that, it doesn't matter what the data is.

90
00:06:01,734 --> 00:06:05,916
We can change code in one place without having impact

91
00:06:05,948 --> 00:06:08,790
on the other. And if it's not like that,

92
00:06:09,800 --> 00:06:13,684
that means that we're again raising the chances of

93
00:06:13,722 --> 00:06:17,236
not going to test. So what are

94
00:06:17,258 --> 00:06:21,876
these things that I mentioned? Cohesion. I rated Wikipedia

95
00:06:22,068 --> 00:06:25,160
the degree to which the elements inside the module belong together.

96
00:06:25,230 --> 00:06:28,648
Like I said, code that deals with something needs to be at

97
00:06:28,654 --> 00:06:31,916
the same place. Same place could be

98
00:06:31,938 --> 00:06:35,484
like a package or something. Think about if

99
00:06:35,522 --> 00:06:39,628
you have code that does things in

100
00:06:39,634 --> 00:06:42,728
the UI and the API and the database layer,

101
00:06:42,824 --> 00:06:46,888
that's not cohesive. Separation of

102
00:06:46,914 --> 00:06:50,384
concerns means that each module addresses separate concerns, a set of

103
00:06:50,422 --> 00:06:53,984
information that affects the code. Like I said, if it deals with

104
00:06:54,022 --> 00:06:57,964
something, it doesn't deal with anything else. Loose coupling

105
00:06:58,012 --> 00:07:01,536
means that each of the component has or makes use of little or no knowledge

106
00:07:01,568 --> 00:07:05,556
of the definition of other separate components. It's not a definition, it is the

107
00:07:05,578 --> 00:07:09,290
implementation. So the interface between

108
00:07:09,660 --> 00:07:13,252
things becomes a contract.

109
00:07:13,396 --> 00:07:17,672
But what happens on either side of this contract doesn't matter.

110
00:07:17,806 --> 00:07:21,328
If we keep it that way, we can change one of the sides

111
00:07:21,364 --> 00:07:25,310
without touching the other. That, like I said, is a good thing.

112
00:07:26,560 --> 00:07:31,244
I'm going to show you today the demo with

113
00:07:31,442 --> 00:07:35,490
a set of tools. It's going to be can XJs application

114
00:07:36,500 --> 00:07:40,732
Mongoose for accessing the database of MongoDB

115
00:07:40,876 --> 00:07:45,072
and Kafka JS for doing

116
00:07:45,126 --> 00:07:48,756
queues. But what I'm going to show you today is

117
00:07:48,778 --> 00:07:52,196
not related to these tools. These are the tools that I

118
00:07:52,218 --> 00:07:55,524
used for this demo. But the principles apply for each

119
00:07:55,562 --> 00:07:58,948
tool that you're going to use. So what we're going

120
00:07:58,954 --> 00:08:01,670
to do, we're going to start with a mess. I prepared some mess,

121
00:08:03,740 --> 00:08:07,576
nice mess, going to separate things,

122
00:08:07,678 --> 00:08:11,080
and we're going to refactor to patterns. We're going to talk about the patterns.

123
00:08:11,760 --> 00:08:15,308
And we're not going to go to the testing today, but I'm going

124
00:08:15,314 --> 00:08:18,796
to discuss the ability to test and how

125
00:08:18,818 --> 00:08:20,110
we're going to do that.

126
00:08:22,000 --> 00:08:25,040
Our API is about scheduling a meeting.

127
00:08:26,660 --> 00:08:30,304
Single API, don't want to go all

128
00:08:30,342 --> 00:08:33,168
out. It's not a full app. The principles are going to be in there in

129
00:08:33,174 --> 00:08:35,360
one single API. It's like magic.

130
00:08:36,520 --> 00:08:40,512
The entities that we have care, basically a calendar which contains

131
00:08:40,576 --> 00:08:44,436
meetings. Meetings have like ids and time and room and stuff like

132
00:08:44,458 --> 00:08:47,540
that. And meetings have invitees.

133
00:08:48,040 --> 00:08:51,460
People we're going to invite, which have emails

134
00:08:51,540 --> 00:08:53,800
and they have invitation status.

135
00:08:54,780 --> 00:08:57,972
Meetings have meeting status and they have two methods,

136
00:08:58,036 --> 00:09:01,980
meetings schedule and invite participants.

137
00:09:02,720 --> 00:09:05,832
The architecture is kind of a layered architecture,

138
00:09:05,896 --> 00:09:09,420
right, that we all know the rest. Controller the API is going to be

139
00:09:09,490 --> 00:09:13,196
next js uprouter the

140
00:09:13,218 --> 00:09:16,640
route to s file meeting logic,

141
00:09:17,300 --> 00:09:21,360
which is mostly what we call the application logic,

142
00:09:22,100 --> 00:09:25,970
which is the most important here. It's not about

143
00:09:26,760 --> 00:09:30,260
the other dependencies and frameworks or databases.

144
00:09:30,600 --> 00:09:35,072
Datax layer. Like I said, mongos. The database

145
00:09:35,216 --> 00:09:39,960
which you're not going to see in live demonstration, is MongodB.

146
00:09:40,620 --> 00:09:45,130
This is the API. It's going to be a post API called

147
00:09:46,540 --> 00:09:51,016
schedule. And this is an

148
00:09:51,038 --> 00:09:54,668
example of the body I'm going to send like emails, which is

149
00:09:54,674 --> 00:09:57,070
an array of things that we're going to.

150
00:09:58,720 --> 00:10:02,076
The list of invitees, really the date and

151
00:10:02,098 --> 00:10:05,508
time, which is a string in the beginning,

152
00:10:05,704 --> 00:10:09,328
a topic of the meeting and the room where we want to go.

153
00:10:09,494 --> 00:10:12,320
It's basically it, what is the problem?

154
00:10:12,390 --> 00:10:14,930
You'll see in a minute. It is a mess.

155
00:10:16,120 --> 00:10:19,808
And the API doesn't

156
00:10:19,904 --> 00:10:23,796
allow testing the state by itself, meaning this is like a

157
00:10:23,818 --> 00:10:28,064
void method. Okay. It's a function that we're calling schedule

158
00:10:28,112 --> 00:10:32,120
meeting. And that means if we want to know if the meeting was scheduled,

159
00:10:33,820 --> 00:10:37,512
then we need either

160
00:10:37,566 --> 00:10:41,464
to go to the database to see it or need another API to look

161
00:10:41,502 --> 00:10:45,016
if the state is changed. Same for the invitees,

162
00:10:45,128 --> 00:10:48,716
their status and so on. And we need

163
00:10:48,738 --> 00:10:52,520
to test everything together. I need to raise everything together, not just the server,

164
00:10:52,600 --> 00:10:56,476
also the database, the patch

165
00:10:56,508 --> 00:10:59,792
Kafka queues to send the events out.

166
00:10:59,926 --> 00:11:03,616
So testing this is like an end to end

167
00:11:03,638 --> 00:11:07,830
test or API test as we know it, full microservice test,

168
00:11:08,360 --> 00:11:11,828
not easy. And if we have enough

169
00:11:11,994 --> 00:11:15,940
platform frameworks, enough methodology,

170
00:11:16,440 --> 00:11:20,550
adding a next test would not be that

171
00:11:21,000 --> 00:11:24,040
expensive. But if it's the first ones,

172
00:11:24,110 --> 00:11:27,544
it's going to be expensive. And like I said, if it's not easy to

173
00:11:27,582 --> 00:11:30,888
test, chances are we're going to drop it. We're not going

174
00:11:30,894 --> 00:11:34,556
to test it now, test it somewhere in the

175
00:11:34,578 --> 00:11:37,870
future. Okay, let's go to the code.

176
00:11:38,960 --> 00:11:43,352
Okay, so you see on the screen, this is like regular

177
00:11:43,416 --> 00:11:46,816
next JS application

178
00:11:46,918 --> 00:11:50,320
out of the box. What I did is

179
00:11:50,470 --> 00:11:54,496
for each web API meetings and

180
00:11:54,518 --> 00:11:57,564
I have schedule 123456 for our steps.

181
00:11:57,612 --> 00:12:00,996
You wouldn't do it like that, but for

182
00:12:01,018 --> 00:12:04,832
today it's going to be enough. We are starting out with three files.

183
00:12:04,896 --> 00:12:09,220
The first one is commons. This is basically enums and interfaces,

184
00:12:09,660 --> 00:12:13,880
the invitation, meeting status and the request which comes

185
00:12:13,950 --> 00:12:17,704
into our system and invite message which goes

186
00:12:17,742 --> 00:12:21,404
out into Kafka. We have the

187
00:12:21,442 --> 00:12:26,604
route, which is our

188
00:12:26,642 --> 00:12:29,020
input into our system, the API.

189
00:12:30,240 --> 00:12:34,380
So we have a post that gets the request, creates a calendar,

190
00:12:35,600 --> 00:12:38,400
gets passes the meeting requests,

191
00:12:38,820 --> 00:12:43,170
validates it. Talk about that. Also that

192
00:12:43,780 --> 00:12:47,636
the request is enough to create a meeting, create a

193
00:12:47,658 --> 00:12:51,284
meeting, calls the invite participants and

194
00:12:51,322 --> 00:12:54,964
returns some kind of either success or

195
00:12:55,002 --> 00:12:58,580
failure message. Our objects basically

196
00:12:58,650 --> 00:13:02,744
have three, we have invitee, which is kind of a data object, but for

197
00:13:02,782 --> 00:13:06,344
now it will be okay. Our calendar, we said that it's going to have

198
00:13:06,382 --> 00:13:11,500
a create meeting, only the route, yes, calls inside

199
00:13:11,570 --> 00:13:15,276
it. We're creating the meeting object, saving it

200
00:13:15,298 --> 00:13:18,876
in our array and calling schedule and

201
00:13:18,898 --> 00:13:24,672
the meeting schedule and meeting logic really is

202
00:13:24,726 --> 00:13:30,316
here where we're scheduling

203
00:13:30,348 --> 00:13:33,968
the meeting. And here we open the database and

204
00:13:34,134 --> 00:13:37,860
save the data there. This is all these things.

205
00:13:37,930 --> 00:13:41,764
Here we have the other method, invite participants, which is

206
00:13:41,802 --> 00:13:44,916
called after that and basically

207
00:13:45,018 --> 00:13:47,700
opens up Kafka JS creates a producer,

208
00:13:49,500 --> 00:13:53,332
changes the state of the invitation

209
00:13:53,396 --> 00:13:56,810
or the invitee, sends the information

210
00:13:57,180 --> 00:14:01,130
and saves the data. That's basically it.

211
00:14:02,640 --> 00:14:05,916
I put on purpose all my objects in one

212
00:14:05,938 --> 00:14:09,900
place to make it a bit more messy. But it's not too messy.

213
00:14:11,280 --> 00:14:13,230
But that's the starting point.

214
00:14:13,920 --> 00:14:17,056
Okay, so the first thing we want to do

215
00:14:17,078 --> 00:14:20,304
is a bit more organizations like, yes, I gave

216
00:14:20,342 --> 00:14:23,648
you separation between the enums and the objects. We want a

217
00:14:23,654 --> 00:14:27,364
bit more. The more organization that we have,

218
00:14:27,402 --> 00:14:31,204
it's easier to move around, move around stuff,

219
00:14:31,402 --> 00:14:33,910
refactor stuff. So it makes sense.

220
00:14:34,920 --> 00:14:37,430
Let's go to our code again.

221
00:14:39,020 --> 00:14:43,050
Okay, so this was like phase one in our phase two,

222
00:14:43,660 --> 00:14:47,050
what we're going to do, and I'm going to use

223
00:14:47,900 --> 00:14:51,544
domain, which comes

224
00:14:51,742 --> 00:14:55,116
from domain driven design. We're going to mention a couple of things

225
00:14:55,138 --> 00:14:58,604
from domain driven design as well. Basically, what are

226
00:14:58,642 --> 00:15:02,476
the domain object. Basically we kind of draw a

227
00:15:02,498 --> 00:15:05,970
boundary around our objects and ask what's inside

228
00:15:06,820 --> 00:15:10,050
and what's outside.

229
00:15:10,500 --> 00:15:14,496
We don't have an outside, but we do have a boundary. So inside we

230
00:15:14,518 --> 00:15:18,272
have our entities, the calendar and the meetings

231
00:15:18,336 --> 00:15:21,508
and so on. And entities in domain driven design

232
00:15:21,594 --> 00:15:24,870
have properties and logic like we've seen,

233
00:15:25,480 --> 00:15:29,328
but on the boundaries they talk with other stuff and other stuff

234
00:15:29,434 --> 00:15:33,144
is databases, stuff like

235
00:15:33,182 --> 00:15:36,488
that, Kafka and so on. It's not part of the application

236
00:15:36,574 --> 00:15:40,296
logic. So we're going to separate those. And the way we're going to

237
00:15:40,318 --> 00:15:44,236
do this created a

238
00:15:44,258 --> 00:15:47,464
data file and the data TS file

239
00:15:47,592 --> 00:15:50,988
has the mongoose stuff which was in

240
00:15:50,994 --> 00:15:55,072
the objects before. So the invitee schema and meeting schema care

241
00:15:55,126 --> 00:15:58,370
here. And also the invite message which goes

242
00:15:59,220 --> 00:16:03,116
into Kafka as well, because it's on the boundary

243
00:16:03,308 --> 00:16:06,320
what we have left. I haven't touched either the common

244
00:16:06,390 --> 00:16:10,352
or the domain is the calendar. The invitee

245
00:16:10,496 --> 00:16:14,532
didn't touch the code of the participants in

246
00:16:14,586 --> 00:16:18,164
the meeting as well. So all this code is here. All I

247
00:16:18,202 --> 00:16:22,868
did is separated the crud mongoose

248
00:16:22,964 --> 00:16:26,728
things and the Kafka is still in there.

249
00:16:26,894 --> 00:16:30,936
We'll deal with that later. We still have these things, the models that

250
00:16:30,958 --> 00:16:34,780
we're going to use. So we talked about coupling and cohesion.

251
00:16:35,120 --> 00:16:39,150
Our code is still coupled to the database. Just move stuff around.

252
00:16:39,680 --> 00:16:43,980
Okay. Didn't do much, but organization helps.

253
00:16:44,400 --> 00:16:48,096
Next thing we're going to talk about is the

254
00:16:48,118 --> 00:16:51,536
idea of ports and adapters, and this comes from like 40 years ago by

255
00:16:51,558 --> 00:16:55,116
Alistair Coburn, one of the people who created

256
00:16:55,148 --> 00:16:59,380
the edge of manifesto and the idea

257
00:16:59,530 --> 00:17:02,996
of creating application logic, and this

258
00:17:03,018 --> 00:17:06,800
also applies to clean code. If you're coming from these areas,

259
00:17:06,880 --> 00:17:10,676
is that we're going to need to separate the logic

260
00:17:10,868 --> 00:17:13,928
application care from all the things that it talks with.

261
00:17:14,014 --> 00:17:17,384
Databases, UI already we

262
00:17:17,422 --> 00:17:20,264
have that Kafka, why is that?

263
00:17:20,462 --> 00:17:24,156
Remember we talked about separation of concerns. So we want to

264
00:17:24,178 --> 00:17:28,076
change one thing without dealing with the impact on the

265
00:17:28,098 --> 00:17:31,512
other. So examples,

266
00:17:31,656 --> 00:17:36,364
if I want to change database from MongoDB

267
00:17:36,412 --> 00:17:39,996
to something else, I now need to go into the meeting

268
00:17:40,028 --> 00:17:44,336
code and because the meeting is coupled to the

269
00:17:44,358 --> 00:17:48,188
Mongoose schema, so I don't want

270
00:17:48,214 --> 00:17:51,604
to have that. The idea is that we're going to keep

271
00:17:51,642 --> 00:17:54,788
the logic clean and we're going to get there

272
00:17:54,954 --> 00:17:58,772
and it's going to talk through interfaces with other stuff.

273
00:17:58,906 --> 00:18:01,512
Now on the left hand you see UI and you think about it,

274
00:18:01,566 --> 00:18:05,252
API is a kind of an interface, the high is an interface.

275
00:18:05,396 --> 00:18:09,208
So the UI can change and

276
00:18:09,294 --> 00:18:13,148
the logic can change. As long as I'm keeping the

277
00:18:13,314 --> 00:18:17,580
contract, the post the same. So that's the idea.

278
00:18:17,730 --> 00:18:21,532
So we're going to push things into our boundary and create

279
00:18:21,586 --> 00:18:25,056
separate objects for them. The first thing

280
00:18:25,078 --> 00:18:28,060
I'm going to do is if you recall and show you that in a minute,

281
00:18:28,140 --> 00:18:32,224
the route ts file not only

282
00:18:32,422 --> 00:18:36,016
got information and talked to

283
00:18:36,038 --> 00:18:39,956
the meeting objects, it also contained logic about

284
00:18:40,058 --> 00:18:43,664
the validation. And another idea from domain

285
00:18:43,712 --> 00:18:49,140
driven design is anticorruption layer. Don't let data creates

286
00:18:49,220 --> 00:18:52,164
invalid entities in your logic.

287
00:18:52,292 --> 00:18:56,344
The reason is that if you create, let's say we

288
00:18:56,382 --> 00:18:59,624
created an invalid meeting, that means

289
00:18:59,662 --> 00:19:02,936
we need to have code for all kinds of cases of invalid meeting.

290
00:19:02,968 --> 00:19:06,364
What to do? If I'm past valid meeting I have to take

291
00:19:06,402 --> 00:19:10,984
care of all kinds of cases and that creates

292
00:19:11,112 --> 00:19:14,924
more complex code. We don't want that.

293
00:19:15,122 --> 00:19:18,736
We want application logic to be as simple as possible. And therefore one of

294
00:19:18,758 --> 00:19:22,032
the ways to do this is through validation in our case,

295
00:19:22,166 --> 00:19:25,890
or anticorruption in the words of domain driven design, don't allow

296
00:19:26,340 --> 00:19:30,116
to create invalid entities. So we have this kind of code,

297
00:19:30,218 --> 00:19:33,750
we just want to put it somewhere else.

298
00:19:34,520 --> 00:19:38,100
What's the validation doing? Basically a meeting is good

299
00:19:38,170 --> 00:19:41,860
if it has a topic, if it at least has one

300
00:19:41,930 --> 00:19:44,230
invitee's and in the future,

301
00:19:44,920 --> 00:19:48,452
in the past it's not a valid meeting. That's a good meeting,

302
00:19:48,596 --> 00:19:52,036
that's what the code does. So let's go back to that

303
00:19:52,078 --> 00:19:55,308
code. So let's look at what

304
00:19:55,314 --> 00:19:58,780
we have right now before we touch it. So basically

305
00:19:58,850 --> 00:20:02,376
this is the code here. We pass the meeting

306
00:20:02,408 --> 00:20:06,300
request, get the information here and this is the validation.

307
00:20:06,380 --> 00:20:10,016
Basically if it's valid we're going. But like I

308
00:20:10,038 --> 00:20:13,516
said, if I want to check this code entire server,

309
00:20:13,708 --> 00:20:17,972
I don't want to. So let's refactor, just move this into

310
00:20:18,026 --> 00:20:21,764
its own class. So we

311
00:20:21,802 --> 00:20:25,636
create an object called meeting validator. And I

312
00:20:25,658 --> 00:20:29,376
just moved things in there. I also renamed

313
00:20:29,408 --> 00:20:32,488
a couple of things to make it more easier, but it's the same code.

314
00:20:32,574 --> 00:20:36,744
So this is a meeting validator. The route now just calls it

315
00:20:36,862 --> 00:20:40,280
now. Note the functionality didn't change, I just moved code

316
00:20:40,350 --> 00:20:43,996
around. But our meeting validator now

317
00:20:44,178 --> 00:20:47,416
this guy is fully unit testable,

318
00:20:47,608 --> 00:20:51,804
doesn't have any dependencies. We can add more stuff to it and more

319
00:20:51,842 --> 00:20:55,104
validations. The route file doesn't need

320
00:20:55,142 --> 00:20:58,800
to change. We separated concerns.

321
00:20:59,220 --> 00:21:03,120
So that's cool and easily testable.

322
00:21:03,460 --> 00:21:06,816
Next thing I want to talk about is repository. So repository, we think about it

323
00:21:06,838 --> 00:21:10,432
as a design pattern. It's not the original design of patterns,

324
00:21:10,496 --> 00:21:13,828
gang of four things, but it comes from domain driven design. And the

325
00:21:13,834 --> 00:21:17,632
idea is that it's like a wrapper for talking to the database,

326
00:21:17,776 --> 00:21:21,156
or mechanism for encapsulating storage, retrieval and search behavior,

327
00:21:21,268 --> 00:21:24,756
which emulates a collection of objects. So basically it's

328
00:21:24,868 --> 00:21:28,308
an orm layer, we call it the data access layer.

329
00:21:28,404 --> 00:21:32,044
And of course mongoose does that

330
00:21:32,242 --> 00:21:36,190
and every object relational mapping tool does that.

331
00:21:37,920 --> 00:21:41,896
But it comes with a quirk. Every Orm

332
00:21:41,928 --> 00:21:45,464
tool comes with a quirk. And the idea is that because it's a general purpose

333
00:21:45,512 --> 00:21:48,544
tool, it doesn't talk our language or

334
00:21:48,582 --> 00:21:52,000
application logic, it doesn't talk about meeting and scheduling and stuff like that.

335
00:21:52,150 --> 00:21:55,856
It talks about schemas and stuff like that. Now you say well what's the

336
00:21:55,878 --> 00:21:58,676
problem with that? There's no real problem with that.

337
00:21:58,858 --> 00:22:02,950
But the more we have languages in our code

338
00:22:03,720 --> 00:22:07,316
it becomes harder to maintain. We don't want that. Cleaner code speaks one

339
00:22:07,338 --> 00:22:10,936
language. And remember what we wanted is our application logic to be

340
00:22:10,958 --> 00:22:15,108
separated from all the rest. So we're going to have some kind of adapter

341
00:22:15,204 --> 00:22:18,276
and a repository is a kind of adapter.

342
00:22:18,468 --> 00:22:20,010
Let's go back to the code.

343
00:22:21,680 --> 00:22:26,136
So we have our data, this is the schema

344
00:22:26,168 --> 00:22:30,620
and stuff like that. And like we see, we saw our domain objects

345
00:22:32,080 --> 00:22:35,728
connect to the database, to the mongoose server in

346
00:22:35,734 --> 00:22:39,980
the code, it's coupled and we have our properties

347
00:22:40,060 --> 00:22:44,428
here which care created and directly into mongoose.

348
00:22:44,524 --> 00:22:48,476
We want to do that through a repository. So let's

349
00:22:48,508 --> 00:22:50,340
do this through a repository.

350
00:22:53,000 --> 00:22:56,870
We'll create a meeting repository and

351
00:22:58,780 --> 00:23:02,248
basically move the code that talks to the

352
00:23:02,254 --> 00:23:07,290
database here. So we moved like these things here and

353
00:23:08,620 --> 00:23:12,036
I created on the meeting repository a method

354
00:23:12,068 --> 00:23:15,964
called a function called admitting which does

355
00:23:16,002 --> 00:23:19,388
all the things against the database that the meeting did before.

356
00:23:19,554 --> 00:23:23,896
But now everything sits here and it speaks

357
00:23:23,928 --> 00:23:27,404
the language of meetings like add meeting and update

358
00:23:27,452 --> 00:23:31,330
meeting. So in our domain object

359
00:23:32,100 --> 00:23:35,596
our meeting code is now shrunk

360
00:23:35,628 --> 00:23:38,630
a bit because it doesn't have all this data.

361
00:23:39,000 --> 00:23:43,044
All it does is have is a repository which it

362
00:23:43,082 --> 00:23:47,044
creates and it speaks with admitting. And now

363
00:23:47,162 --> 00:23:51,684
I have the flexibility of replacing mongoose

364
00:23:51,732 --> 00:23:54,890
with redis, I don't know, whatever.

365
00:23:55,660 --> 00:23:59,108
So this is a repository, the repository

366
00:23:59,204 --> 00:24:02,828
pattern which is kind of adapter which is what we're going to talk about

367
00:24:02,914 --> 00:24:05,340
next. So adapters,

368
00:24:05,920 --> 00:24:10,184
adapters are basically interface

369
00:24:10,232 --> 00:24:14,024
change like you see on the screen here. The definition

370
00:24:14,072 --> 00:24:18,044
is a software design pattern. This comes from an actual design pattern

371
00:24:18,092 --> 00:24:21,712
from the Django four book, a very boring one, a software design

372
00:24:21,766 --> 00:24:25,296
pattern that allows the interface of an existing class to be used as another

373
00:24:25,398 --> 00:24:29,750
interface. We already saw a repository, it's an interface change

374
00:24:30,440 --> 00:24:34,180
that behind it does something other

375
00:24:34,250 --> 00:24:38,336
adapters that you may know proxy has the same interface

376
00:24:38,448 --> 00:24:41,572
but different implementation or facade,

377
00:24:41,716 --> 00:24:45,368
a simpler interface around

378
00:24:45,454 --> 00:24:47,000
something that's very complex.

379
00:24:48,780 --> 00:24:51,928
So we touch the repository. They haven't

380
00:24:51,944 --> 00:24:54,956
touched Kafka js yet, so we're going to do that.

381
00:24:55,138 --> 00:24:59,004
The repository is like database adapter is

382
00:24:59,042 --> 00:25:03,336
like general thing for other stuff. So let's

383
00:25:03,368 --> 00:25:07,296
go to the code again. So look at

384
00:25:07,318 --> 00:25:10,784
the code that we have here. It's basically configuring the

385
00:25:10,822 --> 00:25:14,172
Kafka server, opening the connection,

386
00:25:14,316 --> 00:25:18,384
sort of creating a producer and creating

387
00:25:18,432 --> 00:25:21,616
the messages that we're

388
00:25:21,648 --> 00:25:24,964
going to send. And that's it. Here is

389
00:25:25,002 --> 00:25:28,816
like the repository from before. So all

390
00:25:28,858 --> 00:25:32,376
this needs to go somewhere else. Again it doesn't have any place in the

391
00:25:32,398 --> 00:25:36,308
meeting itself. So we're

392
00:25:36,324 --> 00:25:39,796
going to have a Kafka adapter. The bootstrap server

393
00:25:39,908 --> 00:25:43,416
goes here. If I want to change it somewhere else, take it from somewhere

394
00:25:43,448 --> 00:25:46,796
else. I need to touch the Kafka code, not the

395
00:25:46,818 --> 00:25:50,510
meeting code. It's here basically

396
00:25:50,960 --> 00:25:54,944
we have an invite interface again it's can application

397
00:25:55,062 --> 00:25:58,876
logic language rather than Kafka and invite

398
00:25:58,908 --> 00:26:03,180
message. Now all adapters repositories

399
00:26:03,340 --> 00:26:06,496
can be, I won't say unit tested because

400
00:26:06,518 --> 00:26:09,588
they don't have much code right? They just like do something

401
00:26:09,674 --> 00:26:12,864
can operation but they are easier

402
00:26:12,912 --> 00:26:17,028
to test because now I don't need for testing this the

403
00:26:17,114 --> 00:26:20,456
database of our database. We don't need cockpit, so the

404
00:26:20,478 --> 00:26:23,288
separation helps us. Apart from that,

405
00:26:23,374 --> 00:26:27,530
I moved the invite message here. It was before that

406
00:26:28,380 --> 00:26:32,008
on the boundary stuff because it now belongs to the Kafka

407
00:26:32,024 --> 00:26:34,830
stuff because this is how we send stuff outside.

408
00:26:35,680 --> 00:26:39,420
And our meeting object has

409
00:26:39,490 --> 00:26:43,288
also even more so shrunk.

410
00:26:43,384 --> 00:26:47,170
It just goes over the invitees and

411
00:26:49,300 --> 00:26:53,088
call the invite sender, which is not a Kafka sender by

412
00:26:53,094 --> 00:26:56,820
the way, calls the invite with invite message.

413
00:26:56,890 --> 00:27:00,416
Again, look at the code. It's application language.

414
00:27:00,528 --> 00:27:04,630
It doesn't have any framework language in it much.

415
00:27:05,160 --> 00:27:06,470
So we like that.

416
00:27:09,740 --> 00:27:13,156
Okay, we have one more thing to jump

417
00:27:13,188 --> 00:27:16,650
into, and this is mostly about this.

418
00:27:17,580 --> 00:27:20,708
So we have in the meeting,

419
00:27:20,884 --> 00:27:24,476
it currently creates the repository and the

420
00:27:24,498 --> 00:27:29,580
adapter and we call it coupling. Right. The meeting basically

421
00:27:29,650 --> 00:27:33,016
is coupled to the meeting repository and Kafk adapter because it creates

422
00:27:33,048 --> 00:27:36,610
them and we want to separate that.

423
00:27:38,260 --> 00:27:42,450
It's not possible to do it completely, of course, but it is possible

424
00:27:43,780 --> 00:27:47,920
to put it behind the refactor. And that means

425
00:27:48,070 --> 00:27:51,704
we'll have more flexibility of changing which repository

426
00:27:51,772 --> 00:27:55,156
we're talking with which adapter, and we

427
00:27:55,178 --> 00:27:58,796
can change it to Rabbitmq instead of Kafka,

428
00:27:58,928 --> 00:28:02,616
again without changing the meeting code. So the

429
00:28:02,638 --> 00:28:06,104
solution is usually a factory. Let's go to

430
00:28:06,142 --> 00:28:09,880
the slides. So welcome to the factory.

431
00:28:10,380 --> 00:28:13,924
You all know factory. Factory basically is a pattern,

432
00:28:13,972 --> 00:28:16,110
again from the Django folk book,

433
00:28:17,360 --> 00:28:20,956
a mechanism for encapsulating complex creation logic and abstracting the type

434
00:28:20,978 --> 00:28:24,256
of the objects for the sake of the client. Yeah, but what it

435
00:28:24,278 --> 00:28:27,968
really means is we're separating the creation of

436
00:28:28,054 --> 00:28:31,010
the object, put it somewhere else,

437
00:28:31,380 --> 00:28:34,656
and the usage of the object. So we

438
00:28:34,678 --> 00:28:38,048
think about factories and maybe even singletons. We'll see a couple of examples

439
00:28:38,064 --> 00:28:41,572
of that somebody else creates on their

440
00:28:41,626 --> 00:28:45,236
own time. The object and

441
00:28:45,418 --> 00:28:49,204
the user of this object just gets it out of thin air and just

442
00:28:49,242 --> 00:28:52,504
uses it. Singleton, if I'm already mentioning that,

443
00:28:52,542 --> 00:28:56,056
is a class that allows a single instance of itself to be created, to be

444
00:28:56,078 --> 00:29:00,520
given access to the created instance. Usually we have Singleton

445
00:29:01,580 --> 00:29:07,576
in order to reuse

446
00:29:07,608 --> 00:29:11,180
resources, save resources, not just

447
00:29:11,330 --> 00:29:13,550
pop things up all the times,

448
00:29:14,480 --> 00:29:19,336
concentrate them in one place. And we'll

449
00:29:19,368 --> 00:29:22,988
see a couple of examples because usually think factory comes with a singletone,

450
00:29:23,004 --> 00:29:26,290
it doesn't have to be there. So let's go back to the code.

451
00:29:28,200 --> 00:29:31,796
Okay, so I created a factories file basically,

452
00:29:31,898 --> 00:29:35,956
which creates factories. And I give you three examples of how to

453
00:29:35,978 --> 00:29:40,484
write a factory. What for each, the calendar factory

454
00:29:40,612 --> 00:29:44,570
is what we usually think about as

455
00:29:45,340 --> 00:29:49,272
a factory, right? It has a private instance that we can't access

456
00:29:49,326 --> 00:29:52,728
from the outside and creates the calendar. And this

457
00:29:52,734 --> 00:29:55,772
is like a calendar only factory, it doesn't do anything

458
00:29:55,826 --> 00:29:59,564
else. I can change the calendar from the outside and it only

459
00:29:59,602 --> 00:30:03,228
gives me a calendar, which is useful if I want to

460
00:30:03,234 --> 00:30:05,728
do some kind of validation before that and so on,

461
00:30:05,894 --> 00:30:09,392
and make sure that the creation was correct and so on.

462
00:30:09,526 --> 00:30:11,760
I'd like it to be in a refactor.

463
00:30:12,500 --> 00:30:15,970
But there's another one that you probably know about.

464
00:30:17,720 --> 00:30:20,950
This one, this one is the same as this thing,

465
00:30:21,560 --> 00:30:24,150
but this one,

466
00:30:25,640 --> 00:30:29,728
the meeting repository factory, this one is

467
00:30:29,754 --> 00:30:33,508
actually public. So what's the difference? Here it's

468
00:30:33,524 --> 00:30:37,096
public, here it's private. Well if

469
00:30:37,118 --> 00:30:40,772
it's public I can change that. If I can change that in testing scenarios

470
00:30:40,836 --> 00:30:44,380
I can create a mock repository, put it in or

471
00:30:44,450 --> 00:30:47,944
read from JSON server or JSON file

472
00:30:48,072 --> 00:30:51,416
rather than a full repository that goes into mongols.

473
00:30:51,528 --> 00:30:55,072
So having this kind of pattern, a public one,

474
00:30:55,206 --> 00:30:58,944
allows you to change things on the fly. Is it

475
00:30:58,982 --> 00:31:02,188
risky? Yes, but yeah, Javascript is risky.

476
00:31:02,204 --> 00:31:05,776
Anyway, the final one I have here

477
00:31:05,878 --> 00:31:09,184
as a factory is I move the invite message

478
00:31:09,222 --> 00:31:13,300
and invite sender here. And the invite sender factory

479
00:31:14,440 --> 00:31:18,420
validates the instance before creating one here

480
00:31:18,490 --> 00:31:22,004
it just creates a new Kafka adapter. So this pattern,

481
00:31:22,132 --> 00:31:25,768
unless I set this and it's public from the outside like in a

482
00:31:25,774 --> 00:31:29,204
test, it will create the default

483
00:31:29,252 --> 00:31:32,732
one in our case is the Kafka adapter. Now that we have

484
00:31:32,786 --> 00:31:35,230
this, let's look at our code.

485
00:31:35,920 --> 00:31:39,676
So our meetings, instead of creating it by

486
00:31:39,698 --> 00:31:43,944
themselves, take them from the factories.

487
00:31:43,992 --> 00:31:46,876
And that means that if I'm testing our meetings,

488
00:31:47,068 --> 00:31:51,008
I can set up the factories beforehand and then create a meeting and it

489
00:31:51,014 --> 00:31:54,288
will just swoop in and take what I

490
00:31:54,374 --> 00:31:58,336
injected in. Same goes with our route.

491
00:31:58,368 --> 00:32:01,460
Yes, for the calendar, which currently

492
00:32:01,530 --> 00:32:05,190
is just a calendar, but you can get it from somewhere else.

493
00:32:06,040 --> 00:32:09,396
Obviously I use patterns here. And one thing

494
00:32:09,418 --> 00:32:12,692
I didn't mention until now is like passing things as parameters

495
00:32:12,756 --> 00:32:16,660
or what we call in fancy word dependency injection,

496
00:32:16,820 --> 00:32:19,992
which is also a pattern that we use in order to do that.

497
00:32:20,046 --> 00:32:23,388
But that means somebody up there on the top of the

498
00:32:23,394 --> 00:32:26,572
tree needs to create everything for the little people

499
00:32:26,626 --> 00:32:30,124
down there. Usually it's not something that

500
00:32:30,162 --> 00:32:33,896
we want, a factory or some kind of a

501
00:32:34,018 --> 00:32:37,616
service locator or something

502
00:32:37,638 --> 00:32:40,928
with the get instance is better for that.

503
00:32:41,094 --> 00:32:44,736
Let's go back to the slides and summarize. So what did

504
00:32:44,758 --> 00:32:48,532
we get? We organized the code. We didn't do anything

505
00:32:48,666 --> 00:32:52,484
but basically create wrappers, give them

506
00:32:52,522 --> 00:32:55,972
nice names and move code around. But the code is now

507
00:32:56,026 --> 00:32:59,844
organized better. We know where to put the next

508
00:32:59,882 --> 00:33:03,208
feature in, because we know if it's validation, we're going to

509
00:33:03,214 --> 00:33:06,996
the validation object. If it's replacing the database or adding

510
00:33:07,028 --> 00:33:10,932
some kind of another database, we'll go to the repositories

511
00:33:10,996 --> 00:33:14,156
files. We have a guidance of how to access

512
00:33:14,338 --> 00:33:17,660
external services. With factories and adapters,

513
00:33:19,840 --> 00:33:24,204
we separated code. We're more flexible of either replacing

514
00:33:24,252 --> 00:33:28,816
or enhancing or upgrading stuff without

515
00:33:28,918 --> 00:33:32,700
touching. The most important thing for us, which is the logic

516
00:33:32,780 --> 00:33:36,492
itself, the application, the application rules,

517
00:33:36,636 --> 00:33:40,484
we don't want to touch that because these are the main brains and

518
00:33:40,522 --> 00:33:43,844
main sources of value that we write.

519
00:33:44,042 --> 00:33:47,984
They care more testable, because now not only we have smaller

520
00:33:48,032 --> 00:33:52,852
components, they can be tested separately. Now it's not replacing

521
00:33:52,916 --> 00:33:56,516
like an end to end test, but if we have smaller tests

522
00:33:56,548 --> 00:34:00,516
that give us confidence that these things actually work, we don't

523
00:34:00,548 --> 00:34:04,270
need to test everything around the

524
00:34:04,880 --> 00:34:08,344
big API test. You can have one scenario

525
00:34:08,392 --> 00:34:11,704
with an end to end test, not like ten scenarios of scheduling

526
00:34:11,752 --> 00:34:15,448
stuff. In our case, for example, cases, we have all

527
00:34:15,474 --> 00:34:19,468
the validation stuff that wasn't possible to test without an API

528
00:34:19,564 --> 00:34:23,088
beforehand. Need to create all kinds of meetings and

529
00:34:23,174 --> 00:34:26,384
see what happens and operate the database and so on.

530
00:34:26,582 --> 00:34:29,476
This separation helps us. If it helps us,

531
00:34:29,578 --> 00:34:33,830
that means it's easier to test. If it's easier to test, that means

532
00:34:35,240 --> 00:34:37,750
the bigger the chance that we're actually going to test it.

533
00:34:38,780 --> 00:34:42,040
Finally, maintainability, which kind of pulls everything

534
00:34:42,110 --> 00:34:45,432
inside it here maintainability is kind of weird word.

535
00:34:45,486 --> 00:34:48,712
Everything is maintainable. Everything is testable. Also given

536
00:34:48,766 --> 00:34:52,504
enough time, resources, motivation. But usually the motivation

537
00:34:52,552 --> 00:34:56,472
is external. We need to change that. It becomes

538
00:34:56,536 --> 00:35:01,036
easier and less risky to do so. So to

539
00:35:01,058 --> 00:35:04,496
summarize, know the

540
00:35:04,518 --> 00:35:08,496
patterns, not many of them really. There's a lot of

541
00:35:08,518 --> 00:35:12,130
patterns, but I mentioned like four or five.

542
00:35:13,300 --> 00:35:16,288
I really recommend going into domain derivative design.

543
00:35:16,454 --> 00:35:20,416
If you're writing microservices code, understand the concept and bounded

544
00:35:20,448 --> 00:35:23,956
context and boundaries and stuff of that entities, what goes in,

545
00:35:23,978 --> 00:35:27,732
what goes out, understand the architecture and

546
00:35:27,786 --> 00:35:30,856
the clean architecture thing that we're trying to

547
00:35:30,878 --> 00:35:35,160
achieve. And once you have these kind of guidelines and understanding,

548
00:35:35,660 --> 00:35:39,530
and it becomes easier to move things around.

549
00:35:40,140 --> 00:35:44,076
And most of the things I've done, I've done like

550
00:35:44,178 --> 00:35:47,416
half and half, I use vs.

551
00:35:47,448 --> 00:35:51,470
Code, move to another file if possible.

552
00:35:52,080 --> 00:35:55,932
But a lot of the times it was like manual

553
00:35:55,996 --> 00:35:59,488
typing, so small steps, but we need to

554
00:35:59,494 --> 00:36:03,090
do this in other languages. We have more

555
00:36:05,140 --> 00:36:08,836
stronger tools to

556
00:36:08,858 --> 00:36:12,356
refactor, here we have less. So the

557
00:36:12,378 --> 00:36:15,924
principles still apply. And like

558
00:36:15,962 --> 00:36:19,476
I said, the tools that you use, it doesn't

559
00:36:19,508 --> 00:36:23,108
matter because the patterns are the same and they are repeating.

560
00:36:23,204 --> 00:36:26,776
The principles are the same and eventually what

561
00:36:26,798 --> 00:36:30,760
you want to come to something that is more maintainable.

562
00:36:31,580 --> 00:36:35,050
That's what I wanted to share with you today. If you have any questions,

563
00:36:35,820 --> 00:36:38,984
email them to me at Gila Testingil or

564
00:36:39,022 --> 00:36:42,696
go on Twitter and bother me there or everywhere else.

565
00:36:42,878 --> 00:36:46,048
I'm doing lot of webinars and I'm doing short videos

566
00:36:46,134 --> 00:36:50,224
which you can go to see everything on my YouTube channel. So go

567
00:36:50,262 --> 00:36:53,490
there, watch the videos, subscribe and be happy.

568
00:36:54,500 --> 00:36:58,528
Thank you for watching this and

569
00:36:58,614 --> 00:36:59,550
hope to see you next time.

