1
00:01:44,670 --> 00:01:48,286
Hello everyone, my name is Kufran and I will be talking about the istio

2
00:01:48,318 --> 00:01:52,242
service mesh and we will look into how we can use the istio service

3
00:01:52,296 --> 00:01:56,254
mesh to secure our applications running inside the Kubernetes

4
00:01:56,302 --> 00:02:00,190
clusters. And we will look how we can implement

5
00:02:00,270 --> 00:02:03,922
authentication authorization policies. So let's go ahead and get

6
00:02:03,976 --> 00:02:04,580
started.

7
00:02:07,150 --> 00:02:10,726
So this is the outline of the talk. First we will start with the introduction

8
00:02:10,758 --> 00:02:14,618
to the istio. We will look into the service identities how we can use service

9
00:02:14,704 --> 00:02:18,646
account to convert it into the service identities

10
00:02:18,758 --> 00:02:22,602
that will be used by istio. We will look into the authentication policies

11
00:02:22,666 --> 00:02:26,846
like tls or mtls, and then we will look into the authorization policies that

12
00:02:26,868 --> 00:02:30,510
will let us enforce access rules

13
00:02:31,970 --> 00:02:36,100
within our services. And then finally we will have some q a

14
00:02:37,430 --> 00:02:40,770
so what do you mean by a service

15
00:02:40,840 --> 00:02:44,030
mesh? Service Mes is infrastructure framework

16
00:02:44,110 --> 00:02:46,600
that handles communication between your services.

17
00:02:47,930 --> 00:02:52,130
For example, you want to have some kind of a network policies or retries

18
00:02:52,290 --> 00:02:55,686
or some splitting of the traffic based on

19
00:02:55,708 --> 00:03:00,506
the weightage and the latency. And most

20
00:03:00,528 --> 00:03:04,154
of the times this is implemented as

21
00:03:04,192 --> 00:03:08,646
a network proxies and that intercept the incoming traffic

22
00:03:08,838 --> 00:03:12,494
and they are deployed along with your

23
00:03:12,532 --> 00:03:15,790
application code and this is how

24
00:03:15,860 --> 00:03:19,514
they work. So you will have one container

25
00:03:19,562 --> 00:03:23,406
which contains the sitecar, which we call it as a sidecar proxy,

26
00:03:23,438 --> 00:03:26,740
and another container will be your application port application.

27
00:03:27,670 --> 00:03:30,446
So what does Istio offers?

28
00:03:30,558 --> 00:03:34,366
So istio offers mainly the features.

29
00:03:34,398 --> 00:03:38,146
Istio features can be categorized across three categories.

30
00:03:38,258 --> 00:03:41,526
First is the security. Istio can help us

31
00:03:41,548 --> 00:03:44,966
to implement service to service communication and we

32
00:03:44,988 --> 00:03:49,850
can implement access control within

33
00:03:49,920 --> 00:03:53,434
our services like authentication and authorization tool

34
00:03:53,472 --> 00:03:58,010
rules. With the help of istio we can have complicated routing

35
00:03:58,430 --> 00:04:02,250
routing rules, retry, timeout, circuit breakers, et cetera.

36
00:04:02,410 --> 00:04:07,738
And this is more related to enhancing

37
00:04:07,834 --> 00:04:11,166
the resiliency of your services. It is more

38
00:04:11,188 --> 00:04:14,398
related to routing. And the third part is the observability

39
00:04:14,494 --> 00:04:18,654
with the help of service mesh. It offers rich

40
00:04:18,782 --> 00:04:21,838
metrics and traces of how your traffic is flowing

41
00:04:21,854 --> 00:04:25,542
within your service mesh and which we can use for

42
00:04:25,676 --> 00:04:29,894
benchmarking or debugging the issues or

43
00:04:29,932 --> 00:04:32,950
any latency issues within our service mesh architecture.

44
00:04:33,450 --> 00:04:36,694
So important terminology. So when I say

45
00:04:36,732 --> 00:04:40,682
workload, what I mean is a pod or application deployed within

46
00:04:40,816 --> 00:04:44,266
your kubernetes cluster. And when I

47
00:04:44,288 --> 00:04:47,914
say service it is a microservice or an application that is going

48
00:04:47,952 --> 00:04:51,018
to serve some kind of API

49
00:04:51,114 --> 00:04:54,894
or some feature to end

50
00:04:54,932 --> 00:04:57,120
user or maybe to another service.

51
00:04:58,450 --> 00:05:03,446
So this is how your pod

52
00:05:03,498 --> 00:05:06,946
looks like before we have the istio. So you have two

53
00:05:06,968 --> 00:05:10,514
kind of two parts basically, or maybe

54
00:05:10,552 --> 00:05:14,900
one part inside one part. You have your application logic and

55
00:05:15,290 --> 00:05:18,786
then you have infrastructure logic like routing circuit

56
00:05:18,818 --> 00:05:22,662
breaker code that will be deployed along

57
00:05:22,716 --> 00:05:26,006
with your business logic or that is part of

58
00:05:26,028 --> 00:05:29,654
your application. And same goes with the container

59
00:05:29,702 --> 00:05:33,222
two and these network

60
00:05:33,286 --> 00:05:37,622
policies are part of your business logic without istio.

61
00:05:37,766 --> 00:05:41,520
And what we can do with the istio is we can abstract your

62
00:05:41,890 --> 00:05:46,474
network policies, circuit breaker code and routing

63
00:05:46,522 --> 00:05:49,854
or metrics related code inside

64
00:05:49,892 --> 00:05:53,374
a sidecar proxy. Because istio offers all these

65
00:05:53,412 --> 00:05:57,310
features to you that is built into the istio, we can leverage

66
00:05:57,390 --> 00:06:01,214
the istio. And you can see now we have two containers.

67
00:06:01,262 --> 00:06:04,806
One container which only contains your business logic and another container is

68
00:06:04,828 --> 00:06:08,278
a sidecar container that only contains your

69
00:06:08,444 --> 00:06:11,682
infrastructure logic or your network policies.

70
00:06:11,826 --> 00:06:16,070
And you can see now these two containers can be managed independently

71
00:06:16,490 --> 00:06:20,474
and making a change inside your network policies will

72
00:06:20,512 --> 00:06:24,586
not require to roll out your business logic or your application code and

73
00:06:24,608 --> 00:06:27,946
vice versa. So what the sitecard does,

74
00:06:27,968 --> 00:06:31,694
sitecar is again sitecard is deployed along with your application

75
00:06:31,812 --> 00:06:35,338
part and in general the name of your sidecar

76
00:06:35,354 --> 00:06:38,682
will be istio proxy. And istio proxy doesn't

77
00:06:38,746 --> 00:06:41,902
really modify your incoming request, it is

78
00:06:41,956 --> 00:06:45,774
transparent to the application code. The only thing sidecar proxy

79
00:06:45,822 --> 00:06:49,586
does, it enforces your network policies to the

80
00:06:49,608 --> 00:06:53,422
incoming request. And if these network policies are not satisfied

81
00:06:53,486 --> 00:06:57,094
it will drop the incoming request and your container will not see or

82
00:06:57,132 --> 00:06:59,990
your application will not see that request.

83
00:07:00,330 --> 00:07:03,842
And istio uses the NY proxy

84
00:07:03,906 --> 00:07:07,080
as a sidecar proxy. It is written in C plus plus.

85
00:07:07,610 --> 00:07:10,778
So how we inject the sidecar. So there are

86
00:07:10,944 --> 00:07:14,070
many ways to inject the sidecar proxy in your workloads.

87
00:07:14,150 --> 00:07:18,166
So one way is you deploy container application container

88
00:07:18,198 --> 00:07:22,054
and you also deploy sidecar container that's manual way automatic.

89
00:07:22,102 --> 00:07:26,474
You can enable, you can annotate the namespaces where you want to automatically

90
00:07:26,522 --> 00:07:29,198
inject the sidecar proxies like this.

91
00:07:29,364 --> 00:07:33,154
And your istio control plane will

92
00:07:33,192 --> 00:07:37,026
take care of injecting the sidecar whenever you

93
00:07:37,048 --> 00:07:41,070
deploy a new part. And you can also add the annotations

94
00:07:41,150 --> 00:07:45,134
to your deployment or your deployment

95
00:07:45,182 --> 00:07:48,494
and that will make sure it will automatically

96
00:07:48,542 --> 00:07:51,734
inject the sidecar proxy. So you have different way

97
00:07:51,772 --> 00:07:55,266
or different level of granularity, how you want to inject sitecar

98
00:07:55,298 --> 00:07:59,522
proxy in your application containers and

99
00:07:59,676 --> 00:08:02,986
when there are three part a, part b, part c and as

100
00:08:03,008 --> 00:08:06,886
you can see with each part there is a sidecar container

101
00:08:06,998 --> 00:08:10,494
which is istio proxy deployed. And all the incoming and

102
00:08:10,532 --> 00:08:14,830
outgoing traffic is now being intercepted by the Istio sitecar proxy.

103
00:08:17,970 --> 00:08:22,058
And then it will forward the traffic to your

104
00:08:22,244 --> 00:08:24,420
actual container or your application.

105
00:08:29,830 --> 00:08:33,438
And this is the basic architecture of istio sitecar.

106
00:08:33,534 --> 00:08:37,526
These are the different components of the istio site, car istio and

107
00:08:37,628 --> 00:08:46,726
with the latest version of Istio 1.5 all

108
00:08:46,748 --> 00:08:50,102
these components are consolidated inside the istio control plane.

109
00:08:50,246 --> 00:08:53,370
And for example citadel.

110
00:08:55,950 --> 00:08:59,850
It was a part of control plane which used to

111
00:09:00,000 --> 00:09:03,306
generate the TLS certificate and deploy to or communicate it

112
00:09:03,328 --> 00:09:06,926
to the new parts or cycle proxies. And there was

113
00:09:06,948 --> 00:09:10,494
a mixer which used to take

114
00:09:10,532 --> 00:09:15,126
care of the telemetry related data and there was a gallery

115
00:09:15,178 --> 00:09:18,242
that used to make sure your configurations are correct.

116
00:09:18,376 --> 00:09:22,146
But with the newer version of istio control plane, all these services or all

117
00:09:22,168 --> 00:09:26,070
these components are consolidated inside the istio control plane.

118
00:09:27,610 --> 00:09:31,734
Okay, so let's talk about istio service mesh security.

119
00:09:31,932 --> 00:09:36,082
So when we talk about security, we will specifically look into the authentication

120
00:09:36,146 --> 00:09:39,754
and authorization policies. And when you talk

121
00:09:39,792 --> 00:09:43,574
about authentication and authorization, right? So we have to start from somewhere,

122
00:09:43,622 --> 00:09:47,562
like for example service identities. Before we start

123
00:09:47,616 --> 00:09:51,166
enforcing authentication and authorization policies, we need

124
00:09:51,188 --> 00:09:54,974
to have some kind of identities assigned to

125
00:09:55,012 --> 00:09:57,934
each of our services inside our service mess.

126
00:09:58,132 --> 00:10:02,038
And this will be the starting point. Once we have the established

127
00:10:02,234 --> 00:10:05,986
identities assigned to each of the service, then we can start

128
00:10:06,168 --> 00:10:10,146
implementing authorization and authentication policies. So there

129
00:10:10,168 --> 00:10:14,558
are different ways to implement or assign the identities

130
00:10:14,654 --> 00:10:17,922
to the app services inside your service

131
00:10:17,976 --> 00:10:21,350
mesh. One of the very common ways. Using service account,

132
00:10:21,500 --> 00:10:24,806
you can use the Kubernetes service account and

133
00:10:24,988 --> 00:10:28,778
the service account basically becomes identity for

134
00:10:28,864 --> 00:10:32,186
that application running inside the service account.

135
00:10:32,368 --> 00:10:36,310
You can either use the GCP service account or Aws

136
00:10:36,390 --> 00:10:39,786
im user role. Or if

137
00:10:39,808 --> 00:10:43,434
you are deploying Kubernetes on prem,

138
00:10:43,562 --> 00:10:46,926
you can use user account or some other account that you

139
00:10:46,948 --> 00:10:50,414
have. But in general in most of the cases you will be using

140
00:10:50,452 --> 00:10:52,240
the Kubernetes service account.

141
00:10:54,150 --> 00:10:58,062
So how we convert your identity

142
00:10:58,126 --> 00:11:01,746
or service account into a certificate that

143
00:11:01,768 --> 00:11:04,670
will become identity of your service.

144
00:11:04,840 --> 00:11:08,134
So whenever a new part is deployed or

145
00:11:08,172 --> 00:11:11,602
a new part is created, it will contain a sidecar container,

146
00:11:11,666 --> 00:11:14,774
istio proxy and your application.

147
00:11:14,892 --> 00:11:18,266
Okay, so your istio proxy will create a

148
00:11:18,288 --> 00:11:21,734
public private key pair and it will send the certificate

149
00:11:21,782 --> 00:11:25,402
signing request to the istio control plane. And then control

150
00:11:25,456 --> 00:11:28,854
plane will sign that, create a certificate

151
00:11:28,982 --> 00:11:32,126
scoped within the service account and send it back

152
00:11:32,148 --> 00:11:35,258
to the istio proxy, okay, and control plane

153
00:11:35,274 --> 00:11:38,698
takes care of rotating your SSL certificates

154
00:11:38,794 --> 00:11:42,610
whenever they are about to expire. And control

155
00:11:42,680 --> 00:11:48,082
plane serves your

156
00:11:48,216 --> 00:11:52,270
SSL certificates through the SDS API

157
00:11:52,430 --> 00:11:55,718
and your certificates are stored inside the memory. So if

158
00:11:55,724 --> 00:11:59,506
your container gets deleted, your certificate

159
00:11:59,538 --> 00:12:03,014
gets deleted basically. And this is how the workflow looks like, you create

160
00:12:03,052 --> 00:12:06,742
a new part, your proxy sidecar istio proxy will

161
00:12:06,796 --> 00:12:10,860
create a public private key pair, send it to the control plane. Control plane will

162
00:12:13,870 --> 00:12:17,434
generate a certificate, self signed certificate, and then you can

163
00:12:17,472 --> 00:12:20,894
use that certificate as an identity for

164
00:12:20,932 --> 00:12:24,878
your service. A okay,

165
00:12:25,044 --> 00:12:28,734
so now by now we have some kind of

166
00:12:28,932 --> 00:12:32,554
so now we have enabled

167
00:12:32,602 --> 00:12:36,274
or established the identities for each of the service we are

168
00:12:36,312 --> 00:12:39,710
going to have in our istio service architecture.

169
00:12:39,870 --> 00:12:44,466
And now once we have the identities there, we can now start

170
00:12:44,648 --> 00:12:47,986
implementing the authentication and authorization policies.

171
00:12:48,098 --> 00:12:51,238
So istio provides two types of authentication. One is

172
00:12:51,244 --> 00:12:54,082
the end user authentication, which you can use a JSON web token,

173
00:12:54,146 --> 00:12:58,010
JWT and we are more interested in the service to service

174
00:12:58,080 --> 00:13:02,826
authentication or mtls. And there

175
00:13:02,848 --> 00:13:06,294
are multiple or multiple ways you can implement

176
00:13:06,342 --> 00:13:10,382
the authentication. One is the permissive where your

177
00:13:10,436 --> 00:13:13,918
service mesh or applications or services running

178
00:13:14,084 --> 00:13:17,290
in your Kubernetes workload kubernetes,

179
00:13:17,370 --> 00:13:20,974
they will accept the plain text traffic as

180
00:13:21,012 --> 00:13:24,466
well as the mtls traffic. Okay.

181
00:13:24,648 --> 00:13:28,660
Second is the strict where all the services or services

182
00:13:29,270 --> 00:13:32,994
will only accept the mtls and

183
00:13:33,032 --> 00:13:36,406
third is the disable where we say okay, we don't want any kind out

184
00:13:36,428 --> 00:13:40,278
of the TLS encryption, we just want to go with the plain text communication between

185
00:13:40,364 --> 00:13:43,974
our applications or services. And this is

186
00:13:44,012 --> 00:13:47,382
how your mtls looks like

187
00:13:47,436 --> 00:13:50,874
or mtls how your request flow within your

188
00:13:50,992 --> 00:13:54,186
kubernetes application. So on the left side

189
00:13:54,208 --> 00:13:57,834
we have workload a, in the middle we have workload b, and the right side

190
00:13:57,872 --> 00:14:01,454
we have the workload c and client makes

191
00:14:01,492 --> 00:14:05,070
a request and we can have a different different

192
00:14:05,140 --> 00:14:08,590
policies, authentication policies for each of the workload. For example,

193
00:14:08,660 --> 00:14:11,102
you want to have mtls for workload a,

194
00:14:11,156 --> 00:14:15,806
but workload b can accept plaintext

195
00:14:15,838 --> 00:14:20,526
traffic and also mtls and workload C's only accept

196
00:14:20,558 --> 00:14:24,770
the mtls again. So you can have different policies,

197
00:14:25,290 --> 00:14:27,986
authentication policies for each of your workload.

198
00:14:28,178 --> 00:14:32,226
And yeah, this is how your request flows

199
00:14:32,418 --> 00:14:36,680
within your service mesh and

200
00:14:37,130 --> 00:14:40,714
this is how you can implement the authentication policies. There are

201
00:14:40,752 --> 00:14:43,990
different level of granularity you can implement the authentication.

202
00:14:44,150 --> 00:14:47,626
One way is like you implement the authentication all the

203
00:14:47,648 --> 00:14:52,406
service mesh wide where all the services in

204
00:14:52,448 --> 00:14:55,594
your service mesh has to use the mtls.

205
00:14:55,642 --> 00:14:59,534
And if they don't use anyone try to communicate with your application

206
00:14:59,652 --> 00:15:02,862
and they don't use the mtls, their request will be dropped.

207
00:15:03,006 --> 00:15:06,900
Another way is you want to enable the mtls within

208
00:15:07,270 --> 00:15:10,994
a namespace. So any communication within

209
00:15:11,032 --> 00:15:15,082
that namespace will use the mtls. And anyone try to communicate

210
00:15:15,166 --> 00:15:18,966
to the application inside that namespace they will have to use the

211
00:15:18,988 --> 00:15:22,694
mtls, otherwise their request will be dropped. Third way

212
00:15:22,732 --> 00:15:26,294
is you implement mtls only for

213
00:15:26,332 --> 00:15:29,866
a specific services or specific application. So there are

214
00:15:29,888 --> 00:15:33,254
multiple different level of granularity you can implement.

215
00:15:33,302 --> 00:15:36,646
But in general, we want mtls

216
00:15:36,758 --> 00:15:40,126
enabled within all of our service mesh applications, not just one

217
00:15:40,148 --> 00:15:44,222
namespace. We want it to be enabled for all of

218
00:15:44,276 --> 00:15:48,190
our application inside our service mesh.

219
00:15:49,170 --> 00:15:53,554
Okay, so let's go ahead. I have a dome demo. We can look

220
00:15:53,672 --> 00:15:57,522
how authentication policies looks like or how it works

221
00:15:57,656 --> 00:16:00,980
in real world just with a quick demo.

222
00:16:04,070 --> 00:16:07,026
All right, so let's implement the authentication policies.

223
00:16:07,138 --> 00:16:10,994
And I have two applications deploy.

224
00:16:11,042 --> 00:16:14,162
I will be deploying two applications in two different namespaces.

225
00:16:14,306 --> 00:16:18,006
Okay, so I have an HTTP bin, which is a basic HTTP

226
00:16:18,038 --> 00:16:22,262
server you can ping from, ping it and see it will respond

227
00:16:22,326 --> 00:16:26,838
with this status 100. Okay, so this is the deployment

228
00:16:26,934 --> 00:16:30,186
yaml looks like and we

229
00:16:30,208 --> 00:16:33,834
are deploying it within some specific service account. Okay,

230
00:16:33,952 --> 00:16:37,194
and there is a sleep part that we will be using to make a request

231
00:16:37,242 --> 00:16:40,446
to the HTTP bin application. So there are

232
00:16:40,468 --> 00:16:44,434
two application, one is the slip, one is the HTTP bin, two different services and

233
00:16:44,552 --> 00:16:48,178
we'll try to make a request from slip part to

234
00:16:48,184 --> 00:16:51,794
the HTTP bin pod. And this is

235
00:16:51,832 --> 00:16:55,286
how my authentication policies looks like for

236
00:16:55,308 --> 00:16:59,446
the namespace foo. Okay, so HTTP bin will be

237
00:16:59,468 --> 00:17:02,658
deployed in the namespace foo, where I will deploy the sleep

238
00:17:02,674 --> 00:17:06,706
part in a namespace bar. And foo

239
00:17:06,738 --> 00:17:10,742
namespace will have the mtls or it will have the sidecar proxy

240
00:17:10,806 --> 00:17:14,460
injected. This namespace is the part of your

241
00:17:14,910 --> 00:17:18,906
istio service mess. Okay. And your sleep part is not part of

242
00:17:18,928 --> 00:17:21,802
your istio service mess. It will not have any sidecar containers.

243
00:17:21,866 --> 00:17:22,480
Okay,

244
00:17:25,650 --> 00:17:29,642
so first we will try without implementing the authentication

245
00:17:29,706 --> 00:17:32,878
policies, and then we will see how

246
00:17:32,964 --> 00:17:36,450
the communication works. And then we will implement the authentication policy

247
00:17:36,520 --> 00:17:40,654
and we will see how it behaves or how it automatically drops

248
00:17:40,702 --> 00:17:44,660
your traffic from slippod. Okay, so let's go ahead

249
00:17:45,590 --> 00:17:49,726
and deploy

250
00:17:49,758 --> 00:17:54,118
it. Okay, so I'll just go ahead, create namespace and

251
00:17:54,204 --> 00:17:57,046
just deploy. So I will deploy it.

252
00:17:57,068 --> 00:17:57,640
Okay.

253
00:18:02,750 --> 00:18:06,166
All right, namespace is created.

254
00:18:06,278 --> 00:18:10,306
It's already there and there is no change in the deployment yaml file.

255
00:18:10,438 --> 00:18:14,270
Everything is just up and running. Just check if everything

256
00:18:14,340 --> 00:18:19,774
is up and running. Okay, so you

257
00:18:19,812 --> 00:18:23,538
see HTTP bin has two containers. One is a

258
00:18:23,544 --> 00:18:26,834
sidecar, one is the HTTP bin container and sleep part.

259
00:18:27,032 --> 00:18:30,546
Like this is the sleep part. This one,

260
00:18:30,728 --> 00:18:35,506
it contains only one container. It doesn't have any

261
00:18:35,528 --> 00:18:39,106
sidecar proxies injected. These are two different application deployed

262
00:18:39,138 --> 00:18:43,446
in two different namespaces. Okay, so now let's go ahead and

263
00:18:43,548 --> 00:18:46,966
let's see if we have some authentication policies are deployed or

264
00:18:46,988 --> 00:18:50,314
not. Okay, so we have one

265
00:18:50,352 --> 00:18:54,934
authentication policy which I was talking about. So let's

266
00:18:54,982 --> 00:18:58,326
see how your request will be dropped.

267
00:18:58,358 --> 00:19:02,234
Okay, so we have enabled the strict mtls

268
00:19:02,282 --> 00:19:05,806
in our namespace foo. Anyone tries to communicate to

269
00:19:05,828 --> 00:19:09,582
the namespace foo, it has to do the mtls. And our

270
00:19:09,636 --> 00:19:13,022
service sleep is not running inside a service mesh, it cannot perform

271
00:19:13,076 --> 00:19:17,358
the mtls and it will automatically reject. Our incoming

272
00:19:17,374 --> 00:19:21,342
request will be rejected by the HTTP bin or the sidecar proxy

273
00:19:21,486 --> 00:19:24,626
running along with the HTTP bin. Okay, so let's give

274
00:19:24,648 --> 00:19:25,460
it a try.

275
00:19:33,830 --> 00:19:38,934
Let me do the asset inside the slip

276
00:19:38,982 --> 00:19:39,580
part.

277
00:19:47,230 --> 00:19:51,334
I'm inside the slip part and I try to access the HTTP

278
00:19:51,382 --> 00:19:55,370
bin where it only allows the empty list graphic.

279
00:19:55,730 --> 00:19:59,434
You see connection reset. So this connection is reset

280
00:19:59,482 --> 00:20:03,118
by the sidecar proxy running across

281
00:20:03,204 --> 00:20:07,582
with your HTTP bin container because we have strict authorized authentication

282
00:20:07,646 --> 00:20:11,342
policies which says no communication

283
00:20:11,406 --> 00:20:13,954
is allowed without the mtls. Okay,

284
00:20:14,152 --> 00:20:16,100
and let's go ahead,

285
00:20:17,030 --> 00:20:20,706
open a new terminal and delete the authentication policy which

286
00:20:20,728 --> 00:20:24,434
we deployed and we will see how

287
00:20:24,552 --> 00:20:31,930
it behaves. Okay, so it's

288
00:21:17,770 --> 00:21:21,238
all right, so we deleted the

289
00:21:21,244 --> 00:21:24,762
authentication policies. Now as we see,

290
00:21:24,816 --> 00:21:27,946
we have deleted the authentication policies. By default it

291
00:21:27,968 --> 00:21:31,980
will allow any kind of a traffic. So now

292
00:21:32,590 --> 00:21:36,166
what is expected is namespace foo

293
00:21:36,358 --> 00:21:40,186
should allow the traffic coming from mtls or non

294
00:21:40,218 --> 00:21:44,186
mtls. Okay, so let's go back again to our slip pod

295
00:21:44,218 --> 00:21:47,406
and let's do the call again. And as you can

296
00:21:47,428 --> 00:21:51,010
see, we are able to communicate

297
00:21:52,710 --> 00:21:56,306
to the HTTP service which is inside the service mess.

298
00:21:56,408 --> 00:22:00,098
And slip pod is not a part of service mesh. Okay, so this

299
00:22:00,104 --> 00:22:03,298
is how this authentication policies

300
00:22:03,474 --> 00:22:07,446
policies are deployed. You can either use namespace wide or

301
00:22:07,468 --> 00:22:11,154
you can just enable it within all of your services workloads.

302
00:22:11,202 --> 00:22:14,582
And you can have different kind of modes you want to enforce.

303
00:22:14,646 --> 00:22:17,740
Okay, so let's go back to the presentation again.

304
00:22:22,990 --> 00:22:26,350
So now we have implemented,

305
00:22:26,850 --> 00:22:30,334
or implemented the secure communication within

306
00:22:30,452 --> 00:22:33,662
our services running inside

307
00:22:33,716 --> 00:22:37,626
the Kubernetes. Okay, we have enabled the TLS or MTLS

308
00:22:37,658 --> 00:22:41,634
encryption. All the communication within our services are

309
00:22:41,832 --> 00:22:45,554
securing. Okay, now whenever you are running

310
00:22:45,592 --> 00:22:49,314
some services inside your cluster, you may

311
00:22:49,352 --> 00:22:52,550
want to expose these services to the Internet or

312
00:22:52,620 --> 00:22:56,200
some private endpoints, right? So this is where this

313
00:22:56,890 --> 00:23:00,086
gateway comes into the picture. And this is

314
00:23:00,108 --> 00:23:03,706
to ingress gateway is kind

315
00:23:03,728 --> 00:23:06,938
of entry point that services as an

316
00:23:06,944 --> 00:23:10,182
entry point to any incoming traffic.

317
00:23:10,246 --> 00:23:13,990
All the incoming traffic goes to the ingress gateway,

318
00:23:14,070 --> 00:23:18,620
and from that ingress gateway it gets forwarded to the downstream services

319
00:23:19,070 --> 00:23:22,894
and ingress you can have different kind

320
00:23:22,932 --> 00:23:26,954
of ingress does the TLS

321
00:23:27,002 --> 00:23:30,914
encryption or TLS termination. You can say

322
00:23:31,032 --> 00:23:36,900
you can have a different kind of different

323
00:23:38,070 --> 00:23:42,710
rules, how you want to route the traffic, how you want to manage

324
00:23:42,780 --> 00:23:47,238
the incoming request, and it

325
00:23:47,244 --> 00:23:51,000
is just a reverse proxy running along with your

326
00:23:51,930 --> 00:23:55,146
ingress parts, and it will enforce all the rules that

327
00:23:55,168 --> 00:23:59,062
you want to implement or implement the routing.

328
00:23:59,206 --> 00:24:02,826
So there are different ways you

329
00:24:02,848 --> 00:24:07,070
can do the or you can manage the incoming traffic and

330
00:24:07,140 --> 00:24:10,446
how you want to do the TLS part of it. So there are

331
00:24:10,468 --> 00:24:15,166
three ways, pass through, simple and mutual, and there

332
00:24:15,188 --> 00:24:19,426
are other more policies you can implement. But what pass through does

333
00:24:19,528 --> 00:24:22,210
is whenever client making a request,

334
00:24:23,110 --> 00:24:26,786
both the client and the application part has to

335
00:24:26,808 --> 00:24:30,534
do the mtls pass through does not

336
00:24:30,572 --> 00:24:34,962
terminate your SSL certificate on the ingress gateway,

337
00:24:35,106 --> 00:24:38,822
but it passes as is to your application

338
00:24:38,956 --> 00:24:42,358
part. And then your application part will actually

339
00:24:42,444 --> 00:24:45,754
do the mtls with the client. And this is how it

340
00:24:45,792 --> 00:24:49,500
works. It's more complicated one, there are more simple

341
00:24:50,190 --> 00:24:53,594
another policy simple, which means you want to do the

342
00:24:53,632 --> 00:24:57,066
server side TLS. When I say server side Tls,

343
00:24:57,098 --> 00:25:00,590
it is just your client doesn't really need to

344
00:25:00,740 --> 00:25:04,094
provide a certificate, you will

345
00:25:04,132 --> 00:25:08,498
just create an ingress gateway, you will pass your service

346
00:25:08,584 --> 00:25:12,386
or SSL certificate to the ingress gateway, and whenever client try to

347
00:25:12,408 --> 00:25:15,934
communicate to your server, your client

348
00:25:15,982 --> 00:25:19,710
will just validate the SSL certificate of your services

349
00:25:19,790 --> 00:25:23,602
and you can continue and your TLS gets terminated.

350
00:25:23,746 --> 00:25:26,866
Your TLS termination happens on the ingress gateway,

351
00:25:26,978 --> 00:25:30,840
okay. And there are mutual the third policy where

352
00:25:31,290 --> 00:25:35,382
client and the server client or the ingress gateway,

353
00:25:35,526 --> 00:25:39,162
both this component will perform two way mtls and your

354
00:25:39,216 --> 00:25:42,662
TLS termination will happen on the ingress gateway.

355
00:25:42,726 --> 00:25:47,722
Okay, so only pass through does only

356
00:25:47,776 --> 00:25:51,082
in in case of, only, only in case of pass through. Your TLS

357
00:25:51,146 --> 00:25:54,574
termination doesn't happen on the ingress gateway. In other

358
00:25:54,612 --> 00:25:58,914
two policies, your TLS termination happens on the ingress gateway and

359
00:25:58,952 --> 00:26:02,734
this is how you can define your ingress gateway.

360
00:26:02,862 --> 00:26:05,922
And we will go ahead and I will show you the demo.

361
00:26:06,056 --> 00:26:06,740
Okay.

362
00:26:10,570 --> 00:26:14,358
All right, so before I talk about or

363
00:26:14,444 --> 00:26:18,146
show you the ingress, I have the control plane, istio control plane

364
00:26:18,178 --> 00:26:21,734
deployed, and I specifically want to

365
00:26:21,772 --> 00:26:22,840
talk about,

366
00:26:27,950 --> 00:26:28,700
okay,

367
00:26:33,310 --> 00:26:38,366
this one, okay, so I have a different there

368
00:26:38,388 --> 00:26:41,242
is one ingress gateway, there is one egress gateway,

369
00:26:41,386 --> 00:26:44,750
and whenever you deploy control plane

370
00:26:45,170 --> 00:26:48,638
you will deploy one ingress gateway that will

371
00:26:48,724 --> 00:26:53,310
give you some public or private IP address or DNS

372
00:26:53,390 --> 00:26:57,154
address, and that way you will use, or your client will

373
00:26:57,192 --> 00:27:01,046
use whenever they want to communication or want to access any of

374
00:27:01,068 --> 00:27:04,722
the services within your cluster through this ingress gateway.

375
00:27:04,786 --> 00:27:08,006
Okay? And there

376
00:27:08,028 --> 00:27:11,590
are more configurations you can specify how you want to like

377
00:27:11,660 --> 00:27:15,226
memory, HPA availability, and all we

378
00:27:15,248 --> 00:27:18,634
will not go into it. This is the name

379
00:27:18,672 --> 00:27:21,910
of your ingress gateway that we will use inside our ingress.

380
00:27:21,990 --> 00:27:26,000
Okay, so let's go ahead and

381
00:27:26,770 --> 00:27:31,002
see. I have created the certificates,

382
00:27:31,146 --> 00:27:35,086
one for client, one for the NgInx part, and this is

383
00:27:35,108 --> 00:27:39,034
what our deployment looks like. I will just deploy NgINX

384
00:27:39,082 --> 00:27:42,722
pod that will contain the SSL certificate for

385
00:27:42,776 --> 00:27:49,794
the application or the NgINX server. And there

386
00:27:49,832 --> 00:27:54,278
is mtls. I enable the MTS bar within

387
00:27:54,364 --> 00:27:57,826
our namespace ingress. This is where our NgINX

388
00:27:57,858 --> 00:28:01,922
server is deployed. And this is the NgInx config

389
00:28:01,986 --> 00:28:05,894
where we are mounting the assets. Like this is mounted as a config

390
00:28:05,942 --> 00:28:09,946
map and passed to the pod running. And this

391
00:28:09,968 --> 00:28:13,258
is what our ingress gateway looks like.

392
00:28:13,424 --> 00:28:16,758
So we are using the default ingress gateway that I

393
00:28:16,784 --> 00:28:20,030
just shown you just some time back,

394
00:28:20,100 --> 00:28:23,614
which is, it will give you some IP address or public

395
00:28:23,652 --> 00:28:27,706
private IP address. And this gateway, ingress gateway

396
00:28:27,738 --> 00:28:31,140
will accept the traffic only on port four four three,

397
00:28:31,510 --> 00:28:34,882
we are doing, in this example, we are doing the pass

398
00:28:34,936 --> 00:28:38,882
through the mode, TLS termination mode is passed through, which means

399
00:28:39,016 --> 00:28:44,326
it will do the mtLs, okay, but the

400
00:28:44,348 --> 00:28:48,194
TLS like client will do its TLS, and TLS termination

401
00:28:48,242 --> 00:28:51,622
will not happen on the gateway, but it will happen on the application part.

402
00:28:51,676 --> 00:28:55,574
Like for example the NgInx part, it will take care of the TLS termination

403
00:28:55,622 --> 00:28:59,450
part. You can have more configuration like

404
00:28:59,520 --> 00:29:03,270
which kind of a minimum version you want to enforce,

405
00:29:03,430 --> 00:29:07,206
or some cipher suit and

406
00:29:07,328 --> 00:29:11,306
hostname. Okay, so incoming request should come from this hostname.

407
00:29:11,338 --> 00:29:14,494
For example, you can add more host. So this is kind of

408
00:29:14,532 --> 00:29:18,010
a very critical part of your ingress gateway.

409
00:29:18,090 --> 00:29:23,374
You want to make sure you kind of specify

410
00:29:23,502 --> 00:29:27,106
or block anything else. We only enabling the traffic on

411
00:29:27,128 --> 00:29:30,354
port four four three, we are doing TLS termination. We have some

412
00:29:30,392 --> 00:29:34,178
specific cipher suit. So this is where you have to be very careful

413
00:29:34,274 --> 00:29:38,342
or be very strict what you accept or

414
00:29:38,396 --> 00:29:41,906
what you don't accept. In this example, we are only accepting

415
00:29:41,938 --> 00:29:45,798
the traffic on four four three. Anything else is not allowed,

416
00:29:45,974 --> 00:29:50,140
or any hostname which does not match with this one, it will not be

417
00:29:50,510 --> 00:29:54,214
allowed. It will just drop the request on the ingress gateway

418
00:29:54,262 --> 00:29:58,026
itself. And then we are routing the incoming request,

419
00:29:58,058 --> 00:30:01,786
we are checking the SNI host and we are routing

420
00:30:01,818 --> 00:30:05,726
it to the application running inside our

421
00:30:05,828 --> 00:30:09,518
ingress namespace here. And it is listening

422
00:30:09,534 --> 00:30:13,586
on port four four three. So any incoming request will be routed to the

423
00:30:13,768 --> 00:30:17,700
NgInX part. Okay, so let me go ahead.

424
00:30:30,010 --> 00:30:33,098
So I have already deployed all of

425
00:30:33,104 --> 00:30:36,714
these things already configured. And if

426
00:30:36,752 --> 00:30:40,860
I go ahead and make a request here.

427
00:30:42,270 --> 00:30:45,866
And this is my hostname, I am setting the hostname incoming

428
00:30:45,898 --> 00:30:48,974
request. This is the port number, this is the

429
00:30:49,012 --> 00:30:52,750
public IP address of my Kubernetes cluster and

430
00:30:52,820 --> 00:30:56,334
client is passing the client certificate and

431
00:30:56,452 --> 00:31:00,014
we have the NgINX server which has its own certificates

432
00:31:00,062 --> 00:31:04,146
and both the component will

433
00:31:04,168 --> 00:31:07,666
do the mtls. So let me go ahead and you can see we

434
00:31:07,688 --> 00:31:12,150
are able to access the NgInX part and if I modify it

435
00:31:12,300 --> 00:31:14,310
and I use the port 80,

436
00:31:18,410 --> 00:31:21,430
it should not interpange this request.

437
00:31:25,950 --> 00:31:32,266
Okay, so you see your

438
00:31:32,288 --> 00:31:34,870
request is terminated with some SSL error.

439
00:31:35,030 --> 00:31:38,220
Similarly, if your hostname does not match,

440
00:31:38,990 --> 00:31:42,234
okay, for example, you just making a request

441
00:31:42,282 --> 00:31:46,030
from some another domain or hostname,

442
00:31:46,370 --> 00:31:49,566
it should automatically reject the request because in

443
00:31:49,588 --> 00:31:53,922
our gateway config we only accepting the traffic from

444
00:31:53,976 --> 00:31:57,682
this hostname. Okay, so this is where you

445
00:31:57,736 --> 00:32:01,686
configure or protect your incoming request, or this

446
00:32:01,708 --> 00:32:06,374
is your entry point and this is how you protect your ingress through

447
00:32:06,492 --> 00:32:10,082
any other issues. Or you can implement the termination

448
00:32:10,146 --> 00:32:13,400
policies and. All right, let's go back.

449
00:32:13,950 --> 00:32:19,194
Okay, so far

450
00:32:19,232 --> 00:32:23,610
we have seen how we can implement the protect

451
00:32:23,680 --> 00:32:28,110
the traffic within our cluster, how to securely

452
00:32:29,330 --> 00:32:33,182
expose our application to the outside world. And the third part

453
00:32:33,236 --> 00:32:37,582
is we want to how by

454
00:32:37,636 --> 00:32:41,410
now any other application can try to access any other

455
00:32:41,480 --> 00:32:44,994
application, right? So for example, can service a can send

456
00:32:45,032 --> 00:32:48,990
request to service b? Yes, because we don't have any authorization

457
00:32:49,070 --> 00:32:52,694
policies implemented yet. So we want to

458
00:32:52,892 --> 00:32:56,690
make sure only required resources

459
00:32:56,770 --> 00:33:00,114
are allowed to access. Right. For example database,

460
00:33:00,162 --> 00:33:03,174
it can be accessed by back end, not the front end. Right.

461
00:33:03,212 --> 00:33:07,226
So we want to implement or restrict the access to your services,

462
00:33:07,328 --> 00:33:10,954
right. Or we want to protect our services from any other

463
00:33:10,992 --> 00:33:13,178
services running inside our service mass.

464
00:33:13,344 --> 00:33:16,734
And there are different ways you can

465
00:33:16,772 --> 00:33:20,670
define the authorization policies where you can allow access

466
00:33:20,740 --> 00:33:24,106
or deny access to some applications or resources,

467
00:33:24,298 --> 00:33:27,974
and these requests are validated

468
00:33:28,042 --> 00:33:31,858
at the runtime by the istio sidecar proxy. And if

469
00:33:31,944 --> 00:33:34,690
authorization policies are not satisfied,

470
00:33:35,190 --> 00:33:38,450
your request will be automatically dropped. Okay. For example,

471
00:33:38,520 --> 00:33:41,154
service a try to access the service b.

472
00:33:41,272 --> 00:33:44,790
And authorization policies say service b cannot be accessed by

473
00:33:44,860 --> 00:33:47,670
any other service other than service c. Right?

474
00:33:47,820 --> 00:33:51,526
So the request will be dropped. If service request is

475
00:33:51,548 --> 00:33:54,442
coming from service a, it will be dropped by service b.

476
00:33:54,576 --> 00:33:57,946
Okay, and in general, what you want to do

477
00:33:57,968 --> 00:34:01,386
is you want to start your application or you

478
00:34:01,408 --> 00:34:05,142
want to deploy your application, you want to set the authorizing

479
00:34:05,206 --> 00:34:09,134
policies to deny all that means your

480
00:34:09,172 --> 00:34:12,480
application cannot be accessed by any other application.

481
00:34:12,850 --> 00:34:16,750
And then you want to slowly open your application to other services

482
00:34:16,900 --> 00:34:20,838
or your service to other services, right? For example, you deploy

483
00:34:20,874 --> 00:34:24,066
database, you block all the access and then

484
00:34:24,088 --> 00:34:28,178
you slowly open your application to

485
00:34:28,264 --> 00:34:30,850
another application. Like back end application. Right.

486
00:34:31,000 --> 00:34:34,518
So this is how you can kind of go ahead when you're implementing the

487
00:34:34,524 --> 00:34:37,970
authorization policy by default, deny all and then slowly

488
00:34:38,050 --> 00:34:41,990
open it for other applications. Okay, so this is how

489
00:34:42,140 --> 00:34:45,814
workflow looks like. Workload A, it has its own authorization policies.

490
00:34:45,862 --> 00:34:49,174
Workload B, it will have its own authorization policies.

491
00:34:49,302 --> 00:34:52,838
Whenever workload a, try to access the workload B authorization

492
00:34:52,934 --> 00:34:56,438
policies has to be met.

493
00:34:56,624 --> 00:35:00,378
If it doesn't match, sitecar proxy will terminate

494
00:35:00,394 --> 00:35:04,634
your request. Okay. And these are validated

495
00:35:04,682 --> 00:35:08,858
at the runtime. And your control plane kind of pushes all of your authorization

496
00:35:08,954 --> 00:35:12,786
policies as you make changes there. And this is

497
00:35:12,808 --> 00:35:16,258
what authorization policy look like. I will just show the demo instead.

498
00:35:16,424 --> 00:35:19,860
Let's go back. This is the third and last demo.

499
00:35:21,350 --> 00:35:22,100
Okay,

500
00:35:28,630 --> 00:35:32,326
it, all right. Okay, so I

501
00:35:32,348 --> 00:35:35,670
am deploying three application. One is the sous,

502
00:35:36,170 --> 00:35:40,298
okay. One is the inventory and

503
00:35:40,384 --> 00:35:43,580
one is the users. Okay, let me go ahead

504
00:35:46,850 --> 00:35:49,914
and we will just deploy this application in the same namespace

505
00:35:49,962 --> 00:35:54,282
for the simplicity. But whatever I say here is applicable

506
00:35:54,346 --> 00:35:58,094
to all of other, or if applications are deployed in

507
00:35:58,132 --> 00:36:01,700
another namespaces as well. I will explain what I mean when I say this.

508
00:36:02,710 --> 00:36:06,686
Okay, so we have three applications running inventory

509
00:36:06,798 --> 00:36:10,066
Sus user, three different applications. Each application has

510
00:36:10,088 --> 00:36:11,830
the sidecar proxies injected.

511
00:36:16,330 --> 00:36:20,770
This is the authorization policies. Let's look at the authorization

512
00:36:20,850 --> 00:36:24,166
policies. So we are deploying

513
00:36:24,198 --> 00:36:28,246
this authorization policy inside the namespace auth where our parts

514
00:36:28,278 --> 00:36:31,706
are running. These policies are applied to

515
00:36:31,728 --> 00:36:35,900
the SUS application. And what we say is

516
00:36:37,070 --> 00:36:40,974
application sus can only be accessed by

517
00:36:41,172 --> 00:36:45,182
a namespace auth which is running inside

518
00:36:45,236 --> 00:36:49,026
a service account, inventory sa. Okay,

519
00:36:49,208 --> 00:36:53,780
so we are restricting right now only

520
00:36:54,710 --> 00:36:58,306
application running inside a namespace Auth. And it

521
00:36:58,328 --> 00:37:01,720
is running inside a services name, service account name sa,

522
00:37:03,450 --> 00:37:06,742
inventory sa. Then it will allow

523
00:37:06,796 --> 00:37:09,606
the get request. See application,

524
00:37:09,788 --> 00:37:13,226
this running inside this service account can make a get request to the

525
00:37:13,248 --> 00:37:17,302
sous part. Okay. And we have users

526
00:37:17,446 --> 00:37:21,114
authorization policies. And when I don't specify any

527
00:37:21,152 --> 00:37:24,438
rules by default, any request

528
00:37:24,534 --> 00:37:28,030
made to the user application will be dropped.

529
00:37:28,450 --> 00:37:32,222
You cannot access the user's application. Nobody can access

530
00:37:32,276 --> 00:37:35,454
it because there are no rules by default. It will just

531
00:37:35,492 --> 00:37:38,740
deny all. Okay, all right,

532
00:37:39,510 --> 00:37:43,906
now let me go back and see if there

533
00:37:43,928 --> 00:37:45,860
is authorization policy. Okay,

534
00:37:49,030 --> 00:37:52,418
so it's already deployed. Okay, I have already deployed

535
00:37:52,514 --> 00:37:56,438
beforehand. We have suse writer authorization policy,

536
00:37:56,524 --> 00:38:00,210
which I explained, and there is one user's authorization

537
00:38:00,290 --> 00:38:04,074
policies. Okay, and let's go

538
00:38:04,112 --> 00:38:08,586
ahead and go

539
00:38:08,608 --> 00:38:11,786
to the inventory part. And from the inventory part, what we

540
00:38:11,808 --> 00:38:15,398
will do is like, we will try to access both of

541
00:38:15,424 --> 00:38:19,040
these applications. Okay, go to the inventory part.

542
00:38:20,130 --> 00:38:22,350
Try to access the users.

543
00:38:23,250 --> 00:38:26,990
Again, we have allowed.

544
00:38:29,830 --> 00:38:33,502
Allowed. We have the allowed

545
00:38:33,566 --> 00:38:35,940
access from user application.

546
00:38:36,870 --> 00:38:40,500
From inventory application to the user application. So it should work.

547
00:38:45,670 --> 00:38:49,510
It. Oh, sorry. So user is not accessible by anyone.

548
00:38:49,580 --> 00:38:52,114
So it should be denied by default.

549
00:38:52,162 --> 00:38:55,894
Inventory cannot access the users. Right? But we have deployed the policies

550
00:38:55,942 --> 00:38:59,334
which says SUS can be accessed by the inventory.

551
00:38:59,382 --> 00:39:03,340
Okay, let me go ahead. You see, it is able to

552
00:39:03,710 --> 00:39:07,614
access the SUS service or

553
00:39:07,652 --> 00:39:11,214
SUS application. Okay. And if I try to make a post

554
00:39:11,252 --> 00:39:14,110
request, it should denied, right?

555
00:39:14,180 --> 00:39:17,802
You see, it's saying forbidden, right?

556
00:39:17,876 --> 00:39:22,050
Because inventory service can only make a get request

557
00:39:22,470 --> 00:39:25,742
and it has to satisfy this rule.

558
00:39:25,806 --> 00:39:28,820
Right? And I will go ahead,

559
00:39:29,270 --> 00:39:30,610
I will delete.

560
00:40:07,070 --> 00:40:11,220
So we delete data authorization policies and.

561
00:40:15,270 --> 00:40:18,242
Let's go back. Let me go.

562
00:40:18,296 --> 00:40:22,690
Just verify there are no authorization policies. See? No authorization

563
00:40:22,770 --> 00:40:26,280
policies. We go back to our inventory part.

564
00:40:26,650 --> 00:40:30,694
We make a post request, you see, it is able to

565
00:40:30,732 --> 00:40:34,060
successfully access the make

566
00:40:34,510 --> 00:40:37,820
post request on the source application. It can

567
00:40:38,270 --> 00:40:41,500
make the get request, you see?

568
00:40:46,370 --> 00:40:49,486
200. Okay. And this

569
00:40:49,508 --> 00:40:52,686
is the part which is

570
00:40:52,708 --> 00:40:56,334
serving the request. Right? And same goes for

571
00:40:56,372 --> 00:40:59,934
the users. There are no authorization policies.

572
00:40:59,982 --> 00:41:03,506
You should be able to make the users application as well

573
00:41:03,528 --> 00:41:07,378
from inventory. And you can also make post

574
00:41:07,464 --> 00:41:10,740
as well if you want. All right,

575
00:41:11,510 --> 00:41:15,266
so without authorization policies, it's open. Anyone can

576
00:41:15,288 --> 00:41:18,766
access it. Without authorization policies, you can restrict

577
00:41:18,878 --> 00:41:19,860
the access.

578
00:41:22,470 --> 00:41:26,314
So it. All right, so with this, we are done

579
00:41:26,432 --> 00:41:30,154
with the talk. Thanks for joining and

580
00:41:30,272 --> 00:41:31,818
have a nice rest of your day.

