1
00:00:38,770 --> 00:00:42,386
Hey everybody, and welcome to this session on maximizing CI

2
00:00:42,418 --> 00:00:46,018
CD efficiency, where we're going to dive into reusable templates,

3
00:00:46,114 --> 00:00:49,302
specifically with azure pipelines, and how to make the best out of it.

4
00:00:49,436 --> 00:00:53,166
And love this quote from David Farley is that releasing software is

5
00:00:53,188 --> 00:00:57,354
too often an art. This idea of an art is that every picture

6
00:00:57,402 --> 00:01:00,442
or every painting you do is different, when in actuality

7
00:01:00,506 --> 00:01:03,006
it should be more of an engineering discipline. We should be able to crank these

8
00:01:03,028 --> 00:01:06,718
things out very similarly and get all the best constraints with them in

9
00:01:06,724 --> 00:01:09,986
terms of how we want to update them and maintain them over. And that's what

10
00:01:10,008 --> 00:01:14,110
we want to dive into today. Before we get started, my name is Travis

11
00:01:14,190 --> 00:01:17,650
and I work as a distinguished engineer at SPS Commerce

12
00:01:17,730 --> 00:01:22,070
and you probably haven't heard of SPS commerce. We're a business to business organization that

13
00:01:22,140 --> 00:01:25,718
focuses on connecting the world's largest retail network together,

14
00:01:25,804 --> 00:01:29,426
which is retailers and suppliers to exchange purchase orders

15
00:01:29,458 --> 00:01:33,222
and invoices with some of the biggest names that you might expect, including Walmart,

16
00:01:33,286 --> 00:01:36,874
Target, academy, sports and Bass Pro, and many more.

17
00:01:36,992 --> 00:01:41,100
My focus at SPS commerce is specifically on developer experience,

18
00:01:41,550 --> 00:01:44,746
and you might be asking yourself a little bit, what do you mean by developer

19
00:01:44,778 --> 00:01:48,254
experience? What exactly is that? That can mean so many different things.

20
00:01:48,372 --> 00:01:51,758
For example, if I change my address with the HR department and

21
00:01:51,764 --> 00:01:55,566
I'm a developer, is that a developer experience? And the answer is a little

22
00:01:55,588 --> 00:01:58,546
more fine grained than that. And the definition that I like to land on is

23
00:01:58,568 --> 00:02:02,542
that developer experience is the activity of studying, improving and optimizing

24
00:02:02,606 --> 00:02:05,746
how developers get their work done. We're focusing on how you

25
00:02:05,768 --> 00:02:09,526
get that production, sorry, that value to production and everything in

26
00:02:09,548 --> 00:02:13,506
between that affects your development process and workflow. And so we're really marrying

27
00:02:13,538 --> 00:02:17,442
together this idea of user experience along with your development principles,

28
00:02:17,506 --> 00:02:21,318
specifically at your organization to form your developer experience. Your experience

29
00:02:21,404 --> 00:02:24,986
might be specifically shaped by the tool set that you have, by the process and

30
00:02:25,008 --> 00:02:28,778
the workflows that you have, and by the best practices that you have. In a

31
00:02:28,784 --> 00:02:32,058
lot of cases, our organizations have been around for 510

32
00:02:32,144 --> 00:02:35,918
1525 plus years, and that means that a

33
00:02:35,924 --> 00:02:39,326
lot of these organizations have a series of tools that just have

34
00:02:39,348 --> 00:02:42,362
popped up or grown at different points in time for different initiatives.

35
00:02:42,506 --> 00:02:46,066
And that's why I think that this problem statement really helps define what

36
00:02:46,088 --> 00:02:49,662
we're trying to solve, and that's that developers work in rainforests,

37
00:02:49,726 --> 00:02:53,518
not planned gardens. We didn't necessarily have an opportunity to plan out the workflow

38
00:02:53,534 --> 00:02:56,462
of how you deliver what you're pushing to production.

39
00:02:56,526 --> 00:03:00,534
Instead, you were given this tool and you're told to do this change management process.

40
00:03:00,652 --> 00:03:04,146
And so that leaves you as a lead developer and a lot of times fending

41
00:03:04,178 --> 00:03:07,766
for yourself and figuring out what that workflow is. And it might not be the

42
00:03:07,788 --> 00:03:11,062
best since you're spending your day on delivering value to production,

43
00:03:11,126 --> 00:03:14,870
not actually delivering an update on how you get that value to production,

44
00:03:14,950 --> 00:03:18,346
the process in between. So at SPS commerce we

45
00:03:18,368 --> 00:03:22,278
focus on developer experience capabilities, and we think of these capabilities

46
00:03:22,374 --> 00:03:26,506
as identified horizontal fast tracks that we want to curate for maximum productivity

47
00:03:26,538 --> 00:03:29,966
across the organization. What are the things that we do most often and

48
00:03:29,988 --> 00:03:33,534
how can we make them better across it all? And so if we draw

49
00:03:33,572 --> 00:03:37,138
the organization in these common sets of verticals, we can begin to

50
00:03:37,224 --> 00:03:40,338
think about these types of stories. Like API design is

51
00:03:40,344 --> 00:03:44,046
a really good one for SPS commerce. We are focusing and zoning in specifically

52
00:03:44,078 --> 00:03:47,526
on our API design process as an API first organization and

53
00:03:47,548 --> 00:03:51,126
how we deliver great APIs. You can also think about

54
00:03:51,148 --> 00:03:54,866
code, reusable and inner source. And how you share code effectively

55
00:03:54,898 --> 00:03:58,582
across the organization can have a large impact building

56
00:03:58,636 --> 00:04:02,166
deploying a new application from scratch is sometimes fraught with so

57
00:04:02,188 --> 00:04:05,322
many different toily type of things where you're trying to figure out how to build

58
00:04:05,376 --> 00:04:08,826
inside your ecosystem. Or maybe it takes just way too long to

59
00:04:08,848 --> 00:04:12,266
figure out what those best practices are for building a new app.

60
00:04:12,448 --> 00:04:15,930
And of course, what we do every single day as developers and engineers

61
00:04:16,010 --> 00:04:19,790
is to build out and deploy new features to production. Think about your process

62
00:04:19,860 --> 00:04:23,146
for approaching that and all the tooling that goes with it, and your change management

63
00:04:23,178 --> 00:04:27,300
and your feature flagging and feature toggles is all wrapped into that.

64
00:04:27,670 --> 00:04:31,794
But what we find across all of these as we think about our developer experience,

65
00:04:31,912 --> 00:04:35,282
is that CI CD is at the core of it. This is our orchestration engine

66
00:04:35,336 --> 00:04:38,610
for enabling a lot of the value that we want to keep throwing,

67
00:04:39,030 --> 00:04:42,562
sorry, keep moving through these pipelines, right? And so that's essential

68
00:04:42,626 --> 00:04:45,686
to land on a piece of common tooling that can help you do

69
00:04:45,708 --> 00:04:48,926
that and help you land on specific patterns that make that easier.

70
00:04:49,058 --> 00:04:52,662
Whether it be reducing toilet or keeping developers in their creative flow,

71
00:04:52,726 --> 00:04:56,678
or just reducing duplication, having a standardized CI

72
00:04:56,694 --> 00:04:59,990
CD practice with effective methods for rolling out new pipelines

73
00:05:00,070 --> 00:05:03,366
can be essential foundation in order to do that. And Azure

74
00:05:03,398 --> 00:05:06,542
DevOps is one tool that can do that pretty effectively, I think.

75
00:05:06,676 --> 00:05:10,014
And if you're not familiar with Azure DevOps, it's a series of

76
00:05:10,132 --> 00:05:13,290
products and services that come together as a SaaS offering.

77
00:05:13,450 --> 00:05:17,710
It does offer work items as well, which is similar to like Jira items.

78
00:05:17,790 --> 00:05:20,878
It does offer Azure repos again, much like git repos,

79
00:05:20,974 --> 00:05:24,638
it offers Azure pipelines, and many of the features you'll

80
00:05:24,654 --> 00:05:28,090
see here is very pluggable. And so actually my experience is mostly

81
00:05:28,110 --> 00:05:31,542
with Azure pipelines, specifically not with repos or boards or

82
00:05:31,596 --> 00:05:35,302
test plans or artifacts, because you can plug and

83
00:05:35,356 --> 00:05:38,690
play different components that you want to use out of the Azure DevOps ecosystem.

84
00:05:38,770 --> 00:05:42,822
And pipelines is an excellent example where it works great with GitHub repositories.

85
00:05:42,966 --> 00:05:46,646
It works great with connecting to Jenkins as a source

86
00:05:46,678 --> 00:05:49,866
or a destination. There's lots of different opportunities that you can

87
00:05:49,888 --> 00:05:53,138
use it in these tight scenarios or situations.

88
00:05:53,334 --> 00:05:57,326
Used to be called, or I should say it came from team foundation server or

89
00:05:57,348 --> 00:06:00,782
TFS if you're familiar with the history of that particular product.

90
00:06:00,916 --> 00:06:04,462
Eventually it became visual studio team services and was available online,

91
00:06:04,596 --> 00:06:08,286
also known as vsts, until the name that we know today as Azure

92
00:06:08,318 --> 00:06:11,842
DevOps. It is a SaaS offering, as I mentioned,

93
00:06:11,976 --> 00:06:15,714
and that means that it is available in the cloud, but you can have

94
00:06:15,752 --> 00:06:19,646
self hosted agents as well as cloud hosted agents, much like you see in GitHub

95
00:06:19,758 --> 00:06:23,126
actions and other systems. There are agents that are ready to

96
00:06:23,148 --> 00:06:26,406
go to do your bidding if you want to pay per hour per minute for

97
00:06:26,428 --> 00:06:30,054
those, but you can also deploy your own agents, which can be very effective way

98
00:06:30,092 --> 00:06:33,702
to integrate with your ecosystem with your security. Best practices.

99
00:06:33,846 --> 00:06:37,254
From a cost perspective, I think you'll actually find it's very cheap to execute

100
00:06:37,302 --> 00:06:40,906
if you're already in the Microsoft ecosystem. It can honestly be

101
00:06:41,008 --> 00:06:44,346
almost free depending on the size of your team, depending on the type of license,

102
00:06:44,378 --> 00:06:48,030
and depending on what you want to use. Azure pipeline specifically actually

103
00:06:48,100 --> 00:06:51,486
only requires a stakeholder license to use most

104
00:06:51,508 --> 00:06:54,670
of the features that are there. And so that's something to consider that

105
00:06:54,740 --> 00:06:58,334
this is a very cheap offering if you're already a Microsoft

106
00:06:58,382 --> 00:07:01,538
ecosystem, and if you're not, it's not even that cheap to get.

107
00:07:01,624 --> 00:07:04,578
I should say it's even cheap to get started in that way.

108
00:07:04,744 --> 00:07:08,414
They do offer a marketplace where you can download and install custom extensions

109
00:07:08,462 --> 00:07:12,818
and tasks, though they can be a little fraught with some staleness

110
00:07:12,914 --> 00:07:15,862
depending on the ones that are there. You want to do your due diligence before

111
00:07:15,916 --> 00:07:19,574
entertaining the installation of some of those, and it's important to

112
00:07:19,612 --> 00:07:23,174
remember that when we talk about Azure DevOps, even though it's got that word Azure

113
00:07:23,222 --> 00:07:26,842
in the name, it's actually cloud agnostic. Sure, they provide

114
00:07:26,896 --> 00:07:30,646
integrations specifically for Azure that are there by default, but there are also extensions

115
00:07:30,678 --> 00:07:34,398
you can install specifically for GCP or for AWS and

116
00:07:34,404 --> 00:07:37,774
it works great into them. In fact, we'll talk a little bit later about our

117
00:07:37,812 --> 00:07:40,778
example and current architecture,

118
00:07:40,874 --> 00:07:44,526
but we deploy actually 80% of our services into AWS and

119
00:07:44,548 --> 00:07:48,274
do it entirely through Azure DevOps. And it works great as a platform orchestrator for

120
00:07:48,312 --> 00:07:51,554
that. And so as we position Azure pipelines, then within side

121
00:07:51,592 --> 00:07:54,914
the industry, I think you'll notice that it's very well positioned. If we look at

122
00:07:54,952 --> 00:07:58,434
the g two quadrant, it's definitely there towards the top as

123
00:07:58,472 --> 00:08:01,990
one of the leaders along with GitHub Actions and GitLab and

124
00:08:02,060 --> 00:08:05,734
several others. If we look at the postman report from 2023,

125
00:08:05,772 --> 00:08:09,218
I think you'll find that Azure Pipelines is number four on that list. We see

126
00:08:09,244 --> 00:08:12,054
that top four being very common, GitHub, Jenkins,

127
00:08:12,102 --> 00:08:15,226
GitLab and Azure pipelines. Of course GitHub actions is

128
00:08:15,248 --> 00:08:18,694
fantastic for open source, but sometimes you really need those enterprise

129
00:08:18,742 --> 00:08:22,134
level features which you can only find in enterprise level software

130
00:08:22,182 --> 00:08:25,950
like Azure DevOps and Azure pipelines. And so you'll find definitely some

131
00:08:26,020 --> 00:08:29,374
additional capabilities, especially in some of the templating language we talk about

132
00:08:29,412 --> 00:08:33,210
today that is not present in some of these other tooling

133
00:08:33,290 --> 00:08:35,982
that I think is a large advantage. For example,

134
00:08:36,116 --> 00:08:39,778
when we think about GitHub workflows, they're great, they provide a lot

135
00:08:39,784 --> 00:08:43,070
of capability. But I think you'll find the templating features

136
00:08:43,150 --> 00:08:46,206
and some of the things we're about to accomplish today are a little bit easier,

137
00:08:46,238 --> 00:08:49,598
a little more straightforward in Azure pipelines. As we look at

138
00:08:49,624 --> 00:08:53,206
Azure pipelines, again, if you're not familiar with it or you're relatively new

139
00:08:53,228 --> 00:08:56,594
to it, we really want to focus in on producing what we call the YAML

140
00:08:56,642 --> 00:09:00,082
based pipeline. And focusing in on YAML is essential

141
00:09:00,146 --> 00:09:03,994
because YaML allows us to define this definition of our pipeline as

142
00:09:04,032 --> 00:09:07,402
code. And if we're really going to take advantage of some of the components of

143
00:09:07,456 --> 00:09:10,554
Azure DevOps and reusability, we're going to want to do that as

144
00:09:10,592 --> 00:09:14,510
YAmL syntax in our code base. Here's an example pipeline, and this is actually

145
00:09:14,580 --> 00:09:17,482
a real deployment pipelines in my organization.

146
00:09:17,626 --> 00:09:20,606
And here you can see we have lots of different executions and things that are

147
00:09:20,628 --> 00:09:23,998
happening. But it looks pretty straightforward in terms of the workflow here, right. This is

148
00:09:24,004 --> 00:09:27,394
the YAMl workflow where we have a context analysis. We have a

149
00:09:27,432 --> 00:09:30,802
compilation stage before an integration, before approval, and finally

150
00:09:30,856 --> 00:09:34,706
before production deploy with parallel streams of deployment to

151
00:09:34,728 --> 00:09:37,906
multi region app that's going out behind. And so in

152
00:09:37,928 --> 00:09:41,110
here we also have other components that we might want to look at,

153
00:09:41,180 --> 00:09:44,326
tasks and checks we won't have time to cover those today because

154
00:09:44,348 --> 00:09:47,846
we're focusing on these templates. But templates will give you that foundational basis for how

155
00:09:47,868 --> 00:09:51,430
you're going to integrate and work with tasks and checks

156
00:09:51,510 --> 00:09:54,874
and all these components together. So let's dive in. Let's talk about

157
00:09:54,912 --> 00:09:58,634
templates and this idea of building a YAML templates. YAML templates in

158
00:09:58,672 --> 00:10:02,106
general are not something you should avoid if you're worried about

159
00:10:02,128 --> 00:10:05,614
writing too much YAmL or becoming a YAML engineer. I'd say that

160
00:10:05,652 --> 00:10:08,926
is partially the world that we live in currently. But to a

161
00:10:08,948 --> 00:10:12,606
certain degree this just enables so many other capabilities. There are so many advantages in

162
00:10:12,628 --> 00:10:15,978
doing so that it deems necessary. I think

163
00:10:16,084 --> 00:10:20,386
you'll find that on the tech radar for thoughtworks, which release information about

164
00:10:20,488 --> 00:10:24,174
when you should trial something, when you should adopt it. You'll find that both Azure

165
00:10:24,222 --> 00:10:27,746
DevOps pipelines as well as YAMl show up

166
00:10:27,768 --> 00:10:30,978
here and are present on something that you need to be trialing and trialing,

167
00:10:30,994 --> 00:10:34,454
not from the sense of it may be or may not be ready, it's ready.

168
00:10:34,492 --> 00:10:37,878
It's just something that you need to look forward to using and see how it

169
00:10:37,884 --> 00:10:40,698
fits in your organization. So there's a lot of traction here.

170
00:10:40,784 --> 00:10:43,850
YAML templates is a pretty standardized approach,

171
00:10:44,350 --> 00:10:48,506
and today, as we look at templates, templates are defined as

172
00:10:48,688 --> 00:10:52,302
reusable content, logic and parameters. Templates function

173
00:10:52,356 --> 00:10:53,280
in two ways.

174
00:10:55,410 --> 00:10:58,798
You can insert reusable content with a template, which is great. That's kind

175
00:10:58,804 --> 00:11:03,066
of what we expect, right? Just take content, put it in the spot and materialize

176
00:11:03,098 --> 00:11:06,446
it that way and render it. But here's the interesting part that we'll talk about

177
00:11:06,468 --> 00:11:09,346
a little bit later is that you can use a template to control what is

178
00:11:09,368 --> 00:11:12,866
allowed in a pipeline. So there's a security aspect to the templates that

179
00:11:12,888 --> 00:11:15,950
we'll see here as well. So we'll talk a little bit about the anatomy.

180
00:11:16,030 --> 00:11:19,240
What are tasks, jobs, stages, pipelines, how do they all fit together?

181
00:11:19,610 --> 00:11:22,854
Before we dive into the ideas around extending and

182
00:11:22,892 --> 00:11:25,938
including, which is basically inheritance and composition,

183
00:11:26,034 --> 00:11:28,934
and if you're coming from the object oriented world, you know that those are great

184
00:11:28,972 --> 00:11:32,086
things. We just have to figure out how to use them appropriately in the template

185
00:11:32,118 --> 00:11:35,878
world. So let's get started. Let's think about our functional requirements,

186
00:11:36,054 --> 00:11:39,706
and our functional requirements here as

187
00:11:39,728 --> 00:11:43,086
an example. Typically for a build, well, what are the things we

188
00:11:43,108 --> 00:11:47,182
do? We have a shared context or variables or configuration across

189
00:11:47,236 --> 00:11:51,274
the organization. We have some types of security constraints

190
00:11:51,322 --> 00:11:55,118
or deployment environment or build environment. We have versioning that

191
00:11:55,124 --> 00:11:59,534
we need to do, which could be semantic versioning, could be infrastructure style versioning

192
00:11:59,582 --> 00:12:03,666
with the date as a part of the version name and an iteration number.

193
00:12:03,848 --> 00:12:07,186
We usually have private packages that we need to worry about coming from, like an

194
00:12:07,208 --> 00:12:10,626
internal JFrog or GitHub artifacts or Azure DevOps

195
00:12:10,658 --> 00:12:13,926
artifacts. We also have build verification. We got

196
00:12:13,948 --> 00:12:16,946
to unit test it. We're going to push artifacts, maybe a docker container,

197
00:12:16,978 --> 00:12:20,466
maybe some other files and artifacts that we need. We also want to tag

198
00:12:20,498 --> 00:12:24,298
the repositories, let them know that here's the immutable version I created that's associated with

199
00:12:24,304 --> 00:12:27,338
this. We might have some notifications on failure or success,

200
00:12:27,504 --> 00:12:31,066
and all these are fantastic, but boy, there's a lot of things I have to

201
00:12:31,088 --> 00:12:34,102
do and consider every time I build a new pipelines,

202
00:12:34,246 --> 00:12:38,174
when in fact a lot of these, other than these two, these other ones are

203
00:12:38,212 --> 00:12:41,966
really the same across most of the pipelines that I need to build. And so

204
00:12:41,988 --> 00:12:45,706
when we think about this content that is unique to each pipeline,

205
00:12:45,738 --> 00:12:49,538
the differentiation is really how do I build this thing, how do I verify it,

206
00:12:49,544 --> 00:12:53,026
how do I validate it and then unit test it? Pushing artifacts is

207
00:12:53,048 --> 00:12:56,562
arguably the same across it all, and I think we'd find that also true

208
00:12:56,616 --> 00:13:00,050
for deployment. In deployment we can look at organization,

209
00:13:00,130 --> 00:13:03,478
we can look at security constraints, change management, artifact promotion, and a lot

210
00:13:03,484 --> 00:13:07,330
of these are the same across every pipelines. And so it feels awkward

211
00:13:07,410 --> 00:13:10,966
to copy and paste that yaml every single time. We want to get away from

212
00:13:10,988 --> 00:13:14,858
that. We want to enable ourselves to be able to make changes in

213
00:13:14,864 --> 00:13:17,782
one spot when we want to update and have less code in our repo.

214
00:13:17,846 --> 00:13:21,242
And that's where the templates play an important role. Even here you can see that

215
00:13:21,296 --> 00:13:25,058
depending on how declarative your logic is, there's just a lot of boilerplate,

216
00:13:25,094 --> 00:13:28,526
and you might not even have to have any deploy specific logic other

217
00:13:28,548 --> 00:13:31,902
than tell me my environment and I should know how to declaratively deploy from there.

218
00:13:32,036 --> 00:13:35,642
So there's a lot of boilerplate. This idea of code reuse

219
00:13:35,706 --> 00:13:39,538
is really, really important across your organization, especially not just in

220
00:13:39,544 --> 00:13:43,538
your pipelines, but also in your code distribution as well. I have another session you

221
00:13:43,544 --> 00:13:46,786
can find from other conferences called compelling code reuse in the enterprise that

222
00:13:46,808 --> 00:13:50,178
I think you'd find interesting. If you're enjoying this topic. So let's

223
00:13:50,194 --> 00:13:54,018
dive into the pipeline anatomy then at a high level. This is the diagram we're

224
00:13:54,034 --> 00:13:57,462
given from Microsoft on Azure, DevOps and how it works.

225
00:13:57,596 --> 00:14:01,254
We have a trigger. A trigger is like a commit to a repository, and that

226
00:14:01,292 --> 00:14:04,858
trigger could be from GitHub could be from Azure. Repos triggers a pipeline and a

227
00:14:04,864 --> 00:14:08,778
pipeline is made up of a series of stages, and stages themselves are

228
00:14:08,864 --> 00:14:12,474
made up of a series of jobs. And jobs run on a particular machine or

229
00:14:12,512 --> 00:14:16,046
agent in some location. And each job then

230
00:14:16,228 --> 00:14:19,566
executes a series of steps or tasks that are associated with

231
00:14:19,588 --> 00:14:22,190
them. And those tasks can do anything. They could be script tasks.

232
00:14:22,610 --> 00:14:25,786
And here's an example then demonstrating that we saw this a little bit earlier,

233
00:14:25,818 --> 00:14:29,346
of the different components that were part of my Yaml pipelines, you can see

234
00:14:29,368 --> 00:14:32,738
that these are stages, these are jobs. And then here you

235
00:14:32,744 --> 00:14:35,842
can see are some checks. Checks are kind of run at the job level,

236
00:14:35,896 --> 00:14:39,506
but are aggregated to the stage level just to visualize all

237
00:14:39,528 --> 00:14:42,822
the checks that those jobs have. But there's also different

238
00:14:42,876 --> 00:14:46,134
types of jobs that we need to be concerned with. There's two types. The first

239
00:14:46,172 --> 00:14:49,638
type of job is a regular job and it's literally just called job. And the

240
00:14:49,644 --> 00:14:53,194
second type is called a deployment job. And a deployment job

241
00:14:53,232 --> 00:14:56,186
is a special type of job that has additional constraints that we can connect to

242
00:14:56,208 --> 00:14:59,926
an environment for deployment. And it's essential to use those deployment jobs

243
00:14:59,958 --> 00:15:03,586
for deploys and then use other types of jobs for other utility

244
00:15:03,638 --> 00:15:07,614
like building or other context evaluation. So here's what a YAmL file looks

245
00:15:07,652 --> 00:15:10,974
like. That's very very minimum. We have a trigger which is

246
00:15:11,012 --> 00:15:14,366
main, we have a series of stages, then in this case two

247
00:15:14,388 --> 00:15:17,998
stages, a build stage and a deploy stage. Jobs inside those stages.

248
00:15:18,094 --> 00:15:21,074
And so here you can see, here's a deploy job looks a little different.

249
00:15:21,112 --> 00:15:24,898
It's defined as deployment versus just job that you

250
00:15:24,904 --> 00:15:28,466
can see above. And in this case it's important to recognize some

251
00:15:28,488 --> 00:15:32,706
difference in behaviors. First of all, stages actually run automatically

252
00:15:32,738 --> 00:15:35,846
in sequence from each other. So we know that the build stage and all of

253
00:15:35,868 --> 00:15:38,838
its jobs are going to finish before the next stage is going to run,

254
00:15:38,924 --> 00:15:42,954
unless we decide to change that order. You can adapt that. So stages run by

255
00:15:42,992 --> 00:15:46,966
default in sequence unless you specify otherwise. But jobs,

256
00:15:47,078 --> 00:15:50,246
jobs always materialize in a stage. They by default

257
00:15:50,278 --> 00:15:53,870
run in parallel unless you change that. So that's an important difference

258
00:15:53,940 --> 00:15:57,534
to make and understand in how you can execute your workflows and

259
00:15:57,572 --> 00:16:00,910
build templates. Let's dive into some template basics.

260
00:16:01,330 --> 00:16:05,326
So first is, how do we define a template? Well, normally in

261
00:16:05,348 --> 00:16:08,606
a pipeline, assuming you've built an Azure DevOps Yaml pipeline

262
00:16:08,638 --> 00:16:11,986
before, you would define an Azure pipelines YaMl file, much to like

263
00:16:12,008 --> 00:16:16,414
we just looked at, but then to define a template,

264
00:16:16,542 --> 00:16:19,846
well, we're going to assign some parameters at the top the assignment of

265
00:16:19,868 --> 00:16:23,254
parameters essentially makes it a template, though it doesn't mean

266
00:16:23,292 --> 00:16:27,238
you could still use parameters in a root level pipeline. It's just

267
00:16:27,404 --> 00:16:30,978
a nomenclature and a terminology. So here we can define some

268
00:16:31,004 --> 00:16:34,586
primitive parameters, in this case like a name, and the

269
00:16:34,608 --> 00:16:37,706
name could have a type. It's usually the type that

270
00:16:37,728 --> 00:16:41,418
you want it to be. It's a primitive type, so it could be string number,

271
00:16:41,504 --> 00:16:45,006
boolean at a high level. You can also define whether it's required or not

272
00:16:45,028 --> 00:16:47,946
by passing in whether it has a default. If it doesn't have a default,

273
00:16:47,978 --> 00:16:51,418
then it's a required parameter, which is pretty straightforward.

274
00:16:51,594 --> 00:16:55,246
You can also enforce restricted enumeration. So we can say the type is

275
00:16:55,268 --> 00:16:58,386
a string, but we want to ensure that it is either value of dev or

276
00:16:58,408 --> 00:17:02,782
prod for our environment. And we can also define a series of stages

277
00:17:02,926 --> 00:17:05,582
that we might want to include, or these are stages that we're going to inject

278
00:17:05,646 --> 00:17:09,466
with, that include or that composition into wherever we use the templates.

279
00:17:09,598 --> 00:17:13,826
And so in this example we're injecting a stage and that stage uses

280
00:17:13,858 --> 00:17:17,126
some functions and some variables. And so here we can reference and see how we

281
00:17:17,148 --> 00:17:20,354
can use parameter variable syntax to reference

282
00:17:20,402 --> 00:17:24,214
and change the stage name based on the environment. We can also use these functions

283
00:17:24,262 --> 00:17:28,026
to alter or modify the parameters that we might want to apply. So in this

284
00:17:28,048 --> 00:17:31,626
case I like having my display of my environment always in

285
00:17:31,648 --> 00:17:34,794
uppercase, a nice uppercase prod or uppercase dev.

286
00:17:34,912 --> 00:17:38,174
So we can do upper in order to transform that. And you have many other

287
00:17:38,212 --> 00:17:42,058
functions that you want to get familiar with, whether it be equality checking or greater

288
00:17:42,074 --> 00:17:46,242
than length. You can use or operations to combine and join these together.

289
00:17:46,376 --> 00:17:50,178
Starts with you can invert it and use a knot as well.

290
00:17:50,344 --> 00:17:53,746
And then you can see here where we're just injecting a bash execution script that

291
00:17:53,768 --> 00:17:57,462
just says echo. Hello and then gives the name

292
00:17:57,516 --> 00:18:00,610
of the person that we passed in, in this case hello Travis.

293
00:18:00,770 --> 00:18:03,622
Pretty straightforward template that we can make use of.

294
00:18:03,676 --> 00:18:07,314
Now in another azure pipeline file template

295
00:18:07,362 --> 00:18:11,154
expressions allow us to go one step further with how we think about our parameters.

296
00:18:11,282 --> 00:18:14,662
So here, recognize that we can have complex types, so our parameters

297
00:18:14,726 --> 00:18:18,170
can actually be of type object and that object now can be a list.

298
00:18:18,240 --> 00:18:21,386
So notice that the default, not the restrictions, but the default here is

299
00:18:21,408 --> 00:18:24,766
saying I'm going to pass you dev and prod. Here's all the environments I

300
00:18:24,788 --> 00:18:28,206
want to deploy to. We can also change that

301
00:18:28,228 --> 00:18:32,330
around a bit and use complex environments where we take a list of complex objects.

302
00:18:32,410 --> 00:18:35,762
And notice this list below has

303
00:18:35,816 --> 00:18:38,930
some metadata about each environment. Now approval required,

304
00:18:39,590 --> 00:18:43,058
the approvers that can approve that environment, that sort of information.

305
00:18:43,224 --> 00:18:46,674
So when we create our deploy steps, oh, before I

306
00:18:46,712 --> 00:18:50,678
say that, I should say you can also have a special type of parameter here

307
00:18:50,844 --> 00:18:54,182
that is a step list and that allows you to actually pass in

308
00:18:54,236 --> 00:18:58,498
steps so we can have a user of the template

309
00:18:58,594 --> 00:19:02,110
actually provide you. Here's steps that I want to use and it recognize steps

310
00:19:02,130 --> 00:19:05,594
as a complex type. Same with job and job list, and same with

311
00:19:05,632 --> 00:19:09,306
stage and stage list and deployment deployment list. So you can pass in these as

312
00:19:09,408 --> 00:19:13,146
well known types. When you define then your actual stages you

313
00:19:13,168 --> 00:19:16,986
want to inject, we can begin to do some interesting things from a template expression.

314
00:19:17,098 --> 00:19:20,378
First of all, we can just straight up take the deploy steps that they passed

315
00:19:20,394 --> 00:19:24,474
in and include them. So if this is a step list, it's going to automatically

316
00:19:24,522 --> 00:19:27,634
include all the steps now in that particular part. So we can begin to piece

317
00:19:27,672 --> 00:19:31,006
this together and put them in the right spot or surround

318
00:19:31,038 --> 00:19:35,102
or encapsulate other tasks that are executing. But we can also do loops.

319
00:19:35,166 --> 00:19:38,486
Loops are pretty cool because here I can take our environment list and for each

320
00:19:38,508 --> 00:19:43,218
environment now I can echo out a particular statement.

321
00:19:43,394 --> 00:19:46,486
But think about how we could use this if we had complex environments as well.

322
00:19:46,508 --> 00:19:49,318
We can loop through those and here we can loop through them and we can

323
00:19:49,324 --> 00:19:52,594
check to see if approval is required in that environment. And if approval is required,

324
00:19:52,642 --> 00:19:55,542
we can take a different action than if it's not. In this case, I'm just

325
00:19:55,596 --> 00:19:58,626
doing an echo statement that indicates that. But you can see how you could swap

326
00:19:58,658 --> 00:20:01,726
out your behavior inside these expressions to

327
00:20:01,748 --> 00:20:05,754
build out multiple steps or jobs. You could even have different stages

328
00:20:05,882 --> 00:20:09,434
that are being looped through and added automatically

329
00:20:09,482 --> 00:20:13,450
based on that, which is when we talk about templates. We also have variable templates,

330
00:20:13,530 --> 00:20:16,730
and variable templates don't have parameters at the top, they're simply a file

331
00:20:16,810 --> 00:20:20,306
and they only define variables and they look like this. Here's an example of

332
00:20:20,328 --> 00:20:23,794
where I might have an environment name and a base URL, and this is my

333
00:20:23,832 --> 00:20:27,438
dev variables. I'm using the name dev variables Yaml very explicitly

334
00:20:27,454 --> 00:20:29,906
here because I'm going to have a duplicate of that and I'm going to call

335
00:20:29,928 --> 00:20:33,794
it prod variables. And here I can have my base URL and my environment

336
00:20:33,842 --> 00:20:37,126
name. And now if I were to create a template and this template, let's say

337
00:20:37,148 --> 00:20:40,338
was for deployment, I could use those variables contextually.

338
00:20:40,514 --> 00:20:44,058
And so when we come in here we can import one of

339
00:20:44,064 --> 00:20:46,966
those files. And so this is the same way that we'll see in a minute

340
00:20:46,998 --> 00:20:50,358
that we can import regular parameters and, sorry, regular templates

341
00:20:50,454 --> 00:20:53,858
here. We can also dynamically now bring in a parameter for our environment

342
00:20:53,974 --> 00:20:56,734
and import a file dynamically based on that.

343
00:20:56,852 --> 00:21:00,266
And so we can automatically pull in either the dev variables or the prod

344
00:21:00,298 --> 00:21:03,518
variables and then begin to reference them appropriately. Notice the

345
00:21:03,524 --> 00:21:06,974
different variable syntax that I've used here as well. Parameters environment

346
00:21:07,022 --> 00:21:10,514
is obviously coming from a parameter above versus the

347
00:21:10,552 --> 00:21:13,934
dollar sign syntax with the round brackets

348
00:21:13,982 --> 00:21:17,410
you see on the bottom for environment name. That's coming much later, that's coming

349
00:21:17,480 --> 00:21:20,934
not at render time, but at runtime. And so it's important

350
00:21:20,972 --> 00:21:24,786
to understand the different variable syntax that is available to us when you're completing

351
00:21:24,818 --> 00:21:28,346
not just a pipeline, but specifically when you're working on templates, because those

352
00:21:28,368 --> 00:21:32,314
are happening at completely different points of the lifecycle. So here

353
00:21:32,352 --> 00:21:35,994
you might see that I have macro syntax. Macro syntax is at

354
00:21:36,032 --> 00:21:40,106
task execution. It happens basically

355
00:21:40,288 --> 00:21:44,586
at the last possible minute and is like checking an environment variable.

356
00:21:44,778 --> 00:21:48,074
It's perfect for pipeline task configuration as the typical variable

357
00:21:48,122 --> 00:21:51,646
that you would use when building out a regular pipelines. But the template expression is

358
00:21:51,668 --> 00:21:55,686
a little different, and it is obviously used at compile time or that render

359
00:21:55,738 --> 00:21:59,326
time when we're rendering the template right. And it's

360
00:21:59,358 --> 00:22:03,074
important to note that we can actually change values of the left

361
00:22:03,112 --> 00:22:06,626
or the right side using this, meaning we can actually change the key value

362
00:22:06,808 --> 00:22:10,338
in our template, not just the value of it. And we'll

363
00:22:10,354 --> 00:22:14,194
see why that's important later on in a little. And of course this is necessary

364
00:22:14,242 --> 00:22:17,682
inside templates. Your runtime expression syntax

365
00:22:17,746 --> 00:22:20,894
happens after the templates has been compiled,

366
00:22:21,042 --> 00:22:24,506
but before it's actually running a job. So it's happening kind

367
00:22:24,528 --> 00:22:27,654
of at runtime, but not at the last possible minute.

368
00:22:27,702 --> 00:22:31,290
It's kind of in between. And this is important to use for certain type of

369
00:22:31,360 --> 00:22:34,958
conditional definitions where you might decide that this stage only runs in

370
00:22:34,964 --> 00:22:38,606
this particular scenario. And so as we have those three types of

371
00:22:38,708 --> 00:22:42,574
syntax for variables, you use them in different

372
00:22:42,612 --> 00:22:46,366
ways at different times, but this is the order. Template expression

373
00:22:46,398 --> 00:22:49,554
renders first, macro syntax last,

374
00:22:49,672 --> 00:22:53,026
and runtime right in the middle, so you want to be familiar with those and

375
00:22:53,048 --> 00:22:56,626
when to use them. The template expression syntax and

376
00:22:56,648 --> 00:22:59,426
the macro syntax are pretty standard on when you would use them, but it can

377
00:22:59,448 --> 00:23:02,566
be a little bit confusing on when you need that runtime expression syntax. It might

378
00:23:02,588 --> 00:23:06,006
take a little bit of experimenting depending on where you're using it. So when

379
00:23:06,028 --> 00:23:09,186
you're ready to include a template locally, then like we just saw with the variables

380
00:23:09,218 --> 00:23:12,634
template, you can do that pretty easily. Here's an example where we can pull

381
00:23:12,672 --> 00:23:15,510
in our particular stages and include a template.

382
00:23:15,590 --> 00:23:19,482
And this template we're including here, notice is in line with a

383
00:23:19,536 --> 00:23:22,638
job. And so this is a job template because we're adding it right at the

384
00:23:22,644 --> 00:23:26,106
right indentation level where we would add additional jobs. And notice

385
00:23:26,138 --> 00:23:29,646
that we can include multiple templates within

386
00:23:29,748 --> 00:23:33,294
your particular file so you can build up and use composition to add many

387
00:23:33,332 --> 00:23:36,606
of these together, and you can use the same templates multiple times. Of course,

388
00:23:36,628 --> 00:23:39,646
that's where we get another type of reuse in there as well. We know that

389
00:23:39,668 --> 00:23:42,398
deploying is pretty standard. Whether I'm going to the dev or prod, I just need

390
00:23:42,404 --> 00:23:45,390
to change some of those variables and that's what you can augment with the parameter.

391
00:23:46,330 --> 00:23:50,146
Notice here where these files might exist, there's folders.

392
00:23:50,178 --> 00:23:53,878
And so if we look at the structure of a repository, you'll find that

393
00:23:54,044 --> 00:23:57,058
if I had an azure pipelines yaml file at the root of my repo,

394
00:23:57,154 --> 00:24:00,070
I might have a deploy folder, and then inside there I would have these different

395
00:24:00,140 --> 00:24:03,366
templates for stage or build prep or my variables.

396
00:24:03,398 --> 00:24:06,140
Remember if we were including variables as a part of these too.

397
00:24:06,510 --> 00:24:09,722
I've also been very intentional with the naming of these,

398
00:24:09,776 --> 00:24:12,698
and I would encourage you to think about naming of your templates as well,

399
00:24:12,784 --> 00:24:16,634
because whether it's something that provides job level composition

400
00:24:16,682 --> 00:24:20,206
and include, or whether it's step level or variable, I like to name them and

401
00:24:20,228 --> 00:24:23,770
actually include a suffix in the name that says job or stage or variable

402
00:24:23,850 --> 00:24:27,946
to really define exactly the intention of that. When you're including them, it's always

403
00:24:27,988 --> 00:24:31,666
relative to the file that you're including it from. So as you walk through that

404
00:24:31,688 --> 00:24:35,214
chain, it does become easy. It's not like you're always referencing it to the original

405
00:24:35,262 --> 00:24:38,546
file or to the base file. Templates in parameters to

406
00:24:38,568 --> 00:24:42,082
other templates is tough. That means that if you're taking in a parameter,

407
00:24:42,146 --> 00:24:45,286
and in that parameter you reference another template, which one

408
00:24:45,308 --> 00:24:48,370
do you refer to? It's actually the original template in that case, and that can

409
00:24:48,380 --> 00:24:51,734
be very confusing. So you want to consider that maximum

410
00:24:51,782 --> 00:24:55,962
of 20 levels of template nesting and maximum 100

411
00:24:56,016 --> 00:24:59,626
separate Yaml files total. These are pretty big limits and they want

412
00:24:59,648 --> 00:25:03,178
a maximum ten megabytes of memory parsing before it's going to blow up on

413
00:25:03,184 --> 00:25:06,750
you. I've done some fairly complex templates and haven't reached that

414
00:25:06,820 --> 00:25:10,094
particular problem just yet, so I think you'll be fine to build something

415
00:25:10,132 --> 00:25:13,534
fairly complex here if you wanted. But of course the power comes

416
00:25:13,572 --> 00:25:17,198
in when we're not talking about including just local templates, but the idea that I

417
00:25:17,204 --> 00:25:20,498
want to include a template remotely and remote is important because it means that I

418
00:25:20,504 --> 00:25:24,226
can make use of it across multiple repositories without moving it around or doing

419
00:25:24,248 --> 00:25:28,066
something special to make that happen. And so to

420
00:25:28,088 --> 00:25:31,254
include a remote file we do that first by adding this

421
00:25:31,292 --> 00:25:34,966
resources section at the top where we can include other repository information.

422
00:25:35,148 --> 00:25:38,722
So here for example, we're going to include our repositories

423
00:25:38,786 --> 00:25:42,810
and its name is Azure pipeline templates. You might create that in your repo

424
00:25:43,230 --> 00:25:47,034
and it is going to be named templates. And in

425
00:25:47,072 --> 00:25:50,454
its directory, in its structure, it would have our deployed template

426
00:25:50,502 --> 00:25:53,760
at the root along with environments specified underneath it.

427
00:25:55,170 --> 00:25:57,866
And then you can see here where we start to use some of the resources.

428
00:25:57,898 --> 00:26:01,454
So we're going to use those resources further down and inside.

429
00:26:01,572 --> 00:26:05,154
Then this line here where it says templates and then

430
00:26:05,192 --> 00:26:08,958
it says at templates, meaning that it's actually referring

431
00:26:08,974 --> 00:26:13,486
back to pull all the templates from that particular resource.

432
00:26:13,678 --> 00:26:17,550
And so this is a special syntax with the naming where it connects that repositories

433
00:26:17,630 --> 00:26:21,526
name to it. You can see later on where we actually use the term at

434
00:26:21,548 --> 00:26:25,154
self. At self is a specialized term that you can always use that indicates

435
00:26:25,202 --> 00:26:28,498
this is coming from my primary repo that is connected to this pipeline.

436
00:26:28,594 --> 00:26:31,918
And so that's a local file versus a remote file

437
00:26:31,954 --> 00:26:35,334
of what we're building right there. And this is pretty important, this is pretty powerful,

438
00:26:35,382 --> 00:26:38,646
right? This allows us to have a centralized azure pipeline template

439
00:26:38,678 --> 00:26:42,362
for our variables, for our workflow that can now impact

440
00:26:42,426 --> 00:26:46,462
all organizational pipelines. That in and of itself has

441
00:26:46,516 --> 00:26:50,510
a little bit of amazing power and also concern.

442
00:26:50,930 --> 00:26:54,542
And of course we expect that at the same time. But this idea that yeah,

443
00:26:54,596 --> 00:26:58,286
in one line change, in one character change, you could actually blow up every pipeline

444
00:26:58,318 --> 00:27:02,222
in your organization if you have some very highly reusable capabilities

445
00:27:02,286 --> 00:27:05,794
there. So that being said, you want to make sure that whatever repositories is

446
00:27:05,832 --> 00:27:09,586
hosting these shared templates is going to be locked down, secured and require

447
00:27:09,618 --> 00:27:12,838
some approval process before engineers and anyone is allowed to

448
00:27:12,844 --> 00:27:16,498
submit there. Ideally some good validation and pr status checks

449
00:27:16,514 --> 00:27:20,290
as well. It's also worth noting how you version.

450
00:27:20,370 --> 00:27:24,486
So in this shared repository that you might create to host your templates,

451
00:27:24,598 --> 00:27:27,418
how do you want to version those? In this case it's just referencing whatever's in

452
00:27:27,424 --> 00:27:30,726
the main branch. But there are different organizational template

453
00:27:30,758 --> 00:27:34,490
versioning strategies you might want to consider. The first is branch based.

454
00:27:34,560 --> 00:27:37,726
You could actually just have different branches where you have a v, one branch and

455
00:27:37,748 --> 00:27:41,582
a v two branch and you could put those templates in there and then

456
00:27:41,716 --> 00:27:45,802
your v one branch has everything for v one. But that couples our template versions

457
00:27:45,866 --> 00:27:49,390
together. Meaning if I had a build template and a deploy template,

458
00:27:49,470 --> 00:27:52,578
they both have to be version one inside there. And so if I intend to

459
00:27:52,584 --> 00:27:55,586
make a version two of one that couples a version of the other one,

460
00:27:55,608 --> 00:27:59,502
so I have to make a version for it too. We have non immutable

461
00:27:59,566 --> 00:28:03,286
usage, meaning that I could come in and make an update to that template and

462
00:28:03,308 --> 00:28:06,326
roll that out to everyone very easily. I think that's an advantage. I don't think

463
00:28:06,348 --> 00:28:10,386
we want immutable usage here. And of course it's an explicit reference

464
00:28:10,498 --> 00:28:14,282
that I include with that ref command that's there. Now this is similar

465
00:28:14,416 --> 00:28:17,642
but slightly different. You just go with commit or tag based,

466
00:28:17,776 --> 00:28:21,766
especially if you go with commit based, you can reference the actual commit.

467
00:28:21,878 --> 00:28:24,990
This is again still coupled to the same version of template that's there,

468
00:28:25,060 --> 00:28:28,398
but it's immutable. I can guarantee if I'm worried about it, that no

469
00:28:28,404 --> 00:28:32,378
one's going to change this workflow on me under the covers. Now, maybe that's

470
00:28:32,394 --> 00:28:35,738
good in certain situations. Again, I don't think that's a benefit in the organization where

471
00:28:35,764 --> 00:28:39,406
we actually want the ability to change those under the hood and maintain

472
00:28:39,438 --> 00:28:43,006
it, but it's worth considering. And of course we have an explicit

473
00:28:43,038 --> 00:28:46,386
reference there specified with the commit. Or if you are

474
00:28:46,408 --> 00:28:50,086
using tags, you can obviously move tags around. And so that's another option as well.

475
00:28:50,188 --> 00:28:53,922
But my preference is the naming option, which is what I've been kind of producing

476
00:28:53,986 --> 00:28:57,558
so far. This idea of a version actually in the name.

477
00:28:57,724 --> 00:29:00,518
And this has some benefits. It's kind of like API version. I'm just going to

478
00:29:00,524 --> 00:29:04,146
use the major version, I'm just going to call it v one. It's decoupled template

479
00:29:04,178 --> 00:29:07,094
versions. So in my main branch I have v one there. But that might also

480
00:29:07,132 --> 00:29:10,286
sit beside a v two and a v three. And that might mean that my

481
00:29:10,308 --> 00:29:13,246
build templates, that is version at v one, might just have a v one.

482
00:29:13,268 --> 00:29:15,706
It doesn't need to have a v two, simply because this template does. So we've

483
00:29:15,738 --> 00:29:18,906
decoupled those versions across templates. It's non immutable.

484
00:29:18,938 --> 00:29:21,998
So I can make changes to that version one and maintain it appropriately under the

485
00:29:22,004 --> 00:29:25,566
covers for its implementation. And notice that there's no explicit reference here.

486
00:29:25,588 --> 00:29:29,166
This is kind of nice. My teams don't have to worry about exactly which version

487
00:29:29,198 --> 00:29:32,958
do I use. They're just not making any explicit

488
00:29:32,974 --> 00:29:36,306
reference at all. And that's going to automatically grab the default branch and allow them

489
00:29:36,328 --> 00:29:39,126
to use those templates that are out of there. I think overall this is a

490
00:29:39,128 --> 00:29:41,666
little bit simpler in terms of git maintenance as well. You can follow a trunk

491
00:29:41,698 --> 00:29:44,918
based delivery pattern, which is nice, that's great. We see how

492
00:29:44,924 --> 00:29:48,326
to compositionally include templates, but how do we extend a template and what are some

493
00:29:48,348 --> 00:29:51,818
of the differences and why we'd extend it as opposed to include it.

494
00:29:51,904 --> 00:29:54,886
So extending a template works with the key command.

495
00:29:54,998 --> 00:29:58,966
That's the extend option. Extend basically allows

496
00:29:58,998 --> 00:30:02,526
you to provide one template with a series of parameters that you

497
00:30:02,548 --> 00:30:05,802
want to use for that particular pipeline. You can only inherit

498
00:30:05,946 --> 00:30:09,854
one templates, that template itself can inherit other

499
00:30:09,892 --> 00:30:13,550
things, but only this template can be used inside

500
00:30:13,620 --> 00:30:16,782
this particular pipeline. So when we extend it, what might

501
00:30:16,836 --> 00:30:19,826
we be doing with it? Well, if our base template looks like this, we might

502
00:30:19,848 --> 00:30:23,518
be including a stage and a stage list. And maybe before someone runs

503
00:30:23,534 --> 00:30:26,738
that stage list, I always want to run another job. Well, you can see that

504
00:30:26,744 --> 00:30:29,766
we can do that here. So we include a stage list that we want to

505
00:30:29,788 --> 00:30:32,886
encapsulate logic around. We can eliminate boilerplate and

506
00:30:32,908 --> 00:30:36,694
automatically select like an agent pool for deployment if we wanted, or for build.

507
00:30:36,892 --> 00:30:39,462
We can put that in so that the team doesn't have to worry about which

508
00:30:39,516 --> 00:30:42,838
agent they're using. We can add standard variables as well so that those are

509
00:30:42,844 --> 00:30:46,138
just part of the context now that I can use in my pipeline. And we

510
00:30:46,144 --> 00:30:49,786
can of course add that kind of context job and do whatever custom logic we

511
00:30:49,808 --> 00:30:53,318
might have there that we might want to run across the organization, which is

512
00:30:53,344 --> 00:30:56,954
pretty, so this is pretty powerful, right? But I mentioned earlier

513
00:30:57,002 --> 00:31:00,586
that extension is going to help us with security and some security aspects

514
00:31:00,618 --> 00:31:03,566
and limiting what teams can do. And of course we can do that a little

515
00:31:03,588 --> 00:31:07,290
bit through parameters, but there's more powerful capability

516
00:31:07,370 --> 00:31:10,626
if we go into advanced templating that we. So if we

517
00:31:10,648 --> 00:31:13,266
take a look at our base template, let's say it looks like this, similar to

518
00:31:13,288 --> 00:31:16,850
what we just saw when we're ready to include the dynamic stages.

519
00:31:17,430 --> 00:31:21,474
Here's a wallet text, but just follow me through this a little bit. It's complex,

520
00:31:21,602 --> 00:31:24,470
but this is going to allow us to do some interesting capabilities.

521
00:31:24,810 --> 00:31:28,134
First of all, we can loop through all the stages that are coming in,

522
00:31:28,172 --> 00:31:31,526
and rather than just one line to add all stages and all content, we can

523
00:31:31,548 --> 00:31:34,858
loop through that and begin to make decisions about which portions of

524
00:31:34,864 --> 00:31:38,374
the stage the user gave us that we want to add in. We can disallow

525
00:31:38,422 --> 00:31:42,566
certain syntax, like we could restrict deployment jobs or we could only allow deployment jobs

526
00:31:42,598 --> 00:31:45,818
if we wanted. We can apply defaults and say here's some jobs

527
00:31:45,834 --> 00:31:49,546
that materialize not just before but after or in between some of the configuration that's

528
00:31:49,578 --> 00:31:52,782
there. And if we had configuration like,

529
00:31:52,916 --> 00:31:56,346
do you want me to always download artifacts? We can actually include that

530
00:31:56,388 --> 00:32:00,226
for you as a part of the first step on every job that you add.

531
00:32:00,328 --> 00:32:04,094
So that way you never have to worry about pre downloading artifacts

532
00:32:04,142 --> 00:32:07,934
or doing certain behavior to authorize for JFrog

533
00:32:07,982 --> 00:32:11,478
or for other internal private repositories. Here you could just say, hey,

534
00:32:11,564 --> 00:32:14,306
I'm going to do that for you automatically and inject that step at the beginning

535
00:32:14,338 --> 00:32:17,794
of each job, even though you gave me a stage list, which is incredibly

536
00:32:17,842 --> 00:32:21,442
powerful if you can walk through this syntax. So here we can say download

537
00:32:21,506 --> 00:32:24,694
required, you always have to have these defaults. Maybe I could even run a required

538
00:32:24,742 --> 00:32:28,250
bash script at the start of every job that's going to bootstrap or do something.

539
00:32:28,400 --> 00:32:31,786
But I can also apply restrictions here. If I never want you to be able

540
00:32:31,808 --> 00:32:35,454
to run command line or bash scripts, I can actually remove those.

541
00:32:35,492 --> 00:32:39,086
Here we can add an if expression and check to

542
00:32:39,108 --> 00:32:42,558
see that the step name is a particular task and if it is,

543
00:32:42,644 --> 00:32:46,826
I can error out. That's pretty cool. That is immensely

544
00:32:46,858 --> 00:32:50,434
powerful, but these are really hard to validate sometimes. So when you're doing this,

545
00:32:50,472 --> 00:32:53,298
make sure you have jobs that help you and automation that helps you do that.

546
00:32:53,384 --> 00:32:57,138
And recognize that from a security perspective, this allows you to

547
00:32:57,304 --> 00:33:00,518
work with the security team, work with certain tasks you don't want people to be

548
00:33:00,524 --> 00:33:03,174
able to execute and ensure that when they use your base templates, you can never

549
00:33:03,212 --> 00:33:06,914
do these particular behaviors, or you always do these particular behaviors

550
00:33:06,962 --> 00:33:10,518
in every job. So there's some immense power there that you

551
00:33:10,524 --> 00:33:13,658
can begin to codify your best practices in your organization right into your

552
00:33:13,664 --> 00:33:17,446
CI CD pipeline. And so with these benefits then of inheritance

553
00:33:17,558 --> 00:33:20,966
and composition, think about some of the things that we're gaining

554
00:33:20,998 --> 00:33:25,082
out of this, right. Here's an example of a template that

555
00:33:25,136 --> 00:33:28,510
would, or I should say a pipeline that uses templates to do

556
00:33:28,580 --> 00:33:32,158
some really powerful behaviors. So we have a base templates that's getting us some

557
00:33:32,164 --> 00:33:35,534
security and best practices and default variables and everything into

558
00:33:35,572 --> 00:33:38,946
our ecosystem. We then have a build stage where

559
00:33:38,968 --> 00:33:41,922
we're including context and versioning that was just standard.

560
00:33:42,056 --> 00:33:45,586
We might have a Java application. So we pull in the java specific template of

561
00:33:45,608 --> 00:33:49,326
how we standardize our approach. We're telling it the docker

562
00:33:49,358 --> 00:33:52,118
file and the build command. So that way I don't have to worry about that.

563
00:33:52,204 --> 00:33:55,526
I can still apply customizations through post build steps if I want to

564
00:33:55,548 --> 00:33:59,318
codify that as a parameter, and then I can deploy very declaratively because

565
00:33:59,324 --> 00:34:02,762
I have all this pre baked and ready to go and use it multiple times

566
00:34:02,816 --> 00:34:06,122
to deploy either to dev or to prod using the exact

567
00:34:06,176 --> 00:34:09,546
same logic that I can guarantee since it's using the same template. So when

568
00:34:09,568 --> 00:34:12,886
we talk about these ideas around appropriate coupling, appropriate coupling,

569
00:34:12,918 --> 00:34:16,906
remember the dimensions of the architecture that should be coupled together to provide maximum

570
00:34:16,938 --> 00:34:20,126
benefit with minimal overhead and cost. And that's exactly what we've done here

571
00:34:20,148 --> 00:34:23,886
is applied the principles of appropriate coupling to create something that allows us to

572
00:34:23,908 --> 00:34:27,634
maintain it easier over time and provide value to

573
00:34:27,672 --> 00:34:31,166
the consumers of it. And this is all about removing undifferentiated

574
00:34:31,198 --> 00:34:35,310
engineering. A lot of this stuff. Why do teams have to continually reinvent the wheel

575
00:34:35,390 --> 00:34:38,646
or rebuild how I version or how I are

576
00:34:38,668 --> 00:34:42,374
going to authenticate to private repositories or build my

577
00:34:42,412 --> 00:34:46,054
app, which is always built the same way, and in the name of

578
00:34:46,092 --> 00:34:49,426
platform engineering, which we're all kind of moving towards these days, and internal

579
00:34:49,458 --> 00:34:52,806
developer platforms, what a great way to build and compose

580
00:34:52,838 --> 00:34:56,166
and maintain templates for how you deploy effectively to your internal

581
00:34:56,198 --> 00:35:00,214
developer. And so I think this is a great developer experience that offers fantastic

582
00:35:00,262 --> 00:35:03,706
productivity. And this is all about the ideas

583
00:35:03,738 --> 00:35:07,086
of evolutionary architecture as well. If you're not familiar with that term. It's an

584
00:35:07,108 --> 00:35:10,826
evolutionary architecture supports guided incremental change across multiple dimensions.

585
00:35:10,938 --> 00:35:14,238
And so this is about guiding incrementally our teams being able

586
00:35:14,244 --> 00:35:18,226
to add functionality over time and also maintain and

587
00:35:18,248 --> 00:35:20,786
help them worry about the things they need to work with, which is getting their

588
00:35:20,808 --> 00:35:24,434
value to production, not all these little tidbits about how to do so.

589
00:35:24,632 --> 00:35:27,918
So with that in mind, here's an example architecture. I'll show you how we do

590
00:35:27,944 --> 00:35:31,160
this a little bit at SPS commerce based on what we've learned so far.

591
00:35:31,530 --> 00:35:35,362
And so here's a state of the union or a state of overview

592
00:35:35,426 --> 00:35:38,962
for SPS commerce and how we think about Azure DevOps.

593
00:35:39,026 --> 00:35:42,860
We have 60 plus projects, we have 40 plus teams now,

594
00:35:43,470 --> 00:35:46,634
closer probably now to 500 users in the last little

595
00:35:46,672 --> 00:35:49,302
bit. We run 500 daily pipelines,

596
00:35:49,366 --> 00:35:53,342
15,000 monthly deploys, and we

597
00:35:53,396 --> 00:35:56,526
run over 1300 monthly production deploys as well.

598
00:35:56,628 --> 00:35:59,934
We are running the classic ecosystem, some definitions, but most

599
00:35:59,972 --> 00:36:03,802
importantly we're using these templates to roll out over 2000 pipeline

600
00:36:03,866 --> 00:36:07,730
definitions today that our teams are participating in. And so our design

601
00:36:07,800 --> 00:36:11,186
goals and requirements and constraints as we got into this were much as we've talked

602
00:36:11,208 --> 00:36:14,206
about we wanted to eliminate team management and infrastructure,

603
00:36:14,318 --> 00:36:17,534
eliminate redundant CI CD feature implementation that we saw teams

604
00:36:17,582 --> 00:36:20,726
doing. We wanted a single tool for building and deploying where we

605
00:36:20,748 --> 00:36:24,166
could compose a pipeline in Yaml that went from build and

606
00:36:24,188 --> 00:36:27,458
everything. I need to drive context all the way through to declaratively deploying

607
00:36:27,554 --> 00:36:31,366
the components. We were tired of click Ops, which classic

608
00:36:31,398 --> 00:36:34,700
releases was great, but there's way too much clicking around in there.

609
00:36:35,070 --> 00:36:38,666
And of course we needed something as flexible for polygon ecosystem, so we could build

610
00:36:38,688 --> 00:36:42,186
different templates for Java or for. Net or for

611
00:36:42,208 --> 00:36:45,646
python and different web frameworks in there. And we wanted to build

612
00:36:45,668 --> 00:36:49,114
custom workflows and orchestration and governance. We knew we wanted to adapt these pipelines

613
00:36:49,162 --> 00:36:52,574
and build in change management, automation and other capabilities around

614
00:36:52,612 --> 00:36:56,526
our deployment to make it easy and simple for our teams. Of course,

615
00:36:56,708 --> 00:36:59,790
most important that we just talked about, it has to be evolvable and incremental,

616
00:36:59,870 --> 00:37:03,918
right? We didn't start from nothing and then build everything. We started very slowly

617
00:37:03,934 --> 00:37:07,474
and built some very simple templates that provided us what we needed and built

618
00:37:07,512 --> 00:37:11,430
on it from there. And we're able to provide additional functionality to teams over time

619
00:37:11,580 --> 00:37:14,918
very easily. So our template composition looks a

620
00:37:14,924 --> 00:37:18,118
lot like this. Where we have a base template, we version that,

621
00:37:18,204 --> 00:37:21,670
we have a context job that establishes who's asking

622
00:37:21,740 --> 00:37:25,254
for this build. How do I cost this build? What cpu is it related

623
00:37:25,302 --> 00:37:28,426
to? What are some of the variables I might want to gather as a part

624
00:37:28,448 --> 00:37:31,962
of this to make available? And so that allows our teams to very easily access

625
00:37:32,096 --> 00:37:36,126
slack channels and a bunch of other information as a part of their build that

626
00:37:36,148 --> 00:37:39,662
isn't normally part of Azure DevOps that we've now added. That is

627
00:37:39,716 --> 00:37:42,240
established through some root variables that are there.

628
00:37:42,850 --> 00:37:46,286
Code scanning in our case this is GitHub advanced security code scanning

629
00:37:46,318 --> 00:37:49,618
stages can be easily added and they can be

630
00:37:49,784 --> 00:37:53,438
in a couple of lines of syntax. You can have your application being scanned.

631
00:37:53,454 --> 00:37:57,246
For security perspective, we have different build stages for different components,

632
00:37:57,278 --> 00:38:01,046
especially a UI standardization where we build our UI applications and

633
00:38:01,068 --> 00:38:04,406
static assets and cdns in a very specific way that teams can

634
00:38:04,428 --> 00:38:07,826
just drop in and use with a couple of lines. And we have a fairly

635
00:38:07,858 --> 00:38:11,206
complex deploy stage and templates inside of

636
00:38:11,228 --> 00:38:14,346
templates here. So the base templates is a requirement to use the

637
00:38:14,368 --> 00:38:17,926
rest of these because the rest of these templates rely on variables

638
00:38:17,958 --> 00:38:21,606
that are established in that base template. And similarly we have a deploy workflow

639
00:38:21,638 --> 00:38:25,882
stage, which is a general deployment workflow and it has specific environment

640
00:38:25,946 --> 00:38:29,626
variables for the environment you're deploying to. And then we have a specific deploy

641
00:38:29,658 --> 00:38:32,858
job and it has a deploy workflow job. And there's,

642
00:38:33,034 --> 00:38:36,786
as you can see, a fairly complex tree structure that

643
00:38:36,808 --> 00:38:40,706
you can walk through in order to develop the reusability of your

644
00:38:40,728 --> 00:38:44,514
pipelines, but it can be very helpful to do

645
00:38:44,552 --> 00:38:48,770
so. So you're not having that logic copied, even in multiple spots within

646
00:38:48,840 --> 00:38:52,134
your repository for templates. A lot of these are

647
00:38:52,172 --> 00:38:55,526
not available to teams to use. These are like internal templates and really

648
00:38:55,548 --> 00:38:58,834
they're just using the top level templates. So the base templates and the deploy

649
00:38:58,882 --> 00:39:02,058
stage and the build stages, the rest is kind of built and included as a

650
00:39:02,064 --> 00:39:05,334
part of those automatically for you. We also have a documentation

651
00:39:05,382 --> 00:39:09,626
deploy stage, which again makes use of the deploy workflow in

652
00:39:09,648 --> 00:39:13,206
order to add documentation tasks. This makes it really easy for teams

653
00:39:13,238 --> 00:39:17,262
to get up and start running. And our pipelines look much like this today,

654
00:39:17,316 --> 00:39:21,520
where they can just compositionally add in the right components and build that together

655
00:39:21,890 --> 00:39:24,814
for what they're doing. Some considerations though,

656
00:39:24,852 --> 00:39:28,242
like I mentioned, we didn't start this from day one.

657
00:39:28,296 --> 00:39:31,838
We didn't build up that level of complexity on those templates. You don't

658
00:39:31,854 --> 00:39:35,502
want to start with the great pyramid. You can start with some compositional

659
00:39:35,566 --> 00:39:39,026
templates that add functionality, and I think you'll find that engineers will

660
00:39:39,048 --> 00:39:41,958
want to engage once you get a little bit of momentum and seeing like,

661
00:39:41,964 --> 00:39:44,674
oh, you mean I can just drop this in and it knows how to handle

662
00:39:44,722 --> 00:39:48,386
this functionality or this feature of the pipeline? Yeah, let me start including

663
00:39:48,418 --> 00:39:52,694
those. You'll establish a base for how you can start putting together that base templates

664
00:39:52,822 --> 00:39:56,746
and rolling out a bit broader. Some questions we're still figuring out,

665
00:39:56,848 --> 00:40:00,218
how far do you abstract some of these templates? Is abstracting too much knowledge a

666
00:40:00,224 --> 00:40:03,418
bad thing? What about retirement and deprecation of the templates and how

667
00:40:03,424 --> 00:40:06,782
to think about that like we do with major API versions. And of course

668
00:40:06,836 --> 00:40:10,174
there's lots of components inside Azure DevOps that you can take advantage of,

669
00:40:10,212 --> 00:40:13,982
including deployment jobs and the deployment job strategies that it presents you.

670
00:40:14,036 --> 00:40:17,038
And so it'll be really interesting to see how you take advantage of some of

671
00:40:17,044 --> 00:40:20,146
these templating capabilities. But one of my favorite things to look

672
00:40:20,168 --> 00:40:22,866
at is the law of diminishing returns in this type of situation. If you're not

673
00:40:22,888 --> 00:40:26,306
familiar with it, it's a principle stating that profits or benefits gained from

674
00:40:26,328 --> 00:40:29,838
something will represent a proportionally smaller gain as more money or

675
00:40:29,864 --> 00:40:33,446
energy is invested in. And I think that's very true with duplicating pipelines where once

676
00:40:33,468 --> 00:40:37,126
we start copying those and then you have a small change to make to

677
00:40:37,148 --> 00:40:40,298
one and you have 100 of those resources and you have to make changes to

678
00:40:40,304 --> 00:40:43,846
them all. It's really, really frustrating. So you need to look at abstracting

679
00:40:43,958 --> 00:40:47,146
that reusable content to something

680
00:40:47,168 --> 00:40:50,486
into a reusable pipeline. And of course reusable pipelines we see as the opposite.

681
00:40:50,518 --> 00:40:54,266
We see an initial cost, yes, is the same, and to even make

682
00:40:54,288 --> 00:40:57,706
it reusable one time is this high cost that might even skyrocket higher than what's

683
00:40:57,738 --> 00:41:01,434
shown here. But of course, over time we see that paying many, many dividends

684
00:41:01,482 --> 00:41:05,060
as there's updates and changes to make, it cost me less and less.

685
00:41:05,670 --> 00:41:09,694
And so thanks for chatting with me today about CI CD efficiency

686
00:41:09,822 --> 00:41:13,394
and reusable templates. If there's any takeaway you have from today, it's that

687
00:41:13,432 --> 00:41:17,106
the progression towards yaML templates and workflows that you

688
00:41:17,128 --> 00:41:20,674
can reuse not just within your team but across your organization are pivotal,

689
00:41:20,722 --> 00:41:24,534
especially as we start to connect ideas around platform engineering and

690
00:41:24,572 --> 00:41:27,814
some of that productivity capabilities. And I like this

691
00:41:27,852 --> 00:41:31,542
quote as well, which talks about the idea of software invisibility. When done

692
00:41:31,596 --> 00:41:35,238
well, software is invisible and your templates can be invisible to your teams that need

693
00:41:35,244 --> 00:41:38,246
to use them and that's when they're best positioned. And so when we talk about

694
00:41:38,268 --> 00:41:42,650
invisibility, we think about templates invisibility technique of azure pipelines.

695
00:41:42,810 --> 00:41:46,266
We didn't have time to talk about environments, approvals and checks and custom tasks.

696
00:41:46,298 --> 00:41:49,678
These are other techniques that you can use as a part of your

697
00:41:49,684 --> 00:41:53,018
templates in order to customize it to an even further degree. And I would encourage

698
00:41:53,034 --> 00:41:56,718
you to explore those next from here on out. But thanks and I

699
00:41:56,724 --> 00:41:59,370
hope you have a great conference and you find this information useful.

