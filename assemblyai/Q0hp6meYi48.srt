1
00:00:27,090 --> 00:00:30,310
Hi everyone. Welcome. So my talk is called

2
00:00:30,380 --> 00:00:33,490
let's make a pacts. Don't break my API.

3
00:00:33,570 --> 00:00:36,818
So I generally like to start this with a little bit of an icebreaker,

4
00:00:36,914 --> 00:00:40,898
kind of difficult in a virtual situation, but I just like you to reflect

5
00:00:40,994 --> 00:00:44,774
and see if you've ever been in a situation where you

6
00:00:44,812 --> 00:00:48,598
have broken an API for one of your consumers. And I definitely

7
00:00:48,684 --> 00:00:52,570
fall into that category. I've done that on numerous occasions.

8
00:00:52,730 --> 00:00:56,830
And maybe on the flip side of that situation, have you ever had a case

9
00:00:56,900 --> 00:01:00,494
where you've built out a client, you're depending on one or

10
00:01:00,532 --> 00:01:04,666
multiple APIs, and suddenly an API that you depend on stops

11
00:01:04,698 --> 00:01:08,142
working or starts behaving differently and you've received no communication

12
00:01:08,206 --> 00:01:12,194
from the API provider? Again, I've felt that pain more than

13
00:01:12,232 --> 00:01:15,746
once. So what I'm going to talk about today is really how

14
00:01:15,768 --> 00:01:19,874
to address that challenge. So how can we promote features

15
00:01:19,922 --> 00:01:23,058
through our APIs and evolve our APIs safely?

16
00:01:23,234 --> 00:01:26,514
And we'll look at the relationship between the provider and the consumer

17
00:01:26,562 --> 00:01:30,474
and the expectations that exist on both sides in the

18
00:01:30,512 --> 00:01:32,330
modern API landscape.

19
00:01:33,950 --> 00:01:37,686
So a little bit about me my name is Frank Kilcommins.

20
00:01:37,718 --> 00:01:41,114
I'm an API technical evangelist at Smartbear. I'm a software

21
00:01:41,162 --> 00:01:44,222
engineer and software architect by trade, and I'm very

22
00:01:44,276 --> 00:01:47,994
passionate about APIs and the developer experience surrounding

23
00:01:48,042 --> 00:01:51,690
APIs. And to explore the challenges

24
00:01:51,770 --> 00:01:55,166
that kind of I've laid out at the start, what I'll

25
00:01:55,188 --> 00:01:58,322
aim to do is just kind of take a brief look at what's happening across

26
00:01:58,376 --> 00:02:01,886
the API landscape and why things are probably going to get harder

27
00:02:01,918 --> 00:02:05,518
for all of us. We'll look at then how can you design

28
00:02:05,624 --> 00:02:09,078
for future feature promotion through your APIs and

29
00:02:09,084 --> 00:02:12,214
how you can do that safely? We'll maybe critically look

30
00:02:12,252 --> 00:02:15,766
at extensibility. So good extensibility patterns and can

31
00:02:15,788 --> 00:02:19,402
you succeed with extensibility alone? And probably

32
00:02:19,456 --> 00:02:22,986
the TLDR hint here is that you probably

33
00:02:23,088 --> 00:02:26,982
can't. So I'll introduce the concept of bidirectional contract

34
00:02:27,046 --> 00:02:30,374
testing and we'll explore how that can help us safely

35
00:02:30,422 --> 00:02:33,998
evolve APIs. I'll run through a demo showcasing how you

36
00:02:34,004 --> 00:02:37,742
can get started, what it's all about, and then hopefully you'll be able to leave

37
00:02:37,796 --> 00:02:41,594
the conference and leave this talk with some takeaways and a good understanding

38
00:02:41,642 --> 00:02:44,050
around bi directional contract testing.

39
00:02:45,190 --> 00:02:48,498
So microservices are everywhere. Of course, I think for most of

40
00:02:48,504 --> 00:02:52,002
us that have been involved or are involved in APIs or

41
00:02:52,056 --> 00:02:55,918
just general web development, we've seen the exponential growth

42
00:02:55,934 --> 00:02:59,142
of microservices and APIs over the last number

43
00:02:59,196 --> 00:03:02,326
of years. And we can look at all

44
00:03:02,348 --> 00:03:05,682
of the industry reports that come out, the ones that we produce ourselves

45
00:03:05,746 --> 00:03:09,354
at Smartbear, as well as those by our peers across the

46
00:03:09,392 --> 00:03:13,402
industry, like over at Postman. And we see that microservices are

47
00:03:13,456 --> 00:03:17,414
indeed identified as being the main catalyst for the continued growth

48
00:03:17,462 --> 00:03:21,146
across the API landscape. They're really more than

49
00:03:21,168 --> 00:03:24,606
just a fad. So for any of you that might follow kind

50
00:03:24,628 --> 00:03:27,834
of industry analysts like Gartner, you might be familiar

51
00:03:27,882 --> 00:03:31,214
with hype cycles and microservices really have left

52
00:03:31,252 --> 00:03:35,294
the threat of disillusionment. So we're seeing this continued shift

53
00:03:35,422 --> 00:03:38,754
within the most and the majority of organizations from

54
00:03:38,792 --> 00:03:42,398
kind of monolithic architectures to more consumable and capability

55
00:03:42,494 --> 00:03:46,230
focused architectures. And that's where microservices are, of course, very well

56
00:03:46,300 --> 00:03:49,986
suited. They help us unlock the value and the capabilities that's

57
00:03:50,018 --> 00:03:53,606
potentially hidden away within internal systems. So there's more and

58
00:03:53,628 --> 00:03:57,382
more of them being created and managing that

59
00:03:57,436 --> 00:04:01,234
increasing number of APIs and microservices is getting

60
00:04:01,292 --> 00:04:04,966
harder. And it's something that's often referred to as API sprawl.

61
00:04:05,078 --> 00:04:08,474
Now to deal with it. Up until this point in time, most of us

62
00:04:08,512 --> 00:04:11,902
have relied on traditional API management approaches to perform

63
00:04:12,036 --> 00:04:15,754
important activities, from acting as a central catalog

64
00:04:15,802 --> 00:04:19,502
for our APIs to improve discoverability, even enforcing base

65
00:04:19,556 --> 00:04:23,054
levels of assurance on the API. So the minimum amount of

66
00:04:23,092 --> 00:04:26,962
security that must be honored in order for the gateway to be able to process

67
00:04:27,016 --> 00:04:30,558
and pass through that API request, also acting as a hub

68
00:04:30,654 --> 00:04:34,482
for documentation and maybe even most importantly, acting as that

69
00:04:34,536 --> 00:04:38,258
matrix where we can go to, to understand what consumers

70
00:04:38,354 --> 00:04:41,862
are consuming and relying on what APIs and having

71
00:04:41,916 --> 00:04:45,798
kind of also that place where we can go, or that standard process

72
00:04:45,884 --> 00:04:49,660
for authorizing permissions towards APIs and services themselves.

73
00:04:50,030 --> 00:04:53,542
And if you're not experiencing any problem with API management

74
00:04:53,606 --> 00:04:57,322
as you stand today, then the chances are that you probably will in the near

75
00:04:57,376 --> 00:05:01,302
to midterm future. So more microservices

76
00:05:01,366 --> 00:05:04,622
will be created within your organization. And if we look at what

77
00:05:04,676 --> 00:05:08,462
Gartner are saying, they're saying the chances are as much as 50%

78
00:05:08,516 --> 00:05:11,850
of microservices will not be managed by traditional

79
00:05:11,930 --> 00:05:14,754
API management tooling by the year 2025.

80
00:05:14,872 --> 00:05:18,926
So that means there's a high risk that they will become zombie APIs,

81
00:05:19,038 --> 00:05:21,630
ones that are potentially poorly maintained,

82
00:05:21,790 --> 00:05:25,406
susceptible to security vulnerabilities. And more shadow

83
00:05:25,438 --> 00:05:29,206
APIs will pop up because we'll lose track of what APIs are

84
00:05:29,228 --> 00:05:32,402
there. So we'll reinvent the wheel within our organizations.

85
00:05:32,546 --> 00:05:36,390
The cognitive load, unfortunately for keeping track of all of this will fall

86
00:05:36,460 --> 00:05:40,490
upon the teams and it can be very, very easy

87
00:05:40,560 --> 00:05:44,634
to lose track quite quickly. And losing track and not being

88
00:05:44,672 --> 00:05:47,978
aware of who's consuming your APIs can in fact cause

89
00:05:48,064 --> 00:05:51,258
a blindness. And that has several implications. And the

90
00:05:51,264 --> 00:05:54,318
one I'm going to focus on in this talk today is that it's going to

91
00:05:54,324 --> 00:05:58,000
make the safe evolution of your APIs much more difficult.

92
00:05:59,330 --> 00:06:02,366
Now, one of the fundamental ways that we do our

93
00:06:02,388 --> 00:06:06,210
best to not break APIs and to introduce new changes

94
00:06:06,280 --> 00:06:10,318
and new features through APIs is to have strong design practices.

95
00:06:10,494 --> 00:06:13,726
Design first as an approach for microservices and APIs,

96
00:06:13,838 --> 00:06:17,458
ensures kind of thoughtful and let's

97
00:06:17,474 --> 00:06:21,222
say well defined and agreed design before

98
00:06:21,276 --> 00:06:24,726
we go and implement anything. And the earlier you can

99
00:06:24,748 --> 00:06:28,966
bake extensibility as a practice into your API delivery

100
00:06:28,998 --> 00:06:32,422
machine, the more likely it is that you will have long living APIs.

101
00:06:32,486 --> 00:06:36,182
And longevity is a good indicator. It's a good trait

102
00:06:36,246 --> 00:06:40,006
of a successful API. And here's

103
00:06:40,038 --> 00:06:43,850
kind of a little cheat sheet for API extensibility.

104
00:06:44,010 --> 00:06:47,486
And the first one is think about APIs from the

105
00:06:47,508 --> 00:06:51,354
outside in. So think about the consumer experience and what the consumer

106
00:06:51,402 --> 00:06:55,674
needs, and make sure that API that you're delivering is solving that consumer

107
00:06:55,722 --> 00:06:59,446
problem. Use specifications so ones like open API

108
00:06:59,498 --> 00:07:03,074
to describe the surface area and focus on good documentation to allow

109
00:07:03,112 --> 00:07:05,910
the consuming developers to ramp up as quickly as possible,

110
00:07:06,060 --> 00:07:10,242
effectively treating them like a product. Insofar as that you're prioritizing

111
00:07:10,306 --> 00:07:14,342
discoverability, usefulness and usability as

112
00:07:14,476 --> 00:07:18,034
attributes that will really aid and promote

113
00:07:18,162 --> 00:07:21,306
the adoption of your APIs and make it easier for them

114
00:07:21,328 --> 00:07:25,334
to be used and reused, because APIs that existing and are not consumed

115
00:07:25,382 --> 00:07:28,662
are absolutely useless. Moving more onto the tactile

116
00:07:28,726 --> 00:07:32,058
side of kind of things that I would recommend to do. What you need to

117
00:07:32,064 --> 00:07:35,486
do is define your extension points. And what I mean by that is that

118
00:07:35,508 --> 00:07:39,258
you will advertise to your consumers what parts of the API

119
00:07:39,354 --> 00:07:43,034
are stable versus what parts are maybe newer,

120
00:07:43,082 --> 00:07:46,290
maybe mvp, and they're more susceptible to change

121
00:07:46,360 --> 00:07:49,874
in the near term. So don't be afraid to communicate that upfront with your

122
00:07:49,912 --> 00:07:53,810
consumers. It can really go a long way to set the expectations,

123
00:07:54,470 --> 00:07:58,514
then communicate also an extensibility pattern.

124
00:07:58,642 --> 00:08:02,454
So by that I mean you should inform your consumers the

125
00:08:02,492 --> 00:08:05,794
rules that you would like them to follow if they encounter

126
00:08:05,922 --> 00:08:09,302
something new that they haven't seen before and must

127
00:08:09,356 --> 00:08:13,530
ignore, is probably the most common extensibility pattern out there. So that

128
00:08:13,600 --> 00:08:17,274
means that you want your clients to be tolerant, so you're informing them to

129
00:08:17,312 --> 00:08:20,380
say if you encounter something that you do not understand,

130
00:08:20,750 --> 00:08:24,782
then you must ignore it. Your client implementation must not break

131
00:08:24,916 --> 00:08:27,902
just because you do not understand something new.

132
00:08:28,036 --> 00:08:31,166
And then we'll do our work on the provider side to

133
00:08:31,188 --> 00:08:34,830
make sure that anything that we introduce is safe and it's a backwards

134
00:08:34,910 --> 00:08:38,222
compatible change, and it will not materially impact

135
00:08:38,286 --> 00:08:42,270
the functionality of what was there in the previous minor version.

136
00:08:42,430 --> 00:08:46,134
And then when I get onto that concept of minor versions, I think having

137
00:08:46,172 --> 00:08:49,810
a well defined and clearly communicated versioning strategy

138
00:08:49,890 --> 00:08:53,766
is good practice, and it's almost a base expectation on

139
00:08:53,788 --> 00:08:57,222
a consumer side. And semantic versioning is probably the most

140
00:08:57,276 --> 00:09:00,746
well known out there. And that sets again a clear expectation as

141
00:09:00,768 --> 00:09:04,582
to how you deal with patches, how you deal with minor backwards

142
00:09:04,646 --> 00:09:07,914
compatibility changes, and then how you also will deal

143
00:09:07,952 --> 00:09:11,366
with a breaking change. If in fact you have to make a breaking

144
00:09:11,398 --> 00:09:15,166
change to your API, testing for extensibility is great.

145
00:09:15,268 --> 00:09:19,374
Can you then even make it possible for your clients to peek ahead and

146
00:09:19,412 --> 00:09:22,766
test their client implementations to see if they're going to work with the

147
00:09:22,788 --> 00:09:26,434
next version of the API that you're about to roll out, and above all,

148
00:09:26,472 --> 00:09:30,354
communicate. So for each one of these points, communicate every

149
00:09:30,392 --> 00:09:33,762
time you make a change to your API, make sure you have a change

150
00:09:33,816 --> 00:09:38,258
log. Use that change log as a way to connect again with your consumers

151
00:09:38,354 --> 00:09:42,102
to pitch the value of the new features that you're adding and

152
00:09:42,236 --> 00:09:45,414
create that sense of fomo on their side and really pull

153
00:09:45,452 --> 00:09:48,710
them along with you throughout your API journey.

154
00:09:49,790 --> 00:09:53,542
On the don't side, most of these are very self explanatory,

155
00:09:53,606 --> 00:09:57,386
but don't add required inputs to the API because

156
00:09:57,408 --> 00:10:00,598
that would be a breaking change of course. Don't remove outputs

157
00:10:00,614 --> 00:10:04,078
or make them optional. Don't change the type of a property.

158
00:10:04,164 --> 00:10:07,946
So if you have a string today, make sure it's not can int tomorrow,

159
00:10:08,058 --> 00:10:11,502
and then jumping to the last one. Don't be

160
00:10:11,556 --> 00:10:15,682
inconsistent in your process. So every single time you're going through either

161
00:10:15,736 --> 00:10:19,326
an Apache fix, a bug fix, or a new feature enhancement

162
00:10:19,358 --> 00:10:23,154
to your API, follow a consistent process every

163
00:10:23,192 --> 00:10:26,882
single time. So if you do this, if you bake good extensibility

164
00:10:26,946 --> 00:10:30,182
hygiene into your API practices, if you're really

165
00:10:30,236 --> 00:10:33,926
thoughtful around the evolvability attributes, are you

166
00:10:33,948 --> 00:10:36,866
going to be successful? Well, unfortunately,

167
00:10:37,058 --> 00:10:40,714
probably not. So extensibility alone will

168
00:10:40,752 --> 00:10:44,074
not guarantee success. You can only achieve so much with

169
00:10:44,112 --> 00:10:47,802
interface design, no matter how good it is. And even with really

170
00:10:47,856 --> 00:10:51,114
solid extensibility techniques, the chances

171
00:10:51,162 --> 00:10:54,462
are that you will, in some shape or form break

172
00:10:54,516 --> 00:10:58,314
the expectations on a client side. And API

173
00:10:58,362 --> 00:11:02,074
design in general is a skill that's probably lacking

174
00:11:02,122 --> 00:11:05,434
to a certain degree within the landscape or within the API

175
00:11:05,482 --> 00:11:08,914
space. And that's showing up in some of the industry surveys that are out

176
00:11:08,952 --> 00:11:12,338
there as well. So there's a lack of good API designers in

177
00:11:12,344 --> 00:11:16,286
the market, which means it's more difficult for us to achieve high levels of good

178
00:11:16,328 --> 00:11:19,814
extensibility design. That doesn't mean that you

179
00:11:19,852 --> 00:11:23,922
shouldn't follow kind of the cheat sheet or the best practices with regards to extensibility.

180
00:11:23,986 --> 00:11:27,442
You absolutely should, because of course, good extensibility,

181
00:11:27,586 --> 00:11:31,494
good design hygiene allow us to hope for the best for a decent period of

182
00:11:31,532 --> 00:11:34,986
time. But with the acceleration of microservices growth across the

183
00:11:35,008 --> 00:11:38,586
landscape, we also need to be able to prepare for the worst. And we

184
00:11:38,608 --> 00:11:41,582
need to be aware of what's known as Hiram's law.

185
00:11:41,716 --> 00:11:45,242
And Hiram's law is, and I'll paraphrase,

186
00:11:45,306 --> 00:11:48,746
it's with a sufficient number of users of your API,

187
00:11:48,858 --> 00:11:52,666
it doesn't really matter what you promise in that interface design

188
00:11:52,788 --> 00:11:56,722
contract, all observable behavior of your

189
00:11:56,776 --> 00:12:00,658
system will be depended on by somebody. And that absolutely happens.

190
00:12:00,744 --> 00:12:03,982
So you will have some maybe undocumented behavior

191
00:12:04,046 --> 00:12:07,682
within your API that will be understood by consumers and they'll expect

192
00:12:07,816 --> 00:12:12,066
that that will continue to behave like that. And if that potentially was unintended,

193
00:12:12,098 --> 00:12:15,750
and you then address that, whats potentially could be a breaking change for someone,

194
00:12:15,820 --> 00:12:19,306
even though from a provider perspective you've never advertised that the

195
00:12:19,328 --> 00:12:23,302
API was meant to behave in that particular way. And the years

196
00:12:23,366 --> 00:12:27,222
of this can paralyze many providers.

197
00:12:27,286 --> 00:12:30,842
And we have a problem in the industry with major version

198
00:12:30,906 --> 00:12:35,322
proliferation. So as we lose track of who's consuming an API,

199
00:12:35,466 --> 00:12:39,070
what their explicit expectations are, it can

200
00:12:39,220 --> 00:12:42,702
really cause a little bit of a paralyzing effect

201
00:12:42,756 --> 00:12:46,686
on the API provider side. And then there's a knee jerk jerk reaction.

202
00:12:46,718 --> 00:12:50,062
Conf 42 create a major version of your API,

203
00:12:50,126 --> 00:12:53,634
which basically is saying, hey, we're not sure if

204
00:12:53,672 --> 00:12:57,222
this change is breaking or not. So to be safe, we'll create

205
00:12:57,276 --> 00:13:00,726
another version to make sure that any clients that are still connected to the

206
00:13:00,748 --> 00:13:05,094
previous version will remain up and running. And having

207
00:13:05,212 --> 00:13:08,362
multiple, but yet different versions of the same

208
00:13:08,416 --> 00:13:11,926
API incurs real costs on the team. It incurs

209
00:13:11,958 --> 00:13:15,386
cognitive costs with regards to be able to manage these things,

210
00:13:15,488 --> 00:13:19,450
but it also causes actual real costs for teams.

211
00:13:20,450 --> 00:13:25,306
So it's important to kind of break that in mind. So major version proliferation

212
00:13:25,418 --> 00:13:28,666
is a cost problem also for organizations,

213
00:13:28,778 --> 00:13:31,982
and that cost can be felt also on the

214
00:13:32,036 --> 00:13:35,474
testing side of, let's say the

215
00:13:35,512 --> 00:13:39,326
IT teams and the API teams. So zooming in on testing

216
00:13:39,438 --> 00:13:42,978
for a moment I think it's worth noting that if you're also

217
00:13:43,064 --> 00:13:46,422
employing the same testing strategy as you're maybe moving

218
00:13:46,476 --> 00:13:50,418
from a monolithic architecture over towards a microservices architecture,

219
00:13:50,514 --> 00:13:54,262
then probably you will not be successful. So delivering new

220
00:13:54,316 --> 00:13:57,682
value with the appropriate return on investment will

221
00:13:57,756 --> 00:14:01,606
be something that's hard to achieve. And what's

222
00:14:01,638 --> 00:14:05,974
depicted here is a very simplistic picture. So we have a consumer component

223
00:14:06,102 --> 00:14:10,246
and that is connecting and relying with an underlying

224
00:14:10,358 --> 00:14:13,934
microservice, called microservice one. And if I was to

225
00:14:13,972 --> 00:14:17,146
continue to employ, for example, an end to end testing

226
00:14:17,178 --> 00:14:20,794
strategy, which I was quite comfortable with in a monolithic architectural

227
00:14:20,842 --> 00:14:24,506
approach, and apply this to this specific setup

228
00:14:24,538 --> 00:14:28,210
which is depicted here, then every time I would want to make a small change

229
00:14:28,280 --> 00:14:32,142
to the consumer, I would have to stand up all of the underlying

230
00:14:32,206 --> 00:14:36,186
components in order to be able to execute those end to end tests.

231
00:14:36,318 --> 00:14:39,830
And I would also need to be able to manage all of the contextual data

232
00:14:39,900 --> 00:14:43,030
to allow those tests to run effectively.

233
00:14:43,770 --> 00:14:47,494
And that is a very costs exercise and

234
00:14:47,532 --> 00:14:51,110
it leads to what I call an unbalanced

235
00:14:51,190 --> 00:14:53,910
testing pyramid and testing approach.

236
00:14:53,990 --> 00:14:57,798
So if we're over relying on integration testing and into in testing,

237
00:14:57,894 --> 00:15:01,082
the testing pyramid is not really in hits

238
00:15:01,136 --> 00:15:05,226
optimal setup, especially for microservices. So it's expensive

239
00:15:05,338 --> 00:15:09,594
to set up and maintain all of the underlying components and infrastructure.

240
00:15:09,722 --> 00:15:13,022
It's also slow to get feedback. So you might be waiting for

241
00:15:13,156 --> 00:15:16,402
30 minutes, even more for that pipeline to run

242
00:15:16,456 --> 00:15:20,606
in order to get the feedback that you want. It's unreliable. So managing

243
00:15:20,638 --> 00:15:24,334
all of that context and that data can lead to us ignoring

244
00:15:24,382 --> 00:15:28,594
failures. So have any of you ever been in the situation where you

245
00:15:28,632 --> 00:15:32,018
make changes, you run the tests, a test fails.

246
00:15:32,114 --> 00:15:35,494
You weren't really expecting that test to fail because it's not relating to the change

247
00:15:35,532 --> 00:15:39,302
that you made. You run it again, it passes. So then you're saying,

248
00:15:39,356 --> 00:15:42,694
yes, great, we can proceed. So what that actually means is that you've lost

249
00:15:42,742 --> 00:15:46,154
all confidence in the ability for your tests to be

250
00:15:46,192 --> 00:15:50,026
relied upon. So you really have an unreliable and

251
00:15:50,048 --> 00:15:53,934
expensive approach, and you also have an

252
00:15:53,972 --> 00:15:58,554
approach that's not very started. So it's difficult to just test explicitly

253
00:15:58,602 --> 00:16:02,374
what you're changing. You really have to stand up a complex underlying

254
00:16:02,442 --> 00:16:07,246
environment and you can spend a lot of time investigating

255
00:16:07,438 --> 00:16:09,490
false positives.

256
00:16:11,110 --> 00:16:14,494
And this brings us then on to dependency management

257
00:16:14,542 --> 00:16:18,882
for microservices. So how can you manage the dependencies

258
00:16:18,946 --> 00:16:22,866
between all of the provider components, all of the consumer components,

259
00:16:22,898 --> 00:16:26,470
and manage those across the different environments? It can become

260
00:16:26,620 --> 00:16:30,570
quite a headache. So what I have here is a very simplified

261
00:16:32,510 --> 00:16:36,474
CI setup. So two CI pipelines. So this is just for

262
00:16:36,512 --> 00:16:40,300
example purposes, so two cis across

263
00:16:40,610 --> 00:16:44,526
three environments, the CI environment, the staging environment and a

264
00:16:44,548 --> 00:16:47,994
production environment. So when I say CI, think of continuous

265
00:16:48,042 --> 00:16:51,434
integration. So GitHub actions, Azure DevOps pipelines,

266
00:16:51,482 --> 00:16:55,250
Jenkins and so forth. So anytime someone commits a change,

267
00:16:55,400 --> 00:16:58,500
this process will be kicked off.

268
00:17:00,710 --> 00:17:04,754
And here, what we could expect is that once all

269
00:17:04,872 --> 00:17:09,170
checks and balances are passed, we will be able to safely promote

270
00:17:09,330 --> 00:17:13,462
changes through towards production. So you will see that I have different

271
00:17:13,516 --> 00:17:17,534
versions of consumers, different versions of providers between CI

272
00:17:17,602 --> 00:17:21,254
and production. So we're in the process of deploying some features

273
00:17:21,302 --> 00:17:24,726
and some enhancements towards production, and we're

274
00:17:24,758 --> 00:17:28,154
going through the process. Now, what we might

275
00:17:28,192 --> 00:17:31,974
expect is that at each point within these environments,

276
00:17:32,102 --> 00:17:35,374
we'd make sure that the version of the consumer conforms to the

277
00:17:35,412 --> 00:17:39,150
contract or the expectations with respect to the provider on the same

278
00:17:39,220 --> 00:17:42,738
environment. So for example, if we were to run tests on the

279
00:17:42,744 --> 00:17:45,714
CI environment, we would expect to say,

280
00:17:45,752 --> 00:17:50,014
whats consumer v three works well and is compatible

281
00:17:50,062 --> 00:17:53,986
with provider v three? If those tests pass, and then if

282
00:17:54,088 --> 00:17:57,294
other tests pass, maybe they're security tests,

283
00:17:57,342 --> 00:18:00,806
performance tests, whatever the case may be, then maybe we have enough to

284
00:18:00,828 --> 00:18:04,246
satisfy the gate requirements in order to be able to

285
00:18:04,268 --> 00:18:08,006
move and promote towards the staging environment. However, one of

286
00:18:08,028 --> 00:18:11,930
the aspects of microservices and of course communication in general,

287
00:18:12,000 --> 00:18:15,562
is that we don't want to have to promote all components at the same

288
00:18:15,616 --> 00:18:19,366
time. So for instance, if I just wanted to promote consumer

289
00:18:19,398 --> 00:18:22,966
v three in this case towards managing, without promoting

290
00:18:22,998 --> 00:18:26,126
the provider v three towards staging, what else would I need

291
00:18:26,148 --> 00:18:29,566
to check? Well, we'd also need to check, of course, that the

292
00:18:29,588 --> 00:18:32,826
consumer v three works with the version of the provider

293
00:18:32,858 --> 00:18:36,254
which is in staging, which is provider v two. And then equally,

294
00:18:36,302 --> 00:18:40,098
if we wanted to promote consumer v. Two from staging towards

295
00:18:40,184 --> 00:18:44,478
production, we'd also have to make sure that that version of the consumer is compatible

296
00:18:44,574 --> 00:18:48,146
with the version of the provider that's already promoted or deployed

297
00:18:48,178 --> 00:18:52,226
towards production. And what if the inverse

298
00:18:52,338 --> 00:18:56,230
was the case? What if we wanted to promote the provider without

299
00:18:56,380 --> 00:18:59,894
promoting the consumer? Well then of course we'd have to make sure

300
00:18:59,932 --> 00:19:03,446
that the provider v three and CI is compatible with consumer

301
00:19:03,478 --> 00:19:07,306
v two in staging provider v two and staging is compatible with

302
00:19:07,328 --> 00:19:10,774
consumer v one in production and so on and so forth.

303
00:19:10,902 --> 00:19:14,302
So you can see how quickly the complexity can

304
00:19:14,356 --> 00:19:18,302
be increased. And then if you multiply this by more environments, by many

305
00:19:18,356 --> 00:19:22,446
more components, you will get to a situation that can be very difficult

306
00:19:22,628 --> 00:19:26,466
to manage. And one of the things that we really want to do is make

307
00:19:26,488 --> 00:19:30,286
sure that we still can keep the flexibility to allow us to promote

308
00:19:30,318 --> 00:19:34,178
hot fixes, bug fixes and feature extensions without

309
00:19:34,264 --> 00:19:38,294
having to promote all components and all of the dependencies in

310
00:19:38,332 --> 00:19:41,874
lockstep. And this is of course one of the main areas

311
00:19:41,922 --> 00:19:45,874
that contract testing and bi directional contract testing as an approach

312
00:19:45,922 --> 00:19:49,126
can come in to help. And that's what I'm going to jump into now.

313
00:19:49,228 --> 00:19:52,940
But first, let me just plant something in your mind.

314
00:19:53,310 --> 00:19:56,618
And it's a quote from my colleague Beth Scurry, who's one of the

315
00:19:56,624 --> 00:20:00,826
founders of Pact and Pactflow. And she says if you can't deploy services

316
00:20:00,928 --> 00:20:04,110
independently, then you don't have microservices.

317
00:20:04,450 --> 00:20:08,478
And not alone that you have a very costs approach to asserting quality

318
00:20:08,644 --> 00:20:12,666
and testing your implementations. And you have what we call a distributed

319
00:20:12,698 --> 00:20:16,306
monolith. And just in case the red text isn't kind of

320
00:20:16,328 --> 00:20:20,446
advertising it enough for you, that is a bad thing. And it removes

321
00:20:20,478 --> 00:20:23,634
the benefits that are promised by having an ecosystem of

322
00:20:23,672 --> 00:20:27,510
independent, verifiable and deployable microservices.

323
00:20:29,290 --> 00:20:33,042
So bi directional contract testing. So this is an approach

324
00:20:33,106 --> 00:20:37,186
that can really allow us to be able to safely evolve.

325
00:20:37,298 --> 00:20:40,742
And it's one whats also rewards an investment

326
00:20:40,806 --> 00:20:44,470
in a design first approach towards microservices and APIs.

327
00:20:44,550 --> 00:20:48,614
And it can help us avoid many of the pitfalls that we have discussed

328
00:20:48,662 --> 00:20:51,786
up until now. And if you're coming at

329
00:20:51,808 --> 00:20:55,374
this from, let's say, a familiarity with pacts or

330
00:20:55,412 --> 00:20:58,878
even maybe consumer driven contract testing, then this workflow is a

331
00:20:58,884 --> 00:21:02,126
little bit different. So it's schema based rather than a

332
00:21:02,148 --> 00:21:05,506
specification by example. As I mentioned, it really supports a

333
00:21:05,528 --> 00:21:09,266
design first provider workflow, so it's well suited to starting on

334
00:21:09,288 --> 00:21:13,006
the provider side. And it can be described as an ability to upgrade

335
00:21:13,038 --> 00:21:16,594
your existing tools and processes into a powerful contract testing

336
00:21:16,642 --> 00:21:20,198
solution without having to throw away

337
00:21:20,284 --> 00:21:23,314
investments that you've already made in your technical stack.

338
00:21:23,442 --> 00:21:26,594
So you can already leverage open API definitions,

339
00:21:26,642 --> 00:21:30,214
for example, for describing your API contracts on the consumer

340
00:21:30,262 --> 00:21:33,942
side, you can leverage your mocking tools like Cypress, like Wiremark,

341
00:21:34,006 --> 00:21:38,406
et cetera. And then to prove out that your API implementation matches

342
00:21:38,518 --> 00:21:41,846
that open API definition, you can leverage tools

343
00:21:41,878 --> 00:21:45,214
like ready API dread, rest assured postman, and so on and

344
00:21:45,252 --> 00:21:48,702
so forth. I would also say it's a more inclusive way

345
00:21:48,756 --> 00:21:52,382
of contract testing, whereas consumer driven contract testing really

346
00:21:52,436 --> 00:21:55,906
requires and mandates that you have access to the code because it fits more

347
00:21:55,928 --> 00:21:59,054
closely in with unit testing. But bi directional contract

348
00:21:59,102 --> 00:22:02,706
testing does not need direct access to the code, so it

349
00:22:02,728 --> 00:22:05,970
can support a wider demographic of contract testers.

350
00:22:06,790 --> 00:22:10,374
And when I refer to a pact in terms of contract testing, it means the

351
00:22:10,412 --> 00:22:14,242
artifact that is acting as the verifiable contract

352
00:22:14,306 --> 00:22:17,714
between a provider component and a consumer component.

353
00:22:17,842 --> 00:22:21,162
So I do not mean something like an open API definition which

354
00:22:21,216 --> 00:22:24,454
describes the entire surface area of an API.

355
00:22:24,582 --> 00:22:28,074
So what it does is by capturing the interaction expectations between

356
00:22:28,112 --> 00:22:31,662
the software component pairs. So just one integration at a time,

357
00:22:31,796 --> 00:22:35,246
we have an ability to independently verify the

358
00:22:35,268 --> 00:22:38,382
expectations. So this can happen on each side

359
00:22:38,436 --> 00:22:43,034
of a single integration, so we can disregard downstream dependencies

360
00:22:43,082 --> 00:22:47,182
and upstream dependencies, and we can just focus on one integration

361
00:22:47,246 --> 00:22:51,182
at a time so we don't have to stand up a complex environment

362
00:22:51,246 --> 00:22:54,306
for end to end testing. And the

363
00:22:54,328 --> 00:22:57,910
challenge of course that you might have experienced with

364
00:22:57,980 --> 00:23:01,334
certain mocking approaches or test doubles is

365
00:23:01,452 --> 00:23:05,142
you get stale assumptions quite quickly. And here

366
00:23:05,196 --> 00:23:08,854
your assumptions are kept in sync. So with the case of

367
00:23:08,892 --> 00:23:12,406
bi directional contract testing, the assumptions of the consumer

368
00:23:12,518 --> 00:23:15,994
will be validated to ensure that they are a subset of

369
00:23:16,032 --> 00:23:19,306
what the provider supports. And this is really good.

370
00:23:19,328 --> 00:23:23,738
And you might be familiar maybe with Joe Wallace, who's quite a famous tester

371
00:23:23,834 --> 00:23:27,406
and he always advantages for don't mock what you dont own because you

372
00:23:27,428 --> 00:23:31,006
will get drift quite quickly on those assumptions. And the

373
00:23:31,028 --> 00:23:34,206
verification here with bi directional contract testing can

374
00:23:34,228 --> 00:23:37,810
happen asynchronously, so one side does not need the other side

375
00:23:37,880 --> 00:23:40,878
to be available in order to verify.

376
00:23:41,054 --> 00:23:44,226
Once the comparisons on both sides happen, then you can be

377
00:23:44,248 --> 00:23:47,710
confidence that when these components communicate in real life,

378
00:23:47,800 --> 00:23:51,606
that all should be fine. And what I show here on the right hand

379
00:23:51,628 --> 00:23:55,698
side is an example of a packed JSON file. So it stores

380
00:23:55,794 --> 00:23:58,902
who the consumer is, who the provider is,

381
00:23:59,036 --> 00:24:02,746
the interactions that are expected between the consumer and

382
00:24:02,768 --> 00:24:06,266
the provider, and then some additional metadata. So you will also see

383
00:24:06,288 --> 00:24:09,814
some reference here to a packed specification. So there is a defined

384
00:24:09,862 --> 00:24:13,258
specification for describing the format and

385
00:24:13,264 --> 00:24:16,954
the structure of what should be contained within a packed JSON file.

386
00:24:17,082 --> 00:24:20,286
So how does all of this really work? Well, let's run through kind of

387
00:24:20,308 --> 00:24:23,742
an example here. So again, it starts on the

388
00:24:23,796 --> 00:24:27,038
provider side. Now theoretically it can start on both sides, hence the

389
00:24:27,044 --> 00:24:30,866
name bi directional, but it's well suited to starting on the provider side.

390
00:24:30,968 --> 00:24:34,830
So you can bring your API definition, like an open API

391
00:24:34,910 --> 00:24:39,234
definition. Once you can prove

392
00:24:39,282 --> 00:24:43,314
that the implementation of that API is matching what's specified

393
00:24:43,442 --> 00:24:46,806
on the ten, so to say, so you can bring your own provider tool to

394
00:24:46,828 --> 00:24:50,882
do that. Once you have those two things, you can publish

395
00:24:50,946 --> 00:24:54,758
that contract into the packed flow broker.

396
00:24:54,934 --> 00:24:58,746
Then on the consumer side you can continue to unit test as

397
00:24:58,768 --> 00:25:02,102
you will, you can bring your own mocking tool for testing.

398
00:25:02,166 --> 00:25:05,886
Of course you can use pacts DSL, but you're not mandated to. Once you

399
00:25:05,908 --> 00:25:09,230
serialize those unit tests or those expectations into

400
00:25:09,300 --> 00:25:12,650
a pact file, you can then present those to the broker.

401
00:25:12,730 --> 00:25:16,606
And once the broker chaos both sides of that, then the contract comparison

402
00:25:16,638 --> 00:25:20,194
or the cross contract verification is performed by the can I

403
00:25:20,232 --> 00:25:24,062
deploy tool, which is part of pact and packed flows. And we use this feature

404
00:25:24,126 --> 00:25:27,734
really to control and gate a release. So it ensures that what

405
00:25:27,772 --> 00:25:31,522
we're deploying is compatible with any integrations

406
00:25:31,666 --> 00:25:35,046
or any applications that depend on this component in

407
00:25:35,068 --> 00:25:37,590
the environment that we're targeting for the deployment.

408
00:25:38,250 --> 00:25:41,866
And zooming in on this can I deploy check how it makes that kind

409
00:25:41,888 --> 00:25:45,434
of gated decision is it uses whats we call the matrix of

410
00:25:45,472 --> 00:25:48,982
information. So it queries all versions

411
00:25:49,046 --> 00:25:52,698
of the API consumer, all versions of the API

412
00:25:52,794 --> 00:25:56,014
provider, all integrations between all

413
00:25:56,052 --> 00:25:59,706
versions, which ones are compatible with each other and then which environments they've

414
00:25:59,738 --> 00:26:03,026
been deployed to. So in a past life you might have relied on

415
00:26:03,048 --> 00:26:06,706
heavy processes to keep track of this information. Maybe we even had

416
00:26:06,808 --> 00:26:10,914
dedicated teams for this like configuration management or

417
00:26:10,952 --> 00:26:15,038
even change advisory boards. Now this is available instantaneous

418
00:26:15,134 --> 00:26:18,430
for you, so let's run through kind of a demo.

419
00:26:18,520 --> 00:26:21,682
So this would take too long with the actual pipeline.

420
00:26:21,746 --> 00:26:24,678
So I took some screenshots to speed it up a little bit.

421
00:26:24,764 --> 00:26:27,458
But what I've created is a provider API.

422
00:26:27,634 --> 00:26:31,660
It's written in. Net we have a products API which is

423
00:26:32,190 --> 00:26:35,466
just exposing some endpoints to allow us to retrieve some

424
00:26:35,488 --> 00:26:38,886
product information. I'm bringing my own functional testing

425
00:26:38,918 --> 00:26:42,766
tools schema thesis to test whats what I've implemented matches what

426
00:26:42,788 --> 00:26:48,170
I've designed on the consumer side of just a simple console

427
00:26:48,330 --> 00:26:51,646
net core app. And I'm going to again bring my own

428
00:26:51,748 --> 00:26:54,790
unit testing tool and mocking tool, this case wiremark.

429
00:26:54,890 --> 00:26:58,910
And I'm going to set the expectations. We're going to have some pipelines

430
00:26:58,990 --> 00:27:02,254
to publish my artifacts and both consumer

431
00:27:02,302 --> 00:27:05,746
pipeline and provider pipeline will determine if it's safe

432
00:27:05,778 --> 00:27:08,630
to make any of these changes independently.

433
00:27:09,690 --> 00:27:13,042
So here's my API definition.

434
00:27:13,106 --> 00:27:17,106
So it's open API document products API, three endpoints,

435
00:27:17,138 --> 00:27:20,586
get products, get products by id and then also an endpoint to

436
00:27:20,608 --> 00:27:24,566
delete products. So that's my design. Then once I implemented

437
00:27:24,598 --> 00:27:28,646
the code, I can some functional tests through schema

438
00:27:28,678 --> 00:27:32,486
thesis to provider that my implementation is indeed matching

439
00:27:32,518 --> 00:27:36,026
what's described in the design. Once that's caused, I can commit

440
00:27:36,058 --> 00:27:39,774
my code and then I can run my provider pipeline. So here's me

441
00:27:39,812 --> 00:27:43,626
running through just a GitHub action and then I'm leveraging

442
00:27:43,738 --> 00:27:47,214
the can I deploy check through

443
00:27:47,252 --> 00:27:50,766
the GitHub action for can I deploy to verify if

444
00:27:50,788 --> 00:27:54,446
it's safe for me to do this. This passes. Of course this is expected because

445
00:27:54,468 --> 00:27:57,654
it's the first time through the process. I don't have any consumer yet,

446
00:27:57,692 --> 00:28:01,410
so I'm not expecting to break any contract.

447
00:28:01,570 --> 00:28:05,126
So this gets published into Packflow. This is just an example of what

448
00:28:05,148 --> 00:28:08,774
it looks like in packflow. So we have three question marks for the consumer because

449
00:28:08,812 --> 00:28:12,394
we don't have one yet, we have the provider contract. And you can see also

450
00:28:12,432 --> 00:28:16,474
within Pactflow a representation of the open API definition as

451
00:28:16,512 --> 00:28:19,594
well. Jumping to consumer side,

452
00:28:19,632 --> 00:28:23,386
then I have my simple consumer app, and then I create my unit tests

453
00:28:23,418 --> 00:28:27,022
to verify the expectations. So again, nothing special

454
00:28:27,076 --> 00:28:29,674
here. I'm using X unit for unit testing,

455
00:28:29,802 --> 00:28:33,646
standard setup and arrange an act and an assert. I'm taking advantage

456
00:28:33,678 --> 00:28:37,794
here of the fact that Wiremark as a mocking tool has an

457
00:28:37,832 --> 00:28:41,726
actual integration with pact.

458
00:28:41,838 --> 00:28:45,566
So I'm leveraging that component and I'm serializing

459
00:28:45,598 --> 00:28:49,762
the expectations here into a pacts file. What gets serialized

460
00:28:49,826 --> 00:28:53,318
into a pacts file is the name of the consumer. It's all

461
00:28:53,324 --> 00:28:57,206
of the interaction expectations. So in this case I'm expecting to

462
00:28:57,228 --> 00:29:01,482
be able to call the products by id endpoint with a fictitious id.

463
00:29:01,536 --> 00:29:05,814
And if that happens, I'm expecting the provider to return HTTP

464
00:29:05,862 --> 00:29:09,386
404 not found. And at the bottom you can see the name

465
00:29:09,408 --> 00:29:13,006
of the provider that I'm expecting to be able to honor this for me,

466
00:29:13,188 --> 00:29:16,878
again, here's a separate pipeline for the consumer. First time through the process,

467
00:29:16,964 --> 00:29:20,430
everything goes good. What I'm expecting and what I'm

468
00:29:21,570 --> 00:29:24,874
managing from the provider is indeed a valid subset

469
00:29:24,922 --> 00:29:28,178
of the open API definition. And here now we can see

470
00:29:28,184 --> 00:29:31,570
that the pact broker has been updated and everything

471
00:29:31,640 --> 00:29:35,682
is good. The consumer contracts and all of the assertions there

472
00:29:35,736 --> 00:29:39,442
are successful. Now what's going to happen is

473
00:29:39,496 --> 00:29:42,838
I'm going to make what would be regarded as a breaking change.

474
00:29:42,924 --> 00:29:46,054
So the product owner is going to come to me and say, frank, great job

475
00:29:46,092 --> 00:29:49,366
in deploying that API, but I see you have a delete endpoint there,

476
00:29:49,388 --> 00:29:53,046
and that really only should be for the admin API and not for the API

477
00:29:53,078 --> 00:29:56,598
that we're exposing towards external clients. So can you remove that endpoint

478
00:29:56,774 --> 00:30:00,106
now? For me that's a breaking change. I shouldn't be able to do

479
00:30:00,128 --> 00:30:03,840
that. I should version an API. But what

480
00:30:04,530 --> 00:30:08,398
pactflow and bi directional contract testing allows me to do

481
00:30:08,564 --> 00:30:12,394
is it allows me to make that change safely because I can fully

482
00:30:12,442 --> 00:30:15,774
understand and I have full visibility into how the consumer

483
00:30:15,822 --> 00:30:19,714
is expecting my API to provide for them

484
00:30:19,752 --> 00:30:23,810
so what their expectations are. And I know that they are not

485
00:30:23,960 --> 00:30:27,846
using the delete endpoint. So therefore it's safe for me

486
00:30:27,868 --> 00:30:31,240
to make what would traditionally be a breaking change.

487
00:30:32,250 --> 00:30:35,446
And you can see that the pact within the

488
00:30:35,468 --> 00:30:38,890
pacts broker between the provider and the consumer is still there,

489
00:30:39,040 --> 00:30:42,842
it's still valid. But you can see that the provider contract itself

490
00:30:42,976 --> 00:30:47,450
has updated and now it only has the two get endpoints.

491
00:30:49,470 --> 00:30:52,926
Now it's all well and good, seen all green. But what would happen if I

492
00:30:52,948 --> 00:30:56,394
was to try to make a change that would actually break my consumer

493
00:30:56,442 --> 00:31:00,254
client implementation? So here's another example of

494
00:31:00,292 --> 00:31:04,430
this. So the product owner has now asked me to make some changes because

495
00:31:04,500 --> 00:31:08,526
client errors 404 are hindering his reports

496
00:31:08,558 --> 00:31:11,618
and making him look bad. So he's asked me hey,

497
00:31:11,704 --> 00:31:15,220
can I change those 404s maybe into something different?

498
00:31:15,670 --> 00:31:18,886
I'm not going to debate it too much with him. What I'm going to do

499
00:31:18,908 --> 00:31:21,558
is check is this actually going to be a breaking change?

500
00:31:21,724 --> 00:31:26,114
And what I can do is make that change and instantaneously

501
00:31:26,162 --> 00:31:29,634
see that it would break the expectations on the consumer

502
00:31:29,682 --> 00:31:33,306
side because they are expecting a 404 to be returned. And if

503
00:31:33,328 --> 00:31:37,334
I try to change that, I will get notified that I cannot

504
00:31:37,382 --> 00:31:41,238
deploy this and it will prevent me from making this breaking change for

505
00:31:41,264 --> 00:31:44,846
the consumer. I'll see that in the CI process and

506
00:31:44,868 --> 00:31:47,870
then I'll also see it in Pactflow itself.

507
00:31:47,940 --> 00:31:51,726
And I can see that the contract comparison has failed and

508
00:31:51,748 --> 00:31:56,206
I see explicitly why it's failed. So the provider

509
00:31:56,238 --> 00:31:59,586
code no longer returns a 404 and

510
00:31:59,608 --> 00:32:02,658
that is expected by the consumer. So I get explicit information

511
00:32:02,744 --> 00:32:05,806
into that and the matrix of information that's continuously

512
00:32:05,838 --> 00:32:09,570
queried by the can I deploy check is also updated.

513
00:32:09,650 --> 00:32:12,818
And here we can see the top one has failed

514
00:32:12,914 --> 00:32:16,594
and we can see that the environment is in a so I was not allowed

515
00:32:16,642 --> 00:32:19,610
to deploy whats change into production.

516
00:32:21,070 --> 00:32:25,114
So hopefully you'll see that by introducing a technique like

517
00:32:25,312 --> 00:32:29,222
bi directional contract testing towards your microservices approach,

518
00:32:29,286 --> 00:32:32,666
it can reduce your need for end to end testing

519
00:32:32,698 --> 00:32:37,550
and integration testing and it can significantly rebalance

520
00:32:38,290 --> 00:32:42,094
your costs with regards to testing and enables you to

521
00:32:42,132 --> 00:32:46,046
really safely evolve microservices. You'll have an approach that's

522
00:32:46,158 --> 00:32:49,934
simpler, it's cheaper, it's faster, it scales

523
00:32:49,982 --> 00:32:53,746
linearly as your number of microservices scale, and it allows you

524
00:32:53,768 --> 00:32:57,590
to make sure that you can keep that flexibility and deploy independently.

525
00:32:58,010 --> 00:33:01,094
And with regards to how this benefits a

526
00:33:01,132 --> 00:33:04,326
design first approach one of the main challenges that we have

527
00:33:04,348 --> 00:33:08,626
with API design first is that you lose visibility

528
00:33:08,738 --> 00:33:12,294
quite quickly once you get an API into production

529
00:33:12,342 --> 00:33:15,722
and you start ramping up your number of consumers and it can be really

530
00:33:15,776 --> 00:33:19,450
hard to make informed decisions around what changes

531
00:33:19,520 --> 00:33:22,686
will be breaking, what changes will not be breaking. All you can do

532
00:33:22,708 --> 00:33:26,506
is assume that the full surface area of your API definition is deemed

533
00:33:26,538 --> 00:33:30,206
on by somebody but with contract testing it

534
00:33:30,228 --> 00:33:33,406
gives you that full explicit insight into how consumers are

535
00:33:33,428 --> 00:33:37,214
consumer your API and it lets you have a more pragmatic rather

536
00:33:37,252 --> 00:33:40,922
than dogmatic approach to your API versioning

537
00:33:40,986 --> 00:33:44,654
strategy. So hopefully you see the benefits. Hopefully you enjoyed my

538
00:33:44,692 --> 00:33:48,278
talk. Thanks very much for attending. If you want to connect and reach out

539
00:33:48,364 --> 00:33:52,454
please do. Here are my details and here's how you can get up

540
00:33:52,492 --> 00:33:55,714
and start playing with contract testing and also some useful

541
00:33:55,762 --> 00:33:59,062
resources. Whats helped me frame some of this talk.

542
00:33:59,196 --> 00:33:59,940
Thank you very much.

