1
00:01:54,350 --> 00:01:58,066
Hello. My name is Ronnie Dover, and I'm extremely excited to

2
00:01:58,088 --> 00:02:01,666
be talking to you today about open telemetry and coding with the

3
00:02:01,688 --> 00:02:05,634
insights on and the reason I'm so excited about

4
00:02:05,752 --> 00:02:09,602
this technology and the possibilities it presents is

5
00:02:09,656 --> 00:02:12,706
because I think it represents a very big

6
00:02:12,808 --> 00:02:15,698
change in how we write code.

7
00:02:15,864 --> 00:02:20,042
And I'm just. In regard to my personal

8
00:02:20,176 --> 00:02:23,594
background, I've been a developer for over

9
00:02:23,632 --> 00:02:26,570
20 years. I've been a product manager,

10
00:02:27,150 --> 00:02:30,746
and kind of oscillated between the two roles. It was

11
00:02:30,768 --> 00:02:34,366
very difficult for me to stop coding about design when

12
00:02:34,388 --> 00:02:37,710
I was developing or leave code behind when I was doing

13
00:02:37,780 --> 00:02:41,262
feature design. However, throughout that time,

14
00:02:41,316 --> 00:02:45,154
I was really fascinated by technologies that really changes the way we

15
00:02:45,192 --> 00:02:49,566
code. And I think to some extent, we saw that when testing

16
00:02:49,678 --> 00:02:53,090
started becoming more widespream, asynchronous programming,

17
00:02:53,670 --> 00:02:57,314
event sourcing, there are a lot of technologies that kind of changed how

18
00:02:57,352 --> 00:02:59,990
code got written, how we thought about code.

19
00:03:00,140 --> 00:03:03,826
And I think observability today, and in particular, open telemetry

20
00:03:03,858 --> 00:03:07,366
and continuous feedback, represent just such a

21
00:03:07,388 --> 00:03:10,714
change. And I hope that by the end of this presentation, I will at least

22
00:03:10,752 --> 00:03:14,330
kind of have convinced you that these things are really worth looking

23
00:03:14,400 --> 00:03:18,074
at right now. So, to illustrate that, I want to

24
00:03:18,112 --> 00:03:22,014
start with the story of one of my developers. This is

25
00:03:22,052 --> 00:03:25,822
Bill. And Bill has been tasked with a very

26
00:03:25,876 --> 00:03:29,978
common task for developers, which is take a feature,

27
00:03:30,074 --> 00:03:33,758
develop it all the way through, and then deploy it into production,

28
00:03:33,854 --> 00:03:37,060
something that is fairly routine for developers today.

29
00:03:37,670 --> 00:03:41,054
Now, Bill's job used to be extremely

30
00:03:41,102 --> 00:03:44,434
simple, and this was kind of the situation when I

31
00:03:44,472 --> 00:03:47,778
got started around 20 years ago, which was, you build a

32
00:03:47,784 --> 00:03:51,014
feature, you design the feature, you develop the feature, you wrap it up

33
00:03:51,052 --> 00:03:54,482
real nice, and then you take it to the guys across the hall

34
00:03:54,546 --> 00:03:58,534
and the QA department, and they start looking at it. There would be

35
00:03:58,572 --> 00:04:02,022
some perhaps philosophical arguments about what's a feature,

36
00:04:02,086 --> 00:04:06,374
what's a bug? And then eventually it gets rolled on into production,

37
00:04:06,502 --> 00:04:09,866
and you would probably never hear about that feature again unless there is

38
00:04:09,888 --> 00:04:13,710
some bug, in which case you may be called to correct

39
00:04:13,780 --> 00:04:17,440
it. But of course, that's no longer the case.

40
00:04:17,970 --> 00:04:21,818
So as teams become more cross functional, as developers

41
00:04:21,914 --> 00:04:24,690
started taking on more responsibility,

42
00:04:26,070 --> 00:04:30,014
Bill, as well as the rest of the team, started taking and assuming

43
00:04:30,062 --> 00:04:33,858
more ownership. So now a part of Bill's job is actually

44
00:04:33,944 --> 00:04:37,894
to also write the tests, to validate that there's a test

45
00:04:37,932 --> 00:04:41,430
plan, integration tests, load tests, other types of tests.

46
00:04:42,490 --> 00:04:47,394
Often, Bill needs to worry about how to deploy his

47
00:04:47,452 --> 00:04:51,462
service. So do I deploy it using helm

48
00:04:51,526 --> 00:04:55,258
terraform? What's the RaM requirement, these things that used to be kind of

49
00:04:55,344 --> 00:04:59,590
once kind of the sole responsibility

50
00:04:59,670 --> 00:05:03,214
of the DevOps or it people now

51
00:05:03,412 --> 00:05:06,686
is everyone's to care about and to

52
00:05:06,708 --> 00:05:10,734
know, because eventually there's going to be an issue and the person that might

53
00:05:10,772 --> 00:05:13,380
need to investigate that issue could be Bill.

54
00:05:14,710 --> 00:05:18,034
So a lot has changed. But the

55
00:05:18,072 --> 00:05:21,554
question is, let's say that know

56
00:05:21,592 --> 00:05:24,894
he's top notch developer, he's using the best tools

57
00:05:24,942 --> 00:05:28,306
available, he has the best CI CD pipeline

58
00:05:28,338 --> 00:05:32,162
in the world, and he's just released the feature into production.

59
00:05:32,306 --> 00:05:35,560
So the question is, what happens then?

60
00:05:36,170 --> 00:05:39,866
What happens? Or what should Bill do the moment that

61
00:05:39,888 --> 00:05:42,730
he finished rolling his feature into production?

62
00:05:44,830 --> 00:05:48,490
And the answer to that question is also interesting,

63
00:05:48,560 --> 00:05:52,510
because my expectation from Bill was to

64
00:05:52,580 --> 00:05:56,334
ask a lot of questions. I'm very kind of evidence based in how

65
00:05:56,372 --> 00:06:00,478
I like to think about things. So my first

66
00:06:00,644 --> 00:06:03,914
instinct would be, well, check whether your code actually worked.

67
00:06:03,972 --> 00:06:08,340
Did it work well, is anyone using it?

68
00:06:08,790 --> 00:06:12,846
I've witnessed enough horror stories where metriculously

69
00:06:12,878 --> 00:06:16,406
written code was perhaps just a

70
00:06:16,428 --> 00:06:20,134
few bad if statements away from actually getting

71
00:06:20,172 --> 00:06:23,910
executed in production. So did it actually get run?

72
00:06:23,980 --> 00:06:26,440
Did it change anything for the good? For the bad,

73
00:06:27,550 --> 00:06:30,634
you just changed the data access layer and added something.

74
00:06:30,752 --> 00:06:33,740
Did it actually make things better for everyone?

75
00:06:34,590 --> 00:06:36,890
So that is my expectation.

76
00:06:38,030 --> 00:06:41,582
However, 99% of the time, what would

77
00:06:41,636 --> 00:06:45,262
happen in this situation is that Bill would

78
00:06:45,316 --> 00:06:47,710
move on to the next feature.

79
00:06:49,730 --> 00:06:52,110
And this is something that I tried changing.

80
00:06:52,690 --> 00:06:56,082
So to figure out why this was happening,

81
00:06:56,216 --> 00:06:59,266
I went back to the basics, and here

82
00:06:59,288 --> 00:07:03,406
is some diagram that I pulled from an online source showing

83
00:07:03,438 --> 00:07:06,898
the DevOps loop that by now is completely overused,

84
00:07:06,994 --> 00:07:10,134
but it's still a good model to kind of think about the

85
00:07:10,172 --> 00:07:12,120
process that releases go through.

86
00:07:13,130 --> 00:07:17,830
And I would challenge you to look at this particular diagram,

87
00:07:18,510 --> 00:07:21,850
and you may notice that something

88
00:07:21,920 --> 00:07:25,066
is a bit off about it. So this

89
00:07:25,088 --> 00:07:28,902
is a pretty accurate representation of the different stages of development,

90
00:07:28,966 --> 00:07:32,106
from building to continuous integration, deployment,

91
00:07:32,218 --> 00:07:36,382
operations and so on. But there is one segment here

92
00:07:36,436 --> 00:07:40,446
that actually appears in the diagram that only has one

93
00:07:40,548 --> 00:07:44,660
tool associated with it, which is salesforce for some reason,

94
00:07:45,030 --> 00:07:47,890
and that is continuous feedback.

95
00:07:48,870 --> 00:07:51,906
So although we have plenty of tools to

96
00:07:51,928 --> 00:07:55,970
take our code across the chasm and into production,

97
00:07:56,130 --> 00:07:59,990
to operate it in production and so on, we have very little

98
00:08:00,060 --> 00:08:03,542
tools to none in this diagram that

99
00:08:03,596 --> 00:08:07,058
can actually take the information back from production

100
00:08:07,234 --> 00:08:11,130
and make it into something useful that we can use in depth.

101
00:08:12,670 --> 00:08:15,980
So to think about Bill in this sense,

102
00:08:16,750 --> 00:08:20,342
Bill has a lot of feedback when coding

103
00:08:20,406 --> 00:08:24,586
in his local environment. He has at least some limited feedback

104
00:08:24,618 --> 00:08:28,846
from testing. Limited, I say, because tests are usually

105
00:08:28,948 --> 00:08:32,866
more kind of a red, green, black, white kind of a thing, rather than a

106
00:08:32,888 --> 00:08:36,450
very qualitative way to measure improvements, let's say.

107
00:08:36,520 --> 00:08:40,914
But it's still some feedback, but there is almost

108
00:08:41,032 --> 00:08:44,786
no feedback that he can use in his day

109
00:08:44,808 --> 00:08:47,430
to day from the production environment.

110
00:08:49,450 --> 00:08:52,822
So I thought to myself, well, if only we had

111
00:08:52,876 --> 00:08:56,246
access to instant objective data about

112
00:08:56,268 --> 00:08:59,226
the code. Like, if only it was kind of a non issue,

113
00:08:59,408 --> 00:09:02,570
that whenever Bill would want,

114
00:09:02,640 --> 00:09:06,262
he would just glance over the edge

115
00:09:06,326 --> 00:09:09,580
and kind of see exactly how this code is working.

116
00:09:09,970 --> 00:09:14,590
And this is kind of the perfect segue to talk about opentelemetry.

117
00:09:16,050 --> 00:09:19,790
So open telemetry is a spec, it's a standard.

118
00:09:19,860 --> 00:09:23,534
It defines how to do observability. And there are lots of implementations

119
00:09:23,582 --> 00:09:26,740
of that spec for different languages, platforms and so on.

120
00:09:27,270 --> 00:09:30,660
And opentelemetry, in my humble opinion, is not

121
00:09:31,190 --> 00:09:34,734
important because it is something amazing or revolutionary

122
00:09:34,782 --> 00:09:37,720
in terms of the technology. Although it's a great technology,

123
00:09:38,890 --> 00:09:42,642
it is important first and foremost

124
00:09:42,786 --> 00:09:46,614
because everyone agrees on it. So the

125
00:09:46,652 --> 00:09:50,614
fact that there is a consensus around opentelemetry

126
00:09:50,662 --> 00:09:54,506
that we're no longer talking about kind of this fragmented landscape of

127
00:09:54,528 --> 00:09:58,038
different proprietary agents, protocols,

128
00:09:58,214 --> 00:10:02,330
instrumentations and so on by different vendors,

129
00:10:03,170 --> 00:10:07,194
makes it very easy for two things to happen. First, for an ecosystem

130
00:10:07,242 --> 00:10:10,938
to emerge, as often happens with open source tools.

131
00:10:11,034 --> 00:10:14,946
So suddenly there are a lot of tools that are kind of coming together

132
00:10:15,048 --> 00:10:18,434
and providing the value add of how can we

133
00:10:18,472 --> 00:10:22,574
make this data actually useful and how can we analyze

134
00:10:22,622 --> 00:10:26,774
it, and how can we take that data and

135
00:10:26,812 --> 00:10:28,760
make sure that bill can use it.

136
00:10:29,930 --> 00:10:33,186
The other aspect is in terms of coverage. So if I'm

137
00:10:33,218 --> 00:10:37,142
a platform tool designer or if

138
00:10:37,196 --> 00:10:40,620
I'm a maintainer in, I don't know, some major,

139
00:10:42,110 --> 00:10:46,138
it doesn't matter if it's a backend server platform

140
00:10:46,304 --> 00:10:49,340
or a web server or anything else,

141
00:10:50,110 --> 00:10:53,694
the choice for me is very easy. Now I don't need to worry about,

142
00:10:53,732 --> 00:10:57,614
well, should I allow instrumentation or enable instrumentation for

143
00:10:57,652 --> 00:11:00,590
datadog or splunk or whoever it is,

144
00:11:00,740 --> 00:11:04,030
I just support open telemetry.

145
00:11:04,550 --> 00:11:07,794
And as a result of that, what we're seeing is that first

146
00:11:07,832 --> 00:11:11,058
of all, many programming languages actually

147
00:11:11,224 --> 00:11:14,914
integrate with it in a very, very easy way. I think net

148
00:11:15,032 --> 00:11:18,742
even made it a part of the standard library just to make it

149
00:11:18,796 --> 00:11:22,274
much easier for people to use. But also, it doesn't

150
00:11:22,322 --> 00:11:26,200
matter kind of which tool you're using or what

151
00:11:26,730 --> 00:11:30,554
type of project, there is a very good

152
00:11:30,592 --> 00:11:34,022
chance that you'll find that there is already automatic instrumentation

153
00:11:34,086 --> 00:11:38,010
available, which basically means that we can get data at

154
00:11:38,080 --> 00:11:41,040
practically no cost about my project.

155
00:11:42,130 --> 00:11:45,870
So for this particular example, I created a sample app

156
00:11:45,940 --> 00:11:49,680
that we're going to use to kind of explore these

157
00:11:50,610 --> 00:11:53,906
information pieces that we can now get about our application in

158
00:11:53,928 --> 00:11:57,490
runtime. So because I'm a bit allergic to very

159
00:11:57,560 --> 00:12:01,300
simple crud, apps know, basically just do

160
00:12:01,910 --> 00:12:05,406
basic database operations. I created

161
00:12:05,438 --> 00:12:09,378
a more involved application as I was watching the Harry

162
00:12:09,394 --> 00:12:12,966
Potter movies at the time with my kids. I created an API for

163
00:12:12,988 --> 00:12:16,454
the Gringotts vault, and I tried to

164
00:12:16,492 --> 00:12:20,230
use a variety of technologies, in this case a queuing system, RabbitMQ,

165
00:12:20,310 --> 00:12:23,638
fast API server, some postgres,

166
00:12:23,734 --> 00:12:27,450
an external API with mock data, but all of that is

167
00:12:27,520 --> 00:12:31,606
just details. The same would very easily translate

168
00:12:31,638 --> 00:12:34,430
to any platform and any programming language.

169
00:12:35,650 --> 00:12:39,518
And what surprised me right from the start was just the

170
00:12:39,604 --> 00:12:43,434
amount of out of the box instrumentation for opentelemetry

171
00:12:43,482 --> 00:12:47,314
that exists with all of these libraries and frameworks. And from

172
00:12:47,352 --> 00:12:50,866
my experience, this repeats itself no matter what you're using.

173
00:12:50,968 --> 00:12:55,210
So in this case, I was using FastApi, which is a very popular

174
00:12:55,310 --> 00:12:59,010
Python server. It has out of the box instrumentation.

175
00:12:59,090 --> 00:13:02,950
I was using RabbitMQ with a package called

176
00:13:03,100 --> 00:13:06,978
Pica, which also has can instrumentation.

177
00:13:07,154 --> 00:13:10,906
I was using SQL, alchemy, psycop, a lot of

178
00:13:10,928 --> 00:13:14,060
different libraries, each of them already had

179
00:13:15,070 --> 00:13:18,714
another way, or a very easy way to

180
00:13:18,752 --> 00:13:22,686
instrument it and get data. So the

181
00:13:22,708 --> 00:13:25,806
ramification of that is that I was able to get from an

182
00:13:25,828 --> 00:13:29,038
application that has zero data. Okay,

183
00:13:29,204 --> 00:13:32,986
as Bill, I would look at this application and I would start searching

184
00:13:33,018 --> 00:13:37,138
in logs, trying to find clues, which would take me a lot of time

185
00:13:37,304 --> 00:13:41,218
to a situation where the application was basically

186
00:13:41,304 --> 00:13:44,610
spewing out tools of data about how it was

187
00:13:44,680 --> 00:13:48,166
behaving. Now let's understand

188
00:13:48,268 --> 00:13:51,910
what is the type of data that I'm collecting. So one of the interesting things

189
00:13:51,980 --> 00:13:55,586
that Opentelemetry provides is called tracing. If you're

190
00:13:55,618 --> 00:13:58,954
not familiar with tracing, here's a very quick

191
00:13:58,992 --> 00:14:02,906
one on one on that. So a trace essentially describes a

192
00:14:02,928 --> 00:14:06,586
flow within the system. So in this case,

193
00:14:06,768 --> 00:14:10,270
in my application, a user goes to the fast API service,

194
00:14:10,340 --> 00:14:13,482
let's say he calls evaluate vault

195
00:14:13,546 --> 00:14:16,862
operation that gets translated to a message

196
00:14:16,916 --> 00:14:20,574
queue that gets picked up by a worker that actually does

197
00:14:20,612 --> 00:14:24,686
the work. That entire distributed operation

198
00:14:24,798 --> 00:14:28,866
is a trace, and we can keep track of it and understand what

199
00:14:28,888 --> 00:14:32,274
are the different sections or sub

200
00:14:32,312 --> 00:14:35,794
activities there, how much did each of them take, how does it work

201
00:14:35,832 --> 00:14:39,480
over time? So all of that information is very easily available.

202
00:14:40,090 --> 00:14:43,554
And the other term that we use is a span,

203
00:14:43,602 --> 00:14:46,994
and a span is just a subset of a trace.

204
00:14:47,042 --> 00:14:50,566
So within a trace, let's say, within the segment where we're

205
00:14:50,598 --> 00:14:54,342
making the API call. And before it gets to RabbitMQ

206
00:14:54,406 --> 00:14:57,958
for the next phase, we have various activities

207
00:14:58,054 --> 00:15:01,714
we have actually handling the request and then checking permissions,

208
00:15:01,782 --> 00:15:04,666
maybe validating with some other authentication sources,

209
00:15:04,778 --> 00:15:08,286
then in queuing the job. So each of these is an activity that we

210
00:15:08,308 --> 00:15:11,614
can also track and keep tabs on.

211
00:15:11,732 --> 00:15:15,230
Who called it, how long did it take, what errors did we have there,

212
00:15:15,300 --> 00:15:18,626
what logs and so on. And that is what we call a

213
00:15:18,648 --> 00:15:21,874
span. And in a sec we can actually see how we can use open

214
00:15:21,912 --> 00:15:25,366
source tooling. In this case, we'll use Jaeger in

215
00:15:25,388 --> 00:15:28,834
order to visualize that entire trace

216
00:15:28,882 --> 00:15:32,102
so that my experience as

217
00:15:32,156 --> 00:15:35,574
Bill will be upgraded. For all of a sudden I'll be

218
00:15:35,612 --> 00:15:39,260
able to completely understand how my code is working

219
00:15:41,470 --> 00:15:45,034
in the real world and maybe assess my changes,

220
00:15:45,152 --> 00:15:49,100
which is what we were going for when we got started.

221
00:15:49,790 --> 00:15:53,406
But let's look at some sample code because I

222
00:15:53,428 --> 00:15:55,680
think that would illustrate it the best.

223
00:15:56,530 --> 00:15:59,774
So this is the source code.

224
00:15:59,972 --> 00:16:03,578
All of the links will be provided at the end of this presentation.

225
00:16:03,754 --> 00:16:06,942
I'm looking at some basic operation like authentication.

226
00:16:07,006 --> 00:16:10,194
So a lot of the data I don't need to change the code to get,

227
00:16:10,232 --> 00:16:13,666
as I mentioned. So for example, the fast API service

228
00:16:13,768 --> 00:16:17,478
already tells me about things that happened,

229
00:16:17,644 --> 00:16:21,320
events, and keeps track of

230
00:16:21,690 --> 00:16:25,446
the traces as they happen. The same goes with

231
00:16:25,468 --> 00:16:28,594
the database and the RabbitMQ instrumentation

232
00:16:28,642 --> 00:16:32,182
and all of these other pieces. Now, just to illustrate,

233
00:16:32,246 --> 00:16:35,786
getting all of that to work was extremely simple. Here you can

234
00:16:35,808 --> 00:16:39,100
see kind of the entirety of that code.

235
00:16:39,890 --> 00:16:43,582
Make this a bit bigger. As you can see, it's basically

236
00:16:43,716 --> 00:16:47,098
turning on the insights. Calling a specific instrumenter,

237
00:16:47,194 --> 00:16:51,498
let's say request or Fastapi or postgres,

238
00:16:51,594 --> 00:16:55,794
and then just calling the instrument method. And there are ways

239
00:16:55,912 --> 00:16:59,778
to actually make that also automatic. So even that code

240
00:16:59,864 --> 00:17:03,266
today is not that necessary. Just by including the

241
00:17:03,288 --> 00:17:06,398
right packages, you'll have everything you

242
00:17:06,424 --> 00:17:09,302
need about or all of the data that you need.

243
00:17:09,436 --> 00:17:12,486
In addition to that, you can include within the

244
00:17:12,508 --> 00:17:16,182
code specific manual instrumentations, which basically says,

245
00:17:16,236 --> 00:17:19,706
I'm defining a scope and I want to track that scope in

246
00:17:19,728 --> 00:17:23,526
the code manually. You can think about it like logging on steroids.

247
00:17:23,558 --> 00:17:26,666
So it's not just a message here

248
00:17:26,768 --> 00:17:30,234
or this code was called, but it automatically tracks who called

249
00:17:30,272 --> 00:17:33,450
it, the duration, start and end. So for example,

250
00:17:33,520 --> 00:17:37,274
here we see authenticating the vault owner with the key and we create a scope.

251
00:17:37,322 --> 00:17:40,954
This is the python way of doing things. We call this scope authenticate,

252
00:17:41,002 --> 00:17:44,274
vault owner and key. But of course there are equivalent ways to do it.

253
00:17:44,312 --> 00:17:47,822
In every programming language to use. And there is ample documentation

254
00:17:47,886 --> 00:17:50,610
about how to use it with opentelemetry.

255
00:17:51,190 --> 00:17:54,580
Now once we have this up and running,

256
00:17:55,450 --> 00:17:59,254
let's see how we can actually get data out of it.

257
00:17:59,452 --> 00:18:01,720
So let's take a look at a quick example.

258
00:18:05,710 --> 00:18:08,060
So here we have our application.

259
00:18:09,230 --> 00:18:12,298
It is the API for the

260
00:18:12,304 --> 00:18:16,026
greengrass vault that we're using. And let's trigger

261
00:18:16,218 --> 00:18:19,374
a specific operation. Let's say we want

262
00:18:19,412 --> 00:18:23,186
to trigger a vault appraisal. As we

263
00:18:23,208 --> 00:18:26,900
mentioned previously. In this case we just provide the

264
00:18:27,270 --> 00:18:31,058
vault id, we run the operation, we get back a result,

265
00:18:31,144 --> 00:18:34,466
something happened. What? Who knows, right? And at

266
00:18:34,488 --> 00:18:37,798
this point we can go back to the ide and maybe look at the code,

267
00:18:37,884 --> 00:18:41,462
imagine what would happen. Or we can, as we wanted to

268
00:18:41,596 --> 00:18:45,714
accomplish in the beginning, kind of get that immediate feedback

269
00:18:45,762 --> 00:18:49,290
about, okay, what happens when this operation is called.

270
00:18:49,440 --> 00:18:52,998
And here is Yeager. It's a very popular

271
00:18:53,094 --> 00:18:57,590
open source tool that I like a lot that just allows you to visualize

272
00:18:57,750 --> 00:19:01,722
the traces. It's very easy to set up. You just export data

273
00:19:01,776 --> 00:19:04,958
to it from opentelemetry as a part of kind of

274
00:19:04,964 --> 00:19:09,070
the boilerplate setup, which is very easy. And I won't go into it now,

275
00:19:09,140 --> 00:19:12,766
but it's very well documented. So let

276
00:19:12,788 --> 00:19:16,594
me see, kind of the latest data that we have about our

277
00:19:16,632 --> 00:19:20,770
vault service. And immediately you can see this is the operation I just triggered.

278
00:19:21,190 --> 00:19:24,846
And we can see that there are two services actually in this distributed

279
00:19:24,878 --> 00:19:28,614
trace. One is the goblin worker, the other is the vault service.

280
00:19:28,732 --> 00:19:33,074
And we can actually go and kind of explore the entire request.

281
00:19:33,122 --> 00:19:36,422
And bear in mind all of this data I got just for free just

282
00:19:36,476 --> 00:19:39,674
by enabling the instrumentations. So we have

283
00:19:39,712 --> 00:19:43,674
here the HTTP call to the appraise. We have

284
00:19:43,712 --> 00:19:47,420
here some database statements that are happening.

285
00:19:47,790 --> 00:19:52,810
We have here some logical spans

286
00:19:52,890 --> 00:19:56,560
that we declared in the code, like in this case.

287
00:19:57,330 --> 00:20:00,638
And we can go all the way to see the individual

288
00:20:00,724 --> 00:20:03,770
DB statements and we

289
00:20:03,780 --> 00:20:07,314
can see that the goblin worker picked up the request here and what

290
00:20:07,432 --> 00:20:10,990
happened there. So it's very easy to track and visualize

291
00:20:11,070 --> 00:20:13,890
exactly what happens with such a request.

292
00:20:16,170 --> 00:20:21,174
So this kind of impediment or information

293
00:20:21,292 --> 00:20:24,934
gap between the developer and production no

294
00:20:24,972 --> 00:20:28,426
longer exists once we have the code

295
00:20:28,528 --> 00:20:32,490
being monitored in this way and all of that information is now

296
00:20:32,640 --> 00:20:35,450
readily available for the developer.

297
00:20:38,110 --> 00:20:40,240
And if you think about it,

298
00:20:41,490 --> 00:20:45,406
we can actually make this information much more useful than just validating the

299
00:20:45,428 --> 00:20:49,598
code once we've deployed it. So as you

300
00:20:49,764 --> 00:20:54,242
might think, this is a loop. It's not like every

301
00:20:54,296 --> 00:20:57,986
code that we write is completely new. We continually update code

302
00:20:58,088 --> 00:21:01,326
and there's already very useful information about the pieces

303
00:21:01,358 --> 00:21:05,222
of code that we're writing that could help us design it.

304
00:21:05,356 --> 00:21:08,934
So if you think about it, even before Bill got started into his

305
00:21:09,052 --> 00:21:11,350
Dell upgrade feature,

306
00:21:12,890 --> 00:21:17,766
there are a lot of questions that if

307
00:21:17,788 --> 00:21:21,370
he had access to the right data, he could actually ask,

308
00:21:21,520 --> 00:21:24,730
who is using this code? Is it even used? Who will break

309
00:21:24,800 --> 00:21:28,138
if I change it incorrectly? What are some issues I

310
00:21:28,144 --> 00:21:31,726
should know about? What's the baseline I should compare myself to?

311
00:21:31,828 --> 00:21:35,040
What should I optimize for? Where does concurrency happen?

312
00:21:35,810 --> 00:21:39,134
And then later, when reviewing the changes, we can get

313
00:21:39,172 --> 00:21:42,494
data from the test environments and start asking more

314
00:21:42,532 --> 00:21:46,050
questions like, what should I watch for? What are some historical issues

315
00:21:46,120 --> 00:21:48,020
associated with this code?

316
00:21:49,110 --> 00:21:52,638
What can we learn just by the same observability

317
00:21:52,734 --> 00:21:56,462
that we get by looking at the test. So there is a lot of data

318
00:21:56,536 --> 00:22:00,514
here, and that data has the potential to completely revolutionize

319
00:22:00,642 --> 00:22:04,070
how we write code, because it can be available at every

320
00:22:04,140 --> 00:22:07,538
turn, not just when we validate our code changes, but also when we

321
00:22:07,564 --> 00:22:11,482
design them. Because whether we look at it or not, the data

322
00:22:11,536 --> 00:22:14,474
is already there. So now the question is,

323
00:22:14,592 --> 00:22:17,180
can we open our eyes and actually use it?

324
00:22:18,750 --> 00:22:22,880
But the answer to this question is that

325
00:22:23,490 --> 00:22:27,600
99% of the time, Bill would still not use that data.

326
00:22:29,570 --> 00:22:33,090
And I spent a lot of time trying to figure

327
00:22:33,160 --> 00:22:37,554
out why that is the case and

328
00:22:37,672 --> 00:22:40,962
why, despite my best efforts to convince Bill,

329
00:22:41,016 --> 00:22:44,286
hey, look, there is this really awesome pile of data over there.

330
00:22:44,328 --> 00:22:48,120
Why don't you look and see what you find?

331
00:22:48,810 --> 00:22:52,086
Often Bill, or whoever developer it

332
00:22:52,108 --> 00:22:54,710
was, would prefer to move on to the next feature.

333
00:22:55,770 --> 00:22:59,142
And here are some reasons that I found. There are a few small

334
00:22:59,196 --> 00:23:02,554
reasons, and I think one very big one. So the first has

335
00:23:02,592 --> 00:23:06,438
to do with expertise. And it's by no chance that I put here a picture

336
00:23:06,454 --> 00:23:10,154
of house repairs, because that's my personal blind spot and something that

337
00:23:10,192 --> 00:23:13,338
I would procrastinate as much as possible rather than do.

338
00:23:13,504 --> 00:23:16,974
And it's the same for many developers with domains that they're less

339
00:23:17,012 --> 00:23:20,554
familiar with. For example, not all of us have brushed up on our statistics

340
00:23:20,602 --> 00:23:23,806
101. And to make that data useful that I just showed

341
00:23:23,838 --> 00:23:26,830
you, I actually need to know to remove outliers,

342
00:23:26,910 --> 00:23:30,514
to calculate the median or the p 99

343
00:23:30,712 --> 00:23:34,334
sometimes to do more complex statistics just to get to

344
00:23:34,392 --> 00:23:37,702
meaningful conclusions about what does this mean

345
00:23:37,756 --> 00:23:41,046
about my code. In addition, I need

346
00:23:41,068 --> 00:23:44,840
to actually stop what I'm doing and start learning a new tool,

347
00:23:45,370 --> 00:23:48,730
move between my ide and whatever

348
00:23:48,800 --> 00:23:52,266
dashboard it is continuously, and kind of look for

349
00:23:52,288 --> 00:23:55,900
troubles in simple terms.

350
00:23:56,990 --> 00:24:01,086
But I think the more profound reason is

351
00:24:01,108 --> 00:24:04,654
that it's not continuous. So in

352
00:24:04,692 --> 00:24:08,542
the same way where we have kind of the equivalent and

353
00:24:08,676 --> 00:24:13,098
symmetrical process of continuous integration, which is taking code into production

354
00:24:13,274 --> 00:24:16,834
that happens continuously. You don't think about, hey, I'm going to run

355
00:24:16,872 --> 00:24:20,446
some tests. These tests run automatically just by checking

356
00:24:20,478 --> 00:24:23,598
in code. If you're using continuous deployment, you don't

357
00:24:23,614 --> 00:24:27,158
think about, oh, I'm going to deploy to production. No, you just designed a

358
00:24:27,164 --> 00:24:30,440
very good pipeline, and as a result of your

359
00:24:30,890 --> 00:24:35,350
commits and merges and pull requests, everything will get deployed into production.

360
00:24:36,650 --> 00:24:40,498
In the same way, if we want to make this information useful, it can't

361
00:24:40,514 --> 00:24:44,314
be something that I need to think, oh, let me ask Bill to go search

362
00:24:44,352 --> 00:24:48,134
for stuff after he did his check in. That needs to be continuous,

363
00:24:48,182 --> 00:24:50,430
it needs to happen automatically.

364
00:24:51,650 --> 00:24:55,546
And this is my own kind of personal journey with observability

365
00:24:55,658 --> 00:24:59,674
and continuous feedback, because once I've noticed that, I became

366
00:24:59,722 --> 00:25:02,914
really obsessed with the idea of how can we actually create

367
00:25:02,952 --> 00:25:06,946
a continuous feedback platform, something that can actually

368
00:25:07,048 --> 00:25:10,514
continuously look at the data that the application is

369
00:25:10,552 --> 00:25:14,354
already collecting with technologies such as opentelemetry and try

370
00:25:14,392 --> 00:25:17,430
to make that extremely useful for the developer.

371
00:25:18,250 --> 00:25:21,190
Now I want to show you an example of this, and by the way,

372
00:25:21,260 --> 00:25:25,122
I'm very happy to see that there are other tools and platforms

373
00:25:25,186 --> 00:25:29,282
and ecosystem libraries, except digma,

374
00:25:29,426 --> 00:25:32,442
which is the one that I'm working on, that are providing the same value.

375
00:25:32,576 --> 00:25:36,886
I want to show you an example, not particularly to talk about Digma,

376
00:25:36,918 --> 00:25:40,766
but to just show you my vision or what I think or

377
00:25:40,788 --> 00:25:44,926
where I think development is changing towards and

378
00:25:45,028 --> 00:25:49,262
what a modern developer might do in his code. That's very,

379
00:25:49,316 --> 00:25:52,926
very different from how we code today. So to

380
00:25:52,948 --> 00:25:56,306
do that, let me pull up that same code that we were

381
00:25:56,328 --> 00:25:59,060
looking earlier. Let's look at this vault service.

382
00:25:59,510 --> 00:26:03,022
And what I'm going to do now is simply enable

383
00:26:03,086 --> 00:26:06,966
continuous feedback. In this case, one of the outlets of that feedback is

384
00:26:06,988 --> 00:26:09,270
an IDE plugin that I'm going to enable.

385
00:26:12,300 --> 00:26:15,944
Now, bear in mind, I'm looking at the code. I had no idea

386
00:26:15,982 --> 00:26:19,976
whether it's good or bad or what's going on with it, but now I've turned

387
00:26:20,008 --> 00:26:24,396
on these new spectacles, which are basically the information

388
00:26:24,498 --> 00:26:27,420
that I get back from, in this case, digma.

389
00:26:28,240 --> 00:26:31,612
So immediately I notice things about this code

390
00:26:31,666 --> 00:26:35,136
and I can drill to know more. I can see that this

391
00:26:35,158 --> 00:26:38,688
is actually an area of the code that sees pretty low traffic. I can find

392
00:26:38,774 --> 00:26:42,300
an issue in this case, there's an n plus one query

393
00:26:42,380 --> 00:26:45,504
that can be very easily identified by

394
00:26:45,542 --> 00:26:49,172
looking at the traces I just need to do it. I can look

395
00:26:49,226 --> 00:26:52,836
at the bottlenecks, understand who's using this code and so on, and let

396
00:26:52,858 --> 00:26:56,356
me transition over to where this issue is happening. And I can

397
00:26:56,378 --> 00:26:59,816
see where the culprit or the query that in this case

398
00:26:59,838 --> 00:27:03,240
is repeating over 101 times in each trace,

399
00:27:03,660 --> 00:27:07,560
I can understand who's being impacted by it. And again,

400
00:27:07,630 --> 00:27:10,220
this time I can look at the trace visualization.

401
00:27:10,640 --> 00:27:14,076
But sorry, in this case, it doesn't exist in this machine, but I

402
00:27:14,098 --> 00:27:17,772
can see that trace visualization from

403
00:27:17,826 --> 00:27:20,392
the point of view of the issue.

404
00:27:20,466 --> 00:27:24,144
So instead of looking around phishing for

405
00:27:24,182 --> 00:27:27,970
trouble, I'm kind of starting from the code, starting from

406
00:27:30,100 --> 00:27:33,372
the example, concrete example of something that I found,

407
00:27:33,526 --> 00:27:37,252
and then I can continue to explore and kind of

408
00:27:37,306 --> 00:27:40,784
look for trouble in dashboards. But it's now contextual

409
00:27:40,912 --> 00:27:44,804
to my work. So the vision is taking all of

410
00:27:44,842 --> 00:27:48,424
that amazing information. And I know that

411
00:27:48,462 --> 00:27:51,812
all of that information exists specifically

412
00:27:51,956 --> 00:27:55,224
because whenever something is wrong, we go

413
00:27:55,262 --> 00:27:58,564
and we dig deep deeper into logs and traces

414
00:27:58,612 --> 00:28:02,524
and we find troves of interesting things that if only

415
00:28:02,562 --> 00:28:05,932
we had known them earlier, we would have fixed them and make

416
00:28:05,986 --> 00:28:09,500
that just a part of my coding, making it

417
00:28:09,570 --> 00:28:12,972
so much closer to production. This code I'm looking at right now is already

418
00:28:13,026 --> 00:28:16,636
running in production. And here is what those productions

419
00:28:16,668 --> 00:28:19,712
or insights are telling me. And by the way, I'm learning a lot of things.

420
00:28:19,766 --> 00:28:23,264
For example, I'm seeing that this code only

421
00:28:23,302 --> 00:28:26,624
gets called in production and not by my local test. I can

422
00:28:26,662 --> 00:28:29,844
also see that there is a code here that's never reached, which is

423
00:28:29,882 --> 00:28:33,252
also interesting. So there's a lot of things that we can do just

424
00:28:33,306 --> 00:28:37,128
by putting on these new spectacles that allow us

425
00:28:37,294 --> 00:28:41,620
to understand how this code is actually running in production

426
00:28:41,780 --> 00:28:43,560
and not just theoretically.

427
00:28:47,900 --> 00:28:51,356
So how does one get started? With continuous feedback. This is a

428
00:28:51,378 --> 00:28:54,428
completely new uncharted water, but there are a

429
00:28:54,434 --> 00:28:58,616
lot of people who are also making really great forays

430
00:28:58,648 --> 00:29:03,680
into this new and great methodology.

431
00:29:04,420 --> 00:29:08,192
So first of all, I've created this web page which has

432
00:29:08,246 --> 00:29:11,584
a lot of quick start links that you can get started with.

433
00:29:11,702 --> 00:29:16,560
So if you go on continuousfeedback.org,

434
00:29:16,640 --> 00:29:20,532
let me go there right now. I've included some

435
00:29:20,586 --> 00:29:24,230
really interesting. Just 1 second.

436
00:29:28,540 --> 00:29:32,452
Yeah, I've included some interesting links,

437
00:29:32,516 --> 00:29:35,764
including getting started with opentelemetry. Yeager.

438
00:29:35,892 --> 00:29:39,524
I talk a little bit about digma here, some example projects,

439
00:29:39,572 --> 00:29:43,268
including the project that you just saw now with the Gringotts

440
00:29:43,284 --> 00:29:46,892
vaults, which you can easily get started running just using

441
00:29:46,946 --> 00:29:50,012
docker compose. Everything here is containerized and so on.

442
00:29:50,146 --> 00:29:53,856
So that's extremely easy and something that I would recommend

443
00:29:53,958 --> 00:29:55,170
everyone doing.

444
00:29:58,180 --> 00:30:01,744
I think one of the more fundamental things that need to change is more

445
00:30:01,782 --> 00:30:05,460
around culture. So in a similar way to what we had

446
00:30:05,530 --> 00:30:09,044
when we got started with testing, for example, it was very

447
00:30:09,082 --> 00:30:12,596
hard to convince developers that testing is a part

448
00:30:12,618 --> 00:30:15,664
of their job. I remember having conversations with developers.

449
00:30:15,712 --> 00:30:18,760
Tell me, what do you know? This is QA. Why am I doing testing?

450
00:30:20,300 --> 00:30:24,344
And in a similar manner, I think that today we're kind of taking the

451
00:30:24,382 --> 00:30:27,576
next step and saying, well, we need to own our code all the

452
00:30:27,598 --> 00:30:31,548
way to production, and that's a cultural change that's already happening.

453
00:30:31,634 --> 00:30:36,424
But I think embracing it and understanding what it means in terms of the ramifications

454
00:30:36,472 --> 00:30:40,076
for me as a developer is something that we all need to

455
00:30:40,098 --> 00:30:41,810
kind of learn more about.

456
00:30:43,460 --> 00:30:47,296
If we don't use and harvest the observability data

457
00:30:47,478 --> 00:30:50,720
we already have, then why are we collecting it?

458
00:30:50,790 --> 00:30:54,790
I think that's the second really important point. I've seen

459
00:30:55,160 --> 00:30:58,928
organizations that had amazing dashboards

460
00:30:58,944 --> 00:31:02,944
for observability and they were literally, they could just be screenshots or pictures

461
00:31:02,992 --> 00:31:06,544
on the wall. If we don't actually use them, make sure that

462
00:31:06,602 --> 00:31:08,280
we're using them in practice,

463
00:31:09,100 --> 00:31:12,536
then no point in collecting them, right? And if we're not

464
00:31:12,638 --> 00:31:16,132
using them, we're also kind of creating a very crippled

465
00:31:16,196 --> 00:31:19,756
process because we don't have any feedback loop between

466
00:31:19,858 --> 00:31:22,030
what is happening and what we're doing.

467
00:31:24,240 --> 00:31:27,884
Feedback is something that we need to implement in the process.

468
00:31:28,082 --> 00:31:32,440
And in the same way that we have scrum rituals like dailies

469
00:31:32,520 --> 00:31:36,076
or scrum of scrums, we also need to have feedback

470
00:31:36,108 --> 00:31:39,584
meetings. So it needs to be on the agenda. And I'm putting

471
00:31:39,622 --> 00:31:43,532
on my product manager hat here. If it's not on the agenda,

472
00:31:43,596 --> 00:31:46,908
we're just going to be completely biased towards the next feature and

473
00:31:46,934 --> 00:31:50,068
the next feature, and we're not coding to care about the feedback that

474
00:31:50,074 --> 00:31:53,508
we're receiving and whether it's actually doing what we think it's doing.

475
00:31:53,674 --> 00:31:57,664
So we need to have at least a biweekly feedback

476
00:31:57,712 --> 00:32:01,304
meeting where we're discussing the features that got into production. What do we know about

477
00:32:01,342 --> 00:32:04,376
them? What do we need to know about them more? This is the only way

478
00:32:04,398 --> 00:32:06,840
that we can make it a part of the agenda.

479
00:32:07,980 --> 00:32:11,164
So I'll be very happy to hear your

480
00:32:11,202 --> 00:32:15,116
thoughts about this really interesting topic and also

481
00:32:15,218 --> 00:32:18,972
to have you join the thinking. We have a slack group that's also

482
00:32:19,106 --> 00:32:22,892
in the links that I presented here. You're welcome

483
00:32:22,946 --> 00:32:26,476
to join it and share your thoughts. My contact details are

484
00:32:26,498 --> 00:32:29,980
also there I'm always happy to talk about this topic.

485
00:32:30,800 --> 00:32:34,404
This is it. It was a really great and amazing opportunity to

486
00:32:34,442 --> 00:32:37,924
talk here on conf fourty two. And please do

487
00:32:37,962 --> 00:32:39,010
reach out. Thank you.

