1
00:00:00,250 --> 00:00:01,630
Are you an SRE,

2
00:00:03,570 --> 00:00:04,830
a developer?

3
00:00:06,610 --> 00:00:10,014
A quality engineer who wants to tackle the challenge of

4
00:00:10,052 --> 00:00:13,534
improving reliability in your DevOps? You can enable your

5
00:00:13,572 --> 00:00:17,614
DevOps for reliability with chaos native. Create your

6
00:00:17,652 --> 00:01:17,202
free account at Chaos native Litmus Cloud afternoon,

7
00:01:17,266 --> 00:01:20,582
morning or evening everybody. Hope you're having a good conference so far.

8
00:01:20,716 --> 00:01:23,686
My name is Andrew Kirkpatrick and I'm here to talk to you today about self

9
00:01:23,708 --> 00:01:27,446
service pr based automated terraform. So maintaining your whole infrastructure using

10
00:01:27,468 --> 00:01:31,154
terraform and reusable modules makes most of our lives that little bit easier.

11
00:01:31,282 --> 00:01:34,662
But when those less familiar with DevOps want to create or update resources,

12
00:01:34,726 --> 00:01:38,518
you usually either have to train and enable them to use terraform or handle

13
00:01:38,534 --> 00:01:41,978
the request yourself. However, what if you could offload the execution of those changes to

14
00:01:41,984 --> 00:01:45,146
a centralized tool and just review both the code and output

15
00:01:45,178 --> 00:01:48,414
being submitted for review? Atlantis, terraform cloud,

16
00:01:48,452 --> 00:01:52,154
or m zero can act as a pr based feedback loop for a hosted terraform

17
00:01:52,202 --> 00:01:55,998
executor to make self service a little bit easier. So infrastructure

18
00:01:56,014 --> 00:01:58,626
as code solves some problems, but not all problems.

19
00:01:58,728 --> 00:02:02,574
So having a codified representation of everything in your infrastructure,

20
00:02:02,622 --> 00:02:06,306
whether that be cloud or on premise, is great, means you

21
00:02:06,328 --> 00:02:09,798
can point to exactly what line of code represents what thing.

22
00:02:09,964 --> 00:02:13,574
But on the same hand, that doesn't stop people continually bugging you

23
00:02:13,612 --> 00:02:17,618
for I need this change made, or can you look at this? Or something's

24
00:02:17,634 --> 00:02:21,482
not quite right here? And there are lots of legitimate reasons why people

25
00:02:21,536 --> 00:02:25,340
submit change requests. So they need like a new virtual machine for

26
00:02:25,710 --> 00:02:29,290
increasing capacity for an existing application, they need to test

27
00:02:29,360 --> 00:02:32,618
out a new application, they might need to make changes to a

28
00:02:32,624 --> 00:02:36,094
database configuration, all kinds of things. So what is

29
00:02:36,132 --> 00:02:39,486
important to keep track of? Do you actually need infrastructure engineers to

30
00:02:39,508 --> 00:02:43,166
make these changes, or are there very specific things in their day to day that

31
00:02:43,188 --> 00:02:46,594
are actually the more important parts to make note of?

32
00:02:46,712 --> 00:02:50,222
So do we need to make sure the changes being made are performed safely?

33
00:02:50,286 --> 00:02:54,174
To make sure that production infrastructure isn't accidentally misconfigured

34
00:02:54,222 --> 00:02:57,414
or deleted, or making sure that any changes, say,

35
00:02:57,452 --> 00:03:00,950
to network access is performed in compliance with

36
00:03:01,020 --> 00:03:04,738
whatever network policies you have? Making sure that any changes are actually tracked

37
00:03:04,754 --> 00:03:07,862
against specific individuals or particular teams or

38
00:03:07,996 --> 00:03:11,082
against specific projects. Making sure that the changes

39
00:03:11,136 --> 00:03:14,538
that you made are codified in a way that makes them reproducible so you

40
00:03:14,544 --> 00:03:19,302
can duplicate them or roll back in case of accidental misconfiguration.

41
00:03:19,446 --> 00:03:22,742
But most importantly, from a pr based perspective,

42
00:03:22,806 --> 00:03:26,302
is are we instituting a proper peer review process similar

43
00:03:26,356 --> 00:03:30,158
to a pull request perk workflow for regular code changes? And do we

44
00:03:30,164 --> 00:03:33,742
have approval by the correct chain of command, making sure that any changes that

45
00:03:33,796 --> 00:03:37,314
hit x, y or z are approved by the people that

46
00:03:37,512 --> 00:03:41,438
it should be run past. So why automate terraform? So Hashicorp

47
00:03:41,454 --> 00:03:45,794
control language is a great way to represent all kinds of different parts of infrastructure

48
00:03:45,842 --> 00:03:48,290
with many different vendors like AWS,

49
00:03:48,370 --> 00:03:52,642
GCP, Azure, plenty more. And one of the advantages

50
00:03:52,706 --> 00:03:56,310
of it is being able to kind of bundle up more complex

51
00:03:57,050 --> 00:04:00,466
concepts in modules. So kind of abstracting

52
00:04:00,498 --> 00:04:03,638
some of the complexity of I need this specific set of resources

53
00:04:03,654 --> 00:04:06,794
to go out in this exact configuration each time and making

54
00:04:06,832 --> 00:04:10,598
that kind of tweakable. So using the pre built building blocks

55
00:04:10,614 --> 00:04:13,774
that are sort of like that, would you be able to kind of hand those

56
00:04:13,812 --> 00:04:16,926
over to developers or other stakeholders to

57
00:04:16,948 --> 00:04:20,590
kind of roll out mostly cookie cutter bits of infrastructure,

58
00:04:20,930 --> 00:04:24,526
provide you kind of give them the guardrails to do so. And if

59
00:04:24,548 --> 00:04:27,418
you did that, how would you actually validate that those changes are going to be

60
00:04:27,444 --> 00:04:30,706
correct and make sure that the approval process is there to make

61
00:04:30,728 --> 00:04:34,114
sure that only the changes you want to go out and only the changes

62
00:04:34,152 --> 00:04:37,250
that should go out. So validation is kind of a key point.

63
00:04:37,320 --> 00:04:40,626
So terraform plan on the command

64
00:04:40,658 --> 00:04:44,006
line is these are the kind of changes that I'm proposing to make. What are

65
00:04:44,028 --> 00:04:47,506
you actually going to do based on the difference between the code that I've

66
00:04:47,538 --> 00:04:51,046
got and what's in remote state. So being able to validate

67
00:04:51,078 --> 00:04:54,486
and revalidate that, what's being put up, say, in a pull request

68
00:04:54,518 --> 00:04:58,074
in this example is accurate to what say

69
00:04:58,112 --> 00:05:01,450
the developer originally intended versus what say as

70
00:05:01,520 --> 00:05:05,038
an Sre you'd want to double check. Just making sure that

71
00:05:05,124 --> 00:05:08,974
that kind of matches up. And from an approval perspective, say if someone's making

72
00:05:09,012 --> 00:05:12,478
changes to core DNS records, making sure that

73
00:05:12,484 --> 00:05:16,222
say via a code owner's file or some kind of other validation that the correct

74
00:05:16,276 --> 00:05:19,874
people are getting notified to make sure they approve. Just in case, say we're making

75
00:05:19,912 --> 00:05:23,506
a change that could take down everything in production to make sure that the

76
00:05:23,528 --> 00:05:26,386
right checks and balances are in place, not just from an audit standpoint, but from

77
00:05:26,408 --> 00:05:29,846
a safety standpoint and making sure, say, if you've got

78
00:05:29,868 --> 00:05:33,718
integration between something like Jira and GitHub, that the right kind of

79
00:05:33,724 --> 00:05:37,366
workflows happen in other tools such as project management. So what are we going to

80
00:05:37,388 --> 00:05:40,246
talk about today? So this is just going to be a brief touch point on

81
00:05:40,268 --> 00:05:43,814
each of these topics, just kind of running through terraform

82
00:05:43,942 --> 00:05:47,718
how that kind of sits in a self service infrastructure concept

83
00:05:47,814 --> 00:05:50,806
and evaluating some of the tools that are there and going through a few examples

84
00:05:50,838 --> 00:05:53,914
of how that might work. So terraform at a glance,

85
00:05:54,042 --> 00:05:57,502
for anyone that's not familiar, it's actually kind of like a domain specific

86
00:05:57,556 --> 00:06:01,470
language representative in what's called hashic code control language of

87
00:06:01,620 --> 00:06:04,798
these are things that I wish to exist typically in

88
00:06:04,804 --> 00:06:08,706
the cloud, but also for on premise infrastructure. We also use it for identity and

89
00:06:08,728 --> 00:06:12,162
access management. So essentially any kind of thing that you want to

90
00:06:12,216 --> 00:06:15,614
create, update, update, or delete, fundamentally they just abstract underlying

91
00:06:15,662 --> 00:06:19,810
APIs behind terraform providers, which essentially translates

92
00:06:19,890 --> 00:06:23,298
how this code looks into API calls under the hood,

93
00:06:23,394 --> 00:06:26,566
and it works with many different providers. This is kind of the way that I

94
00:06:26,588 --> 00:06:30,646
typically think about it, which possibly not strictly correct, but I

95
00:06:30,668 --> 00:06:34,214
think of code as the things that I want to be true. If I've

96
00:06:34,262 --> 00:06:37,706
added, then I want these things to be created. If I've deleted, then I want

97
00:06:37,728 --> 00:06:41,254
these things to be removed. State is what either I

98
00:06:41,312 --> 00:06:45,022
or somebody else last caused to be true. So this is

99
00:06:45,156 --> 00:06:48,702
at last known time that we modified state what

100
00:06:48,756 --> 00:06:52,542
was true, and then the APIs represent what is actually

101
00:06:52,596 --> 00:06:55,710
true as of this moment. So if I'm going to try and make something,

102
00:06:55,860 --> 00:06:58,386
I'm going to ask you and you're going to tell me either whether it was

103
00:06:58,408 --> 00:07:02,402
successful or whether it failed. And remote state is kind of key to working with

104
00:07:02,536 --> 00:07:05,774
multiple engineers, which is typical for a team based setup,

105
00:07:05,822 --> 00:07:09,478
but also in the sense of a pool based workflow. It means that you

106
00:07:09,484 --> 00:07:12,934
can continue to use your local development workflow to work on all

107
00:07:12,972 --> 00:07:17,238
terraform projects as you do typically say, syncing state changes to

108
00:07:17,404 --> 00:07:21,194
an AWS S three bucket or Google cloud storage bucket for example.

109
00:07:21,312 --> 00:07:24,842
And then you use your central executor to also sync changes

110
00:07:24,896 --> 00:07:28,554
there. So it means you can collaborate using pool based

111
00:07:28,592 --> 00:07:32,666
workflows for some projects, but continue to use a local workflow for

112
00:07:32,688 --> 00:07:36,110
others. So as a basic example, just in case anyone hasn't seen,

113
00:07:36,180 --> 00:07:39,726
say this is how I would create a bucket, I would type this, but giving

114
00:07:39,748 --> 00:07:43,534
some basic details with some defaults that are provided by the resource, I would

115
00:07:43,572 --> 00:07:46,698
initialize it, which essentially because terraform is modular, just downloads

116
00:07:46,714 --> 00:07:50,418
the modules and well, those plugins rather that I need to communicate to

117
00:07:50,424 --> 00:07:53,966
the backend APIs I could plan, which means these are the API

118
00:07:53,998 --> 00:07:56,638
calls that are going to get sent. I would like to create this bucket,

119
00:07:56,734 --> 00:07:59,950
I would then apply, which then actually creates the underlying bucket as

120
00:07:59,960 --> 00:08:02,834
you can see in the UI. And then we'll write to state saying the bucket

121
00:08:02,882 --> 00:08:06,566
got written, and then subsequently if I deleted that code, it will

122
00:08:06,588 --> 00:08:10,198
say exists in state benign code so I must need to delete it.

123
00:08:10,284 --> 00:08:13,766
And then you see that becomes then reflected in the cloud. So that's

124
00:08:13,798 --> 00:08:16,550
great and all, but how does that hook into self service infrastructure?

125
00:08:16,630 --> 00:08:20,518
Infrastructure engineers usually write infrastructure code, and application engineers

126
00:08:20,614 --> 00:08:23,894
usually write application code, but that often results in the thrown

127
00:08:23,942 --> 00:08:27,200
over the wall antipatten. In terms of I've built this application,

128
00:08:27,570 --> 00:08:30,382
I don't want to care about how it's run, you go and figure it out,

129
00:08:30,436 --> 00:08:34,266
or I manage these servers, why don't you run applications

130
00:08:34,298 --> 00:08:38,030
that don't use too much memory? And that's kind of like a typical clash

131
00:08:38,110 --> 00:08:41,666
of historical dev and ops days that the whole DevOps ethos is trying to

132
00:08:41,688 --> 00:08:45,406
break down. And that kind of creates a couple of problems of infrastructure

133
00:08:45,438 --> 00:08:49,766
engineers want applications to be changed so that they don't cause too

134
00:08:49,788 --> 00:08:53,334
much memory, too much cpu or application engineers want

135
00:08:53,372 --> 00:08:56,770
to make a change to infrastructure because they need a different database,

136
00:08:56,850 --> 00:09:00,194
more servers, more capacity. We won't focus on the former,

137
00:09:00,322 --> 00:09:04,246
so today we'll kind of focus more on those latter of. How do these requests

138
00:09:04,278 --> 00:09:08,294
typically come in? So a lot of this say is either via a Jira ticket,

139
00:09:08,342 --> 00:09:11,866
a slack message, tap on the shoulder, other kind of

140
00:09:11,888 --> 00:09:15,006
just pop up, hey, I would like this thing, can you do

141
00:09:15,028 --> 00:09:19,134
it for me? And that just kind of represents typical toil that

142
00:09:19,252 --> 00:09:22,574
infrastructure, or sres, have to deal with on a day to day basis. So self

143
00:09:22,612 --> 00:09:26,420
service is designed to allow these people to do these things for themselves.

144
00:09:27,270 --> 00:09:30,818
That being said, writing terraform from scratch is pretty daunting. There's a

145
00:09:30,824 --> 00:09:34,386
reason why infrastructure engineers are generally the people that write all these

146
00:09:34,408 --> 00:09:37,550
complex configurations for, say, how load balancers are supposed to

147
00:09:37,560 --> 00:09:41,170
hook up with specific firewall rules, security groups, all of that jazz.

148
00:09:41,250 --> 00:09:44,920
So how do we kind of encapsulate that complexity away so that,

149
00:09:45,370 --> 00:09:49,282
say, an application developer can just throw up a server that automatically

150
00:09:49,346 --> 00:09:53,282
is in the right VPC, hooked up to the right security groups,

151
00:09:53,346 --> 00:09:56,634
all of that stuff, and it just kind of works transparently. So I

152
00:09:56,672 --> 00:10:00,406
tend to think of terraform modules as kind of classes of HCL,

153
00:10:00,518 --> 00:10:04,170
in that you should be able to configure attributes of specific things,

154
00:10:04,240 --> 00:10:07,758
but not everything. And all of the other stuff should kind of happen automatically out

155
00:10:07,764 --> 00:10:11,466
of the box. So as kind of example, using a digitalocean VM, there's lots

156
00:10:11,498 --> 00:10:15,086
of different attributes that you configure on the resource, but if you abstract

157
00:10:15,118 --> 00:10:19,326
that behind a module, you can say, either make things directly configurable via,

158
00:10:19,358 --> 00:10:23,362
say, the name, or you can use interpolation or even

159
00:10:23,416 --> 00:10:27,554
say, ternary statements or hashmap lookups. So say I'm using

160
00:10:27,752 --> 00:10:31,238
a string for environment to configure whether I want backups or monitoring to be in

161
00:10:31,244 --> 00:10:34,758
place. I'm interpolating cpus and memory into a specific

162
00:10:34,924 --> 00:10:38,374
string and then say I'm forcing things like I want

163
00:10:38,412 --> 00:10:41,250
this vm of this type to be in this region, I always want it to

164
00:10:41,260 --> 00:10:44,854
be in this image to make it consistent across say all invocations

165
00:10:44,902 --> 00:10:48,234
of this module or in particular all vms. Say if you wanted

166
00:10:48,272 --> 00:10:51,260
to use a pre baked packer image for example.

167
00:10:51,710 --> 00:10:55,706
So what options are there to kind of facilitate this from a pull request standpoint?

168
00:10:55,818 --> 00:10:59,038
So Atlantis was one of the first options out there,

169
00:10:59,204 --> 00:11:03,034
Terraform cloud subsorm that came along as quite a fully featured solution

170
00:11:03,082 --> 00:11:06,366
from Hashicorp themselves. Then n Zero is a relatively

171
00:11:06,398 --> 00:11:10,066
newer player that takes a slightly different twist on the concept. We'll lives into that

172
00:11:10,088 --> 00:11:14,062
in a moment. So Atlantis versus some of the alternatives.

173
00:11:14,206 --> 00:11:17,474
Atlantis works purely on the basis of pull

174
00:11:17,512 --> 00:11:20,694
requests, whether it be GitHub, GitLab or BitBucket. You can

175
00:11:20,732 --> 00:11:24,566
run it in a container typically, but it's just a go application. So anywhere that

176
00:11:24,588 --> 00:11:27,718
will run and it just responds to webhooks. So the kind

177
00:11:27,724 --> 00:11:31,270
of scope of what it does is very limited and specific to say this presentation.

178
00:11:31,350 --> 00:11:35,178
Those other tools are slightly more or less flexible. You can configure it

179
00:11:35,184 --> 00:11:38,710
to work with multiple repositories, multiple projects per repository,

180
00:11:38,790 --> 00:11:42,362
which is based on directory structure, and you can implement kind of

181
00:11:42,416 --> 00:11:45,518
custom workflows which we'll dive into in a bit. Terraform cloud on

182
00:11:45,524 --> 00:11:48,986
the other hand, is a solution that runs either entirely

183
00:11:49,018 --> 00:11:52,478
in the cloud, entirely on premise, or using a hybrid model where you

184
00:11:52,484 --> 00:11:56,218
can run the control plane in the cloud and then executers within your own environment.

185
00:11:56,394 --> 00:11:59,646
Bit uses an enhanced back env, so if you're familiar with remote

186
00:11:59,678 --> 00:12:02,782
stake for terraform, say if you store it in an s three bucket,

187
00:12:02,846 --> 00:12:06,498
it uses a specific special back env where

188
00:12:06,584 --> 00:12:10,146
local development and development in Terraform cloud will both communicate

189
00:12:10,178 --> 00:12:13,938
to a backend that exists in terraform cloud with some additional features.

190
00:12:14,034 --> 00:12:17,574
But it does kind of feature some other slight limitations in

191
00:12:17,612 --> 00:12:21,346
that how it works with workspaces is slightly different. So whereas Atlantis

192
00:12:21,378 --> 00:12:25,098
is only pr based, Terraform cloud offers many many different ways that

193
00:12:25,104 --> 00:12:28,374
you can work with it. So there's an API rest API that you can interact

194
00:12:28,422 --> 00:12:30,540
with, there's a CLI tool,

195
00:12:31,150 --> 00:12:34,702
it's much more fully featured. The actual confirmation screen

196
00:12:34,836 --> 00:12:38,474
for manual approvals for specific things actually happens within the interface

197
00:12:38,522 --> 00:12:41,854
itself, so it's not kind of triggered via pull

198
00:12:41,892 --> 00:12:45,198
requests, as we'll see later with Atlantis, but the UI is

199
00:12:45,284 --> 00:12:48,398
fairly simple to use and self explanatory. When you confirm those steps,

200
00:12:48,414 --> 00:12:51,346
you can see obviously everything happens exactly as you would see it normally on the

201
00:12:51,368 --> 00:12:54,834
CLI bit has some kind of handy features, like being

202
00:12:54,872 --> 00:12:58,178
able to block destroying things accidentally, and it has a

203
00:12:58,184 --> 00:13:01,682
lot of integrations in terms of notifying you when certain things have occurred

204
00:13:01,746 --> 00:13:05,606
within terraform cloud as an overall platform. Some of the gotchas that

205
00:13:05,628 --> 00:13:08,854
I came across is that it doesn't support SIM links, so I

206
00:13:08,892 --> 00:13:12,246
use some trickery to link TFRS files

207
00:13:12,278 --> 00:13:15,866
into auto TFRS files that's not supported. So it's just one

208
00:13:15,888 --> 00:13:19,146
of those things. There may be others, and one thing that got me initially is

209
00:13:19,168 --> 00:13:22,654
that bit only supports enhanced backends. Not that it's recommended to work with,

210
00:13:22,692 --> 00:13:26,554
but it will actually not. So it didn't read remote state from my GCS

211
00:13:26,602 --> 00:13:30,186
bucket. Mzero, on the other hand, uses what they call organization

212
00:13:30,298 --> 00:13:34,126
templates, and that's essentially kind of like a one

213
00:13:34,148 --> 00:13:37,218
to n carbon copy of any project that you have in a

214
00:13:37,224 --> 00:13:41,026
specific directory. So kind of the idea is more along those lines of

215
00:13:41,208 --> 00:13:44,702
ephemeral environments. Say if you wanted to spin up a dev environment

216
00:13:44,766 --> 00:13:48,466
based on a specific template, this is kind of a tool that's built around that

217
00:13:48,488 --> 00:13:51,686
kind of workflow and uses terraform workspaces to do it. It's a relatively new

218
00:13:51,708 --> 00:13:55,266
tool, so they're probably adding more features, and they probably have since I originally

219
00:13:55,298 --> 00:13:58,838
wrote this presentation, but it's definitely looking promising so far. So the

220
00:13:58,844 --> 00:14:02,018
project templates you can see, you can kind of create a workspace name. And this

221
00:14:02,044 --> 00:14:05,382
kind of differs from a typical workflow in that you don't pre create workspaces.

222
00:14:05,446 --> 00:14:08,742
Say like if you wanted everything to be a carbon copy, you have development,

223
00:14:08,806 --> 00:14:12,950
staging, production, you can just create these workspaces ad hoc,

224
00:14:13,030 --> 00:14:16,606
and that's kind of the intention, or at least what I took away from

225
00:14:16,788 --> 00:14:20,334
trying to use it. So those environments kind of pop up and you get

226
00:14:20,452 --> 00:14:24,062
what is intended to be like cookie cutter environments of,

227
00:14:24,196 --> 00:14:27,394
I want say this load balancer with these three

228
00:14:27,432 --> 00:14:30,814
application servers, one db like that, just like print,

229
00:14:30,862 --> 00:14:34,066
print, print and repeat. That makes it quite easy to do. So some

230
00:14:34,088 --> 00:14:37,074
of the neat features is that it's got cost limitations built in. So say,

231
00:14:37,112 --> 00:14:40,246
if you've got a team of 20 developers making sure that

232
00:14:40,268 --> 00:14:43,462
they don't just spin up infinite amounts of environments to test things

233
00:14:43,516 --> 00:14:47,298
so you don't run out of money, having things be truly ephemeral.

234
00:14:47,314 --> 00:14:50,134
So say if someone spins up a workspace to test something out,

235
00:14:50,252 --> 00:14:54,134
you can set how long it's supposed to last and it can be automatically destroyed

236
00:14:54,182 --> 00:14:57,670
after. And you can limit the number of environments per user.

237
00:14:57,830 --> 00:15:01,254
So kind of, I think it's a great feature for the environmental environments,

238
00:15:01,382 --> 00:15:04,094
and there's a lot of features that really help support that.

239
00:15:04,292 --> 00:15:07,786
So for the Gotchas, it doesn't actually support remote state. It literally

240
00:15:07,818 --> 00:15:11,310
copies state bars out of a working directory within m zero itself,

241
00:15:11,380 --> 00:15:14,640
because it runs entirely in the cloud and there's no other way to run it.

242
00:15:16,130 --> 00:15:19,234
And it uses workspaces to kind of manage that in a way

243
00:15:19,272 --> 00:15:23,086
that you never really see. So everything that kind of happens in m zero stays

244
00:15:23,118 --> 00:15:27,182
in m zero, which is useful if you are just using it to create environments

245
00:15:27,246 --> 00:15:31,126
on the fly. But for more long running infrastructure, it might not necessarily be

246
00:15:31,148 --> 00:15:34,978
the right fit. So how does this relate to pull request workflows?

247
00:15:35,074 --> 00:15:38,242
So some people have kind of asked, why don't you just use CI?

248
00:15:38,306 --> 00:15:41,762
Like, why don't you use something like Circle CI, hook it into that? You can

249
00:15:41,836 --> 00:15:45,174
do it. But there's a few kind of gotchas that Hashicorp themselves actually highlight

250
00:15:45,222 --> 00:15:49,034
quite well in their own documentation, one of which is making sure that

251
00:15:49,152 --> 00:15:52,698
when you plan on something, making sure that state hasn't changed.

252
00:15:52,714 --> 00:15:56,426
In the meantime, commits haven't been added to that, prs haven't

253
00:15:56,458 --> 00:16:00,286
been open, and plans run against them for the same project

254
00:16:00,388 --> 00:16:03,950
somewhere else. How that gets approved

255
00:16:04,290 --> 00:16:08,014
and actually trying to figure out which directory or which workspace

256
00:16:08,062 --> 00:16:11,346
on the same directory to work on. So kind of tricky things

257
00:16:11,368 --> 00:16:14,782
that you take for granted when you're working on it locally, but from an automated

258
00:16:14,846 --> 00:16:18,466
standpoint, those have to be sort of ways for it to identify. So the

259
00:16:18,488 --> 00:16:22,278
plan and apply synchronization is just if, say you're running it on CI and the

260
00:16:22,284 --> 00:16:25,462
plan can happen on any given machine, how do you get that plan

261
00:16:25,516 --> 00:16:29,254
out? File, make sure that it relates to a specific commit, and then have

262
00:16:29,292 --> 00:16:32,394
the plan and then subsequent apply happen on the exact

263
00:16:32,432 --> 00:16:35,574
same commit. So it's kind of a slightly odd

264
00:16:35,622 --> 00:16:38,826
workflow from a CI perspective, which is supposed to validate each commit as

265
00:16:38,848 --> 00:16:42,494
being golden and good. You'd have to write it to somewhere, cloud it back

266
00:16:42,532 --> 00:16:46,030
up. And then there's kind of the issue of the approval step.

267
00:16:46,180 --> 00:16:49,998
So if I've planned something out, how do I decide after

268
00:16:50,084 --> 00:16:53,438
potentially minutes, hours or days whether that's something that I

269
00:16:53,444 --> 00:16:56,670
want to do and know that things haven't changed in the meantime

270
00:16:56,830 --> 00:16:59,650
for something that's supposed to be continuously integrating,

271
00:17:00,470 --> 00:17:03,826
that's potentially hiccups. So it's not that you can, it's just

272
00:17:03,848 --> 00:17:07,666
having a nice. This is what I said I wanted to do. Am I sure

273
00:17:07,768 --> 00:17:10,726
this has been approved? I now want it. I'm now going to let it go

274
00:17:10,748 --> 00:17:14,646
ahead. You could do it automatically, but that has dangers. So in

275
00:17:14,668 --> 00:17:17,878
the context of a pr, how do you actually get feedback on what terraform is

276
00:17:17,884 --> 00:17:22,086
doing in the background? So Atlantis has a couple comment commands

277
00:17:22,198 --> 00:17:25,766
which you essentially comment on the pr, and it will trigger Atlantis plan and Atlantis

278
00:17:25,798 --> 00:17:29,498
apply, which triggers terraform plan and terraform apply.

279
00:17:29,584 --> 00:17:33,310
Correspondingly, it will show feedback of those commands actually as

280
00:17:33,380 --> 00:17:37,006
comments itself. If you assign like a machine user in say,

281
00:17:37,028 --> 00:17:40,318
GitHub, GitLab or BitBucket, Terraform cloud will

282
00:17:40,324 --> 00:17:43,998
only provide the feedback in its own user interface. N zero will

283
00:17:44,004 --> 00:17:47,146
also comment back, but doesn't have a corresponding status check, whereas Atlantis

284
00:17:47,178 --> 00:17:50,098
has both. So you can kind of see like it'll be churning away in the

285
00:17:50,104 --> 00:17:53,426
background. It'll eventually give you feedback on what's going on in

286
00:17:53,448 --> 00:17:56,754
terms of locking. So one of the issues I kind of mentioned before is

287
00:17:56,792 --> 00:18:00,230
if you're making changes to one project and someone else also makes changes

288
00:18:00,300 --> 00:18:03,590
to a project at the same time, how do you decide who goes first?

289
00:18:03,660 --> 00:18:07,078
Especially if you've both branched off of master or main? Atlantis has a

290
00:18:07,084 --> 00:18:10,934
concept of project locking, and this is

291
00:18:10,972 --> 00:18:14,486
separate from terraform state locking. So it will keep separate

292
00:18:14,518 --> 00:18:18,138
track of this and go. If I have planned out a pr over here

293
00:18:18,224 --> 00:18:21,942
and someone else tries to make changes to, say, development DNS,

294
00:18:22,086 --> 00:18:25,646
it'll go okay, you're trying to essentially make a same change to

295
00:18:25,668 --> 00:18:29,658
the same thing. This person was first, so they get to go first, and you'll

296
00:18:29,674 --> 00:18:33,326
see those locks pop up in the UI. You'll get a notification on

297
00:18:33,348 --> 00:18:36,846
a pull request that will basically say this plan has failed because you're not

298
00:18:36,868 --> 00:18:39,982
allowed to do it because someone else is first in the queue. That'll then become

299
00:18:40,036 --> 00:18:42,826
unlocked and bit will sort of show you. If you want to get this pushed

300
00:18:42,858 --> 00:18:46,566
through, you have to get the owner of this other pr to go first.

301
00:18:46,748 --> 00:18:50,214
Apply requirements essentially comes back to your version control system

302
00:18:50,252 --> 00:18:54,274
workflow. So if you're used to using GitHub, whatever approval

303
00:18:54,322 --> 00:18:58,006
workflow you use there could similarly apply, which is kind of nice because if you

304
00:18:58,028 --> 00:19:01,382
use things like code owners and people are very familiar with a GitHub,

305
00:19:01,446 --> 00:19:04,746
GitLab or BitBucket type workflow, this is essentially the

306
00:19:04,768 --> 00:19:08,234
same. So if you need two approvals before it's good to go.

307
00:19:08,272 --> 00:19:12,122
If you need code owners for specific people, for specific files, all of that works

308
00:19:12,176 --> 00:19:15,274
exactly the same and then mergeable requirements, basically making

309
00:19:15,312 --> 00:19:18,670
sure that it's not going to cause a code conflict. So exactly

310
00:19:18,740 --> 00:19:21,838
the same as most people are used to. And that I think is one of

311
00:19:21,844 --> 00:19:24,654
the kind of comforting things about it is that this is kind of a very

312
00:19:24,692 --> 00:19:28,770
similar workflow that people are used to in a lot of cases. Not necessarily

313
00:19:29,350 --> 00:19:32,418
all of those is good and well, but where does this actually happen? Where is

314
00:19:32,424 --> 00:19:35,646
terraform actually running? In the case of Atlantis, it's deployed

315
00:19:35,678 --> 00:19:39,814
into your infrastructure, so it runs from within. Webhooks are sent into

316
00:19:40,012 --> 00:19:43,590
some exposed DNS point, so it

317
00:19:43,660 --> 00:19:47,382
takes a little bit more configuration to set up. Terraform cloud, as I mentioned before,

318
00:19:47,436 --> 00:19:50,614
can be run entirely in those cloud with a control plane in the cloud,

319
00:19:50,652 --> 00:19:53,722
or agent pools that run in your infrastructure. So a hybrid model,

320
00:19:53,776 --> 00:19:56,874
or you can run it entirely on premise if you play for the enterprise plan.

321
00:19:56,992 --> 00:20:00,634
M zero on the other hand, runs entirely in the cloud. But one

322
00:20:00,672 --> 00:20:04,094
thing that some people don't necessarily consider to start with is

323
00:20:04,132 --> 00:20:07,402
that when you're normally working with terraform, you typically identify

324
00:20:07,466 --> 00:20:10,506
as yourself. So I am an SRE.

325
00:20:10,618 --> 00:20:13,866
I have these elevated credentials that work in

326
00:20:13,908 --> 00:20:16,782
say Google Cloud, AWS, GitHub,

327
00:20:16,926 --> 00:20:20,802
pagerduty, whatever provider that you're working with, you'll identify as

328
00:20:20,856 --> 00:20:25,060
you and you get elevated permissions on the things that you have access to control.

329
00:20:25,590 --> 00:20:29,206
Whereas if you're using a central executor, it typically has to be a service or

330
00:20:29,228 --> 00:20:32,854
a robot account that you give permission to on

331
00:20:32,892 --> 00:20:36,466
behalf of this one place. And then everyone essentially tells

332
00:20:36,498 --> 00:20:39,480
this one thing, the central executor, what to do.

333
00:20:39,850 --> 00:20:43,746
So that can be good and bad, depending on your viewpoint.

334
00:20:43,858 --> 00:20:47,178
But creating these service accounts is just kind of one consideration, and you need to

335
00:20:47,184 --> 00:20:50,362
figure out how to get those credentials into which is easier, say,

336
00:20:50,416 --> 00:20:53,674
in those cloud solutions like terraform cloud and n zero with

337
00:20:53,712 --> 00:20:56,878
Atlantis, you're going to have to figure but how to inject them. But being in

338
00:20:56,884 --> 00:20:59,742
mind that these work exactly the same as the providers normally do.

339
00:20:59,796 --> 00:21:03,326
So the configuration for that on your desktop, is it going to be exactly the

340
00:21:03,348 --> 00:21:06,314
same for, say, if you run it in Kubernetes? How are you going to inject

341
00:21:06,362 --> 00:21:10,094
those credentials into the Kubernetes pod if you're running it in Fargate,

342
00:21:10,142 --> 00:21:13,314
which I have done, same kind of thing, you need to just figure out how

343
00:21:13,352 --> 00:21:15,940
to get those credentials securely in there,

344
00:21:16,390 --> 00:21:20,038
which entirely depends on your security posture, how strict you

345
00:21:20,044 --> 00:21:23,750
need to be on that. So this is kind of a very basic example

346
00:21:23,900 --> 00:21:27,474
of how you can inject various secrets keys

347
00:21:27,602 --> 00:21:31,206
into an Atlantis pod. In Kubernetes.

348
00:21:31,398 --> 00:21:34,822
You can either fetch these from vault, given the correct integration,

349
00:21:34,886 --> 00:21:39,046
or say you could use Kubernetes external secrets. There's lots of different mechanisms.

350
00:21:39,078 --> 00:21:42,858
You can use. Anything which you're normally using for making you sure your secrets are

351
00:21:42,864 --> 00:21:46,154
more secure kind of applies here, but this is a bit more of a manual

352
00:21:46,202 --> 00:21:49,502
approach in terms of how that runs in the background. You can kind of see

353
00:21:49,556 --> 00:21:53,038
those is how Atlantis will figure out how to do things. So it has

354
00:21:53,044 --> 00:21:56,590
a Yaml file, similar ish to the other two,

355
00:21:56,740 --> 00:22:00,082
where you can basically say I want you to track these projects in those

356
00:22:00,136 --> 00:22:03,650
places. When you see changes, I want you to do these things

357
00:22:03,720 --> 00:22:07,006
and you can then apply customized workflows on top of that. But otherwise

358
00:22:07,038 --> 00:22:10,338
it runs pretty much as you run it on the desktop. Go to this directory

359
00:22:10,514 --> 00:22:13,618
init, plan and apply, and then print out the results.

360
00:22:13,714 --> 00:22:17,478
If you did want custom execution, those are certain ways that you can do

361
00:22:17,484 --> 00:22:20,602
that in Atlantis, much more limited in terraform cloud.

362
00:22:20,656 --> 00:22:23,402
But M zero also supports custom flows, which is kind of nice.

363
00:22:23,456 --> 00:22:26,842
So a potential weird example of this,

364
00:22:26,976 --> 00:22:30,406
say, if you needed to get specific special credentials,

365
00:22:30,598 --> 00:22:34,240
say for AWS, in this odd example,

366
00:22:34,610 --> 00:22:37,930
you can run custom scripts. So I can inject scripts into the pod,

367
00:22:38,010 --> 00:22:42,186
I can run essentially arbitrary commands before and after every corresponding

368
00:22:42,218 --> 00:22:45,970
terraform command for the plan and apply. So if I need to generate

369
00:22:46,470 --> 00:22:49,714
special tokens, modify tokens, if I need any

370
00:22:49,752 --> 00:22:53,534
kind of homegrown lives weirdness as part of your workflow,

371
00:22:53,662 --> 00:22:56,994
you can get that in there. So if any provider doesn't do what you want

372
00:22:57,032 --> 00:23:00,166
out of the box and you're doing anything funky, you can pretty much get.

373
00:23:00,188 --> 00:23:03,960
That's all set up to actually kind of show you how this looks and work.

374
00:23:05,610 --> 00:23:08,998
So we're going to edit a zone file, I'm going to delete one of the

375
00:23:09,004 --> 00:23:11,906
records that we've got, just as an example.

376
00:23:12,028 --> 00:23:16,166
So let's pull that out of there. So this is Google Cloud DNS.

377
00:23:16,278 --> 00:23:19,626
So you can see the Atlantis UI on the left hand side. Doesn't really do

378
00:23:19,648 --> 00:23:23,658
an awful lot. So I'm going to commit that change to version control,

379
00:23:23,824 --> 00:23:27,774
push that up, and then I'm going to create a pr

380
00:23:27,972 --> 00:23:30,922
off the back of that to say this is what I want to delete.

381
00:23:31,066 --> 00:23:34,554
I want my automation to make this change for me. So you see that pop

382
00:23:34,612 --> 00:23:38,834
up. I'm just following the link, put in a comment, explain to my team members

383
00:23:38,952 --> 00:23:42,274
what's going on and then hope

384
00:23:42,312 --> 00:23:45,774
that the relevant people will come along, review it. Obviously I haven't technically

385
00:23:45,822 --> 00:23:49,502
reviews in this example, but get the point. You see, the Atlantis plan

386
00:23:49,576 --> 00:23:53,046
will happen in the status check. Eventually it will comment back and say this is

387
00:23:53,068 --> 00:23:56,466
what I plan to do. I'm going to delete this DNS

388
00:23:56,498 --> 00:23:59,722
record because that's what you said you wanted. So I'm like okay, great,

389
00:23:59,856 --> 00:24:03,370
Atlantis apply, let's get this DNS record blasted.

390
00:24:03,870 --> 00:24:08,858
You go to apply that and the comment you'll get back is you

391
00:24:08,864 --> 00:24:11,360
need someone to approve this. I'm not going to do it,

392
00:24:11,810 --> 00:24:15,390
so go and get someone. So special person

393
00:24:15,460 --> 00:24:18,826
comes over, reviews, everything looks good. So let's comment

394
00:24:18,858 --> 00:24:21,998
Atlantis apply again. The way that I've got my

395
00:24:22,004 --> 00:24:25,578
workflow set up, once everything's good and

396
00:24:25,604 --> 00:24:29,646
golden it'll apply and I set it to automatically

397
00:24:29,678 --> 00:24:33,538
merge the branch for me and then delete it off the back of that in

398
00:24:33,544 --> 00:24:36,786
terms of how the locking looks. So say we've

399
00:24:36,818 --> 00:24:40,454
already got a pr up that says I want to delete this

400
00:24:40,492 --> 00:24:44,262
record. I'm being to add the change in,

401
00:24:44,396 --> 00:24:47,334
pop the record back in. So let's say,

402
00:24:47,372 --> 00:24:50,986
yeah, I want this record back. Why is it gone? I needed it.

403
00:24:51,088 --> 00:24:54,474
So we'll put up the branch, create a PI just

404
00:24:54,512 --> 00:24:55,340
like before,

405
00:24:59,800 --> 00:25:03,268
open that up and then we'll let Atlantis work away in

406
00:25:03,274 --> 00:25:06,596
the background and you get an error message which will say this project is

407
00:25:06,618 --> 00:25:09,528
currently locked by unapplied plan. You take a quick look in the UI and you

408
00:25:09,534 --> 00:25:12,852
can see that pop up. It's for this repository,

409
00:25:12,996 --> 00:25:16,632
this project. So you can click through onto that and go ah,

410
00:25:16,766 --> 00:25:20,520
okay, so they need to go first that's locked.

411
00:25:20,680 --> 00:25:23,790
Once that goes through, then I get my turn.

412
00:25:24,480 --> 00:25:27,740
So as for n Zero, say I want to create a project environment.

413
00:25:28,560 --> 00:25:32,496
I will go to a project template which is going to be essentially a project

414
00:25:32,598 --> 00:25:36,336
somewhere in my repository, in a version control system. I'll say

415
00:25:36,358 --> 00:25:39,996
I want you to make a new workspace, give me a new project environment that's

416
00:25:40,028 --> 00:25:43,872
based off this project. So it's going to go through, clone out the repository,

417
00:25:43,936 --> 00:25:47,508
go through very similar steps, initialize everything and then it will

418
00:25:47,514 --> 00:25:51,088
give me a plan and we'll wait for approval. Say I'm

419
00:25:51,104 --> 00:25:54,964
being to make these resources that are in this project, like this is what I

420
00:25:55,002 --> 00:25:58,376
plan to do, do you want to do it? So manual approval, step in those

421
00:25:58,398 --> 00:26:01,976
UI here, you'll go through there, think about

422
00:26:01,998 --> 00:26:05,610
it some more and eventually apply it and create the environment for you.

423
00:26:07,760 --> 00:26:11,070
See that everything was created and then we're good to go.

424
00:26:11,920 --> 00:26:15,932
In terms of a pull request workflow. Say we're going to jump into

425
00:26:15,986 --> 00:26:19,328
our zone file here again, delete a record, and then we're going

426
00:26:19,334 --> 00:26:22,572
to commit that and push that up. Same workflow as usual,

427
00:26:22,636 --> 00:26:24,080
but up a pull request.

428
00:26:27,260 --> 00:26:30,824
So once the change is up, go through the same process as

429
00:26:30,862 --> 00:26:33,420
before, add a comment for clarity.

430
00:26:35,360 --> 00:26:39,100
And then once we've created it, you'll see that M Zero

431
00:26:39,170 --> 00:26:42,508
will eventually comment back saying this is the plan of things that

432
00:26:42,514 --> 00:26:43,630
I plan to do.

433
00:26:52,410 --> 00:26:56,006
Takes a little while, and then success, we flip back, you'll see that

434
00:26:56,028 --> 00:26:59,434
bit essentially comments back similar to how Atlantis did, saying I'm going to create

435
00:26:59,472 --> 00:27:01,100
these resources for you.

436
00:27:09,720 --> 00:27:13,332
Once that's all approved by somebody, I'll be able to get that merged

437
00:27:13,396 --> 00:27:17,208
in. Then that will trigger an actual apply. So this is kind

438
00:27:17,214 --> 00:27:21,284
of the difference between this, say an Atlantis and in fact terraform

439
00:27:21,332 --> 00:27:24,456
cloud in that you will get the plan and kind of

440
00:27:24,478 --> 00:27:27,036
like a preview of what changes are going to be made ahead of time.

441
00:27:27,138 --> 00:27:30,600
And then once those have actually been merged back into your master or main branch,

442
00:27:30,680 --> 00:27:34,844
that's when the apply happens. So just kind of a difference of what

443
00:27:34,882 --> 00:27:38,256
happens before or after. You'll get the manual approval step here,

444
00:27:38,278 --> 00:27:42,224
which appears in the UI itself saying this has all been merged into

445
00:27:42,262 --> 00:27:45,680
main. This is what I'm going to now create

446
00:27:45,830 --> 00:27:49,990
for this project environment for this workspace for this project. Are you sure?

447
00:27:50,600 --> 00:27:54,116
Rolls ahead. Terraform apply creates that and then just gives

448
00:27:54,138 --> 00:27:57,584
you those output. In terms of terraform

449
00:27:57,632 --> 00:28:01,712
cloud, you can run a plan manually, say via the user interface

450
00:28:01,856 --> 00:28:05,530
that looks fairly similar to the other two. In terms of what it looks like.

451
00:28:05,900 --> 00:28:09,448
You'll see a plan. What I plan to do, you'll get a

452
00:28:09,454 --> 00:28:13,244
manual confirmation step similar to m zero, which you have to agree to in

453
00:28:13,282 --> 00:28:16,872
the terraform cloud UI apply finishes.

454
00:28:17,016 --> 00:28:20,636
All good. And that's pretty similar. In terms

455
00:28:20,658 --> 00:28:23,852
of how that works in a pull request workflow. Very kind of similar.

456
00:28:23,906 --> 00:28:27,170
I'm going to delete a record from a DNS server again.

457
00:28:27,700 --> 00:28:31,852
Let's delete it, get that committed, get that pushed up to a pull request.

458
00:28:31,996 --> 00:28:35,090
So you'll see the change comes up. Let's create that,

459
00:28:35,620 --> 00:28:37,620
add another comment for clarity.

460
00:28:39,640 --> 00:28:43,584
And then you'll see that terraform

461
00:28:43,632 --> 00:28:46,676
cloud will show the outputs of what it plans to

462
00:28:46,698 --> 00:28:50,096
do off the back of that. So you'll see that show up as a status

463
00:28:50,128 --> 00:28:53,496
check, but it won't actually comment back on the PR itself. Once I've

464
00:28:53,518 --> 00:28:57,480
got an approval from someone, I'll get that merged in. So that's merged into Main,

465
00:28:57,630 --> 00:29:01,240
I can then see similar to m zero, but more similar

466
00:29:01,310 --> 00:29:04,780
to how Atlantis works. And I'll see the apply actually

467
00:29:04,850 --> 00:29:08,204
come up here with their manual confirmation step

468
00:29:08,322 --> 00:29:11,464
in the same way. Let's say, okay, these changes now remain,

469
00:29:11,512 --> 00:29:15,144
it's good to go, let's run that apply, let's get that approved,

470
00:29:15,192 --> 00:29:18,520
and then that's now applied and out into the wild.

471
00:29:18,680 --> 00:29:22,108
So what are some of the advantages and drawbacks of a PR based workflow?

472
00:29:22,204 --> 00:29:25,616
So some of the advantages are that, say, if you're working with

473
00:29:25,638 --> 00:29:29,212
people that need to make infrastructure changes from time to time, but they don't necessarily

474
00:29:29,276 --> 00:29:32,292
have everything checked out, set up good to go,

475
00:29:32,346 --> 00:29:35,376
because that's what they do day to day. It allows people to kind of dip

476
00:29:35,408 --> 00:29:39,012
in and out of making infrastructure contributions, which is nice for people that

477
00:29:39,066 --> 00:29:42,632
need to make changes now and then. It also kind of adds a proper

478
00:29:42,686 --> 00:29:46,536
peer review process before execution, which is nice. So I

479
00:29:46,558 --> 00:29:50,296
imagine myself and probably many other people make

480
00:29:50,318 --> 00:29:54,104
sure they actually terraform, apply certain things to make sure that things happen. Because as

481
00:29:54,142 --> 00:29:57,868
anyone that's used more early stage terraform providers know that sometimes

482
00:29:57,954 --> 00:30:01,230
just because something looks good on a plan doesn't necessarily mean it will work.

483
00:30:01,600 --> 00:30:04,652
Also, there can potentially be conflicting things in,

484
00:30:04,706 --> 00:30:08,736
say, AWS GCP that aren't necessarily apparent when

485
00:30:08,758 --> 00:30:12,064
you try and make changes via the API. Sometimes it's nice to catch things like

486
00:30:12,102 --> 00:30:15,392
this. In this case, say with Atlantis, you'll catch that

487
00:30:15,446 --> 00:30:19,036
pre pr merge, which is kind of nice bit ties in nicely

488
00:30:19,068 --> 00:30:22,484
into other workflow automated tools. So anything that else that hooks up to

489
00:30:22,522 --> 00:30:26,560
your version control system, say, if you want to hook things into Jira,

490
00:30:26,640 --> 00:30:30,564
like for full auditability, making sure that fires off this,

491
00:30:30,602 --> 00:30:33,448
that and the other to any other systems, just to make sure that checks and

492
00:30:33,454 --> 00:30:36,868
balances are in place, it potentially decreases your credential theft.

493
00:30:36,964 --> 00:30:40,456
But the flip side of that is obviously now your

494
00:30:40,478 --> 00:30:44,188
credentials are in one place and it can alleviate some

495
00:30:44,194 --> 00:30:47,388
of your kind of toil bottlenecks. But a lot of that is going to depend

496
00:30:47,474 --> 00:30:51,128
on people's familiarity and comfort with a peer

497
00:30:51,144 --> 00:30:55,292
review process. So how kind of streamlined are your

498
00:30:55,346 --> 00:30:58,928
prs flowing through normally? How are

499
00:30:59,014 --> 00:31:01,730
people used to that kind of workflow as it is?

500
00:31:02,180 --> 00:31:05,552
Also sort of how well documented is not only your own code

501
00:31:05,606 --> 00:31:09,088
base, but say the providers that you're using. So if you're using some of

502
00:31:09,094 --> 00:31:12,928
the providers that are less well used, less well known,

503
00:31:13,024 --> 00:31:15,876
that can be a bit more difficult for people who are not familiar day to

504
00:31:15,898 --> 00:31:19,476
day to kind of drop code in and making sure that

505
00:31:19,498 --> 00:31:22,936
the code that's been written and preexist is actually easy enough to work

506
00:31:22,958 --> 00:31:26,200
with. So if you're not making efficient use of modules,

507
00:31:26,540 --> 00:31:30,280
if you haven't segregated your projects up into small

508
00:31:30,350 --> 00:31:33,908
enough chunks, it can be a bit unwieldy to work with. And that can be

509
00:31:33,934 --> 00:31:37,308
scary, especially for someone seeing feedback on a

510
00:31:37,314 --> 00:31:40,616
pull request. I didn't ask to delete 100 servers.

511
00:31:40,648 --> 00:31:43,932
What's going on can be scary. Some of the disadvantages though

512
00:31:43,986 --> 00:31:47,536
is that say especially if you're developing a module, the feedback cycle can be

513
00:31:47,558 --> 00:31:51,324
really slow if you're fully reliant on a central executor or remote

514
00:31:51,372 --> 00:31:54,704
executor, rather to be previewing what you want to do.

515
00:31:54,742 --> 00:31:58,016
So like me committing code, pushing it up, waiting for something in the cloud to

516
00:31:58,038 --> 00:32:01,428
churn away and tell me if that's good or not is a lot slower than

517
00:32:01,434 --> 00:32:05,232
me just developing it locally. So I typically develop modules

518
00:32:05,296 --> 00:32:08,756
locally for reusable for other people and then once they're kind of tested and good

519
00:32:08,778 --> 00:32:12,544
to go, start hooking those projects that use those modules

520
00:32:12,592 --> 00:32:15,924
up to self service. One somewhat

521
00:32:15,972 --> 00:32:19,720
controversial point, depending on how identity access

522
00:32:19,790 --> 00:32:23,244
management is handled at your company, is that you then kind of move some

523
00:32:23,282 --> 00:32:26,524
security controls from say like

524
00:32:26,562 --> 00:32:29,980
my AWS account, my GCP account, to version control.

525
00:32:30,050 --> 00:32:33,660
So you then sort of delegate power to my GitHub account,

526
00:32:33,730 --> 00:32:37,836
my GitLab account. That may or may not be desirable or

527
00:32:37,858 --> 00:32:41,170
bit may be completely anonymous depending on your security model.

528
00:32:41,620 --> 00:32:45,296
As mentioned, having kind of a skeleton key, one thing that has credentials to

529
00:32:45,318 --> 00:32:48,992
everything can potentially be a risk, but really

530
00:32:49,046 --> 00:32:52,864
you can apply those same kind of secrets management technologies

531
00:32:52,912 --> 00:32:56,116
that you would to the rest of your infrastructure. So in theory it's no more

532
00:32:56,138 --> 00:32:59,744
or less vulnerable, depending also making sure you don't host it in places

533
00:32:59,792 --> 00:33:03,136
that are like a big attack vector. So not putting in production

534
00:33:03,168 --> 00:33:06,744
like we run it in a separate cluster, you've got to maintaining yet

535
00:33:06,782 --> 00:33:09,688
another thing. So Atlantis is pretty easy to set up, but at the end of

536
00:33:09,694 --> 00:33:12,264
the day it's something we do have to manage and keep an eye on.

537
00:33:12,382 --> 00:33:15,416
And it can be problematic if it runs on some of the same infrastructure that

538
00:33:15,438 --> 00:33:18,776
it controls. So trying to make cluster updates to the same cluster

539
00:33:18,808 --> 00:33:22,408
that it's on, it's not really much of an issue, but it can catch

540
00:33:22,424 --> 00:33:26,380
you out if you're not paying attention. So why did we choose Atlantis

541
00:33:26,960 --> 00:33:30,784
open source? And being free to use was a big one. It's quite

542
00:33:30,822 --> 00:33:34,496
well maintained and there's been a lot of contributions to it. So it's not

543
00:33:34,518 --> 00:33:38,352
like a dead project. It's pretty active, to be honest, it's pretty easy

544
00:33:38,406 --> 00:33:41,616
to use. There's not a huge amount of functionality in it, but of

545
00:33:41,638 --> 00:33:45,280
the functionality that we needed, it covers most of our bases. And the flexibility

546
00:33:45,360 --> 00:33:49,152
with custom workflows and being able to inject firebase configurations,

547
00:33:49,216 --> 00:33:52,704
say for managing multiple kubernetes clusters is kind of useful,

548
00:33:52,752 --> 00:33:56,504
which was less obvious to do with the other tools. But as I mentioned before,

549
00:33:56,542 --> 00:33:59,828
it's been a little while since I evaluated terraform cloud and Mzero,

550
00:34:00,004 --> 00:34:02,824
and they've been moving at very rapid pace, both of them.

551
00:34:02,862 --> 00:34:06,476
So definitely worth checking out, sort of where their feature set lies at the moment.

552
00:34:06,658 --> 00:34:10,156
So in summary, Atlantis is

553
00:34:10,178 --> 00:34:13,852
great. It runs entirely on premise, which is quite nice for some people,

554
00:34:13,906 --> 00:34:16,556
but you are going to have to set it up yourself, figure out how to

555
00:34:16,578 --> 00:34:19,856
run it, and you're going to have to manage how secrets get into there.

556
00:34:19,958 --> 00:34:23,264
So a little bit more to be concerned about. It's not out of those box.

557
00:34:23,462 --> 00:34:27,392
M zero seems like a great solution for I want to allow

558
00:34:27,446 --> 00:34:31,096
people to make sort of environments on the fly. I want developers

559
00:34:31,148 --> 00:34:35,280
to quickly test out features with production like environments. I think it's an excellent,

560
00:34:35,360 --> 00:34:38,900
or it looks like an excellent tool for that. Terraform cloud on the other hand,

561
00:34:38,970 --> 00:34:42,216
is kind of the big guns enterprise solution. So you can

562
00:34:42,238 --> 00:34:45,896
use that. Everything from it covers everything that Atlantis does all those

563
00:34:45,918 --> 00:34:49,976
way up to managing big company stuff. So I

564
00:34:49,998 --> 00:34:53,780
think the feature set there is endlessly growing

565
00:34:53,940 --> 00:34:56,856
and I think for a lot of companies that's probably going to be the logical

566
00:34:56,888 --> 00:35:00,092
one to choose. But it really depends on what you're after,

567
00:35:00,226 --> 00:35:04,076
especially because their level of support. Know there are plenty of people at

568
00:35:04,098 --> 00:35:07,356
Hashicorp that can help you out with that. Thank you very

569
00:35:07,378 --> 00:35:11,288
much for listening. I'm Andrew Kirkpatrick. If anybody's interested in engineering

570
00:35:11,304 --> 00:35:14,728
at Partnerstack, please take a look at our job vacancies.

571
00:35:14,904 --> 00:35:18,484
The link to this slide deck is on slideshare and if you have any

572
00:35:18,522 --> 00:35:21,760
questions I'm at magic, but on the Internet,

573
00:35:21,920 --> 00:35:25,044
just come and ping me and ask me a question. Thank you very much and

574
00:35:25,082 --> 00:35:26,130
hope you have a lovely day.

