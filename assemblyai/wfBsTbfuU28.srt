1
00:00:25,570 --> 00:00:29,254
Um, hello, let's start

2
00:00:29,292 --> 00:00:33,494
with few numbers. More than 4000 is

3
00:00:33,532 --> 00:00:37,960
the publicly disclosed data breaches occurred in 2021

4
00:00:38,650 --> 00:00:42,034
and that implied 22 billion

5
00:00:42,162 --> 00:00:46,130
records being exposed with private

6
00:00:46,210 --> 00:00:50,638
information. It's a lot of private information

7
00:00:50,804 --> 00:00:54,186
being publicly disclosed,

8
00:00:54,378 --> 00:00:57,886
don't you think? I'm going

9
00:00:57,908 --> 00:01:01,694
to talk about zero trust and why you should not trust

10
00:01:01,812 --> 00:01:05,540
anyone in your system and validate everyone.

11
00:01:06,870 --> 00:01:10,894
What can you expect of this presentation? Well, it's a simple introduction

12
00:01:10,942 --> 00:01:14,626
to zero trust. Don't expect super

13
00:01:14,728 --> 00:01:18,226
detailed information about it. It's not the

14
00:01:18,248 --> 00:01:21,858
only way that you can implement a similar approach.

15
00:01:22,034 --> 00:01:25,782
And finally I will give you an example with a

16
00:01:25,916 --> 00:01:28,310
live demo with istio,

17
00:01:28,390 --> 00:01:32,106
quarkus Java and local

18
00:01:32,208 --> 00:01:35,914
cluster. My goal for this presentation is

19
00:01:35,952 --> 00:01:40,038
very simple, just light a

20
00:01:40,064 --> 00:01:43,662
sparkle of curiosity about zero trust architecture on

21
00:01:43,716 --> 00:01:47,182
you. So if you at the time that

22
00:01:47,236 --> 00:01:50,574
this presentation finishes you have this feeling of I

23
00:01:50,612 --> 00:01:56,050
want to explore more, let's do PoC

24
00:01:56,710 --> 00:02:00,066
and see how this works. Then I

25
00:02:00,088 --> 00:02:04,130
will be more than happy. Obviously if you have any doubt

26
00:02:05,530 --> 00:02:08,918
I don't know anything to discuss about zero trust.

27
00:02:09,004 --> 00:02:12,934
I will be more than happy to answer them or

28
00:02:12,972 --> 00:02:15,080
find someone that can help you.

29
00:02:15,850 --> 00:02:19,226
I'm Jonathan Vila, I'm Java champion and

30
00:02:19,328 --> 00:02:22,986
have a long time experience

31
00:02:23,088 --> 00:02:26,538
with the community. First with one of the

32
00:02:26,544 --> 00:02:29,706
leaders of the Java Barcelona community and also one

33
00:02:29,728 --> 00:02:33,642
of the founders of JVCN and DevCN conferences.

34
00:02:33,786 --> 00:02:37,066
I've been working in few conference

35
00:02:37,098 --> 00:02:40,814
and meetups. I'm developer for more than 30 years

36
00:02:40,932 --> 00:02:44,642
in several languages and now I'm currently working

37
00:02:44,696 --> 00:02:47,250
as a developer advocate for Sonar.

38
00:02:48,630 --> 00:02:52,562
Sonar is a company that has few products about clean

39
00:02:52,616 --> 00:02:56,722
code. It analyzes your code and gives you hints

40
00:02:56,786 --> 00:03:00,050
issues of some things that you can solve.

41
00:03:00,130 --> 00:03:03,202
It has three main products sonarlint

42
00:03:03,266 --> 00:03:06,934
that it is completely free that you can install in your ide and will

43
00:03:06,972 --> 00:03:10,598
detect your code as you type it.

44
00:03:10,764 --> 00:03:14,598
Sonarcube that it is an on premise solution

45
00:03:14,694 --> 00:03:18,234
that can analyze your different projects and

46
00:03:18,272 --> 00:03:21,594
it's open source and you can download it and sonar

47
00:03:21,642 --> 00:03:25,422
cloud that it is the hosted solution that it is free for

48
00:03:25,476 --> 00:03:28,958
open source projects. So you want to

49
00:03:28,964 --> 00:03:32,506
try them, just go to sonarsource.com or come

50
00:03:32,548 --> 00:03:34,820
to me and ask me about it.

51
00:03:35,750 --> 00:03:39,202
So let's start with the usual context about

52
00:03:39,256 --> 00:03:42,610
security trust on perimeter.

53
00:03:44,390 --> 00:03:47,942
So when we have trust on the perimeter, as you can see here

54
00:03:47,996 --> 00:03:51,894
in this diagram, well we have a user that

55
00:03:51,932 --> 00:03:55,266
it is verified through. Well it tries

56
00:03:55,298 --> 00:03:58,534
to connect to service a but this passes

57
00:03:58,582 --> 00:04:02,506
through a gateway. This gateway will check

58
00:04:02,688 --> 00:04:06,598
with an identity and access management

59
00:04:06,774 --> 00:04:10,358
tool and it will say okay you are

60
00:04:10,384 --> 00:04:13,854
validated, you can go to the service a. Okay, so the

61
00:04:13,892 --> 00:04:17,182
service a call will call again to

62
00:04:17,236 --> 00:04:20,974
service b, and then this service b will

63
00:04:21,012 --> 00:04:24,642
connect to the database one. It also can happen

64
00:04:24,696 --> 00:04:28,274
that service a needs to connect to service c,

65
00:04:28,392 --> 00:04:32,578
and this will connect to db two. So this is

66
00:04:32,744 --> 00:04:35,830
like the happy path when everything works fine,

67
00:04:35,900 --> 00:04:39,750
right? And just in case

68
00:04:39,820 --> 00:04:43,202
that the user is not validated

69
00:04:43,266 --> 00:04:46,406
by the system, the call from the gateway to the

70
00:04:46,428 --> 00:04:49,946
service a will be not allowed. So it

71
00:04:49,968 --> 00:04:52,860
will be rejected. So, yeah,

72
00:04:54,110 --> 00:04:57,814
everything's fine. So only validated users

73
00:04:57,862 --> 00:05:01,358
can go through the gateway to the service a.

74
00:05:01,444 --> 00:05:02,480
That's perfect.

75
00:05:04,850 --> 00:05:09,134
But the problem that we find here is that everything

76
00:05:09,252 --> 00:05:11,866
has been controlled by the gateway.

77
00:05:12,058 --> 00:05:15,346
So it's the gateway who receives the

78
00:05:15,368 --> 00:05:19,522
request and then decides according to what the

79
00:05:19,656 --> 00:05:24,290
yam application has answered,

80
00:05:24,890 --> 00:05:28,374
if the Getgo is going to allow the connection or not

81
00:05:28,412 --> 00:05:32,038
to the service a. But what if for,

82
00:05:32,204 --> 00:05:35,702
I don't know, some reasons someone can

83
00:05:35,756 --> 00:05:38,918
reach service b? I don't

84
00:05:38,934 --> 00:05:43,610
know. Lockforget, for instance, had CBE

85
00:05:43,950 --> 00:05:47,610
that allowed remote execution.

86
00:05:48,110 --> 00:05:52,586
So let's imagine that someone reaches

87
00:05:52,698 --> 00:05:56,480
service b and adds an application there.

88
00:05:57,970 --> 00:06:01,502
What we have here is that we

89
00:06:01,556 --> 00:06:04,722
trust everything that it is in our system,

90
00:06:04,856 --> 00:06:09,874
because we thought the only way

91
00:06:09,912 --> 00:06:13,170
to enter the system was through the gateway.

92
00:06:13,830 --> 00:06:17,670
Let's imagine an analogy. We have a

93
00:06:17,740 --> 00:06:21,606
building, and we have security on

94
00:06:21,628 --> 00:06:25,574
the main floor, on the entrance. So you go to that

95
00:06:25,612 --> 00:06:28,922
building to work, as every

96
00:06:28,976 --> 00:06:32,970
day that you do, and you show them

97
00:06:33,120 --> 00:06:37,002
your identification, they check either

98
00:06:37,056 --> 00:06:39,340
with the machine or either with a system,

99
00:06:39,970 --> 00:06:43,374
manual system, whatever they say,

100
00:06:43,412 --> 00:06:47,150
okay, you are allowed to enter the building. So once

101
00:06:47,220 --> 00:06:51,742
you are inside the building, you could go to any

102
00:06:51,796 --> 00:06:54,740
room or any story.

103
00:06:55,510 --> 00:06:58,642
The thing is that if you want to prevent that,

104
00:06:58,776 --> 00:07:02,302
you will have to create more identity

105
00:07:02,366 --> 00:07:06,006
validations. Therefore, for each room you are going to

106
00:07:06,028 --> 00:07:09,190
have a validation, or for

107
00:07:09,260 --> 00:07:12,630
each story. Well, validation in the elevator.

108
00:07:13,450 --> 00:07:17,218
So what happens is that usually you enter a building,

109
00:07:17,404 --> 00:07:20,954
you have access to everything except for two or three

110
00:07:20,992 --> 00:07:23,260
rooms that you need a private access.

111
00:07:25,470 --> 00:07:28,954
But what if I leave the

112
00:07:28,992 --> 00:07:30,880
toilet window open?

113
00:07:32,130 --> 00:07:35,950
So the person that can get into the building

114
00:07:36,100 --> 00:07:39,934
through that window immediately have access to

115
00:07:39,972 --> 00:07:42,830
everything except for those two rooms.

116
00:07:43,350 --> 00:07:47,458
Because the identity validation happens only

117
00:07:47,624 --> 00:07:51,540
on the main gate. In this case,

118
00:07:52,150 --> 00:07:56,130
you can see someone has added malicious

119
00:07:56,210 --> 00:07:59,862
application on service b, and then this service B

120
00:07:59,916 --> 00:08:03,906
can talk to service C and get information from DB

121
00:08:03,938 --> 00:08:07,400
two, or even connect to DB one and get information.

122
00:08:08,590 --> 00:08:10,620
That's not what we want.

123
00:08:12,110 --> 00:08:15,834
So which is the zero trust approach and how to

124
00:08:16,032 --> 00:08:19,500
solve this? Well, basically,

125
00:08:20,290 --> 00:08:24,030
we are going to enforce identity validation in every

126
00:08:24,180 --> 00:08:27,486
service, not on two

127
00:08:27,588 --> 00:08:31,454
services that are crucial, but in

128
00:08:31,492 --> 00:08:34,974
everyone. We are going to enforce mutual

129
00:08:35,022 --> 00:08:39,300
tls or token validation in every call between services,

130
00:08:39,830 --> 00:08:43,234
not only from the outside to the inside,

131
00:08:43,432 --> 00:08:46,806
but internally too. But you can

132
00:08:46,908 --> 00:08:50,726
never guess who really is calling a

133
00:08:50,748 --> 00:08:54,566
service. It could be, yes, a good service,

134
00:08:54,668 --> 00:08:58,486
so one of our systems, but it could be a fake

135
00:08:58,598 --> 00:09:02,298
service that someone installed there for

136
00:09:02,384 --> 00:09:05,420
whatever backdoor they used.

137
00:09:05,790 --> 00:09:09,580
And even we are going to have a list of

138
00:09:10,130 --> 00:09:14,654
callers and destinations. So is this service

139
00:09:14,772 --> 00:09:18,142
allowed to call outside world? Well,

140
00:09:18,276 --> 00:09:22,350
probably. For most of the services the answer is no because

141
00:09:22,420 --> 00:09:25,618
they are restricted to call between services.

142
00:09:25,784 --> 00:09:29,598
Probably there's one that it is sending emails, is checking

143
00:09:29,694 --> 00:09:33,122
some information from the outside world, so only that one

144
00:09:33,256 --> 00:09:36,406
will be allowed to send information to

145
00:09:36,428 --> 00:09:40,406
the outside world. And for do this we

146
00:09:40,508 --> 00:09:45,042
can use zero trust approach. So it's the perimeter

147
00:09:45,106 --> 00:09:48,346
less security. So what we are going to

148
00:09:48,368 --> 00:09:51,674
do is to assume that everyone in

149
00:09:51,712 --> 00:09:54,250
the system could be an attacker.

150
00:09:55,150 --> 00:09:58,810
So we are going to enforce verification

151
00:09:59,310 --> 00:10:03,502
of identity for each one of

152
00:10:03,556 --> 00:10:06,880
the services that are calling inside the system.

153
00:10:08,930 --> 00:10:12,978
The basic core principles for zero trust is

154
00:10:13,064 --> 00:10:16,482
okay, you need to have a strong identification for

155
00:10:16,616 --> 00:10:19,380
every service that it is calling.

156
00:10:21,430 --> 00:10:24,974
You need to authenticate, as I've said

157
00:10:25,032 --> 00:10:29,574
several times now, you need to authenticate the access

158
00:10:29,772 --> 00:10:33,174
everywhere in the network, not only

159
00:10:33,292 --> 00:10:37,582
on the perimeter, not only on edge, but on everywhere

160
00:10:37,666 --> 00:10:41,434
in the network. It's important to know

161
00:10:41,472 --> 00:10:44,860
which is the whole architecture, just to know

162
00:10:45,470 --> 00:10:49,450
which elements can connect to which

163
00:10:49,520 --> 00:10:53,502
other elements. If not, you could

164
00:10:53,556 --> 00:10:58,206
be restricting access for,

165
00:10:58,388 --> 00:10:59,120
well,

166
00:11:01,650 --> 00:11:05,154
services that should have access for

167
00:11:05,192 --> 00:11:09,330
that. It's important to know the whole architecture.

168
00:11:09,990 --> 00:11:13,860
We are going to set several policies in order to

169
00:11:14,890 --> 00:11:18,438
allow or reject connections to the outside world,

170
00:11:18,524 --> 00:11:22,418
or even services that cannot

171
00:11:22,514 --> 00:11:26,454
talk to other services. So for instance, I have a web

172
00:11:26,492 --> 00:11:29,690
service that it is simply answering,

173
00:11:30,430 --> 00:11:34,540
I don't know, information about products,

174
00:11:34,910 --> 00:11:38,794
but probably that service cannot have

175
00:11:38,832 --> 00:11:43,006
access to the service

176
00:11:43,108 --> 00:11:46,442
that access salaries,

177
00:11:46,506 --> 00:11:50,814
for instance. Yeah, we know that from the application that service is

178
00:11:50,852 --> 00:11:55,234
not going to request anything from the salary service.

179
00:11:55,432 --> 00:11:58,946
But what if someone gets inside

180
00:11:59,128 --> 00:12:03,182
that service and executes a call to the salary

181
00:12:03,246 --> 00:12:08,594
service? We need to explicitly

182
00:12:08,642 --> 00:12:12,018
define which are the access that are allowed,

183
00:12:12,114 --> 00:12:16,470
or at least which are the accesses that are not allowed.

184
00:12:17,790 --> 00:12:21,002
Again, never trust the network. Not because you are inside

185
00:12:21,056 --> 00:12:24,860
the network. You have access to services.

186
00:12:25,230 --> 00:12:29,226
You need to say, hey, I am service a

187
00:12:29,408 --> 00:12:32,560
that I'm trying to call service f.

188
00:12:33,010 --> 00:12:36,560
Then the system will decide if you have access or not

189
00:12:37,650 --> 00:12:41,006
and basically use always services

190
00:12:41,108 --> 00:12:46,114
that are designed for zero trust. So when

191
00:12:46,152 --> 00:12:48,690
you implement the zero trust architecture,

192
00:12:49,430 --> 00:12:52,642
those services are aligned with this

193
00:12:52,776 --> 00:12:57,442
architecture. But implementing zero trust architecture

194
00:12:57,506 --> 00:13:01,334
has some challenges. So if you need to

195
00:13:01,372 --> 00:13:04,326
implement all this security on all of your services,

196
00:13:04,508 --> 00:13:08,140
it's going to cost you a lot of time and money.

197
00:13:08,910 --> 00:13:14,230
You are going to suffer from legacy software compatibility

198
00:13:14,310 --> 00:13:17,946
issues because you try to enforce mutual TLS in

199
00:13:17,968 --> 00:13:21,520
a software that has, I don't know, so many years

200
00:13:22,450 --> 00:13:26,474
that if you want to update that code to use the latest

201
00:13:26,602 --> 00:13:30,718
libraries, you are going to touching a lot of code and enter

202
00:13:30,804 --> 00:13:35,186
a path of uncertainty. Also you can even

203
00:13:35,288 --> 00:13:39,294
use third party technologies that you dont have the source

204
00:13:39,342 --> 00:13:43,966
code. So what if they are not updatable

205
00:13:44,158 --> 00:13:47,894
easily to allow you to

206
00:13:48,012 --> 00:13:51,286
check for all the security issues. And again

207
00:13:51,388 --> 00:13:55,942
it will have that you keep

208
00:13:55,996 --> 00:13:59,366
on continuous maintenance and

209
00:13:59,388 --> 00:14:02,950
monitoring requirements for all your services that you have touched.

210
00:14:03,030 --> 00:14:06,326
So you need to okay every time that a new version of mutual

211
00:14:06,358 --> 00:14:10,006
TLS or CBE has fixed, then you need to update all

212
00:14:10,048 --> 00:14:13,358
the libraries for all the services that you are using

213
00:14:13,444 --> 00:14:16,240
in your mesh or in your system.

214
00:14:17,890 --> 00:14:21,454
So in summary, it would be to ask

215
00:14:21,572 --> 00:14:26,046
SSL transport for all your services authorization and authentication

216
00:14:26,158 --> 00:14:30,034
observability rules to check which

217
00:14:30,072 --> 00:14:35,654
service can talk to which other services use

218
00:14:35,772 --> 00:14:39,590
clean code approach in your code because you don't want

219
00:14:39,660 --> 00:14:43,494
to expose private information outside and

220
00:14:43,532 --> 00:14:47,286
even inspect if your libraries and

221
00:14:47,308 --> 00:14:49,850
your code is affected by cves.

222
00:14:50,430 --> 00:14:54,010
Therefore change libraries, change approaches

223
00:14:54,350 --> 00:14:56,860
and update everything to every application.

224
00:14:57,550 --> 00:15:01,454
So that's a lot of work to do to maintain all

225
00:15:01,492 --> 00:15:04,990
your cluster secure.

226
00:15:05,490 --> 00:15:10,638
Or what we can do is to use the

227
00:15:10,804 --> 00:15:15,650
zero trust approach and not touch any

228
00:15:15,720 --> 00:15:17,300
application's code.

229
00:15:19,190 --> 00:15:22,782
So let's see how we can implement

230
00:15:22,846 --> 00:15:26,230
this zero trust architecture without touching

231
00:15:26,890 --> 00:15:30,070
our application's code. Well,

232
00:15:30,140 --> 00:15:34,118
and for that what we are going to introduce is istio service

233
00:15:34,204 --> 00:15:38,426
mesh. It's a collection of microservices and

234
00:15:38,528 --> 00:15:42,620
the basic thing about

235
00:15:43,150 --> 00:15:47,722
istio service mesh is that it will install a

236
00:15:47,776 --> 00:15:51,374
sidecar for each

237
00:15:51,412 --> 00:15:56,318
of our services pods and

238
00:15:56,404 --> 00:16:00,000
will handle all the traffic coming and going out.

239
00:16:00,850 --> 00:16:04,558
This also allow us to implement

240
00:16:04,654 --> 00:16:08,254
observability or traffic management without touching

241
00:16:08,382 --> 00:16:13,634
the application. Because in the end for the application it

242
00:16:13,672 --> 00:16:17,318
doesn't have knowledge about istio or something

243
00:16:17,404 --> 00:16:21,110
going on. Simply istio is capturing

244
00:16:21,850 --> 00:16:26,326
the network coming and going away from

245
00:16:26,428 --> 00:16:30,310
the pod. This also allows us to implement

246
00:16:30,390 --> 00:16:33,722
a b testing canary deployments because we can

247
00:16:33,776 --> 00:16:37,770
define which traffic is going to which service version.

248
00:16:38,190 --> 00:16:41,694
So it allows us to

249
00:16:41,732 --> 00:16:45,294
even implement rate limiting. I mean we can

250
00:16:45,332 --> 00:16:49,326
decide how much traffic is going to hit a

251
00:16:49,348 --> 00:16:53,074
service at a certain point, but everything is

252
00:16:53,112 --> 00:16:56,290
done transparently for the service.

253
00:16:56,440 --> 00:17:00,302
Even we can define

254
00:17:00,446 --> 00:17:04,322
filters that will modify this connection between

255
00:17:04,376 --> 00:17:08,102
services going through the network. One use case

256
00:17:08,156 --> 00:17:12,354
would be encrypting, then the traffic.

257
00:17:12,482 --> 00:17:16,214
Another case would be adding headers or modifying headers or

258
00:17:16,252 --> 00:17:19,818
checking headers for the messages that are

259
00:17:19,904 --> 00:17:22,060
going between the services.

260
00:17:23,070 --> 00:17:26,762
And obviously one of the main use cases is to

261
00:17:26,816 --> 00:17:30,066
add authentication and authorization

262
00:17:30,198 --> 00:17:33,454
between all the services in a

263
00:17:33,492 --> 00:17:35,840
transparent way for our service.

264
00:17:37,250 --> 00:17:40,926
In this case, well, we see how istio works.

265
00:17:41,028 --> 00:17:44,430
As I mentioned before, it has a proxy,

266
00:17:44,590 --> 00:17:47,970
envoy proxy and all the traffic

267
00:17:48,470 --> 00:17:52,462
across the mesh is passing through the envoy proxy,

268
00:17:52,606 --> 00:17:55,654
istio. What is going to do is to translate those

269
00:17:55,692 --> 00:17:59,394
configuration files into envoy

270
00:17:59,522 --> 00:18:02,390
configuration files that are more complicated.

271
00:18:03,210 --> 00:18:06,930
And Istio allows us to divide

272
00:18:07,090 --> 00:18:10,410
all those configuration in simpler or

273
00:18:10,480 --> 00:18:14,394
smaller pieces that are the ones

274
00:18:14,432 --> 00:18:17,866
that we are going to use. Finally, there's a

275
00:18:17,968 --> 00:18:22,174
control plane in this case with istiod that

276
00:18:22,212 --> 00:18:25,738
is going to handle all the different envoy

277
00:18:25,834 --> 00:18:29,086
proxies in the different clusters. We can

278
00:18:29,108 --> 00:18:32,158
even merge clusters or even

279
00:18:32,324 --> 00:18:37,502
we can incorporate virtual

280
00:18:37,566 --> 00:18:41,970
machines into these meshes

281
00:18:42,550 --> 00:18:46,040
and configuring the networking among them

282
00:18:46,570 --> 00:18:50,790
again as a transport thing for the applications.

283
00:18:51,450 --> 00:18:55,320
So let's go now to a demo and I will show you which is

284
00:18:57,290 --> 00:19:01,114
the services that we are going to handle. Those are

285
00:19:01,152 --> 00:19:04,810
made in Java using Quarkus.

286
00:19:05,310 --> 00:19:08,460
But let's see the demo.

287
00:19:10,770 --> 00:19:14,158
So let's going to take a look to the files that we are going to

288
00:19:14,164 --> 00:19:19,086
use in the demo. So we need a

289
00:19:19,108 --> 00:19:22,442
Kubernetes cluster and we are going to

290
00:19:22,516 --> 00:19:26,370
have this Quarkus DTA service and another service

291
00:19:26,440 --> 00:19:30,050
that is exactly the same service with a different

292
00:19:30,120 --> 00:19:33,794
name just for demoing purposes and

293
00:19:33,832 --> 00:19:37,814
the gateway. And first we are going to use

294
00:19:38,012 --> 00:19:41,366
no security approach and

295
00:19:41,468 --> 00:19:46,150
see that everything goes fine from anywhere.

296
00:19:46,730 --> 00:19:51,930
And then we are going to use security applying

297
00:19:52,350 --> 00:19:56,810
zero trust approach to our kubernetes using

298
00:19:56,880 --> 00:20:01,194
istio service mesh using an external identity

299
00:20:01,242 --> 00:20:05,278
and access management control. It's a key cloak hosted free

300
00:20:05,444 --> 00:20:08,846
that we can create a

301
00:20:08,868 --> 00:20:13,042
configuration that we are going to use in our validation using

302
00:20:13,096 --> 00:20:16,900
the tokens coming from that service.

303
00:20:18,070 --> 00:20:21,410
So basically the steps that I'm going to follow are,

304
00:20:21,480 --> 00:20:26,470
well, first we are going to test from call

305
00:20:26,540 --> 00:20:30,806
from outside the cluster, then a call from inside.

306
00:20:30,908 --> 00:20:34,134
So from one service to another service and

307
00:20:34,172 --> 00:20:37,880
then trying to go from one service to the external world.

308
00:20:39,630 --> 00:20:43,386
Then we are going to move to a security approach where we

309
00:20:43,408 --> 00:20:47,370
are going to replicate exactly the same steps.

310
00:20:48,030 --> 00:20:51,454
And the files that are going to be involved are well

311
00:20:51,492 --> 00:20:55,722
the definition of the quarkus service in Java, a gateway,

312
00:20:55,866 --> 00:21:00,494
a virtual service, a config map that we are going to touch for

313
00:21:00,692 --> 00:21:03,870
istio, then a request authentication

314
00:21:03,950 --> 00:21:09,326
and our authorization policy in order to enforce

315
00:21:09,438 --> 00:21:12,930
the validation for every connection to

316
00:21:13,000 --> 00:21:17,480
any service and then a service entry that will

317
00:21:18,250 --> 00:21:22,214
prevent or allow the request to

318
00:21:22,252 --> 00:21:25,190
external services for the clusters.

319
00:21:25,930 --> 00:21:28,380
So in our case, our service,

320
00:21:30,670 --> 00:21:34,822
it's a simple service, just two methods.

321
00:21:34,966 --> 00:21:38,294
That one is returning a hard coded

322
00:21:38,342 --> 00:21:42,682
text on the endpoint hello and another one returning

323
00:21:42,746 --> 00:21:46,666
a text concatenated with a parameter

324
00:21:46,778 --> 00:21:50,382
on the endpoint echo. That's it, nothing else.

325
00:21:50,436 --> 00:21:53,780
It's a rest endpoint touching else, no security,

326
00:21:54,150 --> 00:21:56,020
no nothing in our service.

327
00:21:59,830 --> 00:22:03,634
For the security we are going to use a gateway where we

328
00:22:03,672 --> 00:22:07,110
are going to define well

329
00:22:07,180 --> 00:22:10,760
the port that it is going to accept and

330
00:22:11,130 --> 00:22:15,698
a virtual service that definitely is configuring

331
00:22:15,794 --> 00:22:19,546
an endpoint that is going

332
00:22:19,568 --> 00:22:22,342
to be called by the gateway.

333
00:22:22,406 --> 00:22:26,486
So we are exposing endpoints

334
00:22:26,598 --> 00:22:29,894
that are connected to services. As you can see host

335
00:22:29,942 --> 00:22:33,902
is a service and we are going to attack the port 80 then

336
00:22:33,956 --> 00:22:37,466
we are going to change something in the config map,

337
00:22:37,498 --> 00:22:41,870
a value when we are going to allow or reject.

338
00:22:42,470 --> 00:22:48,734
So the default policy when calling to endpoints

339
00:22:48,782 --> 00:22:52,546
outside of the cluster by default is allow any, but we

340
00:22:52,568 --> 00:22:56,118
are going to modify to registry only when

341
00:22:56,204 --> 00:23:00,294
we want to only allow certain connections and

342
00:23:00,332 --> 00:23:04,002
not the trust for the request authentication

343
00:23:04,066 --> 00:23:08,154
that it is the file that is going to configure who

344
00:23:08,192 --> 00:23:12,154
is issuing the tokens. In this case, well we

345
00:23:12,192 --> 00:23:16,630
are going to define which are the workloads

346
00:23:16,790 --> 00:23:20,426
deployments that are affected by this request

347
00:23:20,458 --> 00:23:24,874
authentication. So in any case with istio we can filter

348
00:23:25,002 --> 00:23:28,430
who is affected by the configuration using labels.

349
00:23:28,850 --> 00:23:33,986
In this case we are configuring the external keycloak service

350
00:23:34,168 --> 00:23:38,626
and matching all the workloads with app

351
00:23:38,728 --> 00:23:42,900
Quarkus. The authorization policy is saying okay,

352
00:24:05,950 --> 00:24:10,022
we are going to use this key clock external service in order to provide

353
00:24:10,096 --> 00:24:13,658
this valid token. The service entry

354
00:24:13,754 --> 00:24:18,350
is effectively configuring an external

355
00:24:19,650 --> 00:24:20,400
service.

356
00:24:22,630 --> 00:24:27,106
In the case we are prohibiting all

357
00:24:27,128 --> 00:24:30,882
the connections to external services except for

358
00:24:30,936 --> 00:24:33,742
those that are defined as a service entry.

359
00:24:33,886 --> 00:24:36,600
With this case we are going to say okay,

360
00:24:38,090 --> 00:24:42,150
it's connecting to Google.com is allowed

361
00:24:43,210 --> 00:24:47,222
with this service entry, then any

362
00:24:47,276 --> 00:24:51,670
other host is forbidden.

363
00:24:51,830 --> 00:24:55,946
It's easy to configure which are the external services

364
00:24:56,128 --> 00:24:59,930
that are allowed by the mesh in case

365
00:25:00,000 --> 00:25:03,722
that you have configured it as rejecting so registry

366
00:25:03,786 --> 00:25:06,350
only in the config map we will see in a minute.

367
00:25:07,330 --> 00:25:11,034
Okay, so let's play directly with our local cluster

368
00:25:11,082 --> 00:25:14,898
and see how we can implement the zero trust architecture using

369
00:25:14,984 --> 00:25:18,270
istio. I already have a cluster

370
00:25:18,350 --> 00:25:22,178
running and I also

371
00:25:22,264 --> 00:25:25,442
installed Istio. It's very easy

372
00:25:25,496 --> 00:25:29,902
to install istio trust. Download the istio

373
00:25:29,966 --> 00:25:33,560
kernel command and that will allow you to install.

374
00:25:34,170 --> 00:25:38,570
You can find all the steps in this git repository.

375
00:25:38,910 --> 00:25:43,260
So let's deploy our first

376
00:25:44,910 --> 00:25:48,940
service. So what I'm going to do

377
00:25:49,710 --> 00:25:53,998
is to build the service that we saw

378
00:25:54,084 --> 00:25:57,966
previously specifying well, which is the

379
00:25:57,988 --> 00:26:01,854
namespace where it has to be deployed, which is the label that we

380
00:26:01,892 --> 00:26:06,082
are going to use for this workload and

381
00:26:06,136 --> 00:26:10,546
the name of the app. Okay, so we

382
00:26:10,568 --> 00:26:14,050
are going to build it using maven.

383
00:26:14,970 --> 00:26:18,434
In this case it's a regular Java

384
00:26:18,482 --> 00:26:22,134
application using JVM, but we could even

385
00:26:22,252 --> 00:26:25,526
use a native artifact because we

386
00:26:25,548 --> 00:26:28,730
are using Quarkus. And this

387
00:26:28,800 --> 00:26:33,114
will take longer to build but

388
00:26:33,312 --> 00:26:37,290
way shorter to execute.

389
00:26:37,710 --> 00:26:41,820
And now we are going to install another service,

390
00:26:43,630 --> 00:26:47,518
it's exactly the same but with a different

391
00:26:47,604 --> 00:26:50,160
name of the application. That's it.

392
00:26:52,950 --> 00:26:56,690
So we are going to have exactly two same

393
00:26:56,760 --> 00:27:00,050
services doing exactly

394
00:27:00,120 --> 00:27:03,700
the same with two different names just to

395
00:27:04,310 --> 00:27:07,826
demo the requests and calls

396
00:27:07,858 --> 00:27:11,400
from one service to another, and then from

397
00:27:13,450 --> 00:27:15,960
one service to the outside world.

398
00:27:17,390 --> 00:27:21,500
Okay, now we are going to check

399
00:27:22,270 --> 00:27:27,082
which is the

400
00:27:27,136 --> 00:27:30,302
ip for the node in this case, because our

401
00:27:30,356 --> 00:27:34,720
services are

402
00:27:35,650 --> 00:27:38,240
using node port, as you can see here.

403
00:27:38,610 --> 00:27:41,840
So it is using kind.

404
00:27:43,510 --> 00:27:47,140
So therefore what we can do is simply use

405
00:27:52,070 --> 00:27:55,230
the clusters IP and the port,

406
00:27:55,400 --> 00:27:59,494
the port is 31 591

407
00:27:59,612 --> 00:28:02,914
and this will redirect to the port 80.

408
00:28:03,042 --> 00:28:07,314
So if I do this curl from the outside world,

409
00:28:07,452 --> 00:28:11,338
yeah, I get the

410
00:28:11,424 --> 00:28:15,386
response from that service, and if I do exactly the same,

411
00:28:15,568 --> 00:28:19,340
but for the other

412
00:28:19,970 --> 00:28:22,160
service, okay,

413
00:28:22,690 --> 00:28:26,800
I receive a response from them.

414
00:28:28,610 --> 00:28:33,786
But if what I do is I'm

415
00:28:33,818 --> 00:28:43,642
going to do a shell in this spotlight,

416
00:28:43,786 --> 00:28:47,960
okay, so I'm going to shell inside

417
00:28:48,650 --> 00:28:52,920
one of the services and what I'm going to do is

418
00:28:55,290 --> 00:28:59,354
do a curl to the other service using the

419
00:28:59,392 --> 00:29:01,580
name of the service basically.

420
00:29:02,190 --> 00:29:05,786
So, well, we can see there is no problem,

421
00:29:05,888 --> 00:29:09,340
everything is working fine. But even if I want

422
00:29:11,170 --> 00:29:15,390
to call any external

423
00:29:17,170 --> 00:29:18,190
endpoint,

424
00:29:27,510 --> 00:29:30,530
we received a response.

425
00:29:33,590 --> 00:29:35,060
So that's fine.

426
00:29:39,450 --> 00:29:42,886
But now let's implement the security for that.

427
00:29:42,988 --> 00:29:46,966
The first step is to add a

428
00:29:46,988 --> 00:29:51,114
namespace label to

429
00:29:51,152 --> 00:29:57,222
our namespace default,

430
00:29:57,366 --> 00:30:00,210
saying istio injection is enabled.

431
00:30:00,310 --> 00:30:04,494
Okay, nothing happened in

432
00:30:04,532 --> 00:30:08,142
fact. But what we need

433
00:30:08,196 --> 00:30:11,710
is to delete the pods.

434
00:30:13,490 --> 00:30:16,814
And now what we see is

435
00:30:16,852 --> 00:30:20,378
that instead of having one container per each pod,

436
00:30:20,474 --> 00:30:24,110
now we have two, we have

437
00:30:24,260 --> 00:30:27,446
our application station and also what we

438
00:30:27,468 --> 00:30:29,590
have is the proxy,

439
00:30:32,490 --> 00:30:36,454
but we don't have anything yet

440
00:30:36,652 --> 00:30:40,202
in terms of security. So if I try

441
00:30:40,256 --> 00:30:43,818
to connect to the application,

442
00:30:43,984 --> 00:30:46,860
everything is working as before.

443
00:30:47,710 --> 00:30:51,966
So what we need now is to apply

444
00:30:52,148 --> 00:30:55,646
the files that are going to configure istio for

445
00:30:55,668 --> 00:30:59,262
this security. So what we have here is first,

446
00:30:59,396 --> 00:31:02,880
well let's see,

447
00:31:04,530 --> 00:31:05,390
oops.

448
00:31:08,230 --> 00:31:11,614
What we have. So first we are going to add a request

449
00:31:11,662 --> 00:31:14,974
authentication that in fact what it's doing is saying,

450
00:31:15,032 --> 00:31:18,658
okay, the GWT tokens

451
00:31:18,834 --> 00:31:22,040
are issued by this

452
00:31:22,730 --> 00:31:26,760
application. So what we are going to do is to

453
00:31:34,190 --> 00:31:37,866
apply the authentication. Then we

454
00:31:37,888 --> 00:31:46,810
are going to apply the policy it

455
00:31:46,880 --> 00:31:51,726
that will enforce having a

456
00:31:51,748 --> 00:31:55,166
token in each connection. So let's

457
00:31:55,198 --> 00:32:02,580
apply it

458
00:32:05,450 --> 00:32:10,994
with this. If we try to do exactly the same coral

459
00:32:11,122 --> 00:32:14,760
command, it says

460
00:32:15,290 --> 00:32:16,870
access denied.

461
00:32:18,490 --> 00:32:22,310
Why? Because my call request

462
00:32:23,230 --> 00:32:27,610
is not passing any token.

463
00:32:28,430 --> 00:32:32,110
So for that what we need is to get a token.

464
00:32:33,330 --> 00:32:37,774
What we are going to do is we are going to connect

465
00:32:37,972 --> 00:32:41,994
to my key clock

466
00:32:42,042 --> 00:32:46,434
that it is online working and we

467
00:32:46,472 --> 00:32:50,434
are going to get a token, okay, so what

468
00:32:50,472 --> 00:32:53,970
we have is token

469
00:32:55,050 --> 00:32:58,806
and we are going to do exactly

470
00:32:58,908 --> 00:33:02,374
the same call, but in this

471
00:33:02,412 --> 00:33:06,066
case passing the token into the authorization

472
00:33:06,178 --> 00:33:09,420
header. Let me

473
00:33:11,550 --> 00:33:12,700
change this.

474
00:33:15,550 --> 00:33:18,742
Now it is answering

475
00:33:18,886 --> 00:33:22,350
what it is expected. If I do this

476
00:33:22,420 --> 00:33:26,302
again without passing the token, it says RBAC access

477
00:33:26,436 --> 00:33:27,310
denied.

478
00:33:29,730 --> 00:33:34,094
If I go to the

479
00:33:34,132 --> 00:33:37,454
pod and try to do a

480
00:33:37,492 --> 00:33:41,198
shell and I do

481
00:33:41,284 --> 00:33:46,120
exactly the same as we did it

482
00:33:46,570 --> 00:33:47,320
before,

483
00:33:50,170 --> 00:33:54,130
it is saying exactly the same. So the access denied

484
00:33:54,210 --> 00:33:57,898
is raised from an outside

485
00:33:57,984 --> 00:34:00,700
call or from an inside call.

486
00:34:03,310 --> 00:34:06,890
But if we copy

487
00:34:07,630 --> 00:34:13,742
the token and

488
00:34:13,796 --> 00:34:15,840
do exactly the same,

489
00:34:27,190 --> 00:34:31,282
then we have a response from the other service

490
00:34:31,416 --> 00:34:33,730
because the token is valid.

491
00:34:36,010 --> 00:34:40,054
And now what we need is to check if we have access to

492
00:34:40,092 --> 00:34:44,294
the outside world. So from the

493
00:34:44,332 --> 00:34:52,186
inside we are going to do a

494
00:34:52,208 --> 00:34:55,994
call to Google. Okay, it is

495
00:34:56,032 --> 00:34:59,306
working. And if

496
00:34:59,328 --> 00:35:01,470
I do the same for Oracle,

497
00:35:03,970 --> 00:35:07,822
it is working. But if

498
00:35:07,956 --> 00:35:11,002
I apply a virtual

499
00:35:11,066 --> 00:35:16,446
service, in this case, let's see what

500
00:35:16,468 --> 00:35:19,860
is doing this virtual service.

501
00:35:20,230 --> 00:35:23,330
Sorry, the service entry,

502
00:35:25,750 --> 00:35:29,110
it is saying, okay, we are going to create a

503
00:35:29,260 --> 00:35:32,310
service entry for Google.com.

504
00:35:32,460 --> 00:35:36,326
So what it is going to do is to allow me to connect

505
00:35:36,428 --> 00:35:39,994
to google.com. But for that what we need

506
00:35:40,032 --> 00:35:43,530
is to change a config map.

507
00:35:44,750 --> 00:35:48,954
In this case we

508
00:35:48,992 --> 00:35:53,760
are going to change this

509
00:35:54,690 --> 00:35:57,598
config map in istio saying, okay,

510
00:35:57,764 --> 00:36:04,030
instead of the allow any mode,

511
00:36:04,190 --> 00:36:07,330
what we are going to say is only registry.

512
00:36:07,750 --> 00:36:11,106
Anything that it is not in

513
00:36:11,128 --> 00:36:13,570
the registry will be rejected.

514
00:36:14,390 --> 00:36:18,900
So what we do is we

515
00:36:19,830 --> 00:36:23,894
do that config map. Now let's see if

516
00:36:23,932 --> 00:36:27,522
I can go to

517
00:36:27,676 --> 00:36:31,702
inside my pod

518
00:36:31,766 --> 00:36:32,700
and do,

519
00:36:37,790 --> 00:36:40,906
oh, I cannot connect to Oracle,

520
00:36:41,018 --> 00:36:43,760
but if I go to Google,

521
00:36:48,530 --> 00:36:51,120
that's interesting.

522
00:36:52,550 --> 00:36:54,820
Oh, because I didn't apply.

523
00:37:08,250 --> 00:37:11,654
Now if I try to connect to Google I

524
00:37:11,692 --> 00:37:15,350
have an answer. If I try to connect to Oracle,

525
00:37:16,330 --> 00:37:18,700
it is not working at all.

526
00:37:20,110 --> 00:37:23,642
Also I wanted to show you another tool called

527
00:37:23,696 --> 00:37:27,210
Kiali that can help us in order to inspect our

528
00:37:27,280 --> 00:37:31,022
cluster and see how connections are working.

529
00:37:31,156 --> 00:37:35,082
It's very easy to install kiali

530
00:37:35,146 --> 00:37:38,254
using Hull. You can install the operator and then

531
00:37:38,292 --> 00:37:41,886
install Prometheus and it's fine and

532
00:37:41,908 --> 00:37:46,050
easy. And then we only need

533
00:37:46,120 --> 00:37:50,420
to do a poor forward

534
00:37:54,970 --> 00:38:00,406
and finally we will connect to our

535
00:38:00,508 --> 00:38:02,840
service, kiali service.

536
00:38:03,210 --> 00:38:07,554
And with this we have our

537
00:38:07,612 --> 00:38:11,594
applications, our services, and we can

538
00:38:11,632 --> 00:38:16,422
even see how connections

539
00:38:16,486 --> 00:38:20,318
are working. So if I try to do the same coral that I

540
00:38:20,324 --> 00:38:23,534
did before without passing the

541
00:38:23,572 --> 00:38:26,990
header, it is saying access denied.

542
00:38:28,370 --> 00:38:32,602
And if I refresh, I effectively see

543
00:38:32,756 --> 00:38:36,500
that there's an error trying to connect to the service.

544
00:38:36,950 --> 00:38:40,210
We can see which are

545
00:38:40,360 --> 00:38:44,146
our applications and the services and the

546
00:38:44,168 --> 00:38:47,762
elements for them, inbound traffic,

547
00:38:47,826 --> 00:38:51,640
outbound metric traces. So there's a lot of information

548
00:38:52,090 --> 00:38:56,550
that we can get from Kiali

549
00:38:58,350 --> 00:39:02,666
and that's it basically. Regarding the

550
00:39:02,848 --> 00:39:05,242
demo with istio service,

551
00:39:05,296 --> 00:39:09,114
mesh well,

552
00:39:09,232 --> 00:39:13,054
after you saw the demo, well, it's very easy

553
00:39:13,172 --> 00:39:17,150
to handle all this configuration with istio.

554
00:39:18,370 --> 00:39:21,822
Let's talk about which are the conclusions that we can

555
00:39:21,876 --> 00:39:25,042
get of this presentation. Well, as you can see here,

556
00:39:25,096 --> 00:39:28,980
the cvs have been well

557
00:39:29,750 --> 00:39:33,442
increasing year after year and

558
00:39:33,496 --> 00:39:37,190
only in 2022 there were

559
00:39:37,340 --> 00:39:40,918
more than 800 cves with similar

560
00:39:41,004 --> 00:39:44,630
score that the famous issue

561
00:39:44,700 --> 00:39:49,510
with lock for shell that allowed remote execution.

562
00:39:49,670 --> 00:39:54,042
And a lot of services were

563
00:39:54,176 --> 00:39:58,378
well in risk because they were using log,

564
00:39:58,544 --> 00:40:01,790
a logging library to log information.

565
00:40:01,940 --> 00:40:03,840
Very easy one,

566
00:40:04,210 --> 00:40:08,174
but that it allowed this

567
00:40:08,212 --> 00:40:13,140
remote execution and therefore a lot of issues

568
00:40:13,590 --> 00:40:15,540
were generated by it.

569
00:40:17,270 --> 00:40:20,850
So security has

570
00:40:20,920 --> 00:40:24,546
to be taken very seriously because

571
00:40:24,648 --> 00:40:28,998
from the more innocent library that we can use,

572
00:40:29,164 --> 00:40:33,574
a logging library, a very hard

573
00:40:33,692 --> 00:40:37,314
or very important

574
00:40:37,452 --> 00:40:41,226
severity come into your system

575
00:40:41,408 --> 00:40:44,874
and allow that another third party can

576
00:40:44,912 --> 00:40:48,266
put something in your system having access to all

577
00:40:48,288 --> 00:40:51,630
of your services. Zero Trust

578
00:40:51,700 --> 00:40:56,042
is definitely the way to go in order to minimize

579
00:40:56,186 --> 00:41:00,202
security issues because you are enforcing validation

580
00:41:00,346 --> 00:41:03,380
in every call between services,

581
00:41:04,070 --> 00:41:07,874
not just considering that the perimeter is

582
00:41:07,912 --> 00:41:11,474
the only way that attackers can

583
00:41:11,512 --> 00:41:14,180
use in order to go into your system.

584
00:41:15,930 --> 00:41:19,682
Also it can be well costly to implement

585
00:41:19,746 --> 00:41:22,658
because you need to modify your applications.

586
00:41:22,834 --> 00:41:25,458
Adding SSl transport,

587
00:41:25,634 --> 00:41:29,414
dealing with libraries, third parties libraries,

588
00:41:29,542 --> 00:41:33,386
all libraries, and adding a

589
00:41:33,408 --> 00:41:36,858
lot of modifications in order to increase the

590
00:41:36,864 --> 00:41:39,050
level of security of your applications.

591
00:41:40,450 --> 00:41:46,126
Not even considering that it could be that you

592
00:41:46,148 --> 00:41:50,058
cannot have access to modify those third party libraries

593
00:41:50,154 --> 00:41:51,680
because you don't have the code.

594
00:41:54,690 --> 00:41:57,770
It involves security inside your cluster.

595
00:41:57,850 --> 00:42:01,434
So it's not only the security from external

596
00:42:01,482 --> 00:42:04,998
attackers, it can be also security in

597
00:42:05,044 --> 00:42:08,294
inside your cluster from one service to

598
00:42:08,332 --> 00:42:11,746
another. Because sometimes it could be the third party

599
00:42:11,938 --> 00:42:15,622
can have put something inside your cluster in order

600
00:42:15,676 --> 00:42:19,034
to I don't know, take advantage of it and get

601
00:42:19,072 --> 00:42:22,986
information. Or it could be because one service is

602
00:42:23,168 --> 00:42:26,314
malfunctioning or doing a request where it

603
00:42:26,352 --> 00:42:30,350
shouldn't do it. So from

604
00:42:30,420 --> 00:42:34,622
a configuration point of view with zero trust

605
00:42:34,756 --> 00:42:38,526
you can configure who can talk to who.

606
00:42:38,628 --> 00:42:41,360
So it's more secure this way.

607
00:42:42,050 --> 00:42:45,426
Definitely. Service mesh can help you because it allows you to

608
00:42:45,448 --> 00:42:49,282
implement security without touching your applications, because it's something

609
00:42:49,416 --> 00:42:53,998
that it is running beneath your applications.

610
00:42:54,094 --> 00:42:57,510
So they don't even know you are using service mesh.

611
00:42:58,410 --> 00:43:02,022
It's transparent for existing applications because you apply

612
00:43:02,156 --> 00:43:05,586
service mesh for certain namespaces

613
00:43:05,778 --> 00:43:09,126
and then security is implemented and enforce

614
00:43:09,158 --> 00:43:13,526
it and the applications are not suffering

615
00:43:13,638 --> 00:43:18,234
or not being modified by anyone.

616
00:43:18,432 --> 00:43:22,174
And even you can add more features to your

617
00:43:22,212 --> 00:43:26,298
system because you can add observability,

618
00:43:26,474 --> 00:43:30,494
you can add logging, even you

619
00:43:30,532 --> 00:43:34,290
can add headers to the communication,

620
00:43:34,630 --> 00:43:38,466
encrypting the payload. Filtering a lot

621
00:43:38,488 --> 00:43:42,642
of features that can be done transparently for

622
00:43:42,696 --> 00:43:46,978
your applications introduces network complexity,

623
00:43:47,154 --> 00:43:50,722
that's for sure. Using service mesh adds

624
00:43:50,786 --> 00:43:54,246
another layer of complexity to

625
00:43:54,268 --> 00:43:58,362
your system. So before that you had your application,

626
00:43:58,496 --> 00:44:01,670
you have your cluster, probably your gateway,

627
00:44:01,830 --> 00:44:05,226
but now you need a service mesh that is controlling the

628
00:44:05,248 --> 00:44:08,714
network. So a malconfiguration can create that.

629
00:44:08,752 --> 00:44:12,160
Applications cannot talk to the applications they need.

630
00:44:13,010 --> 00:44:16,320
But yeah, nothing comes for free.

631
00:44:18,210 --> 00:44:22,014
Even you can implement gradual security

632
00:44:22,132 --> 00:44:26,658
steps because you can enforce mutual tls now,

633
00:44:26,824 --> 00:44:30,670
then you can enforce token validation, then you can enforce

634
00:44:30,750 --> 00:44:35,874
encryption, then you can enforce policies

635
00:44:36,002 --> 00:44:40,182
of who can talk to who, but nothing

636
00:44:40,236 --> 00:44:43,702
have to be done at once. You can add more

637
00:44:43,756 --> 00:44:46,966
restrictions as you are more mature on

638
00:44:46,988 --> 00:44:51,350
the service mesh management n involves

639
00:44:51,510 --> 00:44:55,900
a high level of customization because you can do

640
00:44:56,830 --> 00:45:00,990
lot of filtering and modifications from

641
00:45:01,060 --> 00:45:04,622
the envoy proxy. There are

642
00:45:04,676 --> 00:45:07,774
several filters that are already built

643
00:45:07,812 --> 00:45:11,120
in in envoy, but even you can use

644
00:45:11,890 --> 00:45:15,122
wasm in order to create new filters that you can

645
00:45:15,176 --> 00:45:18,802
use in your envoy proxies doing well.

646
00:45:18,856 --> 00:45:21,838
I don't know whatever enrichment,

647
00:45:21,934 --> 00:45:25,382
filtering or transformation that you want with

648
00:45:25,436 --> 00:45:29,000
your messages coming from one service to another.

649
00:45:30,170 --> 00:45:33,234
Finally, here are the references that I've

650
00:45:33,282 --> 00:45:36,966
used and that I think they

651
00:45:36,988 --> 00:45:40,154
can help you if you want to dig more into the details about

652
00:45:40,192 --> 00:45:44,234
zero trust architecture. And that

653
00:45:44,272 --> 00:45:47,946
was it. Thank you very much for being patient with

654
00:45:47,968 --> 00:45:54,014
this presentation and hope it

655
00:45:54,052 --> 00:45:57,646
light sparkle of curiosity on you. If you are

656
00:45:57,668 --> 00:46:01,360
not already using zero trust approach and

657
00:46:02,610 --> 00:46:06,366
whatever question you have or if you want

658
00:46:06,388 --> 00:46:09,040
to comment anything about zero trust,

659
00:46:09,650 --> 00:46:13,022
definitely I will be more than glad to answer them.

660
00:46:13,076 --> 00:46:16,566
Use my Twitter handle, my email nil and you

661
00:46:16,588 --> 00:46:21,270
can see even some posts about this in my blog.

662
00:46:22,250 --> 00:46:25,090
Thank you very much and hope you enjoy the presentation.

