1
00:00:00,170 --> 00:00:00,720
You.

2
00:00:17,090 --> 00:00:20,574
Hello everybody. Would you like to be able to

3
00:00:20,612 --> 00:00:23,886
create an application that is always offline or at

4
00:00:23,908 --> 00:00:27,602
least it looks like make? It would be always alight for our users

5
00:00:27,666 --> 00:00:31,574
even though there is no Internet connectivity, this today is

6
00:00:31,612 --> 00:00:35,234
possible thanks to progressive web apps and other modern technologies.

7
00:00:35,362 --> 00:00:39,418
In this session we will see how it's possible to build such an application

8
00:00:39,584 --> 00:00:42,826
and also we will see the different benefits

9
00:00:42,928 --> 00:00:45,900
that progressive web apps can bring into our project.

10
00:00:46,910 --> 00:00:50,234
When I talk about the progressive web apps, I'm always

11
00:00:50,272 --> 00:00:53,534
a bit sad to see that very few people are aware of the

12
00:00:53,572 --> 00:00:57,278
potentiality of this technology and even less people

13
00:00:57,364 --> 00:01:00,858
are using actively in their own project. Progressive web apps.

14
00:01:00,954 --> 00:01:04,882
That's a bit indeed, because progressive web application can

15
00:01:04,936 --> 00:01:08,654
really bring a lot of functionality and feature to our projects,

16
00:01:08,702 --> 00:01:12,226
no matter of complexity of the project or how big it

17
00:01:12,248 --> 00:01:15,938
is. And let's start seeing

18
00:01:16,024 --> 00:01:19,350
first of all, the differences between a progressive web app and

19
00:01:19,420 --> 00:01:22,642
a native application, either Android or iOS.

20
00:01:22,786 --> 00:01:25,926
This doesn't want to be at all a competition nor a fight,

21
00:01:26,028 --> 00:01:30,330
but just list out some concrete differences.

22
00:01:30,910 --> 00:01:35,078
First of all, we don't have to fulfill

23
00:01:35,174 --> 00:01:38,730
the requirements or the rules of a play store

24
00:01:38,800 --> 00:01:42,222
or App Store. We can just deploy our progressive web app

25
00:01:42,276 --> 00:01:45,674
that it is simply a web application enriched

26
00:01:45,722 --> 00:01:49,246
with some other functionalities and once live on

27
00:01:49,268 --> 00:01:53,460
the server it's available to everybody. So immediately online

28
00:01:54,470 --> 00:01:57,794
then we don't have to save and

29
00:01:57,832 --> 00:02:02,174
provide different versions of it, we just have one versions.

30
00:02:02,302 --> 00:02:06,022
Of course, if some functionalities will not be available in

31
00:02:06,076 --> 00:02:10,018
some of the browser, then these will be progressive,

32
00:02:10,194 --> 00:02:13,954
hidden or not provided to these users

33
00:02:14,002 --> 00:02:17,998
that cannot have the latest browser or a compatible

34
00:02:18,114 --> 00:02:21,754
browser. But still, the experience has to be very

35
00:02:21,872 --> 00:02:26,090
smooth and there should be no showstoppers

36
00:02:26,910 --> 00:02:30,474
on the other side. Typically building a progressive web

37
00:02:30,512 --> 00:02:33,918
app is much cheaper than a native app. This because

38
00:02:34,004 --> 00:02:37,614
we can reuse the know how we have internally in our team.

39
00:02:37,732 --> 00:02:41,086
For example, we can reuse our web team to

40
00:02:41,108 --> 00:02:44,834
create also a progressive web app. The know how is exactly the same

41
00:02:44,872 --> 00:02:47,220
as to create a normal web application.

42
00:02:48,310 --> 00:02:51,886
And lastly, it has a much smaller memory footprint

43
00:02:51,998 --> 00:02:55,910
because we don't have to download many packages and

44
00:02:56,060 --> 00:02:58,802
indeed we will see later on. Indeed,

45
00:02:58,866 --> 00:03:02,690
the used memory on the device is much smaller compared

46
00:03:02,770 --> 00:03:06,742
to a native app. Before going

47
00:03:06,796 --> 00:03:10,902
on, just a couple of words about me. My name is Francesco Leardini

48
00:03:11,046 --> 00:03:14,614
and I work as a software engineer, a consultant

49
00:03:14,742 --> 00:03:18,358
for Trivadis, a consultancy company in Switzerland.

50
00:03:18,534 --> 00:03:22,062
But I'm originally from Italy, from the north on the

51
00:03:22,116 --> 00:03:25,914
Algria coast. It's a very nice place, especially in summer. The photo indeed

52
00:03:25,962 --> 00:03:29,822
is taken from my location. That said,

53
00:03:29,956 --> 00:03:33,226
let's start our progressive web apps journey.

54
00:03:33,418 --> 00:03:37,250
Let's imagine a very common scenario. We are traveling or

55
00:03:37,320 --> 00:03:41,154
just commuting to the office and we are passing through

56
00:03:41,192 --> 00:03:44,354
an area that is not very well covered. So we

57
00:03:44,392 --> 00:03:47,926
can have an intermittent connectivity and in some

58
00:03:47,948 --> 00:03:51,606
pages even we could be completely offline. So if

59
00:03:51,628 --> 00:03:55,398
we are reading, for example, our favorite news website or a

60
00:03:55,404 --> 00:03:59,194
blog post, when we pass from one page to the next, this is

61
00:03:59,232 --> 00:04:02,742
what can happen. So simply a default offline

62
00:04:02,806 --> 00:04:06,698
page. Indeed, for our users this would be not a real good

63
00:04:06,784 --> 00:04:10,718
experience. But with progressive web apps we can provide

64
00:04:10,804 --> 00:04:14,686
a much better user experience. As a minimum, we can

65
00:04:14,708 --> 00:04:18,030
provide some corporate colors or

66
00:04:18,100 --> 00:04:21,566
icons with some static data so that even though the

67
00:04:21,588 --> 00:04:25,246
user is offline still it can recognize the logo

68
00:04:25,278 --> 00:04:29,422
or some colors of our company and eventually still benefit

69
00:04:29,566 --> 00:04:33,134
from this content. If we can provide some meaningful

70
00:04:33,262 --> 00:04:36,420
static data like some

71
00:04:36,870 --> 00:04:40,178
items on sale if you are an e commerce shop,

72
00:04:40,264 --> 00:04:44,326
or some telephone numbers on

73
00:04:44,348 --> 00:04:47,494
the other side, and this is the case of Trivago on the right side,

74
00:04:47,612 --> 00:04:51,014
we can provide even a further and richer

75
00:04:51,062 --> 00:04:54,474
experience. In this case, Trivago, when we access the website

76
00:04:54,592 --> 00:04:58,774
for a second time and we are offline, provides us a labyrinth

77
00:04:58,822 --> 00:05:03,070
game. This is a very clever move from them because we

78
00:05:03,140 --> 00:05:06,334
can keep the user attention locked on the

79
00:05:06,372 --> 00:05:09,918
website using this game so that as soon as the

80
00:05:10,004 --> 00:05:13,982
Internet connectivity is then restored, the user will be automatically

81
00:05:14,046 --> 00:05:17,042
redirected to the requested page.

82
00:05:17,176 --> 00:05:21,700
So that with this let's call it trick or good

83
00:05:22,470 --> 00:05:26,054
way of keeping interest of the user, we can

84
00:05:26,252 --> 00:05:29,494
save a potential customer that otherwise would have been most

85
00:05:29,532 --> 00:05:33,590
probably lost. So this is possible thanks to progressive web apps.

86
00:05:35,210 --> 00:05:38,120
Let's see also another difference.

87
00:05:38,590 --> 00:05:42,422
A little test trying to recognize which one is the native

88
00:05:42,486 --> 00:05:45,946
app of the Android this is

89
00:05:45,968 --> 00:05:49,766
a screenshot of my Android device and which one is a progressive

90
00:05:49,798 --> 00:05:52,862
web app. Of course we can see immediately the shape is different,

91
00:05:52,916 --> 00:05:57,070
but other than that there are not big difference. If we open it,

92
00:05:57,140 --> 00:06:00,734
we can see that the layout itself is quite similar.

93
00:06:00,852 --> 00:06:04,418
There are not really big differences and indeed it's very difficult

94
00:06:04,584 --> 00:06:08,594
to recognize which one is the progressive app and on the other side which

95
00:06:08,632 --> 00:06:12,274
one is the native app. Indeed it's very

96
00:06:12,312 --> 00:06:15,842
difficult. As I said, I give you a little

97
00:06:15,976 --> 00:06:19,494
so called hint and this probably should really help

98
00:06:19,532 --> 00:06:22,946
you to understand which one is the native app and which one is a progressive

99
00:06:22,978 --> 00:06:26,422
web app. Most probably yes, you got it.

100
00:06:26,476 --> 00:06:29,782
From the size the native app we can see

101
00:06:29,836 --> 00:06:33,562
it takes much more space or memory space

102
00:06:33,616 --> 00:06:37,642
on a user device, while a progressive web apps is almost

103
00:06:37,776 --> 00:06:41,706
minimal or really minimal. If we look again at the

104
00:06:41,808 --> 00:06:45,774
layout once again we can see that the differences are

105
00:06:45,812 --> 00:06:49,022
really, really small and is almost impossible to understand

106
00:06:49,156 --> 00:06:52,558
and to see which one is the native app and which one is the

107
00:06:52,644 --> 00:06:56,782
progressive web app. And this indeed is one of the core goals

108
00:06:56,846 --> 00:07:00,338
of a progressive app being able to provide

109
00:07:00,424 --> 00:07:03,778
an experience that is as close as possible as a

110
00:07:03,784 --> 00:07:07,426
native app, not only in the functionalities provided,

111
00:07:07,458 --> 00:07:11,234
but also in the layout. So we want to enrich

112
00:07:11,362 --> 00:07:14,934
the experience for a user assessing our web application

113
00:07:15,052 --> 00:07:18,490
and make it as close as possible to what could have been

114
00:07:18,560 --> 00:07:21,180
if the user would have used a native app.

115
00:07:22,670 --> 00:07:26,314
Before going further, just some small

116
00:07:26,352 --> 00:07:29,530
words about what are the core components that are

117
00:07:29,600 --> 00:07:33,102
present in a progressive web app. First of all, we have to talk

118
00:07:33,156 --> 00:07:36,574
about service workers. Service workers are

119
00:07:36,612 --> 00:07:40,730
just a JavaScript component very similar to a web worker.

120
00:07:40,890 --> 00:07:44,546
They operate on a separate thread from the one

121
00:07:44,648 --> 00:07:48,162
used by the main application, so that even though

122
00:07:48,216 --> 00:07:52,370
the service worker crashes, so stop running or it's very

123
00:07:52,440 --> 00:07:56,642
very lengthy or executing a very heavy task,

124
00:07:56,706 --> 00:08:00,054
this will not affect at all our main application and this is

125
00:08:00,092 --> 00:08:03,974
exactly what we want. Let's see how

126
00:08:04,012 --> 00:08:07,800
a service worker operates on our client side.

127
00:08:08,430 --> 00:08:12,650
So when we request our progressive web app, we get

128
00:08:12,720 --> 00:08:16,554
the response and we also download the

129
00:08:16,592 --> 00:08:20,610
service worker. That is, as we said, is just a JavaScript file.

130
00:08:20,790 --> 00:08:25,022
Then according to how we implement caching strategies for

131
00:08:25,076 --> 00:08:28,846
this service worker, we could eventually already save in the

132
00:08:28,868 --> 00:08:32,030
local cache some assets and some other files.

133
00:08:32,630 --> 00:08:36,142
This makes it possible that from next time the user

134
00:08:36,206 --> 00:08:39,954
assess our progressive web apps, even though there is

135
00:08:39,992 --> 00:08:43,394
no Internet connectivity still we are able through

136
00:08:43,432 --> 00:08:47,526
the service worker to provide this requested data from the

137
00:08:47,548 --> 00:08:51,506
local cache. So there is no need to go at all over the network

138
00:08:51,618 --> 00:08:55,490
and the user not only receives this response

139
00:08:55,570 --> 00:08:58,826
extremely quickly, but also when he or

140
00:08:58,848 --> 00:09:02,758
she is offline. So no need of being connected

141
00:09:02,774 --> 00:09:07,206
to the network at all. Web manifest

142
00:09:07,318 --> 00:09:11,002
is a JSON file that contains

143
00:09:11,066 --> 00:09:14,718
all the instruction to tell the user agent

144
00:09:14,804 --> 00:09:18,222
how our progressive web apps should be

145
00:09:18,276 --> 00:09:21,920
rendered. Once open, it's also a very important

146
00:09:22,530 --> 00:09:25,938
file that we have to create in

147
00:09:25,944 --> 00:09:28,962
a proper way. So to fill in a proper way in order to be able

148
00:09:29,016 --> 00:09:32,558
to be installed on a client's device,

149
00:09:32,654 --> 00:09:36,182
our progressive web app let's see, the first two

150
00:09:36,236 --> 00:09:40,214
proper name and short name will be used as a label or

151
00:09:40,252 --> 00:09:43,974
as a text string under the icon. Once this

152
00:09:44,012 --> 00:09:47,670
will be installed on a user device

153
00:09:48,570 --> 00:09:52,546
display mode tells how the browser

154
00:09:52,738 --> 00:09:56,698
should render our progressive app. We can use a browser value.

155
00:09:56,784 --> 00:10:00,362
In that case it's just a default way of or

156
00:10:00,416 --> 00:10:03,894
view that we get once we assess with the mobile device

157
00:10:03,942 --> 00:10:07,562
our progressive web app. But it's more interesting standalone

158
00:10:07,626 --> 00:10:11,342
where we can see that some UI elements of the browser, for example

159
00:10:11,396 --> 00:10:14,862
the address bar are removed. So gives a much more

160
00:10:14,916 --> 00:10:18,114
feeling of a progressive of a native app.

161
00:10:18,312 --> 00:10:21,762
And on the other side full screen that as the name side

162
00:10:21,896 --> 00:10:25,734
says we can use the whole device screen and this is

163
00:10:25,772 --> 00:10:29,206
more suited for device for application that

164
00:10:29,228 --> 00:10:33,606
are media rich or for games. For example we

165
00:10:33,628 --> 00:10:37,122
can define a starting URL for our PWA

166
00:10:37,186 --> 00:10:41,638
because we want to provide, as again we said native

167
00:10:41,734 --> 00:10:45,078
feeling so that when the users open our progressive

168
00:10:45,094 --> 00:10:48,794
web apps, we want to provide always the same home page or

169
00:10:48,832 --> 00:10:53,230
always the same starting page and not the last visited URL.

170
00:10:53,890 --> 00:10:57,678
Lastly, we can define some icons that can be used not only

171
00:10:57,764 --> 00:11:01,086
on the user device home screen but also as a

172
00:11:01,108 --> 00:11:04,546
splash screen. If the browser supports that.

173
00:11:04,728 --> 00:11:08,382
Typically we can provide a different resolution

174
00:11:08,446 --> 00:11:12,500
or different sizes so that we can have a pixel perfect

175
00:11:13,030 --> 00:11:16,498
experience for our users. As a

176
00:11:16,504 --> 00:11:18,770
minimum we should provide two sizes,

177
00:11:18,850 --> 00:11:22,294
192 for 992 or

178
00:11:22,332 --> 00:11:25,240
512 per 512.

179
00:11:26,090 --> 00:11:29,946
We can even provide a purpose. Purpose that says

180
00:11:30,048 --> 00:11:34,086
how this icon will be displayed on a user device.

181
00:11:34,198 --> 00:11:37,770
In this case we can see we define the maskable and

182
00:11:37,840 --> 00:11:41,606
as a fallback any that is the default value. We will see

183
00:11:41,648 --> 00:11:45,226
just in a second what are maskable icons.

184
00:11:45,418 --> 00:11:49,194
So these are the minimum properties that we can define

185
00:11:49,242 --> 00:11:53,774
in a manifest file in order to be able to make it installable

186
00:11:53,822 --> 00:11:57,522
on a user device. Let's see what are

187
00:11:57,576 --> 00:12:01,490
maskable icons. Let's start

188
00:12:01,560 --> 00:12:04,878
saying before that some manufacturers like for example

189
00:12:04,984 --> 00:12:09,046
Samsung at the beginning decided to have all icons on

190
00:12:09,068 --> 00:12:12,630
a device with the same shape. And after

191
00:12:12,700 --> 00:12:16,086
this also other producers decided to have the

192
00:12:16,108 --> 00:12:20,074
same idea but giving a different size. So because

193
00:12:20,112 --> 00:12:23,430
of this Android from the version

194
00:12:23,510 --> 00:12:27,622
Oreo of Android OS decided

195
00:12:27,686 --> 00:12:31,790
to introduce the concept of adaptive icons. So being able

196
00:12:31,860 --> 00:12:35,678
to provide images with an extra space

197
00:12:35,764 --> 00:12:39,694
around that can be cut, it cropped in order to

198
00:12:39,732 --> 00:12:44,058
be able to provide different shapes according to

199
00:12:44,164 --> 00:12:47,250
our or the user wish. This is okay,

200
00:12:47,320 --> 00:12:50,900
this is nice, but it's a problem if we define some

201
00:12:51,350 --> 00:12:54,894
or we already created some progressive web apps and we provided

202
00:12:54,942 --> 00:12:58,806
our icons that are not maskable. If we do that,

203
00:12:58,908 --> 00:13:02,502
we will see that our icons will be either

204
00:13:02,556 --> 00:13:05,942
cropped so some parts will be cut away or they will have

205
00:13:05,996 --> 00:13:10,182
a white background instead of using the whole background

206
00:13:10,246 --> 00:13:14,074
as wished or as desired. To do that we

207
00:13:14,112 --> 00:13:17,674
can create maskable icons. So we define a

208
00:13:17,712 --> 00:13:21,754
circular area where radio is 40% of

209
00:13:21,952 --> 00:13:25,642
the image size and this is called the safe

210
00:13:25,706 --> 00:13:29,326
area. So we can place within this safe area

211
00:13:29,428 --> 00:13:32,918
all the part that we want to be sure that won't be cropped

212
00:13:33,034 --> 00:13:37,234
in any kind of shape and everything that is outside might

213
00:13:37,272 --> 00:13:40,846
be cropped according to the final shape

214
00:13:40,878 --> 00:13:44,606
that will be used. So if we target

215
00:13:44,718 --> 00:13:48,322
Android devices for our progressive web apps,

216
00:13:48,386 --> 00:13:52,854
we have to keep in mind these

217
00:13:52,892 --> 00:13:56,390
aspects. So we have to create icons that are maskable.

218
00:13:58,510 --> 00:14:01,754
That said, let's see how can we make our web

219
00:14:01,792 --> 00:14:05,658
application extremely fast and also how can be possible to

220
00:14:05,744 --> 00:14:09,514
provide data even while offline? This is possible

221
00:14:09,632 --> 00:14:13,470
thanks to caching strategies because by default a service

222
00:14:13,540 --> 00:14:17,278
worker doesn't know anything about which assets to

223
00:14:17,444 --> 00:14:20,830
cache and when to provide from the cache.

224
00:14:21,170 --> 00:14:24,574
These assets we have to define thanks to caching

225
00:14:24,622 --> 00:14:28,260
strategies. Yes,

226
00:14:29,190 --> 00:14:33,106
we can see that the mobile traffic in

227
00:14:33,128 --> 00:14:37,222
the past years really took over the desktop traffic over

228
00:14:37,276 --> 00:14:40,630
Internet and this is something we have really to keep in mind,

229
00:14:40,700 --> 00:14:44,662
being able to optimising our web application even for

230
00:14:44,716 --> 00:14:48,090
mobile devices. So not only for desktop application,

231
00:14:48,160 --> 00:14:52,410
but mobile devices nowadays have a really strong weight

232
00:14:53,230 --> 00:14:55,980
on the market. So we have to keep this in mind.

233
00:14:56,990 --> 00:15:00,334
The first cache structuring we will going to see

234
00:15:00,372 --> 00:15:04,010
is the cache first. As the name suggests,

235
00:15:04,170 --> 00:15:07,870
we make a request and this request gets

236
00:15:07,940 --> 00:15:11,326
intercepted by the service worker and then the

237
00:15:11,348 --> 00:15:16,526
service worker. If there is a match with some cached

238
00:15:16,638 --> 00:15:20,382
assets that we define, then these will be immediately

239
00:15:20,446 --> 00:15:23,954
provided from the cache. So no need to go over the network and

240
00:15:23,992 --> 00:15:27,110
respond extremely fast. On the other side,

241
00:15:27,180 --> 00:15:30,930
if the assets are not available on the cache, there will be a normal

242
00:15:31,010 --> 00:15:35,154
network request. As a fallback, this caching

243
00:15:35,202 --> 00:15:39,510
strategy is to be chosen if we want to implement

244
00:15:39,590 --> 00:15:43,226
an offline first approach. On the

245
00:15:43,248 --> 00:15:47,462
other side, we can implement a network first caching strategy.

246
00:15:47,606 --> 00:15:51,610
As the name suggests, we go first over the network

247
00:15:51,770 --> 00:15:55,642
because we want to provide the very latest response

248
00:15:55,706 --> 00:15:59,422
with the most up to date data or values. This is

249
00:15:59,476 --> 00:16:03,546
the case for example when we want to provide values

250
00:16:03,578 --> 00:16:07,106
from a caching stock exchange API and

251
00:16:07,128 --> 00:16:11,058
so we don't want to provide the cache the data unless there is

252
00:16:11,144 --> 00:16:14,434
no network connectivity. So as a fallback we can go over

253
00:16:14,472 --> 00:16:19,014
the cache if possible. We want to provide the

254
00:16:19,052 --> 00:16:21,990
latest up to date data from the network.

255
00:16:22,970 --> 00:16:27,994
And aside these there are also kind of hybrid services

256
00:16:28,112 --> 00:16:31,894
or strategies. One of these is called stale

257
00:16:31,942 --> 00:16:35,754
while revalidate strategy. What this does is that when

258
00:16:35,792 --> 00:16:39,258
the service worker intercepts a request, it goes

259
00:16:39,344 --> 00:16:43,086
immediately over the cache and tries to provide from

260
00:16:43,108 --> 00:16:46,574
there the requested assets so that the response is

261
00:16:46,612 --> 00:16:50,574
extremely fast. But in the background it also goes over

262
00:16:50,612 --> 00:16:54,450
the network and tries to fetch any new updated

263
00:16:54,950 --> 00:16:58,670
asset and updates the relative version in the cache.

264
00:16:58,750 --> 00:17:03,038
So that any following request will get a newer version

265
00:17:03,134 --> 00:17:06,270
straight from the cache to implement.

266
00:17:06,350 --> 00:17:09,846
This strategy is not very complex, but there are some lines of

267
00:17:09,868 --> 00:17:11,800
code we have to provide.

268
00:17:13,530 --> 00:17:17,398
We don't go over the code because it's quite simple, but just to say that

269
00:17:17,564 --> 00:17:21,202
there is some work that we have to implement, especially if we

270
00:17:21,276 --> 00:17:25,210
wanted to create some more complex strategies

271
00:17:26,910 --> 00:17:30,746
of logic for our application. However, thanks for

272
00:17:30,768 --> 00:17:34,366
us, there are some tools that we can use. One of

273
00:17:34,388 --> 00:17:37,834
these is workbox. Workbox is a set of libraries

274
00:17:37,882 --> 00:17:41,194
and node modules that makes very easy to cache

275
00:17:41,242 --> 00:17:45,006
assets and to create or implement

276
00:17:45,198 --> 00:17:48,850
caching strategies. We can see in this case with just

277
00:17:48,920 --> 00:17:52,226
three lines of code we can say, or we

278
00:17:52,248 --> 00:17:55,646
can implement the stalewall revalidate

279
00:17:55,758 --> 00:17:59,254
strategy, the one we saw just before. And thanks to that

280
00:17:59,292 --> 00:18:02,850
we can say that we want to cache all JavaScript and the CSS

281
00:18:02,930 --> 00:18:06,454
file. For example, we define routes where

282
00:18:06,492 --> 00:18:10,298
we can provide a string or in this case regisc in

283
00:18:10,304 --> 00:18:13,642
order to match some specific path or some

284
00:18:13,696 --> 00:18:16,966
specific files that we want to cache.

285
00:18:17,158 --> 00:18:20,774
So workbox, it's a really powerful tool

286
00:18:20,832 --> 00:18:23,934
or set of libraries that nowadays is kind of considered a

287
00:18:23,972 --> 00:18:28,062
state of art in order to implement advanced scenarios for

288
00:18:28,116 --> 00:18:31,646
progressive web apps. It's also important to say that

289
00:18:31,668 --> 00:18:35,570
workbox is a framework agnostic, so we can work with

290
00:18:35,640 --> 00:18:39,278
Forbox in our react project Vue JS angular

291
00:18:39,374 --> 00:18:43,282
no matter, or even vanilla Javascript, it will just

292
00:18:43,336 --> 00:18:47,030
work on the other side if we are working with

293
00:18:47,100 --> 00:18:51,286
some framework like for example angular, it's also possible

294
00:18:51,388 --> 00:18:54,838
to start with the progressive web apps and it's very

295
00:18:54,924 --> 00:18:58,866
easy. Thanks to the NGraD schematics,

296
00:18:58,898 --> 00:19:02,314
we can inject progressive web apps capabilities into

297
00:19:02,352 --> 00:19:06,186
an existing file. We will

298
00:19:06,208 --> 00:19:09,946
see shortly a demo that shows how easy is to

299
00:19:09,968 --> 00:19:13,434
go and to create a progressive

300
00:19:13,482 --> 00:19:17,374
app starting from an angular project. There is the

301
00:19:17,412 --> 00:19:20,638
code on GitHub. You can see and

302
00:19:20,724 --> 00:19:24,226
download the code there so you don't need to pay attention to all the

303
00:19:24,248 --> 00:19:27,842
details. And the goal of this demo is to see and

304
00:19:27,896 --> 00:19:31,234
to demonstrate how easy is to create a progressive web

305
00:19:31,272 --> 00:19:34,900
app application starting from an angular project.

306
00:19:36,250 --> 00:19:39,814
So we can see here I have my

307
00:19:39,852 --> 00:19:42,950
visual code with the simple basic

308
00:19:43,450 --> 00:19:47,126
new angular project and I

309
00:19:47,148 --> 00:19:51,430
already ran the NgAd angular PWA command.

310
00:19:51,510 --> 00:19:55,050
What this command does is that it downloads the service

311
00:19:55,120 --> 00:19:58,394
worker module and register for us. Plus it creates some

312
00:19:58,432 --> 00:20:02,174
other files that we will describe very soon. We can see

313
00:20:02,212 --> 00:20:07,258
that we register the file ng serviceworkerworker

314
00:20:07,354 --> 00:20:10,830
Js file. This is the real service worker that so

315
00:20:10,980 --> 00:20:14,286
is stored in the node modules.

316
00:20:14,398 --> 00:20:18,110
We cannot manually change this service worker file

317
00:20:18,190 --> 00:20:22,050
otherwise every time our

318
00:20:22,120 --> 00:20:25,526
solution is built, all the changes that we

319
00:20:25,548 --> 00:20:29,462
did will be wiped out and we

320
00:20:29,516 --> 00:20:33,334
enabled this registration. So this service worker we wanted

321
00:20:33,372 --> 00:20:37,080
to register only when we have a production build

322
00:20:37,550 --> 00:20:40,986
this because we want to go over only for

323
00:20:41,088 --> 00:20:44,698
our production releases. One of

324
00:20:44,704 --> 00:20:48,490
the files that is created is the manifest file. As we saw before,

325
00:20:48,640 --> 00:20:52,326
there are some properties that are already prefilled with some

326
00:20:52,368 --> 00:20:56,526
default values for us. Of course we can customize as we want and

327
00:20:56,548 --> 00:20:59,738
we can see that there are also many more sizes

328
00:20:59,834 --> 00:21:02,694
that are created for us per default.

329
00:21:02,842 --> 00:21:06,594
But much more interesting is the NGSW so

330
00:21:06,712 --> 00:21:09,570
angular service worker configuration file.

331
00:21:09,910 --> 00:21:13,426
This is a JSON file that is created for us. And here is the

332
00:21:13,448 --> 00:21:17,378
real magic here. Actually we can define the assets,

333
00:21:17,474 --> 00:21:21,606
static assets or APIs that we want to cache by

334
00:21:21,628 --> 00:21:25,986
default. Angular creates only an asset groups array

335
00:21:26,098 --> 00:21:29,254
where it's possible to define static

336
00:21:29,382 --> 00:21:33,126
assets. So JavaScript files or ATML files

337
00:21:33,158 --> 00:21:37,110
that will be cached according to different installed

338
00:21:37,190 --> 00:21:40,910
mode strategies. Let's calculate this.

339
00:21:41,060 --> 00:21:44,878
The first object has an installed mode prefetch and here

340
00:21:44,964 --> 00:21:49,114
we can put all the files that we want to be cached

341
00:21:49,162 --> 00:21:52,754
already when the service worker is

342
00:21:52,792 --> 00:21:57,934
loaded and installed. These are for example all the core files

343
00:21:57,982 --> 00:22:01,410
that we want to provide immediately when the user access

344
00:22:01,480 --> 00:22:04,718
our website and is offline.

345
00:22:04,894 --> 00:22:08,710
So with this install mode prefetch value

346
00:22:08,780 --> 00:22:12,338
we can tell to the service worker grab all these files

347
00:22:12,434 --> 00:22:15,798
and install already or download and save in the

348
00:22:15,804 --> 00:22:18,946
cache already while you are installing.

349
00:22:19,138 --> 00:22:22,966
It's important to note that if one of these files fails

350
00:22:22,998 --> 00:22:26,614
to be downloaded, the service worker installation fails,

351
00:22:26,662 --> 00:22:30,102
will be aborted and so it will be obtained

352
00:22:30,166 --> 00:22:33,982
again. Next time the users assess the

353
00:22:34,036 --> 00:22:37,534
pages or we refresh the page itself so we don't have to

354
00:22:37,572 --> 00:22:41,802
put their big files or too many files, just a bare

355
00:22:41,866 --> 00:22:45,378
minimum. On the other side we have another

356
00:22:45,464 --> 00:22:48,514
array with name property assets in this

357
00:22:48,552 --> 00:22:52,740
case and installed mode lazy. We wanted to

358
00:22:53,190 --> 00:22:56,626
target here all assets files or font files for

359
00:22:56,648 --> 00:22:59,480
example that are not so crucial for our application.

360
00:23:00,010 --> 00:23:03,910
By defining install mode lazy, we tells the service worker that

361
00:23:03,980 --> 00:23:08,090
we wanted to download and store in the cache those files only

362
00:23:08,160 --> 00:23:11,386
after they have been requested a first time and then

363
00:23:11,408 --> 00:23:14,966
we can see we have an update mode property with value prefetch.

364
00:23:15,078 --> 00:23:19,370
This means tells to the service

365
00:23:19,440 --> 00:23:23,334
worker to upload the stored value the

366
00:23:23,392 --> 00:23:27,566
assets in the cache as soon as a new value is available

367
00:23:27,668 --> 00:23:31,022
on the server. We could have users here a value instead

368
00:23:31,076 --> 00:23:35,118
of prefetch a value of lazy. In that case we would have updated

369
00:23:35,214 --> 00:23:39,314
our stored assets only after they

370
00:23:39,352 --> 00:23:43,154
have been requested a second time. So these values are

371
00:23:43,192 --> 00:23:46,914
created by default for us with the ngrad angular PWA

372
00:23:46,962 --> 00:23:50,534
command, but it's possible also to

373
00:23:50,572 --> 00:23:54,482
go further and to cache

374
00:23:54,546 --> 00:23:58,566
also APIs. For that we have to create a data groups

375
00:23:58,598 --> 00:24:02,582
array and create different cache

376
00:24:02,646 --> 00:24:06,346
names. In this case, for example, I wanted to target an

377
00:24:06,368 --> 00:24:10,598
API where URL providing

378
00:24:10,694 --> 00:24:15,150
dead jokes and we want to define strategy performance.

379
00:24:15,570 --> 00:24:18,558
Strategy performance in angular means a cache first.

380
00:24:18,644 --> 00:24:21,498
So we go immediately over the network,

381
00:24:21,674 --> 00:24:25,202
sorry, over the cache, and we

382
00:24:25,256 --> 00:24:28,946
can have a retain policy of five entries and

383
00:24:28,968 --> 00:24:32,386
a max age of 15 minutes. After that time the

384
00:24:32,408 --> 00:24:35,766
cache will be renewed. So this

385
00:24:35,868 --> 00:24:40,594
strategy is to provide extremely

386
00:24:40,642 --> 00:24:44,550
faster responses. And even though there is no network connectivity

387
00:24:44,890 --> 00:24:48,650
on the other side, we create another

388
00:24:48,720 --> 00:24:51,946
group and we want to cache an

389
00:24:51,968 --> 00:24:55,242
API that provides cat's image. We are really

390
00:24:55,376 --> 00:24:59,938
fans of cats, so we want the very latest images.

391
00:25:00,054 --> 00:25:03,754
Because of this we use a strategy freshness and strategy

392
00:25:03,802 --> 00:25:07,390
freshness means network first.

393
00:25:07,460 --> 00:25:11,114
As we saw before, we can provide again a maxi and max

394
00:25:11,162 --> 00:25:15,102
age values as in the previous cache

395
00:25:15,246 --> 00:25:19,630
configuration group. But here we can also define a timeout

396
00:25:19,710 --> 00:25:22,930
can be 5 seconds one day or a different

397
00:25:23,080 --> 00:25:26,502
timeout. One day actually would be way too

398
00:25:26,556 --> 00:25:30,374
long. So means that if we trigger a

399
00:25:30,412 --> 00:25:34,402
request and the timeout occurs, then we instruct

400
00:25:34,466 --> 00:25:38,766
the service worker that the user

401
00:25:38,818 --> 00:25:42,186
could be eventually offline, or in the case the

402
00:25:42,208 --> 00:25:45,354
network is too slow. So there will be

403
00:25:45,392 --> 00:25:49,770
a fallback and the service worker will try to provide the response

404
00:25:50,930 --> 00:25:54,366
from the cache. So this is everything we

405
00:25:54,388 --> 00:25:58,190
have to create, nothing else. And we are already able to create

406
00:25:58,340 --> 00:26:02,462
and to provide an angular application with just these

407
00:26:02,516 --> 00:26:05,300
a few commands. But let's see now,

408
00:26:05,670 --> 00:26:09,090
how does it look like this is

409
00:26:09,240 --> 00:26:12,722
our application that we just saw? Where on the left side

410
00:26:12,776 --> 00:26:16,834
we have the joke that is coming from the dead joke API,

411
00:26:16,882 --> 00:26:20,818
and on the right side the freshness strategy

412
00:26:20,914 --> 00:26:23,190
with the cats images.

413
00:26:23,690 --> 00:26:27,080
If we open the devtools, in this case I'm using

414
00:26:27,790 --> 00:26:31,354
chrome and we go on the application tab, we can see

415
00:26:31,392 --> 00:26:35,158
that over the service workers menu

416
00:26:35,254 --> 00:26:38,586
we can have an overview about the service worker that

417
00:26:38,608 --> 00:26:42,382
is installed. If we click on a manifest, we can see

418
00:26:42,436 --> 00:26:45,950
just a nice representation of all the values that

419
00:26:46,100 --> 00:26:50,190
are coming or properties that are coming from the web manifest.

420
00:26:50,530 --> 00:26:54,274
In the cache storage we have all the assets that

421
00:26:54,312 --> 00:26:57,902
have been cached. Now if we switch on the network

422
00:26:57,966 --> 00:27:02,258
tab and we refresh the page first time

423
00:27:02,344 --> 00:27:06,450
and now refresh it again, we can see that the joke

424
00:27:06,530 --> 00:27:09,960
doesn't change. And if we check the

425
00:27:11,690 --> 00:27:15,654
network tab, we can see that API providing the joke comes

426
00:27:15,692 --> 00:27:19,690
from the service worker. There is no network

427
00:27:21,230 --> 00:27:25,020
response or payload going back and forth while

428
00:27:26,510 --> 00:27:29,882
the search API for the cat image just comes

429
00:27:29,936 --> 00:27:33,726
back. Now if I go offline and I refresh the

430
00:27:33,748 --> 00:27:37,786
page, we can see that the images and that joke

431
00:27:37,818 --> 00:27:41,406
are provided. And if we check the network tab, we can

432
00:27:41,428 --> 00:27:45,074
see that both endpoints now are provided from

433
00:27:45,112 --> 00:27:49,140
the cache. So there is no network connectivity and

434
00:27:49,510 --> 00:27:53,490
we can provide that thanks to these caching strategies and the service

435
00:27:53,560 --> 00:27:57,370
worker. We can provide the data even though we are offline

436
00:27:57,470 --> 00:28:01,110
from the cache. Very nice and it's in a very simple

437
00:28:01,180 --> 00:28:04,870
way. So now I'm going online again, I refresh and again

438
00:28:04,940 --> 00:28:07,910
we can get a very new fresh image.

439
00:28:08,350 --> 00:28:11,674
And this is to show how easy is to

440
00:28:11,712 --> 00:28:15,606
create a progressive web app with angular

441
00:28:15,718 --> 00:28:19,034
very few steps. Let's continue with

442
00:28:19,072 --> 00:28:22,334
our application, with our presentation, sorry.

443
00:28:22,452 --> 00:28:25,786
And let's see one limit of progressive

444
00:28:25,818 --> 00:28:29,610
web apps. We can see that we could cache

445
00:28:29,690 --> 00:28:32,862
some get calls when we try to fetch

446
00:28:32,926 --> 00:28:36,546
some data. But would it be possible to provide a better experience?

447
00:28:36,648 --> 00:28:40,050
Because what is the case if we want

448
00:28:40,120 --> 00:28:43,966
to provide also the possibility

449
00:28:44,078 --> 00:28:47,346
of to store somehow or persist somehow,

450
00:28:47,458 --> 00:28:50,854
even put and post changes while

451
00:28:50,892 --> 00:28:54,534
the user is offline? How this is possible? This is not

452
00:28:54,572 --> 00:28:57,790
possible by default with the cache API interface,

453
00:28:57,890 --> 00:29:01,382
but we can create some custom solution.

454
00:29:01,446 --> 00:29:05,798
For example, we can implement indexdb

455
00:29:05,894 --> 00:29:09,978
that stores while the user is offline all the put or post

456
00:29:10,064 --> 00:29:13,454
requests that are attempt. And then as soon as the

457
00:29:13,572 --> 00:29:17,214
user restore its connectivity, then we

458
00:29:17,252 --> 00:29:20,526
can implement our logic that we go in order one

459
00:29:20,548 --> 00:29:23,874
by one to these appending requests and we trigger them

460
00:29:23,912 --> 00:29:26,782
one by one. Indeed, not very complex,

461
00:29:26,846 --> 00:29:30,114
but we have to implement quite some

462
00:29:30,152 --> 00:29:34,002
logic. There are so other

463
00:29:34,056 --> 00:29:38,418
tools we can use. For example, Farbas platform provides

464
00:29:38,434 --> 00:29:42,274
a set of functionalities and services for mobile

465
00:29:42,322 --> 00:29:45,250
devices implementation and web implementation.

466
00:29:45,410 --> 00:29:48,730
But we are in this case much more interested in cloud

467
00:29:48,800 --> 00:29:52,678
Firestore in the umbrella of services and products offered.

468
00:29:52,854 --> 00:29:56,886
Cloud Firestore is a NoSQL database

469
00:29:56,918 --> 00:30:00,134
that provides also offline storage. And this is great

470
00:30:00,192 --> 00:30:03,486
for us because with just one command we can

471
00:30:03,588 --> 00:30:07,518
create this indexdb and store all

472
00:30:07,604 --> 00:30:10,954
the changes for us in a very transparent

473
00:30:11,002 --> 00:30:14,930
way for the user. Once we imported

474
00:30:15,430 --> 00:30:19,586
the library, we have to enable the

475
00:30:19,608 --> 00:30:22,978
offline persistence if we are implementing a web application,

476
00:30:23,144 --> 00:30:27,670
while for a mobile application it's already enabled by default.

477
00:30:28,010 --> 00:30:31,766
So we invoke the enable persistence method and

478
00:30:31,788 --> 00:30:35,554
that's all what we have to do. From that moment, all requests

479
00:30:35,602 --> 00:30:38,810
that we ship will be cached by cloud

480
00:30:38,880 --> 00:30:42,502
firestore and will be saved locally.

481
00:30:42,646 --> 00:30:46,490
There is a 40 megabyte megabyte cache

482
00:30:46,830 --> 00:30:50,650
threshold, but we can define a bigger or a smaller

483
00:30:50,730 --> 00:30:54,062
value according we want. As soon as then we reach

484
00:30:54,116 --> 00:30:57,962
this limit, all the oldest values

485
00:30:58,026 --> 00:31:02,190
or records will be wiped away, wiped out from the cache,

486
00:31:02,850 --> 00:31:06,194
and then these value that are stored locally will be

487
00:31:06,232 --> 00:31:08,990
available even when the user is offline.

488
00:31:09,150 --> 00:31:12,322
So that not only it's possible to access this data

489
00:31:12,376 --> 00:31:17,094
while offline, but also to interact. So make

490
00:31:17,132 --> 00:31:21,074
changes over this data while offline, and cloud Firestore

491
00:31:21,122 --> 00:31:24,840
will keep track of all these pending changes. And then as soon as

492
00:31:25,210 --> 00:31:28,426
the network is restored so the

493
00:31:28,448 --> 00:31:31,100
connectivity to the server is restored again,

494
00:31:31,710 --> 00:31:35,366
cloud Firestore will go over these appending changes and ship

495
00:31:35,398 --> 00:31:39,414
them one by one, synchronizing them to the server.

496
00:31:39,542 --> 00:31:42,942
All this is done out of the box for us. We don't have to do

497
00:31:42,996 --> 00:31:44,400
absolutely anything.

498
00:31:45,730 --> 00:31:49,930
So let's see now a slightly more complex

499
00:31:50,090 --> 00:31:53,298
solution that indeed tries to

500
00:31:53,384 --> 00:31:57,154
justify the title of this session, so that offline web

501
00:31:57,192 --> 00:31:59,810
application nowadays don't exist anymore.

502
00:32:01,590 --> 00:32:05,558
We will see. The demo is

503
00:32:05,644 --> 00:32:08,918
also an angular application,

504
00:32:09,004 --> 00:32:12,486
sorry, using angular material for the layout, we can see

505
00:32:12,508 --> 00:32:16,002
the cards and using cloud Firestore

506
00:32:16,066 --> 00:32:20,010
as a NoSQL database. With offline storage

507
00:32:21,550 --> 00:32:25,398
aside, I will try to mirror

508
00:32:25,494 --> 00:32:27,100
my phone.

509
00:32:31,090 --> 00:32:34,750
Just a second. Yes,

510
00:32:34,900 --> 00:32:36,160
connected please.

511
00:32:39,090 --> 00:32:42,486
I will see how it is the progressive

512
00:32:42,538 --> 00:32:46,674
web applications on

513
00:32:46,712 --> 00:32:51,746
my Android device and on

514
00:32:51,768 --> 00:32:55,800
the server. Let's say like this,

515
00:32:56,330 --> 00:32:59,000
sorry, like this, side by side.

516
00:32:59,370 --> 00:33:02,402
So this application I implemented,

517
00:33:02,546 --> 00:33:06,262
it's a progressive application, as we said, I implemented in order to keep track

518
00:33:06,316 --> 00:33:09,702
of all restaurants or nice bars that I visited while

519
00:33:09,756 --> 00:33:13,594
traveling with my wife. So it's a nice way to keep track of

520
00:33:13,712 --> 00:33:17,306
good bars and suggest to my friends, or even not suggest if

521
00:33:17,328 --> 00:33:20,762
they were being so bad. One good things

522
00:33:20,816 --> 00:33:24,234
of it of the progressive apps is that they are responsive.

523
00:33:24,282 --> 00:33:27,726
So for example, in the web view we can

524
00:33:27,748 --> 00:33:31,834
see that if I narrow the window, the layout adapts

525
00:33:31,882 --> 00:33:35,886
automatically. On the other side, if I open my progressive

526
00:33:35,918 --> 00:33:39,486
web app on the device, we can see that we have one line of cards

527
00:33:39,518 --> 00:33:42,706
only and there is no label aside of

528
00:33:42,728 --> 00:33:45,974
the icons. Another nice things is that

529
00:33:46,092 --> 00:33:49,618
we can see that my progressive

530
00:33:49,634 --> 00:33:54,886
web app is displayed as it would be a

531
00:33:54,908 --> 00:33:58,086
separate application, as it would be

532
00:33:58,108 --> 00:34:01,654
a native apps, and not as a party of Chrome browser.

533
00:34:01,702 --> 00:34:05,674
So indeed another aspect to show much

534
00:34:05,712 --> 00:34:09,690
more close to a native app. So if

535
00:34:09,760 --> 00:34:13,502
I now change one

536
00:34:13,556 --> 00:34:17,342
entry, so I just write edit and I save

537
00:34:17,396 --> 00:34:20,942
it automatically. This change is propagated thanks

538
00:34:20,996 --> 00:34:24,966
to sockets and thanks to cloud Firestore is propagated

539
00:34:25,018 --> 00:34:28,926
to all the other clients that are listening to it. So that's

540
00:34:28,958 --> 00:34:32,434
why on the right side I can see that this entry has

541
00:34:32,472 --> 00:34:35,380
been also updated on my phone.

542
00:34:35,930 --> 00:34:39,638
But now let's see a much more interesting scenario. So I

543
00:34:39,724 --> 00:34:43,634
switch off connectivity. So I go in airplane mode

544
00:34:43,682 --> 00:34:47,574
on my phone and I refresh the page. So not

545
00:34:47,612 --> 00:34:51,674
only I can see all the content because I

546
00:34:51,712 --> 00:34:55,354
store these documents locally and this is a progressive web

547
00:34:55,392 --> 00:34:59,418
apps. So all the assets are here, icons and so on are here available.

548
00:34:59,584 --> 00:35:04,074
But I can also open a completely new entry

549
00:35:04,122 --> 00:35:07,274
in restaurant and for example let's

550
00:35:07,322 --> 00:35:10,874
write it offline, save it for a title

551
00:35:11,002 --> 00:35:14,500
and then let's see that this change affects only

552
00:35:15,510 --> 00:35:18,574
my phone. So my progressive

553
00:35:18,622 --> 00:35:22,162
app on the phone because of course there is no connectivity, I'm cut

554
00:35:22,216 --> 00:35:25,750
off, I'm offline and there is no offline

555
00:35:26,330 --> 00:35:29,942
server synchronization. And now

556
00:35:29,996 --> 00:35:34,118
the interesting thing is that as soon as I will go online

557
00:35:34,204 --> 00:35:38,202
again, let's just make, for the sake of demo,

558
00:35:38,336 --> 00:35:42,134
just change the other one. Also the title

559
00:35:42,262 --> 00:35:44,700
and let's save it.

560
00:35:45,390 --> 00:35:48,954
So we have the first two entries that have been

561
00:35:48,992 --> 00:35:52,702
changed, the other are still here visible, but of course we don't change

562
00:35:52,756 --> 00:35:56,874
them. So now I switch my airplane

563
00:35:56,922 --> 00:36:00,414
mode off and I will go online again. What I would

564
00:36:00,452 --> 00:36:04,834
expect is that here on the left side, so on the web

565
00:36:04,952 --> 00:36:10,578
view this client will get these

566
00:36:10,664 --> 00:36:14,094
two values. So the Sagami Milano and the bar North

567
00:36:14,142 --> 00:36:17,602
island entry will be updated with the entries

568
00:36:17,666 --> 00:36:21,174
that I edited on my phone. So I go

569
00:36:21,212 --> 00:36:24,594
online again and according to my connection, if faster,

570
00:36:24,642 --> 00:36:28,360
yeah, it's quite fast. So we can see that the changes that I did

571
00:36:29,770 --> 00:36:33,450
on my phone, so on the progressive web, apps stored on my phone

572
00:36:33,520 --> 00:36:37,146
have been propagated on the server and then to all

573
00:36:37,168 --> 00:36:41,130
the other clients listening to that. And this indeed it's

574
00:36:41,210 --> 00:36:45,162
quite cool because for the user now let me switch

575
00:36:45,226 --> 00:36:49,434
off again the connectivity, so let me go again offline

576
00:36:49,562 --> 00:36:53,170
for the user. Actually there is absolutely no difference whether

577
00:36:53,240 --> 00:36:57,474
being online or offline. We just provide

578
00:36:57,592 --> 00:37:01,714
a great experience because everything is working exactly

579
00:37:01,912 --> 00:37:05,140
in the same way, either offline and online.

580
00:37:05,770 --> 00:37:09,750
So this is a very nice combination of technologies

581
00:37:11,050 --> 00:37:14,342
with this progressive web app and also other

582
00:37:14,476 --> 00:37:18,214
cool technologies like cloud, Firestore and its functionality

583
00:37:18,262 --> 00:37:22,010
of offline storage, offline persistence.

584
00:37:23,470 --> 00:37:26,874
So should we now replace all

585
00:37:26,912 --> 00:37:30,186
our native apps with progressive web apps or should we just go

586
00:37:30,208 --> 00:37:33,214
with the progressive web apps? Well, I would

587
00:37:33,252 --> 00:37:37,162
say it depends on the cases. Of course, there is no silver bullet.

588
00:37:37,226 --> 00:37:40,762
As always, there are some limitations

589
00:37:40,826 --> 00:37:44,370
still in progressive web apps. Some of them are, for example,

590
00:37:44,440 --> 00:37:47,886
that many functionalities are still not fully

591
00:37:47,918 --> 00:37:51,550
supported by Apple. So if we wanted to target

592
00:37:51,630 --> 00:37:54,210
also Apple devices or iOS,

593
00:37:55,430 --> 00:37:59,026
we won't be able to use the full spectrum of functionality

594
00:37:59,058 --> 00:38:02,790
of progressive web apps, for example web notification or some

595
00:38:02,860 --> 00:38:06,466
web manifest properties. This is quite unfortunate, but it's

596
00:38:06,498 --> 00:38:10,114
still the case on the other side. Progressive web apps

597
00:38:10,172 --> 00:38:13,180
can do only what web applications can do.

598
00:38:13,550 --> 00:38:17,414
One thing is that it's not possible to assess the device

599
00:38:17,462 --> 00:38:21,850
contacts, even though Google is bringing on the contact Picker API,

600
00:38:21,930 --> 00:38:25,360
but it's still something experimental and not really

601
00:38:25,890 --> 00:38:29,082
widely used. And lastly,

602
00:38:29,146 --> 00:38:33,094
native apps have in general much better performances.

603
00:38:33,162 --> 00:38:36,610
So if we have to provide an application that is extremely

604
00:38:38,390 --> 00:38:42,290
media rich or is a game, then it's better we go with

605
00:38:42,360 --> 00:38:46,722
native apps because native

606
00:38:46,786 --> 00:38:50,562
apps can be tied to the underlying operating

607
00:38:50,626 --> 00:38:54,210
system while PWAs are provided

608
00:38:54,290 --> 00:38:57,830
through the browser.

609
00:38:59,310 --> 00:39:03,514
Before concluding, I would like to give you some links that might

610
00:39:03,552 --> 00:39:06,714
stimulate further your interest for progressive web

611
00:39:06,752 --> 00:39:10,874
apps and give you even more information about them.

612
00:39:11,072 --> 00:39:13,926
The first two websites,

613
00:39:14,038 --> 00:39:18,222
PWA Rocks and Upscope is a kind of media

614
00:39:18,356 --> 00:39:21,614
or application gallery where you can find a lot

615
00:39:21,652 --> 00:39:24,914
of samples of progressive apps. So to

616
00:39:24,952 --> 00:39:28,594
get an idea of what is possible to create with

617
00:39:28,632 --> 00:39:32,770
the progressive web apps, it's really cool. They are really cool websites.

618
00:39:33,510 --> 00:39:37,238
Progressivewebapstats.com shows

619
00:39:37,404 --> 00:39:40,706
all successful stories and in which measure progressive

620
00:39:40,738 --> 00:39:44,520
web app benefit or improved the

621
00:39:44,970 --> 00:39:48,440
Roy and other metrics for different

622
00:39:49,050 --> 00:39:52,502
websites and domains and the

623
00:39:52,556 --> 00:39:55,666
last two websites.

624
00:39:55,778 --> 00:39:59,510
So PWA is a stack overflow collection of

625
00:39:59,660 --> 00:40:02,986
the the biggest requested or most viewed

626
00:40:03,018 --> 00:40:06,250
requested about progressive web apps and service worker

627
00:40:06,330 --> 00:40:09,646
and what PWA can do today collects a

628
00:40:09,668 --> 00:40:13,490
set of functionalities and features that they are possible to

629
00:40:13,560 --> 00:40:16,210
implement in progressive web apps.

630
00:40:16,790 --> 00:40:20,898
So these are very interesting links and

631
00:40:20,984 --> 00:40:24,578
websites that I really strongly suggested to visit if you are interested

632
00:40:24,664 --> 00:40:27,830
to dig deeper in progressive web apps.

633
00:40:28,490 --> 00:40:32,290
That said, thank you very much for your attention.

634
00:40:32,450 --> 00:40:36,040
You can reach me on Twitter handle or

635
00:40:36,650 --> 00:40:42,258
from time to time I write articles on the dev IO portal

636
00:40:42,434 --> 00:40:46,790
and that's it. Thank you very much. I hope you enjoyed my talk

637
00:40:46,940 --> 00:40:50,990
and if you have questions please contact

638
00:40:51,060 --> 00:40:55,070
me in Twitter or just follow me if you are interested to get updates.

639
00:40:55,570 --> 00:40:56,380
Thank you very much.

