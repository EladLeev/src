1
00:00:26,850 --> 00:00:30,214
Hi everyone, thanks for joining me for my talk about

2
00:00:30,252 --> 00:00:34,054
automated serverless security testing. My name is Tal.

3
00:00:34,252 --> 00:00:38,102
Let's start. So why am I giving you this

4
00:00:38,156 --> 00:00:41,522
talk? About five years ago I joined labs,

5
00:00:41,586 --> 00:00:45,222
a startup based in Israel that developed a

6
00:00:45,276 --> 00:00:48,774
serverless runtime protection solution. Before that,

7
00:00:48,812 --> 00:00:52,602
I never heard about the the topic serverless

8
00:00:52,666 --> 00:00:56,126
before. After two years on

9
00:00:56,148 --> 00:01:00,234
the road, we got acquired by Checkpoint

10
00:01:00,282 --> 00:01:03,666
security, and after that I decided to

11
00:01:03,688 --> 00:01:07,570
shift further left and create my own company called Cloud Essence,

12
00:01:08,150 --> 00:01:11,410
a cloud native security testing

13
00:01:11,990 --> 00:01:16,294
company that got acquired, by contrast, security last year

14
00:01:16,412 --> 00:01:21,410
you can find me on social media, typically with my handler

15
00:01:21,570 --> 00:01:24,120
apps with four. With the four,

16
00:01:25,610 --> 00:01:28,220
right. Why is it this talk? Interesting.

17
00:01:28,670 --> 00:01:32,554
Forrester predicts that one out of four

18
00:01:32,592 --> 00:01:36,182
of you by the end of the year will use serverless regularly.

19
00:01:36,246 --> 00:01:39,420
So I think it's an important topic to talk about,

20
00:01:39,970 --> 00:01:43,338
and it's something we should be aware of. The security implications

21
00:01:43,434 --> 00:01:47,034
and challenges in serverless and serverless testing

22
00:01:47,162 --> 00:01:49,440
might be different. Let's see.

23
00:01:50,610 --> 00:01:54,814
Typically, we already know that the cloud transformation

24
00:01:54,862 --> 00:01:58,702
has begun. We know everyone start talking about cloud and cloud development.

25
00:01:58,766 --> 00:02:02,286
Cloud native. Of course, there are companies like iRobot

26
00:02:02,318 --> 00:02:05,734
and Skyscanner which are pioneering maybe this type

27
00:02:05,772 --> 00:02:08,966
of development, and they are ahead of the

28
00:02:08,988 --> 00:02:13,702
curve. But we can see even big organization coming

29
00:02:13,756 --> 00:02:18,038
ahead with cloud native development. And even if now they are

30
00:02:18,204 --> 00:02:22,202
in a kind of a hybrid solution between monolith and cloud

31
00:02:22,256 --> 00:02:25,930
native applications, they're going to move

32
00:02:26,000 --> 00:02:29,958
more and more and we're going to see more and more adoption into cloud

33
00:02:30,064 --> 00:02:33,530
development. Okay, but what is serverless

34
00:02:33,610 --> 00:02:36,846
really? Serverless is a lot of things. First of

35
00:02:36,868 --> 00:02:39,978
all, it's a different architecture. No more big monoliths,

36
00:02:39,994 --> 00:02:44,190
one big flow application. Instead, many, many resources.

37
00:02:44,270 --> 00:02:48,478
Independent OpenSource, which are configured

38
00:02:48,574 --> 00:02:52,002
to talk to another and other services in order to create

39
00:02:52,056 --> 00:02:55,574
the logic of the application. But each of these resources is

40
00:02:55,612 --> 00:02:58,680
independent, and we have to take care of that.

41
00:02:59,050 --> 00:03:02,706
Cycles are different. Developers devsecops,

42
00:03:02,738 --> 00:03:06,466
you might have heard hyper agile

43
00:03:06,658 --> 00:03:09,690
development cycles. No more waterfalls,

44
00:03:10,030 --> 00:03:14,666
quick iterations and quick

45
00:03:14,768 --> 00:03:18,266
time to value. Processes are different.

46
00:03:18,448 --> 00:03:21,982
Typically in the cloud, you better automate everything because

47
00:03:22,036 --> 00:03:25,166
you do not own the infrastructureascode. Then if

48
00:03:25,188 --> 00:03:27,680
you don't really automate the things,

49
00:03:28,210 --> 00:03:32,554
automate everything. It's really hard to get visibility and get

50
00:03:32,612 --> 00:03:35,762
information from the right place at the right time.

51
00:03:35,896 --> 00:03:39,426
So mostly we're automating things to get

52
00:03:39,608 --> 00:03:42,420
the information and the data that we need.

53
00:03:43,270 --> 00:03:47,302
The decision making is also changes, so it's less about top

54
00:03:47,356 --> 00:03:50,982
down. This is the time, this is the place

55
00:03:51,036 --> 00:03:54,066
to do something. Developers get more and more responsibility.

56
00:03:54,178 --> 00:03:58,598
Part of it is also security, and we'll touch that drives

57
00:03:58,774 --> 00:04:03,018
bottom up decision making, letting the developers get more and more

58
00:04:03,184 --> 00:04:04,410
responsibility.

59
00:04:08,350 --> 00:04:12,302
Serverless architecture. Well, this is a big picture, a small

60
00:04:12,356 --> 00:04:15,966
picture, sorry, of a medium sized, maybe even a

61
00:04:15,988 --> 00:04:19,514
small medium sized application that is built in serverless.

62
00:04:19,562 --> 00:04:23,182
You can see maybe a couple of dozen APIs

63
00:04:23,246 --> 00:04:27,486
and certain functions and some other resources

64
00:04:27,598 --> 00:04:31,890
may be summed up to, I don't know, 200, 300 resources.

65
00:04:33,190 --> 00:04:36,722
This is a small application. I've seen customers

66
00:04:36,856 --> 00:04:39,590
with millions of functions and resources.

67
00:04:40,570 --> 00:04:44,262
I cannot even start to imagine how it would look. The problem

68
00:04:44,316 --> 00:04:48,166
is that if you don't have this kind of look that we provide or

69
00:04:48,268 --> 00:04:51,674
some kind of visibility into what you have, it's really hard to

70
00:04:51,712 --> 00:04:55,162
understand what is connected to what, who is talking

71
00:04:55,216 --> 00:05:02,046
to who and what is my risks. Where are my risks here? Because if

72
00:05:02,068 --> 00:05:05,882
I'm a security expert or even a development

73
00:05:05,946 --> 00:05:09,870
manager, it's hard for me to really understand what

74
00:05:09,940 --> 00:05:13,874
is going on in my system. I mean, lambda functions and other

75
00:05:13,912 --> 00:05:17,634
functions pop up on a daily basis, if not

76
00:05:17,672 --> 00:05:21,780
more into production. Even so, it's really hard to follow that.

77
00:05:23,510 --> 00:05:27,510
That also means that we have to take care of each of these resources

78
00:05:27,850 --> 00:05:31,618
in a separate way. Sometimes for security reasons.

79
00:05:31,714 --> 00:05:35,334
We'll have to monitor each one, to authenticate each one,

80
00:05:35,372 --> 00:05:38,138
to perform zero trust,

81
00:05:38,304 --> 00:05:41,658
or any type of security that we

82
00:05:41,664 --> 00:05:45,930
want to apply into each of those resources separately.

83
00:05:47,950 --> 00:05:51,502
Well, serverless, just to understand. It's less

84
00:05:51,556 --> 00:05:54,986
about a synchronous flow,

85
00:05:55,178 --> 00:05:59,086
it's more about an event driven architecture. Something happens

86
00:05:59,188 --> 00:06:02,646
inside your cloud. It could be a file

87
00:06:02,698 --> 00:06:06,306
that was uploaded, downloaded, deleted, an API call, which is

88
00:06:06,328 --> 00:06:10,174
kind of common. A table or entry

89
00:06:10,222 --> 00:06:14,094
inside your database that was changed an Iot rule,

90
00:06:14,142 --> 00:06:17,554
a log, an analytic, everything that you can imagine,

91
00:06:17,602 --> 00:06:19,670
almost anything that you can imagine,

92
00:06:20,250 --> 00:06:24,498
something happened. It runs your code and your code interacts

93
00:06:24,514 --> 00:06:28,394
with other services and opensource in the cloud. The problem is

94
00:06:28,512 --> 00:06:32,474
that where your code is could

95
00:06:32,512 --> 00:06:36,134
also be your mistakes. And if you're making big mistakes,

96
00:06:36,182 --> 00:06:39,814
that could really end up in a cloud disaster, data breaches

97
00:06:39,862 --> 00:06:44,134
and whatnot. In general, AWS lambdas

98
00:06:44,182 --> 00:06:48,080
work like this. Something happened, triggered the function.

99
00:06:48,450 --> 00:06:51,326
AWS pins up a container for you and we'll talk about.

100
00:06:51,348 --> 00:06:55,294
It's not really a full container. It's like a runtime

101
00:06:55,342 --> 00:06:59,060
environment ready for you. It runs your code.

102
00:07:00,150 --> 00:07:02,180
When the code finish,

103
00:07:04,070 --> 00:07:06,950
the container dies. There is no more container.

104
00:07:08,890 --> 00:07:12,626
What about some security aspects about it? So I'll

105
00:07:12,658 --> 00:07:15,986
touch mostly about AWS and lambda here because it's

106
00:07:16,018 --> 00:07:19,834
the most common one. But you can think about some of the aspects in

107
00:07:19,872 --> 00:07:23,270
other cloud providers as well, like Azure, GCP,

108
00:07:23,430 --> 00:07:27,338
Alibaba and some others. So in

109
00:07:27,424 --> 00:07:31,630
AWS lambda, the environment is a read only environment.

110
00:07:32,290 --> 00:07:35,786
If you need to write into somewhere it's going to be temp.

111
00:07:35,818 --> 00:07:39,790
It's the only write permission directory

112
00:07:40,450 --> 00:07:43,726
that also have some security aspect. We'll talk

113
00:07:43,748 --> 00:07:47,694
about it in just a few seconds. The environments

114
00:07:47,822 --> 00:07:51,314
is not really wired to the interfaces. I mean you can connect to

115
00:07:51,432 --> 00:07:55,170
services, APIs, whatever you want, you can connect to the outside

116
00:07:55,240 --> 00:07:59,400
world. Getting inside access is

117
00:08:00,170 --> 00:08:03,458
not possible. I mean you cannot ssh to the runtime,

118
00:08:03,634 --> 00:08:06,680
you can just run your code inside, that's it.

119
00:08:08,190 --> 00:08:11,942
The data is temporary, meaning that when the execution

120
00:08:12,006 --> 00:08:15,434
ends and you're in runtime dies, the data that was

121
00:08:15,472 --> 00:08:19,194
there is terminated, is deleted. That is

122
00:08:19,232 --> 00:08:23,390
true, but for performance reasons,

123
00:08:24,770 --> 00:08:29,322
the cloud provider, in this case AWS, recycles environments.

124
00:08:29,466 --> 00:08:33,914
So in order to save time of

125
00:08:33,972 --> 00:08:37,666
spinning up environment new environments, if a request coming in or an

126
00:08:37,688 --> 00:08:41,940
event happened, it executes your code. Then another one happens.

127
00:08:42,550 --> 00:08:45,814
That cloud be even dozens or even hundreds at the same

128
00:08:45,852 --> 00:08:49,958
time, randomly, the cloud provider will take

129
00:08:50,044 --> 00:08:53,494
a run environment they already ran because it's up and just

130
00:08:53,532 --> 00:08:56,360
give it to the next coming event.

131
00:08:56,890 --> 00:09:00,474
That means that the data that was before, if it was not deleted by

132
00:09:00,512 --> 00:09:04,186
you, by the code is still there.

133
00:09:04,288 --> 00:09:07,898
And if you have some security issues

134
00:09:07,984 --> 00:09:11,866
in your code, someone can even access this data and exfiltrate

135
00:09:11,898 --> 00:09:15,246
it. What other security interest

136
00:09:15,348 --> 00:09:19,434
aspects we can think about? It is the code itself lies

137
00:09:19,482 --> 00:09:22,894
or resides in the environment. So in order for your

138
00:09:23,012 --> 00:09:27,106
lambda to run, the container comes up, your code is inside and

139
00:09:27,128 --> 00:09:30,610
it runs your code. So the code is there. If I have access to

140
00:09:30,680 --> 00:09:34,222
the runtime, I have access to your code. The keys

141
00:09:34,286 --> 00:09:38,454
are also inside. That means the keys that are basically

142
00:09:38,652 --> 00:09:42,694
the permission keys for the lambda inside the

143
00:09:42,732 --> 00:09:46,866
cloud. This is what lets your lambda function communicate

144
00:09:46,898 --> 00:09:48,970
with other services and resources.

145
00:09:50,350 --> 00:09:53,754
This is a big challenge in security specifically for

146
00:09:53,792 --> 00:09:56,940
lambda and in the cloud in general.

147
00:09:57,710 --> 00:10:00,814
And they're inside the environments. That means that if I

148
00:10:00,852 --> 00:10:03,802
get access to the environment, I get access to the keys.

149
00:10:03,866 --> 00:10:07,550
I can do some, maybe even bad things inside

150
00:10:07,620 --> 00:10:08,480
your cloud.

151
00:10:12,210 --> 00:10:15,714
Serverless security testing a thing well, this is

152
00:10:15,832 --> 00:10:19,854
pretty old, but you can see a continuous rise in serverless computing

153
00:10:19,902 --> 00:10:23,330
trend. This is a Google trend map.

154
00:10:23,910 --> 00:10:27,494
It goes and it continues to go up. There are

155
00:10:27,532 --> 00:10:31,570
some maybe during the COVID

156
00:10:31,650 --> 00:10:34,310
period there was maybe less,

157
00:10:34,460 --> 00:10:38,374
but it's picking up and growing

158
00:10:38,422 --> 00:10:42,060
with time. But you can see that for three, four years

159
00:10:42,430 --> 00:10:46,330
the servers security search on Google was

160
00:10:46,480 --> 00:10:49,578
between zero to one or two at the top

161
00:10:49,664 --> 00:10:53,214
one time and I'm pretty sure

162
00:10:53,252 --> 00:10:56,686
that from here, around here, all the

163
00:10:56,708 --> 00:11:00,446
times that you see one is me. So no

164
00:11:00,468 --> 00:11:04,678
one really talks about it. And I think we should have more awareness about server

165
00:11:04,714 --> 00:11:09,006
security, because even though it still contains

166
00:11:09,038 --> 00:11:12,642
some of the previous security aspects, application security,

167
00:11:12,776 --> 00:11:15,140
there are some challenges that we need to discuss.

168
00:11:15,830 --> 00:11:19,526
Okay, so let's say it's a thing. Can we apply the

169
00:11:19,548 --> 00:11:23,110
traditional application security to serverless? If so,

170
00:11:23,180 --> 00:11:26,786
we don't really need this talk because we can do whatever we've

171
00:11:26,818 --> 00:11:30,054
been doing before. Right? Let's see. Let's inspect

172
00:11:30,102 --> 00:11:33,370
that. So what are the biggest challenges? The first

173
00:11:33,440 --> 00:11:36,714
one is the

174
00:11:36,832 --> 00:11:40,460
provision or the policy given to the function,

175
00:11:41,710 --> 00:11:45,566
which is a huge thing or a big challenge, because if

176
00:11:45,588 --> 00:11:49,150
we're talking about one function, it's relatively easy because you can look

177
00:11:49,220 --> 00:11:52,842
inside the code, do some code reviews, see the API

178
00:11:52,906 --> 00:11:56,610
calls, write, but item, translate it into put item.

179
00:11:57,670 --> 00:12:00,994
Actually this is the good

180
00:12:01,032 --> 00:12:04,558
one. The put item here, the X is because it was an animated

181
00:12:04,734 --> 00:12:07,350
before it was converted into PDF.

182
00:12:08,250 --> 00:12:11,990
So before the put item here, there was a wild card,

183
00:12:12,060 --> 00:12:15,606
the star asterisk, which means the function can

184
00:12:15,628 --> 00:12:18,534
do any action inside your,

185
00:12:18,652 --> 00:12:22,106
inside the cloud, which means that if someone has access to

186
00:12:22,128 --> 00:12:24,886
this function or the code or the runtime,

187
00:12:25,078 --> 00:12:28,454
they can do whatever they want inside your databases,

188
00:12:28,582 --> 00:12:32,282
even if it's a database that it's not even related

189
00:12:32,346 --> 00:12:35,854
to your application. Because also here there was

190
00:12:35,892 --> 00:12:39,454
a wild card, a star meaning access to any

191
00:12:39,492 --> 00:12:43,326
table, whether the list privilege what we

192
00:12:43,348 --> 00:12:47,470
calls, which is the right permission set, is to set put item

193
00:12:47,550 --> 00:12:51,714
as a specific action. That means that if the function is

194
00:12:51,752 --> 00:12:55,794
even if it's vulnerable and someone can run your code

195
00:12:55,912 --> 00:12:59,634
or execute your code, or maybe give an arbitrary

196
00:12:59,682 --> 00:13:02,754
code for the code to run, it will be blocked

197
00:13:02,802 --> 00:13:06,358
by the cloud if it's not the specific policy

198
00:13:06,444 --> 00:13:09,994
that was given. So if I'm going to change that into delete or

199
00:13:10,032 --> 00:13:13,626
scan, even in the code, even if

200
00:13:13,648 --> 00:13:17,318
I change the code, if the policy states just put item,

201
00:13:17,414 --> 00:13:21,174
that means I will be blocked. And you should do it also on the resource

202
00:13:21,222 --> 00:13:23,966
level. So instead of putting a wild card here,

203
00:13:24,068 --> 00:13:27,562
you should specify the exact table

204
00:13:27,626 --> 00:13:30,974
in this case, which is taken from the environment variable. So we

205
00:13:31,012 --> 00:13:34,370
should take the environment variable value and put it inside

206
00:13:34,440 --> 00:13:38,226
the policy resource. Well, when you do

207
00:13:38,248 --> 00:13:41,986
it to one function, it's really easy, but when you have to do it at

208
00:13:42,008 --> 00:13:45,318
scale, it becomes a problem. What happens

209
00:13:45,404 --> 00:13:49,186
if you don't trust me is this. The developer

210
00:13:49,218 --> 00:13:52,566
will go to stack overflow or any other website

211
00:13:52,748 --> 00:13:56,166
will look for my

212
00:13:56,188 --> 00:14:00,026
lambda is unauthorized to perform dynamodb scan. Okay,

213
00:14:00,208 --> 00:14:04,026
I'll put this error in some forums and

214
00:14:04,048 --> 00:14:07,466
I'll get hey, I work with an Amazon engineer and

215
00:14:07,488 --> 00:14:12,042
it turns out the problem was the policy configurations. It should be dynamodb

216
00:14:12,186 --> 00:14:15,742
Star. No, it should not be dynamodb Star.

217
00:14:15,796 --> 00:14:19,498
Of course this gives the function tools many permission.

218
00:14:19,594 --> 00:14:24,020
It just need to do a scan. Let's see another example.

219
00:14:24,950 --> 00:14:27,780
This was taken from stack overflow, right?

220
00:14:29,110 --> 00:14:32,594
I don't even remember the question, but someone said I

221
00:14:32,632 --> 00:14:36,254
solved this by adding AWS lambda full access provision

222
00:14:36,302 --> 00:14:39,762
to the lambda. Just go to the lambda im role,

223
00:14:39,826 --> 00:14:43,474
blah blah, specify everything and add the provision.

224
00:14:43,602 --> 00:14:46,934
That should do it. No, that should not do it. You know why?

225
00:14:47,052 --> 00:14:50,694
Because AWS lambda full access policy looks

226
00:14:50,732 --> 00:14:55,302
like this and this is a

227
00:14:55,356 --> 00:14:59,194
tranquate version of it. There are more provision, I just put the

228
00:14:59,232 --> 00:15:03,754
important ones or the risky ones. Cloudwatch Star dynamodb

229
00:15:03,802 --> 00:15:07,102
Star events star Lambda star. You can

230
00:15:07,156 --> 00:15:10,750
execute any code logs Star s three star

231
00:15:10,820 --> 00:15:14,500
resource star. Lucky for us

232
00:15:15,510 --> 00:15:19,010
AWS deprecated this. So no,

233
00:15:19,080 --> 00:15:22,146
AWs lambda full access should not be the solution for

234
00:15:22,168 --> 00:15:23,380
your lambda code.

235
00:15:25,370 --> 00:15:28,134
Okay, we talked about the policy,

236
00:15:28,332 --> 00:15:33,366
let's talk. But other security challenges we have in

237
00:15:33,388 --> 00:15:37,198
a monolith application, usually we have a synchronous

238
00:15:37,394 --> 00:15:40,970
API request coming in through

239
00:15:41,040 --> 00:15:44,778
the load balancer, through the API gateway, whatever that is.

240
00:15:44,864 --> 00:15:48,666
We can put all our security

241
00:15:48,848 --> 00:15:51,902
tools and security capabilities in this point.

242
00:15:51,956 --> 00:15:55,530
So whatever comes in does through input validation,

243
00:15:55,610 --> 00:15:58,202
through output, filtering, through DLP,

244
00:15:58,266 --> 00:16:01,050
through IPS, through firewalls.

245
00:16:01,210 --> 00:16:04,674
So you're always almost protected, right? At least

246
00:16:04,712 --> 00:16:08,130
90%. When you talk about serverless,

247
00:16:08,710 --> 00:16:12,094
you lose the perimeter. That means that the attacker

248
00:16:12,222 --> 00:16:15,862
can really get into your code from different

249
00:16:15,916 --> 00:16:19,442
things that you haven't thought about before. It can be through an API?

250
00:16:19,506 --> 00:16:23,186
Yeah, of course. But it can also be from someone uploading

251
00:16:23,218 --> 00:16:27,110
a file, someone performing analytics

252
00:16:28,190 --> 00:16:31,978
code, commits, log processing, database changes,

253
00:16:32,144 --> 00:16:36,540
and it just execute your code. And there is no middle between

254
00:16:37,310 --> 00:16:41,002
database, the database and your code. So if someone

255
00:16:41,056 --> 00:16:44,766
changed the database, you cannot say, hey, before you run my code,

256
00:16:44,948 --> 00:16:48,606
transfer this data to me. No, this is not controlled by

257
00:16:48,628 --> 00:16:51,934
you, so you have to put the security inside the

258
00:16:51,972 --> 00:16:56,882
code. You remember this now

259
00:16:56,936 --> 00:17:00,738
protect each and every one of these. Well,

260
00:17:00,824 --> 00:17:03,700
if it's not automated, it's not going to happen.

261
00:17:05,270 --> 00:17:08,866
There are some other security, several security risks.

262
00:17:09,058 --> 00:17:13,446
We're not going to talk about all of them. I'll refer you to information

263
00:17:13,548 --> 00:17:17,442
about them, I'll just mention some of them. So event injection is

264
00:17:17,516 --> 00:17:21,580
basically someone tacking your function with arbitrary code.

265
00:17:22,350 --> 00:17:26,326
Broken authentications are functions that are not performing

266
00:17:26,358 --> 00:17:30,214
any type of authentication, just relying on the incoming data

267
00:17:30,352 --> 00:17:34,394
sensitive data exposure. Of course, lambda contains sensitive

268
00:17:34,442 --> 00:17:38,430
data like keys and codes and

269
00:17:38,500 --> 00:17:44,066
some secrets in your environment variables. So if

270
00:17:44,088 --> 00:17:47,310
you're not testing yourself, you might be at risk.

271
00:17:47,390 --> 00:17:51,566
Over privileged function, we talked about it. Vulnerable dependencies,

272
00:17:51,678 --> 00:17:54,898
well, that's not new just now. It's in a

273
00:17:54,904 --> 00:17:58,582
lambda function. Insufficient logging and monitoring. Well,

274
00:17:58,636 --> 00:18:02,710
AWS logs and monitors pretty much everything. You just need to connect

275
00:18:02,780 --> 00:18:06,866
to the right location and collect the right data and matrices.

276
00:18:07,058 --> 00:18:10,394
Open resources are lambdas and other services like s

277
00:18:10,432 --> 00:18:14,374
three buckets API that are unprotected, unconfigured,

278
00:18:14,422 --> 00:18:17,786
misconfigured, allowing anyone to access them.

279
00:18:17,888 --> 00:18:22,178
Denial of service and denial of wallet

280
00:18:22,294 --> 00:18:26,074
are the ability for someone to either block

281
00:18:26,122 --> 00:18:29,774
your lambda functions because of the limitations they have,

282
00:18:29,892 --> 00:18:34,190
or letting you pay for any lambda executions.

283
00:18:34,690 --> 00:18:38,114
Insecure shared space we discussed this earlier about the

284
00:18:38,152 --> 00:18:41,650
data in slash temp that is shared between random

285
00:18:41,990 --> 00:18:45,766
executions and of course insecure secret management, because your

286
00:18:45,788 --> 00:18:49,366
lambda can have keys and secrets inside the code or

287
00:18:49,388 --> 00:18:52,280
the configuration which are not protected. Well,

288
00:18:53,210 --> 00:18:57,426
can security scale on serverless?

289
00:18:57,538 --> 00:19:00,822
Well, it can, but there are some challenges.

290
00:19:00,966 --> 00:19:04,646
There are a lot of services, lambda is just one of them, but it connects

291
00:19:04,678 --> 00:19:08,230
to many other, there are frequent development, it's not a monolith

292
00:19:08,310 --> 00:19:11,854
application with downtime. Serverless functions go

293
00:19:11,892 --> 00:19:15,854
to production on daily basis. What is

294
00:19:15,892 --> 00:19:19,966
connected to what? We discussed this, it's hard to know if

295
00:19:19,988 --> 00:19:22,880
you're not the developer that wrote the specific function,

296
00:19:23,270 --> 00:19:26,722
what it is connected to. And in this case,

297
00:19:26,776 --> 00:19:30,446
of course, even before there are many developers, less appsec

298
00:19:30,478 --> 00:19:35,006
and security teams, of course. So it's hard to follow what's

299
00:19:35,038 --> 00:19:39,560
important. Well, my lambda could have permission to

300
00:19:39,930 --> 00:19:43,542
do something meaningful in my cloud, but it might not

301
00:19:43,596 --> 00:19:46,998
be connected to anything that allows an attacker to access it,

302
00:19:47,084 --> 00:19:51,174
or vice versa. I have a lambda which has a code injection.

303
00:19:51,302 --> 00:19:54,090
Okay, very risks,

304
00:19:54,990 --> 00:19:58,474
but if the lambda permissions allow it just to write into the

305
00:19:58,512 --> 00:20:01,854
logs, that means that even

306
00:20:01,892 --> 00:20:05,982
if someone access the code runs arbitrary code,

307
00:20:06,036 --> 00:20:09,200
the function can only write logs. Not that it's not important,

308
00:20:09,970 --> 00:20:13,086
but it's less risky than someone reading

309
00:20:13,118 --> 00:20:16,286
data or modifying my files

310
00:20:16,478 --> 00:20:20,226
on an s three bucket. And even more so, it's hard to

311
00:20:20,248 --> 00:20:23,682
know what's important. Is the security the same?

312
00:20:23,816 --> 00:20:27,094
Well, we talked about some aspects, it's not exactly the same.

313
00:20:27,212 --> 00:20:30,440
We'll see about some other aspects in a few minutes.

314
00:20:31,770 --> 00:20:35,126
And there is another question. Who takes care of

315
00:20:35,148 --> 00:20:38,486
the infrastructureascode lambdas are in the

316
00:20:38,508 --> 00:20:41,766
cloud, permissions are configuration. Could be

317
00:20:41,788 --> 00:20:45,286
an appsec team, a security team, could be the developer,

318
00:20:45,398 --> 00:20:48,886
could be the DevOps team, could be the cloud engineering.

319
00:20:49,078 --> 00:20:52,698
I've seen basically everything from everything, so it's

320
00:20:52,714 --> 00:20:56,174
just hard to understand and who

321
00:20:56,212 --> 00:20:58,510
takes responsibility in these cases.

322
00:21:00,050 --> 00:21:04,366
All right, so we talked about the security aspects

323
00:21:04,478 --> 00:21:06,690
of serverless,

324
00:21:07,110 --> 00:21:10,820
but how do you test for security?

325
00:21:11,270 --> 00:21:15,038
I want shift left, right. We don't want to just say, hey, we have a

326
00:21:15,064 --> 00:21:19,046
tool in production runtime protection. We're good. No, we want

327
00:21:19,068 --> 00:21:23,014
to know that we're shipping secure code. So how

328
00:21:23,052 --> 00:21:26,258
do we test security in modern CI

329
00:21:26,274 --> 00:21:30,060
CD pipeline? Well, let's take the traditional one.

330
00:21:30,510 --> 00:21:33,834
I want a SAS here that runs on

331
00:21:33,872 --> 00:21:37,498
every commit I want to is maybe something

332
00:21:37,584 --> 00:21:41,610
more accurate that runs on integration

333
00:21:41,690 --> 00:21:45,502
tests. So some security tests in the integration in the e two e test.

334
00:21:45,636 --> 00:21:49,280
And I want to test like a desk test.

335
00:21:49,890 --> 00:21:53,306
When the product is ready, it's shipped. I have a

336
00:21:53,348 --> 00:21:56,834
website staging whatever it is, and I want to test

337
00:21:56,872 --> 00:22:00,446
it. Well, these are the traditional tools and I'd

338
00:22:00,478 --> 00:22:03,950
say those are not working well for serverless

339
00:22:04,030 --> 00:22:07,862
for several reasons. The normal ones are,

340
00:22:07,916 --> 00:22:10,886
that even happened before.

341
00:22:10,988 --> 00:22:14,962
But that SAS or static analysis

342
00:22:15,106 --> 00:22:18,194
gives a lot of false positive because it doesn't have a context.

343
00:22:18,242 --> 00:22:21,158
It just frees text. So text.

344
00:22:21,244 --> 00:22:24,762
So it's hard to understand what's important, what not. That also

345
00:22:24,816 --> 00:22:28,634
means that the developer needs to work a lot to filter them and

346
00:22:28,672 --> 00:22:32,446
let the security team configure what is important and what

347
00:22:32,468 --> 00:22:36,366
is not. Because if I'm going to test for all the

348
00:22:36,388 --> 00:22:40,126
vulnerabilities or the security policies, I'm going to get

349
00:22:40,228 --> 00:22:44,174
thousands of results. Meaningless, really. All right,

350
00:22:44,292 --> 00:22:47,938
so let's do an is test interactive application security

351
00:22:48,024 --> 00:22:51,426
test. Well, that is good. The coverage is

352
00:22:51,448 --> 00:22:54,914
a problem because you have to write tests in order to cover to get

353
00:22:54,952 --> 00:22:58,482
coverage. And the security teams need a lot of work to instrument

354
00:22:58,546 --> 00:23:02,102
your code in order for it to work. But then

355
00:23:02,156 --> 00:23:05,958
something doesn't work and you don't know if it's the is

356
00:23:06,044 --> 00:23:09,958
plugin instrumentation or your code is our latency.

357
00:23:10,134 --> 00:23:12,460
So it's not really working so good,

358
00:23:13,630 --> 00:23:16,886
especially when we talk about cloud native environment

359
00:23:17,078 --> 00:23:20,220
das. Okay, those are good.

360
00:23:20,850 --> 00:23:24,298
They're not really CI CD tools.

361
00:23:24,394 --> 00:23:27,914
It's really hard to operate them inside the pipeline.

362
00:23:27,962 --> 00:23:32,390
It requires a lot of work from both the engineering and the security teams.

363
00:23:32,570 --> 00:23:36,114
Usually they don't find anything meaningless. Sometimes they

364
00:23:36,152 --> 00:23:40,194
do, but their coverage is relatively low. There is

365
00:23:40,232 --> 00:23:44,206
a lot of work between communication

366
00:23:44,318 --> 00:23:47,474
that needs to be done, between the development, the engineering

367
00:23:47,522 --> 00:23:51,014
and the security, because they need to know when they

368
00:23:51,052 --> 00:23:54,882
can tests, what they can test on what environments.

369
00:23:55,026 --> 00:23:58,600
Basically you need to keep the environment alive with new data,

370
00:23:58,970 --> 00:24:02,714
calls the time, then frees it let the security team test,

371
00:24:02,832 --> 00:24:06,278
give you the results. The developer will go over the results,

372
00:24:06,374 --> 00:24:09,946
try to fix or understand what's going on. Continuing to

373
00:24:09,968 --> 00:24:13,040
talk with the development, the security teams fix.

374
00:24:13,490 --> 00:24:16,654
Go back to the security team, say, hey, I fixed this,

375
00:24:16,692 --> 00:24:21,002
can you retest? Yes. Next week we have another cycle,

376
00:24:21,146 --> 00:24:25,266
let's retest everything together. And there

377
00:24:25,288 --> 00:24:29,154
is a time that has passed and the testing was not

378
00:24:29,192 --> 00:24:32,674
done. And you need to ship your lambda today.

379
00:24:32,872 --> 00:24:36,840
So doesn't really work. What we need is something else.

380
00:24:37,930 --> 00:24:42,114
The problems are that if we want to use those security testing

381
00:24:42,162 --> 00:24:45,798
in a cloud native environment, we're going to get more problems.

382
00:24:45,964 --> 00:24:48,440
First of all, there is not just code.

383
00:24:49,850 --> 00:24:53,226
All the tools pretty much are ignorant of the environment and

384
00:24:53,248 --> 00:24:55,850
the context. What is the environment and the context?

385
00:24:56,430 --> 00:25:00,134
Lambda is not just code. It is connected to an infrastructure,

386
00:25:00,182 --> 00:25:03,358
to the cloud. And the cloud means a lot of things that we need to

387
00:25:03,364 --> 00:25:06,480
know, like configuration and resources and services.

388
00:25:06,850 --> 00:25:10,302
And you need to understand that a lambda is

389
00:25:10,356 --> 00:25:13,726
not an app. It starts somewhere,

390
00:25:13,838 --> 00:25:17,490
runs the code, it finish. Then there is another

391
00:25:17,560 --> 00:25:21,822
service that picks up, maybe the lambda write into the database.

392
00:25:21,966 --> 00:25:25,426
But then when it writes into the database, you have a

393
00:25:25,448 --> 00:25:29,022
configuration that runs another data, that pulls the data from the database,

394
00:25:29,166 --> 00:25:32,006
performs some action, and submit a report.

395
00:25:32,188 --> 00:25:35,782
So it's not something that you can really test

396
00:25:35,836 --> 00:25:39,974
like this. Also, tools are completely blind

397
00:25:40,022 --> 00:25:43,514
to known edge devices. All the security tools are built

398
00:25:43,552 --> 00:25:47,494
to support synchronous

399
00:25:47,542 --> 00:25:51,326
application with some kind of can entry point HTTP or some kind

400
00:25:51,348 --> 00:25:54,510
of traffic coming in. So if you want to test

401
00:25:54,580 --> 00:26:00,394
or fuzz your code, let's say take a dust, right? A dynamic

402
00:26:00,442 --> 00:26:04,660
tester, you need to give it can endpoint to start working.

403
00:26:05,830 --> 00:26:09,614
Some lambdas don't have entry

404
00:26:09,662 --> 00:26:13,358
points. Not entry points, sorry. Some lambdas don't have endpoints, they don't

405
00:26:13,374 --> 00:26:15,650
have URLs, they don't have APIs.

406
00:26:17,110 --> 00:26:21,320
I seen a system with, let's say something small,

407
00:26:22,170 --> 00:26:26,310
maybe 200 functions. Yeah, ten of them had APIs.

408
00:26:26,810 --> 00:26:30,426
Some of them, I'd say 90, 80% of

409
00:26:30,448 --> 00:26:34,860
them don't have APIs. So you cannot test them in a traditional way.

410
00:26:35,790 --> 00:26:38,906
All of these, the issues that

411
00:26:38,928 --> 00:26:42,746
we talked about really block the development and disrupt the

412
00:26:42,768 --> 00:26:46,570
CACD. That means it's very hard to scale in the pace

413
00:26:46,650 --> 00:26:50,206
of cloud native development and they're not

414
00:26:50,228 --> 00:26:54,180
good enough. And when we're in the cloud, we should get better.

415
00:26:56,070 --> 00:27:00,210
So how should we do security existing for serverless?

416
00:27:01,510 --> 00:27:04,946
Let's take an example. This is a

417
00:27:04,968 --> 00:27:08,226
tiny application, really just three lambda functions

418
00:27:08,338 --> 00:27:12,178
taken from Amazon.com. It's based on the irobots

419
00:27:12,274 --> 00:27:15,720
from Roomba, right? It's just the registration service

420
00:27:16,970 --> 00:27:20,186
you bought can irobot you open it for

421
00:27:20,208 --> 00:27:23,302
the first time and it sends one request,

422
00:27:23,366 --> 00:27:26,298
register your robot and there is a process,

423
00:27:26,384 --> 00:27:30,006
there is a lambda that process, something with IoT writes

424
00:27:30,038 --> 00:27:32,590
to the logs, put data into the queue,

425
00:27:33,650 --> 00:27:36,618
and then another function picks up this queue,

426
00:27:36,794 --> 00:27:40,414
continue to run, send it to another lambda and this

427
00:27:40,452 --> 00:27:43,394
lambda communicate with other services, IoT services.

428
00:27:43,512 --> 00:27:46,866
Really very simple. Let's see how we

429
00:27:46,888 --> 00:27:49,650
should test this. Easy,

430
00:27:49,720 --> 00:27:53,140
right? We can scan the image, right?

431
00:27:53,990 --> 00:27:58,214
If you do have an image and

432
00:27:58,252 --> 00:28:00,982
you want to just run an SCA on it, right,

433
00:28:01,036 --> 00:28:04,146
it's going to give you 10% coverage,

434
00:28:04,258 --> 00:28:07,510
50% coverage, maybe even less, I don't know.

435
00:28:07,660 --> 00:28:10,906
And you just find potential problems

436
00:28:11,088 --> 00:28:14,726
that you imported because it doesn't really mean you're vulnerable.

437
00:28:14,838 --> 00:28:18,634
You just imported some issues. I'm not saying it's not important, it is

438
00:28:18,672 --> 00:28:22,234
important, but it doesn't give you any coverage

439
00:28:22,282 --> 00:28:25,566
for your code, your configuration, your cloud,

440
00:28:25,748 --> 00:28:29,374
zero. Usually those things are

441
00:28:29,412 --> 00:28:34,014
even provided out of the box by the cloud provider so

442
00:28:34,052 --> 00:28:37,746
you can use them. And I think you should, but it's not enough.

443
00:28:37,848 --> 00:28:41,378
So what we should do, I know,

444
00:28:41,464 --> 00:28:44,674
infrastructureascode as code. We all use infrastructureascode as code now,

445
00:28:44,712 --> 00:28:48,534
right? Terraform, pulumi, serverless framework, whatever that

446
00:28:48,572 --> 00:28:52,246
is. That's great. Shift left

447
00:28:52,348 --> 00:28:56,854
as far as you can go. But again,

448
00:28:56,972 --> 00:28:59,862
you get limited visibility, right?

449
00:28:59,916 --> 00:29:03,562
Because you just see configurations, zero code

450
00:29:03,616 --> 00:29:06,746
coverage. No one will tell you there you have a problem with your code.

451
00:29:06,848 --> 00:29:10,542
It will just tell you this line is vulnerable because you did not add

452
00:29:10,596 --> 00:29:14,126
encryption, which is good, I'm very API for

453
00:29:14,148 --> 00:29:18,250
it, but it's not enough. You get no logic, no prioritization,

454
00:29:18,410 --> 00:29:22,206
and it's IAC dependent. So you really need a

455
00:29:22,228 --> 00:29:26,226
solution that is built for your infrastructureascode as code. And again you

456
00:29:26,248 --> 00:29:28,820
get zero code coverage. That's not enough,

457
00:29:30,470 --> 00:29:34,210
right? To get code coverage, let's start using

458
00:29:34,280 --> 00:29:37,958
is a modern app tech tool, maybe the most

459
00:29:38,044 --> 00:29:42,630
accurate and reliable one, really enables developers devsecops,

460
00:29:43,210 --> 00:29:46,598
but there are no servers to instrument, right? We're running on

461
00:29:46,604 --> 00:29:50,330
a lambda function. Trying to run an IST on a lambda function is really

462
00:29:50,400 --> 00:29:55,574
an overkill and hasn't worked before. So let's

463
00:29:55,622 --> 00:29:59,558
try another solution. Let's run a saft

464
00:29:59,654 --> 00:30:02,846
static analysis security testing. Well,

465
00:30:02,948 --> 00:30:06,446
looking into this, really the

466
00:30:06,468 --> 00:30:08,990
saft will see three different apps,

467
00:30:09,650 --> 00:30:13,738
just three, because there are three lambdas, because it cannot have the

468
00:30:13,764 --> 00:30:17,714
full overflow flow, because the code is not connected to each other.

469
00:30:17,832 --> 00:30:21,074
This code does not continue here

470
00:30:21,192 --> 00:30:24,306
inside the code. It needs to understand that there is

471
00:30:24,328 --> 00:30:28,582
a configurations that says to write to this queue and

472
00:30:28,636 --> 00:30:32,614
this function reads from this queue and then connect them together.

473
00:30:32,812 --> 00:30:36,166
But it's not possible because it's not in the code, it's in the

474
00:30:36,188 --> 00:30:39,842
configuration. So it doesn't see a source

475
00:30:39,906 --> 00:30:43,046
or a sync, doesn't understand where is the databases

476
00:30:43,158 --> 00:30:46,906
or the queues or anything. So really SAS will give

477
00:30:46,928 --> 00:30:51,006
you bad results, false positive and

478
00:30:51,108 --> 00:30:54,000
really false negative because it doesn't see things.

479
00:30:56,530 --> 00:30:59,930
So what should we do? Run a dast,

480
00:31:00,010 --> 00:31:03,442
a dynamic application, security testing? Well,

481
00:31:03,576 --> 00:31:07,758
you could, and you'll be able to test this API

482
00:31:07,854 --> 00:31:11,406
specifically because that's the only one with a URL

483
00:31:11,598 --> 00:31:12,930
or an API.

484
00:31:15,210 --> 00:31:19,302
So this function maybe, but I'm not sure what

485
00:31:19,356 --> 00:31:23,174
actually you will get from it because I understand, if I

486
00:31:23,212 --> 00:31:26,610
understand this correctly, it's not a synchronous flow,

487
00:31:26,690 --> 00:31:29,746
right? So the roomba will send an API request which

488
00:31:29,788 --> 00:31:32,682
will return or 200, okay,

489
00:31:32,816 --> 00:31:36,362
403, unauthorized, 404, whatever that is.

490
00:31:36,496 --> 00:31:40,198
But the rest of the application and the process doesn't happen yet.

491
00:31:40,384 --> 00:31:43,834
So the API fuzzer

492
00:31:43,962 --> 00:31:47,786
will get always or okay or unauthorized.

493
00:31:47,818 --> 00:31:50,510
You can test some things, I'm not saying you cannot,

494
00:31:50,930 --> 00:31:54,514
but most of the flows and the coverage will not be able to

495
00:31:54,552 --> 00:31:58,350
run. But there is a solution.

496
00:31:58,430 --> 00:32:01,582
Because we're in the cloud, we should do things differently

497
00:32:01,646 --> 00:32:02,580
and better.

498
00:32:04,790 --> 00:32:08,534
For example, what we do is we build something that

499
00:32:08,572 --> 00:32:12,022
connects into the cloud. So once you connect into the cloud,

500
00:32:12,076 --> 00:32:15,206
you can get all the information from the cloud, you don't need to

501
00:32:15,228 --> 00:32:18,662
do anything. So three clicks, you get your

502
00:32:18,716 --> 00:32:22,066
template, connect your cloud formation template, or whatever infrastructureascode

503
00:32:22,098 --> 00:32:25,194
is code you're using, you run it, you connect

504
00:32:25,232 --> 00:32:28,410
to the cloud, you get the right permission to do it. You can run

505
00:32:28,480 --> 00:32:32,326
discovery, get all the information, all the resources, calls, the relationships,

506
00:32:32,358 --> 00:32:36,030
calls, the interfaces, the policies or services in the environment, and connect

507
00:32:36,100 --> 00:32:39,838
them together into the graph that I showed you before. Then you

508
00:32:39,844 --> 00:32:43,454
can start analyzing your weaknesses,

509
00:32:43,502 --> 00:32:47,026
your risky points, your code, your attack surfaces, and try to

510
00:32:47,048 --> 00:32:49,380
understand where there might be problems.

511
00:32:50,230 --> 00:32:53,602
And because the cloud is built in a way

512
00:32:53,656 --> 00:32:58,018
that every service or everything

513
00:32:58,104 --> 00:33:01,286
works with something that is pre built by the cloud,

514
00:33:01,388 --> 00:33:05,778
you can also simulate those things. So what we do is we automate

515
00:33:05,874 --> 00:33:08,998
security simulations on lambda functions in this case.

516
00:33:09,084 --> 00:33:12,442
So let's say your lambda, get an API call

517
00:33:12,496 --> 00:33:16,010
and write into the database. This is what we're going to tell the function

518
00:33:16,080 --> 00:33:19,530
to do. Take this input, it's an API call.

519
00:33:19,600 --> 00:33:22,938
It's not, but we can simulate that and try to

520
00:33:22,944 --> 00:33:26,698
write into the database. And let's see what happens. Maybe I can write a file,

521
00:33:26,794 --> 00:33:30,186
maybe I can access different tables, maybe I can delete

522
00:33:30,218 --> 00:33:34,114
data and then I can also check if I actually did

523
00:33:34,152 --> 00:33:37,326
it because I'm inside the cloud, right? So let's say I'm

524
00:33:37,358 --> 00:33:41,106
trying to upload a file, I can

525
00:33:41,128 --> 00:33:43,620
check if the file was uploaded because I'm there.

526
00:33:44,550 --> 00:33:48,278
If I have the right provision, then of course if something happened,

527
00:33:48,444 --> 00:33:52,422
we can report. And the best being

528
00:33:52,476 --> 00:33:56,130
here, other than the three clicks instrumentation,

529
00:33:56,210 --> 00:33:59,894
let's call it, is that you can do it continuously.

530
00:33:59,942 --> 00:34:04,470
You can continue to monitor the environment. You don't need to run asynchronous

531
00:34:04,630 --> 00:34:08,294
or point in time scanned. We continuously monitor

532
00:34:08,342 --> 00:34:11,994
the run the cloud. If now you're going to push

533
00:34:12,122 --> 00:34:15,534
or deploy a new code or a new configurations, we'll pick

534
00:34:15,572 --> 00:34:18,846
it up and we'll test it automatically so you don't have

535
00:34:18,868 --> 00:34:20,240
to do anything else.

536
00:34:21,810 --> 00:34:24,782
Everything happens autonomously in the background.

537
00:34:24,926 --> 00:34:28,862
New code, new can, new configuration, new scan.

538
00:34:28,926 --> 00:34:32,354
You fixed your vulnerabilities, we'll retest it

539
00:34:32,392 --> 00:34:36,210
automatically, and if you fixed it, we'll just eliminate the issue

540
00:34:36,360 --> 00:34:40,120
so you don't have to even interact with the security team on that.

541
00:34:41,370 --> 00:34:45,106
This is an illustration of what we're going to do. So the developers creates

542
00:34:45,138 --> 00:34:48,458
new, deploys new code, new API with a new function.

543
00:34:48,624 --> 00:34:51,958
We're going to test this specific flow and identify

544
00:34:52,054 --> 00:34:55,642
potential vulnerabilities. And once we do, we'll know

545
00:34:55,696 --> 00:34:59,034
also what else in your cloud is

546
00:34:59,072 --> 00:35:01,760
at risk. If someone managed to do that,

547
00:35:02,690 --> 00:35:05,562
we'll know into the specific table,

548
00:35:05,626 --> 00:35:08,974
the specific action inside the table. There is

549
00:35:09,012 --> 00:35:12,750
also a nice example here, what I showed

550
00:35:13,170 --> 00:35:16,738
in black hat two years ago,

551
00:35:16,824 --> 00:35:19,982
where I hacked a lambda function with my voice

552
00:35:20,046 --> 00:35:23,746
talking to an Alexa device. Well, this is

553
00:35:23,768 --> 00:35:27,826
something that developers did not expect, right? Because it's

554
00:35:27,858 --> 00:35:31,094
not something that you're used to before, but you should take

555
00:35:31,212 --> 00:35:35,126
that into consideration now. All right,

556
00:35:35,148 --> 00:35:39,126
we're getting close. So our tool can automatically

557
00:35:39,318 --> 00:35:43,370
give you vulnerabilities and maybe

558
00:35:43,440 --> 00:35:47,046
even better policies out of the box. Copy paste

559
00:35:47,078 --> 00:35:50,554
into your environment, get a list privilege permission for each of your

560
00:35:50,592 --> 00:35:54,062
functions without doing anything. We're scanning the code,

561
00:35:54,116 --> 00:35:57,614
we're emulating the code, we're looking into the policy, we're seeing

562
00:35:57,652 --> 00:36:01,120
what the function actually needs, and then what we give to you.

563
00:36:02,450 --> 00:36:05,986
Okay. Of course, I cannot cover everything. So what you can

564
00:36:06,008 --> 00:36:09,362
do to learn more, first, there is the OS service, top ten

565
00:36:09,416 --> 00:36:12,654
project. Trying to OS, if you're unfamiliar

566
00:36:12,702 --> 00:36:16,374
with it, is an open organization, the most famous one for

567
00:36:16,412 --> 00:36:20,326
application security. And there is a project I lead

568
00:36:20,508 --> 00:36:24,370
together with some colleagues around the serverless

569
00:36:24,530 --> 00:36:28,326
world, or industry trying to

570
00:36:28,348 --> 00:36:32,594
identify the top risks

571
00:36:32,642 --> 00:36:36,106
for serverless. Right now there is an open call, so if

572
00:36:36,128 --> 00:36:39,594
your organization works with serverless and you have someone with

573
00:36:39,632 --> 00:36:43,130
some insight into security issues, security risks,

574
00:36:43,570 --> 00:36:47,578
please click this or go into this address filling

575
00:36:47,594 --> 00:36:50,894
the forms we'll take it into consideration. All the data that

576
00:36:50,932 --> 00:36:55,460
is sent is anonymous. Of course we'll collect and it's public so

577
00:36:55,910 --> 00:36:59,010
we want to get the best results from the industry.

578
00:37:00,790 --> 00:37:04,194
Lastly, there is another open source which

579
00:37:04,232 --> 00:37:07,874
you can deploy on your cloud with just

580
00:37:07,912 --> 00:37:11,750
three clicks. It's a DVSA. It's a damn vulnerable serverless application

581
00:37:11,820 --> 00:37:17,254
that I created, completely serverless and

582
00:37:17,292 --> 00:37:19,878
you can install it with just three clicks. Really,

583
00:37:20,044 --> 00:37:23,770
you just need can AWS account and the right permissions to install.

584
00:37:23,920 --> 00:37:28,154
Just make sure you do not install it into a production or any account with

585
00:37:28,192 --> 00:37:31,914
sensitive information because it's a vulnerable application and

586
00:37:31,952 --> 00:37:35,200
it's potentially going to give someone access to your data.

587
00:37:36,050 --> 00:37:39,646
Go here. Learn more. There are videos, tutorials and you

588
00:37:39,668 --> 00:37:43,870
can learn how to secure and attack your serverless applications.

589
00:37:45,970 --> 00:37:49,680
That's it. Thank you very much for participating in this call

590
00:37:50,130 --> 00:37:54,190
talk and you're welcome to shoot me an email anytime

591
00:37:54,610 --> 00:37:55,220
if thanks.

