1
00:00:27,330 --> 00:00:30,934
Hello everyone, and thanks for joining my talk. Today I'll be speaking about the

2
00:00:30,972 --> 00:00:34,262
complex relationship between software developers and test code.

3
00:00:34,396 --> 00:00:37,778
I'm also going to suggest and mainly demonstrate with live coding,

4
00:00:37,874 --> 00:00:41,554
how we as an industry can shift some of our assumptions and methodologies

5
00:00:41,602 --> 00:00:44,840
toward improving that relationship. Let us begin.

6
00:00:46,490 --> 00:00:50,270
My name Tal Doron. I'm a software engineer currently

7
00:00:50,340 --> 00:00:54,026
working at Nice and actually have been doing so for the past decade

8
00:00:54,058 --> 00:00:58,270
or so. Mainly I've been working with backend technologies such as Java

9
00:00:58,690 --> 00:01:02,318
net and of course node. About three and a half years ago,

10
00:01:02,404 --> 00:01:06,286
I've stepped out of the development teams and assumed the position of a technical coach,

11
00:01:06,398 --> 00:01:10,270
which means I go through almost every team in our R D organization

12
00:01:10,430 --> 00:01:14,242
and teach a training which is called ASE, which stands for

13
00:01:14,296 --> 00:01:17,954
agile software engineering, which basically covers in a very hands

14
00:01:17,992 --> 00:01:21,302
on and intense way, all the practices that we can see on the right,

15
00:01:21,356 --> 00:01:25,474
such as emergent design, coding, code, refactoring design principles and pattern

16
00:01:25,602 --> 00:01:28,810
testsuse code. Valuable test, TDD and BDD.

17
00:01:30,110 --> 00:01:33,322
Today we're actually going to focus on testable code,

18
00:01:33,376 --> 00:01:37,260
valuable tests and TDD. Now,

19
00:01:37,630 --> 00:01:40,874
after I teach the training, I usually join the teams and work with them

20
00:01:40,912 --> 00:01:44,142
hands on, on their own backlog. And this way we can see that we actually

21
00:01:44,196 --> 00:01:47,566
implement the things that we've done in class. So I

22
00:01:47,588 --> 00:01:51,658
want to start with the following question, okay, and that's

23
00:01:51,674 --> 00:01:54,814
a question for you, so try to think about your answer. How would

24
00:01:54,852 --> 00:01:58,594
you describe your feelings regarding writing automated tests? It doesn't matter

25
00:01:58,632 --> 00:02:01,954
if it's unit, component or integration test. Okay? Now this question actually

26
00:02:01,992 --> 00:02:05,358
interested me quite a lot when I prepared this session. So I've created

27
00:02:05,374 --> 00:02:09,618
the Google forms and published it in many, many forums

28
00:02:09,714 --> 00:02:13,190
and I got several hundred answers. Okay? So think about your answer.

29
00:02:13,260 --> 00:02:16,806
And of course, this is a multiple choice question. So these are the

30
00:02:16,828 --> 00:02:21,050
options. A, I actually like it. B, I don't like it, but I understand

31
00:02:21,120 --> 00:02:24,166
the value of me writing them. C, I hate it. I don't

32
00:02:24,198 --> 00:02:27,930
write tests. It shouldn't be within the responsibility of the developers.

33
00:02:28,670 --> 00:02:32,890
Now, after several hundreds of responses, the graph shows as follows.

34
00:02:32,970 --> 00:02:37,550
Now this is a very surprising graph, so let's talk about it. About 45%

35
00:02:37,700 --> 00:02:40,746
of people say that they actually like writing tests,

36
00:02:40,858 --> 00:02:44,766
okay? 50% don't like it, but I understand the value,

37
00:02:44,868 --> 00:02:48,014
and about 5% actually hate it. Now this is very surprising,

38
00:02:48,062 --> 00:02:51,566
okay? I was expecting different numbers altogether.

39
00:02:51,678 --> 00:02:54,882
So the first time I saw the graph, I thought to myself, you know what,

40
00:02:54,936 --> 00:02:58,638
no chance. Only 75% actually values

41
00:02:58,654 --> 00:03:01,782
the truth and 25% are straight up liars. Now,

42
00:03:01,836 --> 00:03:05,302
the graph on the right, of course, is a joke. But I would expect about

43
00:03:05,356 --> 00:03:08,806
80 or 90% of developers to say that they don't like writing tests, but they

44
00:03:08,828 --> 00:03:12,666
understand the value of it and not like almost 50 50.

45
00:03:12,848 --> 00:03:16,266
Now, I would say that it is a bit biased and the reason for

46
00:03:16,288 --> 00:03:20,086
that is people that actually want to take a survey about testing

47
00:03:20,198 --> 00:03:24,220
probably have some affinity for testing, right? And this affinity actually

48
00:03:25,310 --> 00:03:28,814
has some effects on their response. So this is my guess.

49
00:03:28,932 --> 00:03:32,302
But even if not even if these numbers are correct,

50
00:03:32,356 --> 00:03:35,514
still as an industry, we have a problem. The problem

51
00:03:35,572 --> 00:03:39,074
is that about 55% of developers say that

52
00:03:39,112 --> 00:03:42,402
they don't like writing tests. Now, it's okay not to like something,

53
00:03:42,456 --> 00:03:45,522
but if we don't like something, that we actually do

54
00:03:45,576 --> 00:03:49,106
quite a lot. And most organization actually spend

55
00:03:49,208 --> 00:03:52,550
a great deal of time today in writing tests and increasing their quality.

56
00:03:52,620 --> 00:03:55,974
So if we do it quite a lot and we don't like it, so we

57
00:03:56,012 --> 00:03:59,126
tend to do it bad. So where's the

58
00:03:59,148 --> 00:04:02,634
love? So I would say that there are two main things that

59
00:04:02,672 --> 00:04:05,946
affect this relationship. On the left, the afterthought effect, and on

60
00:04:05,968 --> 00:04:09,034
the right, the univ effect. Let's start from the afterthought effect.

61
00:04:09,152 --> 00:04:12,622
So this illustration shows a daily stand up. And I actually

62
00:04:12,676 --> 00:04:16,046
remember myself participating in

63
00:04:16,068 --> 00:04:19,518
a daily and saying the following. I've finished, okay, the feature is

64
00:04:19,604 --> 00:04:23,418
working because I've tested it in some way, but now I have only tests

65
00:04:23,434 --> 00:04:26,580
left, left to right. And you probably can relate. Okay?

66
00:04:27,670 --> 00:04:30,958
When I think about it today, it's actually pretty absurd.

67
00:04:31,054 --> 00:04:33,950
Why? Because it makes me a bit angry.

68
00:04:34,110 --> 00:04:37,506
Why? Because usually when I write tests, after I write the code,

69
00:04:37,608 --> 00:04:41,286
two things happen. First, I need to rework my code. Perhaps I

70
00:04:41,308 --> 00:04:45,030
discovered that the code is not that testable, that I've missed some of the things,

71
00:04:45,100 --> 00:04:48,754
okay? And I need to rework on something that I actually already know that it's

72
00:04:48,802 --> 00:04:52,634
working. Second thing that happens when I write the test after the

73
00:04:52,672 --> 00:04:56,566
code. So the test code actually becomes a second class citizen,

74
00:04:56,758 --> 00:05:00,314
which means that I treat it not as good as

75
00:05:00,352 --> 00:05:04,026
I treat the production code, okay? I do not adhere

76
00:05:04,058 --> 00:05:07,534
to design principle. The code is not very clean and the code

77
00:05:07,572 --> 00:05:11,022
becomes not maintainable. Now, if the test

78
00:05:11,076 --> 00:05:14,462
code is hard to maintain and hard to develop on top of,

79
00:05:14,516 --> 00:05:18,466
so my entire code base actually becomes this way. Okay? So this

80
00:05:18,488 --> 00:05:22,718
is a very important point. The test code should not be a second cases citizen.

81
00:05:22,894 --> 00:05:26,702
Another thing that the afterthought effect causes is the following diagram.

82
00:05:26,766 --> 00:05:29,826
Okay? We are always stressed

83
00:05:29,858 --> 00:05:34,114
out, right? We always need to deliver more and more value. We always encounter

84
00:05:34,162 --> 00:05:38,258
bugs that we need to fix and we always need to attend many different aspects

85
00:05:38,274 --> 00:05:41,666
of the application. Right? Now, sometimes we are so stressed

86
00:05:41,698 --> 00:05:44,762
out that we actually say, you know what, we don't have time to test,

87
00:05:44,816 --> 00:05:48,042
okay? We have to deliver something we don't have time to test. By the way,

88
00:05:48,096 --> 00:05:51,482
even if testing is part of the definition of done, sometimes the hard

89
00:05:51,536 --> 00:05:54,926
deadline is stronger, okay? Now, having no time to

90
00:05:54,948 --> 00:05:58,314
test has its effects, right? It causes software

91
00:05:58,362 --> 00:06:01,726
defects. If I do not test my software, I probably am missing something,

92
00:06:01,828 --> 00:06:05,806
right? And these defects actually cause a

93
00:06:05,828 --> 00:06:09,726
direct link to load and stress, okay? And this is a very vicious

94
00:06:09,758 --> 00:06:12,946
cycle and I want to avoid it in some way. Now, another thing that it

95
00:06:12,968 --> 00:06:16,342
causes if my test suite is incomplete because I don't have time to test

96
00:06:16,396 --> 00:06:20,834
from time to time, so my trust in the test suite actually decreases.

97
00:06:20,962 --> 00:06:24,520
Okay? Now let's talk about the unit effect. Now, the unit effect

98
00:06:26,010 --> 00:06:29,222
has its own downside. Now, when people are asked,

99
00:06:29,276 --> 00:06:32,666
what are unit tests? So they usually say, we need to test for unit of

100
00:06:32,688 --> 00:06:36,086
code, the smallest units of code possible, such as a function, a module,

101
00:06:36,198 --> 00:06:39,334
class, whatever, okay? And if a discussion cases.

102
00:06:39,382 --> 00:06:42,954
So usually people talk about the testing pyramid that you probably know.

103
00:06:43,072 --> 00:06:46,222
And this testing pyramid is a bit problematic because

104
00:06:46,276 --> 00:06:49,406
it says several things. First of all, as you can see in the base of

105
00:06:49,428 --> 00:06:53,054
the pyramid, we have unit test, right? So it means that according to

106
00:06:53,092 --> 00:06:56,506
this arrow here, we actually need to have lots

107
00:06:56,538 --> 00:06:59,966
and lots and lots and lots of unit tests to test for small units

108
00:06:59,998 --> 00:07:03,618
of code, okay? Another thing that we can see from the error on the

109
00:07:03,624 --> 00:07:07,426
right, we need to test these units of code in isolation,

110
00:07:07,538 --> 00:07:12,130
okay? Now it looks okay, but it actually adds

111
00:07:12,210 --> 00:07:15,798
like four other angry emojis to the picture. And I want to

112
00:07:15,804 --> 00:07:19,558
talk about them first. If I need to test lots of units of

113
00:07:19,564 --> 00:07:23,494
code in isolation, I need to spend lots of my time in writing mock

114
00:07:23,542 --> 00:07:27,014
objects, right? Because this is the way that we can isolate. And nobody

115
00:07:27,062 --> 00:07:30,862
likes to spend lots of time writing mock objects, right? They are not real.

116
00:07:30,996 --> 00:07:34,334
Second thing, the quantity of

117
00:07:34,372 --> 00:07:38,206
test rises. Imagine a complex application that has lots of

118
00:07:38,228 --> 00:07:41,774
modules and lots of functions and perhaps lots of classes. It doesn't matter,

119
00:07:41,812 --> 00:07:45,226
okay? If we need to test for every piece of code,

120
00:07:45,348 --> 00:07:48,654
so the quantity of test becomes really massive.

121
00:07:48,782 --> 00:07:52,718
Now the problem with quantity of test that is massive. The testing

122
00:07:52,734 --> 00:07:56,226
for each unit of code is that if I want to refactor my code for

123
00:07:56,248 --> 00:07:59,478
some reason, and I always want to refactor my code in order to adhere to

124
00:07:59,484 --> 00:08:02,726
a better design, in order to meet a new requirement, it doesn't matter.

125
00:08:02,828 --> 00:08:06,326
So refactoring becomes something which is known as refactoring hell.

126
00:08:06,428 --> 00:08:10,566
Okay, we can be in two different scenarios. Okay, we can

127
00:08:10,748 --> 00:08:13,946
say that, okay, we need to change the system. So we need to refactor the

128
00:08:13,968 --> 00:08:17,446
code in order to better meet the requires. I can say the following.

129
00:08:17,478 --> 00:08:20,106
I can say, you know what? I'm going to refactor my code and everything is

130
00:08:20,128 --> 00:08:23,306
going to be okay because I have a safety net of tests that this

131
00:08:23,328 --> 00:08:26,686
is a great place to be in. The second scenario can be,

132
00:08:26,868 --> 00:08:30,462
you know what, there's no way that I'm refactoring my code

133
00:08:30,516 --> 00:08:33,754
because I'm going to have to change about three or 400 tests,

134
00:08:33,802 --> 00:08:37,442
okay? And of course, this is not the place that we want to be in.

135
00:08:37,496 --> 00:08:41,330
Okay? Now, another problem with unit tests and with treating,

136
00:08:43,190 --> 00:08:46,946
when testing for small units of code, when the test is very aware of

137
00:08:46,968 --> 00:08:50,558
the code structure, is that actually the unit

138
00:08:50,574 --> 00:08:54,102
test might pass and we can be very happy with it. But sometimes

139
00:08:54,156 --> 00:08:57,858
when we integrate the system, so things start to break because everybody knows

140
00:08:57,874 --> 00:09:00,780
that integrations are pretty painful, right?

141
00:09:01,150 --> 00:09:04,858
So this gives me actually another decrease in my trust

142
00:09:04,944 --> 00:09:08,854
in the entire test suite. So I would say that these all angry emojis.

143
00:09:08,902 --> 00:09:12,666
Here are some of the main reasons the developers actually don't

144
00:09:12,698 --> 00:09:16,014
like writing tests. So comes along

145
00:09:16,132 --> 00:09:19,326
Kent back about 20 years ago or more and

146
00:09:19,348 --> 00:09:22,786
says, you know what? There are actually two simple rules in order to solve that

147
00:09:22,808 --> 00:09:26,574
problem. First, you write new code only if an automated test had failed.

148
00:09:26,702 --> 00:09:29,614
Okay? And second, eliminate duplication.

149
00:09:29,662 --> 00:09:32,402
Refactor the code if needed, before you continue.

150
00:09:32,536 --> 00:09:36,126
Okay? He illustrates this mantra,

151
00:09:36,238 --> 00:09:40,230
which is the red green refactor mantra that we can see here. And red

152
00:09:40,300 --> 00:09:43,686
is saying, you know what? When you start to develop something. So please write an

153
00:09:43,708 --> 00:09:47,766
example. Okay? Write a test that failed or even doesn't compile green.

154
00:09:47,868 --> 00:09:51,238
Make only enough code for it to pass. Okay? Committing, by the

155
00:09:51,244 --> 00:09:54,406
way, all the scenes necessary on the process. Green is not the phase

156
00:09:54,438 --> 00:09:58,058
where I think about the best design or the best code that I can after

157
00:09:58,144 --> 00:10:01,354
the test is green, so I can refactor my code. This is where I think

158
00:10:01,392 --> 00:10:04,446
about the best design. I refactor my code. I run the test again to see

159
00:10:04,468 --> 00:10:07,998
that I'm still green. Okay? And there's a logic behind this circle, okay?

160
00:10:08,084 --> 00:10:10,640
I want to provide an example to what I'm about to develop.

161
00:10:11,650 --> 00:10:14,846
Then I make it pass because it's really hard to imagine what

162
00:10:14,868 --> 00:10:18,170
would be the best code to meet the problem. I want to think about the

163
00:10:18,180 --> 00:10:21,266
algorithm and about the thing that I need in order to solve the problem.

164
00:10:21,368 --> 00:10:24,754
And when the code is already written, then I want to try and think about

165
00:10:24,792 --> 00:10:28,386
it. Okay? This actually works much better. Okay? So when

166
00:10:28,408 --> 00:10:31,334
I refactor my code on the last phase, so this is where I think about

167
00:10:31,372 --> 00:10:34,950
the best design. I refactor it, and if I went from green to green,

168
00:10:35,020 --> 00:10:38,390
so I know that I should be good. Okay, great.

169
00:10:38,460 --> 00:10:42,780
So I want to add three additional things to that. Okay? First of all,

170
00:10:43,550 --> 00:10:47,722
a unit should be treated as a business flow, okay? The test should not

171
00:10:47,776 --> 00:10:51,274
care about the structure of code. This is very, very important.

172
00:10:51,392 --> 00:10:55,086
Okay? If the test doesn't know about the structure of code, the code can

173
00:10:55,108 --> 00:10:58,590
be refactored as much as we want, and we always want to

174
00:10:58,660 --> 00:11:02,734
be able to refactor our code, okay? A mock object is

175
00:11:02,772 --> 00:11:05,518
only for external boundaries of the application. This is very important.

176
00:11:05,604 --> 00:11:09,154
Okay? There is no rule of unit testing and then isolating everything.

177
00:11:09,272 --> 00:11:13,166
The rule only says that I want to have valuable tests that I can easily

178
00:11:13,278 --> 00:11:16,686
run and set up, okay? So if I want to mock something, it should be

179
00:11:16,728 --> 00:11:20,518
an external boundary of the application, and there are also rules for that. Okay?

180
00:11:20,684 --> 00:11:24,226
What are external boundaries? Databases, I o devices,

181
00:11:24,338 --> 00:11:27,702
streams, other services. It doesn't matter. Okay. But I never

182
00:11:27,756 --> 00:11:31,106
try to mock an internal layer of my application. Okay?

183
00:11:31,228 --> 00:11:35,514
And that's important. Last thing. Last rule, which is super important.

184
00:11:35,632 --> 00:11:39,194
The test code is as important as production code, and this

185
00:11:39,232 --> 00:11:43,390
requires some shift of mindset for many, many people. Many people tend to

186
00:11:43,540 --> 00:11:47,114
allow many, like, code scenes to appear

187
00:11:47,162 --> 00:11:50,910
because it's test code and it doesn't matter. Okay? But when the test

188
00:11:50,980 --> 00:11:54,154
suite becomes something which is very hard to maintain,

189
00:11:54,202 --> 00:11:57,678
hard to understand, and hard to develop on top of, so practically

190
00:11:57,774 --> 00:12:01,042
the entire code base becomes the same. Okay? So tests code

191
00:12:01,096 --> 00:12:04,594
is as important as production code. And I apply every rule I know

192
00:12:04,632 --> 00:12:08,438
about design or clean code and everything that I know on the test code

193
00:12:08,524 --> 00:12:11,240
as well as production code. Okay?

194
00:12:11,770 --> 00:12:15,638
Now, ive talked about TDD. Now, in order to

195
00:12:15,724 --> 00:12:19,446
demonstrate TDD, I want to do a

196
00:12:19,468 --> 00:12:22,938
code kata. So if you're not familiar with the term kata, kata is a

197
00:12:22,944 --> 00:12:25,786
word from Japanese which means form.

198
00:12:25,888 --> 00:12:29,482
Now, if some of you have been practicing martial Arts or seen

199
00:12:29,536 --> 00:12:32,986
movies, so it's actually from there, okay? So a

200
00:12:33,008 --> 00:12:36,350
kata is a sequence of movement that a martial artist does

201
00:12:36,420 --> 00:12:40,094
over and over and over again. And the idea is that you're doing

202
00:12:40,132 --> 00:12:43,386
something over and over again until it becomes part of your muscle memory,

203
00:12:43,498 --> 00:12:47,682
okay? And then, of course, if the real thing

204
00:12:47,736 --> 00:12:50,926
will happen one day, so your body will know how to react.

205
00:12:51,118 --> 00:12:54,354
So came along Dave Thomas and took

206
00:12:54,392 --> 00:12:57,874
this idea to the programming world. And he called it

207
00:12:57,912 --> 00:13:01,366
a codecata. So what's a codecata? A codecata is a

208
00:13:01,388 --> 00:13:04,582
programming exercise, not that difficult that everybody

209
00:13:04,636 --> 00:13:07,938
with some experience can solve. And the idea is to practice some techniques.

210
00:13:07,954 --> 00:13:10,966
So there are cutters for TDD, and there are cutters for refactoring, and there are

211
00:13:10,988 --> 00:13:14,758
cutters for design patterns, and there are cutters for introducing new features

212
00:13:14,774 --> 00:13:17,914
or new languages or stuff like that. And today I want to do a very

213
00:13:17,952 --> 00:13:21,414
famous kata, which is called the bowling cutter, which was introduced

214
00:13:21,462 --> 00:13:25,126
by Bob Martin. So the bowling

215
00:13:25,238 --> 00:13:29,114
kata is a cutter that actually tells us, please solve

216
00:13:29,242 --> 00:13:32,686
an exercise that will know how to calculate the result of a

217
00:13:32,708 --> 00:13:36,606
bowling game. Okay, now, for those who are not familiar with bowling,

218
00:13:36,718 --> 00:13:40,114
I'm going to introduce the rules very quickly, of course, if you need to,

219
00:13:40,152 --> 00:13:43,378
please refresh. Okay, so what's a bowling game? So a

220
00:13:43,384 --> 00:13:46,834
bowling game actually has ten frames for each player. Okay.

221
00:13:46,952 --> 00:13:50,754
And each frame has two rolls. Okay. We roll the ball actually twice.

222
00:13:50,802 --> 00:13:54,358
Okay. Now we have a very special frame, which is the last one,

223
00:13:54,444 --> 00:13:57,334
that we might have three rolls. Why? I'm going to explain in a second,

224
00:13:57,372 --> 00:14:00,406
because in the last frame, we might have a spare strike, and then we have

225
00:14:00,428 --> 00:14:03,786
an additional role in order to calculate the code. So how

226
00:14:03,808 --> 00:14:07,386
do we calculate the score? So the score of each frame is actually the

227
00:14:07,408 --> 00:14:10,714
sum of two rolls, which is pretty simple if I didn't say so.

228
00:14:10,752 --> 00:14:14,106
There are ten pins and we need to drop the pins. Okay, so the sum

229
00:14:14,138 --> 00:14:17,790
of two rolls, the sum of the pins dropped in two rolls. Great.

230
00:14:17,940 --> 00:14:21,726
Now there's a special situation which is called the spare. A spare is when

231
00:14:21,748 --> 00:14:25,502
I roll the ball twice and after two times, I've actually dropped

232
00:14:25,566 --> 00:14:29,586
all ten pins. So this is good for me. Why? Because I

233
00:14:29,608 --> 00:14:33,554
get a bonus for that frame and the bonus is calculated as

234
00:14:33,592 --> 00:14:36,962
follows. Of course it's ten because I dropped ten pins. And the bonus

235
00:14:37,026 --> 00:14:40,802
is the next roll. I mean, the pins that were dropped

236
00:14:40,866 --> 00:14:44,342
in the next roll. Great. Another special case

237
00:14:44,396 --> 00:14:47,746
is a strike. Strike means that I took the ball,

238
00:14:47,778 --> 00:14:51,358
I rolled it. Okay. And in the first go, I've actually managed

239
00:14:51,394 --> 00:14:55,226
to dropped all ten pins. Okay, so that's great. And the bonus for that

240
00:14:55,248 --> 00:14:59,222
is even bigger. So how do I calculate the score for a strike?

241
00:14:59,286 --> 00:15:02,934
It's actually ten plus the two next rolls.

242
00:15:03,062 --> 00:15:06,218
And the two next rolls doesn't have to be in the same frame. If I've

243
00:15:06,234 --> 00:15:09,018
done a strike and then another strike and another strike.

244
00:15:09,114 --> 00:15:13,086
So the result for the first one, the score for the first strike

245
00:15:13,118 --> 00:15:16,594
would be 30. Right? Because it's ten plus ten. Plus ten.

246
00:15:16,792 --> 00:15:21,762
Great. Now the maximum roles in the game are

247
00:15:21,816 --> 00:15:25,378
21 because 20 is

248
00:15:25,464 --> 00:15:29,254
two times ten. Right? And I have an additional role in

249
00:15:29,292 --> 00:15:32,646
the 10th frame if ive done a

250
00:15:32,668 --> 00:15:35,954
sparrow strike or something like that. And the minimum would be eleven.

251
00:15:36,082 --> 00:15:40,374
Why? Because imagine a game that I've rolled the balls nine

252
00:15:40,412 --> 00:15:43,738
times, nine frames, and I've done a strike, okay? And let's imagine that in

253
00:15:43,744 --> 00:15:47,434
the last frame I've actually missed twice, okay? So whenever I do a

254
00:15:47,472 --> 00:15:50,826
strike in the frame, I don't have an additional roll because I've already managed to

255
00:15:50,848 --> 00:15:54,220
pin to drop all ten pins. Okay?

256
00:15:54,750 --> 00:15:58,398
And the maximum score of a game, of course, is 300. Why? Because in

257
00:15:58,404 --> 00:16:01,806
the example that I just gave, if I'm doing strike and strike and strike and

258
00:16:01,828 --> 00:16:05,102
strike over and over again, so eventually it will be

259
00:16:05,236 --> 00:16:08,686
30 times ten, which is 300. Okay? And the minimum

260
00:16:08,718 --> 00:16:11,918
score is of course zero. Right? Because I've rolled

261
00:16:11,934 --> 00:16:14,580
the ball and I've missed every single time.

262
00:16:15,190 --> 00:16:18,698
Okay, great. Now I hope that you're

263
00:16:18,734 --> 00:16:21,494
starting to think about it. I mean, start to think if you would need to

264
00:16:21,532 --> 00:16:24,774
implement it. I mean, how would you implement it? Okay,

265
00:16:24,972 --> 00:16:28,546
and let us start. So our requirement is actually

266
00:16:28,588 --> 00:16:31,866
to have two APIs, okay? One API would

267
00:16:31,888 --> 00:16:35,862
be to have a role method

268
00:16:35,926 --> 00:16:39,434
which gets the number of pins. So every time the number of pins is

269
00:16:39,472 --> 00:16:42,550
dropped. So the role method will be called with the number of pins that were

270
00:16:42,560 --> 00:16:46,314
dropped. And another one would be. Another API would be the score

271
00:16:46,362 --> 00:16:49,566
method. And the code is actually being called only in the

272
00:16:49,588 --> 00:16:53,086
end of the game. Okay, this is to

273
00:16:53,108 --> 00:16:56,146
make the cut a bit easier. I don't need to know the score all the

274
00:16:56,168 --> 00:16:59,234
time. Only in the end of the game, someone will call the score API and

275
00:16:59,272 --> 00:17:03,362
will ask me to calculate coding to the roles that

276
00:17:03,416 --> 00:17:07,118
were taken before. Okay? Now we're

277
00:17:07,134 --> 00:17:10,774
not going to deal with turns like whose turn is it? And stuff like that.

278
00:17:10,812 --> 00:17:14,200
Imagine if we have a module per player or something like that. Okay?

279
00:17:14,810 --> 00:17:17,720
So let's go to the ide and start.

280
00:17:19,150 --> 00:17:23,270
Now, I want to do it using TDD

281
00:17:23,430 --> 00:17:27,270
because I think the TDD actually cancel

282
00:17:27,430 --> 00:17:31,210
the afterthought effect, which we talked about in the presentation.

283
00:17:31,710 --> 00:17:35,386
And also when I'm doing TDD and I'm thinking about business flow,

284
00:17:35,418 --> 00:17:38,894
so it almost terminates the unit effect as well.

285
00:17:39,012 --> 00:17:42,686
And I want to demonstrate how I do it. Okay, so I

286
00:17:42,708 --> 00:17:46,398
have a project here. This project is pretty empty. It only has some configuration

287
00:17:46,494 --> 00:17:48,740
for running tests using jest. Okay,

288
00:17:49,670 --> 00:17:53,586
so let us begin. So the first test would be

289
00:17:53,688 --> 00:17:57,042
what? So that's always something to think about.

290
00:17:57,096 --> 00:18:00,390
I mean, the first test in TDD needs to describe something very

291
00:18:00,460 --> 00:18:03,766
easy, right? I don't have any code written yet. Okay. So I

292
00:18:03,788 --> 00:18:07,510
don't want to take the hardest scenario possible because

293
00:18:07,580 --> 00:18:10,426
then I will need to implement lots of code in order to adhere to it.

294
00:18:10,448 --> 00:18:14,182
Right. So I always try to choose the simplest scenario

295
00:18:14,246 --> 00:18:17,274
possible that I can solve pretty quickly.

296
00:18:17,392 --> 00:18:20,634
Okay, so what would be the most

297
00:18:20,672 --> 00:18:23,566
simple scenario that we can think about in bowling? So in bowling, it would be

298
00:18:23,588 --> 00:18:27,518
pretty simple, right. If every player everywhere would always miss,

299
00:18:27,604 --> 00:18:30,942
always throw the ball into the gutter. So the score would always be

300
00:18:31,076 --> 00:18:34,446
zero. Right. So let's do that. And as you can see, I'm not

301
00:18:34,468 --> 00:18:37,746
testing for methods or for stuff like that. I don't have the structure of the

302
00:18:37,768 --> 00:18:41,026
code yet. I am testing for business flows. So I

303
00:18:41,048 --> 00:18:44,930
would say that it should score zero when playing

304
00:18:45,370 --> 00:18:47,000
a gutter game.

305
00:18:48,410 --> 00:18:51,462
Great. So what do I do first? I say Const.

306
00:18:51,516 --> 00:18:54,710
Bowling equals require.

307
00:18:55,370 --> 00:18:59,234
And I'm going to require bowling. Now, it doesn't exist

308
00:18:59,282 --> 00:19:03,178
yet, so it's a bit strange, right? But still,

309
00:19:03,264 --> 00:19:07,094
this is, TDD also promotes something which is called outside in programming,

310
00:19:07,142 --> 00:19:10,634
meaning I imagine that I have something and then I create it. It has many,

311
00:19:10,672 --> 00:19:14,414
many benefits and one of them is the fact that the code

312
00:19:14,452 --> 00:19:17,786
becomes much more usable because the test is already using it. So it doesn't

313
00:19:17,818 --> 00:19:22,080
exist. I create it. Great, let's go back here.

314
00:19:22,390 --> 00:19:26,434
And now I want to say, okay, so let's run a for

315
00:19:26,472 --> 00:19:31,170
loop 20 times and let's do bowling role.

316
00:19:31,990 --> 00:19:35,726
And roll zero, right? This is one of the APIs. Now, red green refactor

317
00:19:35,758 --> 00:19:39,142
means that if something doesn't exist or doesn't work, we can see this quickly line

318
00:19:39,196 --> 00:19:42,966
here. So I need to create it. So I'm now in red and I want

319
00:19:42,988 --> 00:19:46,246
to create it. So create method role, which tests the numbers of

320
00:19:46,268 --> 00:19:49,030
pins, sorry, pins.

321
00:19:49,610 --> 00:19:52,634
Okay, now I want to split my screen into two so

322
00:19:52,672 --> 00:19:56,166
it will be convenient for us to see. So on the right I'm

323
00:19:56,198 --> 00:19:59,242
going to have my production code. On the left I'm going to have my tests

324
00:19:59,296 --> 00:20:02,394
code. Okay, so let's start from

325
00:20:02,432 --> 00:20:06,026
here. Now what do I want to do? I want to say, okay, so let's

326
00:20:06,058 --> 00:20:09,726
expect that if someone cases bowling score in the end

327
00:20:09,748 --> 00:20:13,620
of the game, so the score should be zero.

328
00:20:14,550 --> 00:20:17,780
Okay, now score doesn't exist, so let's create it.

329
00:20:18,790 --> 00:20:21,906
So let's create it. That's great. And let's run the

330
00:20:21,928 --> 00:20:25,330
test. So TDD is saying, okay, provide an example

331
00:20:25,400 --> 00:20:28,994
for something, right? Perhaps it will not work or doesn't compile

332
00:20:29,042 --> 00:20:31,686
and then run it. See that you're in red. And then we're going to make

333
00:20:31,708 --> 00:20:34,120
it cases. So let's see what's happening here.

334
00:20:39,050 --> 00:20:42,666
It takes some time. Okay,

335
00:20:42,768 --> 00:20:46,266
so it didn't work. Why? Because expected zero, right? I expect it

336
00:20:46,288 --> 00:20:49,562
to be zero and received undefined. So this is pretty clear, right? Because I return

337
00:20:49,616 --> 00:20:52,666
undefined here. So of course it doesn't work. Now, what's the fastest thing I can

338
00:20:52,688 --> 00:20:56,046
do in order to solve it? Okay. Without thinking about anything. So the

339
00:20:56,068 --> 00:20:59,600
fastest thing to do would be returning zero. Let's run the test

340
00:20:59,970 --> 00:21:03,166
now, you probably think that now, okay, but this

341
00:21:03,188 --> 00:21:06,014
is pretty silly. Okay. Of course, if you return Zero and you expect zero,

342
00:21:06,052 --> 00:21:09,406
it will work. But you didn't do anything. So I agree. And TDD

343
00:21:09,438 --> 00:21:12,734
also agrees. But TDD also says, you know what, if it's

344
00:21:12,782 --> 00:21:16,370
so silly. So let's provide an example to why return zero

345
00:21:16,440 --> 00:21:19,686
is not enough. Okay, and how do we provide an example? We actually write

346
00:21:19,708 --> 00:21:22,920
an additional test. So let's write an additional tests.

347
00:21:23,370 --> 00:21:26,626
So this was very simple when playing a gutter game. So let's increase

348
00:21:26,658 --> 00:21:30,300
complexity just a bit. So I would say that it should score 20

349
00:21:30,910 --> 00:21:34,140
when I'm playing a game with all ones.

350
00:21:35,390 --> 00:21:38,762
A game with all ones. Now,

351
00:21:38,816 --> 00:21:41,814
imagine that I've rolled the ball and each time ive dropped one pin.

352
00:21:41,862 --> 00:21:45,306
So of course the code would be 20. This is very simple. So let's

353
00:21:45,338 --> 00:21:49,582
do that. So if I've rolled once and expected would be 20,

354
00:21:49,716 --> 00:21:53,042
of course I'll run the tests and they will fail, right? Because I return

355
00:21:53,096 --> 00:21:56,846
hard code zero here. So let's

356
00:21:56,878 --> 00:22:00,306
try to make them pass. So first thing

357
00:22:00,328 --> 00:22:03,358
that comes in mind. Okay, let's create a variable.

358
00:22:03,454 --> 00:22:06,946
Let's call it current score. And it will

359
00:22:06,968 --> 00:22:10,582
be zero. Now, whenever someone cases code, let's return

360
00:22:10,636 --> 00:22:14,626
current score. And whenever someone calls roles, so let's calculate

361
00:22:14,658 --> 00:22:18,290
current score. So I would say current score plus equals the number of pins,

362
00:22:18,450 --> 00:22:22,106
right? And I want to change the order of the method because the

363
00:22:22,128 --> 00:22:25,066
role is called before score, and it's better for me to look at it this

364
00:22:25,088 --> 00:22:28,060
way. Okay, let's run the test.

365
00:22:34,290 --> 00:22:37,806
So I think that's going to work. But I'm starting to think that I

366
00:22:37,828 --> 00:22:41,502
might have an additional problem here. Okay, so the tests are green,

367
00:22:41,556 --> 00:22:44,638
which is good. But do you remember that I told you that I don't want

368
00:22:44,644 --> 00:22:48,206
to handle with turns of different people, right? I want to have a module

369
00:22:48,238 --> 00:22:51,618
per player or something like that. And currently, because this

370
00:22:51,624 --> 00:22:54,786
is a module, so it exists only once in memory. So if I'll write an

371
00:22:54,808 --> 00:22:59,030
additional test here. And I'll probably do something like

372
00:22:59,180 --> 00:23:03,240
that and say, you know what, let's see if it works again.

373
00:23:04,570 --> 00:23:08,182
So I'm guessing it will fail, right, because it's already in memory count score after

374
00:23:08,236 --> 00:23:11,654
this game would be 20 and here it should be 40.

375
00:23:11,772 --> 00:23:14,698
So I'm not sure this design is actually good enough for me because I want

376
00:23:14,704 --> 00:23:18,150
to be able to create this kind of module per player.

377
00:23:18,230 --> 00:23:21,454
Okay. Yeah. So that's not good enough. So I want to go back to

378
00:23:21,492 --> 00:23:25,022
green. Okay, let's run the test and I want to make a change.

379
00:23:25,076 --> 00:23:28,366
Okay. So instead of using a module here, I will actually use

380
00:23:28,388 --> 00:23:29,120
a class.

381
00:23:32,130 --> 00:23:34,530
So let's do that. So class bowling,

382
00:23:35,350 --> 00:23:38,626
okay. Class bowling would have what?

383
00:23:38,728 --> 00:23:42,242
It would have a constructor and in the constructor I would have

384
00:23:42,296 --> 00:23:45,814
this current code which

385
00:23:45,932 --> 00:23:49,254
will be zero. Great. Now I'm going to take these two

386
00:23:49,292 --> 00:23:51,160
function inside the class.

387
00:23:54,410 --> 00:23:57,878
Great. And now of course I don't need the syntax of export function.

388
00:23:58,044 --> 00:24:00,700
And I don't need this syntax of export function.

389
00:24:01,230 --> 00:24:04,780
Great. And I actually don't need this let current score as well.

390
00:24:05,230 --> 00:24:08,954
And I do need to do this current

391
00:24:08,992 --> 00:24:12,622
score here. Right. And this current

392
00:24:12,676 --> 00:24:13,600
score here.

393
00:24:15,650 --> 00:24:19,134
Great. And I need to export the

394
00:24:19,172 --> 00:24:21,950
module. So module export will be bowling.

395
00:24:22,770 --> 00:24:26,014
And that's about it here. So this is kind of refactoring. But it's not only

396
00:24:26,052 --> 00:24:29,586
refactoring because I'm changing a bit of behavior right now. I'm going to instantiate this

397
00:24:29,608 --> 00:24:33,278
one and not only have it as a module, but still it's

398
00:24:33,294 --> 00:24:36,658
the same behavior. So let's see. So here instead

399
00:24:36,744 --> 00:24:40,920
of doing this requires, let's take this outside and let's change the

400
00:24:41,450 --> 00:24:44,534
capital b. And I'm going to say, you know what,

401
00:24:44,572 --> 00:24:48,346
let's let a bowling variable and let's create a before

402
00:24:48,528 --> 00:24:52,026
each method, okay, the before each method is a method that

403
00:24:52,048 --> 00:24:55,546
actually runs before each test. Okay. And before each

404
00:24:55,568 --> 00:24:59,290
test I'm going to do bowling equals new bowling.

405
00:25:00,450 --> 00:25:03,920
Okay. And now I don't need this bowling as well here.

406
00:25:04,690 --> 00:25:07,680
And let's run the test to see if it's working now.

407
00:25:11,730 --> 00:25:15,546
So I've done some refactoring here. So this is the idea of red green refactor.

408
00:25:15,578 --> 00:25:18,706
I already have some code. I see some problem or something

409
00:25:18,728 --> 00:25:22,306
that I don't like. I refactor it and see that it is still working.

410
00:25:22,408 --> 00:25:25,970
So of course it's not working because yeast is not defined

411
00:25:26,130 --> 00:25:29,800
naturally. Okay, sorry for that. Let's run it again.

412
00:25:36,730 --> 00:25:40,220
It and once we're green, we know we're good to go.

413
00:25:41,790 --> 00:25:44,874
Great. So we're green and we're good to go. So this is actually much better

414
00:25:44,912 --> 00:25:48,746
for me. So red, green and refactor. So now I

415
00:25:48,768 --> 00:25:52,730
should be refactoring, but I've already refactored my code. But that's a very important

416
00:25:52,800 --> 00:25:56,574
point in TDD in the realm that we are living. So test

417
00:25:56,612 --> 00:26:00,506
code is as important as production code, meaning whenever I'm doing refactoring,

418
00:26:00,618 --> 00:26:04,206
it also goes to the test code. Okay? So I look at

419
00:26:04,228 --> 00:26:07,970
the test code and I think how can I improve it? And actually I can,

420
00:26:08,040 --> 00:26:11,106
right? Because this piece of code here is

421
00:26:11,128 --> 00:26:13,890
actually duplicated for this piece of code. It looks exactly the same,

422
00:26:13,960 --> 00:26:17,906
right? So I want to extract it into a function and use the

423
00:26:17,928 --> 00:26:21,046
function, but I have some hard coded values here. So I'm going to do it

424
00:26:21,068 --> 00:26:24,658
in two phases. First of all, I'm going to extract this 20 here and I'm

425
00:26:24,674 --> 00:26:28,726
going to call it roles. I'm going to take this zero here, extract it

426
00:26:28,748 --> 00:26:32,106
to a variable. I'm going to call it pins and extract it

427
00:26:32,128 --> 00:26:35,130
out. Now I'm going to extract this into a method, okay.

428
00:26:35,280 --> 00:26:39,034
And the method is going to be

429
00:26:39,232 --> 00:26:42,806
role many. Okay, it's a helper

430
00:26:42,838 --> 00:26:46,634
method, the test method. Now I actually don't need these variables, the roles

431
00:26:46,682 --> 00:26:49,966
and pins, okay? I've just used them in order to help the ide help me

432
00:26:49,988 --> 00:26:53,070
to do better refactoring. So I'm going to inline them back,

433
00:26:53,140 --> 00:26:56,318
okay. I'm going to inline them back and I don't need them. And now I'm

434
00:26:56,334 --> 00:26:59,666
going to take this line and I'm also going to invoke it in this test.

435
00:26:59,768 --> 00:27:03,422
By the way, this version of Webstorm doesn't

436
00:27:03,486 --> 00:27:06,854
recognize code application replace them by their own. But they have actually

437
00:27:06,892 --> 00:27:10,694
promised that they will fix it soon. So I hope it will come soon.

438
00:27:10,892 --> 00:27:13,160
Great. Let's run the test again.

439
00:27:16,490 --> 00:27:19,670
Okay, let's wait. It takes a bit of time. Great.

440
00:27:19,740 --> 00:27:22,958
We should be good. Finally we can continue. So we've

441
00:27:22,994 --> 00:27:26,314
tested for a gutter game. We've tested for a game with all ones.

442
00:27:26,352 --> 00:27:29,526
So what could be the next scenario? So as you can see, I'm not testing

443
00:27:29,558 --> 00:27:33,134
full structure of code. Okay. So I would say that maybe

444
00:27:33,172 --> 00:27:37,306
we could continue and test a game that has only one spell.

445
00:27:37,498 --> 00:27:42,914
So it should actually calculate the

446
00:27:42,952 --> 00:27:47,380
score correctly when

447
00:27:49,670 --> 00:27:53,506
with one spell. Great. So how

448
00:27:53,528 --> 00:27:58,950
do I simulate a spare? I do the following, I would say bowling roll.

449
00:27:59,850 --> 00:28:02,870
And I want to roll, for example a seven. Okay.

450
00:28:03,020 --> 00:28:06,086
And then I want to roll a three. Right. That would be a

451
00:28:06,108 --> 00:28:09,994
spare because I've reached ten. And then let's roll an

452
00:28:10,032 --> 00:28:13,526
additional three so I can actually calculate the spare bonus.

453
00:28:13,558 --> 00:28:16,954
I remind you that the spare bonus is ten plus the next roll. Okay,

454
00:28:17,152 --> 00:28:20,886
so I have 17 rolls

455
00:28:20,918 --> 00:28:24,142
left to throw. I'm going to roll zero in all of them to make it

456
00:28:24,196 --> 00:28:27,866
simple. Now, what's the expected score? So let's calculate.

457
00:28:27,898 --> 00:28:31,166
Okay, so for the first frame, I would get ten plus bonus, which is ten

458
00:28:31,188 --> 00:28:34,846
plus 313. For the second frame, I will have this three,

459
00:28:34,948 --> 00:28:38,382
and of course, a zero that comes from here. So it's 13

460
00:28:38,446 --> 00:28:41,906
plus three, which is 16. Okay. Try to calculate for

461
00:28:41,928 --> 00:28:45,042
yourself before I explain it. It will help you see that you actually understand

462
00:28:45,096 --> 00:28:48,994
the rules of the game. Great. Now will

463
00:28:49,032 --> 00:28:52,034
that work? Of course it doesn't work. Okay, I'll run it in the background.

464
00:28:52,082 --> 00:28:55,558
But it doesn't work, right? I mean, I don't have any ability to calculate the

465
00:28:55,564 --> 00:28:59,062
spare bonus because I don't know what is the next role in my current

466
00:28:59,116 --> 00:29:02,418
implementation. An additional thing that actually bugs me

467
00:29:02,444 --> 00:29:05,706
here is the fact that if I look at the code, I'm not sure that

468
00:29:05,728 --> 00:29:09,226
it's very good. I mean, I have a role method, a role function

469
00:29:09,408 --> 00:29:13,158
that what it does, it actually calculates the score. So I'm not sure

470
00:29:13,184 --> 00:29:16,782
this name is very good for the method. And I also have

471
00:29:16,836 --> 00:29:19,866
a score method which actually returns the score.

472
00:29:19,898 --> 00:29:23,086
It's kind of a getter for this current score variable. Right.

473
00:29:23,268 --> 00:29:26,654
So I'm not sure that's good enough. I want to do some refactoring

474
00:29:26,702 --> 00:29:31,170
here in order to meet the new requires, which will be calculating something

475
00:29:31,320 --> 00:29:34,722
from the next frame. Right. So before

476
00:29:34,776 --> 00:29:37,730
I do that TDD tests, you, you know what? You want to do some refactoring?

477
00:29:37,810 --> 00:29:41,750
That's great. But before you do that, please start from green.

478
00:29:41,820 --> 00:29:45,014
So I'm actually commenting out this test and I want to

479
00:29:45,052 --> 00:29:48,438
start from green because whenever I'm starting to refactor, I want

480
00:29:48,444 --> 00:29:50,886
to make sure that things are green. And okay. In this way I will know

481
00:29:50,908 --> 00:29:54,298
that my refactoring didn't break anything and that's very important. Okay,

482
00:29:54,464 --> 00:29:57,340
so now I'm green. I'm going to do this. So I'm going to say this

483
00:29:58,110 --> 00:30:01,822
rolls will be an array. Okay. And whenever someone

484
00:30:01,876 --> 00:30:05,546
is bowling something. So let's do this roll

485
00:30:05,738 --> 00:30:09,466
and let's push the number of pins that were dropped.

486
00:30:09,658 --> 00:30:13,380
Great. Now whenever I want to calculate the score, so let's create

487
00:30:13,830 --> 00:30:17,170
a local variable code and I'm going to

488
00:30:17,240 --> 00:30:19,730
iterate over my roles.

489
00:30:22,950 --> 00:30:26,274
Great. And now I'm going to do score

490
00:30:26,322 --> 00:30:29,720
plus equals roles in I.

491
00:30:30,570 --> 00:30:33,602
This should work. Of course it should be this roles.

492
00:30:33,746 --> 00:30:37,078
Okay. And instead of returning current score, I'm going to

493
00:30:37,084 --> 00:30:40,454
return the local variable score. I think that

494
00:30:40,492 --> 00:30:44,266
should work. And also we keep the history and

495
00:30:44,288 --> 00:30:47,626
the future by doing this roles. Push. Great. Now I don't

496
00:30:47,648 --> 00:30:51,374
need this current score. I don't need this current score as well. Let's see if

497
00:30:51,412 --> 00:30:54,718
I didn't break anything that's important. I've started from green.

498
00:30:54,804 --> 00:30:58,400
I want to see that I'm still green. Let's see.

499
00:31:03,250 --> 00:31:06,594
Okay, great. Still green. Now I

500
00:31:06,632 --> 00:31:09,778
allow myself to put the test here again. Now it's going

501
00:31:09,784 --> 00:31:13,042
to be red. Of course I didn't do anything, but how would I implement it

502
00:31:13,096 --> 00:31:16,678
now? So the very basic thing to do would

503
00:31:16,764 --> 00:31:20,642
be, okay, so if this dot rolls

504
00:31:20,786 --> 00:31:24,662
in, I plus this dot rolls in I plus

505
00:31:24,716 --> 00:31:28,680
one. If it's already ten, so what might happen?

506
00:31:29,770 --> 00:31:33,142
So did you catch the error here? There was an error here

507
00:31:33,196 --> 00:31:36,454
actually. Right. Because I might be checking the

508
00:31:36,492 --> 00:31:39,918
second role in a specific frame and the first role in the

509
00:31:39,964 --> 00:31:43,406
next one. Okay. And this is not a spare. So this is still not

510
00:31:43,428 --> 00:31:46,574
good enough. So my design is still not good enough. I'm not sure that

511
00:31:46,612 --> 00:31:49,998
iterating over roles is the right thing to do. So whenever my design is still

512
00:31:50,004 --> 00:31:53,086
not good enough. So still I want to start from green. Okay.

513
00:31:53,268 --> 00:31:56,354
Commenting out the tests, I know that I'm green now and I want to do

514
00:31:56,392 --> 00:32:00,290
something a bit differently. I want to say, you know what, let's have another

515
00:32:00,360 --> 00:32:03,250
one, which will be the role index.

516
00:32:04,390 --> 00:32:07,854
And I want to iterate over, instead of iterating over the roles,

517
00:32:07,902 --> 00:32:11,126
I want to iterate in the context of frames. So instead of doing that,

518
00:32:11,148 --> 00:32:14,934
I'm going to iterate for ten times. Okay. And by doing

519
00:32:14,972 --> 00:32:19,030
that, I'm going to say the score should plus equals this roles in

520
00:32:19,100 --> 00:32:23,160
current role, sorry, in role index plus

521
00:32:23,530 --> 00:32:27,194
this roles in role index plus

522
00:32:27,232 --> 00:32:30,726
one. And then I'm going to take this index and increase

523
00:32:30,758 --> 00:32:33,902
it by two. And this way I know that I'm in the context of

524
00:32:33,956 --> 00:32:37,326
frames. So let's see if that's working. I want to make sure that

525
00:32:37,428 --> 00:32:40,894
I've started from green and I'm going to be green again.

526
00:32:41,012 --> 00:32:41,680
Okay.

527
00:32:44,130 --> 00:32:47,534
And then I think that now I will be able to add the functionality.

528
00:32:47,582 --> 00:32:50,418
Okay, so I'm still green. Finally adding this test.

529
00:32:50,504 --> 00:32:54,242
Okay. I will run it to see that. Of course I'm still red. Okay.

530
00:32:54,376 --> 00:32:59,174
And now I think that I know how to solve this

531
00:32:59,212 --> 00:33:03,302
challenge. So I would say, okay, I'm going to start writing while

532
00:33:03,356 --> 00:33:08,166
the test runs because I want to make sure that we're

533
00:33:08,198 --> 00:33:11,494
continuing in the correct pace. So of course it doesn't

534
00:33:11,542 --> 00:33:15,274
work. So I would say now if this dot rolls in

535
00:33:15,392 --> 00:33:19,370
all index plus, this dot rolls in

536
00:33:19,440 --> 00:33:22,846
all index plus one. And now I actually know that I'm in the

537
00:33:22,868 --> 00:33:26,798
context of the same frame, right? So if this happens,

538
00:33:26,884 --> 00:33:29,530
so score should be calculated as follows.

539
00:33:29,610 --> 00:33:33,398
It's ten plus these dot roles in roll

540
00:33:33,434 --> 00:33:37,166
index plus two. Right, because it's the next role.

541
00:33:37,358 --> 00:33:41,954
Great. Else I

542
00:33:41,992 --> 00:33:44,882
calculate it regularly. Okay.

543
00:33:44,936 --> 00:33:49,014
And either way, I need to increase the role index by

544
00:33:49,052 --> 00:33:52,120
two. Let's run the test to see if it works.

545
00:33:56,970 --> 00:34:00,614
Okay. Let's see if we're finally green. And we're finally green. Okay?

546
00:34:00,652 --> 00:34:03,898
So that makes me happy. But now let's take a

547
00:34:03,904 --> 00:34:07,206
look at the code. I mean, the code actually becomes pretty complex. So I remind

548
00:34:07,238 --> 00:34:10,140
you, red, green, refactor. So now I should refactor my code.

549
00:34:10,990 --> 00:34:14,438
This is complicated and this is complicated. And if I need to read it and

550
00:34:14,464 --> 00:34:18,014
understand what's going on, it's not that trivial. So someone would

551
00:34:18,052 --> 00:34:21,502
say, you know what, this if is very long. So you need to comment something.

552
00:34:21,556 --> 00:34:25,246
You need to said, okay? Check if this is spare.

553
00:34:25,358 --> 00:34:28,862
Right? So this is an ugly comment.

554
00:34:28,926 --> 00:34:32,254
Okay. Comments are actually not that good practice.

555
00:34:32,302 --> 00:34:36,126
Okay? We need to comment things only that we are unable to express via

556
00:34:36,158 --> 00:34:39,666
readable code. And here this is not the case. So instead of this comment,

557
00:34:39,698 --> 00:34:43,334
I would actually take this entire condition, extract it

558
00:34:43,452 --> 00:34:46,710
to its own method, and I'm going to call it is spell.

559
00:34:47,370 --> 00:34:51,158
Now it's much more readable. Right. Another thing that I'm going

560
00:34:51,164 --> 00:34:54,154
to do, I don't want to work with indices here. Okay? There's a clean code

561
00:34:54,192 --> 00:34:57,546
rule that actually says keep the same level of obstruction in your

562
00:34:57,568 --> 00:35:00,554
function. So I'm going to go here and I'm going to extract it out as

563
00:35:00,592 --> 00:35:05,066
well. And I'm going to call it this spell

564
00:35:05,178 --> 00:35:08,350
bonus. Right? This is how it's calculated.

565
00:35:08,770 --> 00:35:12,138
And again here I'm going to take this line and I'm

566
00:35:12,154 --> 00:35:16,322
going to say let's extract it out and call it sum of two

567
00:35:16,456 --> 00:35:19,460
roles. Great.

568
00:35:19,910 --> 00:35:24,174
So now actually the code is much better when I read it. It's very readable

569
00:35:24,222 --> 00:35:27,698
and very easy to understand. Great. Let's run the test to

570
00:35:27,704 --> 00:35:31,366
see that I didn't break anything. Now try to think about what would

571
00:35:31,388 --> 00:35:34,166
be the next test. Okay, if this is going to be green, I've tested for

572
00:35:34,188 --> 00:35:37,826
a gutter game. I've tested for a game with all ones. And I've actually tested

573
00:35:37,858 --> 00:35:40,650
for it with a game with one spell. So what would be the next phase?

574
00:35:41,150 --> 00:35:44,662
So I'm guessing some of you said it would be a strike.

575
00:35:44,726 --> 00:35:47,994
Okay, so let's see how we can do that.

576
00:35:48,032 --> 00:35:52,010
So it should calculate the correct the score correctly with one strike.

577
00:35:53,630 --> 00:35:57,098
Great. So how do I simulate strike? So I'm

578
00:35:57,114 --> 00:36:00,666
going to do this, right. On the first roll, I've managed to drop

579
00:36:00,698 --> 00:36:04,174
all ten pins, which is great. And now let's keep these three and three because

580
00:36:04,212 --> 00:36:07,438
I need both of them in order to have the strike bonus. I remind

581
00:36:07,454 --> 00:36:10,834
you, a strike bonus is the next two rolls. Okay.

582
00:36:11,032 --> 00:36:15,042
And then I'm going to roll a gutter game

583
00:36:15,096 --> 00:36:18,914
until the end. So how many rolls do I have left? It's actually not

584
00:36:18,952 --> 00:36:22,934
17. It's going to be 16. Right. Because this ten

585
00:36:22,972 --> 00:36:25,746
actually counts as two. Because on the first frame, when I did the strike,

586
00:36:25,778 --> 00:36:28,934
so I didn't have an additional role. Right. So it counts as two. So two

587
00:36:28,972 --> 00:36:32,486
here and two here. So 20 minus four. It's actually 16.

588
00:36:32,678 --> 00:36:36,058
What's the expected score? Try to think for yourself.

589
00:36:36,144 --> 00:36:40,378
Okay. Before I let you know. So it's going to be 22,

590
00:36:40,464 --> 00:36:44,214
right? How? Because on the first frame, I get ten plus

591
00:36:44,272 --> 00:36:47,454
the strike bonus, which will be the next two rolls. So it's three plus

592
00:36:47,492 --> 00:36:50,682
three. So ten plus three plus three. It's 16.

593
00:36:50,746 --> 00:36:53,922
Right. On the second frame, I have three plus three, which is six.

594
00:36:53,976 --> 00:36:56,738
So 16 plus six would be 22.

595
00:36:56,904 --> 00:37:00,046
Okay, great. So let's

596
00:37:00,078 --> 00:37:03,458
continue. I think now it should be pretty obvious,

597
00:37:03,544 --> 00:37:06,258
right. I'm going to go here for my iteration. I'm going to say, you know

598
00:37:06,264 --> 00:37:09,974
what? If this dot rolls is already in,

599
00:37:10,012 --> 00:37:12,280
the role index is already ten.

600
00:37:14,730 --> 00:37:18,586
So what should I do? Sorry, not if. So what

601
00:37:18,608 --> 00:37:22,358
should I do? I should say that the score

602
00:37:22,454 --> 00:37:26,214
plus equals ten plus this dot roles

603
00:37:26,342 --> 00:37:29,386
where in the role index plus one. Right. This is

604
00:37:29,408 --> 00:37:33,238
the next one plus this dot roles

605
00:37:33,414 --> 00:37:35,840
in role index plus two.

606
00:37:38,130 --> 00:37:41,006
And now what do I need to do? Now this is a bit tricky because

607
00:37:41,028 --> 00:37:43,902
the role index actually need to be increased only by one. Right.

608
00:37:43,956 --> 00:37:47,326
Because I do not get to have a second role in this frame because I've

609
00:37:47,358 --> 00:37:50,546
done a strike. Okay. And of course I should add an

610
00:37:50,568 --> 00:37:53,842
else here. And this role index plus equals two should

611
00:37:53,896 --> 00:37:55,890
now go inside the cases.

612
00:37:58,090 --> 00:38:00,440
Okay, let's run the test.

613
00:38:02,810 --> 00:38:06,214
So this red green refactor thing actually causes me to

614
00:38:06,252 --> 00:38:10,054
refactor my code over and over again. So I'm always keeping my

615
00:38:10,092 --> 00:38:13,658
code tight and clean. And of course, I'm doing refactoring for the

616
00:38:13,664 --> 00:38:17,030
test code, as I showed you in the beginning. So the test code also becomes

617
00:38:17,110 --> 00:38:20,358
quite clean. Great, so this is working. So refactoring, we already know

618
00:38:20,384 --> 00:38:24,106
the tricks here, right? I mean, we don't like these heavy conditions.

619
00:38:24,138 --> 00:38:27,706
So I'm going to extract them out. I'm going to say let's

620
00:38:27,738 --> 00:38:30,954
call them cases. Strike.

621
00:38:31,082 --> 00:38:34,478
Right? And I'm going to take this code here and I'm

622
00:38:34,494 --> 00:38:38,574
going to say, this is pretty complicated. Let's call it strike

623
00:38:38,622 --> 00:38:42,062
bonus. Now there's an additional

624
00:38:42,126 --> 00:38:45,646
thing that I want to do. Now, you all understand that I'm iterating

625
00:38:45,678 --> 00:38:49,398
in the context of frames, right? Because it's ten and it's pretty obvious.

626
00:38:49,484 --> 00:38:52,918
Okay? But there's another thing that I can

627
00:38:52,924 --> 00:38:56,082
do that will really help. I mean, instead of calling this variable,

628
00:38:56,146 --> 00:38:59,538
I, I would change its name and I'm

629
00:38:59,554 --> 00:39:02,646
going to call it frame. And now everything is understood.

630
00:39:02,758 --> 00:39:06,022
Now we tend to always call I or j or k in the indices

631
00:39:06,086 --> 00:39:09,542
of a loop in case we are using this kind of for loop.

632
00:39:09,606 --> 00:39:12,538
But sometimes when we change the variable into something meaningful,

633
00:39:12,634 --> 00:39:15,920
it really, really helps. And I really, really like it this way.

634
00:39:16,770 --> 00:39:18,960
Okay, so let's run the test.

635
00:39:20,050 --> 00:39:23,134
Now when I'm running a test, try to think how do we continue from

636
00:39:23,172 --> 00:39:27,218
here? I mean, this is not that obvious, okay, because now

637
00:39:27,304 --> 00:39:30,878
we have four tests. All of them actually cover the basics,

638
00:39:30,974 --> 00:39:34,242
right? And what do we do from now? Because we can do many, many things,

639
00:39:34,296 --> 00:39:37,574
right? We can actually say, let's run this kind

640
00:39:37,612 --> 00:39:40,022
of crazy game that has everything, right?

641
00:39:40,076 --> 00:39:43,334
Gutter, regular, spare strikes, everything.

642
00:39:43,452 --> 00:39:47,046
We can write a game with all spells. We can test for a game with

643
00:39:47,068 --> 00:39:51,014
all strikes. We can do a combination. We can do many, many things. Okay,

644
00:39:51,212 --> 00:39:55,002
so let's start from an edge case. Okay, let's do a perfect game.

645
00:39:55,056 --> 00:39:58,410
Okay. A perfect game is a game with all strikes. It will also cover

646
00:39:58,480 --> 00:40:01,590
the fact that we are doing strike in the last frame, that we

647
00:40:01,600 --> 00:40:04,670
need to have three rolls or something like that. Okay, so let's do that.

648
00:40:04,820 --> 00:40:08,400
So I'm going to duplicate this test and I'm going to say that

649
00:40:11,330 --> 00:40:15,202
it should actually score 300 when

650
00:40:15,256 --> 00:40:17,940
playing a perfect game.

651
00:40:19,510 --> 00:40:23,006
So how do I simulate a perfect game? So I'm going to use my roll

652
00:40:23,038 --> 00:40:26,082
many method. Okay, I'm going to roll twelve

653
00:40:26,136 --> 00:40:29,766
times because this is how I can do it when

654
00:40:29,788 --> 00:40:33,078
I have strike every time and I'm going to strike each time.

655
00:40:33,164 --> 00:40:37,158
Okay, which is great. And the expected, of course, should be 300.

656
00:40:37,324 --> 00:40:40,082
Now try to think, will that work or not?

657
00:40:40,236 --> 00:40:43,466
What do you think? Some of you are saying

658
00:40:43,488 --> 00:40:46,474
yes and some of you are saying no, I'm guessing, but let's try. Okay,

659
00:40:46,512 --> 00:40:47,820
I'm going to run this test.

660
00:40:50,270 --> 00:40:53,886
What is suspense? Let's see. Okay,

661
00:40:53,988 --> 00:40:57,134
already working. Interesting. So I've added a new

662
00:40:57,172 --> 00:41:00,366
test, but I didn't need to change any piece of code in order to make

663
00:41:00,388 --> 00:41:03,486
it pass. So that's interesting. What would you

664
00:41:03,508 --> 00:41:06,834
test next? Okay, so it's starting to get complicated. Should I test

665
00:41:06,872 --> 00:41:10,114
a game with all spells? Should they create a combination or

666
00:41:10,152 --> 00:41:13,218
something? Now I'll let you in on a

667
00:41:13,224 --> 00:41:16,354
small secret. Now we're basically finished, okay. The small

668
00:41:16,392 --> 00:41:19,894
piece of code that we've just written here is actually what we need

669
00:41:19,932 --> 00:41:23,666
in order to calculate a bowling game. So we're done. Every test that we're

670
00:41:23,698 --> 00:41:26,978
going to add here is going to pass. Okay. Which actually brings

671
00:41:26,994 --> 00:41:30,534
me to a question. Should I add more tests if

672
00:41:30,572 --> 00:41:33,718
I don't need to change any code, so should I add more tests? And it's

673
00:41:33,734 --> 00:41:36,954
a difficult question because people sometimes tend to say, why not?

674
00:41:36,992 --> 00:41:40,326
I mean, add some tests and then you will have a safety net, but that's

675
00:41:40,358 --> 00:41:43,706
not very accurate because every piece of code that I write doesn't

676
00:41:43,738 --> 00:41:46,894
matter. Test of production I actually need to maintain later on.

677
00:41:46,932 --> 00:41:50,394
So I want my test suite to be small but very powerful.

678
00:41:50,522 --> 00:41:53,774
Okay. So this is one

679
00:41:53,812 --> 00:41:57,610
thing, but the second thing is that, okay. But I can't rely only on

680
00:41:57,620 --> 00:42:01,202
the basic cases. So I actually like the fact that I've added this perfect game

681
00:42:01,256 --> 00:42:04,466
here. Okay. Because it's kind of an edge case. It's kind of a

682
00:42:04,488 --> 00:42:08,034
thing that helps me know that I've tests for most scenarios. So in the real

683
00:42:08,072 --> 00:42:11,926
world, maybe I would add something like a sanity test that will

684
00:42:12,108 --> 00:42:15,606
take some combination to see that things are working, but that's about it. Okay.

685
00:42:15,628 --> 00:42:19,014
I'm very careful with adding more and more tests. Now, what do we think about

686
00:42:19,052 --> 00:42:22,966
the production code? I mean, if you imagine something when ive

687
00:42:23,078 --> 00:42:27,146
read the requirements, was it this way or was it something else? I'm not

688
00:42:27,168 --> 00:42:30,502
sure. But I actually like the production code. I think it's very concise.

689
00:42:30,566 --> 00:42:34,522
It's very, very expressive. Okay. And very readable. Now, some people

690
00:42:34,576 --> 00:42:37,726
tend to say that if else if is not very good because it is

691
00:42:37,748 --> 00:42:41,198
not closed for changes, if you know the solid principles. But I

692
00:42:41,204 --> 00:42:44,754
would say that the bowling game has never changed, at least

693
00:42:44,792 --> 00:42:48,034
not that I know of. Okay. So when the number of possibilities is

694
00:42:48,072 --> 00:42:51,730
closed, so we're actually good. So we're basically finished the exercise.

695
00:42:52,390 --> 00:42:55,870
So I want to summarize several things.

696
00:42:55,960 --> 00:42:58,280
Okay, so first of all,

697
00:43:01,370 --> 00:43:04,614
I want to thank you for participating, and I hope you find it useful and

698
00:43:04,652 --> 00:43:08,306
interesting. Okay, if you did, and I hope you did, I highly

699
00:43:08,338 --> 00:43:11,846
recommend on trying out the things that we have discussed on your project. It can

700
00:43:11,868 --> 00:43:15,266
be test first if it's not test first. So try to go for business flows

701
00:43:15,378 --> 00:43:18,294
instead of unit test. Okay. Try not to mock everything.

702
00:43:18,412 --> 00:43:22,350
Okay. But if you find it too difficult, especially with test first.

703
00:43:22,420 --> 00:43:26,158
Okay. So I highly recommend on practicing on code cutters such as the

704
00:43:26,164 --> 00:43:29,914
one that I've just did. Okay. It's very useful and very effective,

705
00:43:29,962 --> 00:43:33,006
and the effect of muscle memory actually works when you go

706
00:43:33,028 --> 00:43:36,314
later on to production. It really helps.

707
00:43:36,442 --> 00:43:39,758
Now, thank you very much and feel free to contact me on any platform.

708
00:43:39,924 --> 00:43:40,460
Thanks again.

