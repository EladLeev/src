1
00:00:36,370 --> 00:00:39,826
Hi, my name is Spoons and thanks for joining. I'm here to talk about driving

2
00:00:39,858 --> 00:00:42,150
service ownership with distributed tracing.

3
00:00:43,370 --> 00:00:46,626
Before I get started, just a little bit about myself. So my name is Spoons.

4
00:00:46,658 --> 00:00:50,458
Although my full name is Daniel Spoonhauer, no one calls me that. I'm CTO

5
00:00:50,474 --> 00:00:53,726
and a co founder at Lightstep, where we provide simple observability for

6
00:00:53,748 --> 00:00:57,610
deep systems based on distributed tracing. And I spend a lot of time at Lightstep

7
00:00:57,690 --> 00:01:01,226
thinking and working on both service ownership and, not surprisingly,

8
00:01:01,258 --> 00:01:04,810
distributed tracing. Before I helped found Lightstep, I was

9
00:01:04,820 --> 00:01:08,802
a software engineer at Google. I worked both on Google's internal infrastructure team

10
00:01:08,936 --> 00:01:12,878
and as part of Google's cloud platform team. I worked closely

11
00:01:12,894 --> 00:01:16,146
with SRE in both cases to build processes and roll out

12
00:01:16,168 --> 00:01:20,002
tools to improve reliability and reduce the amount of work for teams,

13
00:01:20,146 --> 00:01:23,122
and in both cases, hands. Subsequently, at Lightstep,

14
00:01:23,186 --> 00:01:27,110
I carried a pager for many years, although they don't let me do that anymore.

15
00:01:28,010 --> 00:01:31,690
So great. So before I get too deep, just to kind of set some context,

16
00:01:32,350 --> 00:01:35,882
I want to talk about this question. What changed? I think this is a really

17
00:01:35,936 --> 00:01:39,306
important question generally for SRE, but I want to talk

18
00:01:39,328 --> 00:01:42,574
about what changed in the kinds of technologies that we use,

19
00:01:42,612 --> 00:01:46,158
the kinds of architectures that we build. And these was that we work together

20
00:01:46,244 --> 00:01:49,946
as well. Many engineering

21
00:01:49,978 --> 00:01:53,466
organizations are adopting services or other kinds of similar systems,

22
00:01:53,498 --> 00:01:57,106
often aside DevOps practices. But what does that mean for how we work

23
00:01:57,128 --> 00:02:00,414
together? So there's been a series of technical

24
00:02:00,462 --> 00:02:04,222
changes as we move from bare metal to virtual machines, to containers,

25
00:02:04,286 --> 00:02:07,042
and finally to orchestration tools like kubernetes.

26
00:02:07,186 --> 00:02:09,974
And each of these has provided additional abstractions, right?

27
00:02:10,012 --> 00:02:13,746
They've raised the level of the primitives

28
00:02:13,778 --> 00:02:17,314
that we can work with. They've also introduced additional complexity.

29
00:02:17,362 --> 00:02:20,626
Hands more was for those systems to fail. So there's a trade

30
00:02:20,658 --> 00:02:24,134
off there. And of course, even though we have those abstractions,

31
00:02:24,182 --> 00:02:28,038
someone still needs to understand what's happening underneath the hood. Partly enabled

32
00:02:28,054 --> 00:02:31,238
by these. We've also changed these way that we build these systems, right? So we've

33
00:02:31,254 --> 00:02:33,950
moved to microservices, maybe we're using serverless.

34
00:02:34,290 --> 00:02:37,706
These are all ways of building more loosely coupled

35
00:02:37,738 --> 00:02:42,110
applications where different pieces of it can be deployed independently, can be scaled independently.

36
00:02:43,170 --> 00:02:46,386
And speaking of independently, we've also

37
00:02:46,488 --> 00:02:50,130
adopting methodologies like agile and DevOps.

38
00:02:51,110 --> 00:02:54,098
I'll talk a bit more about DevOps, but I really think of DevOps as a

39
00:02:54,104 --> 00:02:58,258
way to allow teams to work more autonomously, more independently,

40
00:02:58,434 --> 00:03:02,374
and to boost developer velocity. And while

41
00:03:02,492 --> 00:03:07,318
that's good in a lot of ways, that's also created some challenges. So I

42
00:03:07,484 --> 00:03:10,326
like to put this kind of in the form of this feedback loop, right?

43
00:03:10,348 --> 00:03:14,026
So if we look at the bigger picture in any software system, and really

44
00:03:14,048 --> 00:03:16,986
this goes for a whole bunch of other systems as well, we have a kind

45
00:03:17,008 --> 00:03:20,460
of feedback loop, and on one half of these loop we've got control.

46
00:03:21,390 --> 00:03:24,746
Control is the systems, the levers, the tools that we

47
00:03:24,768 --> 00:03:28,046
use to affect change hands in a software system today, that's things

48
00:03:28,068 --> 00:03:31,950
like kubernetes and associated tools could be things like service mesh,

49
00:03:32,450 --> 00:03:36,018
configuration management. These are all ways of affecting change.

50
00:03:36,184 --> 00:03:39,554
But there's another half to this feedback loop as well, and that's how we

51
00:03:39,592 --> 00:03:43,026
observe those changes. Observing is another

52
00:03:43,128 --> 00:03:45,970
set of tools we can use to understand what's happening. And it's really an important

53
00:03:46,040 --> 00:03:49,046
part of that feedback loop because it tells us what we should do next.

54
00:03:49,148 --> 00:03:52,658
Right. And I think maybe there's some good reasons

55
00:03:52,674 --> 00:03:55,986
for this, but the amount of investment

56
00:03:56,018 --> 00:03:59,334
that we've seen in the tools on the top half of this loop, I think

57
00:03:59,372 --> 00:04:02,934
has really outpaced these investment and really these innovation

58
00:04:02,982 --> 00:04:06,966
as well on the observability side of things. And I know we've had tools

59
00:04:06,998 --> 00:04:09,946
that allow us to observe our systems for a long time. Maybe we didn't call

60
00:04:09,968 --> 00:04:13,946
them observability tools, but I think with these shift to more loosely

61
00:04:13,978 --> 00:04:16,670
coupled services, with the shifts that we've made to our organization,

62
00:04:17,570 --> 00:04:20,846
it really requires a new way of thinking about how

63
00:04:20,868 --> 00:04:24,286
we observe these systems. And really,

64
00:04:24,468 --> 00:04:28,350
if we haven't adapted those systems, if we haven't innovated on those observability

65
00:04:28,430 --> 00:04:32,210
systems, it's like we've built this amazing car that goes super fast.

66
00:04:32,280 --> 00:04:35,218
We've got a great gas pedal, but we don't have a speedometer. So we have

67
00:04:35,224 --> 00:04:38,766
no way of knowing how fast we're going. And this has consequences at all kinds

68
00:04:38,798 --> 00:04:42,198
of different scales, both at the small scale. When we think about how we're going

69
00:04:42,204 --> 00:04:45,846
to do auto scaling and what are the metrics that we're going to use to

70
00:04:45,868 --> 00:04:49,514
inform that to? How do we decide when to peel off functionality into

71
00:04:49,552 --> 00:04:52,700
a new service, to thinking about the application architecture as a whole?

72
00:04:53,790 --> 00:04:57,740
And often the idea here is that

73
00:04:58,910 --> 00:05:02,314
we have given control and we've built out these control systems to allow

74
00:05:02,352 --> 00:05:05,966
teams to move independently. But what's happened is

75
00:05:05,988 --> 00:05:09,342
that we've lost the ability to understand performance or reliability as a system

76
00:05:09,396 --> 00:05:12,586
as a whole. That kind of brings me to the crux

77
00:05:12,618 --> 00:05:16,446
of what we've done here. Kubernetes and other control systems

78
00:05:16,478 --> 00:05:19,906
like that have given each team more power, right,

79
00:05:20,008 --> 00:05:23,950
more decision making, more control. But that control is now distributed,

80
00:05:24,030 --> 00:05:27,682
right? And DevOps likewise means that each team has more control of their own service

81
00:05:27,736 --> 00:05:31,046
when they push code. But each of those teams depends on a lot of other

82
00:05:31,068 --> 00:05:34,646
teams, right? So say youve the team that's responsible for the service. At the

83
00:05:34,668 --> 00:05:38,070
top of this diagram, you're beholden to

84
00:05:38,140 --> 00:05:41,586
end users, say, to deliver a certain amount of reliability and performance,

85
00:05:41,698 --> 00:05:45,018
and you have control over that service, right? You decide when to roll out new

86
00:05:45,104 --> 00:05:48,938
code, you decide when to roll it back as well. But you depend

87
00:05:49,024 --> 00:05:52,886
on all of these services below you. And ultimately you're also responsible

88
00:05:52,998 --> 00:05:56,746
for the performance of those services, right. If those services are slow,

89
00:05:56,778 --> 00:06:00,734
they're part of the functionality that you provide.

90
00:06:00,852 --> 00:06:04,282
Your service is going to be slow as well. But even though you have responsibility

91
00:06:04,346 --> 00:06:07,646
for that performance, you don't have control. Right? You don't have any way of rolling

92
00:06:07,678 --> 00:06:10,786
back those services other than reaching out to those teams and asking them to do

93
00:06:10,808 --> 00:06:14,802
it. And it's not just other services. These things lower

94
00:06:14,856 --> 00:06:18,454
on the diagram here could be infrastructure, they could be managed services. Things outside

95
00:06:18,492 --> 00:06:22,178
of your organization was, well, but this gap that we've created,

96
00:06:22,274 --> 00:06:26,006
for better or worse, and I think for worse, between control and

97
00:06:26,028 --> 00:06:29,830
responsibility, it's really the textbook definition of stress.

98
00:06:30,170 --> 00:06:33,466
And so kind of what I want to talk about today is how can we

99
00:06:33,488 --> 00:06:37,418
use service ownership to lower that stress and

100
00:06:37,424 --> 00:06:40,250
to fill that gap between control and responsibility?

101
00:06:40,670 --> 00:06:44,318
Okay, how are we going to do that? Well, I'm going to talk a

102
00:06:44,324 --> 00:06:47,806
bunch of specifics, but at a very, very high level. To me,

103
00:06:47,828 --> 00:06:51,486
ownership really has two parts, and the two parts are, I think,

104
00:06:51,508 --> 00:06:54,974
both really important. The first one is accountability, and maybe that's not

105
00:06:55,012 --> 00:06:58,366
super surprising. Of course we give people ownership, we have to hold them accountable

106
00:06:58,398 --> 00:07:01,742
to it. But another really important part of that is giving folks agency,

107
00:07:01,806 --> 00:07:05,060
right, the ability, the means to make things better.

108
00:07:06,150 --> 00:07:08,886
And I'm going to touch on both of these a number of times throughout the

109
00:07:08,908 --> 00:07:12,786
talk. At the same time, when we're talking about a loosely coupled

110
00:07:12,818 --> 00:07:15,986
system, we really need to think about the way that we're observing

111
00:07:16,018 --> 00:07:19,218
that system. And distributed tracing, as you may have guessed,

112
00:07:19,234 --> 00:07:22,690
is going to play a really big role in how we

113
00:07:22,700 --> 00:07:26,006
do that. Okay, so let me dive in and talk a bit about distributed tracing,

114
00:07:26,038 --> 00:07:29,770
and I'll come back and then we'll see how we can build better service ownership

115
00:07:30,210 --> 00:07:33,950
just to get everyone on the same page. Distributed tracing

116
00:07:35,650 --> 00:07:39,598
was sort of built and popularized by a bunch of

117
00:07:39,764 --> 00:07:43,982
larger Internet companies. Web search and

118
00:07:44,036 --> 00:07:47,566
social media companies as a way for them to understand their systems

119
00:07:47,598 --> 00:07:51,522
as they built out a microservice like architecture, even though

120
00:07:51,656 --> 00:07:55,006
we didn't call it that at the time. But just to give you a picture

121
00:07:55,038 --> 00:07:58,574
of what distributed tracing might look like, this is a trace.

122
00:07:58,622 --> 00:08:02,198
So almost any distributed tracing tool will show you something like this,

123
00:08:02,284 --> 00:08:05,414
or like one of these traces. And you can think of these

124
00:08:05,452 --> 00:08:09,126
kind of like a Gantt chart, right? So time is moving from left to

125
00:08:09,148 --> 00:08:12,954
right, and each of these bars represents the work done by some services

126
00:08:13,072 --> 00:08:16,426
as part of handling an end user request. And then

127
00:08:16,448 --> 00:08:18,966
as you got from top to bottom, you're kind of going down the stack,

128
00:08:18,998 --> 00:08:22,330
so you can see where time is being spent in servicing those requests.

129
00:08:22,910 --> 00:08:25,694
As I'll explain a bit more in a minute, though, a trace is really just

130
00:08:25,732 --> 00:08:28,590
a building block of what we can do with distributed tracing.

131
00:08:29,410 --> 00:08:32,718
And so I'll speak a bit more about that, but I want to kind

132
00:08:32,724 --> 00:08:34,960
of dive into what the building block is exactly.

133
00:08:35,730 --> 00:08:39,122
So again, we have these bars that represent these work that's being done.

134
00:08:39,176 --> 00:08:42,898
And you can think of the arrows that are going sort of down the

135
00:08:42,904 --> 00:08:46,594
stack, right? These are the calls that are being made when one

136
00:08:46,632 --> 00:08:50,278
service has delegated responsibility for the request to a service below it.

137
00:08:50,364 --> 00:08:53,400
And likewise the arrows that are coming back up are when those things return.

138
00:08:54,170 --> 00:08:57,718
So you can think of whats the trace is really doing is it's encoding the

139
00:08:57,724 --> 00:09:01,526
causal relationships between callers and colleagues, right. It alerts us know who's

140
00:09:01,558 --> 00:09:04,746
responsible for servicing requests at a given moment in time.

141
00:09:04,928 --> 00:09:07,894
And therefore we can understand where to attribute failures.

142
00:09:07,942 --> 00:09:11,050
We can understand where to attribute things like slowness.

143
00:09:12,610 --> 00:09:15,486
I'm not going to say tools much more about tracing here.

144
00:09:15,668 --> 00:09:17,840
If you want to understand more,

145
00:09:18,530 --> 00:09:22,222
Google put out a paper a while back, got ten years ago

146
00:09:22,276 --> 00:09:25,294
about Dapper Google's internal system that

147
00:09:25,332 --> 00:09:28,766
says a lot of details about what was important at Google and kind of rolling

148
00:09:28,798 --> 00:09:32,578
out the system in some of those use cases, especially about the

149
00:09:32,584 --> 00:09:36,610
mechanics of how they collected and managed those traces.

150
00:09:37,510 --> 00:09:40,546
And even though that's a bit old, I think there's a great kind of perspective

151
00:09:40,578 --> 00:09:43,986
on the history of it. I also want to say I wrote

152
00:09:44,018 --> 00:09:47,094
the book on distributed tracing, so if there's more you want to learn about it,

153
00:09:47,132 --> 00:09:50,454
I strongly recommend this book. I don't get any

154
00:09:50,492 --> 00:09:53,418
royalties from it. We donated all the royalties to a good cause,

155
00:09:53,584 --> 00:09:56,762
but the book can obviously cover a lot more than I can cover today.

156
00:09:56,816 --> 00:10:00,454
From the very basics of distributed tracing, to how to think about costs

157
00:10:00,502 --> 00:10:03,614
and implementation, to getting value from tracing and even what

158
00:10:03,652 --> 00:10:07,326
tracing might offer in the future. Okay, I said traces are just

159
00:10:07,348 --> 00:10:11,658
the building block, though. What do I mean? Well, traces are really the raw material,

160
00:10:11,754 --> 00:10:15,018
right? So distributed traces, those are just, youve can think of them as structs,

161
00:10:15,034 --> 00:10:18,866
right? It's a data type, it's these collection of data, but they're not the

162
00:10:18,888 --> 00:10:22,306
finished product. Right? And distributed tracing is really

163
00:10:22,408 --> 00:10:26,142
that process, that art hands science of deriving value from those traces.

164
00:10:26,286 --> 00:10:28,740
So just to give an example of that at Google,

165
00:10:29,050 --> 00:10:32,342
and you can read about this in the dapper paper, some of the most

166
00:10:32,396 --> 00:10:36,566
valuable uses of things tracing data were not looking at individual ones, but looking

167
00:10:36,588 --> 00:10:40,054
at aggregates. So there was at the time, maybe there still

168
00:10:40,092 --> 00:10:43,418
is a weekly Mapreduce that was run that looked at the

169
00:10:43,424 --> 00:10:47,130
entire collection of traces for web search requests over the past week,

170
00:10:47,280 --> 00:10:51,226
and it detailed how each team hands their service had contributed

171
00:10:51,338 --> 00:10:55,406
to performance for web search. So whether that

172
00:10:55,428 --> 00:10:59,280
service was searching web documents or news or images or video or whatever,

173
00:10:59,810 --> 00:11:03,326
that report would essentially say what percent of the latency was

174
00:11:03,348 --> 00:11:06,314
due to each of those services. And then that can be used to then prioritize

175
00:11:06,362 --> 00:11:10,034
work done by those teams. And in fact, when it wasn't used,

176
00:11:10,152 --> 00:11:12,866
we actually had teams that would go off and they would spend a month or

177
00:11:12,888 --> 00:11:16,254
more time on optimization, which might have improved performance

178
00:11:16,302 --> 00:11:20,006
for their individual service, but had no effect on the overall performance as

179
00:11:20,028 --> 00:11:23,350
observed by users. So again,

180
00:11:23,500 --> 00:11:27,206
distributed tracing, thinking about what the value is, and that's really what I

181
00:11:27,228 --> 00:11:31,050
want to talk about in the context of service ownership today. So service

182
00:11:31,120 --> 00:11:34,714
ownership, let's talk about what I think that means and

183
00:11:34,752 --> 00:11:38,442
some of the benefits and maybe the risks associated with moving forward

184
00:11:38,496 --> 00:11:42,394
and pushing that. So just

185
00:11:42,432 --> 00:11:46,942
to define it, service ownership is really making teams or

186
00:11:47,076 --> 00:11:49,854
responsible for the delivery of their software and their services.

187
00:11:49,972 --> 00:11:53,726
Right. And just to be concrete, it can include responsibilities like

188
00:11:53,748 --> 00:11:57,314
incident response. I think that's what a lot of people think of, but it

189
00:11:57,352 --> 00:12:01,106
also probably involves paying for the infrastructure that those services are

190
00:12:01,128 --> 00:12:04,626
using, for the storage that they might be using. And of course, someone needs

191
00:12:04,648 --> 00:12:08,254
to fix bugs. And I think service ownership is an important part of figuring

192
00:12:08,302 --> 00:12:12,306
out how to triage and allocate bugs. Service ownership,

193
00:12:12,338 --> 00:12:14,998
I think, comes up a lot in the context of DevOps. So I kind of

194
00:12:15,004 --> 00:12:17,400
wanted to spend a minute just to compare those two.

195
00:12:18,410 --> 00:12:21,786
And there's obviously a lot of overlap and

196
00:12:21,808 --> 00:12:25,578
a tight relationship. But DevOps also means a lot of different things to different people.

197
00:12:25,744 --> 00:12:29,766
So DevOps can mean an engineering culture, a culture

198
00:12:29,798 --> 00:12:33,822
that's really based on cooperation between the

199
00:12:33,956 --> 00:12:37,806
people that are developing hands operating software. In some cases they

200
00:12:37,828 --> 00:12:41,374
might be the same people, but not always. DevOps can also mean a set of

201
00:12:41,412 --> 00:12:45,200
tools. So it might mean the latest CI CD tool,

202
00:12:45,570 --> 00:12:49,154
it might mean some of the other infrastructure. Whats you're using in order to provide

203
00:12:49,272 --> 00:12:52,946
a platform for the rest of your organization? I really like

204
00:12:52,968 --> 00:12:55,906
to think a little bit higher. I mean those are great definitions as well,

205
00:12:55,928 --> 00:12:59,398
but I like to think of DevOps as I mentioned, as a feedback loop between

206
00:12:59,484 --> 00:13:02,998
developers and their users, right. And creating a

207
00:13:03,004 --> 00:13:06,386
type feedback loop so that those developers see immediately

208
00:13:06,418 --> 00:13:10,566
what the effects of the code that they're writing and deploying are and

209
00:13:10,588 --> 00:13:13,930
they're able to take that and then use it in terms of how they continue

210
00:13:14,000 --> 00:13:17,306
to do product definition and software developers. So in a lot of ways I think

211
00:13:17,328 --> 00:13:21,366
DevOps can be a bit broader and apply more to a larger

212
00:13:21,398 --> 00:13:25,134
set of processes. And I think if service ownership is really just

213
00:13:25,172 --> 00:13:28,686
thinking about for a team that both developers and

214
00:13:28,708 --> 00:13:32,078
operates, what are the set of responsibilities they have in order to make sure that

215
00:13:32,084 --> 00:13:35,810
they're doing that reliably, hands as

216
00:13:35,880 --> 00:13:38,100
according to their customers expect.

217
00:13:39,270 --> 00:13:43,330
Okay, so what are some of the good things about service ownership?

218
00:13:43,670 --> 00:13:47,446
Well, one thing is by giving teams ownership over their

219
00:13:47,468 --> 00:13:51,266
services, you allow them to be more independent and hopefully that'll raise the developer

220
00:13:51,298 --> 00:13:55,186
velocity for your organization. They'll be able to coordinate

221
00:13:55,218 --> 00:13:59,110
less and focus more on the functionality that they're providing.

222
00:13:59,450 --> 00:14:03,174
It also is a way for organizations to hold engineering

223
00:14:03,222 --> 00:14:07,270
teams accountable and to tie their performance to real business metrics.

224
00:14:07,430 --> 00:14:10,650
I'll talk a bit more about this in a few minutes. But for application

225
00:14:10,720 --> 00:14:14,446
developers, this is really about what their customers are

226
00:14:14,468 --> 00:14:18,042
adopting hands perceiving and how they're using the product. For platform engineers,

227
00:14:18,106 --> 00:14:21,294
it's really thinking about the organization as a whole and how other

228
00:14:21,412 --> 00:14:24,946
application developers, teams within the organization are leveraging tools and

229
00:14:24,968 --> 00:14:28,980
infrastructure and delivering on those promises that they're making to their customers.

230
00:14:30,150 --> 00:14:33,074
Now, there's obviously risks that come along with this was,

231
00:14:33,112 --> 00:14:37,118
well, if you make teams more independent, you allow them to make independent choices,

232
00:14:37,294 --> 00:14:40,130
they might make different choices, right. And you can have divergence.

233
00:14:40,290 --> 00:14:44,326
These, you have more frameworks, more tools that

234
00:14:44,348 --> 00:14:47,494
can have some downsides, right? So one of those downsides is that you have higher

235
00:14:47,532 --> 00:14:51,178
vendor costs. You're not getting the same economy of scale that you might get

236
00:14:51,184 --> 00:14:54,570
if you're just using one tool consistently throughout your organization.

237
00:14:55,230 --> 00:14:58,762
It also might mean that there's more training not only for new team members,

238
00:14:58,816 --> 00:15:02,966
but as developers transfer within teams,

239
00:15:02,998 --> 00:15:06,382
they need to learn a new set of tools, a new set of processes and

240
00:15:06,516 --> 00:15:09,758
thinking about it from the point of view of the organization as a whole or

241
00:15:09,764 --> 00:15:12,946
maybe from a platform engineering team, it's harder to get a sense of the big

242
00:15:12,968 --> 00:15:16,466
picture of your application. So if

243
00:15:16,488 --> 00:15:19,954
we think about how to kind of balance these benefits and

244
00:15:19,992 --> 00:15:24,530
risks and think about those trade offs on both sides,

245
00:15:25,270 --> 00:15:28,738
they come from this idea of this independence, right? That we are allowing teams to

246
00:15:28,744 --> 00:15:31,766
make their own choices. So I think the way that we're going to manage these

247
00:15:31,788 --> 00:15:35,094
trade offs is by allowing for that independence, but at the same

248
00:15:35,132 --> 00:15:38,674
time defining clear responsibilities and goals for those teams.

249
00:15:38,802 --> 00:15:41,718
We allow them to make choices, but we give them some guardrails about how they

250
00:15:41,724 --> 00:15:44,874
can make those choices. And then at the same time it's about

251
00:15:44,912 --> 00:15:48,426
ensuring consistency, right? So maybe there are some kinds of tools that we

252
00:15:48,448 --> 00:15:51,574
allow teams to make independent choices about, but maybe not for other tools.

253
00:15:51,622 --> 00:15:55,406
And when we talk about measuring these results of their work, we want

254
00:15:55,428 --> 00:15:59,054
to make sure that we're doing that consistently and we're measuring progress towards those

255
00:15:59,092 --> 00:16:01,998
goals and we're holding those teams accountable. Okay,

256
00:16:02,084 --> 00:16:06,410
so I think thinking of about service ownership in this context

257
00:16:06,490 --> 00:16:10,530
now, how do we allow for this independence? How do we provide for this consistency?

258
00:16:10,950 --> 00:16:13,902
And like I said, this is going to come back to accountability and agency.

259
00:16:13,966 --> 00:16:17,762
Like I mentioned at the beginning. Okay, how do we drive towards service

260
00:16:17,816 --> 00:16:21,078
ownership? I kind of have three pieces to this puzzle that I

261
00:16:21,084 --> 00:16:25,078
want to talk about each in turn. Hands. Those are documentation oncall.

262
00:16:25,164 --> 00:16:28,330
Not surprising. Hands then service level objectives.

263
00:16:28,750 --> 00:16:30,970
Okay, to start with documentation,

264
00:16:32,110 --> 00:16:36,090
the first step is really creating consistent and centralized documentation

265
00:16:36,510 --> 00:16:40,118
specifically around services in your application. As we grew

266
00:16:40,134 --> 00:16:43,566
at Lightstep and I'm sure was a lot of your organizations have we looked

267
00:16:43,588 --> 00:16:46,926
to define responsibilities for services as the teams got

268
00:16:47,028 --> 00:16:50,314
larger, we split teams as the number of services grew.

269
00:16:50,442 --> 00:16:53,634
But before you can split those responsibilities, I think you need to know who the

270
00:16:53,672 --> 00:16:56,962
experts are. I mean, knowing that is valuable in itself,

271
00:16:57,096 --> 00:17:00,900
but those experts are really going to services as the seeds for

272
00:17:02,870 --> 00:17:06,100
these clusters that will take over ownership of the services.

273
00:17:06,870 --> 00:17:09,710
That documentation is also a way to share that expertise. Right.

274
00:17:09,800 --> 00:17:13,638
Hands. A way for others to find related information that comes in

275
00:17:13,644 --> 00:17:17,222
the form of finding telemetry and dashboards. It could be to find

276
00:17:17,276 --> 00:17:20,966
alert definitions or when an alert fires, to find the playbook that helps you do

277
00:17:20,988 --> 00:17:23,894
that. Hands. One of the things that we found useful was to use a template

278
00:17:23,942 --> 00:17:27,514
for this kind of documentation, right? So youve know that you have some

279
00:17:27,552 --> 00:17:30,826
consistency hands. An engineer or developer knows that when they

280
00:17:30,848 --> 00:17:34,426
go to it, they'll be able to find links to say a dashboard or to

281
00:17:34,448 --> 00:17:37,200
a logs or to traces that help them understand what's happening.

282
00:17:38,130 --> 00:17:41,258
The other thing about a template that's I think, really interesting is that it allows

283
00:17:41,274 --> 00:17:45,370
you to run reports over that and extract information from that documentation,

284
00:17:45,450 --> 00:17:48,750
right? So now we can ask questions like how is expertise divided,

285
00:17:48,830 --> 00:17:52,786
right? Are there certain people that are listed as experts for

286
00:17:52,808 --> 00:17:55,986
more of the service? How does that change over time? And if we've written the

287
00:17:56,008 --> 00:17:59,698
documentation in a totally ad hoc and unstructured way,

288
00:17:59,784 --> 00:18:02,998
it's a really manual process to discover that. But if we've built a kind of

289
00:18:03,004 --> 00:18:06,338
template, a form, we can extract that information much more easily.

290
00:18:06,514 --> 00:18:09,174
The other thing is if we put all the documentation in one place, it's really

291
00:18:09,212 --> 00:18:12,758
easy to audit how often it changes, right? And you can require

292
00:18:12,934 --> 00:18:16,694
periodic updates. You can ask when was the last time for the documentation

293
00:18:16,742 --> 00:18:20,266
for a service x updated? Okay, that was too long ago. Someone on that team

294
00:18:20,288 --> 00:18:22,560
is going to need to be responsible for updating it.

295
00:18:23,490 --> 00:18:27,658
Now, centralized documentation is great. Even better is if you can make it machine readable,

296
00:18:27,754 --> 00:18:30,926
right? So if you do that, you can use

297
00:18:30,948 --> 00:18:34,306
the documentation actually was part of building and

298
00:18:34,328 --> 00:18:37,966
deploying these services, right? So you can use it to generate dashboard config,

299
00:18:38,078 --> 00:18:41,806
you can use it to define escalation policies, hands to define

300
00:18:41,838 --> 00:18:45,234
how deployments work. And that's great one,

301
00:18:45,272 --> 00:18:48,966
because it saves a lot of time, it makes it easier to define new services,

302
00:18:49,068 --> 00:18:52,358
there's less work to do there, but it also makes

303
00:18:52,444 --> 00:18:55,702
documentation necessary as part of the day to day work

304
00:18:55,756 --> 00:18:58,854
of a developer. It makes it necessary for them to get their job done.

305
00:18:59,052 --> 00:19:02,406
And if the only way to add a service to the CI pipeline is

306
00:19:02,428 --> 00:19:05,846
to add it to the documentation, then you can be sure that the documentation is

307
00:19:05,868 --> 00:19:08,086
going to be up to date, right? And that's really what we want. We want

308
00:19:08,108 --> 00:19:10,158
the documentation to be up to date because it's not up to date. People will

309
00:19:10,164 --> 00:19:12,846
lose trust in it and it won't be valuable, they won't go to it,

310
00:19:12,868 --> 00:19:16,320
and there's sort of a downward spiral that we'll be in.

311
00:19:17,170 --> 00:19:21,386
The other thing to think about keeping documentation up to date is just really focusing

312
00:19:21,418 --> 00:19:24,958
on which documentation should be written by humans, right? Not all

313
00:19:24,964 --> 00:19:28,100
of it should be. Some of it really should be dynamic hands.

314
00:19:29,110 --> 00:19:32,846
If we're talking about which team owns a given service, fine, like humans

315
00:19:32,878 --> 00:19:36,162
need to update that. But one of the notorious problems that we

316
00:19:36,216 --> 00:19:39,702
looked to tackle over and over again at Google was try to record service

317
00:19:39,756 --> 00:19:43,046
dependencies and it was just incredibly hard to get teams to do

318
00:19:43,068 --> 00:19:46,790
that because it was constantly changing. It's a function of the software itself,

319
00:19:46,940 --> 00:19:50,662
not of the humans involved. And so asking humans to do that,

320
00:19:50,716 --> 00:19:53,914
I think, was, well, I mean, the conclusion we came to

321
00:19:53,952 --> 00:19:57,910
in the end was that it was never going to work, but doing it programmatically

322
00:19:58,070 --> 00:20:01,078
makes a lot more sense, I think. And that's one of the ways that distributed

323
00:20:01,094 --> 00:20:05,102
tracing can come into play. So this is a service

324
00:20:05,156 --> 00:20:08,142
diagram that I pulled from our own system,

325
00:20:08,276 --> 00:20:11,566
and Aggie is one of our internal services that we run as

326
00:20:11,588 --> 00:20:14,666
part of Lightthep's product. And this is an automatically

327
00:20:14,698 --> 00:20:18,402
generated diagram from a set of traces that tells us the dependencies of that,

328
00:20:18,456 --> 00:20:21,986
not only the immediate ones, but the

329
00:20:22,008 --> 00:20:25,314
transitive dependencies as well. So we can discover dependencies that are two, three, four,

330
00:20:25,352 --> 00:20:28,998
even more hops away. And we can actually annotate that

331
00:20:29,004 --> 00:20:32,406
with other information, like which of those services is actually contributing to latency for

332
00:20:32,428 --> 00:20:35,778
my service. So that, say I just got paged

333
00:20:35,794 --> 00:20:39,530
for latency. Even without any additional information, I can

334
00:20:39,680 --> 00:20:43,354
already have a guess just based upon this kind of dynamic documentation about

335
00:20:43,392 --> 00:20:47,114
where I should start looking. I said,

336
00:20:47,152 --> 00:20:50,554
when it comes to documentation, these wikis are great for people

337
00:20:50,592 --> 00:20:53,806
processes, but don't try hands record information about the software though, right? Because it's just

338
00:20:53,828 --> 00:20:56,830
going to change too fast and it won't be useful.

339
00:20:57,410 --> 00:21:00,830
So as a whole, why is

340
00:21:00,900 --> 00:21:04,080
documentation important? Well, like I said,

341
00:21:04,610 --> 00:21:08,562
it's a shared database of ownership, right? It's about recording who

342
00:21:08,616 --> 00:21:12,146
is accountable in a way that everyone can see. But more than

343
00:21:12,168 --> 00:21:15,234
that, you can also use it to automate a lot of mundane tasks. So having

344
00:21:15,272 --> 00:21:18,950
up to date documentation can also be quite valuable just for reducing toil.

345
00:21:19,930 --> 00:21:23,206
It can also be used to train new team members, obviously. But I

346
00:21:23,228 --> 00:21:27,014
think one thing that was important to us at lightstep in

347
00:21:27,052 --> 00:21:30,778
really improving a lot of our internal documentation was building confidence in

348
00:21:30,864 --> 00:21:35,286
the developer and engineering teams. When we've

349
00:21:35,478 --> 00:21:38,858
tried in previous roles that I've been in,

350
00:21:38,864 --> 00:21:42,474
we've tried to change responsibilities, especially around production

351
00:21:42,522 --> 00:21:46,400
systems. Developers can be pretty unsure hands.

352
00:21:47,490 --> 00:21:50,810
This is kind of going back to this definition of stress.

353
00:21:50,970 --> 00:21:54,906
They want to do a good job, right? They want to be delivering

354
00:21:54,938 --> 00:21:57,746
great service, but if they don't feel like they have the information to do that,

355
00:21:57,768 --> 00:22:01,090
well, that can be a really stressful situation for them. And so having

356
00:22:01,160 --> 00:22:04,274
documentation goes a long way towards building that confidence, towards giving

357
00:22:04,312 --> 00:22:08,390
them that certainty and making them comfortable with those changes in responsibility.

358
00:22:09,850 --> 00:22:13,602
And of course, there's no place that developers

359
00:22:13,666 --> 00:22:17,734
probably feel more stressed. At least many developers is around on

360
00:22:17,772 --> 00:22:19,560
call rotations, right?

361
00:22:22,410 --> 00:22:25,462
Obviously, like I said, one of the most stressful moments for a lot of engineers,

362
00:22:25,526 --> 00:22:29,260
maybe not all of you, but certainly a lot of folks that I've worked with.

363
00:22:29,870 --> 00:22:33,126
And if you're going to establish service ownership,

364
00:22:33,238 --> 00:22:36,478
really, this is one part that you absolutely have to do

365
00:22:36,564 --> 00:22:40,110
right. So just to kind of lay out what

366
00:22:40,180 --> 00:22:43,646
I think oncall can mean, or at least what on calls mean in organizations that

367
00:22:43,668 --> 00:22:48,100
I've worked in, obviously incident response is a big piece of that,

368
00:22:48,630 --> 00:22:51,634
but I think not the only one. And like I said,

369
00:22:51,672 --> 00:22:55,374
this might not apply to every organizations, but at least in one organization

370
00:22:55,422 --> 00:22:58,086
I've worked in, Oncall has been responsible for a bunch of other things as well.

371
00:22:58,108 --> 00:23:01,446
So one of those is communicating status internally within these

372
00:23:01,468 --> 00:23:05,510
organization and externally to customers. Oncall is often responsible for

373
00:23:05,580 --> 00:23:09,402
managing changes within production, whether that's deploying new code themselves

374
00:23:09,456 --> 00:23:13,562
or being kind of a traffic cop for deployments or breaking

375
00:23:13,616 --> 00:23:17,546
other infrastructure changes within the production environment. On call

376
00:23:17,568 --> 00:23:21,446
is often responsible for sort of passively monitoring dashboards

377
00:23:21,558 --> 00:23:25,578
and also handling low urgency alerts, customer requests,

378
00:23:25,594 --> 00:23:29,146
and other kinds of interrupt driven work. In one role

379
00:23:29,178 --> 00:23:32,366
we thought of on call was just the person who's getting interrupted all the time,

380
00:23:32,388 --> 00:23:35,746
and they ended up just getting all the interruptions. But in addition to

381
00:23:35,768 --> 00:23:38,994
that, they're also responsible for handoffs between oncall

382
00:23:39,032 --> 00:23:43,140
shifts. So transferring information to the next on call,

383
00:23:43,830 --> 00:23:47,086
and in the case where there are incidents, writing post mortem

384
00:23:47,118 --> 00:23:50,822
so that we can address those hands. So thinking about how to

385
00:23:50,876 --> 00:23:53,926
improve all these and to do these well, I think is really going to be

386
00:23:53,948 --> 00:23:57,686
critical to doing service ownership well. So I wanted to

387
00:23:57,708 --> 00:24:00,978
kind of start with incident response, since that's

388
00:24:00,994 --> 00:24:04,426
certainly the biggest one. And if you think about

389
00:24:04,528 --> 00:24:07,898
service ownership, yeah, doing this well is really going to be important. And there's a

390
00:24:07,904 --> 00:24:11,206
lot of ways that we can do incident response well or improve incident response

391
00:24:11,238 --> 00:24:14,750
as it exists today. One of those is making pages more actionable,

392
00:24:15,090 --> 00:24:18,800
making it easier to mitigate those problems

393
00:24:19,570 --> 00:24:22,958
or ignore them if they're not problems. Another one is to deliver pages to the

394
00:24:22,964 --> 00:24:26,450
right teams. And finally, we can also just reduce the number of pages overall.

395
00:24:26,790 --> 00:24:30,066
So I said we can

396
00:24:30,088 --> 00:24:33,886
make alerts more actionable. Really, that's about understanding root

397
00:24:33,918 --> 00:24:37,250
causes, right? Like how do we get more quickly to what the root cause

398
00:24:37,320 --> 00:24:41,586
is, or root causes are so that we can take action to address and mitigate

399
00:24:41,618 --> 00:24:44,902
those things? And one of the things that we found

400
00:24:44,956 --> 00:24:48,562
to be really useful at lightstep is to actually annotate

401
00:24:48,626 --> 00:24:50,822
alerts, not only with what the condition,

402
00:24:50,966 --> 00:24:54,890
obviously that was triggered was but to add in additional information

403
00:24:54,960 --> 00:24:58,778
that helps us understand why that happened. Right. And so

404
00:24:58,944 --> 00:25:02,634
if I were to receive this page, I know that latency has gone

405
00:25:02,672 --> 00:25:05,230
up, but if I click on this link here, I also get an example.

406
00:25:05,300 --> 00:25:09,194
This is evidence of latency going up. This is a slow request,

407
00:25:09,322 --> 00:25:12,366
and now I can look and try to understand what's happening not only in this

408
00:25:12,388 --> 00:25:15,598
service, but in services that are deeper down the stack. And maybe in

409
00:25:15,604 --> 00:25:19,746
this case, I can look and see that the work that's being done

410
00:25:19,768 --> 00:25:23,426
by the service is actually being sharded. Right. It's divided into a bunch of

411
00:25:23,448 --> 00:25:27,198
pieces, and it turns out that those shards are not very equally balanced.

412
00:25:27,214 --> 00:25:30,034
One of them is taking a lot longer, and that's really what's driving up latency

413
00:25:30,082 --> 00:25:33,798
in this case. So being able to do this root cause analysis quickly without

414
00:25:33,884 --> 00:25:37,800
digging through lots of information is a way to improve that experience of oncall.

415
00:25:38,730 --> 00:25:42,374
Of course, youve know, even better than having to dig

416
00:25:42,412 --> 00:25:45,750
through a bunch of that stuff is making sure that the right people are involved.

417
00:25:45,910 --> 00:25:48,826
Just from the beginning. I know one of the teams that I worked at,

418
00:25:48,848 --> 00:25:53,046
at Google, we were relatively high on the stack, and when we would get paged,

419
00:25:53,158 --> 00:25:56,174
often the only thing that we could do was to turn around and page another

420
00:25:56,212 --> 00:25:59,758
team to tell these that it was actually their problem. And I

421
00:25:59,844 --> 00:26:03,002
wanted to give credit. This is from a talk that Luis Monero

422
00:26:03,066 --> 00:26:06,514
did last year at Srecon, based upon some work

423
00:26:06,552 --> 00:26:09,826
that he and others did at Zalando, which is an e commerce company based in

424
00:26:09,848 --> 00:26:13,122
Europe. And I think it's really cool work.

425
00:26:13,176 --> 00:26:17,106
So, like I said, at Google, my team was often responsible for sort of

426
00:26:17,128 --> 00:26:20,534
page routing in a way, which is a horrible thing for a human

427
00:26:20,572 --> 00:26:24,614
to do, especially at 03:00 in the morning. And so what

428
00:26:24,652 --> 00:26:27,734
they've built at Zalando is actually programmatically doing that

429
00:26:27,772 --> 00:26:31,926
routing. So they still alert based upon symptoms, right, as you should alert

430
00:26:31,958 --> 00:26:35,866
based upon things that their end users are observing. But what

431
00:26:35,888 --> 00:26:40,426
they've done is that when that happens, they actually look at traces from

432
00:26:40,448 --> 00:26:44,058
the application itself, and if there's an error that triggered that alert,

433
00:26:44,154 --> 00:26:47,326
they look at all of the immediate dependencies of the service

434
00:26:47,428 --> 00:26:50,734
that triggered the alert and say, do any of those dependencies also show

435
00:26:50,772 --> 00:26:54,238
errors in this trace? If yes, repeat and go and look at each

436
00:26:54,244 --> 00:26:57,458
of their dependencies. If any of those dependencies have errors, repeat, go and look

437
00:26:57,464 --> 00:27:00,498
at the next service down the stack and keep going until we find a service

438
00:27:00,584 --> 00:27:04,302
or services that don't have any immediate dependencies with errors.

439
00:27:04,366 --> 00:27:07,922
And then page those teams, they found that this is the best place to start.

440
00:27:07,976 --> 00:27:10,838
It might not always be the right place, but it's better than starting at the

441
00:27:10,844 --> 00:27:13,640
top of the stack and going down one service at a time.

442
00:27:14,410 --> 00:27:17,382
And yeah, like I said, I would have loved to have this kind of thing

443
00:27:17,436 --> 00:27:20,870
on the team that I worked at. It's a great way to get information

444
00:27:20,940 --> 00:27:24,554
to the right people. And like I said, this is sort of a function of

445
00:27:24,592 --> 00:27:27,766
the way that we've distributed ownership and the way that we've

446
00:27:27,798 --> 00:27:31,030
distributed the code itself. Right hands. We've broken apart

447
00:27:31,190 --> 00:27:34,414
the application to these more loosely coupled parts. The trace is really

448
00:27:34,452 --> 00:27:37,150
critical to understanding how to respond to these events.

449
00:27:38,690 --> 00:27:42,414
I want to touch briefly on one other part of being on call hands,

450
00:27:42,452 --> 00:27:45,130
that's writing, sharing and reviewing postmortems.

451
00:27:45,290 --> 00:27:49,458
Postmortems, I think are really important part, even if they're not sort of the

452
00:27:49,544 --> 00:27:52,340
same adrenaline rush that being paged is.

453
00:27:53,030 --> 00:27:56,674
But it's really about repeating issues that might

454
00:27:56,712 --> 00:28:00,850
come up again hands, maybe more importantly about improving responses,

455
00:28:00,930 --> 00:28:04,326
because the same issues sre not always going to come up over and

456
00:28:04,348 --> 00:28:07,240
again. So how can we respond better to a novel issue next time?

457
00:28:08,170 --> 00:28:10,918
And for post mortems to really be blameless,

458
00:28:11,014 --> 00:28:14,378
establishing what happened in an objective way is really important.

459
00:28:14,544 --> 00:28:18,662
And I've seen again and again that doing this through real telemetry,

460
00:28:18,726 --> 00:28:21,910
especially in a distributed system, using tracing, is really important.

461
00:28:22,000 --> 00:28:25,918
So I can think of a number of times

462
00:28:26,004 --> 00:28:29,546
when in the writing or the reviewing of a post mortem,

463
00:28:29,578 --> 00:28:33,230
there is essentially a disagreement about whose fault a latency problem is.

464
00:28:33,300 --> 00:28:36,994
Right? Is it service a is making an incorrect call

465
00:28:37,032 --> 00:28:40,434
or is configured incorrectly? Or is it service b is too slow in servicing that

466
00:28:40,472 --> 00:28:43,758
request? And if you look at aggregates, if you're

467
00:28:43,774 --> 00:28:47,010
just looking at something like p 50 latency,

468
00:28:47,350 --> 00:28:50,806
those two teams can have a pretty different perspective of what's going on, especially if

469
00:28:50,828 --> 00:28:54,278
they're not accounting for things like the network in between, and if they're not

470
00:28:54,364 --> 00:28:57,990
really making sure that they're pairing up slow requests on one side with

471
00:28:58,140 --> 00:29:01,478
the same kind of corresponding requests on the other side. And what tracing helps

472
00:29:01,494 --> 00:29:04,778
you do is really understand those causal relationships, right? It allows you to

473
00:29:04,784 --> 00:29:08,362
pair up a slow request on one side with one service

474
00:29:08,496 --> 00:29:12,086
with the response that was part of that request on the other side, and really

475
00:29:12,128 --> 00:29:14,654
understand if that slowness is responsible there.

476
00:29:14,692 --> 00:29:18,320
And look at the logs, look at the request parameters to understand

477
00:29:18,690 --> 00:29:21,600
what service needs to change in order to improve things.

478
00:29:23,190 --> 00:29:26,900
So yeah, obviously improving on call is important,

479
00:29:28,150 --> 00:29:31,570
not just for the obvious reasons, right. That whats

480
00:29:31,640 --> 00:29:35,634
has real impact on your, on your customers experience and on revenue and reputation

481
00:29:35,682 --> 00:29:39,334
and things like that. But it has a cost internally as well,

482
00:29:39,372 --> 00:29:43,670
right? Because time spent handling pages, writing post mortems,

483
00:29:44,010 --> 00:29:47,574
handling those interrupts, that's time that developers and

484
00:29:47,612 --> 00:29:51,830
engineers are not spending building new features or doing proactive optimization.

485
00:29:51,910 --> 00:29:55,194
Right? So there's a cost to that. And then the

486
00:29:55,232 --> 00:29:58,886
stress of being on call has a major impact, I think, on job satisfaction

487
00:29:58,918 --> 00:30:02,574
for a lot of developers. And so thinking

488
00:30:02,612 --> 00:30:06,446
about that stress that can be mitigated by

489
00:30:06,468 --> 00:30:09,790
improving on call, it can be mitigated by having good documentation.

490
00:30:10,690 --> 00:30:13,854
And I mentioned reducing the number of pages is also a great

491
00:30:13,892 --> 00:30:17,198
way of improving on call. Like giving teams the agency

492
00:30:17,294 --> 00:30:21,006
to do that. Right? Like giving teams the agency to say, hey, look, this alert

493
00:30:21,038 --> 00:30:24,482
is not valuable, right? It's not helping us meet

494
00:30:24,536 --> 00:30:27,746
our goals and so we want to delete it. And that's actually going

495
00:30:27,768 --> 00:30:30,950
to make our lives better and make us more productive.

496
00:30:31,690 --> 00:30:34,726
But like I said, we need to understand their goals, right? So how do we

497
00:30:34,748 --> 00:30:38,546
think about holding teams accountable for on call? Like what are the goals

498
00:30:38,658 --> 00:30:42,682
in a way that we can measure? Right. Well, that brings me to my next

499
00:30:42,736 --> 00:30:46,314
topic, which is to talk about Slos. So service level

500
00:30:46,352 --> 00:30:49,690
objectives, again, I'm just going to give kind of

501
00:30:49,760 --> 00:30:52,986
a whirlwind kind of intro to these. There's a lot

502
00:30:53,008 --> 00:30:56,574
more that could be said, obviously, but these are promises that service owners make

503
00:30:56,612 --> 00:30:59,982
to their customers, right? And those could both be

504
00:31:00,036 --> 00:31:03,946
internal customers, these other people within your organization, or end users people external

505
00:31:03,978 --> 00:31:07,486
to your organization. And what's important about an slos is that it's stated

506
00:31:07,518 --> 00:31:10,798
in a way that can be measured on relatively short timescales.

507
00:31:10,974 --> 00:31:14,020
So to give an example of what an SLO looks like,

508
00:31:14,630 --> 00:31:18,226
it might be something like 99th percentile latency should be less than 5

509
00:31:18,248 --> 00:31:21,800
seconds over the last five minutes. And to kind of break this down.

510
00:31:22,410 --> 00:31:25,426
So the first part is the service level indicator. That's the metric,

511
00:31:25,458 --> 00:31:28,738
these thing you're measuring, right. The second part is the threshold.

512
00:31:28,834 --> 00:31:32,006
That's kind of the goal in a way. And usually this is expressed as an

513
00:31:32,028 --> 00:31:35,274
inequality, right. We want to keep latency down and then finally

514
00:31:35,312 --> 00:31:38,474
we have the evaluation window. And I'll say a bit more about that

515
00:31:38,512 --> 00:31:42,426
in a second, but that's really important for making sure that we're measuring things in

516
00:31:42,448 --> 00:31:46,142
a consistent and precise way. So just to give some examples of

517
00:31:46,196 --> 00:31:49,614
other sorts of indicators. So I mentioned latency. You might choose different

518
00:31:49,652 --> 00:31:53,166
percentiles depending on what's important to your customers. You might

519
00:31:53,188 --> 00:31:56,962
measure error rate. That's important for a lot of folks. Availability is often

520
00:31:57,016 --> 00:32:00,562
something whats is promised to customers as well. Depending on your business.

521
00:32:00,616 --> 00:32:04,580
You might also measure something like durability or throughput as well.

522
00:32:05,770 --> 00:32:09,750
So I mentioned the way that you measure

523
00:32:10,890 --> 00:32:14,502
these Slis is important and things idea of

524
00:32:14,556 --> 00:32:18,066
a window. So when we look at a dashboard that's

525
00:32:18,098 --> 00:32:21,974
showing something like latency, usually what that's showing is what you might call instantaneous

526
00:32:22,022 --> 00:32:25,546
latency. And that's good. That's usually these

527
00:32:25,568 --> 00:32:28,906
default and that's what we want to see when we're in the middle of an

528
00:32:28,928 --> 00:32:32,478
incident. Right. Because that's going to be the most responsive way of measuring this.

529
00:32:32,644 --> 00:32:36,906
But if you're trying to measure an slO, the problem with instantaneous

530
00:32:36,938 --> 00:32:40,586
latency is if you look on narrower and narrower timescales,

531
00:32:40,618 --> 00:32:43,946
it can actually significantly change the value of it. And if there's

532
00:32:43,978 --> 00:32:47,106
one thing that's important about slos, it's that we all agree on what

533
00:32:47,128 --> 00:32:50,226
the definition is and whats we're all measuring it in the same way.

534
00:32:50,328 --> 00:32:53,666
And so when we look at something like latency for an

535
00:32:53,688 --> 00:32:57,314
SLO, we're really going to talk about measuring it over something like the last five

536
00:32:57,352 --> 00:33:00,854
minutes or over a five minute window. And really what that's doing is looking at

537
00:33:00,892 --> 00:33:04,182
all of the requests over that five minute window. If we're looking at P 99,

538
00:33:04,236 --> 00:33:08,086
then looking at the fastest 99% of

539
00:33:08,108 --> 00:33:11,770
those requests hands, making sure that all of them fit under some threshold.

540
00:33:12,110 --> 00:33:15,606
Okay, great. So how do we determine

541
00:33:15,638 --> 00:33:19,020
slos? Well, there's a bunch of questions that you need to ask yourself.

542
00:33:19,390 --> 00:33:22,622
The first one is, what do your customers expect? What have you promised them already?

543
00:33:22,676 --> 00:33:25,774
Right. You might be legally bound to provide a certain level

544
00:33:25,812 --> 00:33:29,502
of service, or it might just be that there's an expectation and you can

545
00:33:29,556 --> 00:33:33,006
measure conversion and things like

546
00:33:33,028 --> 00:33:36,686
that. To understand that users get bored and leave if

547
00:33:36,708 --> 00:33:40,242
it takes too long to service requests. Youve should also ask what you can provide

548
00:33:40,296 --> 00:33:43,346
today, right. There's no reason to set an Slo that you're not going

549
00:33:43,368 --> 00:33:45,394
to be able to meet or that you're not going to be able to meet

550
00:33:45,432 --> 00:33:49,334
anytime soon. And so thinking about what is the

551
00:33:49,372 --> 00:33:53,078
product roadmap look like? How much time do we have on

552
00:33:53,084 --> 00:33:57,206
the engineering team to make changes to improve performance or reliability and

553
00:33:57,228 --> 00:33:59,926
making sure that these all line up so that we're doing the best we can

554
00:33:59,948 --> 00:34:03,500
for our customers while providing the functionality that they need at the same time.

555
00:34:04,110 --> 00:34:07,226
Okay, so how do we actually do

556
00:34:07,248 --> 00:34:11,374
that? Right. Let me take a really small, simple example. So say

557
00:34:11,412 --> 00:34:14,586
here's a simple microservice

558
00:34:14,618 --> 00:34:17,918
based application, just three services in this case,

559
00:34:18,004 --> 00:34:22,254
and say whats we've promised our customers that

560
00:34:22,292 --> 00:34:26,034
will serve requests 99%

561
00:34:26,072 --> 00:34:29,342
of the time within 5 seconds. And of course under some evaluation

562
00:34:29,406 --> 00:34:33,042
window and for service a,

563
00:34:33,096 --> 00:34:37,134
the one that's, that's labeled a at the top here, that sort of translates

564
00:34:37,182 --> 00:34:40,040
immediately to what they're on the hook to provide.

565
00:34:40,490 --> 00:34:44,214
But what about internal services? Right? How should this map to

566
00:34:44,252 --> 00:34:47,286
service be? Right, so let's look at a trace, right?

567
00:34:47,308 --> 00:34:50,182
So how does a request actually flow through these things?

568
00:34:50,316 --> 00:34:53,654
And you probably want to look at more than one trace,

569
00:34:53,702 --> 00:34:57,180
in fact. But I just pulled out one here just as an example.

570
00:34:57,950 --> 00:35:01,834
So now that we see this, we can see, it looks

571
00:35:01,872 --> 00:35:05,486
like today, at least in this example, service b is actually responsible for

572
00:35:05,508 --> 00:35:09,102
a lot of the latency of service a. So we can also

573
00:35:09,156 --> 00:35:12,110
give a kind of similar bound to service b in a lot of ways.

574
00:35:12,260 --> 00:35:15,086
That is, it also needs to be able to serve p 99 latency in less

575
00:35:15,108 --> 00:35:18,306
than 5 seconds. But what's interesting is that, sure,

576
00:35:18,408 --> 00:35:22,322
in the kind of services diagram, there's one arrow between b and c,

577
00:35:22,456 --> 00:35:26,594
but in this request, there's actually two requests from b to c that happen

578
00:35:26,632 --> 00:35:29,766
in serial, which means that we need c to

579
00:35:29,788 --> 00:35:32,966
be twice as fast. Right? So maybe things is what

580
00:35:32,988 --> 00:35:36,534
you were thinking, whats p 99 latency for

581
00:35:36,572 --> 00:35:40,646
C needs to be less than two and a half seconds. If you think

582
00:35:40,668 --> 00:35:43,914
about it, maybe for another minute, you realize that that's not quite

583
00:35:43,952 --> 00:35:48,026
correct either. In fact, there's two chances for C to

584
00:35:48,048 --> 00:35:51,194
fail in this case as well, right? So there's two chances for C

585
00:35:51,232 --> 00:35:54,282
to serve in a server request in more than two and a half seconds.

586
00:35:54,346 --> 00:36:00,080
So we actually need the bound to be even tighter than that. It's around 99.5

587
00:36:00,610 --> 00:36:04,426
percentile latency, and that's

588
00:36:04,458 --> 00:36:06,980
sort of how we can pass that down to c.

589
00:36:08,150 --> 00:36:11,474
Now what's kind of interesting in this is it might be that in some other

590
00:36:11,512 --> 00:36:14,514
cases that b also depends on another service D.

591
00:36:14,712 --> 00:36:18,306
But at least in terms of this request, in terms of servicing

592
00:36:18,338 --> 00:36:21,750
a request that came from A, B doesn't depend

593
00:36:21,820 --> 00:36:26,370
on D at all, right? And so thinking about D's slos,

594
00:36:26,450 --> 00:36:29,398
actually, we don't have any information to do that from this case. So looking at

595
00:36:29,404 --> 00:36:32,694
traces is really important. It's not just enough to look at the service diagram.

596
00:36:32,742 --> 00:36:36,060
The trace is really going to tell you what's going to help you there.

597
00:36:37,070 --> 00:36:40,746
Okay, so why are slos important? They are

598
00:36:40,768 --> 00:36:44,574
really about measuring success in delivering a service, they're about measuring success for on

599
00:36:44,612 --> 00:36:48,330
call. Right. These teams can use them as a guide

600
00:36:48,410 --> 00:36:52,560
to prioritize work. So if we've established an slo, we can now

601
00:36:53,090 --> 00:36:56,226
understand how much improvement we need to make and we can use that to

602
00:36:56,248 --> 00:36:58,930
trade off against, say, new feature development.

603
00:36:59,670 --> 00:37:03,806
And it's a way of really holding

604
00:37:03,838 --> 00:37:07,362
teams accountable consistently across your right. So you want to make sure

605
00:37:07,416 --> 00:37:10,934
that as folks move from one team to another that they're not learning new ways

606
00:37:10,972 --> 00:37:14,578
of doing this. And if you're going to measure teams performance

607
00:37:14,674 --> 00:37:18,630
by their ability to meet their slos, it's really important that you do that consistently

608
00:37:18,710 --> 00:37:21,820
as well. And then

609
00:37:23,950 --> 00:37:27,754
finally, yeah, these are all things ways about thinking about

610
00:37:27,792 --> 00:37:31,862
accountability. But agency is also really important too. And slos

611
00:37:31,926 --> 00:37:35,662
are really a way of giving folks a budget for thinking about how much room

612
00:37:35,716 --> 00:37:38,974
they have to push more

613
00:37:39,012 --> 00:37:42,682
deployments out there. Right? Like how close are they to hitting their slos?

614
00:37:42,746 --> 00:37:45,826
And that's really a way for them to build can error budget as well.

615
00:37:46,008 --> 00:37:49,474
Okay, so just kind of review my three piece

616
00:37:49,512 --> 00:37:53,298
puzzle here. So documentation obviously is

617
00:37:53,304 --> 00:37:57,006
an important part of that. I think more important than just documentation for documentation's sake.

618
00:37:57,038 --> 00:38:00,594
But it's a way of establishing ownership hands knowing who is going to be held

619
00:38:00,642 --> 00:38:03,958
accountable. But if you're going to do that, it absolutely has to

620
00:38:03,964 --> 00:38:07,806
be up to date, right? You can't hold people accountable to documentation

621
00:38:07,938 --> 00:38:10,220
based upon documentation that's out of date.

622
00:38:11,950 --> 00:38:15,610
It's also really critical in building confidence within those teams

623
00:38:16,030 --> 00:38:19,526
hands. Along with tools

624
00:38:19,558 --> 00:38:24,174
that describe the dynamic state of a system. It's critical information for

625
00:38:24,212 --> 00:38:27,710
folks that are on call or need to understand how a system is actually behaving

626
00:38:28,050 --> 00:38:31,374
on call. Obviously youve can't do business without it.

627
00:38:31,572 --> 00:38:34,702
Incident management is often the part that people think about

628
00:38:34,756 --> 00:38:38,398
most. When you say service ownership, but I

629
00:38:38,404 --> 00:38:41,342
want to call it that, on call has a lot of other components to it

630
00:38:41,396 --> 00:38:45,640
too. A lot of those are really tools and hands.

631
00:38:46,490 --> 00:38:50,034
Finally, Slos, right. These are really like how you hold teams

632
00:38:50,082 --> 00:38:56,582
accountable, like I said, how you measure their success hands

633
00:38:56,716 --> 00:39:00,338
in all of this. I think in a system where you have a loosely coupled

634
00:39:00,354 --> 00:39:03,654
architecture where you have teams, whats are moving independently, tracing is really

635
00:39:03,692 --> 00:39:07,494
critical to understanding causality in that system, to understanding who

636
00:39:07,532 --> 00:39:11,578
is responsible for at a given moment in time, which services are actually contributing

637
00:39:11,594 --> 00:39:14,606
to latency. And if you don't have that information, you're not going to be able

638
00:39:14,628 --> 00:39:16,686
to keep your documentation up to date. You're not going to be able to make

639
00:39:16,708 --> 00:39:19,182
good decisions while you're on call and you're not going to be able to set

640
00:39:19,236 --> 00:39:22,560
slos in a way that actually reflects what your customers expect.

641
00:39:22,870 --> 00:39:25,758
Okay, so I mentioned error budgets.

642
00:39:25,854 --> 00:39:29,300
That's really just one kind of budget. And I think

643
00:39:31,350 --> 00:39:34,766
giving folks budget to improve reliability and giving them agency

644
00:39:34,798 --> 00:39:37,550
to do that will help them hit their goals and will lower their stress.

645
00:39:37,710 --> 00:39:41,190
But that agency requires them having the right information and the time to do it.

646
00:39:41,260 --> 00:39:44,486
And so this really comes down to ownership doesn't come for free. You've got to

647
00:39:44,508 --> 00:39:47,560
give your teams time to actually invest.

648
00:39:48,110 --> 00:39:51,260
You've got to give them time to improve and to make things better.

649
00:39:52,430 --> 00:39:56,346
Okay, so, sounds great. How do we get this right? Where do we start?

650
00:39:56,448 --> 00:39:59,814
Well, making changes

651
00:39:59,952 --> 00:40:03,230
in a DevOps organization, it's hard,

652
00:40:03,300 --> 00:40:07,086
right? Rolling out new tools and new processes always has to

653
00:40:07,108 --> 00:40:08,880
be a bottom up thing.

654
00:40:10,130 --> 00:40:13,386
And whether that's how you run your sprints, which tools

655
00:40:13,418 --> 00:40:16,740
you choose to do, developers, what observability tools you use.

656
00:40:17,430 --> 00:40:20,930
If they're going to be adopted, they really have to provide value to

657
00:40:21,000 --> 00:40:24,434
those application development teams. And ideally more than

658
00:40:24,472 --> 00:40:27,830
provide value, they would be a necessary part of their day to day work.

659
00:40:27,980 --> 00:40:31,846
If you don't have those things, at least in my experience, it's just

660
00:40:31,868 --> 00:40:35,526
going to be a long, long uphill road to get those

661
00:40:35,548 --> 00:40:37,430
things deployed and adopted.

662
00:40:38,570 --> 00:40:42,058
Then to establish hands, maintain service ownership, use a

663
00:40:42,064 --> 00:40:46,438
communication of documentation, on call process and slos, and manufacture

664
00:40:46,534 --> 00:40:50,186
a need for those tools, hands processes where necessary. Right. So what I mean by

665
00:40:50,208 --> 00:40:54,222
that is just to say make it a requirement to have service

666
00:40:54,276 --> 00:40:57,518
ownership defined within the documentation before a service can

667
00:40:57,524 --> 00:41:00,926
be defined, before it can be part of the deployment pipeline, like I mentioned.

668
00:41:01,108 --> 00:41:05,022
So as a platform team, as part of

669
00:41:05,156 --> 00:41:09,074
engineering leadership, you have the ability to actually make

670
00:41:09,112 --> 00:41:12,466
these processes required in a way, and if you do that, that'll actually go a

671
00:41:12,488 --> 00:41:15,638
long way towards them being adopted hands becoming part of the

672
00:41:15,644 --> 00:41:17,910
tool set of the folks in your organization.

673
00:41:20,410 --> 00:41:24,326
Okay, so just to kind of sum up, I think of ownership is

674
00:41:24,348 --> 00:41:27,686
really having two parts. Obviously, accountability is a big

675
00:41:27,708 --> 00:41:30,778
part of it. I think that's what folks think about a lot when they think

676
00:41:30,784 --> 00:41:34,746
about ownership hands. That's really setting the

677
00:41:34,768 --> 00:41:38,134
deliverables and the goals for the owners within your organization

678
00:41:38,262 --> 00:41:42,610
and making sure that youve evaluating their performance based upon those goals and deliverables.

679
00:41:42,630 --> 00:41:46,186
Right. That's really how youve make those things sink

680
00:41:46,218 --> 00:41:49,566
in. And I think a second and equally important part is to give

681
00:41:49,588 --> 00:41:52,382
those teams, agency agency to make change. Right.

682
00:41:52,436 --> 00:41:56,190
So they're going to be a lot more inclined and a lot happier oncall

683
00:41:56,260 --> 00:41:59,982
if they're able to control and make changes to the kinds of alerts they get,

684
00:42:00,036 --> 00:42:03,438
if they're able to make changes to the architecture itself. Right. So making sure

685
00:42:03,444 --> 00:42:06,754
that you're offering them the information nation, allowing them to build confidence

686
00:42:06,802 --> 00:42:10,166
and giving them these budget to improve is really critical, I think,

687
00:42:10,268 --> 00:42:13,766
in establishing service ownership. So with

688
00:42:13,788 --> 00:42:17,542
that, I wanted to thank everyone for your attention. You can find me

689
00:42:17,596 --> 00:42:21,734
at Dave Spoons on Twitter. You can find me@lightstep.com

690
00:42:21,852 --> 00:42:25,378
I'm always excited to talk about service ownership. I'm always excited to talk about distributed

691
00:42:25,394 --> 00:42:25,954
tracing.

