1
00:01:28,450 --> 00:01:32,230
Hello, my name is Alpersanavji and

2
00:01:32,380 --> 00:01:36,280
I will talk about distributed transactions service mesh search mesh today.

3
00:01:37,370 --> 00:01:39,910
Let me introduce myself in the beginning,

4
00:01:41,170 --> 00:01:44,938
as I mentioned, I'm Mark Personavji and I'm working as a software developer

5
00:01:45,034 --> 00:01:49,070
at Zapata Computing and I'm currently

6
00:01:49,140 --> 00:01:52,974
working with the platform team. We are dealing with the cloud native issues.

7
00:01:53,172 --> 00:01:57,022
We are building the backend applications

8
00:01:57,086 --> 00:02:01,540
for the quantum engine for the quantum computing team

9
00:02:02,230 --> 00:02:06,070
and you can always access me, you can always reach me using my email

10
00:02:06,140 --> 00:02:09,400
which is alpersonalgy@gmail.com.

11
00:02:12,730 --> 00:02:17,314
Let's start our talk with imagining a large

12
00:02:17,452 --> 00:02:21,734
ecommerce business. Imagine that this ecommerce

13
00:02:21,782 --> 00:02:25,402
business has thousands of transactions per day

14
00:02:25,536 --> 00:02:29,690
and there are multiple variety of goods exist

15
00:02:30,370 --> 00:02:34,414
in the business. There are multiple applications and time zones that

16
00:02:34,532 --> 00:02:38,346
people are using. Our business, our websites,

17
00:02:38,538 --> 00:02:42,538
maybe we have multiple websites. And also imagine that

18
00:02:42,564 --> 00:02:46,786
you are a developer in this company and you have more

19
00:02:46,808 --> 00:02:50,398
than hundreds of colleagues, technical colleagues

20
00:02:50,574 --> 00:02:54,850
working on the applications and also DevOps.

21
00:02:55,290 --> 00:02:58,390
And you have multiple specialized teams.

22
00:02:59,130 --> 00:03:02,966
So these specialized teams are

23
00:03:02,988 --> 00:03:07,240
also working in different locations and remote work. We can say that this is the

24
00:03:07,870 --> 00:03:11,370
modern enterprise company structure.

25
00:03:12,190 --> 00:03:15,914
So one day your CTO or your

26
00:03:15,952 --> 00:03:18,940
executives come to you and ask this question.

27
00:03:22,210 --> 00:03:26,026
It will be in your hands. How do you set up our software

28
00:03:26,058 --> 00:03:29,440
architecture from scratch? Which approach will we use?

29
00:03:30,530 --> 00:03:34,510
Will you use a monolith or. We use a microservices

30
00:03:34,590 --> 00:03:37,922
approach. So when we are talking

31
00:03:37,976 --> 00:03:42,238
about monolith and microservices, this is not just a simple approach.

32
00:03:42,334 --> 00:03:45,860
There are multiple then different approaches that you can think

33
00:03:46,250 --> 00:03:49,894
when we call these approaches. But just we

34
00:03:49,932 --> 00:03:53,958
know that monolith is really difficult for these

35
00:03:54,044 --> 00:03:58,170
kind of enterprises and we will most likely eventually

36
00:03:59,790 --> 00:04:03,290
come to a point that we will use microservices approach.

37
00:04:03,950 --> 00:04:07,962
So eventually you choose Microsoft architecture, but the

38
00:04:08,016 --> 00:04:10,060
problems just start with there.

39
00:04:11,330 --> 00:04:15,530
Firstly, you will have multiple different technologies

40
00:04:15,690 --> 00:04:19,482
running on different environments

41
00:04:19,626 --> 00:04:23,342
and you need to make them run stable

42
00:04:23,406 --> 00:04:26,530
and reliably without

43
00:04:26,600 --> 00:04:30,034
having any issues. So you might have front end

44
00:04:30,072 --> 00:04:33,442
services, you might have back end services that are talking

45
00:04:33,496 --> 00:04:35,830
to each other. There will be clients,

46
00:04:36,810 --> 00:04:40,438
external clients that are accessing to your front end services

47
00:04:40,524 --> 00:04:45,030
most likely. And there might be some message brokers

48
00:04:46,890 --> 00:04:50,874
that is used to communicate these services. And there

49
00:04:50,912 --> 00:04:54,566
will be most likely some multiple different system of records,

50
00:04:54,678 --> 00:04:57,866
third party libraries and so on. So you need

51
00:04:57,888 --> 00:05:01,294
to deal with lots of problems. First, we need

52
00:05:01,332 --> 00:05:04,526
to understand where we set

53
00:05:04,548 --> 00:05:08,234
up our microservices, our microservices,

54
00:05:08,282 --> 00:05:12,918
as you know, in the modern ecosystems,

55
00:05:12,954 --> 00:05:16,594
application ecosystems, they are most likely in

56
00:05:16,632 --> 00:05:20,306
a containerized environment which we

57
00:05:20,408 --> 00:05:24,034
most likely will be using Docker for container, as a

58
00:05:24,072 --> 00:05:27,442
container engine and there as the container orchestration

59
00:05:27,506 --> 00:05:29,750
tool, we will be most likely using Kubernetes.

60
00:05:31,610 --> 00:05:36,086
And as the number of Microsoft increase then you

61
00:05:36,108 --> 00:05:39,686
will need new tools. And you know that the number of Microsofts

62
00:05:39,718 --> 00:05:43,254
will increase even in time because you will need new features

63
00:05:43,302 --> 00:05:45,290
and also you will need some scalability.

64
00:05:46,350 --> 00:05:50,166
You will end up with some scalability issues, so the

65
00:05:50,208 --> 00:05:54,158
number will increase. And with these new tools, actually you

66
00:05:54,164 --> 00:05:57,546
will need new tools because you will need more ease

67
00:05:57,578 --> 00:06:00,190
of maintenance on your application environment.

68
00:06:00,530 --> 00:06:04,066
So these new tools will include some kind

69
00:06:04,088 --> 00:06:07,010
of service mesh. So what's the service mesh?

70
00:06:08,310 --> 00:06:13,300
This service mesh is an infrastructure layer application and

71
00:06:15,770 --> 00:06:19,970
it runs in the infrastructure layer and enables the security secure communication

72
00:06:20,050 --> 00:06:24,562
in the infrastructures among

73
00:06:24,626 --> 00:06:28,202
services. So we can say that it is handing over

74
00:06:28,256 --> 00:06:32,586
the east to west communication among services.

75
00:06:32,768 --> 00:06:36,730
And by taking over this communication

76
00:06:38,350 --> 00:06:42,160
you can control the whole

77
00:06:42,530 --> 00:06:45,760
interaction between these services. For example,

78
00:06:46,930 --> 00:06:50,046
by taking over the communication, you can

79
00:06:50,068 --> 00:06:53,330
manage the traffic posts, you can manage the security,

80
00:06:53,480 --> 00:06:57,140
and also you can provide some observability to your

81
00:06:57,590 --> 00:06:59,410
developers and users.

82
00:07:00,950 --> 00:07:04,802
Currently there are multiple service mesh products, but the

83
00:07:04,856 --> 00:07:07,810
top three is istio, console and linkerd.

84
00:07:07,890 --> 00:07:11,830
The most popular one is the istio which we will also use on our demonstration,

85
00:07:13,290 --> 00:07:16,406
but Linkerd and console are also used. There are

86
00:07:16,428 --> 00:07:20,454
also some other applications that the implementations

87
00:07:20,502 --> 00:07:24,234
of service mesh okay, we set

88
00:07:24,272 --> 00:07:27,674
up our service mesh and we tried to solve some

89
00:07:27,712 --> 00:07:28,300
issues,

90
00:07:31,410 --> 00:07:35,502
but since you have multiple services and multiple system

91
00:07:35,556 --> 00:07:39,454
of records, you will most likely end up with dual write

92
00:07:39,492 --> 00:07:42,910
problems which we will mention in a few seconds.

93
00:07:44,630 --> 00:07:48,210
This means that you will need to access multiple

94
00:07:48,790 --> 00:07:52,786
system of records at the same time and you

95
00:07:52,808 --> 00:07:54,770
will need transactional operations.

96
00:07:55,450 --> 00:07:58,882
So since you are running in a distributed environment,

97
00:07:58,946 --> 00:08:02,694
prepare yourself to distribute transactions. Let's talk

98
00:08:02,732 --> 00:08:05,430
about the dual write problem in the beginning.

99
00:08:06,010 --> 00:08:09,674
So this represents a

100
00:08:09,792 --> 00:08:13,500
really small part of our large ecommerce business.

101
00:08:14,510 --> 00:08:18,614
Imagine that there's a front end service that accept the request

102
00:08:18,662 --> 00:08:22,210
from the user and starts a transaction.

103
00:08:22,310 --> 00:08:26,190
Transaction. This transaction can be something

104
00:08:26,260 --> 00:08:30,080
like purchasing a good from your website

105
00:08:30,930 --> 00:08:34,186
and most likely you will be accessing multiple

106
00:08:34,218 --> 00:08:37,602
servers at the same time and you will need to run them in the same

107
00:08:37,656 --> 00:08:41,698
transaction boundary. For instance, you might need to access

108
00:08:41,784 --> 00:08:45,318
user service, product service and banking service at the same time.

109
00:08:45,404 --> 00:08:50,786
And these might be accessing to separate

110
00:08:50,818 --> 00:08:54,146
databases, different databases. For instance like this user DB,

111
00:08:54,258 --> 00:08:56,390
banking DB or product DB.

112
00:08:57,950 --> 00:09:01,674
And if the banking service, for instance, if one of

113
00:09:01,712 --> 00:09:05,146
our services crashes, imagine that

114
00:09:05,168 --> 00:09:08,966
we cannot access the banking service in this transaction. We need to roll

115
00:09:08,998 --> 00:09:12,302
back our updates on the product service

116
00:09:12,356 --> 00:09:13,520
and user service.

117
00:09:15,010 --> 00:09:18,800
So let's demonstrations this problem and

118
00:09:19,970 --> 00:09:24,174
we will try to understand more. So firstly

119
00:09:24,302 --> 00:09:30,354
we will have this

120
00:09:30,392 --> 00:09:33,010
similar environment in our demonstrations.

121
00:09:34,630 --> 00:09:38,902
So let's first see our application.

122
00:09:39,036 --> 00:09:42,790
Yeah, we will have multiple services, we will have the user service

123
00:09:42,940 --> 00:09:47,046
and we will have deployment for

124
00:09:47,068 --> 00:09:50,060
the user service, another deployment for the product service,

125
00:09:50,830 --> 00:09:54,540
another deployment for the banking service and

126
00:09:54,990 --> 00:09:58,746
the one that will serve as the front end service will be

127
00:09:58,768 --> 00:10:02,666
the ecommerce service. And as you can see here, this ecommerce rule

128
00:10:02,698 --> 00:10:06,798
will know about the other three services so

129
00:10:06,964 --> 00:10:10,160
it can communicate to these services.

130
00:10:11,330 --> 00:10:19,070
So let's apply this one's

131
00:10:20,450 --> 00:10:24,434
our deployments is being applied as

132
00:10:24,472 --> 00:10:27,060
we have source by the way.

133
00:10:27,430 --> 00:10:31,014
Meanwhile these source are created. I also

134
00:10:31,052 --> 00:10:36,070
need to mention we have already installed Istio

135
00:10:36,810 --> 00:10:41,100
in our environment. So let's see get services

136
00:10:43,550 --> 00:10:45,580
istio system.

137
00:10:47,230 --> 00:10:50,526
So you can see that there are multiple sources running for

138
00:10:50,548 --> 00:10:55,294
the istio. So when

139
00:10:55,332 --> 00:10:58,426
we check the pods existing in the default namespace,

140
00:10:58,538 --> 00:11:02,206
you will see our pods are now running and

141
00:11:02,228 --> 00:11:05,614
you will see that there will be two ready containers

142
00:11:05,662 --> 00:11:09,458
in each pod. One of them will be the actual pod for the application

143
00:11:09,544 --> 00:11:13,694
and the second one will be the sidecar,

144
00:11:13,822 --> 00:11:17,190
the proxy sidecar for the istio service

145
00:11:17,260 --> 00:11:20,838
mesh. So our service are running,

146
00:11:20,924 --> 00:11:24,902
our pods are running. Let's check the services to get

147
00:11:24,956 --> 00:11:28,186
the external IP for the front end service.

148
00:11:28,288 --> 00:11:32,138
This is the external IP that we'll be using and

149
00:11:32,304 --> 00:11:36,042
we have also our Kiali front end

150
00:11:36,096 --> 00:11:40,042
to see the running services. This is the

151
00:11:40,096 --> 00:11:43,550
tools that come out of the box with istio service

152
00:11:43,620 --> 00:11:47,678
mesh. So you can see that the default Kubernetes service

153
00:11:47,764 --> 00:11:51,440
and also the other services that we are running are all here.

154
00:11:52,390 --> 00:11:56,994
So let's try to access our front

155
00:11:57,032 --> 00:12:00,626
end which will be running on the

156
00:12:00,648 --> 00:12:02,260
881 port.

157
00:12:04,970 --> 00:12:09,000
Yes, this is the simple front end

158
00:12:09,450 --> 00:12:13,094
for our ecommerce. You can see that there's only

159
00:12:13,132 --> 00:12:17,438
a single product and there are multiple information, there are multiple

160
00:12:17,634 --> 00:12:21,594
info about the product and also the user and the store itself.

161
00:12:21,792 --> 00:12:26,330
So we get these product

162
00:12:26,400 --> 00:12:29,990
information, the price, the stock and other information

163
00:12:30,160 --> 00:12:33,786
from the product service. And we have a available user

164
00:12:33,818 --> 00:12:36,590
credits here which is 10,000 pounds.

165
00:12:37,330 --> 00:12:41,214
You can imagine this one as some kind of

166
00:12:41,332 --> 00:12:44,958
available credits to the user which might be already

167
00:12:45,044 --> 00:12:49,066
applied by get by a voucher

168
00:12:49,098 --> 00:12:52,558
or something like that. So we will be using

169
00:12:52,644 --> 00:12:56,326
these credits and this will be also so accessing to

170
00:12:56,348 --> 00:13:00,006
the user service. So let's try to add this

171
00:13:00,028 --> 00:13:04,086
basket and try to buy this product.

172
00:13:04,268 --> 00:13:08,054
So in this place, in this

173
00:13:08,092 --> 00:13:12,170
area, we will specify how many products

174
00:13:12,240 --> 00:13:15,786
that we are buying. Let's think that it will be. Let's imagine that it

175
00:13:15,808 --> 00:13:19,034
will be three. And you can see that this

176
00:13:19,072 --> 00:13:22,574
part will be deducted from your bank account. It means that

177
00:13:22,612 --> 00:13:26,430
in our application, this amount will be deducted

178
00:13:27,970 --> 00:13:31,950
from the banking service. So we are trying to access

179
00:13:32,020 --> 00:13:36,178
banking service and this part will be deducted from your

180
00:13:36,264 --> 00:13:39,442
available user credits. So let's say

181
00:13:39,496 --> 00:13:43,554
that you will get 3000 from

182
00:13:43,752 --> 00:13:47,586
our available user credits and the remaining

183
00:13:47,778 --> 00:13:51,720
10,500 pounds from the bank account.

184
00:13:52,570 --> 00:13:55,320
When I click on buy now,

185
00:13:56,170 --> 00:14:00,214
this application intentionally throws

186
00:14:00,262 --> 00:14:03,642
an error on the banking service.

187
00:14:03,776 --> 00:14:07,434
So we will see an error here.

188
00:14:07,552 --> 00:14:11,486
But what we expect is actually in the dual right problem that we

189
00:14:11,508 --> 00:14:15,278
are trying to demonstrate. Since we have an issue on the

190
00:14:15,284 --> 00:14:19,262
banking service, we don't need to change

191
00:14:19,316 --> 00:14:23,134
the product, the quantity, the stock of the

192
00:14:23,172 --> 00:14:26,674
products, since we haven't purchased these ones. And also

193
00:14:26,872 --> 00:14:30,178
we shouldn't see any issues with the available

194
00:14:30,264 --> 00:14:34,174
user credits. But since we don't have any transactional

195
00:14:34,302 --> 00:14:37,910
operation right now, we will have some problems.

196
00:14:38,060 --> 00:14:42,022
Let's click on buy now. Yes, we have seen

197
00:14:42,076 --> 00:14:45,286
the internal server error here. So let's go back to

198
00:14:45,308 --> 00:14:49,066
our main page. And now you can see that the product stock is

199
00:14:49,168 --> 00:14:52,458
now seven, which was ten

200
00:14:52,544 --> 00:14:56,794
in the beginning. Now we have three

201
00:14:56,832 --> 00:15:00,890
quantities left lost using

202
00:15:00,960 --> 00:15:04,510
the transaction. And also we can see that the

203
00:15:04,580 --> 00:15:08,206
current available user credit is 7000, which should be 10,000.

204
00:15:08,308 --> 00:15:12,426
Because we haven't completed the transaction, we had issues on the banking

205
00:15:12,458 --> 00:15:16,274
service. So this is the representation of the demonstrations of

206
00:15:16,312 --> 00:15:18,180
the dual right problem.

207
00:15:19,670 --> 00:15:22,962
So what we need to do to figure

208
00:15:23,016 --> 00:15:26,742
out this problem. There are multiple approaches that you can use,

209
00:15:26,796 --> 00:15:30,594
but the most popular ones are the two phase commit and distributed sagas.

210
00:15:30,722 --> 00:15:33,190
We will start with the two phase commit.

211
00:15:34,490 --> 00:15:37,994
This two phase commit is actually very similar to

212
00:15:38,032 --> 00:15:41,690
the local transactions. It is trying to approach the local

213
00:15:41,760 --> 00:15:45,366
transaction approach to the distributed

214
00:15:45,398 --> 00:15:48,826
environment. You will have a coordinator and there will

215
00:15:48,848 --> 00:15:51,600
be two phases. As mentioned in the name,

216
00:15:52,290 --> 00:15:55,470
the first phase will be the prepare phase.

217
00:15:55,810 --> 00:16:00,202
When the user try to start a transaction,

218
00:16:00,346 --> 00:16:03,582
the front end service will communicate to coordinator

219
00:16:03,646 --> 00:16:07,358
and the coordinator will start the first phase,

220
00:16:07,454 --> 00:16:11,074
the prepare phase. It will communicate to all of the services

221
00:16:11,192 --> 00:16:14,420
and ask for the changes to be ready.

222
00:16:14,790 --> 00:16:18,834
So they will make the changes ready and then they communicate

223
00:16:18,882 --> 00:16:22,134
back to the coordinator and say that yes, we are ready for

224
00:16:22,172 --> 00:16:25,474
the second phase. If any of the services fail

225
00:16:25,522 --> 00:16:29,606
in the first phase, then the coordinator will roll

226
00:16:29,638 --> 00:16:33,466
back the transaction by communicating again to the

227
00:16:33,488 --> 00:16:38,762
remaining services. But if every service says

228
00:16:38,816 --> 00:16:42,014
that we are ready for the commit based, then the

229
00:16:42,052 --> 00:16:45,610
coordinator will fail. The coordinator will commit the transaction.

230
00:16:45,770 --> 00:16:51,262
Yeah, as we mentioned, for instance, when the banking service says

231
00:16:51,316 --> 00:16:55,018
that it is not ready, I cannot commit, there is a problem on my side.

232
00:16:55,124 --> 00:16:58,626
Then the coordinator will call to user service and product service to

233
00:16:58,648 --> 00:17:02,286
roll back their changes. The advantages of the two phase commit

234
00:17:02,318 --> 00:17:05,250
is that the strong data comes consistency.

235
00:17:05,850 --> 00:17:09,798
So you

236
00:17:09,804 --> 00:17:13,254
will have the consistent data at all

237
00:17:13,292 --> 00:17:16,534
times. And also you will have the read

238
00:17:16,572 --> 00:17:19,946
write isolation because you

239
00:17:19,968 --> 00:17:23,354
will not have any stale reads or something like that. But the

240
00:17:23,392 --> 00:17:26,966
negatives or the disadvantages of the two phase

241
00:17:26,998 --> 00:17:30,874
committee is that it is a blocking

242
00:17:30,922 --> 00:17:33,200
approach. So when it is running,

243
00:17:35,010 --> 00:17:37,710
when you started transaction,

244
00:17:38,690 --> 00:17:44,558
you won't be accessing the same records

245
00:17:44,734 --> 00:17:48,526
at the same time. So it will be running blocking,

246
00:17:48,558 --> 00:17:51,826
which is a reallife big negative in a

247
00:17:51,848 --> 00:17:55,502
distributed environment. Another thing is that your data sources

248
00:17:55,566 --> 00:17:59,014
should be xa compatible and you might have some

249
00:17:59,052 --> 00:18:02,422
scalability issues because of the coordinator. And also

250
00:18:02,476 --> 00:18:05,942
again, since the coordinator is some kind of single point

251
00:18:05,996 --> 00:18:09,702
of failure, you need to handle the failures on the coordinator

252
00:18:09,846 --> 00:18:12,678
and figure out a solution.

253
00:18:12,854 --> 00:18:16,150
So the other approach is the distributed sagas,

254
00:18:16,310 --> 00:18:19,938
the distributed sagas that we will use also in our demonstrations.

255
00:18:20,134 --> 00:18:23,946
So this is a more suitable approach for distributed

256
00:18:23,978 --> 00:18:27,130
environments, because, you know, in the distributed environments,

257
00:18:27,290 --> 00:18:31,982
the applications are responsible for their own running

258
00:18:32,116 --> 00:18:35,938
without discussing any, without having to know

259
00:18:36,024 --> 00:18:39,314
of the others. So they are isolated from in some

260
00:18:39,352 --> 00:18:43,874
kind of terms. So again,

261
00:18:43,912 --> 00:18:47,590
in the distributed sagas, we can say that every service is

262
00:18:47,660 --> 00:18:51,190
responsible with its own transaction, and if

263
00:18:51,260 --> 00:18:54,610
it fails to perform the transaction, the operation,

264
00:18:54,690 --> 00:18:58,262
then it lets other know about its failure

265
00:18:58,326 --> 00:19:01,914
and the other services will take care

266
00:19:01,952 --> 00:19:05,818
of the rest by themselves. Imagine that

267
00:19:05,984 --> 00:19:09,578
we have the

268
00:19:09,664 --> 00:19:13,326
same scenarios. The user access to front end service

269
00:19:13,428 --> 00:19:17,630
and front end service will call. The application will start a transaction

270
00:19:18,050 --> 00:19:21,390
by just calling the services. The user service

271
00:19:21,460 --> 00:19:24,658
will start the transaction itself, the product service will start a

272
00:19:24,664 --> 00:19:27,940
transaction for itself, and the banking service will do so.

273
00:19:28,630 --> 00:19:32,114
And let's imagine that the banking service will fail again.

274
00:19:32,232 --> 00:19:35,634
When it fails, it will just call

275
00:19:35,672 --> 00:19:38,918
the compensation actions of the other services. So it will call the

276
00:19:38,924 --> 00:19:42,310
product service and it will call the user service using

277
00:19:42,380 --> 00:19:45,846
their compensation calls. What's the compensation call

278
00:19:46,028 --> 00:19:49,510
actually? Compensation action. We can say that it is semantically

279
00:19:49,590 --> 00:19:53,980
undoes the action. So you need to develop

280
00:19:54,510 --> 00:19:58,406
another logic to undo

281
00:19:58,438 --> 00:20:02,126
the action. It might be kind of deleting a record from

282
00:20:02,148 --> 00:20:06,014
the database or changing the parameters or

283
00:20:06,052 --> 00:20:11,050
something like that. So it is not a proper rollback,

284
00:20:11,130 --> 00:20:15,902
but changing, semantically changing

285
00:20:15,966 --> 00:20:19,570
the updates, rollbacking the updates.

286
00:20:20,550 --> 00:20:23,986
So this figure

287
00:20:24,168 --> 00:20:27,880
actually represents the saga better,

288
00:20:28,730 --> 00:20:33,026
because it is just a serial

289
00:20:33,138 --> 00:20:36,278
run of multiple services. Imagine that you

290
00:20:36,284 --> 00:20:39,482
are booking a trip, and when you are booking a trip, you need to first

291
00:20:39,536 --> 00:20:43,066
plan the meeting, then book the flights, then book the hotel, and then

292
00:20:43,088 --> 00:20:46,250
book the transport. And again,

293
00:20:46,320 --> 00:20:49,654
imagine that when you are doing these operations,

294
00:20:49,782 --> 00:20:53,434
you plan the meeting successfully, then you book the flight successfully.

295
00:20:53,482 --> 00:20:56,794
But you had an issue with the when booking the hotel.

296
00:20:56,922 --> 00:21:00,926
So the hotel booking will cancel itself

297
00:21:01,028 --> 00:21:05,170
and then call the cancellation call

298
00:21:05,240 --> 00:21:08,866
of the book flight. So the book flights will be canceled, and then

299
00:21:08,968 --> 00:21:12,482
the book flights will cancel the plan meeting by

300
00:21:12,536 --> 00:21:17,462
calling this compensation action. So this is the

301
00:21:17,596 --> 00:21:20,870
simple representation of the distributed sagas.

302
00:21:21,210 --> 00:21:24,966
We also need to mention about two approaches. There are

303
00:21:25,148 --> 00:21:28,278
two basic approaches on the distributed sagas. The first one is

304
00:21:28,284 --> 00:21:31,894
the orchestration and the second one is the choreography approach.

305
00:21:32,022 --> 00:21:36,582
In the orchestration approach, there will be orchestrator

306
00:21:36,646 --> 00:21:41,850
to actually orchestrate manage the

307
00:21:41,920 --> 00:21:45,022
transaction itself. It's not the same

308
00:21:45,076 --> 00:21:49,002
thing in the two phase commit, the coordinator in this two phase commit,

309
00:21:49,146 --> 00:21:52,974
it just helps the

310
00:21:53,012 --> 00:21:56,138
distribute applications to communicate them,

311
00:21:56,324 --> 00:21:59,570
each of them. In the choreography approach,

312
00:22:00,070 --> 00:22:03,874
all of the services are responsible for their own,

313
00:22:03,912 --> 00:22:08,006
and they most likely use kind of event source or something like

314
00:22:08,028 --> 00:22:11,414
that to communicate each other. Yeah.

315
00:22:11,612 --> 00:22:14,840
The advantages of this sagas are, as you know,

316
00:22:16,170 --> 00:22:20,042
it is running asynchronous and it doesn't need

317
00:22:20,096 --> 00:22:24,086
a homogeneous environment. It can run with heterogeneous distributed components.

318
00:22:24,198 --> 00:22:27,050
And also we don't need any xa transactions,

319
00:22:28,430 --> 00:22:31,614
we don't need any Xa specific using. And also

320
00:22:31,652 --> 00:22:37,114
it is scalable because all of the applications,

321
00:22:37,162 --> 00:22:41,226
all of the services are running their own transaction

322
00:22:41,418 --> 00:22:44,750
or responsible from their own transaction.

323
00:22:44,910 --> 00:22:48,958
The disadvantages of the distributed sagas is the eventual consistency.

324
00:22:49,054 --> 00:22:52,130
There is no strong consistency in sagas

325
00:22:53,110 --> 00:22:57,126
because at some time you

326
00:22:57,148 --> 00:23:00,920
can have some sale rates. For instance, imagine that

327
00:23:01,370 --> 00:23:05,186
when you have the issue with the banking service, when it has the failure,

328
00:23:05,378 --> 00:23:09,414
then you might be reaching the same related

329
00:23:09,462 --> 00:23:13,210
records in the user database from a different

330
00:23:13,280 --> 00:23:17,050
application, and you will be the updated information

331
00:23:17,200 --> 00:23:20,814
at the exact that time. So there will be also no

332
00:23:20,852 --> 00:23:22,430
write read isolation.

333
00:23:24,530 --> 00:23:28,318
Another issue with the distributed sagas is you need to develop a

334
00:23:28,404 --> 00:23:32,074
separate compensation function. You need to provide a separate

335
00:23:32,122 --> 00:23:35,474
logic for that one. There's no simple rollback, and you

336
00:23:35,512 --> 00:23:38,770
also need to handle the compensation failures.

337
00:23:39,190 --> 00:23:42,334
So let's talk about our solution.

338
00:23:42,462 --> 00:23:46,670
So we need to first discuss about, we need to talk about istio,

339
00:23:46,830 --> 00:23:50,310
the architecture of istio. As we mentioned

340
00:23:50,380 --> 00:23:54,550
in the beginning, the istio actually

341
00:23:54,700 --> 00:23:58,538
is a service mesh that handles the

342
00:23:58,704 --> 00:24:02,746
service to service communication. So you

343
00:24:02,768 --> 00:24:06,266
can see that there are multiple pods in this system and there

344
00:24:06,288 --> 00:24:10,006
are two planes that we can mention. The first

345
00:24:10,048 --> 00:24:13,402
one is the control plane that runs the Istio's

346
00:24:13,466 --> 00:24:17,870
own applications and also in the data plane

347
00:24:19,170 --> 00:24:22,286
your applications will be running and in

348
00:24:22,308 --> 00:24:25,902
the data plane on each pod there will be a proxy.

349
00:24:26,046 --> 00:24:30,402
Istio uses envoy proxy to communicate, to hand

350
00:24:30,456 --> 00:24:34,142
over the communication. And here you can see that the ingress

351
00:24:34,206 --> 00:24:37,910
traffic comes into the applications and the proxy

352
00:24:38,650 --> 00:24:42,454
hands over that one and you can again see

353
00:24:42,492 --> 00:24:46,310
that there is no direct communication between service a to service

354
00:24:46,380 --> 00:24:50,678
b. It will be only happens through the proxies.

355
00:24:50,774 --> 00:24:54,460
So the east to west communication will be always

356
00:24:54,910 --> 00:24:58,118
happened between the proxies. Another feature that we'll

357
00:24:58,134 --> 00:25:01,642
be using is, will be the envoy proxy filter chains.

358
00:25:01,786 --> 00:25:05,962
This is a really useful feature of envoy that you can enhance

359
00:25:06,026 --> 00:25:09,790
or you can block the data communication.

360
00:25:10,450 --> 00:25:14,034
For instance, you can have some HTTP filters that you can

361
00:25:14,232 --> 00:25:18,340
add more information, some header, update the headers or

362
00:25:19,350 --> 00:25:22,674
change the data itself using these

363
00:25:22,712 --> 00:25:26,374
filters. Or you can even block or you can cut

364
00:25:26,412 --> 00:25:29,430
the circuit using these filters at any time.

365
00:25:29,580 --> 00:25:33,554
Our solution can be demonstrated

366
00:25:33,602 --> 00:25:37,094
like this. Again, we will have user service and

367
00:25:37,132 --> 00:25:41,014
product service and banking microservices in these pods. We will have the envoy

368
00:25:41,062 --> 00:25:44,518
proxies provided by the istio

369
00:25:44,614 --> 00:25:48,170
service meshes. We will attach a filter

370
00:25:48,510 --> 00:25:52,378
to these envoy proxies and these filters

371
00:25:52,474 --> 00:25:56,270
will be communicating to our own application which will be calling

372
00:25:56,340 --> 00:26:00,170
propeller app. These filters

373
00:26:00,250 --> 00:26:04,322
will be providing information about the transaction and

374
00:26:04,376 --> 00:26:08,242
this propeller app will just store the transaction information

375
00:26:08,376 --> 00:26:11,694
on a hazelcast cluster. So let's

376
00:26:11,742 --> 00:26:15,300
see in action. Our application is still running

377
00:26:15,830 --> 00:26:18,946
and we can also see the Kiali console.

378
00:26:18,978 --> 00:26:23,010
Yeah, you can see that this is the previous

379
00:26:23,090 --> 00:26:27,062
run of our demonstration. So the ecommerce service, we access

380
00:26:27,116 --> 00:26:30,858
the ecommerce service and ecommerce service access to

381
00:26:30,944 --> 00:26:33,770
user, product and banking services accordingly.

382
00:26:34,750 --> 00:26:38,826
So here we will first create a

383
00:26:39,008 --> 00:26:42,494
hazardous cluster. This hazardous cluster will have

384
00:26:42,532 --> 00:26:45,806
three replicas and we will

385
00:26:45,828 --> 00:26:49,326
be accessing this hazardous cluster using a hazardous cluster service.

386
00:26:49,508 --> 00:26:52,994
And our propeller application will again have

387
00:26:53,032 --> 00:26:57,998
three replicas and it will be just storing

388
00:26:58,014 --> 00:27:01,534
the data of the transaction data in the hazardous

389
00:27:01,582 --> 00:27:05,198
cluster. So first let's start, let's apply

390
00:27:05,304 --> 00:27:08,822
the deployment, the configuration for

391
00:27:08,876 --> 00:27:10,630
the hazardous cluster.

392
00:27:12,810 --> 00:27:16,754
Okay, our hazardous cluster is being created and let's

393
00:27:16,802 --> 00:27:20,520
apply the propolar app

394
00:27:21,710 --> 00:27:25,638
configuration. Yeah, they are all being created.

395
00:27:25,814 --> 00:27:30,102
Let's check the services or

396
00:27:30,176 --> 00:27:33,520
pods first. They're all running. Yes,

397
00:27:34,130 --> 00:27:38,074
all of them are nearly running. The last instance

398
00:27:38,122 --> 00:27:41,998
of the proper rep is also ready. Let's check

399
00:27:42,084 --> 00:27:47,634
one last time. Everything is running and you can see the

400
00:27:47,832 --> 00:27:51,170
two containers in each pod. One of them is the actual

401
00:27:51,240 --> 00:27:54,850
pod. The second one will be the envoy proxy.

402
00:27:55,450 --> 00:27:59,846
So what will we also do is, as we also mentioned in the

403
00:28:00,028 --> 00:28:03,442
diagram we will apply a filter to envoy

404
00:28:03,506 --> 00:28:07,170
proxy. So let's first apply it and then

405
00:28:07,340 --> 00:28:11,478
discuss about details. It will be propeller filter

406
00:28:11,574 --> 00:28:14,490
yaml. Yeah, it's created.

407
00:28:15,150 --> 00:28:18,618
So let's discuss about

408
00:28:18,704 --> 00:28:22,720
the propeller filter. This is the

409
00:28:23,090 --> 00:28:27,306
part that the transaction the saga

410
00:28:27,418 --> 00:28:30,526
will be running on. So this is the

411
00:28:30,628 --> 00:28:33,906
kind of envoy filter. And this envoy filter is

412
00:28:33,928 --> 00:28:37,780
a custom resource provided by the istio and

413
00:28:40,550 --> 00:28:44,082
it's an HTTP filter. It's running at the HTTP level

414
00:28:44,216 --> 00:28:47,462
and it is inserted before the

415
00:28:47,516 --> 00:28:51,302
operation. So it will be running before the operation for each

416
00:28:51,356 --> 00:28:54,162
operation on the pods.

417
00:28:54,306 --> 00:28:58,258
So it's a Loa filter. You can have multiple

418
00:28:58,354 --> 00:29:02,522
options here, but I will be using LoA to

419
00:29:02,576 --> 00:29:06,554
implement this filter. So there

420
00:29:06,592 --> 00:29:10,146
are two functions, two main functions.

421
00:29:10,198 --> 00:29:13,774
One will be running on

422
00:29:13,812 --> 00:29:18,190
each request. The second one will be running on each response

423
00:29:18,930 --> 00:29:23,090
into the pod. So what we'll do on the request is

424
00:29:23,240 --> 00:29:27,186
we will just get the transaction id from

425
00:29:27,208 --> 00:29:30,706
the headers. And from this header we will

426
00:29:30,728 --> 00:29:35,666
get this transaction id and send it to the propeller

427
00:29:35,698 --> 00:29:39,814
app which you can see here. There's a put key

428
00:29:39,852 --> 00:29:44,038
and value, just an entry. And here is the address of our

429
00:29:44,124 --> 00:29:47,346
internal address of our internal domain

430
00:29:47,378 --> 00:29:51,370
of the propeller app. The second function is

431
00:29:51,440 --> 00:29:54,634
actually on

432
00:29:54,672 --> 00:29:58,250
response function. On each response we will

433
00:29:58,320 --> 00:30:02,026
check the status of the HTTP status of

434
00:30:02,128 --> 00:30:05,902
the response. So if there is a failure on

435
00:30:05,956 --> 00:30:09,694
the response, if it is a failure, then we will say that we

436
00:30:09,732 --> 00:30:13,138
will call the compensation actions. How we will do that,

437
00:30:13,224 --> 00:30:17,154
we will get the transaction id again from the header and we will

438
00:30:17,192 --> 00:30:21,234
communicate the propolar app to

439
00:30:21,272 --> 00:30:24,722
get the information about the information about the

440
00:30:24,856 --> 00:30:28,034
current transaction. We will get the transaction

441
00:30:28,082 --> 00:30:31,782
information and for each endpoint we will call the

442
00:30:31,836 --> 00:30:35,186
compensate actions for this transaction.

443
00:30:35,298 --> 00:30:38,474
And so the compensation actions will be called.

444
00:30:38,592 --> 00:30:42,710
So again we will go and check our envoy

445
00:30:42,790 --> 00:30:46,234
filters. Yeah, this filter is now becoming

446
00:30:46,432 --> 00:30:49,980
applied. So let's try to demonstrate our

447
00:30:50,930 --> 00:30:54,094
demo again. So again we have the

448
00:30:54,132 --> 00:30:57,802
same application as you most likely notice

449
00:30:57,866 --> 00:31:01,070
that we haven't redeployed our application.

450
00:31:01,140 --> 00:31:04,754
We have just applied filter. So let's try

451
00:31:04,792 --> 00:31:08,722
to. Again, you need to see that our current

452
00:31:08,776 --> 00:31:11,970
product stock is seven and available user credits

453
00:31:12,040 --> 00:31:15,394
is 7000. So let's try to purchase

454
00:31:15,442 --> 00:31:19,254
this product again. For instance, this time I will

455
00:31:19,292 --> 00:31:21,880
get four of these products.

456
00:31:24,810 --> 00:31:28,202
Anyway, let's continue with this one and talk about it later.

457
00:31:28,336 --> 00:31:32,154
And also let's get the 5000

458
00:31:32,272 --> 00:31:35,100
from our user credits.

459
00:31:35,950 --> 00:31:40,060
So when I click on buy now, if the

460
00:31:41,390 --> 00:31:46,094
distribute stagger works, then the product

461
00:31:46,292 --> 00:31:49,978
stock and the available user credits shouldn't be changed.

462
00:31:50,074 --> 00:31:53,774
It means that the product stock will stay at seven and

463
00:31:53,812 --> 00:31:57,314
the amount from the available user credits should be

464
00:31:57,352 --> 00:32:00,898
stay at 7000. Let's click on buy now.

465
00:32:01,064 --> 00:32:04,434
Yeah, we have the internal server error and when we go

466
00:32:04,472 --> 00:32:08,360
back yes, we can see that the distributed saga worked because

467
00:32:09,130 --> 00:32:12,278
we have rolled back the updates on the available

468
00:32:12,364 --> 00:32:15,814
user credits and we have rolled back the product stocked on

469
00:32:15,852 --> 00:32:20,300
the product service. And also we can check here,

470
00:32:20,830 --> 00:32:24,682
there's a detailed representation of

471
00:32:24,736 --> 00:32:28,518
the operation. You can see that the product propeller

472
00:32:28,534 --> 00:32:31,230
app is communicating to Helzikas cluster.

473
00:32:32,290 --> 00:32:35,742
The banking services failed. It is still not

474
00:32:35,796 --> 00:32:39,326
properly updated because we will see that the banking service will

475
00:32:39,348 --> 00:32:42,878
be communicating to propular app and then this banking

476
00:32:42,894 --> 00:32:46,386
service will be also communicating to product service and user service in a few

477
00:32:46,488 --> 00:32:51,602
seconds. But let's continue what

478
00:32:51,656 --> 00:32:54,418
happens. Let's try to discuss what happens.

479
00:32:54,584 --> 00:33:02,126
So the banking service app returned

480
00:33:02,158 --> 00:33:05,446
an HTTP 500 response and on

481
00:33:05,468 --> 00:33:09,866
the NY proxy we

482
00:33:10,048 --> 00:33:13,450
intercept that response and then we

483
00:33:13,520 --> 00:33:17,100
check that since it is at 500 then we

484
00:33:18,270 --> 00:33:22,250
access the propol rep, get the details of the

485
00:33:22,400 --> 00:33:26,734
transaction from the hazardous cluster and then with

486
00:33:26,772 --> 00:33:30,510
the information that taken from the cluster

487
00:33:30,850 --> 00:33:34,754
we call the compensation actions on each service on which

488
00:33:34,792 --> 00:33:38,146
will be the product and user services. So the

489
00:33:38,248 --> 00:33:41,602
compensation actions worked and then we roll back the

490
00:33:41,656 --> 00:33:45,074
transaction. We can again yes, here is the updated version of

491
00:33:45,112 --> 00:33:48,486
the it's a pretty complicated one but you

492
00:33:48,508 --> 00:33:52,550
can see that ecommerce service contacted to the provide app

493
00:33:52,620 --> 00:33:56,662
and then contacted the banking service. Sorry the banking service

494
00:33:56,716 --> 00:34:00,698
contact the provide app and then banking service get called

495
00:34:00,784 --> 00:34:03,994
compensation actions of the user service and product service.

496
00:34:04,192 --> 00:34:08,394
Yeah this is the end of my talk and

497
00:34:08,512 --> 00:34:11,854
I hope you enjoyed it. Just I need to say

498
00:34:11,892 --> 00:34:15,006
that this solution is not ready,

499
00:34:15,108 --> 00:34:18,494
production ready. There are still some

500
00:34:18,532 --> 00:34:22,478
problems but I tried to tell you about

501
00:34:22,644 --> 00:34:26,126
the available features of the service meshes and what

502
00:34:26,148 --> 00:34:30,666
we can do with what kind of solutions

503
00:34:30,698 --> 00:34:34,378
that we can provide for the transactions transactions.

504
00:34:34,554 --> 00:34:36,930
Hope you enjoyed it and thank you for listening.

