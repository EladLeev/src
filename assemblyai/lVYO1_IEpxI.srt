1
00:00:26,850 --> 00:00:30,358
Hello everyone, my name is Mitzvinik and I'm a developer advocate on the

2
00:00:30,364 --> 00:00:34,194
Facebook open source team. Today I'll talk about modern web testing

3
00:00:34,242 --> 00:00:37,654
and how to go beyond using nonselenium when it comes

4
00:00:37,692 --> 00:00:41,094
to web. So let's take a look again. Thank you everybody

5
00:00:41,132 --> 00:00:45,026
for joining. And as I said, today we'll talk about modern web testing

6
00:00:45,218 --> 00:00:49,154
and what do I do? So I give you some of my credentials.

7
00:00:49,282 --> 00:00:52,490
My name is Nietzsche. As I said, I'm an open source developer advocate.

8
00:00:52,570 --> 00:00:56,074
What it means is that we're working on this Facebook open source

9
00:00:56,122 --> 00:00:59,470
program where we are trying to empower diverse communities through open

10
00:00:59,540 --> 00:01:03,322
source. Since this screenshot has been taken, we actually updated

11
00:01:03,386 --> 00:01:07,150
our website. So I invite you to go check it out at opensource

12
00:01:07,230 --> 00:01:11,362
facebook.com and you'll find our videos, blogs and

13
00:01:11,416 --> 00:01:14,926
the projects that we are advocating for. I'm also focusing

14
00:01:14,958 --> 00:01:19,026
on mobile, in particular Android, iOS and hybrid development

15
00:01:19,058 --> 00:01:22,514
like react native. And as I mentioned, some of the projects

16
00:01:22,562 --> 00:01:27,138
like lethal that helps you to build declarative UI frameworks,

17
00:01:27,314 --> 00:01:31,622
fresco and flipper for debugging on mobile applications.

18
00:01:31,766 --> 00:01:35,286
But less about that and more about open source.

19
00:01:35,478 --> 00:01:38,294
And again, I'm very much passionate about open source.

20
00:01:38,342 --> 00:01:42,510
Hence I'm talking about testing today, testing using open source technologies.

21
00:01:42,850 --> 00:01:45,962
What are our goals for today's presentation? I always like to establish

22
00:01:46,026 --> 00:01:49,694
goals because they will help us to establish our agenda. And first

23
00:01:49,732 --> 00:01:53,822
and foremost, I'd like for us to choose the right test

24
00:01:53,876 --> 00:01:57,058
context and know where we're working with. Then we

25
00:01:57,064 --> 00:02:00,850
need to choose right level of testing as I'll introduce you.

26
00:02:00,920 --> 00:02:04,306
Hopefully you already know of test pyramid and how to actually apply it to

27
00:02:04,328 --> 00:02:08,058
web context. And last but not least is choosing

28
00:02:08,094 --> 00:02:11,682
the right end to end test approach because that will be the most valuable,

29
00:02:11,826 --> 00:02:15,430
I hope. Takeaway from this presentation is how to do end to end

30
00:02:15,580 --> 00:02:18,790
testing that satisfies your developer's needs.

31
00:02:18,860 --> 00:02:21,898
Whether using Django for development or anything else,

32
00:02:22,064 --> 00:02:25,894
we will try to take an approach of an end user regardless

33
00:02:25,942 --> 00:02:30,058
of what you are using in the back end or even front end. All right,

34
00:02:30,144 --> 00:02:33,462
so let's get to bit more details for this presentation.

35
00:02:33,526 --> 00:02:36,542
And how do we usually test? That's an important question to ask.

36
00:02:36,596 --> 00:02:39,598
So we're all on the same page here. As I mentioned before,

37
00:02:39,684 --> 00:02:43,054
the test pyramid is usually the very good guidance and what

38
00:02:43,092 --> 00:02:46,882
people are introduced to. When we are talking about testing first

39
00:02:46,936 --> 00:02:49,874
level, the lowest level and the widest of them all,

40
00:02:49,912 --> 00:02:53,678
meaning supposed to have the most number of tests unit tests.

41
00:02:53,774 --> 00:02:57,446
They are just testing a single function, a single unit of work.

42
00:02:57,628 --> 00:03:01,458
They are the cheapest to write and maintain the fastest,

43
00:03:01,554 --> 00:03:04,690
but they give you the lowest level of confidence in your overall

44
00:03:04,770 --> 00:03:08,802
application system level. Then an integration tests

45
00:03:08,866 --> 00:03:12,426
take place. This is where you testing multiple functions in

46
00:03:12,448 --> 00:03:15,354
play, multiple components, how they interact with one another.

47
00:03:15,472 --> 00:03:19,142
And last but not least is end to end test, going through the users

48
00:03:19,206 --> 00:03:22,702
scenario, your end user scenario that they will go through

49
00:03:22,756 --> 00:03:26,810
while using your application. And they are usually the most expensive

50
00:03:26,890 --> 00:03:30,970
ones, the slowest, but they give you the highest level of confidence.

51
00:03:31,050 --> 00:03:35,410
Hence you're supposed to use very few of them compared to other levels.

52
00:03:36,230 --> 00:03:40,190
But how do we usually test web real test pyramids?

53
00:03:40,270 --> 00:03:43,694
I like the test pyramid as I just showed you. In ideal scenario,

54
00:03:43,742 --> 00:03:47,174
reality is very much different. What people usually end up using

55
00:03:47,212 --> 00:03:51,218
is ice cream cone, pattern, hourglass or cupcake.

56
00:03:51,394 --> 00:03:54,902
So ice cream cone, the ice cream cone, it's basically

57
00:03:54,956 --> 00:03:58,662
inverted pyramid where you actually have the fewest number

58
00:03:58,716 --> 00:04:02,294
of unit tests. Then you have service or integration tests,

59
00:04:02,342 --> 00:04:05,546
more of those, and a large suite of end to

60
00:04:05,568 --> 00:04:09,654
end tests. I actually worked at the companies before where this would be the reality,

61
00:04:09,702 --> 00:04:13,166
and that's usually the reality for many. And on top of

62
00:04:13,188 --> 00:04:16,814
this cone you would have manual testing, which again

63
00:04:16,852 --> 00:04:21,130
is not very much scalable for large teams and large applications.

64
00:04:21,290 --> 00:04:24,810
Hourglass is similar. Again, you have actually

65
00:04:24,900 --> 00:04:29,326
lots of unit tests, lots of UI tests, but very few service tests.

66
00:04:29,518 --> 00:04:32,900
We can argue whether it's good or bad, but that's reality for many.

67
00:04:33,270 --> 00:04:36,754
And the cupcake, cupcake is very much like these ice cone.

68
00:04:36,802 --> 00:04:40,210
Again, it's very much like an inverted pyramid. You have fewer

69
00:04:40,290 --> 00:04:43,250
unit tests, more integration tests,

70
00:04:43,410 --> 00:04:46,882
lots of automation UI tests, and a massive

71
00:04:46,946 --> 00:04:51,418
number of manual testing. Again, it's very much like these

72
00:04:51,504 --> 00:04:54,806
ice cream cone. But the idea is it's an inverted

73
00:04:54,838 --> 00:04:58,634
pyramid, meaning that the pyramid that we all like to talk about is

74
00:04:58,672 --> 00:05:01,786
not the reality for most. So we

75
00:05:01,808 --> 00:05:04,894
need to change that. We need to change these antipathons that some

76
00:05:04,932 --> 00:05:08,334
people would call it. I call it a reality, but I always like

77
00:05:08,372 --> 00:05:11,866
to hope for the best and advise

78
00:05:11,898 --> 00:05:15,346
us to change that. And the way to change it is first to

79
00:05:15,368 --> 00:05:19,518
actually test something. And what is that something? Throughout today's implementations

80
00:05:19,614 --> 00:05:22,962
we'll have this simple app to do app that

81
00:05:23,016 --> 00:05:26,718
usually people use for lots of different UI frameworks.

82
00:05:26,814 --> 00:05:30,098
You can find an example of to do with angular, with react,

83
00:05:30,194 --> 00:05:33,154
with swelt, any number of projects,

84
00:05:33,202 --> 00:05:37,014
any number of frameworks. And this is a good app

85
00:05:37,052 --> 00:05:40,998
for us to test. It's basically you adding these to do, you checkmark

86
00:05:41,014 --> 00:05:44,534
it, you delete it, you filter items by completed

87
00:05:44,582 --> 00:05:48,134
or active, et cetera. So back to testing.

88
00:05:48,182 --> 00:05:50,634
Now I introduce you what we're going to test throughout today.

89
00:05:50,752 --> 00:05:54,478
And now let's actually see what we're going to do. There are

90
00:05:54,484 --> 00:05:57,994
a couple of scenarios I want to introduce here and go through for today's

91
00:05:58,042 --> 00:06:01,166
presentation. These first case would be imagine if you have

92
00:06:01,188 --> 00:06:04,586
a backend using Java and for many testing

93
00:06:04,618 --> 00:06:07,994
would be Java. In case of Python. Some people use Python,

94
00:06:08,042 --> 00:06:11,474
these backend, they will also use Python for testing. I would

95
00:06:11,512 --> 00:06:14,754
say that there is a problem with this approach where you try to match

96
00:06:14,792 --> 00:06:18,050
what in the back end for actual resonating,

97
00:06:18,130 --> 00:06:22,354
for the language that you use for testing, because ultimately

98
00:06:22,482 --> 00:06:26,662
for web, for web apps, you're seeing it from the end

99
00:06:26,716 --> 00:06:30,134
user perspective. Even if you're writing end to end tests, even if you're writing

100
00:06:30,182 --> 00:06:33,434
unit tests, it doesn't matter, you don't have to match

101
00:06:33,472 --> 00:06:37,226
your back end with a testing code. And so

102
00:06:37,408 --> 00:06:41,114
that's why I'm suggesting us to move away from been bound to whatever

103
00:06:41,152 --> 00:06:44,718
is in the back end and just go away from it and

104
00:06:44,804 --> 00:06:48,362
rather focus on hybrid model, domain driven

105
00:06:48,426 --> 00:06:52,138
development and user centric testing. When I'm

106
00:06:52,154 --> 00:06:56,050
saying these words, what I mean by hybrid model is that many

107
00:06:56,120 --> 00:06:59,474
companies in the past couple of years, they went through transformation where they

108
00:06:59,512 --> 00:07:03,934
used to have testers as a separate team from developers.

109
00:07:04,062 --> 00:07:07,554
So developers would write some production code, they would throw it at testers,

110
00:07:07,602 --> 00:07:11,234
testers will test it, give the feedback back to developers

111
00:07:11,282 --> 00:07:15,240
and there will be like a fairly massive feedback loop, fairly slow one.

112
00:07:16,010 --> 00:07:19,402
People have been trying to, companies been trying to avoid that and they called

113
00:07:19,456 --> 00:07:23,658
everybody now software engineer. And using this hybrid model where

114
00:07:23,744 --> 00:07:27,562
developers are the ones who test and testers are the ones who develop,

115
00:07:27,696 --> 00:07:30,906
there is no separation anymore. It means that

116
00:07:30,928 --> 00:07:34,766
you are trying to use the software engineering principles, even with

117
00:07:34,788 --> 00:07:39,002
the test infrastructure, but you are emphasizing the test expertise

118
00:07:39,066 --> 00:07:42,730
that testers bring. It's not just the fact that testers

119
00:07:42,810 --> 00:07:46,026
don't do anything and developers just do the important work.

120
00:07:46,148 --> 00:07:49,218
No, both parts can actually bring something important

121
00:07:49,304 --> 00:07:52,766
to the table and we need to find both of best of both worlds.

122
00:07:52,798 --> 00:07:55,906
This is what hybrid model is. And by again going away from

123
00:07:55,928 --> 00:07:59,750
a back end testing and just focusing again on the end users,

124
00:08:00,410 --> 00:08:04,226
this is why hybrid model is so important. This is domain driven

125
00:08:04,258 --> 00:08:08,114
development principle that plays these role here as well. Domain driven

126
00:08:08,162 --> 00:08:11,750
design, one of the main ideas these is ubiquitous language.

127
00:08:11,830 --> 00:08:15,686
You're trying to speak the same language with your developers

128
00:08:15,798 --> 00:08:19,274
as you would with your end users. When a user talks about

129
00:08:19,312 --> 00:08:23,466
an account and in the back end you're calling it user

130
00:08:23,578 --> 00:08:26,846
Java or something else. There is this

131
00:08:26,868 --> 00:08:30,766
misalignment, there is that miscommunication that happens. You want to actually match what

132
00:08:30,788 --> 00:08:34,206
your end user would care, because nobody cares what kind of great pattern you

133
00:08:34,228 --> 00:08:37,890
use at the back end. Ultimately it all ends up of

134
00:08:37,960 --> 00:08:41,138
what your customer gets. So customer is what

135
00:08:41,144 --> 00:08:45,378
we care about really here, and we're trying to speak the same language as they.

136
00:08:45,544 --> 00:08:49,442
That's why instead of back end resonating, we do front end testing

137
00:08:49,506 --> 00:08:53,046
even in the lowest levels, because context matters. You don't want to do

138
00:08:53,068 --> 00:08:56,374
this context switching of how you test internally when

139
00:08:56,412 --> 00:08:59,666
you talk to the user. And again, it's all about keeping

140
00:08:59,698 --> 00:09:03,206
it user centric. And I've been repeating that over and over again throughout

141
00:09:03,238 --> 00:09:06,746
these couple of slides. If you're still not convinced why

142
00:09:06,768 --> 00:09:09,994
I'm saying that making sure that you match your back end

143
00:09:10,112 --> 00:09:12,430
language with your testing language,

144
00:09:13,570 --> 00:09:16,320
modern web testing focus on the web.

145
00:09:17,090 --> 00:09:20,586
It brings up the power of JavaScript, and I'll be emphasizing

146
00:09:20,618 --> 00:09:24,526
that regardless of what you have in the back end, throughout your application, throughout the

147
00:09:24,548 --> 00:09:28,894
pyramid, unit integration and end to end, you can use JavaScript

148
00:09:28,942 --> 00:09:32,882
because that's what web is for many of us is based on.

149
00:09:33,016 --> 00:09:36,450
It can be PHP, it can be something else, it can be hack, but really

150
00:09:36,520 --> 00:09:40,374
javascript for majority of the web outside of like WordPress and

151
00:09:40,412 --> 00:09:43,958
such. And that's what I will be focusing on today. When it

152
00:09:43,964 --> 00:09:47,154
comes to power of javascript, I'll talk about assertion libraries,

153
00:09:47,282 --> 00:09:50,978
process libraries and enterprise libraries.

154
00:09:51,074 --> 00:09:53,446
So assertion libraries, things like jest,

155
00:09:53,558 --> 00:09:56,966
Jasmine process libraries, it's behavioral driven

156
00:09:56,998 --> 00:10:01,062
development libraries like cucumber and enterprise libraries

157
00:10:01,206 --> 00:10:04,714
like applitools for testing it help us with visual

158
00:10:04,762 --> 00:10:08,574
testing. And speaking of language of the web, JavaScript in

159
00:10:08,612 --> 00:10:12,014
particular I'll talk about node JS. So when it comes to

160
00:10:12,052 --> 00:10:15,502
node JS, it's isomorphic. It basically helps you

161
00:10:15,556 --> 00:10:19,346
to write code for server side and the front end for

162
00:10:19,368 --> 00:10:22,818
the UI. Then it's fairly flexible, obviously,

163
00:10:22,904 --> 00:10:26,598
and it's customizable. And it all comes down to the

164
00:10:26,764 --> 00:10:30,146
power of NPM manager as well. You have packages,

165
00:10:30,258 --> 00:10:34,390
so you can basically reuse something that other people built and

166
00:10:34,460 --> 00:10:38,258
simply import those packages and use them, whether it's

167
00:10:38,274 --> 00:10:41,786
for testing or development code. But going back

168
00:10:41,808 --> 00:10:46,060
to the pyramid web test pyramid, it's very much the same as

169
00:10:46,430 --> 00:10:50,186
any other pyramid would be. It's with unit test, low cost,

170
00:10:50,288 --> 00:10:53,534
high speed, and still quite a low level

171
00:10:53,572 --> 00:10:56,906
of continue in the overall app. But for the unit testing,

172
00:10:56,938 --> 00:11:00,126
for the web unit testing, we'll use Jasmine for an

173
00:11:00,148 --> 00:11:03,700
example to showcase how it can be done for your app.

174
00:11:04,390 --> 00:11:07,314
So let's say for our to do app,

175
00:11:07,352 --> 00:11:11,506
we have this simple function that takes an input, it converts it to

176
00:11:11,608 --> 00:11:15,234
JSON and basically returns name

177
00:11:15,272 --> 00:11:18,574
and state here, name of the to do and the state active

178
00:11:18,622 --> 00:11:22,054
in a completed, et cetera. When it comes

179
00:11:22,092 --> 00:11:25,746
to actually writing test with Jasmine, we first initialize

180
00:11:25,778 --> 00:11:29,114
the test suite create to do item. These. We create

181
00:11:29,152 --> 00:11:33,020
a test case where we accept valid test data.

182
00:11:33,950 --> 00:11:37,834
We initialize the to do item here. We basically pass some

183
00:11:38,032 --> 00:11:41,210
data to test some data that we know of,

184
00:11:41,280 --> 00:11:44,974
brainstorm ideas, and these state is incomplete and

185
00:11:45,012 --> 00:11:48,814
we do simple validation. We make sure the name matches what we

186
00:11:48,852 --> 00:11:52,398
expected after the app, process it, after the function. In this case,

187
00:11:52,484 --> 00:11:55,726
process it. That's what the unit test is. You're testing a

188
00:11:55,748 --> 00:11:59,138
single function, create to do item, and Jasmine lets you do

189
00:11:59,144 --> 00:12:02,734
that. And I didn't care how that function is processed on the backend.

190
00:12:02,862 --> 00:12:06,482
What kind of services are being invoked with what, what kind of

191
00:12:06,536 --> 00:12:10,002
language you have at the back end. Ultimately your end user

192
00:12:10,066 --> 00:12:13,286
wouldn't call the service directly. Your user would call this function

193
00:12:13,388 --> 00:12:16,578
on these front end, on the Javascript side. And that's what I'm

194
00:12:16,594 --> 00:12:20,106
going to test here. If I go up the level of the

195
00:12:20,128 --> 00:12:24,230
pyramid in integration test in the web context, I would use jest.

196
00:12:24,310 --> 00:12:28,378
Amazing framework. It's a test framework. They have so many things there.

197
00:12:28,464 --> 00:12:32,278
I'll give you one particular thing called snapshot testing with jest.

198
00:12:32,374 --> 00:12:35,674
It's a Facebook open source projects, by the way. So imagine

199
00:12:35,722 --> 00:12:38,766
you have this react component that's kind of an old pattern of

200
00:12:38,788 --> 00:12:41,886
writing it. But imagine that we do, we have these create to

201
00:12:41,908 --> 00:12:45,154
do function, create to do component. I would

202
00:12:45,192 --> 00:12:49,746
say that has a render function

203
00:12:49,848 --> 00:12:53,214
that returns you a button and it generates a certain action

204
00:12:53,262 --> 00:12:55,780
on click and has the label create.

205
00:12:56,310 --> 00:13:00,306
And it also has some sort of styling attached

206
00:13:00,338 --> 00:13:04,130
to it. I know people usually don't combine component and styling,

207
00:13:04,210 --> 00:13:08,166
but this is for simplicity reasons, just to show you visually what a

208
00:13:08,188 --> 00:13:12,034
component might look like, in case you've never seen react before, which is totally

209
00:13:12,082 --> 00:13:15,498
fine. And let's say if I were to test with just,

210
00:13:15,584 --> 00:13:18,746
I would create a test suite, I would say create a to do

211
00:13:18,768 --> 00:13:21,910
button is what I'm trying to test here. I render a component,

212
00:13:21,990 --> 00:13:25,774
basically I load it, I initialize it, and I call

213
00:13:25,812 --> 00:13:29,658
it by what it is create to do, and I convert

214
00:13:29,674 --> 00:13:33,306
it to JSon and I save it as we call a snapshot. What snapshot

215
00:13:33,338 --> 00:13:36,466
is, is basically this piece of code.

216
00:13:36,648 --> 00:13:39,886
It renders a component, it renders everything in that component

217
00:13:39,918 --> 00:13:43,966
has the web would see it the function, you can see it's undefined

218
00:13:43,998 --> 00:13:47,566
because it's in solutions. Here. Name the class names

219
00:13:47,678 --> 00:13:51,206
and styles and if there was anything to be changed to

220
00:13:51,228 --> 00:13:55,106
this component, we would catch this after we validate these snapshots.

221
00:13:55,298 --> 00:13:59,206
So to reflect on these two levels of the pyramid that we just looked at,

222
00:13:59,308 --> 00:14:02,278
every step has only one focus and it's developers.

223
00:14:02,454 --> 00:14:05,626
Even though I kept saying that user centric testing is important,

224
00:14:05,728 --> 00:14:09,514
I keep talking about those lower levels of testing and

225
00:14:09,632 --> 00:14:13,046
their focus is still on developers. Good for some tests,

226
00:14:13,078 --> 00:14:16,046
this kind of focus, but not for end to end tests. For end to end

227
00:14:16,068 --> 00:14:19,578
tests, we still very much care about our users.

228
00:14:19,754 --> 00:14:23,230
And when it comes to end to end tests,

229
00:14:23,570 --> 00:14:27,246
just to remind they are the highest cost, lowest speed,

230
00:14:27,278 --> 00:14:30,514
but they give you the highest confidence level. And these

231
00:14:30,552 --> 00:14:33,790
kind of three points have to be kept in mind throughout your writing

232
00:14:33,870 --> 00:14:37,250
tests. So to shift focus from developers towards

233
00:14:37,320 --> 00:14:40,726
your users is what we need to do when we are writing this

234
00:14:40,748 --> 00:14:44,786
end to end test. So it might sound great to do this shift

235
00:14:44,818 --> 00:14:47,462
of the focus, but how do we actually do that?

236
00:14:47,596 --> 00:14:51,066
So end to end task testing is what we need

237
00:14:51,088 --> 00:14:55,190
to do. User centric testing, it means that instead of interactions,

238
00:14:55,270 --> 00:14:58,682
we do tasks. We focus on tasks in hand.

239
00:14:58,816 --> 00:15:02,426
You do not care about. For instance, we have a workflow

240
00:15:02,458 --> 00:15:06,558
of the user logging in. You don't want to describe your test

241
00:15:06,644 --> 00:15:10,400
as user types in,

242
00:15:10,930 --> 00:15:14,686
sends keys in for the username, for the password.

243
00:15:14,798 --> 00:15:18,274
A user presses the button to submit this form.

244
00:15:18,312 --> 00:15:21,262
You don't want that language to be used when you're writing your tests.

245
00:15:21,326 --> 00:15:24,978
Instead, user enters username, users enters a

246
00:15:24,984 --> 00:15:28,886
password, user presses ok button. You do not

247
00:15:28,908 --> 00:15:32,114
go deep into like send keys. If you talk selenium,

248
00:15:32,242 --> 00:15:36,422
you don't focus on individual interactions, you focus on the task at hand instead

249
00:15:36,476 --> 00:15:39,818
of. If you're talking about particularly writing code,

250
00:15:39,904 --> 00:15:43,402
writing test code, these page object model, we're using something called

251
00:15:43,456 --> 00:15:46,934
screenplay model, screenplay pattern,

252
00:15:47,062 --> 00:15:50,554
where really it's how you write, how you speak, how you

253
00:15:50,592 --> 00:15:54,554
name your functions, what matters. But back to our apps,

254
00:15:54,682 --> 00:15:57,918
end to end testing is a common way to do. What's the

255
00:15:57,924 --> 00:16:01,178
common way to do end to end? Obviously it's nonselenium webdriver.

256
00:16:01,274 --> 00:16:05,140
It's at this point, it's a de facto end to end tool. Great tool.

257
00:16:05,590 --> 00:16:09,246
It's basically a testing standard at this point. And it's

258
00:16:09,278 --> 00:16:12,734
generic, meaning it can be fit for most use cases,

259
00:16:12,782 --> 00:16:16,070
I would say. And more importantly,

260
00:16:18,650 --> 00:16:22,530
it has quite a high integration with plenty of other open source projects,

261
00:16:22,610 --> 00:16:26,354
plugins, weights, objects, et cetera.

262
00:16:26,402 --> 00:16:29,480
So it has a great community behind it's an open source project,

263
00:16:29,850 --> 00:16:33,878
so send your webdriver. What it actually looks like behind the scene doesn't

264
00:16:33,894 --> 00:16:37,354
really matter to us as much, but ultimately what we care about. It has

265
00:16:37,392 --> 00:16:40,806
different bindings for different programming language, so what you'd

266
00:16:40,838 --> 00:16:44,606
like to use, you can use. But again, I want to go away from

267
00:16:44,708 --> 00:16:47,898
matching your back end with your front end testing,

268
00:16:47,994 --> 00:16:51,994
and also it has drivers for Internet

269
00:16:52,042 --> 00:16:55,540
explorers, Firefox and whatever you'd like.

270
00:16:56,470 --> 00:17:00,082
So since I've been talking about JavaScript, in particular the front

271
00:17:00,136 --> 00:17:03,886
end testing for the front end, I'd like to bring up Webdriver JS.

272
00:17:03,998 --> 00:17:08,018
And by the way, it is important how I capitalize GS

273
00:17:08,114 --> 00:17:11,958
because Webdriver Js, with two capital J and S is a

274
00:17:11,964 --> 00:17:13,350
different framework altogether.

275
00:17:14,890 --> 00:17:18,700
Capital G and J and small s

276
00:17:19,150 --> 00:17:22,730
is the official webdriver

277
00:17:23,070 --> 00:17:26,518
bindings for JavaScript. So nonselenium Webdriver Js,

278
00:17:26,614 --> 00:17:30,042
it's still de facto end to end tool, still a testing standard,

279
00:17:30,176 --> 00:17:33,294
still generic, and has a great integration with the open

280
00:17:33,332 --> 00:17:37,050
source community. And in terms of how it actually looks behind the scene,

281
00:17:37,130 --> 00:17:40,878
just the bindings are node JS exactly what we want here,

282
00:17:40,964 --> 00:17:44,878
and that's what I'll showcase here. So we have a suite initialized

283
00:17:44,974 --> 00:17:48,306
we name create to do we

284
00:17:48,328 --> 00:17:51,522
initialize the Webdriver? Doesn't matter what exactly it does,

285
00:17:51,576 --> 00:17:54,994
just believe that it does initialize it. Then you

286
00:17:55,032 --> 00:17:58,774
create an actual test case. You're using the valid data to create a to

287
00:17:58,812 --> 00:18:02,406
do. You make sure you wait for the page to

288
00:18:02,428 --> 00:18:06,114
load, then you send the name of the webdriver

289
00:18:06,162 --> 00:18:09,318
of the to do of the new to do,

290
00:18:09,404 --> 00:18:13,146
and you basically what is in this case, you make sure it

291
00:18:13,168 --> 00:18:16,954
actually appears. And that's about all. You made sure that

292
00:18:16,992 --> 00:18:20,490
it appeared on the web. You edit a new to do and that's all.

293
00:18:20,560 --> 00:18:24,218
Nothing special there. That's how you would do it with any other Webdriver bindings,

294
00:18:24,314 --> 00:18:27,642
Java, C sharp, whatever else. Unfortunately,

295
00:18:27,706 --> 00:18:31,086
they're not just these good parts to Webdriver JS. With any

296
00:18:31,108 --> 00:18:34,638
end to end test complexities, there is always an issue how you select,

297
00:18:34,724 --> 00:18:38,114
how you find your elements on these web, how you

298
00:18:38,152 --> 00:18:42,146
locate them, what's these test flow like, and what kind

299
00:18:42,168 --> 00:18:45,702
of single page application, what frameworks it can

300
00:18:45,836 --> 00:18:49,238
work for. What about Webdriver JS though?

301
00:18:49,324 --> 00:18:53,334
Webdriver JS is great, I mean, selector wise it

302
00:18:53,372 --> 00:18:56,962
has everything standard id and CSS and xpath

303
00:18:57,106 --> 00:19:01,298
bindings. For locators it has by allocators

304
00:19:01,314 --> 00:19:04,474
like by dot for test flows. It used to have

305
00:19:04,512 --> 00:19:07,638
something called promise manager, because node JS

306
00:19:07,734 --> 00:19:11,082
by default is async. You wouldn't want to have your

307
00:19:11,136 --> 00:19:15,506
tester or your developers worry about managing this asynchronous.

308
00:19:15,558 --> 00:19:19,274
And so the promise manager allowed you to write this kind of sequential

309
00:19:19,322 --> 00:19:23,130
code before, but we since removed it and now it's

310
00:19:23,210 --> 00:19:27,086
await and async. By we I mean open source

311
00:19:27,118 --> 00:19:30,946
community did. And it's still very generic so

312
00:19:30,968 --> 00:19:34,862
it can work with anything. But still it looks limited

313
00:19:34,926 --> 00:19:39,234
though. I mean the byte selectors are great, id CSS selectors

314
00:19:39,282 --> 00:19:42,982
are nice, but is there anything better? And for special

315
00:19:43,036 --> 00:19:46,134
case number two, let's say we have angular as a front end.

316
00:19:46,172 --> 00:19:49,686
Angular is quite popular. And when it comes to angular,

317
00:19:49,718 --> 00:19:53,386
if you've never seen it before, which is fine for

318
00:19:53,408 --> 00:19:56,890
the way how it's written, you don't have just regular classes,

319
00:19:59,070 --> 00:20:02,606
you have special attributes like entry, submit, model change,

320
00:20:02,708 --> 00:20:05,854
et cetera. Basically it helps you quite

321
00:20:05,892 --> 00:20:09,886
heavily to write front end. And in terms of actually

322
00:20:09,988 --> 00:20:13,374
testing angular, we still use the same pyramid for

323
00:20:13,412 --> 00:20:16,882
unit testing, for integration. But for end to end testing we have something

324
00:20:16,936 --> 00:20:20,386
special. It's not just Webdriver JS. We don't have to

325
00:20:20,408 --> 00:20:24,686
use just Webdriver JS for that. We have protractor.

326
00:20:24,798 --> 00:20:28,386
Protractor is end to end test framework for angular apps. It's created

327
00:20:28,418 --> 00:20:31,350
and maintained by the angular JS folks.

328
00:20:31,690 --> 00:20:35,186
So protractor is basically everything these Webdriver

329
00:20:35,218 --> 00:20:38,530
JS has. But then it has additional

330
00:20:38,610 --> 00:20:42,474
things, has still nonselenium server, it has

331
00:20:42,592 --> 00:20:46,074
API for angular in particular, but also it

332
00:20:46,112 --> 00:20:49,994
has connection to the angular JS app. It knows exactly when the

333
00:20:50,032 --> 00:20:53,454
app is loaded and ready to be tested, which is a great

334
00:20:53,572 --> 00:20:57,626
addition to any these infrastructure. For the protractor selector

335
00:20:57,658 --> 00:21:00,826
wise. It has element bindings, it has biri

336
00:21:00,858 --> 00:21:04,506
beaters. In terms of the test flow, it knows,

337
00:21:04,538 --> 00:21:07,906
as I said, exactly when the app is ready. You don't have to wait for

338
00:21:07,928 --> 00:21:11,474
a particular element to appear in order to test, which is

339
00:21:11,512 --> 00:21:14,974
a great help. And it's intentionally built for

340
00:21:15,032 --> 00:21:18,738
angular. In terms of tests similar tests

341
00:21:18,754 --> 00:21:21,494
create to do validate data.

342
00:21:21,692 --> 00:21:25,426
You load the browser for a particular URL, you find element

343
00:21:25,538 --> 00:21:29,046
by model, you send keys and you make sure

344
00:21:29,068 --> 00:21:32,714
it appears. You can see that how much less code I had to write,

345
00:21:32,832 --> 00:21:35,994
but I did ultimately the same thing and I didn't have to wait for the

346
00:21:36,032 --> 00:21:39,462
app to load. All of that is handled for me. But angular

347
00:21:39,526 --> 00:21:42,470
is great. But there are so many other UI frameworks.

348
00:21:42,550 --> 00:21:47,018
Obviously there is react, there is vue, there is amber backbone,

349
00:21:47,194 --> 00:21:50,378
swelt and many others. I think there are more UI frameworks

350
00:21:50,394 --> 00:21:53,886
that I can ever count. But let's say we were to use protractor

351
00:21:53,918 --> 00:21:57,700
with react. You technically can, you can remove this

352
00:21:58,070 --> 00:22:01,906
ignore synchronization property. It's called. Basically it doesn't wait for

353
00:22:01,928 --> 00:22:05,682
angular app to load because it won't ever load with react.

354
00:22:05,746 --> 00:22:09,298
Right? But still, it's kind of silly.

355
00:22:09,394 --> 00:22:13,240
You're trying to fit one thing into another that wasn't built for it

356
00:22:14,170 --> 00:22:17,726
really. I would say non selenium

357
00:22:17,778 --> 00:22:21,580
UI test frameworks is the next thing to try other than

358
00:22:21,950 --> 00:22:25,862
general Webdriver for JavaScript.

359
00:22:26,006 --> 00:22:30,090
And in here, I'd like to showcase two things, test cafe and Cypressio.

360
00:22:30,670 --> 00:22:34,638
So what have we learned so far though? Patterns. That patterns matter the

361
00:22:34,644 --> 00:22:38,158
most when it comes to testing. The common patterns are

362
00:22:38,324 --> 00:22:41,754
how you're handling weights, how you execute in parallel

363
00:22:41,802 --> 00:22:46,238
your tests, rapid test development how quickly can I get my feedback

364
00:22:46,334 --> 00:22:50,510
from the test as a developer, especially in hybrid development teams?

365
00:22:50,590 --> 00:22:54,670
And can I record and do I have an ide for my test

366
00:22:54,840 --> 00:22:58,150
automation framework? In terms of test cafe,

367
00:23:00,090 --> 00:23:03,366
it handles weights pretty well. It does allow you

368
00:23:03,388 --> 00:23:07,234
to parallel execute your tests. It has a great feedback loop,

369
00:23:07,282 --> 00:23:10,742
it gives you feedback fairly quickly, and it has a recorder and

370
00:23:10,796 --> 00:23:14,522
ide for you to try. To give you an example, if you were to write

371
00:23:14,576 --> 00:23:17,734
code itself for test cafe, you can you create a fixture

372
00:23:17,782 --> 00:23:20,906
what you're trying to test, you load the page, you can see this stream

373
00:23:20,938 --> 00:23:24,494
kind of API style of writing code.

374
00:23:24,612 --> 00:23:27,822
You initialize your test, you type

375
00:23:27,876 --> 00:23:31,514
a name, you click the button, you submit

376
00:23:31,562 --> 00:23:34,978
it and you're done. I'm not going to dive into particular

377
00:23:35,064 --> 00:23:38,530
code that Testcafe use, but really the recorder that it has

378
00:23:38,600 --> 00:23:42,082
is quite nice. It allows you to kind of,

379
00:23:42,136 --> 00:23:45,554
if you have a manual tester team at your

380
00:23:45,592 --> 00:23:49,574
company, you can use them to basically record a bunch of these tests and then

381
00:23:49,612 --> 00:23:52,950
convert them to code. It's kind of a great first step

382
00:23:53,020 --> 00:23:56,454
to teach them how to write automation, and it's also quite

383
00:23:56,492 --> 00:23:59,526
a nice way to debug your tests if you

384
00:23:59,548 --> 00:24:03,466
wanted to. So if anything, the idea for Testcafe is

385
00:24:03,488 --> 00:24:07,018
quite nice. But cypressio is actually more, I think,

386
00:24:07,104 --> 00:24:10,426
getting more traction online lately. And the same

387
00:24:10,448 --> 00:24:14,206
thing, it handles weights very well, I can attest to

388
00:24:14,228 --> 00:24:17,342
that. It has a great parallel execution support,

389
00:24:17,476 --> 00:24:21,294
it gives you feedback extremely quickly, and it does

390
00:24:21,332 --> 00:24:25,006
allow you to record your tests. It has a special plugin

391
00:24:25,038 --> 00:24:29,250
for that. So if you were to write test code for cypress

392
00:24:30,070 --> 00:24:33,540
for, let's say a login page, something different from the to do,

393
00:24:33,990 --> 00:24:37,334
you basically create these test case for that you

394
00:24:37,372 --> 00:24:40,610
specify username and password, you can even tweak

395
00:24:40,690 --> 00:24:44,402
cookies right here if you wanted to. You can say you can get cookies,

396
00:24:44,466 --> 00:24:47,914
validate those, you can do basically anything you want.

397
00:24:47,952 --> 00:24:51,578
And Cypressio has evolved largely from when

398
00:24:51,664 --> 00:24:54,682
I first made

399
00:24:54,736 --> 00:24:59,402
this snapshot for the code for this presentation and

400
00:24:59,456 --> 00:25:02,698
the Cypress. Again, it allows you to record things fairly well.

401
00:25:02,784 --> 00:25:06,862
You can see in these browser on the site how it's executed and

402
00:25:06,916 --> 00:25:09,534
how you can repeat that too. You can also pause it if you want to

403
00:25:09,572 --> 00:25:13,102
debug your tests. And yes, Cypress community

404
00:25:13,156 --> 00:25:16,866
has been growing rapidly, has lots of resources about it.

405
00:25:17,048 --> 00:25:20,274
So important thing to remember is to choose

406
00:25:20,312 --> 00:25:24,786
the right tool for the right problem. Don't try to fit a thing into a

407
00:25:24,808 --> 00:25:28,758
use case that doesn't work. There are so many test frameworks that

408
00:25:28,764 --> 00:25:31,714
I haven't even touched. Webdriver, IO, Nightwatch,

409
00:25:31,762 --> 00:25:35,414
JS, WD, Nemo so many

410
00:25:35,612 --> 00:25:38,954
avoid tool mix ups. If anything, do not have

411
00:25:38,992 --> 00:25:42,966
different tools test tools in your test infrastructure,

412
00:25:42,998 --> 00:25:47,114
it increases the complexities. When you're trying to test a complex thing with

413
00:25:47,152 --> 00:25:50,522
a complex test infrastructure, you're making it twice as hard.

414
00:25:50,576 --> 00:25:53,738
At least twice has hard there is no ubiquitous language, there is

415
00:25:53,744 --> 00:25:56,958
no domain driven design anymore, and there is

416
00:25:56,964 --> 00:26:00,222
no common language. So how do you choose what to use

417
00:26:00,276 --> 00:26:03,370
for your infrastructure? You can look at the open source projects at the

418
00:26:03,380 --> 00:26:07,166
GitHub pages, GitHub stars, how many npm

419
00:26:07,278 --> 00:26:11,346
downloads it has, external integrations, and also give it

420
00:26:11,368 --> 00:26:14,690
a try. And do the proof of concept first before you transition everything

421
00:26:14,760 --> 00:26:17,190
you have to use this framework.

422
00:26:18,330 --> 00:26:21,734
But more importantly, choose flexibility and your use

423
00:26:21,772 --> 00:26:25,526
case. Build it for your use case. In terms of flexibility, what I mean by

424
00:26:25,548 --> 00:26:29,366
that is look at cost transition. Let's say today you're using angular and

425
00:26:29,388 --> 00:26:32,874
you use protractor. But what if you know that your

426
00:26:32,912 --> 00:26:36,266
team, your company is traditional to react in a couple of

427
00:26:36,288 --> 00:26:40,186
months, in a year and two? Or maybe you haven't actually thought

428
00:26:40,208 --> 00:26:43,678
of that, but it will happen. So maybe investing in protractor is not the

429
00:26:43,684 --> 00:26:47,374
best option. So think of that. Think about return

430
00:26:47,492 --> 00:26:51,194
on investment. Does it even worth switching to Cyprus?

431
00:26:51,242 --> 00:26:54,706
If you're fully on selenium, it might count hours,

432
00:26:54,808 --> 00:26:57,870
count time you spent on maintaining these selenium tests,

433
00:26:57,950 --> 00:27:01,486
and then see if it justifies you spending

434
00:27:01,518 --> 00:27:04,290
time learning cypress, moving to cypressio, etc.

435
00:27:05,050 --> 00:27:08,998
Can you actually customize the framework you're using for

436
00:27:09,164 --> 00:27:14,326
your use case if it changes? And can you replace it easily in

437
00:27:14,348 --> 00:27:17,240
terms of again, thinking of your particular application,

438
00:27:18,030 --> 00:27:21,926
what's your team expertise? If you're all non

439
00:27:21,958 --> 00:27:26,262
Javascript developers, maybe again, everything I said in this presentation

440
00:27:26,326 --> 00:27:30,134
of testing with Javascript is nonsense for your team. It doesn't

441
00:27:30,182 --> 00:27:33,578
worth the trouble to then write Javascript tests.

442
00:27:33,674 --> 00:27:37,758
But if you are like a full stack has I would say sometimes team

443
00:27:37,844 --> 00:27:41,246
then it might make more sense. Think of what the

444
00:27:41,268 --> 00:27:44,634
application uses again, that's why it's important if you're using angular.

445
00:27:44,682 --> 00:27:48,846
If you users in react it will play a major role of what these infrastructure

446
00:27:48,878 --> 00:27:52,626
you have because test infrastructure is what matters. Can you

447
00:27:52,648 --> 00:27:56,040
actually support? Do you care about parallel execution at all?

448
00:27:58,490 --> 00:28:02,086
Do your service can handle that? And I always like

449
00:28:02,108 --> 00:28:04,150
to end my talks with call for action.

450
00:28:05,290 --> 00:28:08,738
Evaluate your current test infrastructure test architecture.

451
00:28:08,834 --> 00:28:12,698
Does it worth changing it? Have domain boundaries? Know exactly

452
00:28:12,784 --> 00:28:16,614
where you're working? Are you going all the way to end to end tests

453
00:28:16,662 --> 00:28:20,582
integration tests? Or you can simply stay at unit tests and then don't bother

454
00:28:20,726 --> 00:28:24,202
of my changes these unify your test strategy.

455
00:28:24,266 --> 00:28:27,870
Think about it the long run and again don't have the shifts between

456
00:28:27,940 --> 00:28:31,742
we have end to end tests with one framework, unit test

457
00:28:31,796 --> 00:28:36,142
with another, and integration. We use some old

458
00:28:36,196 --> 00:28:39,634
fashioned language for that, so think about that as well. Have it

459
00:28:39,672 --> 00:28:43,646
as few hoops you have to jump through when you're testing and debugging those tests

460
00:28:43,678 --> 00:28:47,106
as possible. Think of onboarding someone new for your

461
00:28:47,128 --> 00:28:50,386
test infrastructure and gives you kind of a good perspective.

462
00:28:50,498 --> 00:28:54,134
But experiment first. Don't just convince your team

463
00:28:54,172 --> 00:28:57,734
to switch before you do the proof of concept. Give it a try first

464
00:28:57,772 --> 00:29:00,726
and then see if it works. So thank you so much.

465
00:29:00,748 --> 00:29:04,518
Unfortunately we can't do q a over the Internet here, but if you want to

466
00:29:04,524 --> 00:29:08,246
contact me, please do on my twitter, my blog, website,

467
00:29:08,348 --> 00:29:11,180
LinkedIn, or directly email me.

