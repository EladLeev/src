1
00:00:25,410 --> 00:00:28,934
You hi, welcome to Conf 42

2
00:00:28,972 --> 00:00:32,854
Javascript. We're going to talk about JavaScript, the grumpy parts. Why is it so

3
00:00:32,892 --> 00:00:36,678
weird and how can we demystify it? Here's the

4
00:00:36,684 --> 00:00:39,094
part where I tell you, I'm definitely going to post the slides on my site

5
00:00:39,132 --> 00:00:43,442
tonight, but they are online already. Let's head out to roberich.org.

6
00:00:43,506 --> 00:00:46,626
We'll click on presentations here at the top. And here's Javascript,

7
00:00:46,658 --> 00:00:49,966
the grumpy parts. The slides are online right now.

8
00:00:50,028 --> 00:00:53,262
It while we're here on robrich.org, let's click on about

9
00:00:53,316 --> 00:00:56,794
me and we'll see some of the things that I've done recently. I'm a Microsoft

10
00:00:56,842 --> 00:01:00,330
MVP, a Docker captain and a friend of Redgate.

11
00:01:00,490 --> 00:01:03,834
I'm a Cyral developer advocate. So if you're struggling with your data mesh,

12
00:01:03,882 --> 00:01:07,878
I'd love to learn from you. AZ Giftcamp is really fun AZ Giftcamp

13
00:01:07,914 --> 00:01:11,886
brings volunteer developers together with charities to build free software.

14
00:01:11,998 --> 00:01:15,778
We start Friday after work. Sunday afternoon we deliver completed software to

15
00:01:15,784 --> 00:01:19,026
the charities. Sleep is optional, caffeine provided. If you're in

16
00:01:19,048 --> 00:01:22,566
Phoenix, come join us for the next AZ give camp. Or if you'd like

17
00:01:22,588 --> 00:01:25,782
a give camp where you live, hit me up on email or Twitter and

18
00:01:25,836 --> 00:01:29,398
let's get a give camp in your neighborhood too. Some of the other things that

19
00:01:29,404 --> 00:01:33,114
I've done, I worked on these gulp team as a core contributor in version two

20
00:01:33,152 --> 00:01:36,646
and version three. And one of the things I'm

21
00:01:36,678 --> 00:01:40,446
particularly proud of I replied to a Net Rocks podcast episode. They read

22
00:01:40,468 --> 00:01:42,670
my comment on the air and they sent me a mug.

23
00:01:43,730 --> 00:01:46,906
So there's my claim to fame. So let's

24
00:01:46,938 --> 00:01:51,774
dig into Javascript. The grumpy parts we

25
00:01:51,812 --> 00:01:55,194
talked about. This guy I want to thank Jonathan Mills.

26
00:01:55,242 --> 00:01:58,802
He created a talk called a guide to Javascript. Scary side.

27
00:01:58,936 --> 00:02:02,354
And this talk is kind of an extension of the conversation that we had.

28
00:02:02,392 --> 00:02:05,986
After that, if you had a chance to see John Mills in

29
00:02:06,008 --> 00:02:09,558
action, it is a great talk. We're going

30
00:02:09,564 --> 00:02:12,850
to get to the spot where we may hit these edge of my knowledge.

31
00:02:12,930 --> 00:02:16,866
I'm excited to do that. Let's explore comments and concerns

32
00:02:16,898 --> 00:02:20,534
and dig into those things that you want to learn about. And let's

33
00:02:20,582 --> 00:02:24,060
see, can we stump me? That'll be fun.

34
00:02:26,590 --> 00:02:30,454
Javascript this is Brendan Ike.

35
00:02:30,502 --> 00:02:34,400
Brendan Ike wrote JavaScript 25 years ago in ten days.

36
00:02:35,330 --> 00:02:39,214
The code that I wrote 25 years ago is pretty awful. The code

37
00:02:39,252 --> 00:02:42,706
that he wrote 25 years ago is powering the majority of the

38
00:02:42,728 --> 00:02:46,466
Internet. That's amazing. If you want to grab the slides from

39
00:02:46,488 --> 00:02:49,634
roberts.org and you can read more or watch more about

40
00:02:49,752 --> 00:02:53,010
Brendan Ike's journey in creating JavaScript.

41
00:02:54,790 --> 00:02:58,326
JavaScript the cool part is that we now

42
00:02:58,348 --> 00:03:02,054
have Javascript in lots of different runtimes. I bet you

43
00:03:02,092 --> 00:03:05,080
have a JavaScript runtime in your pocket right now.

44
00:03:05,450 --> 00:03:09,250
For Chrome we have V eight. V eight also powers node.

45
00:03:09,410 --> 00:03:12,854
In Firefox we have Spidermonkey. The old Internet Explorer

46
00:03:12,902 --> 00:03:16,646
had the Chakra JavaScript engine, and Safari has the JavaScript core

47
00:03:16,678 --> 00:03:19,906
engine. And the cool part is that each of these engines

48
00:03:19,958 --> 00:03:23,086
has been copied with amazing fidelity, so you

49
00:03:23,108 --> 00:03:26,538
won't find differences in JavaScript in various engines.

50
00:03:26,634 --> 00:03:30,410
Maybe newer features aren't implemented yet, but JavaScript

51
00:03:30,490 --> 00:03:34,210
itself is incredibly consistent across platforms.

52
00:03:34,790 --> 00:03:38,466
Now it was copied with amazing fidelity in

53
00:03:38,488 --> 00:03:42,274
the early days when we were struggling with JavaScript. What we were struggling with was

54
00:03:42,312 --> 00:03:45,582
not JavaScript, it was the document object model,

55
00:03:45,656 --> 00:03:48,966
the DoM. The implementation between JavaScript and

56
00:03:48,988 --> 00:03:52,914
the DOM was really haphazard, and that's been standardized

57
00:03:52,962 --> 00:03:56,754
a lot with HTML five. But that's the part that isn't consistent.

58
00:03:56,802 --> 00:04:00,194
Javascript. The language itself has been copied amazingly

59
00:04:00,242 --> 00:04:02,838
well, including the bugs.

60
00:04:03,014 --> 00:04:07,034
Brendan Ike was interviewed and said about two weeks after he built

61
00:04:07,072 --> 00:04:09,882
it, he noticed a bunch of bugs and he wanted to go back and fix

62
00:04:09,936 --> 00:04:13,662
it. And they said no, there's 40 developers building

63
00:04:13,716 --> 00:04:17,578
JavaScript apps. I bet there's 40 developers right now wishing

64
00:04:17,594 --> 00:04:19,840
these had gone back and fixed them.

65
00:04:20,850 --> 00:04:24,542
But the cool part is that the methodology of JavaScript

66
00:04:24,606 --> 00:04:28,434
is this mechanism where we download our source code into

67
00:04:28,472 --> 00:04:32,354
the browser. Now this is interesting, unlike other things

68
00:04:32,472 --> 00:04:36,206
where maybe we'll create an executable and ship that executable,

69
00:04:36,318 --> 00:04:40,386
or we'll create an image and you don't need all the Photoshop details

70
00:04:40,418 --> 00:04:44,226
and all the layers. By comparison, in JavaScript we are shipping source

71
00:04:44,258 --> 00:04:47,702
code. So the methodology is that that source code

72
00:04:47,756 --> 00:04:51,578
is running in an environment where the developer has already left.

73
00:04:51,744 --> 00:04:54,954
It's a memory constrained area, and so the goal of

74
00:04:54,992 --> 00:04:58,860
JavaScript is to keep going as long as possible.

75
00:04:59,550 --> 00:05:03,402
Now that means that, well, if it finds an error,

76
00:05:03,466 --> 00:05:06,254
it's going to back up and try to see if it can fix it by

77
00:05:06,292 --> 00:05:10,014
inserting a semicolon. So the magic question

78
00:05:10,212 --> 00:05:13,514
are semicolons required? Well yes, the engine

79
00:05:13,572 --> 00:05:17,086
does require it. It's just really good at putting them in place if you don't.

80
00:05:17,198 --> 00:05:21,294
So if you leave off the semicolons, then JavaScript

81
00:05:21,342 --> 00:05:25,198
will help. Let's take a look at

82
00:05:25,224 --> 00:05:29,126
some of the weird JavaScript parts. This is

83
00:05:29,148 --> 00:05:32,326
a talk where Brendan Icke plays a

84
00:05:32,348 --> 00:05:35,622
video called JavaScript Watt and I love this

85
00:05:35,676 --> 00:05:38,874
grab the slides from roberts.org and push play. You will

86
00:05:38,912 --> 00:05:43,350
really enjoy this video. The cool part is this is at Fluentcomp

87
00:05:43,430 --> 00:05:47,146
where Brendan Icke is actually giving commentary throughout the video.

88
00:05:47,328 --> 00:05:51,382
That is amazing. In that video these talk about lets of weird

89
00:05:51,446 --> 00:05:55,166
parts about JavaScript. We're not going to dig into all those, but let's look at

90
00:05:55,188 --> 00:05:59,086
a couple of the weirder ones. Undefined undefined is

91
00:05:59,108 --> 00:06:02,686
just a variable in JavaScript. In later versions of JavaScript it

92
00:06:02,708 --> 00:06:06,642
behave a constant, but in early

93
00:06:06,696 --> 00:06:10,258
versions of JavaScript it was just a variable, so you could

94
00:06:10,344 --> 00:06:13,986
say assign it. That's a great way to break a lot

95
00:06:14,008 --> 00:06:16,710
of programs to assign something to undefined.

96
00:06:18,170 --> 00:06:21,794
Similarly, type of null type of null

97
00:06:21,842 --> 00:06:24,966
is an object. That's weird. Why wouldn't type of

98
00:06:24,988 --> 00:06:28,342
null be null or undefined? Yeah,

99
00:06:28,396 --> 00:06:31,958
that's probably a, but similarly

100
00:06:32,054 --> 00:06:35,626
type of not a number type of Nan. Now as

101
00:06:35,648 --> 00:06:39,222
we look at the types in JavaScript, we have functions, we have objects,

102
00:06:39,286 --> 00:06:42,698
we have numbers, we have strings, we have booleans,

103
00:06:42,794 --> 00:06:46,558
we have arrays. So what type is

104
00:06:46,644 --> 00:06:50,366
not a number? Well, it's kind of in the number family, so I kind

105
00:06:50,388 --> 00:06:53,794
of get that it was organized that way. But is

106
00:06:53,832 --> 00:06:57,380
this a bug? Not sure.

107
00:06:59,030 --> 00:07:02,802
The compiler now a lot of the weirdness that is

108
00:07:02,856 --> 00:07:06,446
JavaScript is based on how the compiler works. Let's dig in deep

109
00:07:06,478 --> 00:07:10,086
and see if we can understand the compiler. Now at each step

110
00:07:10,188 --> 00:07:13,238
we're going to take a look at how this code works. We're going

111
00:07:13,244 --> 00:07:16,310
to think like the compiler to see if we can disambiguate it,

112
00:07:16,380 --> 00:07:19,562
make it make sense. The Javascript compiler is

113
00:07:19,616 --> 00:07:23,386
a two phase compiler. These first pass it

114
00:07:23,408 --> 00:07:26,938
goes and looks for memory that it needs to allocate. The second pass,

115
00:07:27,024 --> 00:07:30,134
it executes all the code. Now there are a whole

116
00:07:30,192 --> 00:07:34,186
lot of modern updates to compilers that'll do tree

117
00:07:34,218 --> 00:07:38,970
shaking and just in time recompilation and comparing hotpaths.

118
00:07:39,050 --> 00:07:42,974
And those are interesting, but still fundamentally it is a

119
00:07:43,012 --> 00:07:46,350
two phase compiler. Grab these slides from robertsch.org,

120
00:07:46,430 --> 00:07:49,266
click on the read more or the watch more link, and you can learn more

121
00:07:49,288 --> 00:07:52,530
about the Javascript two parts compiler.

122
00:07:54,230 --> 00:07:57,606
So here's some code, and let's take a look at how

123
00:07:57,628 --> 00:08:00,790
that behaves with this two parts compiler.

124
00:08:01,610 --> 00:08:04,786
We start by defining a function, and then we'll execute

125
00:08:04,818 --> 00:08:08,058
that function. As we get into that function we go looking for a

126
00:08:08,064 --> 00:08:11,002
variable called foo. If true.

127
00:08:11,136 --> 00:08:14,774
Now in this case variables are defined

128
00:08:14,822 --> 00:08:18,474
with function scope, not curly brace scope. So we've defined a

129
00:08:18,512 --> 00:08:21,614
foo variable and set its value to bar.

130
00:08:21,812 --> 00:08:23,840
Then we console log foo again.

131
00:08:24,370 --> 00:08:27,600
Now when we first look at this, we go well,

132
00:08:28,370 --> 00:08:31,550
how are we using the variable before it's defined?

133
00:08:32,130 --> 00:08:36,146
Yes, let's think like the compiler and see if we can figure this out.

134
00:08:36,328 --> 00:08:40,270
Using the two these compiler, we first look for variable allocations.

135
00:08:40,350 --> 00:08:43,922
So here's one. We've got that variable and it is scoped to this main

136
00:08:43,976 --> 00:08:47,566
function. Okay, second path, let's execute

137
00:08:47,598 --> 00:08:51,046
it. We execute the main function and now we want

138
00:08:51,068 --> 00:08:54,546
to go log the foo variable. Well, we defined it here. It doesn't

139
00:08:54,578 --> 00:08:58,466
have a value set. So we'll console log undefined. Then we'll assign

140
00:08:58,498 --> 00:09:02,940
it to bar and we'll log it again. So we get undefined and bar.

141
00:09:03,790 --> 00:09:07,418
It's much like this. And here's variable hoisting where we've kind

142
00:09:07,424 --> 00:09:11,098
of given ourselves a good interpretation of what's happening.

143
00:09:11,264 --> 00:09:15,210
Now, this isn't actually what's happening. What's happening is that two pass compiler.

144
00:09:15,290 --> 00:09:18,718
But we can give ourselves this kind of mental trick so that

145
00:09:18,724 --> 00:09:23,034
we don't have to think of that. We call this variable hoisting. We pretend

146
00:09:23,162 --> 00:09:26,786
that that variable got defined up here and set to undefined and

147
00:09:26,808 --> 00:09:30,546
now we can reason about it a little easier. Okay, got defined and then we

148
00:09:30,568 --> 00:09:35,006
do it and away we go hoisting.

149
00:09:35,198 --> 00:09:38,662
It's a lie. It's a convenient lie and it works

150
00:09:38,716 --> 00:09:42,742
for us, but it's an artifact of this two

151
00:09:42,796 --> 00:09:46,470
parts compiler. If we think like the compiler and we understand

152
00:09:46,540 --> 00:09:50,346
that two phase process, then variable hoisting is

153
00:09:50,448 --> 00:09:54,090
a lie that we may not need anymore. Or maybe it's still convenient.

154
00:09:56,590 --> 00:09:59,702
So when we look at this and we think like the compiler,

155
00:09:59,766 --> 00:10:03,086
we can kind of understand what's going on. Let's do a lot of

156
00:10:03,108 --> 00:10:06,670
exercises of doing exactly this thinking like the compiler.

157
00:10:08,370 --> 00:10:12,126
First we'll start with variable scope. Let's take a look at what happens when

158
00:10:12,148 --> 00:10:15,770
we define and don't define variables in various scopes.

159
00:10:15,930 --> 00:10:19,906
Now I'm going to define two variables here, one outside these function and

160
00:10:19,928 --> 00:10:23,486
one inside the function. Maybe this is foo one and foo two, or foo

161
00:10:23,518 --> 00:10:26,760
outer and foo inner. Now take a moment,

162
00:10:27,210 --> 00:10:29,560
pause the video. What happens here?

163
00:10:31,210 --> 00:10:33,960
Let's think like the compiler and figure it out.

164
00:10:34,410 --> 00:10:37,910
First we go look for variable allocations. We've got one here,

165
00:10:37,980 --> 00:10:41,270
one here, so we've defined those two foo variables,

166
00:10:41,610 --> 00:10:44,966
second parts. Now let's go execute it. Let's set the outer foo

167
00:10:44,998 --> 00:10:48,460
to bar. Let's define a function, call that function.

168
00:10:49,550 --> 00:10:53,180
We'll set the second variable to bas.

169
00:10:53,490 --> 00:10:57,262
Okay, so we know that variables in Javascript are

170
00:10:57,316 --> 00:11:00,506
function scoped, not curly brace scoped so here we're

171
00:11:00,538 --> 00:11:03,586
going to go look for a foo variable. In our current scope, we find this

172
00:11:03,608 --> 00:11:07,314
inner foo and we set what was baz to bam and let's log

173
00:11:07,352 --> 00:11:10,830
it. Then leaving the curly braces,

174
00:11:10,910 --> 00:11:15,374
let's log foo again and so we get bam again leaving

175
00:11:15,422 --> 00:11:19,574
that function, we'll now log foo and we'll log this outer foo bar.

176
00:11:19,772 --> 00:11:23,640
So we got bam, bam, and bar. Is that what you got?

177
00:11:25,450 --> 00:11:28,806
Let's do it again, but in this case instead of defining

178
00:11:28,838 --> 00:11:32,282
it here, we'll define it here. What happens

179
00:11:32,336 --> 00:11:35,546
in this case, let's think

180
00:11:35,568 --> 00:11:39,906
like the compiler and figure it out. Our first pass is defining variables.

181
00:11:40,038 --> 00:11:43,214
We look for variable allocations. We find outer foo and we find

182
00:11:43,252 --> 00:11:47,006
inner foo and we've got those marked. Next pass,

183
00:11:47,108 --> 00:11:50,910
let's, pardon me, next pass,

184
00:11:50,980 --> 00:11:54,366
let's execute it. So we'll set our outer foo to bar.

185
00:11:54,468 --> 00:11:58,146
We'll define our function and then execute it. We'll set a

186
00:11:58,248 --> 00:12:01,938
foo variable to Bas. Now we're looking for a foo variable in

187
00:12:01,944 --> 00:12:05,394
our current scope. Inside these curly braces we find

188
00:12:05,512 --> 00:12:09,238
this foo variable and it is in scope because these variables are scoped to

189
00:12:09,324 --> 00:12:13,142
functions, not to curly braces. So these variable we set

190
00:12:13,196 --> 00:12:16,854
to Baz. Now inside the curly braces we go looking

191
00:12:16,892 --> 00:12:20,246
for a foo variable and we find that same one and we set what

192
00:12:20,268 --> 00:12:24,006
was baz to bam. We'll console log that, we'll console

193
00:12:24,038 --> 00:12:28,138
log it again and so we get bam twice leaving the function.

194
00:12:28,224 --> 00:12:31,934
We're now looking for an outer foo variable. We find bar,

195
00:12:32,052 --> 00:12:34,800
so we get bam, bam, bar,

196
00:12:35,330 --> 00:12:36,800
is that what you got?

197
00:12:38,290 --> 00:12:41,898
Let's do it again, but in this case let's only define

198
00:12:41,994 --> 00:12:45,794
the variable, but here what

199
00:12:45,832 --> 00:12:49,346
happens here? Let's think like the

200
00:12:49,368 --> 00:12:53,278
compiler and figure it out. Our first pass is to define the variables, so we'll

201
00:12:53,294 --> 00:12:57,054
allocate this outer foo variable. Next pass we'll start assigning

202
00:12:57,102 --> 00:13:00,854
things, so we'll assign it to bar. Then we'll define and then

203
00:13:00,892 --> 00:13:04,098
execute our function. And then we'll go looking for a foo variable.

204
00:13:04,194 --> 00:13:07,826
Now we don't find a foo variable in this current scope, so we'll climb

205
00:13:07,858 --> 00:13:11,434
up scopes. We found one here in these outer scope and

206
00:13:11,472 --> 00:13:13,850
so what was bar is now Baz.

207
00:13:15,950 --> 00:13:19,626
Let's go looking for a foo variable again. We'll find this variable and let's set

208
00:13:19,648 --> 00:13:23,222
what was Baz to bam console log. Bam and bam.

209
00:13:23,366 --> 00:13:26,894
And then as we leave the function we'll console log it again. We go

210
00:13:26,932 --> 00:13:29,886
looking for the variable and we find this one in our current scope that we

211
00:13:29,908 --> 00:13:33,154
set to bam previously. And so in this case we get bam three

212
00:13:33,192 --> 00:13:35,380
times. Is that what you got?

213
00:13:37,350 --> 00:13:41,410
Let's do it again. But in this case we're not defining any variables.

214
00:13:42,150 --> 00:13:45,714
What happens here? Let's think

215
00:13:45,752 --> 00:13:49,746
like the compiler and figure it out. Our first pass, we go allocate variables

216
00:13:49,778 --> 00:13:52,854
and in this case there aren't any. Next pass,

217
00:13:53,052 --> 00:13:56,374
let's start by looking for a foo variable to assign to bar.

218
00:13:56,492 --> 00:14:00,226
Now we don't have a foo variable defined in these scope, so we start climbing

219
00:14:00,258 --> 00:14:03,894
up scopes and eventually we get to the global scope. Now Javascript

220
00:14:03,942 --> 00:14:07,482
is an engine that tries to recover from errors as best it possibly can.

221
00:14:07,536 --> 00:14:11,682
So it says, hey, I'll invent one for you, and it creates a global

222
00:14:11,766 --> 00:14:15,326
variable called foo. Okay, so let's set that

223
00:14:15,348 --> 00:14:18,746
global variable to bar. We'll define our function and then execute

224
00:14:18,778 --> 00:14:22,638
it, and then we'll go looking for a global variable. Now we

225
00:14:22,644 --> 00:14:26,802
don't have a variable foo in this scope, but we can climb up through

226
00:14:26,856 --> 00:14:30,546
outer scopes and eventually into the global scope and find that

227
00:14:30,568 --> 00:14:34,510
variable that we created before. So what was bar is now Baz.

228
00:14:34,670 --> 00:14:37,960
Let's set what was Baz to bam and log it.

229
00:14:38,490 --> 00:14:42,230
And then leaving the function, we will log it again. And so we will log

230
00:14:42,300 --> 00:14:45,878
bam three times. Now we did end up with

231
00:14:45,884 --> 00:14:49,442
a global variable. Global variables are really awkward

232
00:14:49,506 --> 00:14:52,634
because for example, if I create an I variable and

233
00:14:52,672 --> 00:14:55,846
you create an I variable and we both forget to define

234
00:14:55,878 --> 00:14:59,386
them, then well, we'll start to stomp on each other.

235
00:14:59,488 --> 00:15:03,866
That's bad. So let's

236
00:15:03,898 --> 00:15:07,818
do this again. Now I'm going to set foo equal

237
00:15:07,834 --> 00:15:10,800
to bam. What happens here?

238
00:15:12,850 --> 00:15:16,482
Let's think like the compiler and figure it out. Okay, first step,

239
00:15:16,536 --> 00:15:20,482
we look for allocations. We find one here and next

240
00:15:20,536 --> 00:15:23,266
we will execute it. So we'll set our outer foo to bar,

241
00:15:23,368 --> 00:15:26,830
we'll define and these execute a function, we will set our foo,

242
00:15:26,910 --> 00:15:30,546
oh, let's find a foo. We find one in this outer scope.

243
00:15:30,578 --> 00:15:33,942
So we'll set what was bar to Baz inside here,

244
00:15:33,996 --> 00:15:37,398
we will set foo to these value of bam. Ooh, we need

245
00:15:37,404 --> 00:15:40,738
to go find a bam variable. We look in the current scope, there is no

246
00:15:40,764 --> 00:15:44,538
bam in the outer scope, there also is no bam. Eventually we get up

247
00:15:44,544 --> 00:15:48,106
to the global scope, still no bam. So we

248
00:15:48,128 --> 00:15:52,342
get an error here, we can't read the value of an undefined variable

249
00:15:52,486 --> 00:15:55,790
and so we get a reference error. Bam is not defined.

250
00:15:56,290 --> 00:15:59,626
Wait a minute. If we tried to set a variable that didn't

251
00:15:59,658 --> 00:16:03,130
exist, it worked. If we try to get a variable that doesn't exist,

252
00:16:03,210 --> 00:16:06,206
it doesn't work. Yeah, that's kind of weird,

253
00:16:06,318 --> 00:16:10,046
but we understand now why it is. Javascript tries to correct whenever

254
00:16:10,078 --> 00:16:13,070
it can, and it can create new variables. That's easily,

255
00:16:13,150 --> 00:16:17,198
that's easy, but it can't read from variables that aren't defined.

256
00:16:17,294 --> 00:16:20,966
So this fails. If ever you've put a console log

257
00:16:21,068 --> 00:16:24,214
right above the variable that you thought you were defining, and you

258
00:16:24,252 --> 00:16:28,454
actually weren't defining it, you might have seen this error. So Javascript

259
00:16:28,502 --> 00:16:31,180
will stop here and that's all we'll get.

260
00:16:33,070 --> 00:16:36,330
Next up, instead of VAR, let's switch these

261
00:16:36,400 --> 00:16:39,926
for let is new in es five and allows

262
00:16:39,958 --> 00:16:43,338
us to create functions or create variables that are scoped

263
00:16:43,354 --> 00:16:47,214
to curly braces, not to functions. Now this may feel a little bit more

264
00:16:47,252 --> 00:16:51,194
natural if ever you've used curly brace style languages like C sharp,

265
00:16:51,242 --> 00:16:54,722
Java C, or C plus plus. So what happens

266
00:16:54,776 --> 00:16:58,146
here? Let's think like the

267
00:16:58,168 --> 00:17:01,634
compiler and figure it out. We start by defining by

268
00:17:01,672 --> 00:17:05,342
allocating variables. So we'll allocate our outer foo and our inner foo.

269
00:17:05,486 --> 00:17:09,018
Then let's execute, we'll set our outer foo

270
00:17:09,054 --> 00:17:12,374
to bar and then we'll define and then execute this function.

271
00:17:12,492 --> 00:17:16,274
Now we go looking for a foo variable. Now we don't have a foo variable

272
00:17:16,322 --> 00:17:19,778
defined in these scope. Let defines these associated with

273
00:17:19,804 --> 00:17:23,900
a curly brace. So that doesn't exist yet. So we find this outer function,

274
00:17:24,350 --> 00:17:28,250
this outer variable, and we set what was bar to Baz.

275
00:17:28,590 --> 00:17:31,958
Now inside the curly braces we'll define a foo variable that is scoped

276
00:17:31,974 --> 00:17:35,546
to these two curly braces. Let's set its value to bam and console

277
00:17:35,578 --> 00:17:39,354
log bam. Now as we leave these curly braces, this inner foo

278
00:17:39,402 --> 00:17:42,986
disappears and now we're left looking for a foo.

279
00:17:43,098 --> 00:17:47,250
We find this foo, this outer foo, and so we log baz

280
00:17:47,830 --> 00:17:51,294
finishing our function, we will log the outer foo again and we get Baz.

281
00:17:51,422 --> 00:17:54,994
Bam, baz, baz, is that what you

282
00:17:55,032 --> 00:17:58,226
got? Now let's

283
00:17:58,258 --> 00:18:02,022
comment out this variable. What happens

284
00:18:02,076 --> 00:18:05,766
here? Let's think like the

285
00:18:05,788 --> 00:18:09,846
compiler and figure it out. We'll allocate this inner foo variable and

286
00:18:09,868 --> 00:18:13,526
then we will define and then execute our function. We're looking for a foo

287
00:18:13,558 --> 00:18:17,446
variable in the current scope. We don't find one. We climb up to the outer

288
00:18:17,478 --> 00:18:20,486
scope, we don't find one there. We keep climbing until we get to the global

289
00:18:20,518 --> 00:18:24,618
scope, not finding one. We will create one, a global variable,

290
00:18:24,714 --> 00:18:28,202
and we will set its value to Baz inside the curly braces.

291
00:18:28,266 --> 00:18:31,674
We'll set our inner foo to bam and console long bam,

292
00:18:31,802 --> 00:18:35,670
leaving the curly braces this inner foo gets garbage collected and now we're

293
00:18:35,690 --> 00:18:39,170
looking for foo. We'll find our global variable that we set to Baz.

294
00:18:39,670 --> 00:18:42,834
Now leaving our function, we're looking for a variable called

295
00:18:42,872 --> 00:18:46,722
foo. We will find that global variable and we will log Baz

296
00:18:46,786 --> 00:18:50,886
again. Bam. Baz, baz, wait a

297
00:18:50,908 --> 00:18:54,246
minute. We just created a

298
00:18:54,268 --> 00:18:57,830
variable that leaked outside of its current scope.

299
00:18:58,730 --> 00:19:02,182
Yeah, you're right, because we didn't define this variable,

300
00:19:02,246 --> 00:19:05,622
it wasn't scoped to either this function or this curly brace,

301
00:19:05,686 --> 00:19:08,966
and therefore we leaked it into the global scope. There's a memory

302
00:19:08,998 --> 00:19:12,862
leak in Javascript now instead

303
00:19:12,916 --> 00:19:16,686
of let, what did we

304
00:19:16,708 --> 00:19:20,318
do? Oh, now let's define this let here.

305
00:19:20,404 --> 00:19:24,030
We want to fix our mistake and define this variable

306
00:19:24,110 --> 00:19:27,060
inside here. What happens here?

307
00:19:27,990 --> 00:19:31,410
Let's think like the compiler and figure it out. We start out looking

308
00:19:31,480 --> 00:19:34,354
for defining and then executing our function.

309
00:19:34,472 --> 00:19:38,166
We will set our foo variable to bath inside this

310
00:19:38,188 --> 00:19:41,174
curly brace. We'll set an inner foo to bam, console log.

311
00:19:41,292 --> 00:19:45,526
Bam. As we leave, this inner one gets garbage collected and

312
00:19:45,628 --> 00:19:48,934
our outside one is Baz. And then

313
00:19:48,972 --> 00:19:52,866
as we leave we're going to look for a foo variable. Now the goal

314
00:19:52,898 --> 00:19:56,426
is to console log it. And so we climb up through various scopes, we get

315
00:19:56,448 --> 00:19:59,654
to the global scope, still don't find it, and we get a reference error.

316
00:19:59,702 --> 00:20:03,194
Foo is not defined because we correctly allocated

317
00:20:03,242 --> 00:20:06,782
our variable here. Then we get a reference error as we would expect,

318
00:20:06,916 --> 00:20:10,526
rather than just silently leaking that variable into place.

319
00:20:10,708 --> 00:20:13,470
It's really important for us to define our variables.

320
00:20:15,170 --> 00:20:18,962
Now let's flip over from let to const. Now the cool part about

321
00:20:19,016 --> 00:20:22,686
const is you can't reassign it. Now const, you can't reassign

322
00:20:22,718 --> 00:20:26,006
the pointer to that object, but you can still mutate the

323
00:20:26,028 --> 00:20:29,270
object. In this case we're using

324
00:20:29,340 --> 00:20:32,706
value types instead of reference types, and so we can't

325
00:20:32,818 --> 00:20:35,974
change what foo points to. Okay,

326
00:20:36,092 --> 00:20:39,594
what happens here? Our first pass, we will

327
00:20:39,632 --> 00:20:43,286
allocate some variables. Here's our outer foo. Here's our inner foo.

328
00:20:43,398 --> 00:20:46,458
Next pass, let's execute it.

329
00:20:46,544 --> 00:20:49,642
We'll set our outer foo to bar. We can't change that value

330
00:20:49,696 --> 00:20:53,178
anymore. We will define and execute our function.

331
00:20:53,264 --> 00:20:56,606
We go looking for a foo variable. We don't have one in this

332
00:20:56,628 --> 00:20:59,594
current scope because it's const scope to curly braces.

333
00:20:59,642 --> 00:21:02,862
So this inner foo doesn't exist. So we try to set

334
00:21:02,916 --> 00:21:06,362
foo equal to baz. We find this outer foo

335
00:21:06,426 --> 00:21:09,666
and we try to set it. It's a const and it won't. And we get

336
00:21:09,688 --> 00:21:13,634
a type error assignment to a constant variable. Now this is perfect.

337
00:21:13,752 --> 00:21:17,490
If you're targeting es five or above, you will get this error.

338
00:21:17,650 --> 00:21:21,622
But if you're using Babel and webpack to transpile this

339
00:21:21,676 --> 00:21:24,786
into a lower form of Javascript,

340
00:21:24,898 --> 00:21:28,406
then it will try to do as best it can, but it

341
00:21:28,428 --> 00:21:31,558
can't catch this assignment under the hood,

342
00:21:31,654 --> 00:21:34,998
it will set it to VAR. So if you're upgrading

343
00:21:35,014 --> 00:21:38,826
your project from es three to es five, and you're modifying your

344
00:21:38,848 --> 00:21:42,506
Babel config to maybe spit out Es next, and suddenly

345
00:21:42,538 --> 00:21:46,126
you get a whole lot of these errors. It's not the change in Babel that

346
00:21:46,228 --> 00:21:49,498
caused this, but rather that you were transpiling

347
00:21:49,594 --> 00:21:53,694
all of the const to Vars. And well,

348
00:21:53,892 --> 00:21:57,522
parts aren't read only. So types you need to go fix

349
00:21:57,576 --> 00:22:01,026
your const to make that happen. Now we

350
00:22:01,048 --> 00:22:04,526
got to look at a lot of ways of defining and not defining scopes

351
00:22:04,558 --> 00:22:07,220
in interesting ways. Let's take a look at this.

352
00:22:08,310 --> 00:22:11,894
This is the thing to the left of the dot. And I really like this

353
00:22:11,932 --> 00:22:15,686
definition. It's very concise. Click read more or

354
00:22:15,708 --> 00:22:19,400
watch more as you grab the slides from roberts.org to learn more.

355
00:22:19,850 --> 00:22:23,402
So let's take this for a spin. Now, we have this console log

356
00:22:23,456 --> 00:22:27,578
where we're going to grab this name and we have this speak function.

357
00:22:27,664 --> 00:22:31,530
Yes, we could have defined it in place in each object, but for simplicity,

358
00:22:31,610 --> 00:22:34,880
we'll just define it out here. What happens here?

359
00:22:35,730 --> 00:22:39,646
Well, we start out saying a global name. So we'll speak.

360
00:22:39,748 --> 00:22:42,874
And so this is our global object and we'll

361
00:22:42,922 --> 00:22:46,994
do this. And so we'll get ninja right here for

362
00:22:47,032 --> 00:22:50,338
object one. This is the object that's these thing to the

363
00:22:50,344 --> 00:22:53,454
left of the dot. And so we'll get Doctor and then Skywalker.

364
00:22:53,502 --> 00:22:56,680
Ninja Doctor Skywalker. Perfect.

365
00:22:58,490 --> 00:23:02,706
Now, we can create variables

366
00:23:02,738 --> 00:23:06,166
from functions. So let's grab the object one speak and make it an

367
00:23:06,188 --> 00:23:10,026
object speak variable. Now, when we do object one

368
00:23:10,048 --> 00:23:13,702
speak, it works as expected and we get Docker Doctor.

369
00:23:13,846 --> 00:23:17,366
But here, object speak, what is the global

370
00:23:17,398 --> 00:23:21,214
variable? Well, it's undefined. Now, I'm assuming that

371
00:23:21,252 --> 00:23:24,670
something defines name, otherwise we would have gotten a reference error.

372
00:23:25,250 --> 00:23:28,586
But because I removed the thing to the left of the dot,

373
00:23:28,698 --> 00:23:32,160
I've changed what this applies to.

374
00:23:33,990 --> 00:23:38,066
Similarly, if we do this in

375
00:23:38,088 --> 00:23:41,486
a page, let's document getbyid the button, and then we'll

376
00:23:41,518 --> 00:23:45,198
button add event listener, click here's our speak event and we'll console

377
00:23:45,214 --> 00:23:48,962
log this id. What's the thing to the left of the dot?

378
00:23:49,106 --> 00:23:52,630
It's the button. And so what gets passed in as

379
00:23:52,700 --> 00:23:56,946
this is the button, because we got it by id. When we output

380
00:23:56,978 --> 00:24:00,460
this, we get the button. Perfect.

381
00:24:01,950 --> 00:24:05,674
Now, I want to not show the name right now.

382
00:24:05,792 --> 00:24:08,874
Rather, I want to show it after a little while. So I'm going to set

383
00:24:08,912 --> 00:24:12,126
timeout. Now, the interesting thing about set timeout is it will

384
00:24:12,148 --> 00:24:15,614
create a new scope. So when we do

385
00:24:15,652 --> 00:24:19,354
this, what happens? Well, we're going to find ninja,

386
00:24:19,402 --> 00:24:23,086
and then we'll speak. We'll set timeout in 100 milliseconds. We'll go

387
00:24:23,108 --> 00:24:26,786
look for the thing, this name. What's the thing to the left of the

388
00:24:26,808 --> 00:24:29,870
dot? Well, it's the global object. We created a new scope,

389
00:24:29,950 --> 00:24:33,250
so we get ninja. Now, object one,

390
00:24:33,320 --> 00:24:36,866
speak. We'll wait 100 milliseconds, and then we'll look for

391
00:24:36,888 --> 00:24:39,686
the thing to the left of the dot, which is the global object, and we

392
00:24:39,708 --> 00:24:41,670
will get ninja. Oops.

393
00:24:42,730 --> 00:24:45,958
Because we created a new scope with this function,

394
00:24:46,124 --> 00:24:49,530
then we lost the context of the thing to the left of the dot.

395
00:24:49,870 --> 00:24:53,466
Let's see how we can control it. Now we can use

396
00:24:53,568 --> 00:24:57,146
call. Call is really interesting. Now,

397
00:24:57,248 --> 00:25:01,066
I've not defined an object here or not defined the speak,

398
00:25:01,168 --> 00:25:04,254
but I can say object one. Speak, call,

399
00:25:04,372 --> 00:25:07,406
and I'll pass in what I want this to be. In this

400
00:25:07,428 --> 00:25:10,798
case, it's OBJ two. So now when

401
00:25:10,884 --> 00:25:14,898
it gets passed in, I've overridden this, and it's now ob two.

402
00:25:14,984 --> 00:25:18,078
And so I will correctly get Dr. And Skywalker.

403
00:25:18,254 --> 00:25:22,050
Perfect. Next up, let's use this

404
00:25:22,200 --> 00:25:25,726
call to try and fix our set timeout bug. Now,

405
00:25:25,768 --> 00:25:29,158
the interesting thing is this executes the function right away,

406
00:25:29,324 --> 00:25:32,774
so I will get the right answer. But I didn't wait

407
00:25:32,812 --> 00:25:37,298
100 milliseconds. Let's see if we can delay

408
00:25:37,394 --> 00:25:40,390
these thing rather than just calling it right away.

409
00:25:40,540 --> 00:25:44,426
Let's see if we can wait and call it later. We have

410
00:25:44,528 --> 00:25:48,186
bind. Now, this isn't these actual syntax of bind, but we can kind of think

411
00:25:48,208 --> 00:25:51,546
of it these way. We'll have this fake bind function we'll pass in

412
00:25:51,568 --> 00:25:54,766
our function and what we want this to be. And we can return a

413
00:25:54,788 --> 00:25:58,606
new function that later will call passing in

414
00:25:58,628 --> 00:26:02,078
what we want this to be. So now we have this new function that we

415
00:26:02,084 --> 00:26:06,046
can call whenever we want. And this is already overwritten.

416
00:26:06,158 --> 00:26:09,774
That's cool. So let's use the real bind.

417
00:26:09,822 --> 00:26:13,810
Here's the real syntax. Object one, speak, bind, and we pass in the

418
00:26:13,880 --> 00:26:17,554
this. And so now we will

419
00:26:17,592 --> 00:26:20,722
get the values as we expect. Doctor and Skywalker.

420
00:26:20,866 --> 00:26:24,402
Perfect. Let's see if we can use this bind

421
00:26:24,466 --> 00:26:27,734
mechanism. Oh, you may find content in your code that says

422
00:26:27,772 --> 00:26:31,366
obst two speak, bind obst two. Basically, what they're

423
00:26:31,398 --> 00:26:35,674
trying to do is enforce that this object has overridden this

424
00:26:35,792 --> 00:26:39,094
in all these ways that it needs to so that it never loses

425
00:26:39,142 --> 00:26:42,766
context for what it's after. If you see that code in

426
00:26:42,788 --> 00:26:45,614
your code base a lot,

427
00:26:45,652 --> 00:26:49,402
that's exactly what it's doing. So let's use bind

428
00:26:49,466 --> 00:26:53,294
to see if we can solve this problem. Now,

429
00:26:53,332 --> 00:26:56,862
we'll start out by calling speak. It's going to create a new scope,

430
00:26:56,926 --> 00:27:00,194
but we've overridden that scope with what this is while

431
00:27:00,232 --> 00:27:03,874
we're inside here. This is the global function. And so in 100

432
00:27:03,912 --> 00:27:07,000
milliseconds, we output ninja. Perfect.

433
00:27:07,450 --> 00:27:10,886
Now, when you call object one speak, what comes in here?

434
00:27:10,988 --> 00:27:14,818
Object one is this. We'll set timeout. We'll override

435
00:27:14,914 --> 00:27:18,402
the global that it would assume with this, which is object

436
00:27:18,476 --> 00:27:21,978
one. And in 100 milliseconds, we get the correct answer.

437
00:27:22,144 --> 00:27:25,606
Great. Bind was able to help us solve

438
00:27:25,638 --> 00:27:27,130
our set timeout error.

439
00:27:28,510 --> 00:27:32,262
Let's use arrow functions. Now, the cool part about arrow functions

440
00:27:32,326 --> 00:27:36,014
is it defines a function in a really

441
00:27:36,132 --> 00:27:39,434
these syntax, but it also sets

442
00:27:39,482 --> 00:27:42,618
this at the point where the function is created.

443
00:27:42,794 --> 00:27:46,100
So it's much like calling dot bind this,

444
00:27:46,550 --> 00:27:50,514
right? As we define it, we can think of this as

445
00:27:50,552 --> 00:27:53,826
equivalent to this. Okay,

446
00:27:54,008 --> 00:27:57,286
so knowing that the arrow function is going to bind this at the point where

447
00:27:57,308 --> 00:28:00,866
it's instantiated, we might be able to use or misuse

448
00:28:00,898 --> 00:28:04,326
that. So let's create this speak function, and we

449
00:28:04,348 --> 00:28:07,526
will bind it to this name. And let's see what

450
00:28:07,548 --> 00:28:10,458
happens here. Well, when we call speak,

451
00:28:10,624 --> 00:28:14,378
we get to here. What's the thing that got bound when it

452
00:28:14,384 --> 00:28:18,438
was created? It was the global object. So speak, we get ninja.

453
00:28:18,614 --> 00:28:22,478
How about object one speak. When we call object one

454
00:28:22,564 --> 00:28:26,094
speak. Then it comes in here. This was defined with the

455
00:28:26,132 --> 00:28:29,562
global object in place. And so we also get ninja

456
00:28:29,626 --> 00:28:32,880
rather than Doctor or Skywalker Ninja. Three types.

457
00:28:33,830 --> 00:28:37,774
That's not great. If ever you've done a find and replace

458
00:28:37,822 --> 00:28:41,154
in your code base, changing from

459
00:28:41,192 --> 00:28:44,446
function to arrow functions, and these, your app doesn't work anymore.

460
00:28:44,558 --> 00:28:47,942
This is exactly what's happening. You've defined this in ways

461
00:28:47,996 --> 00:28:51,158
that you didn't expect. That's totally fine. Now that we understand

462
00:28:51,244 --> 00:28:54,630
how that works, we can use that correctly.

463
00:28:54,970 --> 00:28:58,646
There are times when we want function where we don't want to override this,

464
00:28:58,748 --> 00:29:02,026
and there's times when we do want to override this, where we can use that

465
00:29:02,048 --> 00:29:05,514
terser syntax. So let's use

466
00:29:05,552 --> 00:29:08,618
that. Well, we want to say obst two speak.

467
00:29:08,704 --> 00:29:11,100
Bind obs two to try and get our thing.

468
00:29:11,870 --> 00:29:15,994
But we've already created this envelope and we've baked the global

469
00:29:16,042 --> 00:29:19,374
scope into it, so we can put it in another envelope and

470
00:29:19,412 --> 00:29:22,618
try to set it to object two. But as we open the

471
00:29:22,644 --> 00:29:26,002
envelopes, eventually the inner envelope still has this

472
00:29:26,056 --> 00:29:30,002
set to the global object. And so we can't fix this

473
00:29:30,136 --> 00:29:33,630
with a dot bind. We've already bound

474
00:29:33,710 --> 00:29:37,206
this name into place. Even if we have an outer envelope that

475
00:29:37,228 --> 00:29:40,566
changes it, the inner envelope still has it set to

476
00:29:40,588 --> 00:29:41,720
the global object.

477
00:29:43,130 --> 00:29:46,514
Okay, so let's see if we can use arrow functions

478
00:29:46,562 --> 00:29:49,270
here to solve our timeout concern.

479
00:29:50,330 --> 00:29:54,058
What happens here? Well, we're going to start off, we're going to

480
00:29:54,064 --> 00:29:57,386
call speak, what comes in here? The this right now is the

481
00:29:57,408 --> 00:30:01,070
global object. We will set timeout and we'll bind this function

482
00:30:01,220 --> 00:30:04,970
to this, which is that global object. In 100 milliseconds

483
00:30:05,050 --> 00:30:08,718
we will execute this name, object one

484
00:30:08,804 --> 00:30:12,734
speak, what comes in here? The this is object one. And then

485
00:30:12,772 --> 00:30:16,442
we set timeout. We've baked it into place and so we got object

486
00:30:16,516 --> 00:30:19,502
one's name. So we get ninja and Doctor.

487
00:30:19,646 --> 00:30:23,390
Perfect. We were able to use these arrow functions

488
00:30:23,470 --> 00:30:27,206
binding of this to be able to get that into place in

489
00:30:27,228 --> 00:30:30,742
a really elegant way. The event

490
00:30:30,796 --> 00:30:34,130
loop. When we look at the event loop,

491
00:30:34,210 --> 00:30:37,898
we can see some really interesting things. And I like this site

492
00:30:37,984 --> 00:30:41,580
that allows us to explore how the event loop works.

493
00:30:42,750 --> 00:30:46,666
Now this site is a great way to be

494
00:30:46,688 --> 00:30:50,026
able to visualize mechanisms. We have our

495
00:30:50,048 --> 00:30:53,866
call stack things that are executing right now. We behave a callback

496
00:30:53,898 --> 00:30:57,374
queue, things that have finished, and then we have stuff that's waiting on

497
00:30:57,412 --> 00:31:00,782
external pieces as the external pieces get done.

498
00:31:00,836 --> 00:31:04,622
For example, if I click the button, then that will come into this

499
00:31:04,676 --> 00:31:08,514
callback queue. And when the call stack is empty, it will grab the next

500
00:31:08,552 --> 00:31:11,940
thing from the callback queue and be able to execute it.

501
00:31:12,550 --> 00:31:16,354
So we could take a look at this mechanism and we

502
00:31:16,392 --> 00:31:19,958
could run that code, setting it here in place,

503
00:31:20,044 --> 00:31:23,746
save and run. Now this does take a bit to execute, especially because it's

504
00:31:23,778 --> 00:31:27,094
waiting a second. But we can see how it's counting through each of these,

505
00:31:27,212 --> 00:31:30,038
setting it in place when 100 milliseconds,

506
00:31:30,134 --> 00:31:33,846
when 1 second finishes, it's in this callback

507
00:31:33,878 --> 00:31:37,094
queue, but it's not executing yet because it's still counting

508
00:31:37,142 --> 00:31:40,666
down. This is that great example of what

509
00:31:40,688 --> 00:31:44,254
is the console log once we get done here? Well, these are all

510
00:31:44,292 --> 00:31:47,786
bunching up. Eventually, when it finishes counting

511
00:31:47,818 --> 00:31:50,986
up and finishes queuing things, it'll be able to drain

512
00:31:51,018 --> 00:31:54,820
these and the answer by then will always be

513
00:31:55,990 --> 00:31:59,326
eleven or ten rather, so we'll console

514
00:31:59,358 --> 00:32:02,786
log ten times. I love this mechanism of

515
00:32:02,808 --> 00:32:06,126
being able to visualize that. Now that the call stack

516
00:32:06,158 --> 00:32:09,414
is empty, we're starting to pull data from the callback queue and

517
00:32:09,452 --> 00:32:13,334
sticking it in the call stack to do interesting things. Now this

518
00:32:13,372 --> 00:32:17,366
call stack mechanism is interesting, and we can use that

519
00:32:17,468 --> 00:32:21,754
to be able to visualize what we're doing. Here we

520
00:32:21,792 --> 00:32:25,466
have the GUI thread that is executing that content. We have the list

521
00:32:25,488 --> 00:32:29,686
of things that are ready to go in that callback

522
00:32:29,718 --> 00:32:32,742
queue. And so every time the GUI thread finishes,

523
00:32:32,806 --> 00:32:35,870
it'll go grab the next thing out of the callback queue and execute it.

524
00:32:35,940 --> 00:32:39,310
And then we have those other things waiting for something else.

525
00:32:39,460 --> 00:32:42,746
If that event happens, then they'll go into the callback queue.

526
00:32:42,938 --> 00:32:46,526
So if our GUI stack is doing something really intense looping

527
00:32:46,558 --> 00:32:50,850
from one to a million, then it's never going to run those callbacks.

528
00:32:52,230 --> 00:32:55,666
Click on this read more, or watch more as you grab the

529
00:32:55,688 --> 00:32:59,026
slides from roberts.org to learn more about the event loop.

530
00:32:59,218 --> 00:33:02,662
When we talk about node servers, we have in effect

531
00:33:02,796 --> 00:33:06,674
a bunch of these different mechanisms. Now this is definitely the logical

532
00:33:06,722 --> 00:33:10,946
implementation, not the physical implementation, but we can think of every request

533
00:33:11,058 --> 00:33:14,290
as having their own GUI thread, callback queue,

534
00:33:14,370 --> 00:33:18,710
and web API callbacks.

535
00:33:19,370 --> 00:33:22,766
So Javascript is single threaded. So it'll go look at

536
00:33:22,788 --> 00:33:26,138
this request and it'll drain its current stack, and then it'll

537
00:33:26,154 --> 00:33:29,534
go to these request and drain its current stack, and then it'll go to this

538
00:33:29,572 --> 00:33:33,086
request and drain its current stack and wander all the way through. If it

539
00:33:33,108 --> 00:33:36,174
gets to a request that has an empty callback stack, it will grab the next

540
00:33:36,212 --> 00:33:39,682
thing from its done stack and be able to accomplish that.

541
00:33:39,816 --> 00:33:43,186
So if I've got a request over here that's counting from one to

542
00:33:43,208 --> 00:33:46,798
a million, or doing a big computation on an image, then that's

543
00:33:46,814 --> 00:33:50,070
why all of these requests are blocked. Now,

544
00:33:50,140 --> 00:33:53,926
JavaScript is single threaded, so we need to yield that thread and let the

545
00:33:53,948 --> 00:33:57,830
node loop go around that circle and go grab all of these next

546
00:33:57,900 --> 00:34:01,450
things and then continue counting in on our image.

547
00:34:02,430 --> 00:34:06,682
If ever you've seen a set timeout zero, or if you've seen a process next

548
00:34:06,736 --> 00:34:10,294
tick that you've awaited, and you're like well, why would I wait 0 second

549
00:34:10,342 --> 00:34:14,366
just to be able to get it? That's exactly that. You're yielding the thread so

550
00:34:14,388 --> 00:34:18,062
that other threads can catch up and you haven't locked out all of the other

551
00:34:18,116 --> 00:34:18,990
requests.

552
00:34:20,610 --> 00:34:24,238
Async and await async and await is really neat,

553
00:34:24,334 --> 00:34:27,838
and it's a pattern

554
00:34:27,934 --> 00:34:31,534
clearly stolen. I mean inspired by c sharp.

555
00:34:31,662 --> 00:34:35,778
C sharp uses async and await over the top of the task. Parallel library

556
00:34:35,874 --> 00:34:39,574
and JavaScript uses async and await over the top of

557
00:34:39,612 --> 00:34:43,222
promises and generators. So it's these

558
00:34:43,276 --> 00:34:46,530
resumable state machine that is created by the compiler.

559
00:34:46,610 --> 00:34:50,090
It knows what step it's on and when it comes back in it can continue

560
00:34:50,160 --> 00:34:53,882
on with the next step. That's perfect now because

561
00:34:53,936 --> 00:34:56,810
it's built on top of promises and generators.

562
00:34:58,190 --> 00:35:02,262
Pardon me. We have a great interop story between promises

563
00:35:02,406 --> 00:35:05,726
and async and await. Let's take a look at that.

564
00:35:05,908 --> 00:35:09,438
Here's a promise based code. We have return new promise. We have

565
00:35:09,444 --> 00:35:13,118
the resolve and reject method and once we're done doing our thing we

566
00:35:13,124 --> 00:35:16,866
will resolve it with those results. We can then say then.

567
00:35:16,968 --> 00:35:20,660
And we can call our various libraries with catch at the end.

568
00:35:21,670 --> 00:35:25,566
Now here's a library that we might have built in the promise days and

569
00:35:25,608 --> 00:35:28,790
now we want to async and await it. Well,

570
00:35:28,940 --> 00:35:33,494
let's take a look at that. Let's create an async function and

571
00:35:33,692 --> 00:35:37,574
these we will say await that async function and now

572
00:35:37,612 --> 00:35:40,898
we can return our results. Now do

573
00:35:40,924 --> 00:35:44,186
we need to wait until we do a big bang refactoring to

574
00:35:44,208 --> 00:35:48,330
get all of our promise code into async and await code? No, we don't.

575
00:35:48,990 --> 00:35:52,046
The cool part about async and await is now we get to

576
00:35:52,068 --> 00:35:55,626
use actual catch. The state machine understands

577
00:35:55,818 --> 00:35:59,514
what state it's on and it can throw and catch

578
00:35:59,562 --> 00:36:02,674
exceptions in the normal way. It looks a whole lot

579
00:36:02,712 --> 00:36:06,820
more synchronous than our thenathon. That's pretty cool.

580
00:36:08,230 --> 00:36:12,082
So promise calling an async. Here we have an async function.

581
00:36:12,216 --> 00:36:15,986
Now if we call our async function but we don't await it and

582
00:36:16,008 --> 00:36:19,266
we take a look at what is these response? The response

583
00:36:19,298 --> 00:36:22,914
is a promise. Well, we know how to handle promises.

584
00:36:23,042 --> 00:36:26,274
So if we behave a new async function that we need to call from legacy

585
00:36:26,322 --> 00:36:29,640
code, we can dot these it.

586
00:36:30,010 --> 00:36:33,446
Here's our async function and we're just saying dot these on that async

587
00:36:33,478 --> 00:36:36,860
function to continue on with our legacy code. That's perfect.

588
00:36:37,390 --> 00:36:40,326
Let's see if we can do it the other way. We have a legacy promise

589
00:36:40,358 --> 00:36:43,478
function and we want to call it from async and await code. Well,

590
00:36:43,504 --> 00:36:46,926
let's go call it. What do we get back? We have a promise. We know

591
00:36:46,948 --> 00:36:50,602
how to await promises. That's what we were doing with async and await.

592
00:36:50,746 --> 00:36:53,874
So let's await this promise based

593
00:36:53,912 --> 00:36:57,726
code. Now we have new async functions calling legacy

594
00:36:57,758 --> 00:37:01,410
promise functions. We didn't need to wait for that big bang refactor.

595
00:37:02,870 --> 00:37:06,518
Async and await its interop with promises is great

596
00:37:06,604 --> 00:37:09,670
because under the hood async and await are just promises.

597
00:37:12,170 --> 00:37:15,494
So how would we do many things in parallel? Understanding now

598
00:37:15,532 --> 00:37:18,998
how async and await and promises work together?

599
00:37:19,164 --> 00:37:23,030
Here's this long running task, and I don't want to await

600
00:37:23,110 --> 00:37:27,002
these previous one before I launch the next one. So I'm going to call

601
00:37:27,056 --> 00:37:30,880
all these libraries, notice that we're not awaiting any of them.

602
00:37:31,250 --> 00:37:35,406
And now what do I have? I have three promises we

603
00:37:35,428 --> 00:37:38,750
can use promise all to wait for,

604
00:37:38,900 --> 00:37:42,990
to turn this promise into an array of into

605
00:37:43,060 --> 00:37:46,286
a new promise that will return an array of results once it's

606
00:37:46,318 --> 00:37:50,046
done. And so let's take this promise all and we will await

607
00:37:50,078 --> 00:37:52,690
it. Now we get three results.

608
00:37:53,510 --> 00:37:56,626
All three of these happened in parallel. Well, Javascript is

609
00:37:56,648 --> 00:38:00,434
still single threaded, so it's waiting

610
00:38:00,482 --> 00:38:03,606
for all of them to finish. I've launched all three and

611
00:38:03,628 --> 00:38:06,806
if each one takes 1 second to execute, I may be done in

612
00:38:06,828 --> 00:38:10,518
1 second instead of these seconds that interrupt between async and

613
00:38:10,524 --> 00:38:15,030
await and promises is beautiful here. Now I can just return the results.

614
00:38:16,970 --> 00:38:20,734
Javascript. Brendan Ike built it 25 years

615
00:38:20,772 --> 00:38:23,694
ago in ten days. I don't know about you,

616
00:38:23,732 --> 00:38:27,150
but Javascript is a pretty excellent place to work. Good job.

617
00:38:27,220 --> 00:38:31,226
Good job, Brandon. I'll be at that spot

618
00:38:31,258 --> 00:38:34,606
where the conference has designated Q and A or hit me

619
00:38:34,628 --> 00:38:38,398
up on Twitter at robrich and you can grab the slides online

620
00:38:38,484 --> 00:38:41,886
right now@robrich.org. Thanks for joining us for

621
00:38:41,908 --> 00:38:43,450
Conf 42s Javascript.

