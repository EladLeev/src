1
00:00:41,010 --> 00:00:44,102
Hello everybody. My name is Michael Haberman. I am the

2
00:00:44,156 --> 00:00:47,494
co founder and CTO of Aspecto. Today. I would like CTO

3
00:00:47,532 --> 00:00:50,778
talk with you about one of the most, most exciting

4
00:00:50,874 --> 00:00:54,334
topics out there. That would be microservices in

5
00:00:54,372 --> 00:00:58,190
particular a lot of microservices, and even more particular,

6
00:00:58,340 --> 00:01:02,238
not breaking your API. So if you run microservices today

7
00:01:02,324 --> 00:01:05,986
or in your, I don't know, prior job or something like that, you know that

8
00:01:06,008 --> 00:01:10,146
microservices could be complex. And in this talk

9
00:01:10,248 --> 00:01:13,714
I'm going to try and help with that and

10
00:01:13,752 --> 00:01:16,962
try to kind of predict what are the challenges that

11
00:01:17,016 --> 00:01:20,934
you are going to face and also how we can overcome those

12
00:01:20,972 --> 00:01:24,758
challenges, how we are going to do that. We are going to do that

13
00:01:24,844 --> 00:01:28,498
by going through a journey, how your microservices,

14
00:01:28,594 --> 00:01:31,754
your typical microservices project start in

15
00:01:31,792 --> 00:01:35,226
a company and how it starts small and simple, and then

16
00:01:35,248 --> 00:01:39,354
it start to get more and more complex as you go. Probably by

17
00:01:39,392 --> 00:01:42,798
definition of microservices going to be complex. And then we

18
00:01:42,804 --> 00:01:46,762
need to ask ourselves what tools do we have in order CTO overcome

19
00:01:46,826 --> 00:01:50,494
these challenges, this complexity. Specifically, I'm going to talk

20
00:01:50,532 --> 00:01:53,918
about distributed tracing, and also we are going to take a

21
00:01:53,924 --> 00:01:58,366
look at what is distributed breaking, how we can use it to overcome microservice

22
00:01:58,398 --> 00:02:02,290
issues and also how we can use it in a cool new

23
00:02:02,360 --> 00:02:05,806
way that is going to, I think, really help your

24
00:02:05,848 --> 00:02:09,878
development process. So let's get started. But before that,

25
00:02:09,964 --> 00:02:13,190
let me tell you why. I feel that I know

26
00:02:13,340 --> 00:02:17,174
a bit about microservices. So I've been doing microservices for

27
00:02:17,212 --> 00:02:20,726
about five years. Started as an independent consultant,

28
00:02:20,838 --> 00:02:24,198
helped companies to break their monolith to microservices

29
00:02:24,294 --> 00:02:27,754
or their microservices scaled and they needed some

30
00:02:27,792 --> 00:02:31,466
help with that. At my last position, I worked for

31
00:02:31,488 --> 00:02:35,070
a company and I was the chief architect, managing about

32
00:02:35,140 --> 00:02:38,846
120 microservices with quite some scale. And in

33
00:02:38,868 --> 00:02:42,350
the last two years I decided that I'm going to do my own thing.

34
00:02:42,420 --> 00:02:46,366
Started Aspecto basically product focus on helping

35
00:02:46,398 --> 00:02:50,002
developers with microservices. So yeah, let's dive right into

36
00:02:50,056 --> 00:02:53,726
it, looking at your typical microservices journey.

37
00:02:53,838 --> 00:02:57,158
So most companies are migrating to

38
00:02:57,244 --> 00:03:01,430
microservices rather than starting a brand new company

39
00:03:01,500 --> 00:03:05,174
or product with microservices. You usually have some problems. You have

40
00:03:05,212 --> 00:03:08,534
some problems with your monolith. It's hard to deploy, it takes

41
00:03:08,572 --> 00:03:12,042
a lot of time to test, you have a lot of regression bugs. This is

42
00:03:12,096 --> 00:03:15,990
the area of complaints that you hear starting the migration

43
00:03:16,070 --> 00:03:19,354
process. And then when you start your process and you

44
00:03:19,392 --> 00:03:23,406
start to create microservices. Usually it's something outside of

45
00:03:23,428 --> 00:03:26,750
the monolith. Usually it's something, a new feature, a green

46
00:03:26,820 --> 00:03:30,366
field feature, something that doesn't evolve a

47
00:03:30,388 --> 00:03:34,690
lot of monolith logic. And then you start to

48
00:03:34,760 --> 00:03:37,906
develop, you develop those three services that you can see on the

49
00:03:37,928 --> 00:03:41,362
screen. And your architecture is really simple.

50
00:03:41,496 --> 00:03:44,610
Like you have service a communicating with b,

51
00:03:44,680 --> 00:03:48,658
communicate with database, service b also communicates with the database.

52
00:03:48,754 --> 00:03:52,646
Then service b communicates with service c and it uses the

53
00:03:52,668 --> 00:03:55,846
database. And maybe even service a communicates with c.

54
00:03:55,948 --> 00:03:59,782
Something quite simple, quite straightforward, very easy to maintain,

55
00:03:59,846 --> 00:04:04,310
very easy to understand, and one of the characteristics

56
00:04:04,390 --> 00:04:07,894
that you can, oh, important CTO say we are talking about HTTP

57
00:04:07,942 --> 00:04:11,114
at this point. So it's a synchronous communication

58
00:04:11,162 --> 00:04:14,458
between services. So what identify

59
00:04:14,634 --> 00:04:18,526
that you are at the beginning of your microservices journey. It's very

60
00:04:18,628 --> 00:04:22,826
simple to run it locally. I can just spin up three processes,

61
00:04:22,938 --> 00:04:26,314
maybe with Docker, maybe without, maybe Docker compose,

62
00:04:26,442 --> 00:04:30,542
maybe, I don't know. It's very simple to spin it up in your local environment.

63
00:04:30,686 --> 00:04:33,966
And if I were to ask you to go CTO a whiteboard

64
00:04:33,998 --> 00:04:37,922
and describe your architecture, you would do it quite easily. And maybe the best

65
00:04:37,976 --> 00:04:40,738
way to know that you're in the beginning of your journey.

66
00:04:40,834 --> 00:04:43,794
How easy it for a developer to onboard?

67
00:04:43,842 --> 00:04:47,494
If it's easy, that means that you're in the beginning. And when looking

68
00:04:47,532 --> 00:04:51,274
at product in companies, successful projects continue.

69
00:04:51,392 --> 00:04:55,114
Now the most likely that your first

70
00:04:55,152 --> 00:04:58,906
day in microservices are successful. You have small amount of

71
00:04:58,928 --> 00:05:03,230
services, you don't have high complexity, you manage to release

72
00:05:03,570 --> 00:05:07,294
this new feature fast. So the product is happy, sales are

73
00:05:07,332 --> 00:05:10,382
happy because they can sell it, business are happy because

74
00:05:10,436 --> 00:05:14,058
things are going fast, everybody is happy. And when everybody is

75
00:05:14,084 --> 00:05:17,278
happy, you start CTO, get more requirements, more feature,

76
00:05:17,374 --> 00:05:20,894
you started to take responsibility from your monoliths

77
00:05:20,942 --> 00:05:24,654
and it starts to grow. When it is starting to grow your architecture

78
00:05:24,702 --> 00:05:27,718
a few months later, starting to look more like that,

79
00:05:27,884 --> 00:05:31,574
and there is a lot of components on the screen. But as

80
00:05:31,612 --> 00:05:34,950
you start to draw the relation between

81
00:05:35,020 --> 00:05:38,806
them, this is where it start to get a bit scary because there

82
00:05:38,828 --> 00:05:42,570
is a lot of relations between them. And I was quite easy

83
00:05:42,640 --> 00:05:46,682
here. You could have tons of relations between different services

84
00:05:46,816 --> 00:05:50,138
depending on one another. And it's starting to get big,

85
00:05:50,224 --> 00:05:53,822
it's starting to get more and more complex. So if I were

86
00:05:53,876 --> 00:05:57,454
to ask you a few questions, I would ask you, okay, can you please

87
00:05:57,652 --> 00:06:01,946
draw the architecture diagram of your project? And that's

88
00:06:01,978 --> 00:06:05,666
starting to get more and more complex as you go and if I

89
00:06:05,688 --> 00:06:09,554
would ask you, let's take this service, for instance, who is

90
00:06:09,592 --> 00:06:13,554
using it, which other services or clients are calling this

91
00:06:13,592 --> 00:06:17,058
service? And this service, does it call other services? If you know

92
00:06:17,144 --> 00:06:21,058
this answer, it's going to really help you. But as the picture gets bigger

93
00:06:21,154 --> 00:06:24,054
and the diagram gets bigger, it's harder to remember.

94
00:06:24,172 --> 00:06:27,654
And also when you are looking at the communication, there is

95
00:06:27,692 --> 00:06:30,874
tons of communication. We chose at this point to be

96
00:06:30,912 --> 00:06:34,106
still with HTTP, but even with HTTP, you need

97
00:06:34,128 --> 00:06:37,430
to remember the route that you are calling, the verb

98
00:06:37,510 --> 00:06:41,054
and also the structure itself. What is the contract that

99
00:06:41,092 --> 00:06:45,038
this service expects to get? When I'm communicating with another service,

100
00:06:45,124 --> 00:06:47,998
I need to know what is the contract between us?

101
00:06:48,084 --> 00:06:51,262
And sometimes even that. Isn't that obvious?

102
00:06:51,396 --> 00:06:54,506
So I've raised your three main concerns

103
00:06:54,538 --> 00:06:58,066
that I think that at this point in your microservice journey, those would

104
00:06:58,088 --> 00:07:01,874
be the main concerns. Understanding the bigger picture, understanding who

105
00:07:01,912 --> 00:07:05,378
is consuming who and how they're consuming. So those are

106
00:07:05,384 --> 00:07:09,394
the three questions. But we are developers, we know how to solve

107
00:07:09,442 --> 00:07:13,014
problems. This is what we do. So let's get and

108
00:07:13,052 --> 00:07:16,662
get it fixed. But one thing to remember, and this is really

109
00:07:16,716 --> 00:07:20,138
important, talking about microservices or distributed application

110
00:07:20,224 --> 00:07:24,054
as a whole, as the picture. And when I'm saying picture,

111
00:07:24,102 --> 00:07:27,770
I mean your architectural diagram, when that's big

112
00:07:27,920 --> 00:07:31,674
and it increases over time, it also increases the risk of

113
00:07:31,712 --> 00:07:35,326
having production issues. And this is something that we need to

114
00:07:35,348 --> 00:07:39,038
remember because it's going to kind of guide us through this talk.

115
00:07:39,124 --> 00:07:43,006
So if we agree that microservices, as they grow,

116
00:07:43,108 --> 00:07:46,466
as we have more and more services, we are going to

117
00:07:46,488 --> 00:07:50,146
have production issues. And the reason that is basically when you

118
00:07:50,168 --> 00:07:53,714
have more to remember, more dependencies, more things

119
00:07:53,752 --> 00:07:57,122
that you need to take into account when you code, it's just

120
00:07:57,176 --> 00:08:01,174
getting bigger and just getting harder. And microservices, quite by

121
00:08:01,212 --> 00:08:04,886
nature, by their definition, they are keep on growing. If I

122
00:08:04,988 --> 00:08:08,502
were speaking in front of you, and I could really ask you the question,

123
00:08:08,636 --> 00:08:12,618
how many services have you added in the past year? Most of

124
00:08:12,624 --> 00:08:15,834
you would say some number. But if I were to ask you, did you

125
00:08:15,872 --> 00:08:19,050
remove a service? So that doesn't happen a lot.

126
00:08:19,120 --> 00:08:23,046
It does, but not at the same rate. So microservices

127
00:08:23,238 --> 00:08:27,006
kind of dictates that we need to have a lot of them and

128
00:08:27,108 --> 00:08:30,526
we need CTo have separation of concern, and we have all

129
00:08:30,548 --> 00:08:34,046
kind of reason why we are separating. But microservices are

130
00:08:34,068 --> 00:08:38,142
usually growing, and when they are growing, the picture gets bigger.

131
00:08:38,206 --> 00:08:41,886
And when the picture gets bigger, the risk of production issue increases.

132
00:08:41,998 --> 00:08:45,574
So this is kind of an equation that we need to take into account

133
00:08:45,692 --> 00:08:49,574
when thinking about microservices. What I want

134
00:08:49,612 --> 00:08:53,874
you to remember at this point is when microservices are growing,

135
00:08:54,002 --> 00:08:57,382
my risk to have production issues increases as well.

136
00:08:57,516 --> 00:09:00,714
Okay, so we mentioned three issues.

137
00:09:00,832 --> 00:09:04,022
We mentioned the picture is big. It's hard to understood,

138
00:09:04,086 --> 00:09:07,786
to understand who is consuming who, and it's hard to understand how.

139
00:09:07,888 --> 00:09:11,598
And this is problems. Let's try to solve them. Again.

140
00:09:11,684 --> 00:09:14,734
From being with a lot of customers and having with

141
00:09:14,772 --> 00:09:18,782
them projects to migrate to microservices, I'm kind of going

142
00:09:18,836 --> 00:09:22,702
to the main points that were repetitive between those

143
00:09:22,756 --> 00:09:26,442
projects. And the first thing that I thought people are doing when

144
00:09:26,516 --> 00:09:29,874
they're having a hard time to understand their architecture, they are doing

145
00:09:29,912 --> 00:09:33,010
an architectural document. So they go to, I don't know,

146
00:09:33,080 --> 00:09:36,934
any kind of solution that you can draw your diagram. And I

147
00:09:36,972 --> 00:09:40,934
bet that each and one of you has in your organization some

148
00:09:40,972 --> 00:09:44,134
kind of an architectural chart. And if I were

149
00:09:44,172 --> 00:09:48,006
to ask you how confident you're absolutely sure that this

150
00:09:48,028 --> 00:09:51,674
is accurate, I think all of you would find the honesty to

151
00:09:51,712 --> 00:09:55,190
say, yeah, that's probably not 100% accurate.

152
00:09:55,270 --> 00:09:58,794
It's somewhere in that direction, but it's not 100%.

153
00:09:58,992 --> 00:10:02,714
And this is something, I think it makes sense, it's very natural.

154
00:10:02,762 --> 00:10:06,826
Just go and create your architectural document and that's

155
00:10:06,858 --> 00:10:10,286
fine, go ahead, do that. Do remember, it's never up

156
00:10:10,308 --> 00:10:14,386
to date, it's always a leg behind. So we have an

157
00:10:14,408 --> 00:10:17,934
architectural document that we did manually. Okay, that helps.

158
00:10:17,982 --> 00:10:21,954
That doesn't solve it. But let's go to the second

159
00:10:22,072 --> 00:10:25,494
issue, which is a bit more complex. I want to know

160
00:10:25,532 --> 00:10:28,998
for a specific service on which service it depends on,

161
00:10:29,084 --> 00:10:33,234
and which services it serve, which services consume

162
00:10:33,282 --> 00:10:36,630
it. And this is again, something that it could

163
00:10:36,700 --> 00:10:39,926
be somewhat difficult. Maybe another documentation,

164
00:10:40,038 --> 00:10:43,306
maybe to find some service map solution, maybe CTO serve to

165
00:10:43,328 --> 00:10:47,066
find some service catalog solution. You could try to find a

166
00:10:47,088 --> 00:10:50,794
way, but also it's oriented a challenge. I think that

167
00:10:50,992 --> 00:10:53,726
at the early days I would go with docs probably,

168
00:10:53,828 --> 00:10:57,134
but maybe down the road I would take some vendor to

169
00:10:57,252 --> 00:11:01,550
help with that. And the question how services communicate between one another.

170
00:11:01,700 --> 00:11:05,278
Well, we can just go with Swagger. Swagger is a great tool,

171
00:11:05,364 --> 00:11:09,714
or openapi, it's just the

172
00:11:09,752 --> 00:11:12,386
protocol name that Swagger gave to their standard.

173
00:11:12,568 --> 00:11:16,054
And open API really helps you to kind

174
00:11:16,092 --> 00:11:19,782
of document your HTTP endpoints. And yeah,

175
00:11:19,836 --> 00:11:23,682
again, you can do a documentation, usually not one hundreds percent accurate,

176
00:11:23,746 --> 00:11:26,550
but really helpful at the beginning.

177
00:11:27,050 --> 00:11:30,762
Okay, so we did all of that and everything

178
00:11:30,816 --> 00:11:34,506
is good, everybody is happy, but time went by.

179
00:11:34,608 --> 00:11:38,490
And now we have your first downtime. So when having

180
00:11:38,560 --> 00:11:42,098
something down, you're starting to reallife that it's

181
00:11:42,134 --> 00:11:45,098
quite problematic because looking at HTTP,

182
00:11:45,194 --> 00:11:48,766
if service a, as you can see in the diagram below, sends an

183
00:11:48,788 --> 00:11:51,934
API call to service b and service b is

184
00:11:51,972 --> 00:11:55,694
down, is not available for some reason. Basically that

185
00:11:55,732 --> 00:11:58,962
means that you lost data and we don't want to lose data.

186
00:11:59,096 --> 00:12:02,914
The fact that we chose to do a distributed application doesn't mean that we need

187
00:12:02,952 --> 00:12:05,870
to lose data, right? So HTTP,

188
00:12:06,030 --> 00:12:09,814
it's great. I love working with HTTP. But do remember, if your

189
00:12:09,852 --> 00:12:13,702
service is down, you may lose data. Losing data is something

190
00:12:13,756 --> 00:12:17,430
that we should be afraid of. And your boss might

191
00:12:17,500 --> 00:12:20,498
get upset with you because you lost data.

192
00:12:20,604 --> 00:12:24,022
And then you sit outside and you just say, I hate HTTP,

193
00:12:24,086 --> 00:12:27,466
I just hate it. So we can fix it. We know how to

194
00:12:27,488 --> 00:12:31,066
fix it. HTTP doesn't work for us. We need to

195
00:12:31,088 --> 00:12:34,566
move from synchronous to unsynchronous communication. And there

196
00:12:34,608 --> 00:12:38,286
are just an endless amount of options out there to choose the

197
00:12:38,308 --> 00:12:41,518
right one for you. It could be a pub sub solution, it could be a

198
00:12:41,524 --> 00:12:44,814
queue solution. Or being more specific, Kafka Redis pub

199
00:12:44,852 --> 00:12:48,270
sub RabbitmQ and AWS sQs.

200
00:12:48,350 --> 00:12:51,954
There is can endless amount. You just need to pick the one that fits your

201
00:12:51,992 --> 00:12:55,554
need or the one that your company already works with. And I'm going

202
00:12:55,592 --> 00:12:58,482
to refer it from now on as Kafka,

203
00:12:58,546 --> 00:13:01,986
just because we use a lot of Kafka and it's very trendy

204
00:13:02,018 --> 00:13:05,442
these days. So when I'm introducing Kafka,

205
00:13:05,506 --> 00:13:09,474
how is that going to help me? So you can see here the diagram

206
00:13:09,522 --> 00:13:12,666
that I show you. Really, really at the beginning of this talk,

207
00:13:12,768 --> 00:13:16,730
we have three services a, B and C. They communicate with one another.

208
00:13:16,880 --> 00:13:20,218
But right now, if I'll take this example how service

209
00:13:20,304 --> 00:13:23,898
a communicates with C, they are not communicating directly,

210
00:13:23,994 --> 00:13:27,950
they are communicating through Kafka. So service a is going

211
00:13:28,020 --> 00:13:31,166
to send the data to Kafka and Kafka is

212
00:13:31,188 --> 00:13:34,750
going to receive it and is going to persist it. And then

213
00:13:34,820 --> 00:13:38,418
service C is going to ask Kafka, hey, can you give me more

214
00:13:38,584 --> 00:13:42,014
messages? I'm ready to kind of process more messages.

215
00:13:42,142 --> 00:13:45,410
This thing that Kafka is doing, that it persists the data until

216
00:13:45,480 --> 00:13:49,062
service c completes. To work on that basically ensures that

217
00:13:49,116 --> 00:13:52,870
you don't have downtime. And that is great. That is exactly

218
00:13:53,020 --> 00:13:56,598
what we wanted. So that's all of it.

219
00:13:56,684 --> 00:14:00,410
Data is persisted, no data loss. If service is down,

220
00:14:00,480 --> 00:14:04,166
we'll just spin a new one and everybody is happy. But we are experienced

221
00:14:04,198 --> 00:14:07,094
enough with distributed application microservices.

222
00:14:07,222 --> 00:14:11,866
And we know that usually there is downtime to architectural decisions.

223
00:14:11,978 --> 00:14:15,226
So think for a second, what's the problem that we're

224
00:14:15,258 --> 00:14:19,230
going to introduce by introducing Kafka? The first thing is

225
00:14:19,300 --> 00:14:23,342
that our picture, our whole picture diagram just got

226
00:14:23,476 --> 00:14:27,458
way more complicated. There is tons of stuff that happened

227
00:14:27,544 --> 00:14:30,754
just because we made this tiny change and we need to take a look

228
00:14:30,792 --> 00:14:34,450
in that. So service a is calling service b,

229
00:14:34,520 --> 00:14:38,018
that's fine. Service a is calling Kafka.

230
00:14:38,194 --> 00:14:41,046
But then, I don't know, as a service a,

231
00:14:41,148 --> 00:14:45,014
who am I communicating with? I just lost my ability to

232
00:14:45,052 --> 00:14:48,534
understand from service a perspective who is going to

233
00:14:48,572 --> 00:14:52,026
consume this data. I can only understand that if I'll go to

234
00:14:52,048 --> 00:14:55,498
the code base of service b and then figure out

235
00:14:55,664 --> 00:14:59,274
if it's using that Kafka topic. And it

236
00:14:59,312 --> 00:15:03,002
works really easy when you have 310, but when you have 100,

237
00:15:03,056 --> 00:15:07,050
120 microservices, it's trying to get really problematic.

238
00:15:07,130 --> 00:15:11,214
Like I don't know who produces this data, I don't know who is consuming this

239
00:15:11,252 --> 00:15:14,990
data. So by introducing Kafka to a solution,

240
00:15:15,070 --> 00:15:18,354
we didn't only solve the problems that we

241
00:15:18,392 --> 00:15:21,890
had with async communication, but it also

242
00:15:21,960 --> 00:15:25,710
introduced some problems in perspective of understanding

243
00:15:25,790 --> 00:15:29,286
who is communicating with who. Also another thing that is part

244
00:15:29,308 --> 00:15:32,694
of the architecture, you just need to use it in the way that

245
00:15:32,732 --> 00:15:36,354
fits your need. It's a two way communication.

246
00:15:36,402 --> 00:15:39,378
You don't have a request and a response. It's a one way thing. You just

247
00:15:39,404 --> 00:15:42,826
send your payload and somebody's going to get it. You're not going to get a

248
00:15:42,848 --> 00:15:46,774
response. That's fine. Also doing debugging

249
00:15:46,822 --> 00:15:50,746
locally got more complicated. You can just spin service a, service b,

250
00:15:50,768 --> 00:15:54,198
and start sending data. You need to spin up service a,

251
00:15:54,224 --> 00:15:57,038
you need to spin up Kafka. You need to spin up service c. You need

252
00:15:57,044 --> 00:16:00,346
to send data to service a so it would populate Kafka,

253
00:16:00,378 --> 00:16:03,554
so B could consume it. Everything's starting CTO,

254
00:16:03,592 --> 00:16:07,346
just be more complex. And Swagger is not relevant because Swagger is

255
00:16:07,368 --> 00:16:11,262
an HTTP do communication rather than some payload

256
00:16:11,406 --> 00:16:14,766
at any form. So those are the downsides.

257
00:16:14,798 --> 00:16:17,826
And I kind of wanted to emphasize how it looks.

258
00:16:17,928 --> 00:16:22,150
So I took the second diagram that I showed you where we have twelve services.

259
00:16:22,300 --> 00:16:25,862
And I started to introduce Kafka in the middle. And I think

260
00:16:25,916 --> 00:16:29,174
that you blind of get the idea. Like I hope

261
00:16:29,212 --> 00:16:32,858
you look at this and you say, nah, that's too crowded. And if you

262
00:16:32,864 --> 00:16:36,378
can see, I only added Kafka in the left

263
00:16:36,464 --> 00:16:40,434
side of the screen. So it gets really complicated, it gets messy.

264
00:16:40,502 --> 00:16:44,234
It's very hard to work with. And again, as the picture

265
00:16:44,282 --> 00:16:47,774
gets bigger, the risk increases. Then if

266
00:16:47,812 --> 00:16:51,150
we are able to serve the developer with the big

267
00:16:51,220 --> 00:16:55,434
picture in a good compact way that is going to simplify

268
00:16:55,482 --> 00:16:58,786
the developer work, it's going to reduce the risk. If I

269
00:16:58,808 --> 00:17:01,922
were a developer and I was looking at the code base of service a,

270
00:17:01,976 --> 00:17:05,346
I knew it. Communication with service b, there was no doubt in

271
00:17:05,368 --> 00:17:09,286
my mind. Looking at Kafka solutions, I will have a

272
00:17:09,308 --> 00:17:13,042
doubt. So if I were the ability to answer the developer

273
00:17:13,106 --> 00:17:16,354
who is consuming this message, I would reduce the risk

274
00:17:16,402 --> 00:17:19,538
of having production issues. So kind

275
00:17:19,564 --> 00:17:23,066
of to summarize so far, what I was referring to when

276
00:17:23,088 --> 00:17:25,930
I'm saying that microservices is complex,

277
00:17:27,070 --> 00:17:30,090
your name is micro, you are going to have a lot of them.

278
00:17:30,160 --> 00:17:33,370
I know a lot of companies are saying we're not doing microservices,

279
00:17:33,450 --> 00:17:36,926
we have only like five or ten or something like that. We don't have

280
00:17:37,028 --> 00:17:40,926
the big ones like thousands of services. Any distributed application

281
00:17:41,028 --> 00:17:44,762
is going to have those issues. It just depends

282
00:17:44,826 --> 00:17:48,578
on how significant they are. The more micro you go,

283
00:17:48,664 --> 00:17:52,206
the more complexity you are going to face. But it's

284
00:17:52,238 --> 00:17:55,666
going to allow you to run faster, it's going to allow you to deploy really,

285
00:17:55,688 --> 00:17:59,362
really fast. So that's one thing that makes it more complex,

286
00:17:59,426 --> 00:18:02,550
that it's very legitimate. CTO create more and more services.

287
00:18:02,700 --> 00:18:06,470
Also microservices allow us to choose the right tool for the job.

288
00:18:06,540 --> 00:18:10,426
Whether you need a special database or a special programming language, then you

289
00:18:10,448 --> 00:18:13,370
just spin up another microservice and that's absolutely fine.

290
00:18:13,440 --> 00:18:16,714
But you're going to have more. And also it's not only

291
00:18:16,752 --> 00:18:19,690
HTTP, ASEAN communication is very popular.

292
00:18:20,750 --> 00:18:24,270
We see all kind of async communication. All of them

293
00:18:24,340 --> 00:18:27,854
has their own purpose. But you are going to face at some point

294
00:18:27,892 --> 00:18:31,294
or another non HTTP communication and it's going

295
00:18:31,332 --> 00:18:35,138
to get complex. So I hope I

296
00:18:35,224 --> 00:18:38,418
kind of scared you just a bit, just the right amount.

297
00:18:38,504 --> 00:18:42,434
So you know that distributed application are complicated and

298
00:18:42,472 --> 00:18:45,646
we have tool to overcome it. So every time I spoke

299
00:18:45,678 --> 00:18:48,498
about the complexity, I spoke about the big picture,

300
00:18:48,594 --> 00:18:52,022
understanding the big picture, who is communicating with who

301
00:18:52,076 --> 00:18:55,350
and how. And this is what I want to try and

302
00:18:55,420 --> 00:18:58,966
help you with. So there is something out there called distributed breaking,

303
00:18:59,078 --> 00:19:03,334
getting more and more popular. CNCF, the same foundation responsible

304
00:19:03,382 --> 00:19:07,350
in Kubernetes is responsible also in a product called open telemetry,

305
00:19:07,430 --> 00:19:10,786
a product that allows you to do distributed tracing.

306
00:19:10,918 --> 00:19:14,414
The concept and I'll show you it in a second is quite simple.

307
00:19:14,532 --> 00:19:18,526
If every microservice would report what's happening.

308
00:19:18,708 --> 00:19:22,190
When I'm saying what's happening. I mean as a service,

309
00:19:22,260 --> 00:19:25,678
I got an API call, I performed a DB query,

310
00:19:25,774 --> 00:19:29,186
I set some data in redis, I communication with

311
00:19:29,208 --> 00:19:33,090
my cloud provider, all of those are being reported into one

312
00:19:33,160 --> 00:19:37,030
central place and there is kind of a link between

313
00:19:37,100 --> 00:19:40,760
them. If I see that somebody, some service

314
00:19:41,130 --> 00:19:45,442
set some data in redis, I have a blind to the HTTP

315
00:19:45,506 --> 00:19:49,742
call that initiated this DB statement or redis statement.

316
00:19:49,826 --> 00:19:53,226
So the way that it looks, if you can see here we have two

317
00:19:53,248 --> 00:19:56,794
services, service a and service b. And within the

318
00:19:56,832 --> 00:19:59,994
application code we have open telemetry service e.

319
00:20:00,032 --> 00:20:03,662
What it does, it sends an API call to service b.

320
00:20:03,796 --> 00:20:07,262
Service B gets it and, I don't know, does something

321
00:20:07,316 --> 00:20:10,430
with it. And you can see that both of them are

322
00:20:10,500 --> 00:20:15,010
kind of writing to a central traces solution. When service

323
00:20:15,160 --> 00:20:18,734
a got the API call, basically it's

324
00:20:18,782 --> 00:20:22,814
the root of this trace, it's the starting point, the entry

325
00:20:22,862 --> 00:20:26,162
point of this trace. It gets this data

326
00:20:26,216 --> 00:20:29,702
and it's saying, okay, I'm trace number one, this is the first

327
00:20:29,756 --> 00:20:34,130
trace and I'm also the first span. So this is the first action

328
00:20:34,210 --> 00:20:38,022
that took place under this context and

329
00:20:38,076 --> 00:20:41,386
it will be more clear in a second. And then he sent the

330
00:20:41,408 --> 00:20:44,922
API call. Now when this API call is

331
00:20:44,976 --> 00:20:49,606
being sent, it actually ejects a unique header telling

332
00:20:49,718 --> 00:20:53,166
the next microservice in line, hey, you are not the

333
00:20:53,188 --> 00:20:57,342
first one. I was before you. I want you to link them together.

334
00:20:57,476 --> 00:21:01,182
So when service b got the API call, it took

335
00:21:01,236 --> 00:21:04,190
the reference that got from service a.

336
00:21:04,260 --> 00:21:07,698
And as you can see, when it's reporting to the central trace place,

337
00:21:07,784 --> 00:21:10,978
it's using the same trace but span number two.

338
00:21:11,064 --> 00:21:14,386
So now if I'll ask you what's in trace one,

339
00:21:14,488 --> 00:21:17,766
the answer is span one and spend two.

340
00:21:17,868 --> 00:21:21,314
Span one represent the API call of microservice

341
00:21:21,362 --> 00:21:24,866
A, and span two represent the API

342
00:21:24,898 --> 00:21:28,182
call of service b. Now, being able

343
00:21:28,316 --> 00:21:32,202
to see it all together kind of give you the story of

344
00:21:32,256 --> 00:21:35,674
what happened to a particular API call. Let's even see that in

345
00:21:35,712 --> 00:21:39,354
action. So here you can see Jaeger Yeager is

346
00:21:39,392 --> 00:21:42,878
a very well known tool that allows you to

347
00:21:43,044 --> 00:21:46,926
visualize traces, open telemetry traces, and other

348
00:21:47,108 --> 00:21:50,410
type. And this is some flow in our backend.

349
00:21:50,490 --> 00:21:53,806
And you can see here that we have aspecto API docs and we

350
00:21:53,828 --> 00:21:57,182
have aspecto account and we have versions API lambda.

351
00:21:57,246 --> 00:22:00,274
And you can see the process, you can see that we got an API call

352
00:22:00,312 --> 00:22:04,222
to OpenAPI packages and then we sent an API

353
00:22:04,286 --> 00:22:07,846
call to aspecto account to get the user probably to

354
00:22:07,868 --> 00:22:11,746
authenticate the user. And once it was authenticated, we invoked

355
00:22:11,778 --> 00:22:15,378
a lambda called version API lambda, which can a query

356
00:22:15,474 --> 00:22:18,934
on DynamoDb. And I can see here the entire flow.

357
00:22:18,982 --> 00:22:22,874
So I have three microservices involved, I have API docs account

358
00:22:22,992 --> 00:22:26,506
and the versions microservice. And I

359
00:22:26,528 --> 00:22:29,574
can see the interaction between them. And if I'll

360
00:22:29,622 --> 00:22:33,406
click on one of them, I can even see all the

361
00:22:33,428 --> 00:22:36,606
data, all the relevant data that I need in order to

362
00:22:36,628 --> 00:22:39,758
understand what this thing is doing. Basically,

363
00:22:39,924 --> 00:22:43,826
Opentelemetry gives you the ability to take one

364
00:22:43,928 --> 00:22:47,230
particular request and visualize it altogether.

365
00:22:47,390 --> 00:22:50,782
If I'll try to give you with a bit more details,

366
00:22:50,846 --> 00:22:54,306
how it looks. So looking at, wait a

367
00:22:54,328 --> 00:22:58,230
second, looking at how to implement

368
00:22:58,970 --> 00:23:02,520
open telemetry. So it's usually kind of simple.

369
00:23:03,130 --> 00:23:07,094
You have this SDK, this is our open

370
00:23:07,132 --> 00:23:10,874
telemetry distribution. But there are plain open

371
00:23:10,912 --> 00:23:14,490
source open telemetry, you can implement it.

372
00:23:14,560 --> 00:23:18,442
Basically it's an SDK within your code that

373
00:23:18,496 --> 00:23:22,494
is sending out to whatever destination you are going to

374
00:23:22,532 --> 00:23:26,890
send it to. A destination could be directly

375
00:23:26,970 --> 00:23:30,958
to something like Yeager. So Yeager would

376
00:23:31,044 --> 00:23:34,426
take it and persist it in some database and then you're able to visualize

377
00:23:34,458 --> 00:23:38,322
it. You can send it to some vendor that is going to

378
00:23:38,376 --> 00:23:42,002
visualize it for you, and you can send it to your own database and then

379
00:23:42,056 --> 00:23:45,234
query this data in which fashion that you

380
00:23:45,272 --> 00:23:49,142
want. For instance, aspecto would take

381
00:23:49,196 --> 00:23:52,774
this Jaeger UI and

382
00:23:52,812 --> 00:23:56,438
would present it in kind of a, I don't

383
00:23:56,444 --> 00:24:00,794
know, different way, I would say. And you can see here how

384
00:24:00,832 --> 00:24:04,202
it looks within a spectrum. So once

385
00:24:04,256 --> 00:24:07,802
you started to send, you implemented open

386
00:24:07,856 --> 00:24:11,066
telemetry and you're sending the data, then what you got

387
00:24:11,088 --> 00:24:15,086
out of it is two important things. The first one is the ability to

388
00:24:15,108 --> 00:24:19,102
debug whenever you have an issue. Now you have all the story, all the

389
00:24:19,156 --> 00:24:22,542
breadcrumbs altogether. CTO understand how you reach

390
00:24:22,596 --> 00:24:26,114
this situation, how you reach the situation where you have this

391
00:24:26,152 --> 00:24:30,318
bug and now you can understand it. And also it helps

392
00:24:30,334 --> 00:24:34,194
you to visualize. We took some actions and we put

393
00:24:34,232 --> 00:24:37,926
them together on a graph, and now it's more visualized for

394
00:24:37,948 --> 00:24:41,506
the developer, which is definitely better. I'm not sure if it's

395
00:24:41,538 --> 00:24:44,694
still answering the big picture question,

396
00:24:44,812 --> 00:24:48,150
not sure about it. One really reallife important

397
00:24:48,220 --> 00:24:51,834
thing to do in your log, you ship all

398
00:24:51,872 --> 00:24:55,482
kind of metadata with it, right? What you can do is

399
00:24:55,536 --> 00:24:58,986
basically if you look on your flow that you have a bug in

400
00:24:59,008 --> 00:25:02,266
production today, you would get some error,

401
00:25:02,378 --> 00:25:06,222
probably, maybe try to product it, maybe go to your log

402
00:25:06,276 --> 00:25:10,222
solution, try to find the exception that was causing it.

403
00:25:10,356 --> 00:25:13,594
And imagine that you found an exception, quite a generic

404
00:25:13,642 --> 00:25:17,010
one, but you also have the trace id. The trace id

405
00:25:17,080 --> 00:25:20,258
allows you to take the trace id and throw it back

406
00:25:20,344 --> 00:25:23,854
into Jaeger. So you got an exception, you took the trace

407
00:25:23,902 --> 00:25:27,160
id. As you can see here, that's the trace id.

408
00:25:27,690 --> 00:25:31,640
You throw it in and now you can see the whole process

409
00:25:32,170 --> 00:25:35,414
that caused this exception. And it's a really reallife cool

410
00:25:35,452 --> 00:25:39,106
trick, simple one that you should definitely do. And I would urge

411
00:25:39,138 --> 00:25:42,634
you to start with open telemetry in Jaeger. It's kind of easy to set

412
00:25:42,672 --> 00:25:45,066
up and just work and it's amazing.

413
00:25:45,248 --> 00:25:48,506
Now I started to talk about visualization and

414
00:25:48,528 --> 00:25:51,966
said that I'm not sure it's answering the question. Let's say that

415
00:25:51,988 --> 00:25:54,766
you have some complex system,

416
00:25:54,948 --> 00:25:58,750
that you have a lot of services communicating with one another and

417
00:25:58,900 --> 00:26:03,278
everything is being sent to Jaeger. In here you

418
00:26:03,284 --> 00:26:07,006
are able to see how Yeager will show you the diagram

419
00:26:07,038 --> 00:26:10,914
of dependencies between services. Now this is in

420
00:26:10,952 --> 00:26:14,418
the service level communication. It's just telling you, hey,

421
00:26:14,504 --> 00:26:18,294
Scraper service is communicating with user service, but it

422
00:26:18,332 --> 00:26:22,038
also communicates with Wikipedia service. It's just telling you service

423
00:26:22,124 --> 00:26:25,986
a communication with B and just telling you who is communicating

424
00:26:26,098 --> 00:26:29,386
with who. It doesn't answer important question of

425
00:26:29,488 --> 00:26:32,954
when in which endpoint they are going to start

426
00:26:32,992 --> 00:26:35,418
to communicate with one another.

427
00:26:35,584 --> 00:26:39,322
So let's give it an example. In the left hand side

428
00:26:39,376 --> 00:26:43,386
you can see the service a, service b, service key communication.

429
00:26:43,578 --> 00:26:46,814
That's cool. And now I'm going to show

430
00:26:46,852 --> 00:26:50,190
you two different example of service a service a

431
00:26:50,260 --> 00:26:53,758
as an endpoint, v one items. Then it calls service

432
00:26:53,844 --> 00:26:57,902
c, but it calls service b only in v one purchase.

433
00:26:58,046 --> 00:27:01,666
And this is kind of the resolution that the developer is looking for.

434
00:27:01,768 --> 00:27:05,266
I want to know when services, when I'm communicating with

435
00:27:05,288 --> 00:27:08,578
one another. The fact they are communicating with one another is important,

436
00:27:08,664 --> 00:27:11,798
but it doesn't tell me all the details just yet. Those are

437
00:27:11,804 --> 00:27:15,046
the kind of things that aspecto is really good at helping the

438
00:27:15,068 --> 00:27:19,026
developer because we are trying to look at it from the developer perspective

439
00:27:19,058 --> 00:27:22,338
and trying to answer what they are looking for. We understood the

440
00:27:22,364 --> 00:27:26,214
problem. Now we know open telemetry, at least briefly,

441
00:27:26,262 --> 00:27:29,866
but we know what it can help us with. Let's assume that you

442
00:27:29,888 --> 00:27:32,960
started to collect distributed tracing data.

443
00:27:33,570 --> 00:27:37,694
Let's talk about why it's extremely important. So we

444
00:27:37,732 --> 00:27:40,766
already said that breaking as

445
00:27:40,788 --> 00:27:44,174
a whole helps us, but not a lot. It doesn't

446
00:27:44,222 --> 00:27:47,954
help me still with the big picture to understand it.

447
00:27:47,992 --> 00:27:51,890
It doesn't exactly help me with dependencies and

448
00:27:51,960 --> 00:27:55,682
it doesn't help me to narrow the gap between production to dev.

449
00:27:55,816 --> 00:27:59,346
Let me try and emphasize. So let's say

450
00:27:59,368 --> 00:28:02,678
that you want to replay traffic, right? I don't know how you're going to

451
00:28:02,684 --> 00:28:06,166
solve it today, but it's hard CTO solve. You need to start work on that.

452
00:28:06,188 --> 00:28:09,926
You need to start to introduce some tools that allows you to do that

453
00:28:10,108 --> 00:28:13,866
if you want to generate mocks. So usually you do static mocks. If you

454
00:28:13,888 --> 00:28:17,594
want to do API documentation, you do it manually, but maybe you can

455
00:28:17,632 --> 00:28:21,294
auto generate that. Think of all of those things. All of those

456
00:28:21,332 --> 00:28:25,182
things are present in your tracing data. Your ability to

457
00:28:25,236 --> 00:28:29,034
create docs is if you have the raw

458
00:28:29,082 --> 00:28:32,414
data, the raw network, the raw communication between

459
00:28:32,532 --> 00:28:35,934
the services, you can just take this data and create documentation

460
00:28:35,982 --> 00:28:39,646
based on that. So I think that you should use opentelemetry

461
00:28:39,678 --> 00:28:42,898
data. And it's very simple. You have sdks deployed in

462
00:28:42,984 --> 00:28:46,574
all kinds of different microservices. All of them are reporting

463
00:28:46,622 --> 00:28:50,290
to some component called collect and opentelemetry.

464
00:28:50,370 --> 00:28:54,134
Basically something that knows how to receive all the span and then just send

465
00:28:54,172 --> 00:28:57,826
them to some database of your choosing, such as elasticsearch.

466
00:28:57,938 --> 00:29:01,526
And on top of that you have Jaeger. Right? Yeager can communicate

467
00:29:01,558 --> 00:29:05,242
with elasticsearch. I think it's their best

468
00:29:05,296 --> 00:29:08,934
practice. And then what you can do is whenever

469
00:29:08,982 --> 00:29:12,846
you have some question that you want to understand how things are

470
00:29:12,868 --> 00:29:15,930
operating production environment, go and ask your database.

471
00:29:16,010 --> 00:29:19,486
It's already there, just to give you an idea.

472
00:29:19,668 --> 00:29:23,102
So you need to generate a mock, a mock for your unit tests.

473
00:29:23,156 --> 00:29:26,786
For instance, how are you doing it today? Looking at the

474
00:29:26,808 --> 00:29:29,954
code probably, and saying okay, I assume that I need

475
00:29:29,992 --> 00:29:33,346
this data to look that way or another. And I would

476
00:29:33,368 --> 00:29:36,978
just create the basic thing that I need to have for my mock,

477
00:29:37,074 --> 00:29:40,182
make it static. And I won't ever change it, right.

478
00:29:40,236 --> 00:29:43,862
Unless something really significant happens. But what

479
00:29:43,916 --> 00:29:47,278
happens if we use the database to fetch some mocks?

480
00:29:47,394 --> 00:29:51,690
Right now I have real relevant traces with real

481
00:29:51,760 --> 00:29:56,214
different usages, and I can really easily reproduce

482
00:29:56,262 --> 00:29:59,018
my production environment better in my test.

483
00:29:59,104 --> 00:30:03,178
And this is very, very easy to do and could really improve

484
00:30:03,274 --> 00:30:06,814
your tests. So I think we found cool ways. And just

485
00:30:06,852 --> 00:30:10,286
through an idea there, there is tons of things that you

486
00:30:10,308 --> 00:30:13,986
can do with distributing tracing data.

487
00:30:14,088 --> 00:30:17,746
If you're interested in that, go check out aspecto and our

488
00:30:17,768 --> 00:30:21,474
blog. We're talking about it quite often. And yeah,

489
00:30:21,512 --> 00:30:25,266
we started from three microservices, very simple,

490
00:30:25,368 --> 00:30:28,550
easy to reproduce locally, easy to tell another

491
00:30:28,620 --> 00:30:31,686
developer about it. And things started to get more and

492
00:30:31,708 --> 00:30:35,494
more complicated. So we introduced async communication using

493
00:30:35,532 --> 00:30:38,710
Kafka. Then we kind of lost sight of what's happening.

494
00:30:38,780 --> 00:30:42,650
So we had to introduce tracing. And then we found what

495
00:30:42,720 --> 00:30:46,378
we can do with tracing, and we can do a whole bunch of that.

496
00:30:46,544 --> 00:30:50,294
My suggestion is CTo you to get familiar with open telemetry,

497
00:30:50,342 --> 00:30:53,406
get to know distributed tracing, understand how

498
00:30:53,428 --> 00:30:56,558
to implement it. Your microservices is going to be super

499
00:30:56,644 --> 00:31:00,494
helpful. Always log your trace id in any log in our

500
00:31:00,532 --> 00:31:04,266
system, we have the trace id. If something happens, we can always throw

501
00:31:04,298 --> 00:31:08,238
it in Yeager and then just visualize it. And once you have all

502
00:31:08,244 --> 00:31:11,774
of that, go once a week to your database, have a look

503
00:31:11,812 --> 00:31:15,478
there. I'm pretty sure you're going to find some interesting stuff.

504
00:31:15,564 --> 00:31:19,574
So thank you very much. I really enjoyed talking about

505
00:31:19,612 --> 00:31:23,206
it. And if you have any questions, feel free to shoot me an email,

506
00:31:23,308 --> 00:31:26,614
Twitter, whatever. Thank you. Hope to see you next

507
00:31:26,652 --> 00:31:26,740
time.

