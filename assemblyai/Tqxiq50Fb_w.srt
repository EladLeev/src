1
00:00:00,250 --> 00:00:04,830
Are you an SRE, a developer,

2
00:00:06,610 --> 00:00:10,474
a quality engineer who wants to tackle the challenge of improving

3
00:00:10,522 --> 00:00:14,026
reliability in your DevOps? You can enable your DevOps

4
00:00:14,058 --> 00:00:17,614
for reliability with chaos native. Create your

5
00:00:17,652 --> 00:01:17,640
free account at Chaos native Litmus Cloud hello,

6
00:01:18,410 --> 00:01:22,198
it's miece Shukong and we will be talking about

7
00:01:22,364 --> 00:01:26,470
reaching effectiveness for modern Java applications

8
00:01:26,810 --> 00:01:30,246
and still keeping them reliable in modern

9
00:01:30,278 --> 00:01:34,106
deployments. I work at a

10
00:01:34,128 --> 00:01:37,450
company named Bellsoft. We are among

11
00:01:38,430 --> 00:01:42,302
top OpenJDK enterprise contributors for

12
00:01:42,356 --> 00:01:45,706
minor releases and we release

13
00:01:45,738 --> 00:01:49,338
our own binary distribution of OpenJDK called Liberica

14
00:01:49,354 --> 00:01:53,042
JDK. I will mention it today,

15
00:01:53,176 --> 00:01:57,010
but all that I say is applicable

16
00:01:57,590 --> 00:02:01,518
to generality to any OpenJDK distribution.

17
00:02:01,694 --> 00:02:04,802
I guess so.

18
00:02:04,856 --> 00:02:08,230
Today we most typically use containers

19
00:02:08,890 --> 00:02:13,954
to offload routine task of reproducing

20
00:02:14,082 --> 00:02:17,850
same environment for all different

21
00:02:17,920 --> 00:02:21,820
applications we have assembled together.

22
00:02:23,070 --> 00:02:26,220
And we take help

23
00:02:26,590 --> 00:02:31,022
from systems like kubernetes and other

24
00:02:31,076 --> 00:02:34,458
systems that provide us other components

25
00:02:34,634 --> 00:02:38,190
to assemble all the production, the business

26
00:02:38,260 --> 00:02:41,678
logic, and also things like circuit breaker or

27
00:02:41,764 --> 00:02:44,258
fingers controller. Anyway,

28
00:02:44,424 --> 00:02:49,010
they're helpful. And inside containers that we produce

29
00:02:49,750 --> 00:02:53,298
we typically see layers starting

30
00:02:53,384 --> 00:02:56,550
from scratch and then having some os.

31
00:02:57,290 --> 00:02:59,800
In the case of Java world,

32
00:03:00,330 --> 00:03:04,438
of course some runtime and to run that

33
00:03:04,604 --> 00:03:08,682
JVM we need some os packages and we may also

34
00:03:08,736 --> 00:03:12,314
need some os packages to run the application itself.

35
00:03:12,432 --> 00:03:16,634
Maybe we have some native dependencies and

36
00:03:16,752 --> 00:03:21,166
then we have Java libraries. We typically have

37
00:03:21,348 --> 00:03:25,134
some framework that helps to

38
00:03:25,172 --> 00:03:28,414
connect to database to respond with

39
00:03:28,452 --> 00:03:32,058
some nice formatted output to our clients,

40
00:03:32,234 --> 00:03:33,840
whatever it makes.

41
00:03:34,930 --> 00:03:38,386
And then they have a tiny piece of the

42
00:03:38,408 --> 00:03:42,066
iceberg where our business logic, our application

43
00:03:42,168 --> 00:03:45,474
lives. And this

44
00:03:45,512 --> 00:03:48,854
is for classical container, the for JVM. And there

45
00:03:48,892 --> 00:03:53,298
may be another case then we use and when we produce native images

46
00:03:53,474 --> 00:03:56,822
using static compilation to

47
00:03:56,876 --> 00:04:00,380
decode machine code of the target platform.

48
00:04:01,230 --> 00:04:05,494
In this case we'll probably have larger

49
00:04:05,542 --> 00:04:08,902
tip of the iceberg, but we won't have additional

50
00:04:08,966 --> 00:04:15,162
things. We may even skip the OS

51
00:04:15,226 --> 00:04:18,800
layer sometimes. Then we link

52
00:04:19,170 --> 00:04:22,960
all necessary dependencies into the native image itself.

53
00:04:27,040 --> 00:04:30,796
So how

54
00:04:30,898 --> 00:04:34,590
small is that iceberg tip in the case

55
00:04:34,960 --> 00:04:37,900
of regular JVM deployment?

56
00:04:38,820 --> 00:04:42,112
If we go and if we

57
00:04:42,166 --> 00:04:46,076
imagine some spring application using spring

58
00:04:46,108 --> 00:04:49,928
boot framework and we go and create such an application using spring

59
00:04:49,964 --> 00:04:51,140
initializer,

60
00:04:53,000 --> 00:04:56,580
we will have a working project. We can compile it and get

61
00:04:56,730 --> 00:04:59,456
a 37 megabytes fat jar.

62
00:04:59,648 --> 00:05:02,936
That's all we need to run it on

63
00:05:02,958 --> 00:05:06,612
the JVMCI. But if we extract

64
00:05:06,676 --> 00:05:10,410
thin jar out of it, it will

65
00:05:10,860 --> 00:05:14,708
be as small as 3 kb, so it

66
00:05:14,814 --> 00:05:16,780
will be really extremely tiny.

67
00:05:18,320 --> 00:05:22,344
This is a piece of code that initializes

68
00:05:22,392 --> 00:05:26,076
our application, maybe starts from endpoint, that's it.

69
00:05:26,258 --> 00:05:31,664
Everything else is performed by the framework and

70
00:05:31,702 --> 00:05:35,360
then we wrap it into a container.

71
00:05:36,900 --> 00:05:40,252
How do we do that? Well, there are different ways.

72
00:05:40,406 --> 00:05:44,004
Sometimes we even see so

73
00:05:44,042 --> 00:05:47,700
called classical deployments and we create war files and

74
00:05:47,770 --> 00:05:51,492
they are deployed on the web server. Some people

75
00:05:51,626 --> 00:05:55,636
use out of the box functionality provided

76
00:05:55,668 --> 00:05:59,240
by the framework to produce the container,

77
00:06:00,220 --> 00:06:04,656
and still many developers

78
00:06:04,788 --> 00:06:08,110
or DevOps write docker files themselves.

79
00:06:09,600 --> 00:06:13,132
There's no wrong and right way

80
00:06:13,186 --> 00:06:16,568
here. All approaches

81
00:06:16,744 --> 00:06:19,984
have their drawbacks and have reasons to

82
00:06:20,022 --> 00:06:23,552
be used. But we can

83
00:06:23,606 --> 00:06:27,632
help in many cases from the side

84
00:06:27,766 --> 00:06:30,912
of vendor of JVM,

85
00:06:30,976 --> 00:06:34,550
or from other perspectives. Let's see.

86
00:06:36,120 --> 00:06:40,628
So as I mentioned, we need some parent

87
00:06:40,794 --> 00:06:44,280
image in all the cases to

88
00:06:44,430 --> 00:06:48,148
inject our application logic.

89
00:06:48,324 --> 00:06:51,930
On top of that and from

90
00:06:53,340 --> 00:06:56,856
JDK vendor perspective, base image

91
00:06:56,888 --> 00:07:00,860
is always an image having Java runtime.

92
00:07:01,200 --> 00:07:05,176
So I will use base and parent image

93
00:07:05,208 --> 00:07:08,750
terms both for the same thing,

94
00:07:09,840 --> 00:07:13,890
and then we put Java runtime into the

95
00:07:14,260 --> 00:07:17,552
container image. It can be

96
00:07:17,606 --> 00:07:21,572
done in a different ways. Basically very

97
00:07:21,626 --> 00:07:25,684
simple options like we can drop a binary, extract it and

98
00:07:25,802 --> 00:07:30,356
create all necessary dependencies. That's one of the ways we

99
00:07:30,378 --> 00:07:34,356
can install some OpenJDK distribution

100
00:07:34,468 --> 00:07:38,650
from standard packages repository of

101
00:07:39,020 --> 00:07:42,808
the OS distribution, or we can plug in

102
00:07:42,974 --> 00:07:46,572
some additional repository and

103
00:07:46,706 --> 00:07:49,070
install the package from there.

104
00:07:49,680 --> 00:07:53,084
In all that cases, it's good to be sure

105
00:07:53,282 --> 00:07:56,524
that someone who

106
00:07:56,562 --> 00:08:00,400
provided the base container image for you

107
00:08:00,550 --> 00:08:04,370
to care about testing because

108
00:08:06,420 --> 00:08:10,200
there is a huge amount of compatibility

109
00:08:10,300 --> 00:08:12,900
testing for the case.

110
00:08:13,050 --> 00:08:15,780
Then we create a JDK distribution.

111
00:08:16,440 --> 00:08:20,390
Many tests are to be run and

112
00:08:21,400 --> 00:08:25,092
there are bugs and there

113
00:08:25,146 --> 00:08:29,096
may be fine issues that we will see later.

114
00:08:29,278 --> 00:08:33,192
Then we install something looking pretty

115
00:08:33,246 --> 00:08:37,228
standard, but we get

116
00:08:37,314 --> 00:08:39,340
some unexpected behavior.

117
00:08:41,760 --> 00:08:45,116
So that is very simple to get an

118
00:08:45,138 --> 00:08:48,300
OpenJDk for your Java service or

119
00:08:48,370 --> 00:08:52,032
groovy service or Kotlin service. We just

120
00:08:52,166 --> 00:08:55,810
can use docker pool and say okay,

121
00:08:57,620 --> 00:09:00,948
I need something called openjdk, get jit please.

122
00:09:01,034 --> 00:09:03,190
And it will work,

123
00:09:04,040 --> 00:09:06,960
no problem, you'll have some image.

124
00:09:07,120 --> 00:09:10,532
Well you probably already asked

125
00:09:10,586 --> 00:09:13,610
all the questions about testing and who provide that.

126
00:09:14,540 --> 00:09:16,730
Well anyway,

127
00:09:18,700 --> 00:09:22,232
in my circumstances with 100

128
00:09:22,286 --> 00:09:26,220
megabit network it will be downloaded half of a minute.

129
00:09:28,880 --> 00:09:32,044
It really takes a long time to get

130
00:09:32,082 --> 00:09:35,916
to my machine. What's the problem actually then

131
00:09:36,018 --> 00:09:39,120
it is uncompressed. Jit takes half,

132
00:09:39,190 --> 00:09:42,320
more than half of a gigabyte on my disk.

133
00:09:43,460 --> 00:09:45,410
That's not something that I like.

134
00:09:46,500 --> 00:09:50,164
Well, it becomes even

135
00:09:50,202 --> 00:09:54,244
more scary and probably unreliable. Then you have

136
00:09:54,362 --> 00:09:57,060
massive deployment in your production.

137
00:09:57,720 --> 00:10:01,540
Imagine that you have 1000

138
00:10:01,690 --> 00:10:05,396
deploys using simultaneously and you have quarter

139
00:10:05,428 --> 00:10:07,450
of terabyte flying around.

140
00:10:08,540 --> 00:10:13,064
Something may go wrong it

141
00:10:13,102 --> 00:10:16,860
may be easy and cheap,

142
00:10:18,080 --> 00:10:22,716
but for example, if you start chasing the

143
00:10:22,738 --> 00:10:27,268
main region boundaries with the traffic,

144
00:10:27,464 --> 00:10:30,924
or you start to break some limits,

145
00:10:30,972 --> 00:10:36,432
some quotas that you already have and that

146
00:10:36,486 --> 00:10:39,852
might be used by some neighbor services or

147
00:10:39,926 --> 00:10:43,444
some stuff that you put on the same machines where

148
00:10:43,482 --> 00:10:45,540
you deploy.

149
00:10:47,640 --> 00:10:51,990
Or maybe you don't have a public cloud

150
00:10:52,780 --> 00:10:56,712
issues, but you really have a lot of private cloud

151
00:10:56,766 --> 00:11:00,008
issues. Well in any case,

152
00:11:00,174 --> 00:11:04,804
such a massive overhead doesn't

153
00:11:04,852 --> 00:11:07,452
sound right. Well,

154
00:11:07,506 --> 00:11:11,500
obviously smaller containers help us in these situations.

155
00:11:12,560 --> 00:11:16,136
Smaller containers, small container images, base images,

156
00:11:16,328 --> 00:11:19,936
JVMci how do we get that?

157
00:11:20,038 --> 00:11:22,930
Well, there are different ways,

158
00:11:23,460 --> 00:11:27,056
different vendors, providers. We can

159
00:11:27,158 --> 00:11:30,316
go and search, but then we have to select some.

160
00:11:30,438 --> 00:11:33,750
Well we'll look at a couple of examples here.

161
00:11:34,280 --> 00:11:35,190
For example,

162
00:11:37,960 --> 00:11:42,172
someone may say okay, we are targeted to microservices,

163
00:11:42,336 --> 00:11:44,920
to cloud deployments, kubernetes,

164
00:11:46,300 --> 00:11:50,250
and someone else can say exactly the same.

165
00:11:52,220 --> 00:11:56,030
Well let's look at

166
00:11:57,120 --> 00:12:01,230
these examples in action. We can

167
00:12:02,240 --> 00:12:05,708
try two different containers with Java eight.

168
00:12:05,874 --> 00:12:10,480
It is still alive, long term support at the release of JDK

169
00:12:11,700 --> 00:12:15,324
and we take something that's expected to be the latest

170
00:12:15,372 --> 00:12:19,136
version and we see that in one case the version is

171
00:12:19,158 --> 00:12:23,284
not latest, which means we

172
00:12:23,322 --> 00:12:27,108
miss like a year of security updates in

173
00:12:27,194 --> 00:12:31,110
this base image. That's really not good,

174
00:12:31,800 --> 00:12:36,264
while it is smaller and look

175
00:12:36,302 --> 00:12:39,800
here, both images are smaller than the one

176
00:12:39,870 --> 00:12:42,730
that I showed you first.

177
00:12:45,020 --> 00:12:48,296
Well, what's inside? Something is missing.

178
00:12:48,488 --> 00:12:51,516
The smallest one doesn't have.

179
00:12:51,698 --> 00:12:54,984
So Jit is outdated and it doesn't

180
00:12:55,032 --> 00:12:58,816
have a diagnostic tool called Java Flight recorder or

181
00:12:58,838 --> 00:13:02,464
JDK flight recorder. It is

182
00:13:02,502 --> 00:13:05,936
a very convenient tool. You can go to

183
00:13:06,038 --> 00:13:09,360
Bellsoft's block for example. We have a detailed

184
00:13:09,800 --> 00:13:13,856
overview of how to squeeze

185
00:13:13,968 --> 00:13:17,860
useful information about your production using JFR

186
00:13:18,440 --> 00:13:23,140
and it's just not there. It is a free option in OpenJDK,

187
00:13:23,660 --> 00:13:26,936
but it's not included here.

188
00:13:27,118 --> 00:13:31,370
Or we can go another way.

189
00:13:32,380 --> 00:13:35,660
If we use spring, we can issue a simple

190
00:13:35,730 --> 00:13:39,576
comment spring build a container

191
00:13:39,608 --> 00:13:43,496
image for me and it will perform container

192
00:13:43,528 --> 00:13:47,116
image build and the output will be a

193
00:13:47,138 --> 00:13:50,896
container image in your local repository which

194
00:13:50,918 --> 00:13:54,530
is already layered and inside it has

195
00:13:55,620 --> 00:13:58,160
supported Liberica JDK.

196
00:13:58,820 --> 00:14:02,852
So if you building such

197
00:14:02,906 --> 00:14:06,272
images on a regular manner, you will have updated

198
00:14:06,336 --> 00:14:10,084
version with security updates and you can switch to

199
00:14:10,202 --> 00:14:11,430
some page support.

200
00:14:13,820 --> 00:14:17,892
But here you get the properly

201
00:14:17,956 --> 00:14:20,250
prepared container out of the box,

202
00:14:21,020 --> 00:14:24,810
which is also much smaller than we saw

203
00:14:26,080 --> 00:14:29,756
in the previous cases and it is

204
00:14:29,778 --> 00:14:34,904
a convenient way and diagnostic

205
00:14:35,032 --> 00:14:38,496
tools like JFR are already included here.

206
00:14:38,678 --> 00:14:40,370
Well this is great.

207
00:14:41,940 --> 00:14:45,116
Besides of JDK, the extremely

208
00:14:45,148 --> 00:14:49,184
important part of your base container image is

209
00:14:49,222 --> 00:14:52,950
the OS layer and options here

210
00:14:53,480 --> 00:14:54,950
are really different.

211
00:14:56,600 --> 00:14:59,510
First they are really different in size,

212
00:15:00,360 --> 00:15:04,152
there are humongous ones and there is one

213
00:15:04,206 --> 00:15:07,864
which is extremely slim, but still it

214
00:15:07,902 --> 00:15:11,620
has standard C library, JIt has a package manager

215
00:15:11,700 --> 00:15:15,964
and it has a shell so you can log

216
00:15:16,002 --> 00:15:17,820
in in a convenient manner,

217
00:15:19,040 --> 00:15:22,664
apply some diagnostic scripts, standard JDK

218
00:15:22,712 --> 00:15:26,632
tools, whatever. And this distribution

219
00:15:26,696 --> 00:15:30,236
is called Alpine Linux. Well it's

220
00:15:30,268 --> 00:15:31,330
slightly different.

221
00:15:33,860 --> 00:15:37,536
This distribution is based on a special

222
00:15:37,638 --> 00:15:41,236
C library called muscle. It also

223
00:15:41,338 --> 00:15:44,612
has something called Busybox which is a

224
00:15:44,666 --> 00:15:48,820
swiss army knife implementing all standard or many

225
00:15:48,890 --> 00:15:51,220
standard Unix tools.

226
00:15:52,700 --> 00:15:56,776
And JDK was ported to

227
00:15:56,878 --> 00:16:00,760
be able to work natively on opine Linux

228
00:16:01,820 --> 00:16:05,320
and other muscle based distributions

229
00:16:07,340 --> 00:16:11,808
in the manner when it doesn't require glipc

230
00:16:11,924 --> 00:16:15,692
library. So we only use muscle and that

231
00:16:15,746 --> 00:16:19,584
allows us to use that initially slim version of

232
00:16:19,622 --> 00:16:23,376
Alpine. There is also an option to

233
00:16:23,398 --> 00:16:27,410
use glipsy layer. It will be still small but

234
00:16:28,100 --> 00:16:31,764
it will be noticeably larger than

235
00:16:31,802 --> 00:16:33,140
the muscle version.

236
00:16:35,080 --> 00:16:38,870
So if we look what happened

237
00:16:40,440 --> 00:16:44,456
then we released some like in this case 15

238
00:16:44,638 --> 00:16:49,492
version of JDK comparing

239
00:16:49,636 --> 00:16:53,160
other images that are also slim.

240
00:16:53,740 --> 00:16:57,470
The Alpine is a champion here. And by the way

241
00:16:57,840 --> 00:17:00,750
if you noticed few slides before,

242
00:17:01,120 --> 00:17:05,150
Alpine Linux is even smaller than distro less

243
00:17:06,160 --> 00:17:10,036
which is actually a distro image devout

244
00:17:10,088 --> 00:17:12,000
package manager and shell.

245
00:17:14,260 --> 00:17:17,884
Well pull time is only 4 seconds

246
00:17:18,012 --> 00:17:21,492
that this small image paste on

247
00:17:21,546 --> 00:17:25,460
Alpine. So in 4 seconds on 100 megabytes network

248
00:17:26,040 --> 00:17:29,860
you get working OpenJDK in a container.

249
00:17:30,840 --> 00:17:34,216
That's really cool and really fast. If you have

250
00:17:34,238 --> 00:17:37,320
faster network of course you get it even faster.

251
00:17:39,100 --> 00:17:43,912
Well for Opian there are different

252
00:17:44,046 --> 00:17:47,836
options. Again the

253
00:17:47,858 --> 00:17:51,272
landscape is big and here we compiler

254
00:17:51,336 --> 00:17:54,588
for example the berka with

255
00:17:54,754 --> 00:17:58,416
another base image which appears to

256
00:17:58,438 --> 00:18:02,156
be smaller. Well why doesn't

257
00:18:02,188 --> 00:18:05,410
happen? You see that

258
00:18:07,380 --> 00:18:11,632
RTjar and other jars

259
00:18:11,776 --> 00:18:15,760
that contain standard library classes are compressed

260
00:18:15,840 --> 00:18:18,180
in the case of other distribution.

261
00:18:19,400 --> 00:18:23,636
Well unfortunately for Java

262
00:18:23,668 --> 00:18:27,092
eight that leads to a performant

263
00:18:27,156 --> 00:18:31,128
hit. Then we start our application and then it uses some

264
00:18:31,214 --> 00:18:34,676
classes and definitely it does classes

265
00:18:34,708 --> 00:18:38,830
from standard library it start to

266
00:18:40,160 --> 00:18:44,216
load slower and moreover

267
00:18:44,328 --> 00:18:47,260
than we transfer such an image over the network.

268
00:18:47,620 --> 00:18:51,200
Yes it may take less size

269
00:18:51,270 --> 00:18:55,168
on disk but we transfer

270
00:18:55,254 --> 00:18:58,736
it compressed. Like for example if we connect to

271
00:18:58,758 --> 00:19:02,244
docker repository and if we

272
00:19:02,282 --> 00:19:06,304
compress something twice jit actually becomes

273
00:19:06,352 --> 00:19:09,732
larger. So the size

274
00:19:09,786 --> 00:19:13,370
of compressed image is worse in this case

275
00:19:15,340 --> 00:19:18,280
if it contains compressed chars.

276
00:19:20,780 --> 00:19:24,804
Okay, we sometimes need to

277
00:19:24,862 --> 00:19:28,664
profile our application to ensure that it's

278
00:19:28,712 --> 00:19:31,710
reliable or to fix some problems.

279
00:19:32,240 --> 00:19:35,772
Well there is a great tool in Java world called

280
00:19:35,826 --> 00:19:39,292
Async profiler which can be used and

281
00:19:39,346 --> 00:19:43,116
it combines Java stacks, the native stacks

282
00:19:43,148 --> 00:19:46,864
up to some kernel calls and

283
00:19:46,902 --> 00:19:51,188
we might try to use it. Okay, let's install

284
00:19:51,274 --> 00:19:53,670
some dependencies, run our application,

285
00:19:54,120 --> 00:19:58,484
find the process id connect well

286
00:19:58,682 --> 00:20:03,480
we see that it does something inside JVM.

287
00:20:03,980 --> 00:20:07,880
What's the problem? We can take the Berkeley

288
00:20:08,220 --> 00:20:11,864
and to see detailed description for what

289
00:20:11,902 --> 00:20:15,544
happens in this case C two server

290
00:20:15,592 --> 00:20:19,144
compiler and its internal

291
00:20:19,192 --> 00:20:21,420
parts are visible in the profile.

292
00:20:22,720 --> 00:20:25,900
The key here is having debug symbols.

293
00:20:27,300 --> 00:20:30,092
This is not a debug build of JDK,

294
00:20:30,236 --> 00:20:34,672
but debug symbols can be just included with release build

295
00:20:34,806 --> 00:20:38,396
into release build and they help profilers

296
00:20:38,508 --> 00:20:42,328
like Async profiler to show morphine

297
00:20:42,364 --> 00:20:46,400
great information about what application and runtime

298
00:20:46,560 --> 00:20:49,940
do in some workloads.

299
00:20:53,430 --> 00:20:57,334
So I mentioned port of

300
00:20:57,372 --> 00:21:01,430
OpenJDK to muscle and opine Linux.

301
00:21:02,410 --> 00:21:05,942
It was integrated on

302
00:21:06,076 --> 00:21:09,894
the timeline of JDK 16 and these

303
00:21:09,932 --> 00:21:12,650
days we made JDK 17.

304
00:21:14,430 --> 00:21:18,378
But JDk eleven and JDK eight

305
00:21:18,464 --> 00:21:22,030
are still actively maintained long term supported releases.

306
00:21:22,770 --> 00:21:25,840
So few vendors provide

307
00:21:27,970 --> 00:21:32,058
ports of alpine muscle support

308
00:21:32,244 --> 00:21:35,486
to that older

309
00:21:35,518 --> 00:21:39,234
releases. So such builds are also

310
00:21:39,272 --> 00:21:42,546
available. And don't forget about

311
00:21:42,648 --> 00:21:46,310
alternatives architectures isas

312
00:21:46,890 --> 00:21:50,994
like arm 64. They are also supported

313
00:21:51,122 --> 00:21:53,960
by this change.

314
00:21:56,250 --> 00:21:59,850
Okay, we discussed a couple of examples,

315
00:22:00,350 --> 00:22:03,690
but can it be simpler?

316
00:22:04,190 --> 00:22:07,366
What if we just take Alpine Linux and install OpenJdk

317
00:22:07,398 --> 00:22:11,058
there and we'll get that sweet

318
00:22:11,174 --> 00:22:14,938
small container with all standard components

319
00:22:15,114 --> 00:22:18,282
and we don't need to think of different vendors,

320
00:22:18,426 --> 00:22:22,842
we just select base OS image and use OpenJDK,

321
00:22:22,986 --> 00:22:25,840
include it there. Okay, we can try.

322
00:22:26,210 --> 00:22:29,822
Let's add OpenJDk eight and

323
00:22:29,876 --> 00:22:33,870
try to use standard diagnostic tool called jcommand.

324
00:22:34,810 --> 00:22:38,210
Jit allows scripting

325
00:22:38,290 --> 00:22:41,782
and provides a very nice text

326
00:22:41,836 --> 00:22:45,574
interface. So this

327
00:22:45,612 --> 00:22:50,534
is a really necessary diagnostic

328
00:22:50,662 --> 00:22:54,380
tool. It just can start.

329
00:22:55,230 --> 00:22:58,282
There is no ls for this

330
00:22:58,336 --> 00:23:00,800
command. Okay.

331
00:23:01,410 --> 00:23:04,942
Anyway it's there and we can find Jit and

332
00:23:04,996 --> 00:23:09,002
use fullpath to start it. And let's try to execute

333
00:23:09,066 --> 00:23:12,270
a very simple basic command.

334
00:23:12,790 --> 00:23:17,378
Let's find out the uptime of running JVM instead

335
00:23:17,464 --> 00:23:21,074
we'll get a stack trace. That's really

336
00:23:21,112 --> 00:23:24,260
weird. Let's instead take

337
00:23:25,270 --> 00:23:30,414
some tested distribution prepared

338
00:23:30,462 --> 00:23:33,526
as a ready made container. Well,

339
00:23:33,628 --> 00:23:37,866
no problem. We have that jcommand tool

340
00:23:38,048 --> 00:23:41,370
and we get the uptime of running JVM instantly.

341
00:23:44,350 --> 00:23:48,506
Sometimes we have

342
00:23:48,688 --> 00:23:51,760
issues with public services,

343
00:23:52,290 --> 00:23:56,526
different ones, and sometimes they just change the

344
00:23:56,548 --> 00:23:59,950
terms of service like it happened with Docker hub.

345
00:24:00,610 --> 00:24:03,922
For that cases it's good to have

346
00:24:04,056 --> 00:24:07,918
some proxying functionality to bypass the limits

347
00:24:08,094 --> 00:24:11,474
or to have a private registry that

348
00:24:11,512 --> 00:24:15,302
you can connect to and where

349
00:24:15,356 --> 00:24:18,710
you can ask for some

350
00:24:18,780 --> 00:24:22,694
slas. And in the case of Bellsoft we

351
00:24:22,732 --> 00:24:26,802
provide such a thing. We also put some

352
00:24:26,876 --> 00:24:31,158
custom builds and container images

353
00:24:31,334 --> 00:24:34,874
for customers there. For example

354
00:24:35,072 --> 00:24:39,034
if you have support contract and you have

355
00:24:39,232 --> 00:24:42,670
refined or you find a bug in JDK,

356
00:24:43,090 --> 00:24:46,206
we can fix it, run all the testing to

357
00:24:46,228 --> 00:24:52,474
ensure that the build that affix corresponds

358
00:24:52,602 --> 00:24:56,066
to a Java specification and then it can be

359
00:24:56,088 --> 00:24:59,566
released in a private repository. It is one of the channels

360
00:24:59,758 --> 00:25:05,122
to deliver such useful

361
00:25:05,266 --> 00:25:08,774
builds for customers. Then the fix is integrated into

362
00:25:08,812 --> 00:25:11,670
OpenJDK publicly,

363
00:25:12,730 --> 00:25:16,566
but there

364
00:25:16,588 --> 00:25:20,170
is no need to wait for having it in production.

365
00:25:22,190 --> 00:25:26,170
So you can also try early access

366
00:25:26,240 --> 00:25:30,320
builds there. At least they used to be

367
00:25:31,250 --> 00:25:37,886
provided in this repository. Also it

368
00:25:37,908 --> 00:25:41,550
is very essential to connect to such a registry.

369
00:25:42,070 --> 00:25:46,594
You just need some credentials and then you work with

370
00:25:46,712 --> 00:25:50,206
it. Just like this public Toky

371
00:25:50,238 --> 00:25:53,954
registry. You see

372
00:25:53,992 --> 00:25:58,294
some experimental things that they put there are

373
00:25:58,332 --> 00:26:02,294
related to container sizes and

374
00:26:02,332 --> 00:26:06,022
they also provide experimental optimizations for

375
00:26:06,076 --> 00:26:08,950
latency, for footprint,

376
00:26:10,090 --> 00:26:13,298
for throughput in

377
00:26:13,324 --> 00:26:17,338
such builds like interesting

378
00:26:17,424 --> 00:26:21,070
bug ports. We've dont in JDK eleven

379
00:26:23,330 --> 00:26:28,538
not for a long time ago. They include footprint

380
00:26:28,714 --> 00:26:32,850
savings. Here we take some typical

381
00:26:33,590 --> 00:26:37,694
spring boot service pet clinic

382
00:26:37,742 --> 00:26:41,860
sample application and we can just launch it

383
00:26:42,390 --> 00:26:46,806
put now load and measure how

384
00:26:46,828 --> 00:26:49,590
much memory does it require.

385
00:26:51,530 --> 00:26:55,426
And if we apply slightly

386
00:26:55,458 --> 00:26:58,758
updated version of JDK we have

387
00:26:58,924 --> 00:27:01,580
big settings in footprint for free.

388
00:27:03,230 --> 00:27:06,902
So we immediately made our production more reliable.

389
00:27:07,046 --> 00:27:10,478
The JDK is tested in

390
00:27:10,484 --> 00:27:13,834
the same way as the released

391
00:27:13,882 --> 00:27:17,902
version. So this preview early access is

392
00:27:17,956 --> 00:27:21,926
just for some extra features,

393
00:27:21,978 --> 00:27:25,714
but it goes through the same pipeline of

394
00:27:25,752 --> 00:27:28,834
testing, so still

395
00:27:28,872 --> 00:27:31,170
secure and we get that savings.

396
00:27:32,870 --> 00:27:36,886
So when we select the container and

397
00:27:36,988 --> 00:27:40,200
the way we build it, there are a few

398
00:27:41,210 --> 00:27:47,234
interesting big roads like

399
00:27:47,292 --> 00:27:53,100
we may decide to take native image road that

400
00:27:54,030 --> 00:27:57,130
has its known limitations.

401
00:27:57,630 --> 00:28:01,738
Like for example we won't be able to use standard diagnostic tools

402
00:28:01,754 --> 00:28:05,022
from JDK and we will have

403
00:28:05,156 --> 00:28:08,830
the penalty. Then we update our

404
00:28:08,900 --> 00:28:12,974
running images frequently. So in

405
00:28:13,012 --> 00:28:16,114
case then we use classical JVM and we have

406
00:28:16,152 --> 00:28:18,370
very small iceberg tip,

407
00:28:19,990 --> 00:28:23,554
we can update only that thin layer and

408
00:28:23,592 --> 00:28:27,366
it will be extremely effective. In case

409
00:28:27,388 --> 00:28:29,720
of native image we'll have to update everything,

410
00:28:31,690 --> 00:28:36,486
almost everything. But at

411
00:28:36,508 --> 00:28:40,460
the same time it is better for

412
00:28:41,230 --> 00:28:44,586
new nodes because we

413
00:28:44,608 --> 00:28:48,602
don't need to transfer the entire big Asperg, we'll transfer smaller one

414
00:28:48,656 --> 00:28:54,220
the native image and we'll see the comparison what

415
00:28:54,850 --> 00:28:58,334
size difference. Then we use it. So for

416
00:28:58,372 --> 00:29:02,240
classical JVM containers we also have options.

417
00:29:02,550 --> 00:29:05,714
Like I mentioned LPN Linux you

418
00:29:05,752 --> 00:29:08,962
may have something against MuSL or Busybox or

419
00:29:09,016 --> 00:29:12,900
APK package manager. It may be just

420
00:29:13,670 --> 00:29:17,640
not familiar environment. Okay then you can take

421
00:29:18,410 --> 00:29:23,366
something more well known like

422
00:29:23,548 --> 00:29:27,214
yam package manager or apt

423
00:29:27,362 --> 00:29:30,986
or you need glipsy which

424
00:29:31,008 --> 00:29:34,854
is also available in opine case and in other cases

425
00:29:34,902 --> 00:29:40,814
too. So what

426
00:29:40,852 --> 00:29:44,462
about native images and the ways to create

427
00:29:44,516 --> 00:29:48,510
them? Native images are about static compilation

428
00:29:49,650 --> 00:29:53,630
and static compilation was added to JDK

429
00:29:54,930 --> 00:29:59,122
to OpenJDK some time ago and

430
00:29:59,256 --> 00:30:04,146
now it's been removed in

431
00:30:04,168 --> 00:30:07,270
the form that it has been implemented earlier.

432
00:30:08,890 --> 00:30:12,162
But there is still can interface to plug

433
00:30:12,226 --> 00:30:17,054
in a special kind of dynamic

434
00:30:17,202 --> 00:30:21,702
compiler or compiler that helps to produce native

435
00:30:21,766 --> 00:30:25,930
images. The interface is called JVMCi

436
00:30:27,150 --> 00:30:30,874
that's an interface for Java

437
00:30:31,002 --> 00:30:35,006
based compilers. And there is a project

438
00:30:35,108 --> 00:30:38,346
called GraalVM where Graal compiler

439
00:30:38,378 --> 00:30:41,950
is being developed and it's not stopped.

440
00:30:43,110 --> 00:30:46,820
So these changes, they just mean that

441
00:30:47,910 --> 00:30:51,874
source code of Graal compiler is

442
00:30:51,912 --> 00:30:55,922
not anymore dropped from GraalVM repository

443
00:30:55,986 --> 00:30:59,510
into OpenJDK repository and no

444
00:30:59,580 --> 00:31:03,142
developer resources are spent for doing

445
00:31:03,196 --> 00:31:08,022
that. But instead you

446
00:31:08,076 --> 00:31:11,766
can use GraalVM based technologies

447
00:31:11,878 --> 00:31:15,386
and we will see how to do

448
00:31:15,408 --> 00:31:15,980
that.

449
00:31:18,830 --> 00:31:22,542
If I talk about GraalVM builds from

450
00:31:22,596 --> 00:31:25,840
Oracle, there are two big options.

451
00:31:27,650 --> 00:31:31,598
One option is Graal VM Community

452
00:31:31,684 --> 00:31:35,618
edition builds which are provided the

453
00:31:35,704 --> 00:31:38,946
basic free license. And there is

454
00:31:38,968 --> 00:31:42,354
the GraalVM Enterprise Edition which

455
00:31:42,392 --> 00:31:46,710
is provided using Oracle OTN

456
00:31:47,290 --> 00:31:51,190
and same licensing policies

457
00:31:53,050 --> 00:31:54,520
like Java C.

458
00:31:58,910 --> 00:32:02,780
We decided to give

459
00:32:03,150 --> 00:32:06,330
the community something that

460
00:32:06,400 --> 00:32:10,122
will cover the task of native

461
00:32:10,186 --> 00:32:11,550
image generation,

462
00:32:13,730 --> 00:32:15,790
particularly for containers.

463
00:32:18,290 --> 00:32:22,578
This is a subset of what GraalVM world

464
00:32:22,664 --> 00:32:26,740
gives you because there is an option

465
00:32:27,830 --> 00:32:31,970
to have a dynamic Grail compiler for mixing languages

466
00:32:32,550 --> 00:32:36,470
and we focused on native images

467
00:32:37,370 --> 00:32:41,238
and we think that

468
00:32:41,324 --> 00:32:45,318
support for few extra

469
00:32:45,404 --> 00:32:49,654
platforms is important, like Alpine muscle

470
00:32:49,782 --> 00:32:55,670
here, arm 64 languages

471
00:32:55,750 --> 00:32:59,114
support for native images. It's still interesting and

472
00:32:59,152 --> 00:33:02,682
we still include that into

473
00:33:02,816 --> 00:33:04,830
Liberca native image jit.

474
00:33:06,130 --> 00:33:09,840
And also in the heart of this tool

475
00:33:10,530 --> 00:33:14,754
of this kit there

476
00:33:14,792 --> 00:33:18,450
is Liberica, the LTS version of

477
00:33:18,520 --> 00:33:19,490
JDK.

478
00:33:22,070 --> 00:33:25,800
To support Alpine we had to support both

479
00:33:27,210 --> 00:33:31,254
GraalVM native image tool as

480
00:33:31,292 --> 00:33:34,950
a compiler to work in such environment,

481
00:33:35,610 --> 00:33:41,542
and also support for generated

482
00:33:41,606 --> 00:33:46,010
native images to work again in the alpine environment.

483
00:33:47,950 --> 00:33:50,400
There are multiple aspects of it,

484
00:33:51,490 --> 00:33:55,310
but in the end all

485
00:33:55,460 --> 00:33:59,054
this has been implemented and you can

486
00:33:59,092 --> 00:34:02,786
download the binaries just like you

487
00:34:02,808 --> 00:34:06,610
can download the JDK binaries.

488
00:34:07,350 --> 00:34:09,940
And well, how to use that,

489
00:34:11,030 --> 00:34:12,740
there are a few good ways.

490
00:34:14,330 --> 00:34:16,840
Let's again look at the example.

491
00:34:17,850 --> 00:34:21,062
We can go and create sample microservices even

492
00:34:21,116 --> 00:34:21,910
smaller.

493
00:34:23,930 --> 00:34:27,354
Its fat jar will be

494
00:34:27,392 --> 00:34:31,162
as small as 17 megabytes. Fin jar again

495
00:34:31,296 --> 00:34:37,866
will be much much smaller, kind of like 32.

496
00:34:37,888 --> 00:34:41,790
We can switch to native image

497
00:34:42,770 --> 00:34:46,554
generation. What are good roots

498
00:34:46,602 --> 00:34:50,510
here. And what will be the difference

499
00:34:50,660 --> 00:34:54,414
between classical JVMCi container produced from such

500
00:34:54,452 --> 00:34:57,934
a services, such a service and native

501
00:34:57,982 --> 00:35:01,922
image containers? Well first of all

502
00:35:02,056 --> 00:35:05,510
you can go to spring initializer and then you create

503
00:35:05,580 --> 00:35:09,590
such a microservice. You can now check

504
00:35:09,740 --> 00:35:15,858
spring native support and you will have prepared

505
00:35:15,954 --> 00:35:19,754
configuration for maven or gradle that

506
00:35:19,792 --> 00:35:23,180
you can just use out of the box. But what's inside?

507
00:35:24,590 --> 00:35:28,154
Well of course you will

508
00:35:28,192 --> 00:35:32,270
need special plugin

509
00:35:34,690 --> 00:35:40,158
for your

510
00:35:40,244 --> 00:35:44,194
for Springboot and you

511
00:35:44,232 --> 00:35:48,190
will need that plugin to generate

512
00:35:48,350 --> 00:35:53,102
some things ahead of time that's not the static compilation

513
00:35:53,246 --> 00:35:56,742
into machine code itself. This is

514
00:35:56,796 --> 00:36:00,454
generation of some Java code which is

515
00:36:00,492 --> 00:36:04,738
necessary to get rid of some dynamic behavior

516
00:36:04,914 --> 00:36:08,774
which is too complex for a static

517
00:36:08,902 --> 00:36:12,540
compiler that will produce the machine code.

518
00:36:14,590 --> 00:36:18,470
And also you will need spring native.

519
00:36:18,630 --> 00:36:22,814
You will get spring native plugin of some

520
00:36:22,852 --> 00:36:27,854
version. Currently the

521
00:36:27,972 --> 00:36:34,690
support of newer

522
00:36:35,910 --> 00:36:41,300
version was announced and

523
00:36:44,650 --> 00:36:48,630
you will need to include GraalVM

524
00:36:49,050 --> 00:36:53,350
plugin in some cases.

525
00:36:54,410 --> 00:36:57,770
In basic case JIT is used

526
00:36:57,840 --> 00:37:00,730
under the hood by spring native,

527
00:37:01,150 --> 00:37:04,586
but you may want to take more control

528
00:37:04,768 --> 00:37:07,290
and we'll look at the examples.

529
00:37:09,650 --> 00:37:13,406
So here it is activated only

530
00:37:13,508 --> 00:37:15,310
for a special profile.

531
00:37:18,290 --> 00:37:23,134
This special case we invoke

532
00:37:23,182 --> 00:37:26,418
this profile and we say okay,

533
00:37:26,504 --> 00:37:30,722
let's create a native image and the

534
00:37:30,776 --> 00:37:34,100
specific version of

535
00:37:34,570 --> 00:37:39,446
native image tool will be used in this case if

536
00:37:39,468 --> 00:37:41,990
you don't want this complexity,

537
00:37:43,850 --> 00:37:47,420
but we in this case agree

538
00:37:48,030 --> 00:37:51,846
to get silent

539
00:37:51,958 --> 00:37:54,410
upgrades of the tooling,

540
00:37:57,630 --> 00:38:01,662
or at least we get the version of

541
00:38:01,716 --> 00:38:05,166
native image tool bound to the

542
00:38:05,188 --> 00:38:08,030
version of spring native tooling.

543
00:38:09,170 --> 00:38:12,914
We can invoke again same standard out

544
00:38:12,952 --> 00:38:16,446
of the box command line provided by spring

545
00:38:16,478 --> 00:38:17,250
plugins,

546
00:38:19,830 --> 00:38:23,826
but in the native image mode. And in

547
00:38:23,848 --> 00:38:27,906
this case we'll get a container built by Liberica

548
00:38:27,938 --> 00:38:32,390
native imagekit core of some version.

549
00:38:36,750 --> 00:38:41,274
Or again we may want more

550
00:38:41,312 --> 00:38:45,622
control and we may want the most effective

551
00:38:45,686 --> 00:38:49,610
alpine Linux container for this environment.

552
00:38:50,930 --> 00:38:54,858
They can manually recreate

553
00:38:55,034 --> 00:38:58,560
the build

554
00:39:00,450 --> 00:39:05,634
all necessary dependencies and

555
00:39:05,672 --> 00:39:11,934
then we invoke standard building

556
00:39:11,982 --> 00:39:12,850
commands,

557
00:39:16,330 --> 00:39:22,738
sorry, standard native

558
00:39:22,914 --> 00:39:28,162
image JIT commands to install native

559
00:39:28,226 --> 00:39:31,526
image support. If it's not Liberica native image

560
00:39:31,558 --> 00:39:35,702
JIT core, which is basically targeted

561
00:39:35,766 --> 00:39:39,554
only to creation

562
00:39:39,622 --> 00:39:44,640
of native images from Java programs and

563
00:39:45,410 --> 00:39:48,990
here we can compile

564
00:39:50,050 --> 00:39:54,706
the service itself with

565
00:39:54,728 --> 00:39:58,274
a simple comment and finally we

566
00:39:58,312 --> 00:40:01,534
get the resulting native image.

567
00:40:01,582 --> 00:40:06,070
In all that cases it will be smaller than 60 megabytes,

568
00:40:08,410 --> 00:40:12,214
which is really cool because we

569
00:40:12,252 --> 00:40:17,580
have for example in the case of alpine Linux only

570
00:40:19,150 --> 00:40:22,602
5.6 megabyte base image. Then we have

571
00:40:22,656 --> 00:40:26,502
that dependencies for running the native

572
00:40:26,566 --> 00:40:30,822
images. It is extra seven megabytes

573
00:40:30,966 --> 00:40:35,102
and then we have that 57

574
00:40:35,156 --> 00:40:38,510
megabytes on top of it and that

575
00:40:38,660 --> 00:40:42,058
resulting container will start

576
00:40:42,164 --> 00:40:45,460
in one 20th of a second,

577
00:40:47,030 --> 00:40:50,930
probably faster on server hardware.

578
00:40:53,270 --> 00:40:57,000
And what is also sweet here,

579
00:40:57,530 --> 00:41:00,994
if we get back to the original footprint comparison,

580
00:41:01,122 --> 00:41:03,910
we can take pet clinic,

581
00:41:04,970 --> 00:41:10,202
start it, measure the same plot and

582
00:41:10,256 --> 00:41:13,382
we have even more memory

583
00:41:13,446 --> 00:41:17,450
saved. For the case of using native image,

584
00:41:20,850 --> 00:41:24,094
it is really easy to try.

585
00:41:24,292 --> 00:41:28,250
Just take spring native

586
00:41:28,330 --> 00:41:32,030
and use standard build packs or

587
00:41:32,100 --> 00:41:35,626
go and download the Berry Connective

588
00:41:35,658 --> 00:41:40,800
image kit and try your

589
00:41:41,730 --> 00:41:46,166
production services and thank

590
00:41:46,188 --> 00:41:46,850
you for your attention.

