{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/ad738c45-8ee9-491e-bf15-91e89075807f", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["abhishek doshi", "abisheks", "answers", "app", "blah", "bloc", "bloc flutter", "blocks", "but", "can", "conf fourty two", "from", "has", "lets", "manage blocks of your app", "questions", "senior flutter engineer", "somnio software", "techniques", "these", "widgets"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "id": "c45004c9-cd10-4e8e-badb-364673387e65", "status": "completed", "error": null, "text": "Hello friends. I hope you are doing well and you're healthy and you're keeping safety. So I'm Abisheks Doshi and today's talk is on block or you can manage blocks of your app app with blocks. So first of all, who am I exactly? I am a Google developer expert for Dart and Flutter. I am also a Google mentor. So basically I mentor individuals as well as startups to migrate to flutter or learn flutter. I am also Flutter vulsar organizer, co organizer of Flutter India and I have been working in Flutter since almost past three years now and professionally I am a senior flutter engineer at Somnia Software. I've been writing event tech articles on Flutter since past six to one year, six months to one year now. So yeah, you can say that I'm suitable for taking this session. So what is flutter exactly? And why is it trending so much? So first of all, Flutter was released in around 2018 and it is developed by Google and it is a UI toolkit that supports multiple platforms like Android, iOS, Web, macOS, Windows, Fuchsia OS, Linux embedded systems, et cetera. And it is trending because one of the reason is it is open source and it has a large community support and it is easy to use. So coming to today's topic, what are the points for discussion then? So first we would see what is state, what is state management, why state management is needed, and if we need state management, then what is block exactly? And some terminologies related to block. And then if time permits we would be doing live coding or I would show you the code. So first of all, what is state? So in flutter, everything is widget. Widget, you can say is a smallest form of UI that you can show on the screen. If you are from web development background, you can compare widget as a tag. So in web development we have button as a tag. In flutter we have different kinds of buttons, has a widgets, raised button, elevated button, text button, et cetera. So in the same way, every widget would be having a state. Or you can say every widget has properties, or the properties of a widget considers to be a state. Now let's suppose you have a text field. So the text that you enter becomes the state of that particular text field. So every properties related to that widget becomes the state. And the state can be independent. The state can be dependent on one another. It is also possible to have a single state in the entire application. It is also possible to have a single state in a one particular widget or one particular file. Based on how you manage your state or based on how you lay out your UI. Also, it is possible to manipulate the state throughout the lifecycle. So yeah, when you're handling with state or when you are working with state, you should keep in mind that there are chances that you might face issues or your app can crash if the state is not managed properly. So what is the role of state then and how is it useful? So basically there are three points that we can consider for the state. That is, information about widget can rebuild UI whenever we need and gives control over the entire lifecycle of the widget. Now going deeper with the state object, we can access the information about that particular widget, or we can even access the information about the widgets, about the parent widget. So yeah, state is the information that can be read synchronously when the widget is built, it holds the properties of the widget. So as I said, state can be considered as the properties of the widget and we can access that properties with the state. So second point is it can rebuild UI whenever we need. So basically state object is responsible for rebuilding your UI. That's the reason we call set state. We have a set state method, we have a set state method that updates your UI or recalls or rebuilds your UI. And the third point is gives control over lifecycle. State can change during the lifetime of the widget. If you don't utilize it properly, you can have adverse effect on your app. Basically your app can crash, you can have memory, lets, et cetera, et cetera. So now what is state management then? Basically has the name suggests managing the state properly so that you don't face any issues in your app and you can rebuild your UI whenever you need. Then why state management? Why is it needed? Or why is it a really hot topic in flutter? So if data changes or new data is being added, then and only then the request to the server will be sent. So for example, let's suppose you want to update your UI when your API call is successful. So in this case data management will be important because let's say you call the API, it takes time to get the data and then you want to update the UI. Or let's say when the app is being hit, you want to show a loader so that the user gets to know that the API is being hit, the data is being fetched, and then you can update the UI. So in this case, state management is important. State management helps to centralize and make the maintenance of code very easy. Also improves the quality of code by reducing the code size and making it more readable as well. Let's take an example. Let's suppose that you have an application where there are only two screens, page one and page two. Now you want to pass data from page one to page two. It becomes very easy, right? You can pass it when you navigate to page two. But what if you have a screen? What if you have an app? These, there are five pages and you want to pass data from page one to page five. So you can't pass the data from page one to page two to three to four to five, right? You have to pass data from page one to directly to page five. So in these case, state management helps. State management basically will help you to allow excess of data wherever you want. So what is block then? Basically, state management can be implemented using many techniques. One is block provider Riverpod Redux Rxdart. Many such packages are available for implementing state management, and one of that is block. Basically block stands for business logic components. Block basically uses the concept of inherited widget. Not only block, but any state management package that you check will use inherited widget concept. We can implement blocks using stream and sync, but we already have a package called flutter, underscore block, which is a wrapper of stream and sync. So there are a few terminologies related to block, which is event, state block provider, block builder, blocks listener and block consumer. We'd go through them one by one. So first is event. Now what exactly do you mean by event? Event you can say is a class or a trigger that you pass through the block and based on that block manages the data. So let's suppose you are having a login functionality, Google sign in, let's say. So what your app would be doing is on the UI part, it adds an event or sends an event to the block. Let's suppose the name of the event is Google sign. In event it sends the event to the blocks, blocks matches that event or takes that event. And from that basically you can also pass parameters like any user id, email id, et cetera, et cetera to the event. So block would take that parameters, it would process that parameters, or it would process based on that data, maybe an API call or anything that you want. And once the process has been successfully completed, it would send a successful state to the UI, back to the UI. If it fails, it will send a failure state. So to summarize, we can say that event is something that you send from UI to block, and state is something that you send from block to UI. Now what is block provider. Then basically blocks provider is a widget that provides the instance of your blocks to the widget tree. Now the normal practice is to wrap the material app that is the root of our widget root of our application with the block provider and provide the blocks to the entire widgets tree. But this would create a single state for the entire widget tree. Now if you want to have multiple instances of the same block, it would be good to wrap the page root root of the page with block provider. Next is block builder. Basically block builder is responsible for rebuilding your UI. Block builder is a widget that matches state and rebuilds these UI based on the state that is available from the block. Block listener is something same to block builder, but it doesn't rebuild your UI, it just listens to states and performs some action. So let's suppose you want to navigate to a page. Navigate to home page. When Google sign in is successful then you would use block listener because you're not rebuilding your UI, you are navigating to a different page. But let's suppose you want to rebuild your UI. You want to show something different on your UI based on success rate of the Google sign in, then you would be using block builder. Now what is block consumer then? Basically block consumer is block builder plus blocks listener. Block builder, the combination of block builder and block listener. Basically when you need to use both, when you want to process some data on the UI part as well as rebuild your UI, it is preferable to use block consumer. So I hope these terminologies are clear because these are the base of blocks, you can say. So yeah, enough of talk. Now let's check some work these. So basically whenever we create an application, our first, or you can say our basic app that we have is counter application. So what we are doing right now is to have the counter application to update the counter application into block. So I hope the vs code is visible and let me zoom a bit. Yeah, okay, so there is one class called main dart which just provides my home page. So you can see here we have the block provider and I have provided the counter blocks to my home page. Now what is inside the counterblock? So what counterblock does is it maps the event to state. This is the older version of block. The newer version has very simple code. But yeah, basically the concept remains same. It maps the event to state. So if event is counterevent increment, then yield the state with an incremented value. So what is the event then? Basically it's just an NM where we have added an increment part. Now in the home part you can see I have created a variable for counter blocks and inside the build method I have initialized it. This can be done even in your init state as well. Basically we are providing the instance of blocks from the parent to this variable. Now the code is pretty simple. You can see just 43 lines of code with all the formatting and stuff. So the scaffold and everything remains same. What I have done here is in the body part I have added a block builder and in that return a text widget which displays the state. Now the state is just an integer value over here, but we can have multiple states based on our use case. Now when the user clicks on the button, the floating action button, a counterblock event is being added over here. So you can see in the entire application set, state is not used, which means that I am not rebuilding the UI using setstate. So I hope the code looks good and it's pretty simple. I guess the code is very simple for the counter blocks. But yeah, when your application goes in bigger size it is possible that you would get confused with all the blocks, elements, event, state, et cetera, et cetera. Basically that was it. But the work that we have, you can see you saw that the code was very less to just update these counter application with the block part. So yeah, if you have any questions, feel free to ask. I hope you learned something new and feel free to connect with me on Instagram, Twitter, LinkedIn, GitHub, Medium, et cetera. And the username remains same, that is Abisheks Doshi 26. Yeah, you can read my articles on medium and these also username remains same Abisheks Doshi 26 so you can go abhishek Doshi 26 medium.com for my medium articles, I guess. Thank you so much for joining today's session and I hope you learned something and I hope that you stay safe and maybe migrate to flutter as well. Thank you so much.", "words": [], "utterances": null, "confidence": 0.948556145648315, "audio_duration": 961.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Abisheks Doshi is a Google developer expert for Dart and Flutter. Today's talk is on block or you can manage blocks of your app app with blocks.\n- Flutter is a UI toolkit that supports multiple platforms like Android, iOS, Web, macOS, Windows, Fuchsia OS, Linux embedded systems. State management gives control over the entire lifecycle of the widget. If you don't utilize it properly, you can have adverse effect on your app.\n- Block stands for business logic components. Any state management package that you check will use inherited widget concept. Event, state block provider, block builder, blocks listener and block consumer. When you need to process data on the UI part as well as rebuild your UI, it is preferable to use Block consumer.\n- So basically whenever we create an application, our first. app that we have is counter application. What counterblock does is it maps the event to state. When your application goes in bigger size it is possible that you would get confused with all the blocks, elements, event, state. I hope you learned something and maybe migrate to flutter as well.", "auto_highlights_result": {"status": "success", "results": [{"count": 1, "rank": 0.11, "text": "state block provider", "timestamps": [{"start": 490592, "end": 492102}]}, {"count": 12, "rank": 0.1, "text": "state management", "timestamps": [{"start": 120248, "end": 121410}, {"start": 122680, "end": 123534}, {"start": 126312, "end": 126938}, {"start": 325128, "end": 325954}, {"start": 340412, "end": 341270}, {"start": 386668, "end": 387394}, {"start": 388108, "end": 388914}, {"start": 432508, "end": 433394}, {"start": 434034, "end": 434914}, {"start": 445904, "end": 446694}, {"start": 458314, "end": 459194}, {"start": 469112, "end": 469854}]}, {"count": 10, "rank": 0.09, "text": "block builder", "timestamps": [{"start": 492166, "end": 492934}, {"start": 616712, "end": 617966}, {"start": 618808, "end": 619566}, {"start": 622542, "end": 623358}, {"start": 637068, "end": 638066}, {"start": 665080, "end": 666238}, {"start": 670216, "end": 671118}, {"start": 673070, "end": 674110}, {"start": 675048, "end": 675518}, {"start": 833598, "end": 834760}]}, {"count": 1, "rank": 0.09, "text": "multiple states", "timestamps": [{"start": 843538, "end": 844396}]}, {"count": 6, "rank": 0.09, "text": "block provider", "timestamps": [{"start": 450436, "end": 451962}, {"start": 491104, "end": 492102}, {"start": 584012, "end": 584754}, {"start": 599264, "end": 600278}, {"start": 614792, "end": 615950}, {"start": 750898, "end": 752164}]}, {"count": 2, "rank": 0.09, "text": "state object", "timestamps": [{"start": 251188, "end": 252366}, {"start": 283164, "end": 284006}]}, {"count": 3, "rank": 0.09, "text": "block listener", "timestamps": [{"start": 633290, "end": 634226}, {"start": 650112, "end": 650806}, {"start": 675688, "end": 676334}]}, {"count": 4, "rank": 0.08, "text": "block consumer", "timestamps": [{"start": 493824, "end": 494806}, {"start": 667128, "end": 667854}, {"start": 668968, "end": 669854}, {"start": 686156, "end": 687510}]}, {"count": 3, "rank": 0.08, "text": "counter blocks", "timestamps": [{"start": 753878, "end": 754604}, {"start": 798690, "end": 799900}, {"start": 876618, "end": 877356}]}, {"count": 1, "rank": 0.08, "text": "block provider Riverpod Redux Rxdart", "timestamps": [{"start": 450436, "end": 454826}]}, {"count": 1, "rank": 0.07, "text": "block builder and block listener", "timestamps": [{"start": 675048, "end": 676334}]}, {"count": 2, "rank": 0.07, "text": "inherited widget", "timestamps": [{"start": 466168, "end": 467118}, {"start": 472280, "end": 473342}]}, {"count": 1, "rank": 0.06, "text": "inherited widget concept", "timestamps": [{"start": 472280, "end": 474318}]}, {"count": 1, "rank": 0.06, "text": "any state management package", "timestamps": [{"start": 468840, "end": 470254}]}, {"count": 20, "rank": 0.06, "text": "event", "timestamps": [{"start": 64954, "end": 65226}, {"start": 490016, "end": 490474}, {"start": 499088, "end": 499878}, {"start": 502052, "end": 502640}, {"start": 503010, "end": 503470}, {"start": 526488, "end": 526818}, {"start": 527752, "end": 528014}, {"start": 530748, "end": 530934}, {"start": 531932, "end": 532566}, {"start": 533548, "end": 533782}, {"start": 536108, "end": 536390}, {"start": 537292, "end": 537880}, {"start": 547088, "end": 547660}, {"start": 575512, "end": 575938}, {"start": 764758, "end": 764992}, {"start": 774298, "end": 774484}, {"start": 776330, "end": 776660}, {"start": 787678, "end": 787912}, {"start": 852840, "end": 853192}, {"start": 885300, "end": 885640}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}