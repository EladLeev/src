1
00:00:19,690 --> 00:00:23,310
In this session we are going to learn about test driven development using

2
00:00:23,380 --> 00:00:27,126
Golang. We will be looking some best practices of it and how we

3
00:00:27,148 --> 00:00:31,014
can start working on TDD on our company's project. Or either we're just

4
00:00:31,052 --> 00:00:33,958
starting to practicing it, practices it out.

5
00:00:34,124 --> 00:00:38,014
All right, so who am I? I'm Mohammad Quanit.

6
00:00:38,082 --> 00:00:41,434
I'm working as product engineering manager manager at Timegram IO, which is

7
00:00:41,472 --> 00:00:43,530
basically a SaaS based startup,

8
00:00:44,110 --> 00:00:47,802
basically calculates or manage

9
00:00:47,856 --> 00:00:51,018
the time for freelancer agencies. Also,

10
00:00:51,104 --> 00:00:54,574
I also am AWS community builder as well, along with

11
00:00:54,612 --> 00:00:58,638
I do write technical content on dev two which you may probably have heard.

12
00:00:58,724 --> 00:01:01,600
And I also do some public speaking as well.

13
00:01:01,970 --> 00:01:05,380
And these are my hobbies that I provided, I mentioned.

14
00:01:06,390 --> 00:01:09,940
Okay, so let's see our agenda for today's talk.

15
00:01:10,310 --> 00:01:13,982
First we will be looking test driven development. What actually test driven development

16
00:01:14,046 --> 00:01:17,998
is, what should we do, how should we care about and

17
00:01:18,104 --> 00:01:21,206
what is basically the motivation for it. And then we

18
00:01:21,228 --> 00:01:24,774
are looking some ways to test in Golang, to write

19
00:01:24,812 --> 00:01:28,234
testing in Golang. There are some approaches that I've already mentioned in this

20
00:01:28,272 --> 00:01:32,170
list. Go testing package. We'll be discussing about HTTP server

21
00:01:32,510 --> 00:01:35,926
rest API testing. We'll be looking at table driven testing,

22
00:01:35,958 --> 00:01:39,274
which is basically an approach for writing test

23
00:01:39,312 --> 00:01:42,666
cases in Golang. We will be looking some open source testing

24
00:01:42,698 --> 00:01:46,014
framework that you can use, and at the end of our talk

25
00:01:46,052 --> 00:01:48,750
we will be looking some TDD best practices.

26
00:01:49,250 --> 00:01:51,920
And after that we will be uploading our talk.

27
00:01:52,610 --> 00:01:56,194
So TDD, what is TDD? You probably have heard

28
00:01:56,232 --> 00:01:59,426
of TDD as a most hyped term. So TDD is

29
00:01:59,448 --> 00:02:03,150
nothing but just a software development process that involves repeatedly

30
00:02:03,230 --> 00:02:06,710
writing test cases first and then write actual code.

31
00:02:06,860 --> 00:02:11,154
So basically what happens that developers, traditionally developers

32
00:02:11,282 --> 00:02:14,242
do whenever they write a software,

33
00:02:14,306 --> 00:02:18,120
whenever they write a feature in a software, they probably write some code

34
00:02:18,510 --> 00:02:22,742
first, and then after that they actually start implementing test cases.

35
00:02:22,886 --> 00:02:26,314
But there's a high chance that developers or engineers can miss

36
00:02:26,352 --> 00:02:30,300
some of the cases that actually if

37
00:02:30,850 --> 00:02:34,094
that feature contains. Right. So for that issue,

38
00:02:34,292 --> 00:02:37,594
for that problem, test driven development is an approach

39
00:02:37,642 --> 00:02:41,150
that introduced by some of the early

40
00:02:41,300 --> 00:02:46,114
engineers in early 90s that why

41
00:02:46,152 --> 00:02:49,470
you shouldn't write test cases before actual development.

42
00:02:49,630 --> 00:02:53,374
So this is what best driven development is. It actually forces

43
00:02:53,422 --> 00:02:57,106
the developers in terms of implementing implementers

44
00:02:57,138 --> 00:03:00,754
or users. So basically when developers are writing test cases

45
00:03:00,802 --> 00:03:03,542
before writing actual production code,

46
00:03:03,676 --> 00:03:07,400
they know that, okay, so this is a feature we need to cover

47
00:03:07,950 --> 00:03:11,210
this amount of cases.

48
00:03:12,030 --> 00:03:16,106
And then if all our cases are covered, then we

49
00:03:16,128 --> 00:03:19,494
can start writing our actual code. So by writing

50
00:03:19,542 --> 00:03:22,670
test cases first, we developers can

51
00:03:22,820 --> 00:03:27,054
catch errors early in the development process and ensure that

52
00:03:27,252 --> 00:03:30,926
our code is easy to test, maintainable and

53
00:03:31,108 --> 00:03:34,910
refactorable. So what does mean by that? Okay, so if developers

54
00:03:34,990 --> 00:03:39,346
are required to write a feature for

55
00:03:39,368 --> 00:03:42,900
their application, what they can do is they can first

56
00:03:43,590 --> 00:03:47,174
assess all the test cases that could cover

57
00:03:47,212 --> 00:03:50,790
the actual features. Then they can start writing the test cases.

58
00:03:52,330 --> 00:03:56,326
After writing test cases and

59
00:03:56,348 --> 00:03:59,554
after their production code, writing production code, they can catch

60
00:03:59,602 --> 00:04:03,526
errors early in the development process. If somehow things are breaking

61
00:04:03,558 --> 00:04:07,290
in production production code, what they can do is they can actually check

62
00:04:07,360 --> 00:04:11,226
in test cases like what they did miss or what

63
00:04:11,408 --> 00:04:15,326
they have done wrong or what could they have done wrong? Right, what could

64
00:04:15,348 --> 00:04:19,454
they have done wrong? So that's how they can ensure our test case are

65
00:04:19,492 --> 00:04:23,226
easy to maintain. And after that, when they maintain,

66
00:04:23,338 --> 00:04:26,746
it's easy to refactor as well. Best driven development

67
00:04:26,778 --> 00:04:30,254
approach also helps engineer to write better code and reduce time on debugging.

68
00:04:30,302 --> 00:04:34,046
As I said about if developers are able to catch errors

69
00:04:34,078 --> 00:04:37,160
early on development time on actual production code,

70
00:04:38,250 --> 00:04:41,542
they are able to reduce the time on debugging because they knew that

71
00:04:41,596 --> 00:04:45,046
they actually wrote best cases first and they

72
00:04:45,228 --> 00:04:48,746
knew that where the error could occur or where the issue could

73
00:04:48,768 --> 00:04:52,390
happen. So it eventually

74
00:04:52,550 --> 00:04:56,106
reduces time on debugging part. And this can

75
00:04:56,128 --> 00:05:01,146
lead to more predictable and reliable software as they

76
00:05:01,168 --> 00:05:04,430
are already reducing the time or reduce the time on debugging.

77
00:05:05,010 --> 00:05:08,346
And the last part is that TDD is not just part of merely testing

78
00:05:08,378 --> 00:05:12,640
mechanism. It requires a lot of practice, to be honest,

79
00:05:13,010 --> 00:05:16,630
to implement in real world project, because it's

80
00:05:16,650 --> 00:05:19,954
not just like that. You start writing test cases before, and then

81
00:05:19,992 --> 00:05:23,394
after you write production board, you need to be mentally prepared. That,

82
00:05:23,432 --> 00:05:27,486
okay, if I need to write this feature, what are the test cases

83
00:05:27,598 --> 00:05:31,554
actually covered? So it requires a lot of analysis and assessment

84
00:05:31,682 --> 00:05:35,974
of our feature that we are supposed to deliver and then we

85
00:05:36,172 --> 00:05:39,930
have to discuss with our leads that, okay, so what are the things that

86
00:05:40,000 --> 00:05:43,674
this feature can cover or should not

87
00:05:43,712 --> 00:05:48,282
cover? And then according to this, we need to write

88
00:05:48,336 --> 00:05:51,770
cases according to that. So it's basically a like mental model.

89
00:05:51,840 --> 00:05:55,194
If you go along with at first it will be overwhelming,

90
00:05:55,322 --> 00:05:59,518
but if you are doing practice with your side projects or any

91
00:05:59,684 --> 00:06:03,466
small scale projects, you will be good to go in TDD

92
00:06:03,498 --> 00:06:07,330
first because this is a mental approach for writing proper

93
00:06:07,400 --> 00:06:11,410
software. Okay, so TDD has some stages.

94
00:06:12,150 --> 00:06:15,298
The first stage is when we write a test case, we need

95
00:06:15,304 --> 00:06:18,726
to write a test case. Okay, so after writing the test cases, we need

96
00:06:18,748 --> 00:06:22,806
to check the best case. Okay, so if

97
00:06:22,828 --> 00:06:26,326
we have some provider, if we have some road and test cases. Let's say

98
00:06:26,348 --> 00:06:30,854
if we are testing some function that actually testing

99
00:06:30,902 --> 00:06:34,170
or some function that takes numbers and incrementing them,

100
00:06:34,320 --> 00:06:38,646
we need to verify that, okay, if we are providing

101
00:06:38,838 --> 00:06:42,090
this length of numbers, then it could result in this.

102
00:06:42,240 --> 00:06:44,846
Okay, then we will see in live code as well.

103
00:06:45,028 --> 00:06:48,318
After writing our test cases, we then need to

104
00:06:48,324 --> 00:06:51,662
write our production code so that we can actually run

105
00:06:51,716 --> 00:06:55,218
our test by our production code.

106
00:06:55,384 --> 00:06:59,394
After writing our production code, we can run, or we do run all

107
00:06:59,432 --> 00:07:02,962
our tests, and if things are good, we actually can

108
00:07:03,016 --> 00:07:06,786
our code or refactoring our code that if this is

109
00:07:06,808 --> 00:07:07,570
required,

110
00:07:10,890 --> 00:07:15,160
both refactoring required in test cases code or the production code.

111
00:07:15,530 --> 00:07:19,294
All right, so this is stages of TDD.

112
00:07:19,362 --> 00:07:22,970
Okay? So why should we even care about TDD?

113
00:07:23,550 --> 00:07:27,254
Okay, so first point is it shortens the programming feedback loop.

114
00:07:27,302 --> 00:07:31,210
Okay, so what does it mean by that? It reduces

115
00:07:31,290 --> 00:07:34,814
the feedback time. Let's say

116
00:07:34,852 --> 00:07:38,746
if there is something, if there's a requirement

117
00:07:38,778 --> 00:07:42,506
of a feature and you have already wrote

118
00:07:42,538 --> 00:07:45,786
a test suit test case of that feature,

119
00:07:45,978 --> 00:07:49,378
after writing the production code, all things are

120
00:07:49,464 --> 00:07:53,438
valid work. But suddenly there's a change required

121
00:07:53,534 --> 00:07:57,586
in that feature. You can easily go through your

122
00:07:57,608 --> 00:08:01,286
test cases code and then you can actually update it because you

123
00:08:01,308 --> 00:08:04,534
don't need to write the whole test case again for that feature. You just

124
00:08:04,572 --> 00:08:07,458
need to maybe tweaks in your test cases code.

125
00:08:07,564 --> 00:08:11,210
So it actually shortens the feedback loop of your

126
00:08:11,280 --> 00:08:14,170
basic requirement for your test cases.

127
00:08:15,150 --> 00:08:18,394
As I said about it also encourages engineers to write

128
00:08:18,432 --> 00:08:20,860
modular, testable and maintainable code.

129
00:08:21,390 --> 00:08:25,166
Modular in the sense like, if I

130
00:08:25,188 --> 00:08:28,574
have an XYZ feature and it consists of some, let's say,

131
00:08:28,612 --> 00:08:32,782
five steps, we can write five separate test

132
00:08:32,836 --> 00:08:37,086
cases for that specific feature, which we can wrote

133
00:08:37,118 --> 00:08:40,546
it in a test suite, and we can test it

134
00:08:40,568 --> 00:08:44,770
via separately. So we can test those five steps separately

135
00:08:47,030 --> 00:08:49,630
in a modular manner. It is also testable.

136
00:08:49,710 --> 00:08:52,902
And if we write our test cases in a modular form,

137
00:08:52,956 --> 00:08:57,026
it is also maintainable as well. It also sketches errors

138
00:08:57,058 --> 00:09:00,522
early in the development. It also reduces debugging time as well,

139
00:09:00,656 --> 00:09:04,794
because if you know what you are doing actually, and if there's some

140
00:09:04,912 --> 00:09:08,474
issue happens in your production code, you know where

141
00:09:08,512 --> 00:09:12,206
to look at your test cases, and then you can fix out

142
00:09:12,228 --> 00:09:15,294
your actual time. It also reduces the cost of change.

143
00:09:15,412 --> 00:09:18,714
Let's say if there's

144
00:09:18,762 --> 00:09:21,834
something new requirement in that specific XYZ feature,

145
00:09:21,962 --> 00:09:25,634
you can also change the test cases along with that feature, and then

146
00:09:25,672 --> 00:09:31,762
you can just probably add some

147
00:09:31,816 --> 00:09:35,138
age cases that that feature actually was supposed to cover.

148
00:09:35,224 --> 00:09:39,134
Right. It also boosts confidence with sense of continuous

149
00:09:39,182 --> 00:09:42,838
reliability and success. So then as a developer, when you

150
00:09:42,844 --> 00:09:46,520
are writing test cases, you know that, all right,

151
00:09:46,890 --> 00:09:50,250
you have done your part in terms of testing

152
00:09:50,670 --> 00:09:54,682
and you have covered all of your cases. So it

153
00:09:54,736 --> 00:09:58,442
helps you with the sense of reliability. Okay, so I already

154
00:09:58,496 --> 00:10:01,726
wrote this test case or those test cases. Now I'm good

155
00:10:01,748 --> 00:10:05,678
to go with this feature. If there's any issue

156
00:10:05,764 --> 00:10:09,566
occur, I know where I have to look

157
00:10:09,588 --> 00:10:13,466
at on our testboard. And if you don't write test cases,

158
00:10:13,498 --> 00:10:17,570
how do youre know that your code is doing the right thing? Right. Test cases

159
00:10:17,910 --> 00:10:20,180
should be mandatory for every company.

160
00:10:20,950 --> 00:10:24,594
In our company we are also doing some test

161
00:10:24,632 --> 00:10:28,440
driven development. We just started in our company

162
00:10:30,730 --> 00:10:34,294
implementing TDD in our project and so far is going good

163
00:10:34,332 --> 00:10:38,410
now because we know that whatever feature we are supposed to ship,

164
00:10:40,510 --> 00:10:44,294
it will supposed to work, it will work. And if there's

165
00:10:44,342 --> 00:10:47,786
any issue comes up, we know where we have to make

166
00:10:47,808 --> 00:10:51,774
some changes in our test cases. So these are some motivations that

167
00:10:51,812 --> 00:10:55,710
we should consider when implementing TDD because

168
00:10:55,860 --> 00:10:58,942
it helps you to focus on your path that,

169
00:10:58,996 --> 00:11:02,874
okay, so you are doing TDD for this purpose and

170
00:11:03,012 --> 00:11:05,620
it will pay off in long term of time.

171
00:11:06,710 --> 00:11:10,734
Okay, so let's see some of the packages

172
00:11:10,782 --> 00:11:14,078
in our Golang. So the first and the foremost testing

173
00:11:14,174 --> 00:11:18,002
package actually provided by go. So whenever you install

174
00:11:18,136 --> 00:11:21,110
a Golang environment in your computers,

175
00:11:21,450 --> 00:11:25,080
you actually get testing package along with it.

176
00:11:25,530 --> 00:11:28,946
So go testing package is a built in by default testing

177
00:11:28,978 --> 00:11:32,534
package that comes with go environment. It is

178
00:11:32,572 --> 00:11:36,118
basically a companys line tool that automates the process of running tests.

179
00:11:36,214 --> 00:11:39,610
Okay so whenever you write test cases in Golang,

180
00:11:41,090 --> 00:11:45,454
you wrote test cases, right? And then how?

181
00:11:45,492 --> 00:11:48,874
Then you have to run those test cases, you provide a command

182
00:11:48,922 --> 00:11:52,874
called go test and then it will actually run

183
00:11:52,932 --> 00:11:56,386
all the tests which you

184
00:11:56,408 --> 00:12:00,066
have written code of. Right. So we will

185
00:12:00,088 --> 00:12:03,634
see it in an example as well. So test functions with a specific.

186
00:12:03,752 --> 00:12:07,400
So whenever we write test cases in go, we need to provide

187
00:12:08,010 --> 00:12:11,654
with a specific signature that must started with test.

188
00:12:11,852 --> 00:12:15,874
Okay, so whenever we test go, let's say we are writing

189
00:12:15,922 --> 00:12:19,754
a test for our feature xyz. So the

190
00:12:19,792 --> 00:12:22,966
file name should be our xyz underscore

191
00:12:22,998 --> 00:12:26,860
test which takes a pointer and then

192
00:12:27,310 --> 00:12:30,682
we then create a function on it and then it takes a pointer testing

193
00:12:30,746 --> 00:12:34,666
t which is basically a struct that actually provides

194
00:12:34,698 --> 00:12:38,522
some of the methods and methods and properties

195
00:12:38,666 --> 00:12:42,560
that we can use to write or assert test cases in a web

196
00:12:43,170 --> 00:12:46,274
testing package comes along with testing coverage tool

197
00:12:46,312 --> 00:12:50,562
as well. That can actually helps you to generate coverage report which shows

198
00:12:50,696 --> 00:12:54,340
how much of your code is covered by best. So let's say

199
00:12:56,150 --> 00:13:01,286
if you have write 20 test cases in your project and you

200
00:13:01,308 --> 00:13:05,094
want to see the coverage of your test cases, maybe it could be 80%

201
00:13:05,132 --> 00:13:09,834
or 90%. So you can use a go

202
00:13:09,872 --> 00:13:13,802
coverage tool which can actually generate and visualize the

203
00:13:13,936 --> 00:13:16,630
coverage of your actual test cases.

204
00:13:16,790 --> 00:13:20,266
It also supports benchmarking as well, which is used to

205
00:13:20,288 --> 00:13:23,386
measure the performance of your code. So let's say if you are writing an HTTP

206
00:13:23,418 --> 00:13:27,200
server and if you want to benchmark the latency of

207
00:13:28,930 --> 00:13:32,666
the rest and server or client to database connection,

208
00:13:32,778 --> 00:13:35,040
you can actually benchmark that as well.

209
00:13:36,690 --> 00:13:39,906
Not just rest APIs, but in fact whatever youre

210
00:13:39,928 --> 00:13:44,386
are writing. So you get a point. And it also comes with

211
00:13:44,568 --> 00:13:48,054
some of these flags as well as youre know, Golang supports some

212
00:13:48,092 --> 00:13:52,120
flags. We can provide some of the flags to see the

213
00:13:53,050 --> 00:13:56,630
more detailed logs in youre test cases.

214
00:13:57,210 --> 00:14:01,074
We mostly use Vlag which is basically purpose

215
00:14:01,122 --> 00:14:04,266
flag which is to show the

216
00:14:04,288 --> 00:14:07,798
more logs in our test cases or the behavior of our test cases.

217
00:14:07,894 --> 00:14:11,374
How youre test case going or what

218
00:14:11,412 --> 00:14:15,854
is the behavior of our test cases are Golang best

219
00:14:15,892 --> 00:14:20,062
package as I said, return on a file ending with underscore test go

220
00:14:20,196 --> 00:14:23,706
and every best function start with test keyword

221
00:14:23,818 --> 00:14:27,070
which takes a testing parameter testing t pointer

222
00:14:27,570 --> 00:14:31,540
that's basically a strut. So let's hear on a live code.

223
00:14:34,230 --> 00:14:38,510
Okay, so as you can see here, we have file

224
00:14:38,590 --> 00:14:42,358
called main co and we

225
00:14:42,364 --> 00:14:45,926
have written two functions on it. One is hello world and other is

226
00:14:45,948 --> 00:14:49,526
sum. So we will see the test cases of

227
00:14:49,708 --> 00:14:52,954
both of these two functions. Let's see on our main

228
00:14:52,992 --> 00:14:56,822
underscore test go which is our test case file. Test cases file.

229
00:14:56,966 --> 00:15:00,766
So let's see for test hello world test cases. So as

230
00:15:00,788 --> 00:15:05,038
you can see, as I said before, that whatever

231
00:15:05,124 --> 00:15:08,974
function we have to write for run

232
00:15:09,012 --> 00:15:12,880
our test cases, the convert for boolean testing is

233
00:15:13,730 --> 00:15:16,500
the function should start with that keyword test.

234
00:15:17,910 --> 00:15:21,554
We have two array, one is God and one is bond. And if for

235
00:15:21,592 --> 00:15:25,370
some reason God and bond is not equal, our test case will be failed.

236
00:15:25,470 --> 00:15:27,240
Same as for test sum function.

237
00:15:29,050 --> 00:15:33,094
As you can see as well that we are

238
00:15:33,292 --> 00:15:37,198
providing a parameter testing t which is basically a struct

239
00:15:37,394 --> 00:15:40,250
that provides some common methods,

240
00:15:40,670 --> 00:15:43,770
interfaces and properties.

241
00:15:45,150 --> 00:15:48,730
If you see this test function. So basically test function,

242
00:15:48,880 --> 00:15:52,978
the sum function is taken a number array

243
00:15:53,014 --> 00:15:56,318
of numbers and then it actually run loop on

244
00:15:56,324 --> 00:16:00,078
it. Runs loop for loop on it and returns the sum of all the

245
00:16:00,164 --> 00:16:04,014
numbers provided in our arrays. And we have written our test case for

246
00:16:04,052 --> 00:16:07,538
test sum as well. The d run function provide is basically

247
00:16:07,624 --> 00:16:12,946
supposed to run our test case in

248
00:16:12,968 --> 00:16:16,582
a separate thread. So if I write another t run

249
00:16:16,716 --> 00:16:20,038
in our test sum function, it works in a

250
00:16:20,044 --> 00:16:23,318
separate thread. So for now, for the

251
00:16:23,324 --> 00:16:26,406
sake of this example, I will just run a

252
00:16:26,428 --> 00:16:30,322
single t dot run function which basically best our sum of numbers in an array.

253
00:16:30,466 --> 00:16:34,522
So the numbers of array we have provided here is

254
00:16:34,576 --> 00:16:38,518
5.3 to one. That makes it basically the sum

255
00:16:38,694 --> 00:16:42,414
that 15 will be the sum of this function when

256
00:16:42,452 --> 00:16:46,218
the sum function returns and the run value contains

257
00:16:46,234 --> 00:16:49,360
16. So somehow it should fail, right?

258
00:16:50,130 --> 00:16:53,140
So let's check the,

259
00:16:53,910 --> 00:16:57,746
let's see how we

260
00:16:57,768 --> 00:17:00,450
can run our test kit.

261
00:17:02,550 --> 00:17:05,534
And if I provide b flag,

262
00:17:05,582 --> 00:17:08,754
it's basically providing me enough information

263
00:17:08,872 --> 00:17:12,502
to see the steps on our test case. If I

264
00:17:12,556 --> 00:17:15,960
click on it. And you can see here that,

265
00:17:16,410 --> 00:17:19,654
you can see here my best string function has been

266
00:17:19,692 --> 00:17:23,082
passed test case function because this headover function

267
00:17:23,136 --> 00:17:26,890
is written exactly the same string as I provided what variable.

268
00:17:28,430 --> 00:17:31,534
But my test some number of arrays to

269
00:17:31,572 --> 00:17:35,600
test some function has been failed because

270
00:17:36,050 --> 00:17:39,486
we are getting the result in

271
00:17:39,508 --> 00:17:42,766
this function is 15 and I am asserting with the value of

272
00:17:42,788 --> 00:17:47,298
16. So it actually failed because it

273
00:17:47,304 --> 00:17:51,106
is a t error function run which is basically a log app to

274
00:17:51,128 --> 00:17:54,770
print the logs that your actual test case had been failed.

275
00:17:55,190 --> 00:17:59,062
To see this on premise. So that's basically how

276
00:17:59,116 --> 00:18:03,490
the day you write test cases. HTTP testing

277
00:18:03,650 --> 00:18:07,154
testing can HTTP server in go involves some sending HTTP

278
00:18:07,202 --> 00:18:11,350
requests to the server and verifying the responses that it returns.

279
00:18:11,510 --> 00:18:16,266
So whenever we create an HTTP server in

280
00:18:16,288 --> 00:18:19,850
a form of best endpoint, what we need to check is that if

281
00:18:19,920 --> 00:18:23,374
our data is coming out in a proper manner, or the length of our data

282
00:18:23,412 --> 00:18:27,022
is coming correct from the server, or if we have to see,

283
00:18:27,076 --> 00:18:30,414
we have to check some status code. So there are some

284
00:18:30,452 --> 00:18:34,386
examples that we can test on HTTP server. So let's see on the

285
00:18:34,408 --> 00:18:37,886
code. Okay, so here you can see that we have a file

286
00:18:37,918 --> 00:18:41,780
called endpoints go, and I've already

287
00:18:42,470 --> 00:18:46,054
wrote two functions on it. One is get posts that is

288
00:18:46,092 --> 00:18:49,734
basically returning all the hundred posts that's coming from

289
00:18:49,772 --> 00:18:53,702
this API endpoint, this public API endpoint. And we

290
00:18:53,756 --> 00:18:57,346
have along with a header and some status

291
00:18:57,378 --> 00:19:01,242
code, okay, and we have another function called get single post

292
00:19:01,296 --> 00:19:04,602
which takes a parameter and then it will return a single

293
00:19:04,656 --> 00:19:07,434
post on the basis of an id.

294
00:19:07,632 --> 00:19:11,178
And if we see the main function which is HTTP example,

295
00:19:11,264 --> 00:19:15,642
which we are calling in our main go function, main function

296
00:19:15,696 --> 00:19:19,550
in go environment. So you can see here the endpoint HTTP example.

297
00:19:19,620 --> 00:19:23,166
So if we see this function implementation, we can see that we

298
00:19:23,188 --> 00:19:26,706
have provided a port. I'm using the mux new

299
00:19:26,728 --> 00:19:30,274
router to set up the routers, to set up the routes for

300
00:19:30,312 --> 00:19:33,854
my API. I have set it up two routes,

301
00:19:33,902 --> 00:19:38,150
one for posts, one for single post along with the id parameter.

302
00:19:39,690 --> 00:19:43,314
And I have started and I have did some logging

303
00:19:43,362 --> 00:19:47,174
to see the actual log for our

304
00:19:47,212 --> 00:19:50,646
server and I've already up and run the server. So if you can see

305
00:19:50,668 --> 00:19:55,222
this, I already started server on port 3001.

306
00:19:55,356 --> 00:19:58,982
So let's see the test cases of it. Okay,

307
00:19:59,036 --> 00:20:02,634
so I have created a function called test post endpoint,

308
00:20:02,682 --> 00:20:06,910
which is supposed to test the endpoint. Supposed to test the endpoint,

309
00:20:08,610 --> 00:20:11,930
as I said that it takes a testing parameter t testing

310
00:20:12,010 --> 00:20:16,114
t struct in a parameter. We are creating a new request which

311
00:20:16,232 --> 00:20:19,714
actually hit the request and post something.

312
00:20:19,832 --> 00:20:23,310
The new request basically runs with a context

313
00:20:23,390 --> 00:20:26,966
background and which helps us to

314
00:20:26,988 --> 00:20:30,514
generate a new request on the specific endpoint

315
00:20:30,642 --> 00:20:33,750
which is post in our case.

316
00:20:33,900 --> 00:20:36,898
And we are getting our get request.

317
00:20:37,074 --> 00:20:40,922
And if there is an error, we can see an error. So what actually

318
00:20:40,976 --> 00:20:44,486
we are doing here? So there's something called HTTP

319
00:20:44,518 --> 00:20:48,598
test, which is a package, comes with environment

320
00:20:48,774 --> 00:20:52,238
and we are using the new recorder function. So basically this function

321
00:20:52,324 --> 00:20:57,438
is an initialized response recorder. So it

322
00:20:57,444 --> 00:21:00,958
is the enhanced implementation of response writer. So if

323
00:21:00,964 --> 00:21:04,686
you have ever worked with best APIs in Go, if you have ever worked with

324
00:21:04,708 --> 00:21:08,302
best cases in go, so you have used response writers

325
00:21:08,366 --> 00:21:11,300
most every time, right? So this is something like,

326
00:21:12,150 --> 00:21:16,166
this is something on top of response writer, but it

327
00:21:16,188 --> 00:21:19,382
is basically a response recorder that helps us to record

328
00:21:19,436 --> 00:21:23,634
the response. We then create another variable

329
00:21:23,682 --> 00:21:27,126
called handler and we simply provide the handle function which

330
00:21:27,148 --> 00:21:31,114
is basically getting this get post. So get post basically the function that we

331
00:21:31,152 --> 00:21:34,294
have implemented for getting all the posts,

332
00:21:34,342 --> 00:21:37,930
right. So again we go to our best

333
00:21:38,000 --> 00:21:41,434
function. We are then serving our HTTP

334
00:21:41,482 --> 00:21:44,654
because we need to test our

335
00:21:44,692 --> 00:21:49,774
endpoint in such a way that it can actually run

336
00:21:49,812 --> 00:21:54,046
the endpoint and get the response from

337
00:21:54,068 --> 00:21:57,314
the actual API. And then we are Golang to look at the

338
00:21:57,432 --> 00:22:00,594
length of the response that we need to verify. Okay,

339
00:22:00,632 --> 00:22:03,682
so I then did all this stuff,

340
00:22:03,736 --> 00:22:08,594
then decoding and sharing stuff for converting

341
00:22:08,642 --> 00:22:12,162
data into struct. All right? And then we have created two variables,

342
00:22:12,226 --> 00:22:16,146
got expected length and want expected length. Okay, so this API

343
00:22:16,178 --> 00:22:20,074
that the post public API is supposed to return

344
00:22:20,272 --> 00:22:23,180
error object of 100 objects, right?

345
00:22:24,590 --> 00:22:27,194
So I want to verify that, okay,

346
00:22:27,392 --> 00:22:30,506
if my API is returning me the

347
00:22:30,528 --> 00:22:33,162
length of 100 objects in an array,

348
00:22:33,306 --> 00:22:37,230
and we are checking with God expected length, that what actually

349
00:22:37,380 --> 00:22:40,506
the length of the data is getting from the API endpoint,

350
00:22:40,698 --> 00:22:44,942
then simply we just did if condition and if somehow

351
00:22:45,006 --> 00:22:48,622
our length does not match, it will fail,

352
00:22:48,686 --> 00:22:52,194
right? So if I run

353
00:22:52,232 --> 00:22:55,970
the terminal here server

354
00:22:56,630 --> 00:23:00,494
and I run go run go

355
00:23:00,552 --> 00:23:03,766
best. So you

356
00:23:03,788 --> 00:23:07,426
can see that my best are passed because how it's

357
00:23:07,458 --> 00:23:10,666
passed because the length of the

358
00:23:10,688 --> 00:23:14,634
data which came from the API endpoint, the post API has 100

359
00:23:14,672 --> 00:23:18,060
items and I want to check it with 100 as well

360
00:23:20,530 --> 00:23:23,786
if I want to see the failed version

361
00:23:23,818 --> 00:23:27,454
of my test case. So if I provide 10 one and

362
00:23:27,572 --> 00:23:30,400
I do this,

363
00:23:31,650 --> 00:23:35,134
if I run again, vote sv youre see it must

364
00:23:35,172 --> 00:23:39,026
fail because unexpected length of data got 100 want xo one

365
00:23:39,128 --> 00:23:42,406
because I want the length of data to be 101

366
00:23:42,408 --> 00:23:45,610
and I am getting the data, the length of the data is 100.

367
00:23:45,700 --> 00:23:49,494
So that's how you can actually write HTTP and test

368
00:23:49,532 --> 00:23:53,462
cases. Another one like you can also check

369
00:23:53,516 --> 00:23:56,950
some status code as well if you want to see if this API,

370
00:23:58,730 --> 00:24:02,294
if this response of this API is getting 200, okay server,

371
00:24:02,342 --> 00:24:06,410
or if you are trying to check some other status as well,

372
00:24:06,480 --> 00:24:10,380
or if you are finding out that okay,

373
00:24:11,310 --> 00:24:14,606
if this API comes with some data that

374
00:24:14,628 --> 00:24:18,506
I am expecting with this specific field. So these are some of the examples

375
00:24:18,538 --> 00:24:22,058
that we can cover in HTTP. But for the sake

376
00:24:22,074 --> 00:24:25,554
of this session, I am just showing you this

377
00:24:25,672 --> 00:24:29,518
example for HTTP test. So the main purpose of this HTTPs

378
00:24:29,614 --> 00:24:32,654
basically we basically use the new recorder.

379
00:24:32,782 --> 00:24:36,054
So the new recorder is basically like we

380
00:24:36,092 --> 00:24:39,366
get all the properties and methods which comes in

381
00:24:39,388 --> 00:24:42,786
response writer when we create some API

382
00:24:42,898 --> 00:24:45,480
HTTP API. All right,

383
00:24:46,010 --> 00:24:49,734
so let's move on to our table

384
00:24:49,782 --> 00:24:53,926
driven testing. So table driven testing basically allows

385
00:24:53,958 --> 00:24:57,946
you to test your features or

386
00:24:57,968 --> 00:25:01,246
function with multiple inputs and expected outputs, right?

387
00:25:01,348 --> 00:25:04,910
So what basically means that if youre see this

388
00:25:04,980 --> 00:25:08,142
example, let me show you here,

389
00:25:08,196 --> 00:25:12,254
we only created got and want variable. If you remember our first test

390
00:25:12,292 --> 00:25:16,100
case, we only use got and want variable. But if we want to check

391
00:25:16,950 --> 00:25:20,526
multiple, but if we want to test our feature

392
00:25:20,718 --> 00:25:24,146
according to multiple use cases, then what we can do here is

393
00:25:24,248 --> 00:25:27,998
let me show you the example. So there's a simple

394
00:25:28,104 --> 00:25:31,382
sum function which I've created that is simply returning a plus b

395
00:25:31,436 --> 00:25:34,726
response. And if we go to the test function,

396
00:25:34,828 --> 00:25:38,418
so you can see here the best sum, and you can see here

397
00:25:38,444 --> 00:25:42,346
that I've created a simple struct, named cases and

398
00:25:42,368 --> 00:25:45,930
I've provided a description number and expected. So what basically

399
00:25:46,000 --> 00:25:49,642
does is that I can create as many as

400
00:25:49,776 --> 00:25:52,800
use cases as I want for testing my sum function.

401
00:25:53,330 --> 00:25:57,418
Let's say if you see the first two objects,

402
00:25:57,434 --> 00:26:00,894
basically. So here I am providing the description one plus

403
00:26:00,932 --> 00:26:04,590
two and number one and one plus one. Two and expected will be three

404
00:26:04,660 --> 00:26:08,306
okay, so if we add one and two, one plus two expected should

405
00:26:08,328 --> 00:26:11,794
be three. And if we provide three and four input, like num

406
00:26:11,832 --> 00:26:15,362
one from three and num two to four expected should be seven.

407
00:26:15,496 --> 00:26:18,982
So you can see that we have created a struct along with,

408
00:26:19,116 --> 00:26:22,930
and then we ran the loop on our struct cases

409
00:26:23,090 --> 00:26:25,720
by using range keyword. Now,

410
00:26:26,250 --> 00:26:30,994
as I said before, that t run is basically responsible

411
00:26:31,042 --> 00:26:34,278
for running our test case, responsible for running our best

412
00:26:34,444 --> 00:26:38,346
cases, right? So here we are providing t run, and then we provide our

413
00:26:38,368 --> 00:26:42,110
t description, which is basically the text for the text that

414
00:26:42,180 --> 00:26:46,046
we are supposed to see on terminal. Then we have provided a function

415
00:26:46,148 --> 00:26:49,882
that is getting testing t, which we already discussed.

416
00:26:49,946 --> 00:26:53,818
And in this loop I am getting the result of

417
00:26:53,844 --> 00:26:56,674
sum, and I'm providing the parameter num one.

418
00:26:56,712 --> 00:26:59,746
And on the loop side,

419
00:26:59,848 --> 00:27:02,434
in the loop we are getting num one and um, two.

420
00:27:02,472 --> 00:27:06,134
And for each of these cases, like for

421
00:27:06,252 --> 00:27:08,760
case number one and case number two,

422
00:27:10,250 --> 00:27:14,710
it will return the response, either our best case is passed or failed.

423
00:27:15,610 --> 00:27:18,140
So if I run my code,

424
00:27:18,990 --> 00:27:22,890
let me clear the screen, I go to CD

425
00:27:23,230 --> 00:27:25,610
and table.

426
00:27:26,590 --> 00:27:28,620
If I run go test.

427
00:27:33,410 --> 00:27:38,826
Okay, so as you can see that in youre verbus

428
00:27:38,938 --> 00:27:42,320
flag, youre can see that we have run

429
00:27:42,930 --> 00:27:46,098
a couple of test cases, one plus two and three plus four, and all of

430
00:27:46,104 --> 00:27:49,634
them are passed. Okay, so now

431
00:27:49,672 --> 00:27:53,186
you have the idea like table driven testing. What? Table driven testing is the

432
00:27:53,208 --> 00:27:56,520
table driven testing is basically an approach where we actually provide

433
00:27:57,050 --> 00:28:00,886
as many as use cases, as many as inputs to

434
00:28:00,908 --> 00:28:04,422
get different outputs. So let's say, let me add another

435
00:28:04,476 --> 00:28:09,106
one, another input,

436
00:28:09,218 --> 00:28:13,560
and let me do this. Ten plus

437
00:28:14,490 --> 00:28:18,678
45, and I provide

438
00:28:18,844 --> 00:28:22,554
number one and number 210 or 45. But I'm expecting,

439
00:28:22,602 --> 00:28:26,320
let's say 70, which is not basically, which should be failed. Right?

440
00:28:28,930 --> 00:28:32,734
If I run this test case again, we can see that our

441
00:28:32,932 --> 00:28:36,850
test sum one plus two is passed. Test sum three plus four

442
00:28:36,920 --> 00:28:41,300
is actually passed. But ten plus 45 has actually failed because

443
00:28:41,990 --> 00:28:46,018
we actually wanted the number, because we actually

444
00:28:46,104 --> 00:28:49,574
wanted the expected 70. But we are getting ten

445
00:28:49,612 --> 00:28:53,446
plus 45, which is 55. So that's how you can provide as many as

446
00:28:53,468 --> 00:28:57,094
input as you want and get different outputs according to your use

447
00:28:57,132 --> 00:29:01,126
case. All right, so you got the idea of table driven

448
00:29:01,158 --> 00:29:04,646
testing. There are some testing frameworks already provided

449
00:29:04,678 --> 00:29:08,506
by Go community in which youre can see the Gomega, which is basically a

450
00:29:08,528 --> 00:29:12,334
matcher assertion library. So if you

451
00:29:12,372 --> 00:29:15,486
have some advanced level of assertion and you want to

452
00:29:15,508 --> 00:29:18,574
test some complex use

453
00:29:18,612 --> 00:29:21,774
cases that require some matching features, then you can

454
00:29:21,812 --> 00:29:24,714
go for Gomega library.

455
00:29:24,842 --> 00:29:28,166
Another was in group, another was in Pocheck. Basically it's a feature

456
00:29:28,218 --> 00:29:32,306
rich testing library which includes that in

457
00:29:32,328 --> 00:29:36,766
a more advanced and complex features testify toolkit

458
00:29:36,798 --> 00:29:40,490
for mocks and assertions. It is also similar as Bomega,

459
00:29:40,510 --> 00:29:43,894
but it also provides you some mocking feature to provide

460
00:29:43,932 --> 00:29:46,994
some fake data or fake responses,

461
00:29:47,042 --> 00:29:50,694
I should say. So. Go mock is another dedicated framework

462
00:29:50,742 --> 00:29:54,138
that you can use to test your actual code base.

463
00:29:54,304 --> 00:29:58,566
And there's another one called Jinko which is basically a BDD testing

464
00:29:58,598 --> 00:30:02,638
framework. BDD stands for behavior driven development. So it's like

465
00:30:02,724 --> 00:30:06,346
something where we have to check specific specs.

466
00:30:06,538 --> 00:30:10,282
So basically it means like we can see the behavior

467
00:30:10,346 --> 00:30:13,570
of our code in a form of specific specs.

468
00:30:16,390 --> 00:30:19,918
So you see here are testing frameworks that is already introduced

469
00:30:19,934 --> 00:30:23,474
by both community, okay, so the main thing

470
00:30:23,512 --> 00:30:27,174
to follow is whenever you are working with TDD, you need to follow

471
00:30:27,212 --> 00:30:30,678
some best practices, which you should basically.

472
00:30:30,764 --> 00:30:34,360
So the first and foremost, which I already discussed as well

473
00:30:35,690 --> 00:30:39,202
in the start of my session, that always

474
00:30:39,356 --> 00:30:42,586
write test case before the actual code. Because whenever you

475
00:30:42,608 --> 00:30:46,474
write test cases, you know what you are actually supposed to do

476
00:30:46,512 --> 00:30:50,026
in your actual code, right? Write a small and

477
00:30:50,048 --> 00:30:53,118
focused test. Okay, so if you have a

478
00:30:53,124 --> 00:30:57,022
feature that contains some, that contains some different sort

479
00:30:57,076 --> 00:31:00,186
of performed different sorts

480
00:31:00,218 --> 00:31:03,582
of algorithm, you can write a small and focus test of

481
00:31:03,636 --> 00:31:08,174
that feature, like test

482
00:31:08,212 --> 00:31:12,866
for algorithm one, best for test for algorithm two, and you

483
00:31:12,888 --> 00:31:16,406
can set it up in a specific suite. So make sure

484
00:31:16,428 --> 00:31:20,482
to write small and focus best so that it can be easily manageable

485
00:31:20,546 --> 00:31:24,018
and maintainable. Use go test command

486
00:31:24,034 --> 00:31:28,086
to test case along with v flag for verbus logs as

487
00:31:28,108 --> 00:31:31,770
I show you in the terminal. As I show you in live code that always

488
00:31:31,840 --> 00:31:35,914
use go test for testing your Google test cases use

489
00:31:35,952 --> 00:31:39,370
mock dependencies to simulate actual behavior of their feature.

490
00:31:41,970 --> 00:31:45,834
As we see in our table driven testing

491
00:31:45,882 --> 00:31:49,870
example, we use mock inputs, right? So not just inputs,

492
00:31:51,170 --> 00:31:54,922
we can also mimic some dependencies

493
00:31:54,986 --> 00:31:58,666
to simulate our actual behavior that our code have

494
00:31:58,708 --> 00:32:02,098
to follow, right? Yes. So basically

495
00:32:02,184 --> 00:32:05,826
fake, you can use fake dependency as well utilizing port coverage tool. As I

496
00:32:05,848 --> 00:32:09,654
said, as I said in my starting of the session, always use

497
00:32:09,692 --> 00:32:12,806
go test cover. So basically if you want to see the coverage of youre

498
00:32:12,828 --> 00:32:16,102
test, you can use go test cover, which is basically

499
00:32:16,156 --> 00:32:19,706
a good thing to do along with when you are writing your

500
00:32:19,728 --> 00:32:22,858
test cases, automate and refactor your

501
00:32:22,864 --> 00:32:26,266
test cases using CI tools. Okay, so after writing your

502
00:32:26,288 --> 00:32:29,946
test cases, make sure after time to

503
00:32:29,968 --> 00:32:33,198
time you are updating your code or you are refactoring your code,

504
00:32:33,364 --> 00:32:37,354
because at any given time that feature

505
00:32:37,402 --> 00:32:41,070
got some changes or client have some requirement that okay, we need to do

506
00:32:41,140 --> 00:32:45,938
something this and that or we

507
00:32:45,944 --> 00:32:49,058
need to do some replacement or we need to some add or

508
00:32:49,064 --> 00:32:52,530
remove things. So we need to have our test cases

509
00:32:53,110 --> 00:32:54,660
along with our code.

510
00:32:55,910 --> 00:32:58,934
And if you are deciding to automate it,

511
00:32:58,972 --> 00:33:02,866
it will be a great practice to do it. You can use different CI tools

512
00:33:02,898 --> 00:33:06,738
like databases, travis CI, Jenkins, et cetera,

513
00:33:06,754 --> 00:33:10,266
et cetera. Always keep your test cases up to date as

514
00:33:10,288 --> 00:33:12,940
I said, always keep your test case up to date.

515
00:33:13,870 --> 00:33:17,366
You may not know that any given time requirements get changed,

516
00:33:17,398 --> 00:33:20,890
so you make sure that you are already

517
00:33:20,960 --> 00:33:24,326
up to date in your desk already. Update your test

518
00:33:24,368 --> 00:33:28,634
cases along in the convert of feature or even if you are using some external

519
00:33:28,762 --> 00:33:32,494
framework or library. You need to update that as well

520
00:33:32,612 --> 00:33:36,030
so you do not get break in the actual runtime.

521
00:33:37,170 --> 00:33:40,842
All right guys, so thank you very much. This was my session

522
00:33:40,986 --> 00:33:44,766
and thank you conf 42 Golang team for having me

523
00:33:44,788 --> 00:33:48,326
here, for inviting me to talk on this. You can follow me on

524
00:33:48,348 --> 00:33:51,862
Twitter at mkhan, GitHub, LinkedIn where I'm mostly active on.

525
00:33:51,916 --> 00:33:55,382
So let me know if you have any questions. You can reach me out on

526
00:33:55,516 --> 00:33:57,780
social media. And thank you.

