1
00:01:44,750 --> 00:01:48,206
Hello and welcome to this session on GitHub, where we're focusing

2
00:01:48,238 --> 00:01:51,666
on fortifying your code base with GitHub specifically. There's a lot of

3
00:01:51,688 --> 00:01:55,186
great features in GitHub. We just got through GitHub Universe and there's some

4
00:01:55,208 --> 00:01:59,086
amazing copilot and AI innovations there and so many features

5
00:01:59,118 --> 00:02:02,574
that I think a year from now you'll wish you had started today to implement

6
00:02:02,622 --> 00:02:06,306
some of these things. And I love that quote by Karen Lamb showing here as

7
00:02:06,328 --> 00:02:09,946
we get started in today's session. My name is Travis and I work

8
00:02:09,968 --> 00:02:13,286
as a distinguished software engineer for a company called SPscommerce.

9
00:02:13,398 --> 00:02:16,186
And you may not have heard of SPS commerce. That's because we're a business to

10
00:02:16,208 --> 00:02:20,346
business organization that's focusing on connecting suppliers and retailers together

11
00:02:20,448 --> 00:02:23,606
into a massive retail network, the world's largest retail network,

12
00:02:23,638 --> 00:02:27,566
in fact. And I focus specifically there on developer experience.

13
00:02:27,748 --> 00:02:31,086
And you might be asking yourself, developer experience, what does

14
00:02:31,108 --> 00:02:34,782
that mean exactly? That can mean so many different things to different people.

15
00:02:34,916 --> 00:02:38,318
And over the last few years, this is one of my favorite definitions that I've

16
00:02:38,334 --> 00:02:41,406
seen pop up and land on. And that's the developer

17
00:02:41,438 --> 00:02:44,942
experience is the activity of studying, improving and optimizing

18
00:02:45,006 --> 00:02:48,726
how developers get their work done. So we're not interested in how a developer is

19
00:02:48,748 --> 00:02:51,782
going to communicate with the HR department to change their address.

20
00:02:51,916 --> 00:02:55,894
Instead, we're focusing on how we can engage with the developer and have

21
00:02:55,932 --> 00:03:00,198
their user experience and their developer principles line up to form this frictionless

22
00:03:00,374 --> 00:03:04,426
experience that they can use day to day to deliver code to

23
00:03:04,448 --> 00:03:08,278
production, to deliver features to production. And that's

24
00:03:08,294 --> 00:03:11,962
so important, especially as you think about the history of your organization, the number

25
00:03:12,016 --> 00:03:15,902
of existing tools that you have that are kind of forming this different experience of

26
00:03:15,956 --> 00:03:19,902
this CI CD tool, this source control tool, this observability tool.

27
00:03:19,956 --> 00:03:23,326
And we need to all bring them together to form this nice cohesive ecosystem that

28
00:03:23,348 --> 00:03:26,846
allows you to have the best quality of life possible. And one of my favorite

29
00:03:26,878 --> 00:03:30,386
quotes kind of describing this problem is that developers work in

30
00:03:30,408 --> 00:03:33,506
rainforests, not planned gardens. This idea of

31
00:03:33,528 --> 00:03:36,754
a rainforest or a jungle, that these tools have really

32
00:03:36,792 --> 00:03:40,326
popped out in your organization over the last 20 years when

33
00:03:40,348 --> 00:03:44,422
you needed a particular need, but they haven't been curated together or planned together

34
00:03:44,476 --> 00:03:48,022
what that ecosystem looks like. And so as we think about how we can

35
00:03:48,076 --> 00:03:51,820
more effectively create planned gardens for our developer experience,

36
00:03:52,190 --> 00:03:55,258
the reality is that there's a lot of work to do,

37
00:03:55,344 --> 00:03:59,062
especially when we think about just coding alone. As an engineer

38
00:03:59,126 --> 00:04:02,586
specifically or developer who's writing code to deliver to production,

39
00:04:02,698 --> 00:04:05,918
your job is far more than just delivering code. In fact,

40
00:04:06,004 --> 00:04:09,306
you are expected to deal with infrastructure as code, CI,

41
00:04:09,338 --> 00:04:12,350
CD pipelines, dev environments, configuration.

42
00:04:12,690 --> 00:04:15,754
You also, which is really important for today's discussion,

43
00:04:15,802 --> 00:04:19,842
have to deal with a plethora of supply chain, SaaS, Das, remediation issues,

44
00:04:19,896 --> 00:04:23,266
all related to security. And on top of that, or I should say

45
00:04:23,288 --> 00:04:26,446
on bottom of that, you have to deal with code quality, tech debt, feature flags,

46
00:04:26,478 --> 00:04:29,814
testing and of course just the overhead of the day to day

47
00:04:29,852 --> 00:04:33,686
operation within an organization, whether it be meetings or management or

48
00:04:33,708 --> 00:04:37,990
just other stuff. And when we examine this and we pull the

49
00:04:38,140 --> 00:04:41,674
stats from software, we find that developers code

50
00:04:41,712 --> 00:04:45,386
on average 52 minutes a day. That's not very much. And so

51
00:04:45,408 --> 00:04:48,954
we need to make that 52 minutes longer and better and

52
00:04:49,072 --> 00:04:52,318
better quality, better quality of life so you can accomplish more during that. From a

53
00:04:52,324 --> 00:04:55,982
productivity perspective, this quote from software

54
00:04:56,036 --> 00:05:00,170
CTO Mason McLeod, who says code time is often undervalued,

55
00:05:00,250 --> 00:05:03,774
continually interrupted and almost wholly unmeasurable. And I definitely agree

56
00:05:03,812 --> 00:05:07,106
with that, especially in my coding experience. So we need to

57
00:05:07,128 --> 00:05:10,846
work to improve daily work. We need to fix bottlenecks,

58
00:05:10,878 --> 00:05:14,734
we need to include more automation, we need to reduce feedback cycle

59
00:05:14,782 --> 00:05:18,018
durations. Codified best practices is one of my favorites. I don't want

60
00:05:18,024 --> 00:05:20,854
to have to read a whole bunch of documentation. I want it to be part

61
00:05:20,892 --> 00:05:24,886
of the process that I'm working in and the tool set that I'm working with.

62
00:05:25,068 --> 00:05:28,754
Effective documentation is so important. We so many times don't

63
00:05:28,802 --> 00:05:32,362
even think about documentation and how important it is to be not just present,

64
00:05:32,416 --> 00:05:35,862
but also accurate and of course streamlining collaboration.

65
00:05:36,006 --> 00:05:39,370
And one of the key toolset that we find in developer experience

66
00:05:39,440 --> 00:05:43,014
that can impact many of these areas is GitHub. And GitHub

67
00:05:43,062 --> 00:05:46,606
has had a long, interesting journey from when it started started way

68
00:05:46,628 --> 00:05:50,298
back as early as 2008. Right? That's when we first saw GitHub

69
00:05:50,394 --> 00:05:53,898
and they were really focused on the idea of git repository hosting.

70
00:05:53,994 --> 00:05:57,762
No longer a pain in the ass. Finally a code repository that works

71
00:05:57,816 --> 00:06:01,314
as well as you do, which is incredible. At the time we were just happy

72
00:06:01,352 --> 00:06:05,330
to get managed source control that worked so excellently quickly.

73
00:06:05,400 --> 00:06:08,646
They realized what they were onto. And in 2011 we see their mission and their

74
00:06:08,668 --> 00:06:12,162
focus move towards this, lowering the barriers of collaboration

75
00:06:12,226 --> 00:06:16,242
by building powerful features into our products that make it easier to contribute,

76
00:06:16,386 --> 00:06:19,710
which is true. We see them moving just beyond githing and saying we're going to

77
00:06:19,720 --> 00:06:23,034
allow you to collaborate better. And of course, moving back

78
00:06:23,072 --> 00:06:27,334
to the acquisition from Microsoft in 2018, we see the complete developer

79
00:06:27,382 --> 00:06:30,874
platform, build, scale and deliver secure software and

80
00:06:30,912 --> 00:06:34,366
if you've been paying attention, especially to GitHub universe, there's lots of

81
00:06:34,388 --> 00:06:37,918
new, exciting features that were launched even this particular month.

82
00:06:38,084 --> 00:06:41,642
And so now GitHub has transitioned, as of November

83
00:06:41,706 --> 00:06:44,746
2023, to the world's leading aipowered

84
00:06:44,778 --> 00:06:48,002
developer platform. And that's an exciting place to be in.

85
00:06:48,136 --> 00:06:52,066
But at the same time, recognize that staying up to date with GitHub features is

86
00:06:52,168 --> 00:06:55,954
almost a full time job. It would seem if you track the

87
00:06:55,992 --> 00:06:59,158
releases per month, I'm only going back as far as 2018. You can

88
00:06:59,164 --> 00:07:03,074
see that we're getting as many as 60 70 releases,

89
00:07:03,202 --> 00:07:07,286
feature releases of GitHub per month. And that's just so many

90
00:07:07,388 --> 00:07:11,494
explosion of capabilities that are both exciting. But have

91
00:07:11,532 --> 00:07:15,034
you worrying about what do I focus on? What don't I focus on? So I

92
00:07:15,072 --> 00:07:18,422
found a lot of our teams are looking for the hints at where to explore,

93
00:07:18,486 --> 00:07:21,754
where do I go next? So as we dive in today on fortifying your code

94
00:07:21,792 --> 00:07:25,818
base, we're zoning in on GitHub on how we can maximize your developer productivity,

95
00:07:25,914 --> 00:07:28,750
specifically with two GitHub tools.

96
00:07:29,170 --> 00:07:32,382
This is important. If we look at the Gardener 2020 report,

97
00:07:32,516 --> 00:07:36,130
it says that 29% of organizations have the shift towards

98
00:07:36,200 --> 00:07:39,566
consolidating security vendors due to operational inefficiencies.

99
00:07:39,758 --> 00:07:43,202
And we see that growing. That grew to 75%

100
00:07:43,256 --> 00:07:46,818
on the same report in 2022. And I imagine in 2024 it's going

101
00:07:46,824 --> 00:07:50,086
to be even more interesting on top of that. And so what is

102
00:07:50,108 --> 00:07:54,386
that all about, shifting security vendors due to operational inefficiencies?

103
00:07:54,498 --> 00:07:58,054
Well, we find some answers deeper inside the Dynatrace report, focusing on

104
00:07:58,092 --> 00:08:01,458
application security, where it talks about tool sprawl. And if you're

105
00:08:01,474 --> 00:08:04,826
in developer experience, you know, tool sprawl is a big problem. We have so many

106
00:08:04,848 --> 00:08:08,134
tools all over the place, and this comes back to that curated

107
00:08:08,262 --> 00:08:11,354
garden that we want to build. It's very difficult when you have so much

108
00:08:11,392 --> 00:08:15,430
individual or independent tooling and incumbents that are there. And so as

109
00:08:15,440 --> 00:08:18,734
we look to this and we gauge we're already in source control, GitHub does

110
00:08:18,772 --> 00:08:22,014
so much of what we need already. What if it could do more? What can

111
00:08:22,052 --> 00:08:25,658
it do for us from a security perspective, to bring in that tool sprawl

112
00:08:25,674 --> 00:08:28,180
and allow us to focus on what we do best in code?

113
00:08:28,550 --> 00:08:32,306
And GitHub really is in some cases that swiss army knife of

114
00:08:32,328 --> 00:08:35,058
tooling. But at the same time, some of the tooling that it has, a lot

115
00:08:35,064 --> 00:08:39,370
of the tooling it has, does an incredibly great job of integrating with the ecosystem.

116
00:08:39,550 --> 00:08:43,154
And so today we want to look at Dependabot which is all about transparency

117
00:08:43,202 --> 00:08:46,438
and automation to keep your supply chain dependencies up to date.

118
00:08:46,524 --> 00:08:49,862
And it's going to be super effective. If you haven't seen Dependabot yet,

119
00:08:49,916 --> 00:08:53,638
it's going to feel like a breath of fresh air. And of course, GitHub advanced

120
00:08:53,654 --> 00:08:57,014
security we've seen recently take a large presence

121
00:08:57,062 --> 00:09:00,662
on GitHub and it's all about the centralization and the transparency

122
00:09:00,726 --> 00:09:04,318
of code security, really focusing on static code analysis and how

123
00:09:04,324 --> 00:09:07,598
it can support that. And so with that, let's dive in. Let's take a

124
00:09:07,604 --> 00:09:11,086
look at GitHub Dependabot. And this is all about

125
00:09:11,188 --> 00:09:14,638
supply chain security. And in this particular feature,

126
00:09:14,734 --> 00:09:18,462
GitHub defines it as monitor vulnerabilities and dependencies

127
00:09:18,526 --> 00:09:22,530
used in your project and keep your dependencies up to date with Dependabot.

128
00:09:22,950 --> 00:09:26,290
What does that actually mean? Don't worry, we're going to explore it. But this idea

129
00:09:26,360 --> 00:09:29,874
that in all of your repositories, whether it be pypy

130
00:09:29,922 --> 00:09:33,314
packages or like a requirements TXT, whether it be a nuget config

131
00:09:33,362 --> 00:09:37,314
for. Net or whether it be a maven settings,

132
00:09:37,362 --> 00:09:41,106
XML, whatever you have, whatever ecosystem you're

133
00:09:41,138 --> 00:09:44,346
in, you have a number of dependencies. You rely on abstractions that

134
00:09:44,368 --> 00:09:47,658
are really important, but keeping them up to date can feel like a

135
00:09:47,664 --> 00:09:51,674
nightmare, right? But if we look at the mend IO 2021

136
00:09:51,712 --> 00:09:55,626
report, it says that over 90% of cves aren't present in most recent

137
00:09:55,658 --> 00:09:59,374
dependency versions. That's incredible. That means that the single best

138
00:09:59,412 --> 00:10:02,666
security practice that you can do in terms of consuming external supply

139
00:10:02,698 --> 00:10:06,462
chain security is to just keep your packages up to date all the time.

140
00:10:06,516 --> 00:10:09,554
Just use the latest and you're going to save yourself a lot of pain.

141
00:10:09,752 --> 00:10:13,378
And I like to think about this as Mendio describes it, which is kind

142
00:10:13,384 --> 00:10:17,154
of like going to the dentist. If you only update your dependencies every five

143
00:10:17,192 --> 00:10:21,046
years, it's going to be painful, right? It's really going to hurt. But if you're

144
00:10:21,068 --> 00:10:24,914
doing it every month or continually every week, it becomes second nature.

145
00:10:24,962 --> 00:10:28,806
It's a simple best practice, right? Just as we think about CI CD

146
00:10:28,838 --> 00:10:33,174
and doing that more often, and so we'll dive into three components of dependent

147
00:10:33,222 --> 00:10:36,810
bot alerts, security updates and version updates.

148
00:10:37,470 --> 00:10:40,554
All right, so first bit of an overview. If you go into

149
00:10:40,592 --> 00:10:43,518
your GitHub, you're going to need admin access to your repository and you'll be able

150
00:10:43,524 --> 00:10:47,470
to find this security section that we'll be exploring today, which is code

151
00:10:47,540 --> 00:10:51,146
security and analysis. And it's got a dependency graph

152
00:10:51,258 --> 00:10:55,274
present. And dependency graph has been around a long time in GitHub and basically maps

153
00:10:55,322 --> 00:10:59,202
all of these supply chain dependencies. So that way you can generate a pretty clear

154
00:10:59,256 --> 00:11:02,370
software bill of materials or an s bomb. And turning that on

155
00:11:02,440 --> 00:11:05,534
is free and cheap and easy and there's no reason you shouldn't use your dependency

156
00:11:05,582 --> 00:11:09,046
graph. And once you have that data set enabled, then you

157
00:11:09,068 --> 00:11:13,190
can begin to take advantage of the dependent bot features that we just introduced

158
00:11:13,610 --> 00:11:16,838
and there you'll be able to then drill in. You can

159
00:11:16,844 --> 00:11:20,114
see your dependency graph where you can actually take a look at all the packages

160
00:11:20,162 --> 00:11:24,070
in your repo or better yet, see what dependencies are used across your entire organization

161
00:11:24,150 --> 00:11:27,674
as a part of that sbom. And when you drill into it,

162
00:11:27,712 --> 00:11:31,686
then you'll be able to look at your dependent bot alerts. And so by enabling

163
00:11:31,718 --> 00:11:35,770
the dependent bot alerts, we can very quickly see well, here's my dependency graph,

164
00:11:35,850 --> 00:11:39,514
but highlight for me the things that are critical or high concerns

165
00:11:39,562 --> 00:11:42,558
related to cves that are out there. And you get that as a part of

166
00:11:42,564 --> 00:11:45,726
your security tab that you can see here. And on that security tab you can

167
00:11:45,748 --> 00:11:48,562
drill in and check out the individual details of each and every one of these.

168
00:11:48,616 --> 00:11:51,918
And there's no other infrastructure you have to turn on for this, you just simply

169
00:11:51,934 --> 00:11:55,090
have to enable the feature. Once it's enabled,

170
00:11:55,430 --> 00:11:58,406
you'll be able to drill in. And from here you can do a couple of

171
00:11:58,428 --> 00:12:02,194
things. First, that's pretty neat is you can actually create a security update

172
00:12:02,242 --> 00:12:05,766
immediately from this particular issue, and it's going to create

173
00:12:05,788 --> 00:12:09,206
a pull request on your repository for you. If you decide that

174
00:12:09,228 --> 00:12:12,290
this isn't a fix that you need to make, or perhaps the surface area of

175
00:12:12,300 --> 00:12:15,766
this particular cv doesn't affect the way that you're using it well, you can easily

176
00:12:15,798 --> 00:12:19,306
dismiss it. And there's plenty of workflow options that allow you to track and

177
00:12:19,328 --> 00:12:23,102
see why certain things were dismissed over time. And so you also

178
00:12:23,156 --> 00:12:26,734
have the option in your organizational settings to turn

179
00:12:26,772 --> 00:12:30,810
on this capability across the entire organization. You can enable and disable

180
00:12:30,890 --> 00:12:33,914
all from it as an administrator and an.org owner.

181
00:12:34,042 --> 00:12:37,106
However, a word of warning, as you begin to turn on and play with these

182
00:12:37,128 --> 00:12:40,606
features, especially the ones that actually create pull requests,

183
00:12:40,638 --> 00:12:44,530
that's the security updates alerts. Just remember, tell me about

184
00:12:44,600 --> 00:12:48,230
a problem. Security updates actually submit pull requests when there's a security

185
00:12:48,300 --> 00:12:52,310
concern disabling, or I should say enabling security

186
00:12:52,380 --> 00:12:56,326
updates for everyone. Keep in mind that if you have 3000 repos in your

187
00:12:56,348 --> 00:12:59,926
organization, you're about to turn that on across the board and

188
00:12:59,948 --> 00:13:04,054
each one of those may submit a pull request, which in turn will submit

189
00:13:04,102 --> 00:13:07,338
a status check related to your build provider, and all of a

190
00:13:07,344 --> 00:13:10,374
sudden you're about to kick off a plethora of builds that's really going to jog

191
00:13:10,422 --> 00:13:13,994
up that queue, I think. So just be careful as you think about organizational

192
00:13:14,042 --> 00:13:17,086
rollout, but it does seem pretty trivial and easy

193
00:13:17,188 --> 00:13:20,382
to do. So here. You can also find views at that level

194
00:13:20,436 --> 00:13:24,330
about who has it enabled, who has alerts enabled, versus security updates,

195
00:13:24,410 --> 00:13:28,334
and how many of your repos are protected version updates.

196
00:13:28,382 --> 00:13:31,550
Take us to the next level then they say, I don't just want security updates,

197
00:13:31,630 --> 00:13:35,058
actually give me updates for all packages that are out there, any package that I

198
00:13:35,064 --> 00:13:38,486
have in my ecosystem, and I'm a big fan of using version updates across the

199
00:13:38,508 --> 00:13:41,766
board. And GitHub defines version updates as automated pull

200
00:13:41,788 --> 00:13:44,934
requests that keep your dependencies updated even when they don't have

201
00:13:44,972 --> 00:13:48,294
any vulnerabilities. And so you can see here an example of

202
00:13:48,332 --> 00:13:51,766
a pull request that's been created that clearly outlines

203
00:13:51,878 --> 00:13:55,786
an update that I'm making for this particular package, and has release notes and

204
00:13:55,808 --> 00:13:59,706
commit information available to you, as well as labels that are there. And the

205
00:13:59,728 --> 00:14:02,974
supported ecosystem is pretty substantial here. I think you'll find that

206
00:14:03,012 --> 00:14:06,526
a lot of the core languages that you work with will be supported, whether it

207
00:14:06,548 --> 00:14:09,594
be go, maven, gradle, NPM, nuget,

208
00:14:09,642 --> 00:14:12,926
PiP, Elm, even some interesting ones that you might not

209
00:14:12,948 --> 00:14:16,642
have thought of would be docker, for example, or terraform modules, or even

210
00:14:16,696 --> 00:14:19,694
git sub modules or GitHub actions can all be updated.

211
00:14:19,822 --> 00:14:23,470
If you're specifying a Docker file and it uses semantic versioning,

212
00:14:23,550 --> 00:14:27,566
you can automatically have that from statement updated as a part of Dependabot.

213
00:14:27,758 --> 00:14:30,598
And a little bit on my wish list is that Helmchides could be part of

214
00:14:30,604 --> 00:14:34,070
that too, but maybe we'll see that in the future. It does support

215
00:14:34,140 --> 00:14:37,714
private feeds as well, so you likely have internal packages

216
00:14:37,762 --> 00:14:41,098
that are part of your organization, and you can include those here as a

217
00:14:41,104 --> 00:14:44,346
part of it too. And organizationally configure secrets that

218
00:14:44,368 --> 00:14:47,834
would allow private access to a JFrog feed. For example,

219
00:14:48,032 --> 00:14:51,866
you can specify an update schedule, which is important because you don't always just want

220
00:14:51,888 --> 00:14:55,510
to update in real time. Sometimes you want that to happen on a regular cadence.

221
00:14:55,670 --> 00:14:59,242
You also have metadata configuration, and we'll talk about the metadata configuration options

222
00:14:59,296 --> 00:15:02,866
in a second. And we have behavioral configuration, and we'll see that

223
00:15:02,888 --> 00:15:05,746
too. So as we begin to explore, you'll find that that dependency graph now is

224
00:15:05,768 --> 00:15:08,638
going to be populated. And as a part of that, here's where you can generate

225
00:15:08,654 --> 00:15:11,998
that s bomb that we talked. But, and 83% of security teams don't

226
00:15:12,014 --> 00:15:14,866
have access to a fully accurate s bomb in real time, which is crazy that

227
00:15:14,888 --> 00:15:18,514
you can have that for free here. You can automatically hit the

228
00:15:18,552 --> 00:15:21,654
check for updates and you can look for updates anytime that you need to and

229
00:15:21,692 --> 00:15:25,714
process through that. All right, so moving on to configuration. Now, version updates

230
00:15:25,842 --> 00:15:29,442
are not configured through the UI like the rest of the dependent bot capabilities

231
00:15:29,506 --> 00:15:32,546
were. Version updates are actually going to move into source

232
00:15:32,578 --> 00:15:35,590
control and configure it in the way that you expect with the YamL file.

233
00:15:35,670 --> 00:15:38,774
So you're going to create a yaml file called Dependabot Yaml,

234
00:15:38,822 --> 00:15:42,246
and you're going to place that under your GitHub metadata folder that exists

235
00:15:42,278 --> 00:15:45,838
in your repository here. Then we're going to specify version two because dependabot comes

236
00:15:45,844 --> 00:15:48,986
from a previous preview that had a different schema. So we're just specifying the version

237
00:15:49,018 --> 00:15:52,394
of schema we want to use, followed then by a series of registries.

238
00:15:52,442 --> 00:15:55,790
These could be private registries inside your organization that you want to make use of.

239
00:15:55,860 --> 00:15:58,718
In this case, I'm going to use a private Nuget feed that's attached to Azure

240
00:15:58,734 --> 00:16:01,950
DevOps. And you can see here that I can tokenize and use secrets

241
00:16:02,030 --> 00:16:04,946
that are pulled from the organizational level, which is great. It means I can use

242
00:16:04,968 --> 00:16:07,490
this configuration across many repositories.

243
00:16:08,150 --> 00:16:11,666
And now I'm going to indicate the ecosystems I want to update and the directories

244
00:16:11,698 --> 00:16:14,786
for those. So if you have a monorepo, you can specify multiple ecosystems

245
00:16:14,818 --> 00:16:18,454
in a single file and specify just one if you need. And you can set

246
00:16:18,492 --> 00:16:22,038
that schedule here in the interval of how often you want to update. You can

247
00:16:22,044 --> 00:16:25,386
also have several other options around open pull request limits. In this case,

248
00:16:25,408 --> 00:16:27,578
I'm going to say I don't want any more than ten pull requests ever at

249
00:16:27,584 --> 00:16:31,270
a time. You can also include additional metadata around custom labels,

250
00:16:31,350 --> 00:16:34,510
signees, reviewers, commit messages, lots of information

251
00:16:34,580 --> 00:16:37,934
you can explore for how you want to customize and piece together your workflow for

252
00:16:37,972 --> 00:16:41,726
how it creates pull requests. What's neat though, is that you

253
00:16:41,748 --> 00:16:45,006
have the ability to ignore certain dependencies. In many cases you

254
00:16:45,028 --> 00:16:48,258
have some of your capabilities, or I should say some of your

255
00:16:48,264 --> 00:16:51,634
packages are updated in like a nightly build, and you might retrieve those far

256
00:16:51,672 --> 00:16:55,102
more often than you want. An example of this that I've seen is like AWS

257
00:16:55,166 --> 00:16:58,946
SDK seems to have almost a build every single day for

258
00:16:58,968 --> 00:17:02,018
some of them. And well, I want that build. I want to get updated.

259
00:17:02,114 --> 00:17:05,414
Boy, I don't necessarily want to worry about it every single day,

260
00:17:05,452 --> 00:17:08,994
maybe once a week or whatever that cadence is. You can ignore certain types

261
00:17:09,042 --> 00:17:12,634
of updates, and you can also ignore in some cases, if you're not ready

262
00:17:12,672 --> 00:17:16,486
to make a major upgrade to your system, ignore major version numbers or patch version

263
00:17:16,518 --> 00:17:20,358
numbers, depending on what you want. One of the largest additions

264
00:17:20,374 --> 00:17:24,046
that makes Dependabot even so much better now than it was a few

265
00:17:24,068 --> 00:17:27,674
months ago is the ability to handle grouped

266
00:17:27,722 --> 00:17:31,550
pull requests. And by that I mean we won't actually group several changes

267
00:17:31,620 --> 00:17:34,718
or several package updates into a single pr.

268
00:17:34,884 --> 00:17:38,334
And that's essential because it causes a lot of problems, a lot of noise,

269
00:17:38,382 --> 00:17:41,826
by generating ten pull requests. In some cases, the granularity is

270
00:17:41,848 --> 00:17:45,554
too small that updating one package causes another one to break, and you'll never

271
00:17:45,592 --> 00:17:48,766
get both of those to pass your status checks as it creates those pull requests

272
00:17:48,798 --> 00:17:52,466
in GitHub for you, requiring some manual intervention and moving between branches

273
00:17:52,498 --> 00:17:55,814
in order to figure it out. And so this is why grouped updates allow

274
00:17:55,852 --> 00:17:59,186
us to say, hey, take all of those test dependencies and squash

275
00:17:59,218 --> 00:18:02,314
them together into one pull request. Take those core dependencies and those

276
00:18:02,352 --> 00:18:06,038
packages that rely on each other. Make sure they're together in one pull request.

277
00:18:06,134 --> 00:18:09,494
Take all of those AWS updates and make sure they're in one pull request

278
00:18:09,542 --> 00:18:12,902
together, not individual ones. And this is pretty essential,

279
00:18:12,966 --> 00:18:16,186
I think, for the effectiveness and the productivity

280
00:18:16,218 --> 00:18:19,566
of dependent but, and so if you've come from dependent but years ago and you

281
00:18:19,588 --> 00:18:22,862
thought it's too noisy for me, try it again, because this is a big difference

282
00:18:22,916 --> 00:18:26,782
that's enabled now and available. So custom

283
00:18:26,836 --> 00:18:29,986
groups are awesome. I can add those. I can add exclude patterns per group

284
00:18:30,008 --> 00:18:33,186
so I can say include all these, accept these. You can also

285
00:18:33,208 --> 00:18:36,286
do a catch all where you could actually say I want all my dependencies

286
00:18:36,318 --> 00:18:39,646
in one easy pull request. And that makes it nice and easy to validate

287
00:18:39,678 --> 00:18:43,074
and merge when it's successful. But what about when it's not successful?

288
00:18:43,122 --> 00:18:47,346
Then you have to try and filter through and understand exactly which update failed

289
00:18:47,378 --> 00:18:51,702
what? So there can be good and some bad with that. It also supports dependency

290
00:18:51,766 --> 00:18:55,046
types as well. So you can say, hey, I want all of my production dependencies

291
00:18:55,078 --> 00:18:58,166
or development dependencies if your ecosystem supports

292
00:18:58,198 --> 00:19:01,334
that. And of course you can do other update

293
00:19:01,382 --> 00:19:04,466
types to say, I actually only want to update minor or patch versions,

294
00:19:04,518 --> 00:19:07,390
don't give me major version updates. Those are something that I need to plan for.

295
00:19:07,460 --> 00:19:11,374
I can't just have prs being open for. And so the usage of

296
00:19:11,492 --> 00:19:15,506
dependent bot with grouped updates and updates in general is critical. I know,

297
00:19:15,528 --> 00:19:18,882
at SPS commerce, one of the key use cases that we have as well is

298
00:19:18,936 --> 00:19:22,494
inner source distribution, really focusing on velocity.

299
00:19:22,622 --> 00:19:26,118
And so internally when you're setting up a new library and you're distributing it and

300
00:19:26,124 --> 00:19:29,606
your applications are consuming it, typically the only reason

301
00:19:29,708 --> 00:19:33,526
these applications are going to update a version number without something

302
00:19:33,548 --> 00:19:37,446
like Dependabot is because they did an initial install, they're doing

303
00:19:37,468 --> 00:19:40,406
a major upgrade, or they need a feature that's actually as a part of that

304
00:19:40,428 --> 00:19:43,786
and they've been following it. Otherwise the only way you're going to get upgrade is

305
00:19:43,808 --> 00:19:47,146
through Dependabot. And so if you're interested in that at all, feel free to

306
00:19:47,168 --> 00:19:50,822
check out. I have another session at other conferences

307
00:19:50,966 --> 00:19:54,334
called compelling code reuse in the enterprise. You can feel free to Google

308
00:19:54,372 --> 00:19:58,362
that and find it online as well. But this is essential to enabling

309
00:19:58,426 --> 00:20:01,726
inner source distribution and velocity. And you can filter your

310
00:20:01,748 --> 00:20:04,894
updates independent, but by using the allow tag and

311
00:20:04,932 --> 00:20:08,178
saying I actually only want this individual dependency to be updated. And so if you're

312
00:20:08,184 --> 00:20:10,846
not going to use it for the rest, at least use it for your internal

313
00:20:10,878 --> 00:20:12,370
organizational velocity.

314
00:20:14,070 --> 00:20:17,778
And so with that, a couple of thoughts. Some pitfalls. If you're not

315
00:20:17,784 --> 00:20:20,950
using grouped updates, you need to be, because that is a big difference here that

316
00:20:21,020 --> 00:20:24,898
makes it go ten times further. There's no auto merge capability.

317
00:20:24,994 --> 00:20:28,306
So assuming your checks pass and everything's good, there's no ability

318
00:20:28,338 --> 00:20:31,914
to merge it in without some additional extensions or using GitHub actions in order

319
00:20:31,952 --> 00:20:35,946
to accomplish that. And I would love a feature here that allowed us

320
00:20:35,968 --> 00:20:38,890
to look at the package maturity or the package age and say,

321
00:20:38,960 --> 00:20:41,914
I only want to include updates for packages that are x number of days old.

322
00:20:41,952 --> 00:20:45,294
I want someone else to go through the process of finding those particular bugs and

323
00:20:45,332 --> 00:20:48,126
kind of have a pre baked period for that.

324
00:20:48,308 --> 00:20:51,534
There are alternatives. If you're not in the GitHub ecosystem and you're really

325
00:20:51,572 --> 00:20:54,938
liking this one alternative out there, it's kind of deprecated. Now is new keeper.

326
00:20:54,954 --> 00:20:57,902
It was kind of new get specific. But it had just a ton of features

327
00:20:57,966 --> 00:21:01,346
and was really before its time. And a more popular one

328
00:21:01,368 --> 00:21:04,946
then would be renovate that you can make use of and renovate is cross platform

329
00:21:05,048 --> 00:21:08,334
and provides a lot of the same functionality, if not even more capabilities

330
00:21:08,382 --> 00:21:11,646
in some cases. Merge queues if you're using

331
00:21:11,688 --> 00:21:14,086
merge queues, which is a brand new GitHub feature as well, we don't have time

332
00:21:14,108 --> 00:21:17,174
to cover that today. But you can actually integrate and use merge queues along with

333
00:21:17,212 --> 00:21:20,610
dependent bot to try and get some of that grouped update effect in there kind

334
00:21:20,620 --> 00:21:23,578
of throttle some of those deploys a little bit. So that way you can group

335
00:21:23,664 --> 00:21:28,314
a number of merged dependent bot updates all at the same time and

336
00:21:28,352 --> 00:21:31,230
custom dependencies. So looking at this,

337
00:21:31,380 --> 00:21:34,602
trying to understand your dependency chain, what's proprietary,

338
00:21:34,746 --> 00:21:39,006
what's internal, can be helpful, but can also be really

339
00:21:39,108 --> 00:21:42,586
problematic as well. And of course, from a security governance

340
00:21:42,618 --> 00:21:46,562
perspective, enable those defaults, get your dependency graphs on, get your

341
00:21:46,616 --> 00:21:50,206
alerts on, and have access to that s bomb,

342
00:21:50,238 --> 00:21:53,854
and begin to assess what your organizational kind of perspective

343
00:21:53,902 --> 00:21:57,602
looks like from security. And you'll be able to actually see

344
00:21:57,736 --> 00:22:01,026
who's using some of the packages you maybe thought are a little bit funny.

345
00:22:01,218 --> 00:22:04,246
So with that, I want to move on to GitHub advanced security.

346
00:22:04,428 --> 00:22:07,654
And while dependent bot was all about supply chain kind of

347
00:22:07,692 --> 00:22:11,458
scanning other people's code and consuming other people's code, GitHub advanced

348
00:22:11,474 --> 00:22:14,906
security is a feature that is all about thinking about the practices around your

349
00:22:14,928 --> 00:22:18,026
own code security. So now the code that we actually write, and so that's why

350
00:22:18,048 --> 00:22:21,126
it pairs very well. And going back to our introduction,

351
00:22:21,158 --> 00:22:24,586
you'll recall that we talked a lot about this tool. Sprawl and

352
00:22:24,608 --> 00:22:28,094
team silos and Dependpot is great,

353
00:22:28,132 --> 00:22:30,798
but it doesn't necessarily allow you to hook in with other tools. What we're going

354
00:22:30,804 --> 00:22:33,770
to find is that GitHub advanced security provides a centralization,

355
00:22:33,850 --> 00:22:37,746
a mechanism for visibility of not just information that

356
00:22:37,768 --> 00:22:41,138
we're seeing related to GitHub itself that is generated, but how we

357
00:22:41,144 --> 00:22:44,082
can integrate other tools into the same interface as well,

358
00:22:44,136 --> 00:22:47,650
which is a massive advantage compared to what we're seeing elsewhere.

359
00:22:47,990 --> 00:22:50,758
And so we want to do a little bit of an overview. We want to

360
00:22:50,764 --> 00:22:54,274
check out code scanning, and we want to then separately check out CodeqL,

361
00:22:54,322 --> 00:22:57,638
which is going to interact with code scanning to provide some static analysis as a

362
00:22:57,644 --> 00:23:01,126
part of that centralization. And as we get started, we'll see

363
00:23:01,148 --> 00:23:04,380
a couple other components here with GitHub advanced security as well.

364
00:23:04,750 --> 00:23:07,514
First is you're going to be in the same section of security that we were

365
00:23:07,552 --> 00:23:10,026
before for dependent bot, but you're going to scroll down the page a little more

366
00:23:10,048 --> 00:23:13,406
in your settings, and you're going to find GitHub advanced security in there. It's got

367
00:23:13,428 --> 00:23:15,998
these two sections that you can enable here,

368
00:23:16,084 --> 00:23:19,946
enabling then gives you access to code scanning

369
00:23:20,058 --> 00:23:23,434
and secret scanning. And so code scanning

370
00:23:23,482 --> 00:23:26,338
basically is what we're going to focus more on in a minute. But to give

371
00:23:26,344 --> 00:23:29,506
you a preview of secret scanning, we'll see that too.

372
00:23:29,528 --> 00:23:32,866
And that's where we can receive alerts or even block commits to your

373
00:23:32,888 --> 00:23:36,254
repository that it thinks contains secrets.

374
00:23:36,382 --> 00:23:40,226
For GitHub advanced security. It's important you know that this is a paid portion

375
00:23:40,258 --> 00:23:43,526
of the ecosystem. And so depending on if you're a public repo or

376
00:23:43,548 --> 00:23:46,866
you're an enterprise or what your implementation of on premise

377
00:23:46,898 --> 00:23:50,274
is, you'll have to look at the licensing for this. And the licensing

378
00:23:50,322 --> 00:23:53,722
is a bit odd, mind you. It's actually one license per user for every

379
00:23:53,776 --> 00:23:57,526
active committer, which is the last 90 days on your particular repository.

380
00:23:57,638 --> 00:24:01,226
And once you're licensed in that organization, then you don't take up a license in

381
00:24:01,248 --> 00:24:04,160
another repository that's there. So just be mindful of that.

382
00:24:04,770 --> 00:24:08,126
But as we dive into secret scanning, I think you'll find that it's interesting to

383
00:24:08,148 --> 00:24:11,694
see that push protection, when it went

384
00:24:11,732 --> 00:24:14,990
generally available for public root pools, blocked over 17,000

385
00:24:15,060 --> 00:24:19,214
credentials in one year, which is incredible. And so enabling

386
00:24:19,262 --> 00:24:21,858
secret scanning is a no brainer. If you have the license, you're going to want

387
00:24:21,864 --> 00:24:25,666
to turn that on and you can verify then if a secret is valid or

388
00:24:25,688 --> 00:24:29,366
not as well. So as it detects a secret inside your

389
00:24:29,388 --> 00:24:32,934
repository or the code that you're committing can actually go and verify that

390
00:24:32,972 --> 00:24:36,454
with providers. So think about AWS and taking those

391
00:24:36,492 --> 00:24:39,898
particular credentials and seeing that not only did I find credentials that match a

392
00:24:39,904 --> 00:24:43,610
pattern, but I've actually validated these credentials are real and they work.

393
00:24:43,760 --> 00:24:47,430
That's obviously going to raise a much larger security risk

394
00:24:47,510 --> 00:24:51,190
than invalid credentials or credentials that don't match a particular pattern.

395
00:24:51,350 --> 00:24:54,634
And so as we take a look at this and we're thinking about the

396
00:24:54,672 --> 00:24:57,406
number of blocked credentials in a year, think about the impact this can have to

397
00:24:57,428 --> 00:25:01,214
your organization. I'm sure your security team would love that. And in

398
00:25:01,252 --> 00:25:04,858
addition, you can also add custom patterns that you can see there in the background.

399
00:25:04,954 --> 00:25:08,410
You can block the protection. So as someone commits, don't even let them

400
00:25:08,420 --> 00:25:11,586
commit, they're going to see this message here instead that says, hey, I see a

401
00:25:11,608 --> 00:25:14,434
secret in your code. I see a secret in your code based on this custom

402
00:25:14,472 --> 00:25:18,162
pattern or based on our standardized patterns that we see, you might

403
00:25:18,216 --> 00:25:22,166
internally, for example, have your own implementation of a token and you can codify those

404
00:25:22,188 --> 00:25:25,414
patterns across the organization and include them. But better yet,

405
00:25:25,452 --> 00:25:29,110
if you're following GitHub universe, we saw that GitHub copilot, which is

406
00:25:29,260 --> 00:25:32,886
basically finding its integration to everything we do in GitHub,

407
00:25:32,998 --> 00:25:36,650
has the ability to auto detect passwords based on the context and

408
00:25:36,720 --> 00:25:40,614
information around it. So that's exciting to see that being even more effective

409
00:25:40,662 --> 00:25:44,850
for detecting credentials even without custom patterns in place. So that's

410
00:25:44,870 --> 00:25:48,346
great, but let's dive into code scanning. Secret scanning is a no brainer.

411
00:25:48,378 --> 00:25:51,534
Turn that on. If you have a license, there's no reason not to. But code

412
00:25:51,572 --> 00:25:54,666
scanning has a lot more interesting architecture and details

413
00:25:54,698 --> 00:25:58,206
that we need to think about. First of all, recognize that with code scanning it

414
00:25:58,228 --> 00:26:01,138
allows me to include a number of tools. And so you can see here,

415
00:26:01,224 --> 00:26:04,146
first thing it says is, well, what tools would you like to turn on that

416
00:26:04,168 --> 00:26:08,194
can contribute to the code scanning of detecting anomalies

417
00:26:08,242 --> 00:26:12,178
and coding errors? So first is the first class citizen of CodeqL.

418
00:26:12,274 --> 00:26:16,402
CodeqL was a purchased product, or I should say an acquisition to GitHub.

419
00:26:16,546 --> 00:26:20,598
It was originally the product was SEML, and now they've integrated that capability,

420
00:26:20,694 --> 00:26:24,086
first class with integrated CLI that can upload

421
00:26:24,198 --> 00:26:27,418
directly to code scanning capability here. So you

422
00:26:27,424 --> 00:26:31,146
can go ahead and hit the setup option. And this setup option here is going

423
00:26:31,168 --> 00:26:35,102
to create a GitHub action for you essentially, that has this ready to go

424
00:26:35,156 --> 00:26:39,370
that can execute on your repository. And of course you can explore other workflows

425
00:26:39,450 --> 00:26:43,246
and pull those up. And we'll just shelve the idea of codeql here

426
00:26:43,268 --> 00:26:46,558
for a second now, and we'll talk about the interface that code scanning provides

427
00:26:46,654 --> 00:26:50,066
that any tool can contribute to. First, here is the

428
00:26:50,088 --> 00:26:52,898
interface. It looks a lot like dependent bot. In fact, you'll see when I go

429
00:26:52,904 --> 00:26:56,386
to the security tab and I scroll down to the pendantbot section for

430
00:26:56,408 --> 00:26:59,874
vulnerability alerts, or right below that is code scanning. And you also

431
00:26:59,912 --> 00:27:03,206
see there's a secret scanning section. So it's all very nicely outlined on where

432
00:27:03,228 --> 00:27:06,498
you find your alerts on different components. And here under code scanning,

433
00:27:06,514 --> 00:27:09,666
then you get the same classic view the GitHub provides.

434
00:27:09,698 --> 00:27:13,014
Here's a list of the different warnings or critical items or even notes

435
00:27:13,062 --> 00:27:16,250
that we've detected related to your code specifically.

436
00:27:16,910 --> 00:27:20,074
Drilling into one of those then gives you the nice view that you can see

437
00:27:20,112 --> 00:27:23,750
exactly what happened. In this case, it's calling out a generic catch clause,

438
00:27:23,830 --> 00:27:27,326
indicating that you probably should be more specific in your exceptions and not just

439
00:27:27,428 --> 00:27:31,038
grab that. And of course you still have your workflow on the right. You can

440
00:27:31,044 --> 00:27:34,478
see there where you can dismiss a particular code scanning item and say, I'm not

441
00:27:34,484 --> 00:27:38,206
going to fix this, or this is actually just used in tests,

442
00:27:38,238 --> 00:27:41,858
it's not production code, so I'm not going to worry about it. And that information

443
00:27:41,944 --> 00:27:45,730
again is just part of the workflow that tracks. So you can see who and

444
00:27:45,800 --> 00:27:48,950
the reasoning why they might dismiss something with a bit of a description.

445
00:27:49,370 --> 00:27:52,930
And what makes code scanning so great? Not just the centralization

446
00:27:53,010 --> 00:27:56,626
of it, but the fact that it executes on your pull requests.

447
00:27:56,738 --> 00:28:00,166
And so when you're configuring code scanning in the security section, you're going to have

448
00:28:00,188 --> 00:28:03,738
this option to say, what's your pull request check failure? Do I

449
00:28:03,744 --> 00:28:07,338
want to fail pull requests if code scanning detects an error? Probably,

450
00:28:07,424 --> 00:28:11,130
I think so the best thing that we can do is to bring this left

451
00:28:11,200 --> 00:28:14,554
as far as we can, meaning for engineers and developers, the best experience is

452
00:28:14,592 --> 00:28:17,694
I'm submitting a pull request. I'm going to have other people look at and make

453
00:28:17,732 --> 00:28:21,166
comments on the pull request. Why not have code scanning automatically do that

454
00:28:21,188 --> 00:28:23,966
as well, and reject or fail the status check?

455
00:28:24,068 --> 00:28:27,426
That's exactly what I'm doing. That's a zone I'm working in. And so we

456
00:28:27,448 --> 00:28:31,262
can configure the level of failure that we want. We can also configure

457
00:28:31,326 --> 00:28:35,006
a status check here to actually bubble up as a first class citizen.

458
00:28:35,038 --> 00:28:38,078
So you can see that check and see whether it's passing or failing.

459
00:28:38,254 --> 00:28:41,474
But the best part about code scanning on pull requests

460
00:28:41,602 --> 00:28:44,646
is that it actually creates an annotation on your code as well. So just like

461
00:28:44,668 --> 00:28:48,086
any other reviewer, you get that right on your code, only for

462
00:28:48,108 --> 00:28:51,526
the code you changed. You're not actually going to see this for all errors in

463
00:28:51,548 --> 00:28:54,874
your system, that doesn't make it easy for you to get a pull request in.

464
00:28:54,912 --> 00:28:58,266
You need a kind of a baseline start from. But code scanning by default will

465
00:28:58,288 --> 00:29:01,706
only block you if you're introducing a.

466
00:29:01,728 --> 00:29:04,554
Net new item in the code that you've changed.

467
00:29:04,682 --> 00:29:08,190
And so in this case, here's a warning saying I have a useless local variable

468
00:29:08,530 --> 00:29:11,966
and I've also configured to give me code warnings. I don't just care

469
00:29:11,988 --> 00:29:15,546
about security related information, give me some obvious things like unused

470
00:29:15,578 --> 00:29:18,500
variables, because I can just clean up my code too,

471
00:29:19,110 --> 00:29:22,306
once you've worked with it in a pull request like this, it's so nice that

472
00:29:22,328 --> 00:29:25,666
this takes away some of that manual effort that maybe an

473
00:29:25,688 --> 00:29:28,838
individual contributor would have come in and reviewed this and called out some of those

474
00:29:28,844 --> 00:29:31,958
things. I can have all those things obvious things fixed and all the

475
00:29:31,964 --> 00:29:35,318
security problems fixed before a reviewer even gets to my code.

476
00:29:35,484 --> 00:29:38,866
And so in my mind, I love what Mike Lyman says from synopsis.

477
00:29:38,898 --> 00:29:42,066
He says it makes no more sense to write code without code scanning tools

478
00:29:42,098 --> 00:29:44,954
than it does to write a paper without spell check. Just like we're all using

479
00:29:44,992 --> 00:29:48,166
AI now to help us as well. The differences with something like AI

480
00:29:48,198 --> 00:29:51,706
and Copilot is, it still has the

481
00:29:51,728 --> 00:29:55,694
potentiality to write security problems in it too, because it's trained based on our code

482
00:29:55,732 --> 00:29:59,086
basis. So you're going to want to continue to scan all of

483
00:29:59,108 --> 00:30:02,622
your code, no matter where it was generated or who created it.

484
00:30:02,756 --> 00:30:05,886
And so for me, this is fantastic. Correlating alerts from different

485
00:30:05,908 --> 00:30:09,186
tools is labor intensive with many false positives. But now

486
00:30:09,208 --> 00:30:12,222
if I can shift this left as far as possible to the pull request workflow,

487
00:30:12,286 --> 00:30:15,746
this is a huge key in ensuring that these things are fixed before they

488
00:30:15,768 --> 00:30:20,034
even get introduced. And on top of that, with GitHub Copilot

489
00:30:20,162 --> 00:30:23,814
and where it's going to take us, they've introduced the ability to auto fix,

490
00:30:23,932 --> 00:30:27,362
meaning that right on the pull request. Now, when I have something, a useless

491
00:30:27,426 --> 00:30:30,902
assignment to a variable, I can just hit the auto fix button and just clean

492
00:30:30,956 --> 00:30:34,506
that up for me and just make me one step faster to some

493
00:30:34,528 --> 00:30:38,026
of those tedious things that are maybe obvious. But as we

494
00:30:38,048 --> 00:30:41,830
dive in more to this idea of what is code scanning and what is CodeqL,

495
00:30:41,990 --> 00:30:45,438
it might not be entirely separated for you yet. And so I

496
00:30:45,444 --> 00:30:48,574
want to just discuss the differences and where those barriers are a little

497
00:30:48,612 --> 00:30:52,746
bit. Code scanning is the framework, right? It sits on GitHub. It acts

498
00:30:52,778 --> 00:30:56,622
as a user interface that we can interact with that provides alerts and capabilities

499
00:30:56,686 --> 00:31:00,494
that are tracking across the GitHub ecosystem. And you as an engineer,

500
00:31:00,542 --> 00:31:04,290
a developer, and operator, we interact with those, whether at a specific repo or

501
00:31:04,360 --> 00:31:08,094
at an aggregated level in your organization. But code

502
00:31:08,152 --> 00:31:11,686
scanning and the rest of these tools sit outside of that. We choose when

503
00:31:11,708 --> 00:31:15,250
we want to run CodeQL, formerly SEML,

504
00:31:15,330 --> 00:31:18,626
or any of these other great tools that are out there, whether you're using Sonotype

505
00:31:18,658 --> 00:31:22,326
or 42 cronch or checkmarks, all of them can also contribute

506
00:31:22,438 --> 00:31:26,266
and upload information to code scanning, meaning that now I can begin

507
00:31:26,288 --> 00:31:29,574
to pick and choose and use codeQL for code scanning,

508
00:31:29,622 --> 00:31:33,374
but I can use 42 crunch to also submit security analysis on

509
00:31:33,412 --> 00:31:36,714
an open API design. Or I can use another one of these providers

510
00:31:36,762 --> 00:31:39,918
to submit information to code scanning about

511
00:31:40,084 --> 00:31:43,934
infrastructure as code related concerns. So you can explore just

512
00:31:43,972 --> 00:31:46,978
a ton of those other options. When I took this screenshot, there were 67.

513
00:31:47,064 --> 00:31:51,074
I'm sure there's a lot more now, but essentially we get code

514
00:31:51,112 --> 00:31:54,770
security analysis, and that's given to us from CodeQL. That's free.

515
00:31:54,920 --> 00:31:58,806
We get code quality analysis, meaning I've enabled queries that not just for

516
00:31:58,908 --> 00:32:02,758
security, but also those unused local variables and the other gotchas that I want

517
00:32:02,764 --> 00:32:06,306
to call out. It is database driven. So CodeQL

518
00:32:06,338 --> 00:32:09,366
is specifically going to create a database and index all your code locally, and then

519
00:32:09,388 --> 00:32:12,806
you'll fire queries against it. That's how it operates. But the

520
00:32:12,828 --> 00:32:15,974
queries that it runs are also open source queries that you can find on GitHub

521
00:32:16,022 --> 00:32:19,354
today. You can take a look at and understand completely what kind of things

522
00:32:19,392 --> 00:32:22,586
it's searching for in the code, and you're going to find that. CodeQL is pretty

523
00:32:22,608 --> 00:32:26,334
well adopted across a ton of languages in the GitHub ecosystem, and these are definitely

524
00:32:26,372 --> 00:32:29,758
all the core languages that we use at SPS commerce, since that makes a lot

525
00:32:29,764 --> 00:32:33,258
of sense. But the key is that whatever tool you're

526
00:32:33,274 --> 00:32:36,386
using, each of them are going to kind of execute differently. And you'll have to

527
00:32:36,408 --> 00:32:40,674
investigate and explore that and figure but how you're going to upload then information

528
00:32:40,872 --> 00:32:45,006
into the code scanning framework. Here's how it works for CodeQL specifically.

529
00:32:45,038 --> 00:32:48,338
You'll have a GitHub repository, you'll have a

530
00:32:48,504 --> 00:32:51,638
database create option. So you're going to call CodeQL database create.

531
00:32:51,724 --> 00:32:55,158
You can say, here's my language, here is the database that

532
00:32:55,164 --> 00:32:58,406
I want to create, and it's going to go and index against a

533
00:32:58,508 --> 00:33:01,994
repository that you give it. And you can specify other

534
00:33:02,032 --> 00:33:05,514
custom build commands that you want or many other overrides here.

535
00:33:05,632 --> 00:33:09,526
But it's going to look at the CodeQL query packs and code queries that existing

536
00:33:09,558 --> 00:33:13,350
on GitHub today. CodeQL, it's going to create that database

537
00:33:13,510 --> 00:33:16,926
and then we're going to specify that query packs that we want to use here.

538
00:33:16,948 --> 00:33:20,686
It's a QLS and the database that was created and

539
00:33:20,708 --> 00:33:23,374
we're going to say create a serif file from this. So now it's basically taking

540
00:33:23,412 --> 00:33:26,654
the database, taking the queries and executing all those commands.

541
00:33:26,782 --> 00:33:30,498
The output of that then is a serif file. And a

542
00:33:30,504 --> 00:33:34,174
serif file, if you're not familiar with that, is a static analysis results interchange

543
00:33:34,222 --> 00:33:37,358
format. It streamlines how static analysis tools share results. So it's

544
00:33:37,374 --> 00:33:40,886
a generic JSON schema essentially. And so you can

545
00:33:40,908 --> 00:33:44,534
follow that schema by creating your own tools and uploaded code scanning or using

546
00:33:44,572 --> 00:33:47,446
many of the existing tools that can follow that format and upload to it.

547
00:33:47,548 --> 00:33:52,086
Now, of course, with the tight integration that we see between CodeQL

548
00:33:52,118 --> 00:33:55,846
and GitHub, CodeQL CLI comes built in with a CodeQL

549
00:33:55,878 --> 00:33:59,306
GitHub upload results, which is hitting an API endpoint that I can

550
00:33:59,328 --> 00:34:03,246
pass the serif file to on that particular repository and that's it.

551
00:34:03,268 --> 00:34:07,274
It's submitted to code scanning pretty easy and you can commit multiple

552
00:34:07,322 --> 00:34:10,842
configurations to that. So different subdirectories, different tools,

553
00:34:10,906 --> 00:34:14,942
they can all contribute and create this suite of capabilities that you're now

554
00:34:14,996 --> 00:34:18,734
analyzing against your code base. Be asking, what is a CodeQL

555
00:34:18,782 --> 00:34:22,226
query exactly? I'm no expert on CodeQL queries. I'm still

556
00:34:22,248 --> 00:34:25,726
learning as well. But think of it as a standard kind of SQL

557
00:34:25,758 --> 00:34:29,474
like query language that you can kind of drive. Where you're importing libraries,

558
00:34:29,522 --> 00:34:32,966
you're using a from statement, a where statement, and a select statement. Here's an

559
00:34:32,988 --> 00:34:37,350
example how you can really simply find an empty if statement

560
00:34:37,930 --> 00:34:41,542
and then go ahead and write that as a custom

561
00:34:41,596 --> 00:34:44,746
query. And so there's lots of tutorials you can find online about that for

562
00:34:44,768 --> 00:34:48,394
writing custom queries. You can also define custom query packs, meaning I can just

563
00:34:48,432 --> 00:34:52,438
configure the exact number of queries that I want to use in a YAML file

564
00:34:52,534 --> 00:34:56,538
and then provide that to the CodeQL CLi as well to really fine tune

565
00:34:56,554 --> 00:34:59,998
it. And they also come and query suites too. And you can create your

566
00:35:00,004 --> 00:35:03,214
own suites internally for your organization. What makes sense for you? Kind of pull

567
00:35:03,252 --> 00:35:06,738
those together. There is a vs code extension that can make that easy,

568
00:35:06,904 --> 00:35:09,140
but you can see that generally speaking,

569
00:35:09,750 --> 00:35:13,534
the CodeQL repository itself, where the open source maintained queries

570
00:35:13,582 --> 00:35:17,266
are, is fairly popular, fairly regular, and is in

571
00:35:17,288 --> 00:35:20,706
my opinion maintained by lots of great experts. And so I'm

572
00:35:20,738 --> 00:35:23,206
glad to be able to pull in what they're doing, but also augment it with

573
00:35:23,228 --> 00:35:25,880
some of the small minute things I might want to add.

574
00:35:26,330 --> 00:35:29,798
So advanced security provides a ton of stuff, but there can be a

575
00:35:29,804 --> 00:35:32,634
high setup cost and that depends. Are you using GitHub actions? It can be easy

576
00:35:32,672 --> 00:35:36,582
to set up, but do you have specific dependencies?

577
00:35:36,646 --> 00:35:39,978
Do you have specific requirements in order to build it that don't need

578
00:35:39,984 --> 00:35:43,466
to be integrated with it? It will take a little bit of architectural understanding

579
00:35:43,498 --> 00:35:46,782
in order to put that together, but in some cases it's as simple as running

580
00:35:46,836 --> 00:35:50,654
the CLI tool, understanding your build command and away you go.

581
00:35:50,852 --> 00:35:54,570
Dynastray says 62% of organizations use four or more solutions.

582
00:35:54,650 --> 00:35:58,610
Well, I'm really glad that this is a simple integrated experience. This is one

583
00:35:58,680 --> 00:36:02,194
final solution that we can put a lot of backing behind and

584
00:36:02,232 --> 00:36:05,762
see it in one central pane of glass. It is remote only

585
00:36:05,816 --> 00:36:08,854
and that's something to consider. A lot of our teams have asked about. Well,

586
00:36:08,892 --> 00:36:12,338
I want some of that analysis done in my Ide locally

587
00:36:12,434 --> 00:36:15,766
and you can see that information in your ide when

588
00:36:15,788 --> 00:36:18,726
it pulls it from GitHub and you can see it locally and highlighted in your

589
00:36:18,748 --> 00:36:22,026
code, but it's not generated locally. It has to be done on the server or

590
00:36:22,048 --> 00:36:25,414
you have to do it as part of the Codeql Cli commands.

591
00:36:25,462 --> 00:36:29,034
And that can take three, four, five minutes. So this is not something

592
00:36:29,072 --> 00:36:32,682
that is comparable to linting in real time where you'll get those results. It's there,

593
00:36:32,736 --> 00:36:36,078
and GitHub has indicated that's not their intention either. So you might want

594
00:36:36,084 --> 00:36:39,418
to look elsewhere for some of those easier linting problems that you're solving.

595
00:36:39,594 --> 00:36:43,326
And of course, the VS code extension helps you pull down that information and see

596
00:36:43,348 --> 00:36:47,134
it and pull request workflow is fantastic. We all use that workflow

597
00:36:47,182 --> 00:36:50,018
at our organization. And if you are, this is a great place where you can

598
00:36:50,024 --> 00:36:53,486
put it in organizationally from a governance perspective and begin to rally

599
00:36:53,518 --> 00:36:56,994
around it. Depending on where you're at and what

600
00:36:57,032 --> 00:37:00,418
your investment in GitHub is, the cost can be significant, but we've

601
00:37:00,434 --> 00:37:03,698
found it to be actually significantly lower than some of the other comparables

602
00:37:03,714 --> 00:37:06,578
and some of the other tools out there that would do something similar. So there's

603
00:37:06,594 --> 00:37:10,326
a really nice blend of capabilities and getting code scanning and then

604
00:37:10,428 --> 00:37:13,100
using CodeqL as part of that for free.

605
00:37:14,670 --> 00:37:17,914
As we said, you can write custom queries, you can bring your own. I'm really

606
00:37:17,952 --> 00:37:21,814
looking for custom queries that we can write on YamL and JSON and basically non

607
00:37:21,862 --> 00:37:26,122
supported languages. Even so, I can detect other things and other linting warnings

608
00:37:26,186 --> 00:37:29,818
and other kind of organizational problems in our code bases

609
00:37:29,834 --> 00:37:33,406
that we're seeing. But the complexity to writing custom queries does take

610
00:37:33,428 --> 00:37:35,998
a little bit of onboarding experience and knowledge to get started with. So it's not

611
00:37:36,004 --> 00:37:39,266
the simplest. And in terms of interoperability, it's a

612
00:37:39,288 --> 00:37:42,786
huge win here. Ecosystem of tools in the standard serif format to

613
00:37:42,808 --> 00:37:46,286
even build your own integration is the win that you're

614
00:37:46,318 --> 00:37:48,914
looking for, I believe, and this is what we're looking for in terms of building

615
00:37:48,952 --> 00:37:52,486
our ecosystem of security tools together. So that's all

616
00:37:52,508 --> 00:37:55,506
the time that we have for today. Thanks for checking out this talk on fortifying

617
00:37:55,538 --> 00:37:58,838
codebase with GitHub. I hope these two tools are something you're able

618
00:37:58,844 --> 00:38:02,954
to take advantage of, especially dependent bot. That one's really easy to get started with.

619
00:38:03,072 --> 00:38:06,474
Code security is a little bit more involved, but not that

620
00:38:06,512 --> 00:38:09,110
difficult either, especially if you're already on GitHub actions.

621
00:38:09,270 --> 00:38:12,186
And at the end of the day, this comes down to this quote that we

622
00:38:12,208 --> 00:38:15,706
started, which is that developers work in rainforest, not planned gardens. And so if

623
00:38:15,728 --> 00:38:18,918
we can bring the GitHub ecosystem a little bit more to being that planned garden

624
00:38:18,934 --> 00:38:22,418
for engineers, let's give them that quality of life and let's continue to

625
00:38:22,424 --> 00:38:26,046
work towards this centralized ecosystem and this single pane of glass.

626
00:38:26,158 --> 00:38:28,320
So, thanks all, and we'll catch you at another talk.

