1
00:00:00,410 --> 00:00:06,174
Jamaica real

2
00:00:06,212 --> 00:00:09,578
time feedback into the behavior of your distributed systems

3
00:00:09,674 --> 00:00:13,374
and observing changes exceptions errors in

4
00:00:13,412 --> 00:00:16,746
real time allows you to not only experiment with confidence,

5
00:00:16,858 --> 00:00:20,480
but respond instantly to get things working again.

6
00:00:24,610 --> 00:00:47,274
Close hi

7
00:00:47,312 --> 00:00:50,646
there folks, thanks so much for taking your time today to join

8
00:00:50,678 --> 00:00:54,970
me to talk about my favorite topic. That's serverless application development,

9
00:00:55,130 --> 00:00:58,954
and I want to get into talking about what serverless development

10
00:00:59,002 --> 00:01:02,880
is and how it is changing the world for you as a developer today.

11
00:01:03,250 --> 00:01:06,482
Those that aren't aware my name is Gareth McCumskey. I am

12
00:01:06,536 --> 00:01:10,194
a developer advocate and customer success engineer at Serverless Inc.

13
00:01:10,232 --> 00:01:13,394
The creators of the serverless framework, and I've been

14
00:01:13,432 --> 00:01:17,214
building serverless applications since around 2016 and joined serverless

15
00:01:17,262 --> 00:01:20,754
back in 2019 to help the company assist

16
00:01:20,802 --> 00:01:24,002
users and customers with building serverless applications.

17
00:01:24,146 --> 00:01:27,542
So let's get into it, and we have quite a lot to discuss today,

18
00:01:27,596 --> 00:01:30,434
so forgive me if I go a little bit quickly at times. Thankfully,

19
00:01:30,482 --> 00:01:33,706
being in a video format, you can pause, rewind, slow it down, speed it

20
00:01:33,728 --> 00:01:36,986
up, even if you prefer. And to get us started, I really wanted to take

21
00:01:37,008 --> 00:01:40,346
a look at defining what serverless is because there are

22
00:01:40,368 --> 00:01:43,466
a lot of people talking about what serverless is with different definitions and so

23
00:01:43,488 --> 00:01:46,734
on. So I thought, let's start with that. Let's define what I mean

24
00:01:46,772 --> 00:01:50,174
by serverless. So we're all kind of on the same page. And what

25
00:01:50,212 --> 00:01:54,240
we find today is traditionally your application that you're building

26
00:01:54,610 --> 00:01:57,954
ends up just being a collection of code, and it's this huge pile of code

27
00:01:57,992 --> 00:02:01,854
that you've got that makes your application what it is. And what serverless

28
00:02:01,902 --> 00:02:05,394
is, is about taking that existing application youll have and

29
00:02:05,432 --> 00:02:09,110
breaking it up in a way to use the cloud serverless available to you

30
00:02:09,260 --> 00:02:12,870
in services such as AWS, Google Cloud,

31
00:02:12,940 --> 00:02:16,438
Azure and so on. And this is not just

32
00:02:16,524 --> 00:02:20,198
about taking that nice big chunk of code you've

33
00:02:20,294 --> 00:02:24,998
got running on now and just picking it up and dropping it into Lambda.

34
00:02:25,174 --> 00:02:28,586
What this is is about architecting your application to

35
00:02:28,608 --> 00:02:32,266
make the best use of the cloud services that are available to you. And this

36
00:02:32,288 --> 00:02:36,014
is what is often referred to as being cloud native. We're building

37
00:02:36,052 --> 00:02:39,550
our application to make use of the cloud services, as opposed to

38
00:02:39,620 --> 00:02:43,086
building youll application and happen to be using cloud services to

39
00:02:43,108 --> 00:02:44,080
make it run.

40
00:02:46,130 --> 00:02:50,338
So you'd be building your app. Something like this is a very simple example,

41
00:02:50,424 --> 00:02:53,906
obviously, but you've got your front end and your back end. Your back end is

42
00:02:53,928 --> 00:02:57,086
often defined with exprs, where it's managing

43
00:02:57,118 --> 00:03:00,566
the routing for you, and you've got your front end with your HTML JavaScript and

44
00:03:00,588 --> 00:03:04,406
CSS, and it's all one big pile of code. You have a server somewhere that

45
00:03:04,428 --> 00:03:08,074
you're going to put that machine on. You have a web server application

46
00:03:08,192 --> 00:03:12,678
like an Nginx or an Apache that receives HTTP requests,

47
00:03:12,854 --> 00:03:16,234
and that application software will then format the

48
00:03:16,272 --> 00:03:20,246
incoming HTTP request in a way that exprs and other frameworks

49
00:03:20,278 --> 00:03:23,946
can understand it. What serverless development

50
00:03:23,978 --> 00:03:27,646
does is a bit different. So typically what you'll find in

51
00:03:27,668 --> 00:03:31,786
serverless development is that youll have a separation between a front end and a backend.

52
00:03:31,978 --> 00:03:35,474
This is also where Jamstack becomes really useful if you have

53
00:03:35,512 --> 00:03:38,980
a static front end, but there are ways as well to do

54
00:03:41,510 --> 00:03:44,894
dynamic back ends. So typically

55
00:03:44,942 --> 00:03:48,698
in a serverless application what you'll find on the front end side is in AWS

56
00:03:48,734 --> 00:03:52,534
for example. And I'll be talking about AWS specifically because it's this

57
00:03:52,652 --> 00:03:56,694
cloud vendor that I'm the most familiar with, but you'll have a service like s

58
00:03:56,732 --> 00:04:00,486
three. S three is a really great cloud service for storing files

59
00:04:00,518 --> 00:04:04,106
including HTML, CSS and JavaScript, and your front end is

60
00:04:04,128 --> 00:04:07,946
then expressed using those three technologies. JavaScript is then used to

61
00:04:07,968 --> 00:04:11,466
help make your site dynamic and query. Youll backend and

62
00:04:11,488 --> 00:04:15,710
in youll front end you'll probably want a can of some type. So AWS provides

63
00:04:16,450 --> 00:04:19,870
cloudfront to act as your CDN across the globe,

64
00:04:20,210 --> 00:04:23,646
and now you've got a front end making requests into a backend. So you need

65
00:04:23,668 --> 00:04:27,154
a way to receive HTTP requests for your backend. And this is often

66
00:04:27,192 --> 00:04:30,878
done in AWS with a service called API gateway.

67
00:04:31,054 --> 00:04:35,438
Instead of having application software that is receiving incoming HTTP requests

68
00:04:35,534 --> 00:04:38,854
and formatting it for your code, API gateway will

69
00:04:38,892 --> 00:04:42,786
actually expose endpoints that can receive those incoming

70
00:04:42,818 --> 00:04:46,582
requests. There's no server involved in that. And then using

71
00:04:46,636 --> 00:04:50,454
the path thing that's provided, automatically route that to the correct chunk of code

72
00:04:50,492 --> 00:04:53,866
for you. There's no code that you had to write to set

73
00:04:53,888 --> 00:04:57,578
up that routing, and that's where lambda comes in. Lambda will be the code

74
00:04:57,664 --> 00:05:01,206
that you then execute when it receives the HTTP

75
00:05:01,238 --> 00:05:04,958
request formatted for the lambda function. Then lambda will obviously have

76
00:05:04,964 --> 00:05:08,366
to talk to database of some type usually. And in the serverless world, especially in

77
00:05:08,388 --> 00:05:11,918
AWS, this is often done using Dynamodb as a

78
00:05:11,924 --> 00:05:15,294
database, just because it's a fully managed data store. This is the

79
00:05:15,332 --> 00:05:19,074
sort of rough, very basic macro overview of what a serverless application can

80
00:05:19,112 --> 00:05:21,870
look like. There's a lot more stuff that you can do and a bit nuanced,

81
00:05:21,950 --> 00:05:24,900
but those are the basics. So looking at this,

82
00:05:26,550 --> 00:05:30,134
there are a lot of advantages as well to building serverless applications, and I wanted

83
00:05:30,172 --> 00:05:33,474
to cover them. If you've heard people talk about serverless,

84
00:05:33,522 --> 00:05:36,610
you've probably heard them mention these specific advantages,

85
00:05:36,770 --> 00:05:40,438
one of them being that there's no infrastructure management, especially if you're using services

86
00:05:40,524 --> 00:05:43,926
like S three lambda API, gateway and so on that are fully

87
00:05:43,958 --> 00:05:47,018
managed. There's no machines or cpus or RAM or

88
00:05:47,024 --> 00:05:50,602
anything like that you need to worry about. But even if you add on

89
00:05:50,736 --> 00:05:54,318
services like RDS, which is the relational database service,

90
00:05:54,404 --> 00:05:57,486
or an elastic search type service,

91
00:05:57,668 --> 00:06:00,926
while you still have to worry about the cluster sizes and so on, there is

92
00:06:00,948 --> 00:06:05,330
still nothing for you to maintain as far as application software updates,

93
00:06:05,910 --> 00:06:09,874
making sure about bugs and so on. This is really useful and

94
00:06:09,912 --> 00:06:13,122
it can be very time saving. And this time saving

95
00:06:13,176 --> 00:06:16,750
that you get from the production in infrastructure management

96
00:06:16,830 --> 00:06:19,894
means that you can spend more time building features and getting

97
00:06:19,932 --> 00:06:23,254
stuff done. Accelerated time to market means that your business

98
00:06:23,372 --> 00:06:27,126
is putting stuff in front of users faster and earning revenue sooner, which is often

99
00:06:27,228 --> 00:06:30,774
very important for a business. Another really great benefit is that

100
00:06:30,812 --> 00:06:34,202
with serverless development, often you only pay for what you actually use.

101
00:06:34,336 --> 00:06:37,718
Lambda doesn't cost you anything at 02:00 a.m. When there's no users

102
00:06:37,734 --> 00:06:41,434
on your site, unlike a server that's sitting around waiting for traffic to happen,

103
00:06:41,472 --> 00:06:44,650
you're still getting billed even when nothing is actually happening.

104
00:06:44,800 --> 00:06:47,614
So really useful for that.

105
00:06:47,812 --> 00:06:50,958
And traffic management is often built into these services as well.

106
00:06:51,044 --> 00:06:54,998
If you suddenly have a spike of users, there's often capacity in services like API,

107
00:06:55,034 --> 00:06:58,654
Gateway and Lambda and so on to manage these bursts of traffic

108
00:06:58,702 --> 00:07:02,814
and in the ability to automatically scale and to handle larger

109
00:07:02,942 --> 00:07:06,626
amounts of traffic as it starts coming in, which is really useful, something that you

110
00:07:06,648 --> 00:07:10,098
don't have to worry about now. But there's also other advantages to serverless,

111
00:07:10,114 --> 00:07:13,320
and that's really what my talk is going to be discussing in more detail today.

112
00:07:13,770 --> 00:07:16,994
The not so usual things that change the way we as developers

113
00:07:17,042 --> 00:07:21,210
build applications for the better, and pretty big deals as well.

114
00:07:21,360 --> 00:07:25,222
This is the kind of stuff that we figured out after years of building serverless

115
00:07:25,286 --> 00:07:28,940
applications, working with teams of customers,

116
00:07:29,310 --> 00:07:32,526
working with these teams to figure out how to structure and build

117
00:07:32,548 --> 00:07:36,394
their serverless applications, and ourselves, we've been building serverless applications

118
00:07:36,442 --> 00:07:39,582
ourselves, as well as services and products to provide

119
00:07:39,636 --> 00:07:42,958
to our customers. And frameworks are a

120
00:07:42,964 --> 00:07:46,526
very integral part of building a serverless application. Now, what you're

121
00:07:46,558 --> 00:07:49,858
seeing in front of you here is an example of a configuration file for the

122
00:07:49,864 --> 00:07:53,966
serverless framework, where I am essentially creating an HTTP

123
00:07:53,998 --> 00:07:57,630
endpoint. This could be the start of my rest API that I'm busy building.

124
00:07:57,800 --> 00:08:00,786
And really what this does is with a single command,

125
00:08:00,818 --> 00:08:04,582
a serverless deploy command. This will connect to my AWS account.

126
00:08:04,716 --> 00:08:08,694
It will create an API gateway endpoint for me. It will upload my lambda function

127
00:08:08,732 --> 00:08:12,282
that's in the file called handler js with a function called

128
00:08:12,336 --> 00:08:16,486
hello. And that code will then get triggered when a HTTP

129
00:08:16,518 --> 00:08:20,246
request is made on the endpoint that's generated from API gateway.

130
00:08:20,358 --> 00:08:23,814
All of this is automatically set up for me, along with permissions, IAM policies

131
00:08:23,862 --> 00:08:26,974
and so on. I don't need to worry about setting any of that up.

132
00:08:27,092 --> 00:08:31,120
Anybody in my team can now take this configuration file and deploy it into their

133
00:08:31,490 --> 00:08:35,026
AWS account, and we can both be working on the

134
00:08:35,048 --> 00:08:38,594
same the synchronization of these tools is

135
00:08:38,632 --> 00:08:42,530
maintained in the cloud. I don't need to worry about whether my application

136
00:08:42,600 --> 00:08:46,158
is synchronized or not, and I can make changes to this configuration file,

137
00:08:46,174 --> 00:08:49,526
run a serverless deploy command, and it'll just make the changes in the

138
00:08:49,548 --> 00:08:53,046
cloud for me automatically. So if you are looking at

139
00:08:53,068 --> 00:08:57,046
building serverless applications, you could go to your AWS console and create an

140
00:08:57,068 --> 00:09:00,586
API gateway endpoint and upload your lambda function and then try to connect the

141
00:09:00,608 --> 00:09:03,974
two manually. But that doesn't allow you to share things, doesn't allow you to easily

142
00:09:04,022 --> 00:09:07,414
debug, and so on. So using a framework

143
00:09:07,462 --> 00:09:10,570
of some type is almost absolutely required.

144
00:09:11,310 --> 00:09:14,414
I know the serverless framework. It's what I know really well. There are many others

145
00:09:14,452 --> 00:09:17,120
out there, so there's a lot of choice for you to have.

146
00:09:17,650 --> 00:09:21,486
Let's start taking a look at these other advantages I was talking about that makes

147
00:09:21,588 --> 00:09:25,458
serverless application development so awesome and can rapidly change what we do

148
00:09:25,544 --> 00:09:29,106
as developers. And the first one is that ultimately we end

149
00:09:29,128 --> 00:09:32,626
up being closer to production, which is really useful feature to

150
00:09:32,648 --> 00:09:36,242
have. Additionally, we have to develop

151
00:09:36,296 --> 00:09:39,890
and test locally. Youll are going to be writing your code on youll own machine,

152
00:09:39,970 --> 00:09:42,342
and then you're going to have some kind of environment, might be very simple,

153
00:09:42,396 --> 00:09:46,322
might be really complex to test the code that you've written

154
00:09:46,386 --> 00:09:49,766
on your own machine before you do anything else, to make sure it does what

155
00:09:49,788 --> 00:09:53,014
you needed to do accomplishes the feature that you're coding for.

156
00:09:53,132 --> 00:09:56,218
And once you've done that, the whole team might get together and you've merged a

157
00:09:56,224 --> 00:09:59,626
bunch of code changes together and you're planning a release. It might be at

158
00:09:59,648 --> 00:10:02,826
the end of your two week sprint, you start compiling all this stuff together that

159
00:10:02,848 --> 00:10:06,478
the team's been working on, then ultimately that has to get passed over to

160
00:10:06,484 --> 00:10:09,726
DevOps. Maybe that's just somebody else on the team, maybe that's an entirely different team.

161
00:10:09,828 --> 00:10:13,566
But your code then needs to go to production, and the

162
00:10:13,588 --> 00:10:17,042
phrase is toss it over the wall to developers and then

163
00:10:17,096 --> 00:10:21,074
the app breaks. For some reason there was a

164
00:10:21,112 --> 00:10:24,386
feature that youll coded on your local machine that doesn't quite work that way in

165
00:10:24,408 --> 00:10:27,986
production. There are too many differences between the two environments

166
00:10:28,098 --> 00:10:31,782
for you to absolutely 100% guarantee that you're building things

167
00:10:31,836 --> 00:10:35,606
that work across both. And what has

168
00:10:35,628 --> 00:10:39,494
happened is that teams have started moving towards better release configurations

169
00:10:39,542 --> 00:10:43,146
so that they can release more often, potentially, or a little

170
00:10:43,168 --> 00:10:46,406
bit more cleanly, or have interim deployment environments, like a staging

171
00:10:46,438 --> 00:10:49,994
environment. But ultimately you're still expecting something

172
00:10:50,032 --> 00:10:53,518
that you've built on your local machine to work in production as is,

173
00:10:53,604 --> 00:10:57,070
to a large degree, and it can be pretty inaccurate.

174
00:10:57,410 --> 00:11:00,606
So what we find in the serverless world, what we tend to

175
00:11:00,628 --> 00:11:04,242
recommend, is that local emulation is really, really hard to do,

176
00:11:04,296 --> 00:11:08,178
because cloud services are very difficult to run

177
00:11:08,344 --> 00:11:12,420
locally. Even getting

178
00:11:13,190 --> 00:11:16,942
a replica of production in the traditional sense, using something like vagrant or docker,

179
00:11:17,006 --> 00:11:20,678
can be a tricky thing to do to some level of accuracy. Now that

180
00:11:20,684 --> 00:11:24,406
you're using cloud services, this becomes even more difficult. This isn't necessarily a

181
00:11:24,428 --> 00:11:27,846
bad thing. What this does is make it more appropriate for

182
00:11:27,868 --> 00:11:31,526
us to consider using the cloud directly. So a better development

183
00:11:31,558 --> 00:11:34,890
model is to push the changes to the cloud and rather test

184
00:11:34,960 --> 00:11:38,454
there. Now, for some, this may seem

185
00:11:38,502 --> 00:11:42,214
like a, it might seem like you have a bit of a slow development

186
00:11:42,262 --> 00:11:45,486
cycle. You first make the changes, then you push it to the cloud, and then

187
00:11:45,508 --> 00:11:49,214
you test, and so on. But there are a lot of benefits to doing it

188
00:11:49,252 --> 00:11:52,814
directly in production, instead of trying to test locally and then push into production

189
00:11:52,862 --> 00:11:56,706
later. Ultimately, you can very easily and

190
00:11:56,728 --> 00:12:00,354
quickly deployed into a replica of production that

191
00:12:00,392 --> 00:12:04,094
is exactly the same as production. You are essentially

192
00:12:04,142 --> 00:12:07,590
deploying into production when you develop and test directly in the cloud.

193
00:12:07,740 --> 00:12:12,022
So there is no difference between production and

194
00:12:12,076 --> 00:12:15,702
your local testing environment. Apart from configuration settings. There's no

195
00:12:15,756 --> 00:12:19,270
cpu difference, there's no hard drive difference, there's no library

196
00:12:19,350 --> 00:12:23,020
difference. Everything is pretty much exactly the same between

197
00:12:23,550 --> 00:12:26,614
your testing environment and your production environment, which reduces

198
00:12:26,742 --> 00:12:30,026
that difference massively. Not to

199
00:12:30,048 --> 00:12:33,538
mention, even if you could set up a local testing environment

200
00:12:33,574 --> 00:12:36,686
to some degree, there are a lot of things about the cloud that

201
00:12:36,708 --> 00:12:39,818
are just obviously possible to actually test locally.

202
00:12:39,914 --> 00:12:43,502
IAM is a service in AWS that manages permissions between services.

203
00:12:43,636 --> 00:12:47,774
It's very difficult to emulate that locally. There are latencies

204
00:12:47,822 --> 00:12:51,534
between services. IAM itself adds latency between services, and you can't

205
00:12:51,582 --> 00:12:55,330
really test the impact that latencies between services will have on your application

206
00:12:55,400 --> 00:12:58,562
if they're all running on your local machine, not to mention concurrency.

207
00:12:58,626 --> 00:13:01,986
Issues of running multiple services in parallel altogether,

208
00:13:02,098 --> 00:13:06,166
API validations and an absolute ton more. There's so much more that

209
00:13:06,188 --> 00:13:09,414
you actually cannot test on a local machine. And in order

210
00:13:09,452 --> 00:13:12,666
to do this, this is where the advantage of frameworks comes in,

211
00:13:12,688 --> 00:13:16,342
is that the serverless framework, for example, provides a way for you to edit

212
00:13:16,406 --> 00:13:20,442
your lambda function code and immediately deploy that into the cloud within

213
00:13:20,496 --> 00:13:23,886
seconds using the serverless deploy function command. At that point you

214
00:13:23,908 --> 00:13:27,406
can then tail the logs in the cloud. You can run

215
00:13:27,428 --> 00:13:30,078
an invoke command to execute the code in the cloud,

216
00:13:30,164 --> 00:13:33,326
or use your curl command or whatever it is

217
00:13:33,348 --> 00:13:37,294
to actually execute the function. So you deploy within seconds,

218
00:13:37,342 --> 00:13:40,626
test, read the logs, continue to iterate and change and

219
00:13:40,648 --> 00:13:44,850
make changes directly in the cloud. No difference with production. Really, really powerful.

220
00:13:45,190 --> 00:13:48,998
So I want to take one step back from that. One nice thing about

221
00:13:49,164 --> 00:13:53,046
building stuff in the cloud is that lambda as

222
00:13:53,068 --> 00:13:56,200
a way to execute code is really forgiving of bad code.

223
00:13:57,290 --> 00:14:00,822
If you've been building stuff on servers in the traditional

224
00:14:00,886 --> 00:14:04,090
sense, youll might have experienced the issue

225
00:14:04,160 --> 00:14:07,990
where you've written maybe a really bad for or while loop

226
00:14:08,150 --> 00:14:11,734
and that code isn't optimal, and it starts

227
00:14:11,782 --> 00:14:15,598
having a massively negative impact on the performance of your application as a

228
00:14:15,604 --> 00:14:19,550
whole. It affects the entire application stack, all your users are affected.

229
00:14:19,970 --> 00:14:23,550
This is because there are shared resources between threads.

230
00:14:23,710 --> 00:14:28,574
When you have a single execution,

231
00:14:28,622 --> 00:14:32,018
a single user executing your code, and it hits a

232
00:14:32,024 --> 00:14:35,618
bad for loop or any other type of code, it's going

233
00:14:35,624 --> 00:14:38,838
to bottle up cpu, it's going to affect all the other users that happen to

234
00:14:38,844 --> 00:14:42,310
be on that machine at the same time and really negatively impact your entire

235
00:14:42,380 --> 00:14:46,434
application. And clustering as a solution helps somewhat,

236
00:14:46,482 --> 00:14:50,550
but ultimately as more and more users come on board, start executing

237
00:14:51,450 --> 00:14:54,778
the code that is not performant, and starts bottling up more and

238
00:14:54,784 --> 00:14:57,386
more cpu, you're going to be spinning up more and more machines as a part

239
00:14:57,408 --> 00:15:00,694
of your cluster if you have auto scaling, for example, and ultimately

240
00:15:00,742 --> 00:15:04,346
they're all using to get swamped. So this can be really bad.

241
00:15:04,368 --> 00:15:07,806
This is why we have so many developers spending so much time

242
00:15:07,828 --> 00:15:11,166
and effort trying to make sure they write optimal, well performing code, because it can

243
00:15:11,188 --> 00:15:14,782
have a really disastrous effect on your cluster of machines that you run.

244
00:15:14,916 --> 00:15:18,382
Containerization as a way to help manage this helps to some degree,

245
00:15:18,446 --> 00:15:21,662
but it can only help so much because ultimately even those containers

246
00:15:21,726 --> 00:15:25,514
are running on an actual cpu. And the containerization

247
00:15:25,582 --> 00:15:29,314
methods used in the traditional sense, like Docker, aren't specifically

248
00:15:29,362 --> 00:15:32,786
designed to limit the impact on cpu

249
00:15:32,898 --> 00:15:36,834
as much as tools like lambda are. So in the serverless

250
00:15:36,882 --> 00:15:39,914
world, single lambda executes very much in its

251
00:15:39,952 --> 00:15:44,358
own context, and is specifically designed this way. The firecracker

252
00:15:44,534 --> 00:15:48,166
virtual machine technology built by AWS, for example, for lambda

253
00:15:48,278 --> 00:15:51,502
is different to Docker in that it is specifically designed to help

254
00:15:51,556 --> 00:15:54,814
constrain CPU and other resource usage within

255
00:15:54,852 --> 00:15:58,010
the context of the lambda, very, very tightly controlled.

256
00:15:58,170 --> 00:16:01,562
And there's been extensive

257
00:16:01,626 --> 00:16:03,710
testing done on this impact.

258
00:16:04,610 --> 00:16:08,020
Lambda also has built in timeout, so even if the code is

259
00:16:08,390 --> 00:16:12,450
so bad that the execution continues,

260
00:16:13,430 --> 00:16:16,706
it'll eventually reach a timeout. There is a timeout even if you don't set one

261
00:16:16,728 --> 00:16:20,006
explicitly. There is a default timeout that lambda has that it

262
00:16:20,028 --> 00:16:23,862
cannot execute beyond. So your code will stop executing at some point.

263
00:16:23,996 --> 00:16:27,446
And as I mentioned, there have been lots of tests showing that

264
00:16:27,468 --> 00:16:30,280
the noisy neighbor issues on lambda are minimal at best.

265
00:16:30,650 --> 00:16:34,646
Researchers have actually executed code that locks up a lot of cpu

266
00:16:34,678 --> 00:16:37,818
and then run parallel loads next to it to see what the impact is,

267
00:16:37,904 --> 00:16:42,006
and they can barely detect a difference at all. And this is where the ephemeral

268
00:16:42,038 --> 00:16:45,786
nature of lambda is a savior. The problem with having these big clusters

269
00:16:45,818 --> 00:16:49,726
of servers is that often these machines are around for days, weeks at

270
00:16:49,748 --> 00:16:53,360
a time, and having something execute there means that

271
00:16:53,810 --> 00:16:57,234
the processing of non performant code

272
00:16:57,272 --> 00:17:01,390
is going to be around for a long time. Lambda functions execute

273
00:17:01,550 --> 00:17:04,786
and either idle, waiting for the next time to execute, or are

274
00:17:04,808 --> 00:17:08,466
killed immediately anyway. So this is a really useful feature to

275
00:17:08,488 --> 00:17:11,286
help make sure that even if you write bad code, it's not going to have

276
00:17:11,308 --> 00:17:14,898
as much of an impact. Now that we're in a situation with lambda

277
00:17:14,914 --> 00:17:18,482
functions where you're not going to completely give up an optimization,

278
00:17:18,626 --> 00:17:21,238
but you don't need to focus on it quite as intently. It's not going to

279
00:17:21,244 --> 00:17:24,326
have quite as bad an impact on your application as a whole. Which means that

280
00:17:24,348 --> 00:17:27,266
you and the rest of the team can focus more on what pays the bills

281
00:17:27,298 --> 00:17:30,960
for your company, more on the features that your customers are to pay for.

282
00:17:31,890 --> 00:17:35,758
I've never met a single MD of a company

283
00:17:35,924 --> 00:17:39,086
that is going to be happy to hear that you need to spend two to

284
00:17:39,108 --> 00:17:42,766
four weeks on optimizing code. Instead, they want to

285
00:17:42,788 --> 00:17:45,970
hear you talk about features that you can push, that you can help drive revenue.

286
00:17:46,630 --> 00:17:50,050
Now, in the beginning of the talk, I mentioned

287
00:17:50,120 --> 00:17:53,426
the idea that building serverless applications helps reduce the

288
00:17:53,448 --> 00:17:56,846
amount of code you generate, because you are switching from describing

289
00:17:56,878 --> 00:18:00,454
everything in code to using the cloud services to replace some of that code

290
00:18:00,492 --> 00:18:04,246
for you. This has the knock on benefit that just by having less code,

291
00:18:04,348 --> 00:18:06,870
you're ultimately going to produce less errors.

292
00:18:07,530 --> 00:18:10,998
So if we have a web application in the traditional sense,

293
00:18:11,164 --> 00:18:14,602
we need to perform all of the reprocessing of the HTTP request in code.

294
00:18:14,656 --> 00:18:17,386
All of it happens in code. Even if that code is a framework that youll

295
00:18:17,408 --> 00:18:20,506
might use, it's still code that we need to worry about. Manage and

296
00:18:20,528 --> 00:18:23,626
maintain the routing in the past is

297
00:18:23,648 --> 00:18:26,942
stuff that we need to write our own authentication. Even if it is,

298
00:18:26,996 --> 00:18:29,722
even if it's a library that we happen to use, we still need to implement,

299
00:18:29,786 --> 00:18:32,746
we still need to manage it, maintain its versioning,

300
00:18:32,858 --> 00:18:36,046
we need to manage cause responses and general responses and a lot more.

301
00:18:36,068 --> 00:18:39,074
There's a ton of stuff that we need to write as a part of our

302
00:18:39,112 --> 00:18:43,090
application. All of this means that there's a lot more code

303
00:18:43,240 --> 00:18:46,274
and a lot more code isn't necessarily a good thing.

304
00:18:46,472 --> 00:18:50,338
Single largest causes of failures in platforms is code written by developers.

305
00:18:50,434 --> 00:18:53,634
When you have a bug, it's usually not the framework

306
00:18:53,682 --> 00:18:57,094
that you installed three weeks ago, it's the chunk of code that was released last

307
00:18:57,132 --> 00:19:00,970
week. And this is the single biggest cause of failures.

308
00:19:01,630 --> 00:19:05,274
And this is where it's no wonder then that low code

309
00:19:05,312 --> 00:19:08,310
or no code solutions have been getting so popular recently,

310
00:19:08,470 --> 00:19:12,090
like Lambda. So if we look at serverless,

311
00:19:12,450 --> 00:19:16,074
the interesting thing here is that we can replace pathing,

312
00:19:16,202 --> 00:19:20,026
for example, and HTTP request management with API

313
00:19:20,058 --> 00:19:22,894
gateway. API gateway can kind of handle a lot of the stuff for us,

314
00:19:22,932 --> 00:19:26,340
just take that completely out of our hands. There's no framework to manage,

315
00:19:27,270 --> 00:19:30,718
there's no libraries to maintain, there's no configuration. Once you've

316
00:19:30,734 --> 00:19:33,620
got the API gateway set up, that's it, it's done.

317
00:19:34,070 --> 00:19:37,286
Everything else is being managed by the team at AWS for you.

318
00:19:37,468 --> 00:19:40,742
DynamoDB simplifies database interactions because instead

319
00:19:40,796 --> 00:19:44,786
of having this very large, complex relational database where you've designed

320
00:19:44,818 --> 00:19:47,510
the schema upfront and now you need to write complexity,

321
00:19:48,090 --> 00:19:53,158
sometimes hard to manage, and error prone SQL queries to DynamoDB

322
00:19:53,254 --> 00:19:56,890
is completely managed for you and you design your database structure based

323
00:19:56,960 --> 00:20:00,406
on the data that you need to retrieve. So the design of your database

324
00:20:00,438 --> 00:20:04,026
is based on your query patterns, not your query patterns need to

325
00:20:04,048 --> 00:20:07,546
be to design to the structure of the database, which makes things far less error

326
00:20:07,578 --> 00:20:11,502
prone and means that everything is decided up front more.

327
00:20:11,636 --> 00:20:14,686
And if you ever had to build a system that has to interact with the

328
00:20:14,708 --> 00:20:18,034
file system, that's often an incredibly scary prospect because working

329
00:20:18,072 --> 00:20:21,378
on a file system can potentially cause massive performance issues.

330
00:20:21,544 --> 00:20:25,486
However, with the serverless world with S three. S three is essentially a replacement

331
00:20:25,518 --> 00:20:28,946
for a file system. S three is specifically designed to be a highly performant

332
00:20:28,978 --> 00:20:32,838
way to store files and retrieve files in the cloud,

333
00:20:33,004 --> 00:20:36,294
and it absolutely excels at that job. So using S three

334
00:20:36,332 --> 00:20:38,818
will take a lot of load off of you having to worry about these file

335
00:20:38,834 --> 00:20:42,134
system interactions. You can just use the SDK provided by AWS

336
00:20:42,182 --> 00:20:45,610
to send files to s three and retrieve files from s three, and it absolutely

337
00:20:45,680 --> 00:20:48,826
kills it. That job and the serverless framework itself.

338
00:20:48,928 --> 00:20:52,998
Unlike other frameworks that you might have used like can exprs and

339
00:20:53,024 --> 00:20:57,166
so on, serverless framework doesn't actually add any additional code to your application.

340
00:20:57,348 --> 00:21:00,382
The point of the serverless framework is to give you the ability to

341
00:21:00,436 --> 00:21:04,538
configure a serverless application in a configuration file,

342
00:21:04,714 --> 00:21:08,846
and when you run a deploy command, all it does is use that configuration file

343
00:21:08,878 --> 00:21:12,098
to package everything, including your lambda function, in a way that can

344
00:21:12,104 --> 00:21:15,826
be sent to AWS. To instruct AWS to create all of

345
00:21:15,848 --> 00:21:19,718
these cloud resources for you doesn't actually add any additional code,

346
00:21:19,884 --> 00:21:23,714
and that's also pretty killer. The serverless framework version

347
00:21:23,842 --> 00:21:27,778
isn't as integral in managing the deployment to AWS.

348
00:21:27,954 --> 00:21:31,238
Only if you want to use new features in AWS might you need to upgrade

349
00:21:31,254 --> 00:21:34,554
the serverless framework, but it doesn't actually change the code that is

350
00:21:34,592 --> 00:21:38,810
sent into the cloud. So what you write is what is in

351
00:21:38,880 --> 00:21:42,198
Lambda now with all this together as well, now that we're

352
00:21:42,214 --> 00:21:46,734
using a framework to deploy, now we are writing less code and

353
00:21:46,772 --> 00:21:50,938
we have the ability to very easily make deployed. This means continuous delivery

354
00:21:51,034 --> 00:21:53,806
suddenly becomes a lot easier to do. And this is a practice we found very

355
00:21:53,828 --> 00:21:57,154
useful at serverless as well, in that we can constantly be pushing out

356
00:21:57,192 --> 00:22:01,106
new features as soon as developers finish building them. And some of the team have

357
00:22:01,208 --> 00:22:04,782
spent some time validating the work instead of waiting for Big Bang releases,

358
00:22:04,846 --> 00:22:07,906
you can push a code out very very quickly. And this is what we did

359
00:22:07,928 --> 00:22:11,126
in the good old days. We would put these releases together and toss it over

360
00:22:11,148 --> 00:22:15,218
the wall at the developers team, and this creates that friction between the infrastructure teams

361
00:22:15,234 --> 00:22:18,966
and the developers. Now I keep throwing code at the infrastructure team to put into

362
00:22:18,988 --> 00:22:21,820
production, it keeps breaking. They fight with me, we fight with them.

363
00:22:22,750 --> 00:22:25,946
It's not a great situation to be in and leads to

364
00:22:25,968 --> 00:22:29,466
these Big Bang releases collected over two to

365
00:22:29,488 --> 00:22:33,146
four weeks or even longer, that suddenly have enormous amounts of

366
00:22:33,168 --> 00:22:37,326
changes to deploy, when a better approach would be to push changes as they're made

367
00:22:37,508 --> 00:22:41,230
piece by piece at a time. And this is what's recently started

368
00:22:41,300 --> 00:22:44,686
happening even in the more traditional development sense, where teams are trying

369
00:22:44,708 --> 00:22:47,870
to structure themselves in a way where as teams finish features,

370
00:22:47,950 --> 00:22:51,586
they try to deploy them immediately into production instead of waiting around for

371
00:22:51,608 --> 00:22:55,378
these big release cadences to come. But it's a

372
00:22:55,384 --> 00:22:58,534
little tricky to do in the traditional sense.

373
00:22:58,572 --> 00:23:02,722
The infrastructure around these applications tends to be slow

374
00:23:02,786 --> 00:23:07,522
and time consuming to update. So if you're making a change to a relational database

375
00:23:07,666 --> 00:23:11,058
that often requires downtime, you're going to have to tell users

376
00:23:11,074 --> 00:23:14,154
to stop using the system or turn it off so that you can update that

377
00:23:14,192 --> 00:23:17,738
relational database. Even EC two instances changing the structure of

378
00:23:17,744 --> 00:23:21,306
the way EC two instances work because of the code you're deploying have

379
00:23:21,328 --> 00:23:25,054
massive impact on the uptime and downtime of your system. And it's not great

380
00:23:25,092 --> 00:23:28,510
to keep taking your system down because developers want to push code

381
00:23:28,580 --> 00:23:31,070
really quickly, so difficult to balance.

382
00:23:31,410 --> 00:23:33,822
But in the serverless world,

383
00:23:33,956 --> 00:23:37,570
infrastructure that is needed is actually a part of the service

384
00:23:37,640 --> 00:23:41,362
itself. It's not something over there that the developer sends code

385
00:23:41,416 --> 00:23:45,154
to, it's a part of the app itself. It's integral to the actual

386
00:23:45,192 --> 00:23:48,606
service that you're building. What this means is that when you're

387
00:23:48,638 --> 00:23:52,434
busy making changes, you can immediately push them to production with a single command.

388
00:23:52,562 --> 00:23:55,666
Now you might go through a process of validation with a sort of staging

389
00:23:55,698 --> 00:23:58,854
environment where some of the team can look at what you've done and run some

390
00:23:58,892 --> 00:24:02,266
tests. But ultimately sending stuff to production is a case of running a

391
00:24:02,288 --> 00:24:05,926
command, and those changes are immediately deployed. You can also merge

392
00:24:05,958 --> 00:24:09,418
changes immediately to GitHub. You can create pull requests and merge this into a

393
00:24:09,424 --> 00:24:11,680
GitHub repo for a CRCD tool.

394
00:24:12,050 --> 00:24:16,138
And with the advent these days of microservices

395
00:24:16,234 --> 00:24:19,610
being a preferred architectural pattern, in a lot of situations,

396
00:24:19,690 --> 00:24:22,814
serverless as an architectural pattern is very well

397
00:24:22,852 --> 00:24:26,802
suited to microservices, and this means that you can now build

398
00:24:26,936 --> 00:24:30,100
a collection of small services for your entire application.

399
00:24:30,630 --> 00:24:34,418
These small services decrease the surface area of each individual service that

400
00:24:34,424 --> 00:24:37,766
you might run a deploy command on, which makes it even easier to do this

401
00:24:37,788 --> 00:24:43,560
continuous deployment of changes over time. And if

402
00:24:45,290 --> 00:24:48,742
these little deployments over time are so much easier to do,

403
00:24:48,876 --> 00:24:52,726
automation with something like CRCD becomes incredibly simple. You really just

404
00:24:52,748 --> 00:24:56,086
keep running a deployed command in your CRCD tool on the services

405
00:24:56,188 --> 00:24:59,640
as changing are pushed into a repo, like GitHub for example.

406
00:25:00,290 --> 00:25:03,774
Thanks so much. Those are the big ones that I wanted to talk about,

407
00:25:03,812 --> 00:25:07,066
how serverless is improving things and changing

408
00:25:07,098 --> 00:25:10,206
the world for developers massively I

409
00:25:10,228 --> 00:25:13,818
am looking forward to answering the questions you might have. I'll be in the discord

410
00:25:13,914 --> 00:25:16,940
to take a look and answer anything that I can find. Thank you so much.

