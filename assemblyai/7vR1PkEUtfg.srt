1
00:00:26,930 --> 00:00:30,374
Welcome to my talk. I'm recording this video from Spain where

2
00:00:30,412 --> 00:00:34,200
I'm based. I hope you enjoy, I hope you're having a nice day

3
00:00:34,650 --> 00:00:37,846
and I would still very much like to interact with you. So if

4
00:00:37,868 --> 00:00:41,206
you have any questions, comments, ideas, or just

5
00:00:41,228 --> 00:00:44,040
want to say hi, feel free to reach out to me after the talk.

6
00:00:44,810 --> 00:00:48,374
I'll share my contact details right at the end.

7
00:00:48,572 --> 00:00:52,574
So let's go. Move fast without breaking things probably

8
00:00:52,692 --> 00:00:57,102
you heard the opposite of this phrase from

9
00:00:57,156 --> 00:01:00,462
here, where it started, like, I think maybe

10
00:01:00,516 --> 00:01:03,818
ten or 15 years ago, where it became Facebook's.

11
00:01:03,914 --> 00:01:07,266
One of mottos of Facebook. And this is

12
00:01:07,448 --> 00:01:10,866
funny, actually, because I remember I first seen this phrase in

13
00:01:10,888 --> 00:01:15,086
my first office, one of my first offices in Istanbul,

14
00:01:15,118 --> 00:01:18,750
Turkey, where I was working in one

15
00:01:18,760 --> 00:01:22,354
of the largest banks in Turkey as a software developer. And this phrase was written

16
00:01:22,402 --> 00:01:26,482
on top of the wall right next to my desk.

17
00:01:26,626 --> 00:01:30,890
And it was a bit confusing because things bank is run with strong hierarchy,

18
00:01:31,390 --> 00:01:34,538
stability and quality is everything.

19
00:01:34,624 --> 00:01:38,314
Like perception of quality is everything, both individually and both of the systems we

20
00:01:38,352 --> 00:01:41,882
build. And to be honest, we deal with money

21
00:01:41,936 --> 00:01:45,406
and it's a banking system, so there's not much room to.

22
00:01:45,508 --> 00:01:48,926
Room for error or to break things. So it was a bit confusing for me,

23
00:01:49,028 --> 00:01:52,666
bit for the case of Facebook. It actually makes a lot of sense and it's

24
00:01:52,698 --> 00:01:56,066
great, it's a great vision as what great leaders should

25
00:01:56,088 --> 00:02:00,226
do. They set great visions and I think move

26
00:02:00,248 --> 00:02:04,046
fast and break things states that pace is the priority,

27
00:02:04,078 --> 00:02:07,666
even on the cost of breaking things. They wanted their employees

28
00:02:07,858 --> 00:02:11,474
to feel safe, to not fear

29
00:02:11,522 --> 00:02:14,482
about breaking things, because they want to innovate.

30
00:02:14,626 --> 00:02:17,846
Facebook created new user habits for us,

31
00:02:17,868 --> 00:02:20,986
they invented new user habits for us and wanted to go further. They wanted to

32
00:02:21,008 --> 00:02:24,394
invent newer things, they wanted to invent better, faster things

33
00:02:24,432 --> 00:02:28,234
of interacting in web. So that's why they went

34
00:02:28,272 --> 00:02:32,938
with it up until it became this. So not

35
00:02:33,024 --> 00:02:36,222
too, like maybe, let's say recently, a few years ago,

36
00:02:36,276 --> 00:02:40,266
Facebook adopted move fast with stable infra. So they're

37
00:02:40,298 --> 00:02:43,394
both valid approaches, but different times call for different

38
00:02:43,432 --> 00:02:47,810
measures. So why would any company would prefer this

39
00:02:47,880 --> 00:02:52,030
move fast with still having a stable infrastructure, stable performance

40
00:02:52,190 --> 00:02:56,454
over just pure pace? So of course, there's an obvious reason

41
00:02:56,652 --> 00:03:00,166
where now user base expects a certain level of threshold of

42
00:03:00,188 --> 00:03:03,254
performance, you want to comply with

43
00:03:03,292 --> 00:03:06,742
the standard of quality. But there are a few

44
00:03:06,796 --> 00:03:10,730
other things, maybe like, not too obvious things that I want to mention here

45
00:03:10,880 --> 00:03:14,730
to consider high or good performance.

46
00:03:16,190 --> 00:03:20,486
First of those is experimentation, where I've

47
00:03:20,518 --> 00:03:24,106
seen this in my workplaces, where we've shipped an

48
00:03:24,128 --> 00:03:27,886
experiment we shipped a new feature can idea as an experiment to get

49
00:03:27,908 --> 00:03:31,006
feedback to see how it's going to perform. But the thing is,

50
00:03:31,028 --> 00:03:34,522
what we missed was the specific feature

51
00:03:34,586 --> 00:03:37,970
idea was performing like the performance to quality

52
00:03:38,040 --> 00:03:41,714
was a little worse than the actual product because we just wanted to be fast.

53
00:03:41,912 --> 00:03:46,034
But then the experiment results were the users didn't like this idea.

54
00:03:46,152 --> 00:03:49,766
But actually soon after we found out that it's not that users didn't like the

55
00:03:49,788 --> 00:03:53,554
idea, it's just that that feature was slow, it wasn't performing

56
00:03:53,602 --> 00:03:57,670
well, it wasn't really in high quality that users didn't value,

57
00:03:57,740 --> 00:04:00,060
users didn't want to use it, they dropped out.

58
00:04:00,430 --> 00:04:04,202
So during experimentation, it's really crucial that

59
00:04:04,256 --> 00:04:07,734
you meet your current quality standards so that users

60
00:04:07,782 --> 00:04:11,046
don't, even if they don't notice this consciously,

61
00:04:11,158 --> 00:04:14,686
they wouldn't just want to drop out, they wouldn't want

62
00:04:14,708 --> 00:04:18,266
to be annoyed with your product. And the next one is morale.

63
00:04:18,378 --> 00:04:21,626
So when you ship things that every once in a while breaks,

64
00:04:21,658 --> 00:04:25,310
and when you break things you have to go fix them.

65
00:04:25,380 --> 00:04:28,882
And when you ship things that breaks often, then you have to go fix them

66
00:04:28,936 --> 00:04:31,538
quite often and spend a lot of time on it. So every once in a

67
00:04:31,544 --> 00:04:34,738
while this is fine, but if it happens quite frequently over a

68
00:04:34,744 --> 00:04:38,434
long course of time, in the mid and long term, this would actually bring

69
00:04:38,472 --> 00:04:41,766
down the morale of your teams a lot. This is also something you want to

70
00:04:41,788 --> 00:04:44,966
consider. And the last thing I want to

71
00:04:44,988 --> 00:04:49,020
mention is I think things is something I really want to emphasize, which is

72
00:04:50,110 --> 00:04:54,474
more than often spending 10% extra time and effort will probably

73
00:04:54,592 --> 00:04:58,582
prevent 90% of the issues you will face, that or otherwise.

74
00:04:58,726 --> 00:05:02,462
I think this is almost

75
00:05:02,516 --> 00:05:05,774
always free in my personal experience and I think

76
00:05:05,892 --> 00:05:09,358
with the content that I'm just going to be telling you about, I'm going

77
00:05:09,364 --> 00:05:13,294
to be supporting this idea. And maybe now

78
00:05:13,332 --> 00:05:16,562
it's time to talk about why am I talking about

79
00:05:16,616 --> 00:05:19,986
this? Why not for something else? Or why

80
00:05:20,088 --> 00:05:23,726
not someone else is talking about these but me? I think it's

81
00:05:23,758 --> 00:05:27,570
a good time to explain myself, like my past, my experience.

82
00:05:27,720 --> 00:05:30,614
So I've been working in tech for ten teams for the past ten years as

83
00:05:30,652 --> 00:05:34,306
a software engineer. I call myself a product management engineer.

84
00:05:34,418 --> 00:05:38,166
I love solving users problems and I've been grown

85
00:05:38,198 --> 00:05:41,610
from a junior engineer for technically doublet teams.

86
00:05:42,590 --> 00:05:46,166
I've mostly worked in thoughtworks in the past where I've

87
00:05:46,198 --> 00:05:49,482
started in Turkey, and I've then worked

88
00:05:49,536 --> 00:05:53,350
in Germany, India and then Spain finally where I settled.

89
00:05:53,430 --> 00:05:57,054
I believe we came for the past five years and

90
00:05:57,092 --> 00:06:00,618
I worked in various different domains, banking, e commerce, pricing,

91
00:06:00,714 --> 00:06:04,314
breaking and then in new relic

92
00:06:04,442 --> 00:06:07,810
I moved to new relic to the observability domain. I've had amazing

93
00:06:07,880 --> 00:06:11,970
few years and then since the beginning of this year I'm working on Shopify.

94
00:06:12,310 --> 00:06:15,746
So I worked a lot with those individual able to I had

95
00:06:15,768 --> 00:06:19,186
the luck to build that muscle and I'm really interested in complex systems

96
00:06:19,218 --> 00:06:22,518
and how people I'm fascinated by the characteristic of

97
00:06:22,684 --> 00:06:26,440
complex systems, the complexity and especially how people

98
00:06:26,810 --> 00:06:29,880
struggle or can manage with that, deal with that.

99
00:06:31,450 --> 00:06:34,666
So I've led teams that own and build

100
00:06:34,848 --> 00:06:39,478
or been part of teams that own and build really high scale

101
00:06:39,654 --> 00:06:43,306
systems that demand really high quality like for example neuralic

102
00:06:43,338 --> 00:06:47,802
processes and serves telemetry data. They own perhaps

103
00:06:47,866 --> 00:06:51,482
the biggest Kafka cluster in the world and requires

104
00:06:51,626 --> 00:06:54,778
excellent operational quality because actually

105
00:06:54,964 --> 00:06:58,162
that's the product where other companies need when things are going

106
00:06:58,216 --> 00:07:02,114
tough, or during critical data like Black Friday, Cyber Monday, which is

107
00:07:02,152 --> 00:07:05,346
happening now, where I'm recording this, or now

108
00:07:05,368 --> 00:07:08,854
I'm building in Shopify and I'm part of the shop app. My team is

109
00:07:08,892 --> 00:07:12,406
responsible of helping our users attract their

110
00:07:12,428 --> 00:07:15,686
packages, track their orders and in updates we process

111
00:07:15,788 --> 00:07:19,282
more than 20 million of status updates,

112
00:07:19,346 --> 00:07:22,806
track order updates to be able to let our users

113
00:07:22,838 --> 00:07:25,590
know the latest status about their orders.

114
00:07:25,750 --> 00:07:29,718
And while dealing managing this complexity,

115
00:07:29,894 --> 00:07:33,500
my teams have always been under pressure of moving fast.

116
00:07:35,150 --> 00:07:38,880
And I want to share my experience of how did we balance those two things.

117
00:07:40,530 --> 00:07:44,322
So it all starts with planning, right? If you want to go really

118
00:07:44,376 --> 00:07:48,210
fast, but also keep a high level of fidelity, you need to plan accordingly.

119
00:07:49,190 --> 00:07:52,660
And first thing I've been really happy about

120
00:07:53,110 --> 00:07:56,238
when we achieved this was setting our priorities,

121
00:07:56,334 --> 00:07:59,780
really setting our priorities straight. So that will come daytoday

122
00:08:00,090 --> 00:08:03,702
for a lot of people or more than one person in the team,

123
00:08:03,756 --> 00:08:07,154
where we'll need to make a decision between time, performance,

124
00:08:07,282 --> 00:08:09,880
scope, quality, security,

125
00:08:10,890 --> 00:08:14,394
things like this. We need to choose one or the others. There's this trade off

126
00:08:14,432 --> 00:08:18,662
coming. They'll come a day that you need to make a choice

127
00:08:18,726 --> 00:08:22,106
within this trade off. And I think a teams should be

128
00:08:22,128 --> 00:08:25,822
doing the most important thing at any given time. So this is my

129
00:08:25,876 --> 00:08:28,670
motto. And in order to be able to do that,

130
00:08:28,820 --> 00:08:32,478
consider one Wednesday morning you show up to work. There's two things you

131
00:08:32,484 --> 00:08:35,922
can do. Or someone in your team, like you can

132
00:08:35,976 --> 00:08:39,618
just do something to make your application more secure, or you

133
00:08:39,624 --> 00:08:43,842
can do this other thing that's a performance optimization. So which one you would do?

134
00:08:43,976 --> 00:08:47,302
Instead of just relying on

135
00:08:47,436 --> 00:08:51,942
making the right choice every time for

136
00:08:51,996 --> 00:08:55,906
individuals, I think we should just set our priorities straight,

137
00:08:55,938 --> 00:08:59,462
unknown, and broadcast them clearly, so that this choice

138
00:08:59,526 --> 00:09:03,834
is straightforward, so that this choice is

139
00:09:03,872 --> 00:09:07,350
almost known. I think setting your priorities

140
00:09:07,510 --> 00:09:11,034
clear in the beginning will, as I wrote right here,

141
00:09:11,072 --> 00:09:14,638
will make your team work on the most important thing at any given time.

142
00:09:14,724 --> 00:09:18,814
And how do we achieve this? So there are like workshops like

143
00:09:18,852 --> 00:09:21,934
trade up sliders and such. Bit, you don't have to go in a full on

144
00:09:21,972 --> 00:09:25,486
formal practice bit. Could be just a 20 minutes talk. I think it just

145
00:09:25,508 --> 00:09:28,370
makes sure to reach the stake.

146
00:09:29,430 --> 00:09:32,194
And once it's done, of course we have a problem. We have an idea.

147
00:09:32,232 --> 00:09:36,062
We're going to design, right, in big tech, mostly, we have this already running complex

148
00:09:36,126 --> 00:09:38,994
architecture, and we're going to add to this, we're going to add some logic,

149
00:09:39,042 --> 00:09:42,966
possibly some infrastructure. And how do we go about this when we still want

150
00:09:42,988 --> 00:09:47,014
to move really fast? Because many

151
00:09:47,052 --> 00:09:49,942
things can impact us, architectural decisions, right? Like,

152
00:09:50,076 --> 00:09:53,178
if we believe this system is going to grow in a certain way, if we

153
00:09:53,184 --> 00:09:56,474
need to scale in a certain way, if we believe we may

154
00:09:56,512 --> 00:10:00,220
add some logic in a certain way, they all factors in,

155
00:10:00,590 --> 00:10:04,426
impacts this decision. But there is this one concept

156
00:10:04,458 --> 00:10:07,754
I wanted to talk to you about is that's actually coined by my former employer,

157
00:10:07,802 --> 00:10:10,778
thoughtworks. It's called evolutionary architecture.

158
00:10:10,954 --> 00:10:15,298
So when you put the subjective evolutionary in

159
00:10:15,304 --> 00:10:18,738
front of architecture, I think that implies few things.

160
00:10:18,824 --> 00:10:22,306
One of them is it makes architecture a

161
00:10:22,328 --> 00:10:26,178
living entity. Now, we accept architecture is a living entity and it changes,

162
00:10:26,264 --> 00:10:29,814
right? Bit evolves, and now we have a choice then,

163
00:10:29,932 --> 00:10:34,002
right after, we can just let it drift away, let it evolve naturally,

164
00:10:34,066 --> 00:10:37,966
or we can make it consciously, right? We can change it consciously

165
00:10:38,098 --> 00:10:42,234
instead of letting it drift in time. So how

166
00:10:42,272 --> 00:10:45,354
does this gets applied is we

167
00:10:45,392 --> 00:10:48,938
create. Thoughtworks have defined this way of, you create a

168
00:10:48,944 --> 00:10:52,378
fitness function. So, by the way, you don't have to, I think, apply this

169
00:10:52,464 --> 00:10:55,646
formal practice or adopt this at all bit. I think it's really good to

170
00:10:55,668 --> 00:10:59,546
understand the concept. So you create a fitness function. A fitness

171
00:10:59,578 --> 00:11:02,838
function is a term that's been borrowed by evolutionary

172
00:11:02,874 --> 00:11:07,678
biology. It describes the likelihood of survival

173
00:11:07,694 --> 00:11:11,406
of fitness, survival of the fittest. It describes the likelihood

174
00:11:11,438 --> 00:11:14,930
of a species to survive. Likelihood to survive of a species.

175
00:11:15,770 --> 00:11:20,514
So then here, the fitness function actually represents

176
00:11:20,562 --> 00:11:24,294
our priorities, right? We can actually apply things function

177
00:11:24,332 --> 00:11:27,702
to our architecture and see if it matches our priorities or not. For example,

178
00:11:27,756 --> 00:11:31,206
in this case, in this example that I put here, high throughput,

179
00:11:31,238 --> 00:11:34,730
for example, is more important than low latency, for example, or data security

180
00:11:34,800 --> 00:11:38,682
is more important than usability. So once you define this,

181
00:11:38,736 --> 00:11:42,622
then, and make sure your team is clear about this,

182
00:11:42,676 --> 00:11:45,390
you can design your architecture accordingly.

183
00:11:49,090 --> 00:11:52,570
So the next thing is I want to mention is I think this is a

184
00:11:52,580 --> 00:11:55,666
good heuristic for designing a

185
00:11:55,688 --> 00:11:58,978
base architecture, because as we said, as we

186
00:11:58,984 --> 00:12:02,690
now accept our architecture, especially when we are moving

187
00:12:02,760 --> 00:12:06,466
fast, it's a living entity and

188
00:12:06,488 --> 00:12:09,874
it's going to grow and evolve. So I think it's a really good heuristic

189
00:12:09,922 --> 00:12:14,214
to start with, keeping complexity low. And maybe

190
00:12:14,412 --> 00:12:18,294
I want your attention on the left side of this or the right side of

191
00:12:18,492 --> 00:12:22,066
the screen, where is, there's a chessboard,

192
00:12:22,098 --> 00:12:25,450
right? Like why is that? So? I put this, because if you ever

193
00:12:25,520 --> 00:12:29,046
imagine we're looking at a chessboard, like I take a photograph

194
00:12:29,078 --> 00:12:32,046
of a chessboard in the middle of a game, you're not either one of the

195
00:12:32,068 --> 00:12:35,626
players. Sometimes, especially if you're not too experienced

196
00:12:35,658 --> 00:12:39,486
with chess, it's really hard to understand the strategies of

197
00:12:39,508 --> 00:12:42,830
each player, or it's really hard to understand what is the reason,

198
00:12:42,900 --> 00:12:46,094
what's the purpose of each

199
00:12:46,132 --> 00:12:49,426
element on a table, each element on the board, and what

200
00:12:49,448 --> 00:12:53,266
is the strategy of either player and what's going to happen next. It's really

201
00:12:53,288 --> 00:12:56,500
hard to understand the behavior, what's going to come next,

202
00:12:56,870 --> 00:13:00,046
unless you're a really experienced chess player

203
00:13:00,078 --> 00:13:03,478
or really know about things player. And that means there's a

204
00:13:03,484 --> 00:13:06,982
hidden complexity right there. We don't know what to expect from system.

205
00:13:07,036 --> 00:13:10,502
We don't know what is next. And this is exactly what we want to avoid

206
00:13:10,646 --> 00:13:13,846
in our system. If you look at your architecture,

207
00:13:13,958 --> 00:13:17,706
we want architecture to express its behavior, to not

208
00:13:17,728 --> 00:13:20,570
hide it, to really explicitly,

209
00:13:22,270 --> 00:13:26,054
as explicit as possibly express

210
00:13:26,102 --> 00:13:29,774
the behavior so that you can actually grow in it. So I

211
00:13:29,812 --> 00:13:33,054
think that's why I feel having a base level of.

212
00:13:33,092 --> 00:13:36,266
So if you want to make a decision, if you want to make a trade

213
00:13:36,298 --> 00:13:39,886
off designing your architecture between complexity and performance,

214
00:13:39,998 --> 00:13:43,634
between amount of resources, I think it's a really good heuristic to start

215
00:13:43,672 --> 00:13:46,934
a base level of architecture with a lower complexity so that

216
00:13:46,972 --> 00:13:50,246
it's really faster and easier to grow and let the

217
00:13:50,268 --> 00:13:51,590
architecture evolve,

218
00:13:53,610 --> 00:13:57,526
which I can connect back to the code that I have just told you more

219
00:13:57,548 --> 00:14:02,170
than often. Spending 10% extra time, perhaps to build

220
00:14:02,240 --> 00:14:06,054
the architecture with the lower complexity or have more resources

221
00:14:06,182 --> 00:14:09,578
or have more latency, will avoid 90% of

222
00:14:09,584 --> 00:14:13,066
the issues that you'll face later otherwise, and will make you grow your architecture,

223
00:14:13,098 --> 00:14:14,990
evolve your architecture faster.

224
00:14:15,810 --> 00:14:18,640
So next is you have this big design.

225
00:14:19,170 --> 00:14:22,734
Now you need to split it into parts, split bit into chunks, so that people

226
00:14:22,772 --> 00:14:26,226
can work on that, that will complete the puzzle and become your

227
00:14:26,248 --> 00:14:30,034
product. Right? So how do we go about this I

228
00:14:30,072 --> 00:14:33,490
think a great rule of thumb is you first do the things that has

229
00:14:33,560 --> 00:14:37,338
high value and high complexity. You should prioritize

230
00:14:37,454 --> 00:14:40,742
these type of parts. So that basically translates into

231
00:14:40,796 --> 00:14:43,986
parts that connect the pipes and build a walking skeleton,

232
00:14:44,018 --> 00:14:47,494
for example, parts that are complex to build, risky parts that

233
00:14:47,532 --> 00:14:51,194
holds unknown. So basically, again, a rule of thumb is you

234
00:14:51,232 --> 00:14:54,886
face the tough things first. You face the tough burst

235
00:14:54,918 --> 00:14:58,662
that may uncover risky things that maybe your team lacks skill.

236
00:14:58,726 --> 00:15:01,962
Maybe it's a complex logic that you need to build.

237
00:15:02,096 --> 00:15:05,870
Maybe it's a complex infrastructure that you want to face those things

238
00:15:05,940 --> 00:15:09,438
first. And also, instead of just going,

239
00:15:09,524 --> 00:15:12,638
just to go back to the first point, instead of building parts of a

240
00:15:12,644 --> 00:15:15,918
body separately, imagine building parts

241
00:15:15,934 --> 00:15:19,042
of the car separately and connecting them in the last week,

242
00:15:19,096 --> 00:15:22,434
at the last minute. I think you should really consider having

243
00:15:22,472 --> 00:15:25,986
a walking skeleton from week one so that you

244
00:15:26,008 --> 00:15:30,054
get feedback. You experience running it, you know how it feels like, and I

245
00:15:30,092 --> 00:15:33,382
think you may uncover things you wouldn't otherwise. Things is something

246
00:15:33,436 --> 00:15:37,000
I cannot emphasize enough. The benefits of

247
00:15:37,310 --> 00:15:41,514
bit. So the next part is now we're going to more

248
00:15:41,552 --> 00:15:45,830
practical things is integrations. So integrations

249
00:15:45,910 --> 00:15:49,980
is usually in this big, complex system,

250
00:15:50,830 --> 00:15:54,366
this is the most critical and delicate parts because these

251
00:15:54,388 --> 00:15:57,726
are the parts where most incidents and issues occur, and they need to be

252
00:15:57,748 --> 00:16:00,830
treated really with delicacy and they need to be secured.

253
00:16:01,170 --> 00:16:04,266
So we can divide this. How the secure integrations are two,

254
00:16:04,308 --> 00:16:07,326
like downstream integrations versus upstream integrations,

255
00:16:07,438 --> 00:16:11,026
and there are different patterns and you can apply them. So for

256
00:16:11,048 --> 00:16:13,854
downstream integrations, you can apply timeouts, retry,

257
00:16:13,902 --> 00:16:16,834
backup policy, circuit breaking. I'm not going to details of them.

258
00:16:16,952 --> 00:16:19,378
I'm going to talk about a few books. I'm going to mention a few books

259
00:16:19,394 --> 00:16:22,758
that you can learn really deep information and how to

260
00:16:22,764 --> 00:16:26,706
do things and get experience of those. But like timeouts,

261
00:16:26,738 --> 00:16:30,198
for example. But the main idea is simple. If a part of your system

262
00:16:30,284 --> 00:16:33,894
breaks, it's like a system design principle. If a part of your system breaks,

263
00:16:33,942 --> 00:16:37,386
so the rest should be working as best as possible. And in order to do

264
00:16:37,408 --> 00:16:40,614
that, you need to be able to isolate the failure.

265
00:16:40,662 --> 00:16:43,946
Right. So if a downstream system is downstream

266
00:16:43,978 --> 00:16:47,486
service is failing, instead of waiting for that

267
00:16:47,508 --> 00:16:50,734
service for 30 seconds, you should time out and then use that

268
00:16:50,772 --> 00:16:54,786
resource instead of waiting to do some other stuff. Right? Or for

269
00:16:54,808 --> 00:16:58,094
example, let's say circuit breaking. If a downstream

270
00:16:58,142 --> 00:17:01,806
service is really having a hard time under high load,

271
00:17:01,838 --> 00:17:05,470
et cetera, instead of hammering it and having errors all the time,

272
00:17:05,560 --> 00:17:09,074
you should just do circuit breaking and give that downstream

273
00:17:09,122 --> 00:17:12,358
service time to breathe back up. And then you

274
00:17:12,364 --> 00:17:16,690
can try it again. And for the upstream direction,

275
00:17:16,770 --> 00:17:20,426
it's basically similar idea,

276
00:17:20,528 --> 00:17:24,714
similar principle. If a part of the system breaks, you shouldn't let

277
00:17:24,752 --> 00:17:27,260
that failure leak into the rest of the system.

278
00:17:27,790 --> 00:17:31,066
So there are practices called bulkheads, load shedding and

279
00:17:31,088 --> 00:17:35,002
weight limiting. So bulkheads, for example, compartmentalize your

280
00:17:35,056 --> 00:17:38,426
resources so that the failure doesn't leak to the other resources.

281
00:17:38,458 --> 00:17:41,966
Or if you have some issue like a high load that's eating up

282
00:17:41,988 --> 00:17:45,666
all your resources, you compartmentalize it so that it doesn't eat up

283
00:17:45,688 --> 00:17:49,518
all your resources that impact other parts of your system. So load shedding

284
00:17:49,534 --> 00:17:53,394
and rate limiting as well, they make sure

285
00:17:53,432 --> 00:17:56,470
your system performs still at a maximum capacity,

286
00:17:56,890 --> 00:18:00,134
even under high load. Doesn't let

287
00:18:00,172 --> 00:18:04,022
your system gets hammered, basically. So one thing

288
00:18:04,076 --> 00:18:07,654
that is really important I feel that I want to mention here is I think

289
00:18:07,692 --> 00:18:11,354
you should implement them in the beginning. You should implement them while you build

290
00:18:11,392 --> 00:18:15,114
your integrations, don't add them. I've seen practices of

291
00:18:15,312 --> 00:18:21,866
habits of adding these things while productifying the

292
00:18:21,888 --> 00:18:25,386
new implementation, one week before shipping, before releasing

293
00:18:25,418 --> 00:18:29,214
it. I think there's an anti pattern. You should add them

294
00:18:29,332 --> 00:18:32,414
as soon as you build the integration so that you can actually test them,

295
00:18:32,452 --> 00:18:35,758
you can tune them, you know, how they react,

296
00:18:35,854 --> 00:18:39,506
how the system reacts. Because sometimes these things are really hard

297
00:18:39,528 --> 00:18:43,266
to predict with the complexity increases in

298
00:18:43,288 --> 00:18:47,426
the bigger system. So you face the error scenarios, you face the tough situations

299
00:18:47,458 --> 00:18:50,120
again while building as early as possible.

300
00:18:52,090 --> 00:18:55,446
So the next things is testing. Of course it's great if you

301
00:18:55,468 --> 00:18:58,854
have a. I'm going to skip like test and pyramid how you write

302
00:18:58,892 --> 00:19:01,866
tests. I think we're going to approach a little more high level in terms of

303
00:19:01,888 --> 00:19:05,386
testing how you test your product. I think it's great if

304
00:19:05,408 --> 00:19:09,066
you have a staging and testing environment that you can ship to and you

305
00:19:09,088 --> 00:19:12,846
can, while building before you release it to your users, you can

306
00:19:12,868 --> 00:19:16,430
actually get feedback, you can actually see how your system behave.

307
00:19:16,850 --> 00:19:19,934
There are two things we need to consider. Make sure

308
00:19:19,972 --> 00:19:23,338
we cover here, load and diversity. Load, as we need

309
00:19:23,364 --> 00:19:27,598
to make sure we test our system with a load that it's

310
00:19:27,614 --> 00:19:31,298
going to see once we release it. Right? Because we need to face

311
00:19:31,384 --> 00:19:34,882
those scenarios before our users do.

312
00:19:35,016 --> 00:19:38,706
And the other one is diversity. Like, don't test your, if you're

313
00:19:38,738 --> 00:19:42,038
dog fooding, if you're testing your features yourself,

314
00:19:42,124 --> 00:19:45,782
don't test it with just one user. Try to create as much

315
00:19:45,836 --> 00:19:49,494
diverse scenarios as bit can represent real

316
00:19:49,532 --> 00:19:52,986
life. So one really good practice for this that

317
00:19:53,008 --> 00:19:56,774
you can apply is shadow releasing. Right. Shadow releasing means you release

318
00:19:56,822 --> 00:20:00,614
a feature. I think big tech does this all the time. You release a feature,

319
00:20:00,662 --> 00:20:04,650
but only a portion of your users without

320
00:20:04,720 --> 00:20:08,302
breaking, making those big glass man or without marketing about

321
00:20:08,356 --> 00:20:11,646
it. You just release it for a portion of your users so that

322
00:20:11,668 --> 00:20:15,486
you can get the most scenarios you can get, you can get the most feedback.

323
00:20:15,598 --> 00:20:18,706
Find out edge error cases. This is a

324
00:20:18,728 --> 00:20:22,862
really good way of testing that will give you load and most importantly

325
00:20:23,006 --> 00:20:26,182
diversity that you need to make sure your product is working

326
00:20:26,236 --> 00:20:30,280
well. So the next one is

327
00:20:31,450 --> 00:20:34,934
building for resilience. This is a really good heuristic. I want to put

328
00:20:35,052 --> 00:20:38,486
as much content as I can put in the

329
00:20:38,508 --> 00:20:41,546
slide actually, so maybe you can take a photo screenshot even.

330
00:20:41,648 --> 00:20:45,034
So, building for resilience, what does it mean? So I think it's a really good

331
00:20:45,072 --> 00:20:49,050
practice to map out possible problematic and error scenarios.

332
00:20:51,410 --> 00:20:55,038
For example, what those scenarios could be. For example, there could be

333
00:20:55,044 --> 00:20:58,702
a sudden increase in the ingress load. Your database may become

334
00:20:58,756 --> 00:21:02,222
bottlenecked. You should map this out and

335
00:21:02,356 --> 00:21:05,778
imagine how it would play out.

336
00:21:05,864 --> 00:21:09,730
Or for example, one of your downstream API calls, again,

337
00:21:09,800 --> 00:21:13,726
being that being threatened, what happens next? Or your cloud provider

338
00:21:13,758 --> 00:21:17,618
is having issues, your caching clusters unavailable. It's really crucial

339
00:21:17,714 --> 00:21:21,446
and super helpful to make the decision how

340
00:21:21,468 --> 00:21:25,318
to react to these before they actually happen. Instead of a

341
00:21:25,484 --> 00:21:30,374
Saturday night, 02:00 a.m. You should actually just

342
00:21:30,492 --> 00:21:34,054
one person on call woke up from the sleep making this decision

343
00:21:34,182 --> 00:21:37,974
as a team. You should make this decision before and then perhaps

344
00:21:38,022 --> 00:21:42,766
build the tools around it so that you

345
00:21:42,788 --> 00:21:46,526
can actually overcome these problems as best as

346
00:21:46,548 --> 00:21:49,630
possible and document this. Have a runbook.

347
00:21:51,730 --> 00:21:55,226
Other things I can mention about building for resilience of a good patterns is auto

348
00:21:55,258 --> 00:21:59,086
scaling warm up. So most infrastructure technologies, infrastructure providers

349
00:21:59,118 --> 00:22:02,306
support some kind of auto scaling. If you know how to do this, it could

350
00:22:02,328 --> 00:22:05,822
be really good, helpful, and if used consciously. And also warming

351
00:22:05,886 --> 00:22:09,426
up. Like for example, if you know, every Monday morning, or let's

352
00:22:09,458 --> 00:22:13,106
say every Saturday night, you have a huge load, you can actually warm

353
00:22:13,138 --> 00:22:16,406
up your infrastructure so that you

354
00:22:16,428 --> 00:22:20,186
can be resilient under high load. So the next two things I

355
00:22:20,208 --> 00:22:24,054
think are really important and we should be opting in for these concepts

356
00:22:24,102 --> 00:22:29,206
whenever we can. First of them is immutability, a concept that's

357
00:22:29,238 --> 00:22:33,502
been getting highly popular in the last ten years with data storages, with more

358
00:22:33,556 --> 00:22:37,790
data analytics and data processing work is

359
00:22:37,940 --> 00:22:41,230
getting higher, getting more popular, getting more frequent.

360
00:22:41,730 --> 00:22:45,646
So one important thing that immutability does is

361
00:22:45,748 --> 00:22:49,858
it let us reach right parts of our flow? Right? If part of your

362
00:22:49,944 --> 00:22:53,374
flow is immutable, if there's an error happen, if there's

363
00:22:53,422 --> 00:22:56,674
high load, et cetera. If there's an issue happen, you can just retry it on

364
00:22:56,712 --> 00:23:00,966
later and it gives you a lot of power to overcome issues

365
00:23:01,068 --> 00:23:04,486
when they happen, which most of the time it's not a matter of when,

366
00:23:04,588 --> 00:23:07,586
it's not a matter of if, it's a matter of when. The next one is

367
00:23:07,628 --> 00:23:11,494
compartmentalizing. So compartmentalizing let us deprioritize

368
00:23:11,542 --> 00:23:15,178
less important non time sensor tasks, for example.

369
00:23:15,344 --> 00:23:17,926
And the other thing is you can scale them separately.

370
00:23:18,118 --> 00:23:21,274
Like if for example, you're reading a message,

371
00:23:21,392 --> 00:23:25,120
like your system reads a message and then does some job with it.

372
00:23:26,370 --> 00:23:29,866
If you compartmentalize reading a message and those different jobs

373
00:23:29,898 --> 00:23:33,726
that you need to do, for example, notifying your users, maybe you

374
00:23:33,748 --> 00:23:37,122
can on a high load time that you need to send 50

375
00:23:37,176 --> 00:23:41,154
million notifications, you can just scale it separately without touching your whole app.

376
00:23:41,272 --> 00:23:44,754
It is really powerful. And the last one acquisition is ones

377
00:23:44,792 --> 00:23:48,790
time configuration management. These are more or less really

378
00:23:48,860 --> 00:23:52,274
well adopted and quite straightforward

379
00:23:52,322 --> 00:23:55,766
approach, but it really helps to be able to have a

380
00:23:55,788 --> 00:23:59,174
configuration management that

381
00:23:59,212 --> 00:24:03,254
your system can read without the need to deploy new code.

382
00:24:03,372 --> 00:24:07,382
Like for example, you can have kill switches, you can change your

383
00:24:07,436 --> 00:24:11,466
infrastructure, even you can number of replicas,

384
00:24:11,578 --> 00:24:15,098
or like you can change certain thresholds

385
00:24:15,194 --> 00:24:18,622
during runtime depending on how the environment of the system

386
00:24:18,676 --> 00:24:22,014
is, depending on your high load, low load, depending on

387
00:24:22,052 --> 00:24:25,442
if you have an issue or not. I think this is a really good

388
00:24:25,496 --> 00:24:28,340
tool during tough situations as well.

389
00:24:29,910 --> 00:24:33,522
So the next one is observability. I'm going to move myself just

390
00:24:33,576 --> 00:24:37,186
here. Perfect. So first thing

391
00:24:37,208 --> 00:24:40,962
about observability is added while you build it. This is really crucial.

392
00:24:41,026 --> 00:24:44,422
Again, don't add it while productifying your product in the last

393
00:24:44,476 --> 00:24:47,606
week, add it while you build it because it's really easy to miss.

394
00:24:47,708 --> 00:24:51,434
I think it's really straightforward to add it while you build it instead of

395
00:24:51,472 --> 00:24:55,398
being lazy, let's say with respect,

396
00:24:55,494 --> 00:24:58,842
instead of just adding it later. Because later in the last

397
00:24:58,976 --> 00:25:02,506
week, if you're trying to add some metrics of the flow that's

398
00:25:02,538 --> 00:25:06,126
been implemented a few months ago, it's really far more easier to

399
00:25:06,148 --> 00:25:11,102
miss things. And it's really painful to realize during an incident you

400
00:25:11,156 --> 00:25:14,910
miss a metric that you wish it was there.

401
00:25:14,980 --> 00:25:18,914
You can just go back and edit. So my first recommendation would be

402
00:25:18,952 --> 00:25:22,594
edit while you build. And I think the other thing

403
00:25:22,632 --> 00:25:25,538
is other good recommendation. I will have to start with the question.

404
00:25:25,704 --> 00:25:29,158
Start with the question and how do we know if our product is working well?

405
00:25:29,244 --> 00:25:32,934
Like what could be the data that shows us, prove us our

406
00:25:32,972 --> 00:25:36,486
product is working well, this could be, for example, a success rate of an

407
00:25:36,508 --> 00:25:39,926
API call is above this level. A response time p

408
00:25:39,948 --> 00:25:45,018
95. Response time for any given user request is below

409
00:25:45,104 --> 00:25:48,634
this level. A number of requests for per seconds around this bit could be things

410
00:25:48,672 --> 00:25:51,966
like this. You start with a question, but also know that you

411
00:25:51,988 --> 00:25:56,330
may not know all the questions that you need. So emit

412
00:25:56,410 --> 00:26:00,640
data generously, really generously. There are efficient libraries. I think

413
00:26:02,130 --> 00:26:04,914
this could be a good heuristic and start alerting from day one.

414
00:26:04,952 --> 00:26:08,034
Like start getting those alerts so that you can tune them,

415
00:26:08,072 --> 00:26:11,522
test them and know how to react them. And so

416
00:26:11,576 --> 00:26:15,378
this is a mode of system bit. I'm going

417
00:26:15,384 --> 00:26:19,142
to talk about modes of systems where systems behave differently under

418
00:26:19,196 --> 00:26:22,310
different environments. So I think it's really great

419
00:26:22,380 --> 00:26:25,654
we put our system in and sometimes those are really

420
00:26:25,852 --> 00:26:29,798
hard to predict because of the complexity that these systems contain.

421
00:26:29,894 --> 00:26:33,446
So it's really good to put our system under harsh conditions

422
00:26:33,558 --> 00:26:36,986
before those conditions happen when we're not expecting, right?

423
00:26:37,088 --> 00:26:39,500
So performance testing is great for this.

424
00:26:40,750 --> 00:26:44,750
Put your system under high load, high stress, so that

425
00:26:44,820 --> 00:26:48,558
you see how it behaves. And if the performance is something critical for you,

426
00:26:48,644 --> 00:26:51,918
start testing early. Put it as a gateway. Put it as a

427
00:26:51,924 --> 00:26:55,674
gateway so that you can make sure after every chances

428
00:26:55,732 --> 00:26:58,770
to your logic, to your infrastructure, you're not regressing. Right.

429
00:26:58,920 --> 00:27:02,594
And another superpower thing is that I cannot recommend enough

430
00:27:02,632 --> 00:27:05,970
is run game days like put your system under harsh conditions.

431
00:27:06,970 --> 00:27:10,898
If your club conditions, as your cloud provider is unreachable, your cache

432
00:27:10,914 --> 00:27:14,262
cluster is gone. So simulate these things so that you face

433
00:27:14,316 --> 00:27:18,040
it before they actually happen in real world.

434
00:27:18,510 --> 00:27:23,302
So let's recap. What have I said? I said, set your priorities clearly,

435
00:27:23,366 --> 00:27:26,694
broadcast them, make them known. Your architecture

436
00:27:26,742 --> 00:27:30,726
will evolve. Let's adopt evolutionary architecture. And a good heuristic

437
00:27:30,758 --> 00:27:34,610
is optimizing initially for less complexity. Have a walking

438
00:27:34,630 --> 00:27:38,366
skeleton from week one. Face tough task first, we need

439
00:27:38,388 --> 00:27:42,320
the secure integrations. They're important parts of our system.

440
00:27:43,170 --> 00:27:47,120
We should map out our incident scenarios. Create a run book

441
00:27:48,550 --> 00:27:52,094
with a detailed explanation of what to do during tough

442
00:27:52,142 --> 00:27:55,394
times, during problems. Build optimizing for

443
00:27:55,432 --> 00:27:58,786
resilience, immutability and compartmentalizing as our

444
00:27:58,808 --> 00:28:02,774
friends are our friends. Observability. We should have observability from

445
00:28:02,812 --> 00:28:05,894
day one and alerting as well included into this.

446
00:28:06,012 --> 00:28:09,638
And performance testing probably is a really good idea,

447
00:28:09,724 --> 00:28:13,670
even if performance is not a high, high critical priority of yours.

448
00:28:14,970 --> 00:28:18,182
Thank you so much. I tried to really go a bit fast.

449
00:28:18,236 --> 00:28:21,550
I may have skipped this bit. Feel free. Reach out to me in my email

450
00:28:21,620 --> 00:28:25,006
or via LinkedIn. I hope you enjoyed it.

451
00:28:25,028 --> 00:28:28,846
I hope you have got some stuff from out of this that

452
00:28:28,868 --> 00:28:32,590
you can help. You can apply to your day to day job. Really happy

453
00:28:32,660 --> 00:28:35,166
for the chance and hope to hear from you.

